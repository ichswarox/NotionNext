"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["themes_simple_components_ExampleRecentComments_js"],{

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARRAY_ITERATE_KEY: function() { return /* binding */ ARRAY_ITERATE_KEY; },\n/* harmony export */   EffectFlags: function() { return /* binding */ EffectFlags; },\n/* harmony export */   EffectScope: function() { return /* binding */ EffectScope; },\n/* harmony export */   ITERATE_KEY: function() { return /* binding */ ITERATE_KEY; },\n/* harmony export */   MAP_KEY_ITERATE_KEY: function() { return /* binding */ MAP_KEY_ITERATE_KEY; },\n/* harmony export */   ReactiveEffect: function() { return /* binding */ ReactiveEffect; },\n/* harmony export */   ReactiveFlags: function() { return /* binding */ ReactiveFlags; },\n/* harmony export */   TrackOpTypes: function() { return /* binding */ TrackOpTypes; },\n/* harmony export */   TriggerOpTypes: function() { return /* binding */ TriggerOpTypes; },\n/* harmony export */   WatchErrorCodes: function() { return /* binding */ WatchErrorCodes; },\n/* harmony export */   computed: function() { return /* binding */ computed; },\n/* harmony export */   customRef: function() { return /* binding */ customRef; },\n/* harmony export */   effect: function() { return /* binding */ effect; },\n/* harmony export */   effectScope: function() { return /* binding */ effectScope; },\n/* harmony export */   enableTracking: function() { return /* binding */ enableTracking; },\n/* harmony export */   getCurrentScope: function() { return /* binding */ getCurrentScope; },\n/* harmony export */   getCurrentWatcher: function() { return /* binding */ getCurrentWatcher; },\n/* harmony export */   isProxy: function() { return /* binding */ isProxy; },\n/* harmony export */   isReactive: function() { return /* binding */ isReactive; },\n/* harmony export */   isReadonly: function() { return /* binding */ isReadonly; },\n/* harmony export */   isRef: function() { return /* binding */ isRef; },\n/* harmony export */   isShallow: function() { return /* binding */ isShallow; },\n/* harmony export */   markRaw: function() { return /* binding */ markRaw; },\n/* harmony export */   onEffectCleanup: function() { return /* binding */ onEffectCleanup; },\n/* harmony export */   onScopeDispose: function() { return /* binding */ onScopeDispose; },\n/* harmony export */   onWatcherCleanup: function() { return /* binding */ onWatcherCleanup; },\n/* harmony export */   pauseTracking: function() { return /* binding */ pauseTracking; },\n/* harmony export */   proxyRefs: function() { return /* binding */ proxyRefs; },\n/* harmony export */   reactive: function() { return /* binding */ reactive; },\n/* harmony export */   reactiveReadArray: function() { return /* binding */ reactiveReadArray; },\n/* harmony export */   readonly: function() { return /* binding */ readonly; },\n/* harmony export */   ref: function() { return /* binding */ ref; },\n/* harmony export */   resetTracking: function() { return /* binding */ resetTracking; },\n/* harmony export */   shallowReactive: function() { return /* binding */ shallowReactive; },\n/* harmony export */   shallowReadArray: function() { return /* binding */ shallowReadArray; },\n/* harmony export */   shallowReadonly: function() { return /* binding */ shallowReadonly; },\n/* harmony export */   shallowRef: function() { return /* binding */ shallowRef; },\n/* harmony export */   stop: function() { return /* binding */ stop; },\n/* harmony export */   toRaw: function() { return /* binding */ toRaw; },\n/* harmony export */   toReactive: function() { return /* binding */ toReactive; },\n/* harmony export */   toReadonly: function() { return /* binding */ toReadonly; },\n/* harmony export */   toRef: function() { return /* binding */ toRef; },\n/* harmony export */   toRefs: function() { return /* binding */ toRefs; },\n/* harmony export */   toValue: function() { return /* binding */ toValue; },\n/* harmony export */   track: function() { return /* binding */ track; },\n/* harmony export */   traverse: function() { return /* binding */ traverse; },\n/* harmony export */   trigger: function() { return /* binding */ trigger; },\n/* harmony export */   triggerRef: function() { return /* binding */ triggerRef; },\n/* harmony export */   unref: function() { return /* binding */ unref; },\n/* harmony export */   watch: function() { return /* binding */ watch; }\n/* harmony export */ });\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (true) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if ( true && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= ~64;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if ( true && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= ~2;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= ~1;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= ~16;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  const dep = computed.dep;\n  computed.flags |= 2;\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= ~2;\n    return;\n  }\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= ~2;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if ( true && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= ~4;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if ( true && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    if (true) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if ( true && activeSub.onTrack) {\n      activeSub.onTrack(\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (true) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if ( true && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n   true ? \"Object iterate\" : 0\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n   true ? \"Map keys iterate\" : 0\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n   true ? \"Array iterate\" : 0\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (true) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {}\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (true) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {}\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);\n    const isArrayIndex = targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (true) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (true) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (true) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (true) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (true) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {\n    if (true) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(value, \"__v_skip\") && Object.isExtensible(value)) {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;\nconst toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (true) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {}\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (true) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {}\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (true) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {}\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if ( true && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {\n    return new GetterRefImpl(source);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (true) ;\n  }\n  get value() {\n    const link =  true ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : 0;\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (true) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if ( true && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if ( true && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n         true && warnInvalidSource(s);\n      }\n    });\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP;\n     true && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.remove)(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (true) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJNOztBQUUzTTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU0sU0FBUyxJQUF5QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUyxLQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsS0FBeUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlCQUF5QixvREFBTztBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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QUF5QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSxLQUFLLEVBRU47QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUF5QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sS0FBSyxFQUVOO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUF5QztBQUMvQztBQUNBO0FBQ0EsY0FBYyxvREFBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTLHVEQUFVO0FBQ3ZCO0FBQ0EsSUFBSSxTQUFTLHFEQUFRO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxTQUFTLDBEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcz84OWRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBAdnVlL3JlYWN0aXZpdHkgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgaGFzQ2hhbmdlZCwgZXh0ZW5kLCBpc0FycmF5LCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBpc01hcCwgaGFzT3duLCBpc09iamVjdCwgbWFrZU1hcCwgdG9SYXdUeXBlLCBjYXBpdGFsaXplLCBkZWYsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgaXNTZXQsIGlzUGxhaW5PYmplY3QsIE5PT1AsIHJlbW92ZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyB0aGUgZWZmZWN0IHNjb3BlLCBpbmNsdWRpbmcgYWxsIGNoaWxkIHNjb3BlcyBhbmQgZWZmZWN0cy5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGksIGw7XG4gICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICB9XG4gIHN0b3AoZnJvbVBhcmVudCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhbnVwcy5sZW5ndGggPSAwO1xuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NvcGVzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcbiAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcbn1cbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbn1cblxubGV0IGFjdGl2ZVN1YjtcbmNvbnN0IEVmZmVjdEZsYWdzID0ge1xuICBcIkFDVElWRVwiOiAxLFxuICBcIjFcIjogXCJBQ1RJVkVcIixcbiAgXCJSVU5OSU5HXCI6IDIsXG4gIFwiMlwiOiBcIlJVTk5JTkdcIixcbiAgXCJUUkFDS0lOR1wiOiA0LFxuICBcIjRcIjogXCJUUkFDS0lOR1wiLFxuICBcIk5PVElGSUVEXCI6IDgsXG4gIFwiOFwiOiBcIk5PVElGSUVEXCIsXG4gIFwiRElSVFlcIjogMTYsXG4gIFwiMTZcIjogXCJESVJUWVwiLFxuICBcIkFMTE9XX1JFQ1VSU0VcIjogMzIsXG4gIFwiMzJcIjogXCJBTExPV19SRUNVUlNFXCIsXG4gIFwiUEFVU0VEXCI6IDY0LFxuICBcIjY0XCI6IFwiUEFVU0VEXCJcbn07XG5jb25zdCBwYXVzZWRRdWV1ZUVmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IDEgfCA0O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXAgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSB2b2lkIDA7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlICYmIGFjdGl2ZUVmZmVjdFNjb3BlLmFjdGl2ZSkge1xuICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuZWZmZWN0cy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmZsYWdzIHw9IDY0O1xuICB9XG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICB0aGlzLmZsYWdzICY9IH42NDtcbiAgICAgIGlmIChwYXVzZWRRdWV1ZUVmZmVjdHMuaGFzKHRoaXMpKSB7XG4gICAgICAgIHBhdXNlZFF1ZXVlRWZmZWN0cy5kZWxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnkoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAyICYmICEodGhpcy5mbGFncyAmIDMyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0aGlzLmZsYWdzICYgOCkpIHtcbiAgICAgIGJhdGNoKHRoaXMpO1xuICAgIH1cbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH1cbiAgICB0aGlzLmZsYWdzIHw9IDI7XG4gICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcbiAgICBwcmVwYXJlRGVwcyh0aGlzKTtcbiAgICBjb25zdCBwcmV2RWZmZWN0ID0gYWN0aXZlU3ViO1xuICAgIGNvbnN0IHByZXZTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICAgIGFjdGl2ZVN1YiA9IHRoaXM7XG4gICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVTdWIgIT09IHRoaXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkFjdGl2ZSBlZmZlY3Qgd2FzIG5vdCByZXN0b3JlZCBjb3JyZWN0bHkgLSB0aGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbCBidWcuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNsZWFudXBEZXBzKHRoaXMpO1xuICAgICAgYWN0aXZlU3ViID0gcHJldkVmZmVjdDtcbiAgICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgICAgdGhpcy5mbGFncyAmPSB+MjtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDEpIHtcbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICAgICAgcmVtb3ZlU3ViKGxpbmspO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXBzID0gdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICB0aGlzLm9uU3RvcCAmJiB0aGlzLm9uU3RvcCgpO1xuICAgICAgdGhpcy5mbGFncyAmPSB+MTtcbiAgICB9XG4gIH1cbiAgdHJpZ2dlcigpIHtcbiAgICBpZiAodGhpcy5mbGFncyAmIDY0KSB7XG4gICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuYWRkKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVuSWZEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBydW5JZkRpcnR5KCkge1xuICAgIGlmIChpc0RpcnR5KHRoaXMpKSB7XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH1cbiAgfVxuICBnZXQgZGlydHkoKSB7XG4gICAgcmV0dXJuIGlzRGlydHkodGhpcyk7XG4gIH1cbn1cbmxldCBiYXRjaERlcHRoID0gMDtcbmxldCBiYXRjaGVkU3ViO1xubGV0IGJhdGNoZWRDb21wdXRlZDtcbmZ1bmN0aW9uIGJhdGNoKHN1YiwgaXNDb21wdXRlZCA9IGZhbHNlKSB7XG4gIHN1Yi5mbGFncyB8PSA4O1xuICBpZiAoaXNDb21wdXRlZCkge1xuICAgIHN1Yi5uZXh0ID0gYmF0Y2hlZENvbXB1dGVkO1xuICAgIGJhdGNoZWRDb21wdXRlZCA9IHN1YjtcbiAgICByZXR1cm47XG4gIH1cbiAgc3ViLm5leHQgPSBiYXRjaGVkU3ViO1xuICBiYXRjaGVkU3ViID0gc3ViO1xufVxuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgYmF0Y2hEZXB0aCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWJhdGNoRGVwdGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChiYXRjaGVkQ29tcHV0ZWQpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRDb21wdXRlZDtcbiAgICBiYXRjaGVkQ29tcHV0ZWQgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XG4gICAgICBlLm5leHQgPSB2b2lkIDA7XG4gICAgICBlLmZsYWdzICY9IH44O1xuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGxldCBlcnJvcjtcbiAgd2hpbGUgKGJhdGNoZWRTdWIpIHtcbiAgICBsZXQgZSA9IGJhdGNoZWRTdWI7XG4gICAgYmF0Y2hlZFN1YiA9IHZvaWQgMDtcbiAgICB3aGlsZSAoZSkge1xuICAgICAgY29uc3QgbmV4dCA9IGUubmV4dDtcbiAgICAgIGUubmV4dCA9IHZvaWQgMDtcbiAgICAgIGUuZmxhZ3MgJj0gfjg7XG4gICAgICBpZiAoZS5mbGFncyAmIDEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZS50cmlnZ2VyKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVEZXBzKHN1Yikge1xuICBmb3IgKGxldCBsaW5rID0gc3ViLmRlcHM7IGxpbms7IGxpbmsgPSBsaW5rLm5leHREZXApIHtcbiAgICBsaW5rLnZlcnNpb24gPSAtMTtcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gbGluay5kZXAuYWN0aXZlTGluaztcbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluaztcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cERlcHMoc3ViKSB7XG4gIGxldCBoZWFkO1xuICBsZXQgdGFpbCA9IHN1Yi5kZXBzVGFpbDtcbiAgbGV0IGxpbmsgPSB0YWlsO1xuICB3aGlsZSAobGluaykge1xuICAgIGNvbnN0IHByZXYgPSBsaW5rLnByZXZEZXA7XG4gICAgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGlmIChsaW5rID09PSB0YWlsKSB0YWlsID0gcHJldjtcbiAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIHJlbW92ZURlcChsaW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGxpbms7XG4gICAgfVxuICAgIGxpbmsuZGVwLmFjdGl2ZUxpbmsgPSBsaW5rLnByZXZBY3RpdmVMaW5rO1xuICAgIGxpbmsucHJldkFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gICAgbGluayA9IHByZXY7XG4gIH1cbiAgc3ViLmRlcHMgPSBoZWFkO1xuICBzdWIuZGVwc1RhaWwgPSB0YWlsO1xufVxuZnVuY3Rpb24gaXNEaXJ0eShzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgaWYgKGxpbmsuZGVwLnZlcnNpb24gIT09IGxpbmsudmVyc2lvbiB8fCBsaW5rLmRlcC5jb21wdXRlZCAmJiAocmVmcmVzaENvbXB1dGVkKGxpbmsuZGVwLmNvbXB1dGVkKSB8fCBsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHN1Yi5fZGlydHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWZyZXNoQ29tcHV0ZWQoY29tcHV0ZWQpIHtcbiAgaWYgKGNvbXB1dGVkLmZsYWdzICYgNCAmJiAhKGNvbXB1dGVkLmZsYWdzICYgMTYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmZsYWdzICY9IH4xNjtcbiAgaWYgKGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPT09IGdsb2JhbFZlcnNpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZ2xvYmFsVmVyc2lvbiA9IGdsb2JhbFZlcnNpb247XG4gIGNvbnN0IGRlcCA9IGNvbXB1dGVkLmRlcDtcbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcbiAgaWYgKGRlcC52ZXJzaW9uID4gMCAmJiAhY29tcHV0ZWQuaXNTU1IgJiYgY29tcHV0ZWQuZGVwcyAmJiAhaXNEaXJ0eShjb21wdXRlZCkpIHtcbiAgICBjb21wdXRlZC5mbGFncyAmPSB+MjtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcbiAgY29uc3QgcHJldlNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XG4gIGFjdGl2ZVN1YiA9IGNvbXB1dGVkO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG4gIHRyeSB7XG4gICAgcHJlcGFyZURlcHMoY29tcHV0ZWQpO1xuICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWQuZm4oY29tcHV0ZWQuX3ZhbHVlKTtcbiAgICBpZiAoZGVwLnZlcnNpb24gPT09IDAgfHwgaGFzQ2hhbmdlZCh2YWx1ZSwgY29tcHV0ZWQuX3ZhbHVlKSkge1xuICAgICAgY29tcHV0ZWQuX3ZhbHVlID0gdmFsdWU7XG4gICAgICBkZXAudmVyc2lvbisrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVwLnZlcnNpb24rKztcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlU3ViID0gcHJldlN1YjtcbiAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICBjbGVhbnVwRGVwcyhjb21wdXRlZCk7XG4gICAgY29tcHV0ZWQuZmxhZ3MgJj0gfjI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVN1YihsaW5rLCBzb2Z0ID0gZmFsc2UpIHtcbiAgY29uc3QgeyBkZXAsIHByZXZTdWIsIG5leHRTdWIgfSA9IGxpbms7XG4gIGlmIChwcmV2U3ViKSB7XG4gICAgcHJldlN1Yi5uZXh0U3ViID0gbmV4dFN1YjtcbiAgICBsaW5rLnByZXZTdWIgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHRTdWIpIHtcbiAgICBuZXh0U3ViLnByZXZTdWIgPSBwcmV2U3ViO1xuICAgIGxpbmsubmV4dFN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZXAuc3Vic0hlYWQgPT09IGxpbmspIHtcbiAgICBkZXAuc3Vic0hlYWQgPSBuZXh0U3ViO1xuICB9XG4gIGlmIChkZXAuc3VicyA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzID0gcHJldlN1YjtcbiAgICBpZiAoIXByZXZTdWIgJiYgZGVwLmNvbXB1dGVkKSB7XG4gICAgICBkZXAuY29tcHV0ZWQuZmxhZ3MgJj0gfjQ7XG4gICAgICBmb3IgKGxldCBsID0gZGVwLmNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgICAgcmVtb3ZlU3ViKGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXNvZnQgJiYgIS0tZGVwLnNjICYmIGRlcC5tYXApIHtcbiAgICBkZXAubWFwLmRlbGV0ZShkZXAua2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRGVwKGxpbmspIHtcbiAgY29uc3QgeyBwcmV2RGVwLCBuZXh0RGVwIH0gPSBsaW5rO1xuICBpZiAocHJldkRlcCkge1xuICAgIHByZXZEZXAubmV4dERlcCA9IG5leHREZXA7XG4gICAgbGluay5wcmV2RGVwID0gdm9pZCAwO1xuICB9XG4gIGlmIChuZXh0RGVwKSB7XG4gICAgbmV4dERlcC5wcmV2RGVwID0gcHJldkRlcDtcbiAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xuICBpZiAoZm4uZWZmZWN0IGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgfVxuICBjb25zdCBlID0gbmV3IFJlYWN0aXZlRWZmZWN0KGZuKTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQoZSwgb3B0aW9ucyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBlLnJ1bigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlLnN0b3AoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29uc3QgcnVubmVyID0gZS5ydW4uYmluZChlKTtcbiAgcnVubmVyLmVmZmVjdCA9IGU7XG4gIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBzaG91bGRUcmFjayA9IHRydWU7XG5jb25zdCB0cmFja1N0YWNrID0gW107XG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhY2tpbmcoKSB7XG4gIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xufVxuZnVuY3Rpb24gb25FZmZlY3RDbGVhbnVwKGZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSkge1xuICBpZiAoYWN0aXZlU3ViIGluc3RhbmNlb2YgUmVhY3RpdmVFZmZlY3QpIHtcbiAgICBhY3RpdmVTdWIuY2xlYW51cCA9IGZuO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25FZmZlY3RDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgZWZmZWN0IHRvIGFzc29jaWF0ZSB3aXRoLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGUpIHtcbiAgY29uc3QgeyBjbGVhbnVwIH0gPSBlO1xuICBlLmNsZWFudXAgPSB2b2lkIDA7XG4gIGlmIChjbGVhbnVwKSB7XG4gICAgY29uc3QgcHJldlN1YiA9IGFjdGl2ZVN1YjtcbiAgICBhY3RpdmVTdWIgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWN0aXZlU3ViID0gcHJldlN1YjtcbiAgICB9XG4gIH1cbn1cblxubGV0IGdsb2JhbFZlcnNpb24gPSAwO1xuY2xhc3MgTGluayB7XG4gIGNvbnN0cnVjdG9yKHN1YiwgZGVwKSB7XG4gICAgdGhpcy5zdWIgPSBzdWI7XG4gICAgdGhpcy5kZXAgPSBkZXA7XG4gICAgdGhpcy52ZXJzaW9uID0gZGVwLnZlcnNpb247XG4gICAgdGhpcy5uZXh0RGVwID0gdGhpcy5wcmV2RGVwID0gdGhpcy5uZXh0U3ViID0gdGhpcy5wcmV2U3ViID0gdGhpcy5wcmV2QWN0aXZlTGluayA9IHZvaWQgMDtcbiAgfVxufVxuY2xhc3MgRGVwIHtcbiAgY29uc3RydWN0b3IoY29tcHV0ZWQpIHtcbiAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBMaW5rIGJldHdlZW4gdGhpcyBkZXAgYW5kIHRoZSBjdXJyZW50IGFjdGl2ZSBlZmZlY3RcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogRG91Ymx5IGxpbmtlZCBsaXN0IHJlcHJlc2VudGluZyB0aGUgc3Vic2NyaWJpbmcgZWZmZWN0cyAodGFpbClcbiAgICAgKi9cbiAgICB0aGlzLnN1YnMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogRm9yIG9iamVjdCBwcm9wZXJ0eSBkZXBzIGNsZWFudXBcbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVyIGNvdW50ZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjID0gMDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5zdWJzSGVhZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgdHJhY2soZGVidWdJbmZvKSB7XG4gICAgaWYgKCFhY3RpdmVTdWIgfHwgIXNob3VsZFRyYWNrIHx8IGFjdGl2ZVN1YiA9PT0gdGhpcy5jb21wdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbGluayA9IHRoaXMuYWN0aXZlTGluaztcbiAgICBpZiAobGluayA9PT0gdm9pZCAwIHx8IGxpbmsuc3ViICE9PSBhY3RpdmVTdWIpIHtcbiAgICAgIGxpbmsgPSB0aGlzLmFjdGl2ZUxpbmsgPSBuZXcgTGluayhhY3RpdmVTdWIsIHRoaXMpO1xuICAgICAgaWYgKCFhY3RpdmVTdWIuZGVwcykge1xuICAgICAgICBhY3RpdmVTdWIuZGVwcyA9IGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rLnByZXZEZXAgPSBhY3RpdmVTdWIuZGVwc1RhaWw7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH1cbiAgICAgIGFkZFN1YihsaW5rKTtcbiAgICB9IGVsc2UgaWYgKGxpbmsudmVyc2lvbiA9PT0gLTEpIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGlmIChsaW5rLm5leHREZXApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxpbmsubmV4dERlcDtcbiAgICAgICAgbmV4dC5wcmV2RGVwID0gbGluay5wcmV2RGVwO1xuICAgICAgICBpZiAobGluay5wcmV2RGVwKSB7XG4gICAgICAgICAgbGluay5wcmV2RGVwLm5leHREZXAgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgbGluay5uZXh0RGVwID0gdm9pZCAwO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwubmV4dERlcCA9IGxpbms7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICAgIGlmIChhY3RpdmVTdWIuZGVwcyA9PT0gbGluaykge1xuICAgICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBhY3RpdmVTdWIub25UcmFjaykge1xuICAgICAgYWN0aXZlU3ViLm9uVHJhY2soXG4gICAgICAgIGV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZVN1YlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rO1xuICB9XG4gIHRyaWdnZXIoZGVidWdJbmZvKSB7XG4gICAgdGhpcy52ZXJzaW9uKys7XG4gICAgZ2xvYmFsVmVyc2lvbisrO1xuICAgIHRoaXMubm90aWZ5KGRlYnVnSW5mbyk7XG4gIH1cbiAgbm90aWZ5KGRlYnVnSW5mbykge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB0cnkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChsZXQgaGVhZCA9IHRoaXMuc3Vic0hlYWQ7IGhlYWQ7IGhlYWQgPSBoZWFkLm5leHRTdWIpIHtcbiAgICAgICAgICBpZiAoaGVhZC5zdWIub25UcmlnZ2VyICYmICEoaGVhZC5zdWIuZmxhZ3MgJiA4KSkge1xuICAgICAgICAgICAgaGVhZC5zdWIub25UcmlnZ2VyKFxuICAgICAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWZmZWN0OiBoZWFkLnN1YlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVidWdJbmZvXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5zdWJzOyBsaW5rOyBsaW5rID0gbGluay5wcmV2U3ViKSB7XG4gICAgICAgIGlmIChsaW5rLnN1Yi5ub3RpZnkoKSkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBsaW5rLnN1Yi5kZXAubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFN1YihsaW5rKSB7XG4gIGxpbmsuZGVwLnNjKys7XG4gIGlmIChsaW5rLnN1Yi5mbGFncyAmIDQpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IGxpbmsuZGVwLmNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCAmJiAhbGluay5kZXAuc3Vicykge1xuICAgICAgY29tcHV0ZWQuZmxhZ3MgfD0gNCB8IDE2O1xuICAgICAgZm9yIChsZXQgbCA9IGNvbXB1dGVkLmRlcHM7IGw7IGwgPSBsLm5leHREZXApIHtcbiAgICAgICAgYWRkU3ViKGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGFpbCA9IGxpbmsuZGVwLnN1YnM7XG4gICAgaWYgKGN1cnJlbnRUYWlsICE9PSBsaW5rKSB7XG4gICAgICBsaW5rLnByZXZTdWIgPSBjdXJyZW50VGFpbDtcbiAgICAgIGlmIChjdXJyZW50VGFpbCkgY3VycmVudFRhaWwubmV4dFN1YiA9IGxpbms7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGxpbmsuZGVwLnN1YnNIZWFkID09PSB2b2lkIDApIHtcbiAgICAgIGxpbmsuZGVwLnN1YnNIZWFkID0gbGluaztcbiAgICB9XG4gICAgbGluay5kZXAuc3VicyA9IGxpbms7XG4gIH1cbn1cbmNvbnN0IHRhcmdldE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk9iamVjdCBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiTWFwIGtleXMgaXRlcmF0ZVwiIDogXCJcIlxuKTtcbmNvbnN0IEFSUkFZX0lURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJBcnJheSBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZVN1Yikge1xuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIGRlcHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gbmV3IERlcCgpKTtcbiAgICAgIGRlcC5tYXAgPSBkZXBzTWFwO1xuICAgICAgZGVwLmtleSA9IGtleTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGRlcC50cmFjayh7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVwLnRyYWNrKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xuICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoIWRlcHNNYXApIHtcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJ1biA9IChkZXApID0+IHtcbiAgICBpZiAoZGVwKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBkZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIG9sZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGFydEJhdGNoKCk7XG4gIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICBkZXBzTWFwLmZvckVhY2gocnVuKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGNvbnN0IGlzQXJyYXlJbmRleCA9IHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSk7XG4gICAgaWYgKHRhcmdldElzQXJyYXkgJiYga2V5ID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgICAgZGVwc01hcC5mb3JFYWNoKChkZXAsIGtleTIpID0+IHtcbiAgICAgICAgaWYgKGtleTIgPT09IFwibGVuZ3RoXCIgfHwga2V5MiA9PT0gQVJSQVlfSVRFUkFURV9LRVkgfHwgIWlzU3ltYm9sKGtleTIpICYmIGtleTIgPj0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgcnVuKGRlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5ICE9PSB2b2lkIDAgfHwgZGVwc01hcC5oYXModm9pZCAwKSkge1xuICAgICAgICBydW4oZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChBUlJBWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlJbmRleCkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICBpZiAoIXRhcmdldElzQXJyYXkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmRCYXRjaCgpO1xufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gIGNvbnN0IGRlcE1hcCA9IHRhcmdldE1hcC5nZXQob2JqZWN0KTtcbiAgcmV0dXJuIGRlcE1hcCAmJiBkZXBNYXAuZ2V0KGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0aXZlUmVhZEFycmF5KGFycmF5KSB7XG4gIGNvbnN0IHJhdyA9IHRvUmF3KGFycmF5KTtcbiAgaWYgKHJhdyA9PT0gYXJyYXkpIHJldHVybiByYXc7XG4gIHRyYWNrKHJhdywgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGlzU2hhbGxvdyhhcnJheSkgPyByYXcgOiByYXcubWFwKHRvUmVhY3RpdmUpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRBcnJheShhcnIpIHtcbiAgdHJhY2soYXJyID0gdG9SYXcoYXJyKSwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgU3ltYm9sLml0ZXJhdG9yLCB0b1JlYWN0aXZlKTtcbiAgfSxcbiAgY29uY2F0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuY29uY2F0KFxuICAgICAgLi4uYXJncy5tYXAoKHgpID0+IGlzQXJyYXkoeCkgPyByZWFjdGl2ZVJlYWRBcnJheSh4KSA6IHgpXG4gICAgKTtcbiAgfSxcbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJlbnRyaWVzXCIsICh2YWx1ZSkgPT4ge1xuICAgICAgdmFsdWVbMV0gPSB0b1JlYWN0aXZlKHZhbHVlWzFdKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSxcbiAgZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJldmVyeVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaWx0ZXIoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaWx0ZXJcIiwgZm4sIHRoaXNBcmcsICh2KSA9PiB2Lm1hcCh0b1JlYWN0aXZlKSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRcIiwgZm4sIHRoaXNBcmcsIHRvUmVhY3RpdmUsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmRJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0XCIsIGZuLCB0aGlzQXJnLCB0b1JlYWN0aXZlLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdEluZGV4KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmluZExhc3RJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICAvLyBmbGF0LCBmbGF0TWFwIGNvdWxkIGJlbmVmaXQgZnJvbSBBUlJBWV9JVEVSQVRFIGJ1dCBhcmUgbm90IHN0cmFpZ2h0LWZvcndhcmQgdG8gaW1wbGVtZW50XG4gIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmb3JFYWNoXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGluY2x1ZGVzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJpbmNsdWRlc1wiLCBhcmdzKTtcbiAgfSxcbiAgaW5kZXhPZiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5kZXhPZlwiLCBhcmdzKTtcbiAgfSxcbiAgam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykuam9pbihzZXBhcmF0b3IpO1xuICB9LFxuICAvLyBrZXlzKCkgaXRlcmF0b3Igb25seSByZWFkcyBgbGVuZ3RoYCwgbm8gb3B0aW1pc2F0aW9uIHJlcXVpcmVkXG4gIGxhc3RJbmRleE9mKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gc2VhcmNoUHJveHkodGhpcywgXCJsYXN0SW5kZXhPZlwiLCBhcmdzKTtcbiAgfSxcbiAgbWFwKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwibWFwXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInBvcFwiKTtcbiAgfSxcbiAgcHVzaCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJwdXNoXCIsIGFyZ3MpO1xuICB9LFxuICByZWR1Y2UoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIFwicmVkdWNlXCIsIGZuLCBhcmdzKTtcbiAgfSxcbiAgcmVkdWNlUmlnaHQoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIFwicmVkdWNlUmlnaHRcIiwgZm4sIGFyZ3MpO1xuICB9LFxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInNoaWZ0XCIpO1xuICB9LFxuICAvLyBzbGljZSBjb3VsZCB1c2UgQVJSQVlfSVRFUkFURSBidXQgYWxzbyBzZWVtcyB0byBiZWcgZm9yIHJhbmdlIHRyYWNraW5nXG4gIHNvbWUoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJzb21lXCIsIGZuLCB0aGlzQXJnLCB2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIHNwbGljZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJzcGxpY2VcIiwgYXJncyk7XG4gIH0sXG4gIHRvUmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvUmV2ZXJzZWQoKTtcbiAgfSxcbiAgdG9Tb3J0ZWQoY29tcGFyZXIpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9Tb3J0ZWQoY29tcGFyZXIpO1xuICB9LFxuICB0b1NwbGljZWQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1NwbGljZWQoLi4uYXJncyk7XG4gIH0sXG4gIHVuc2hpZnQoLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwidW5zaGlmdFwiLCBhcmdzKTtcbiAgfSxcbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcInZhbHVlc1wiLCB0b1JlYWN0aXZlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGl0ZXJhdG9yKHNlbGYsIG1ldGhvZCwgd3JhcFZhbHVlKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGNvbnN0IGl0ZXIgPSBhcnJbbWV0aG9kXSgpO1xuICBpZiAoYXJyICE9PSBzZWxmICYmICFpc1NoYWxsb3coc2VsZikpIHtcbiAgICBpdGVyLl9uZXh0ID0gaXRlci5uZXh0O1xuICAgIGl0ZXIubmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXIuX25leHQoKTtcbiAgICAgIGlmIChyZXN1bHQudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gd3JhcFZhbHVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGl0ZXI7XG59XG5jb25zdCBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuZnVuY3Rpb24gYXBwbHkoc2VsZiwgbWV0aG9kLCBmbiwgdGhpc0FyZywgd3JhcHBlZFJldEZuLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGNvbnN0IG5lZWRzV3JhcCA9IGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpO1xuICBjb25zdCBtZXRob2RGbiA9IGFyclttZXRob2RdO1xuICBpZiAobWV0aG9kRm4gIT09IGFycmF5UHJvdG9bbWV0aG9kXSkge1xuICAgIGNvbnN0IHJlc3VsdDIgPSBtZXRob2RGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICByZXR1cm4gbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShyZXN1bHQyKSA6IHJlc3VsdDI7XG4gIH1cbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKG5lZWRzV3JhcCkge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDIpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG1ldGhvZEZuLmNhbGwoYXJyLCB3cmFwcGVkRm4sIHRoaXNBcmcpO1xuICByZXR1cm4gbmVlZHNXcmFwICYmIHdyYXBwZWRSZXRGbiA/IHdyYXBwZWRSZXRGbihyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlKHNlbGYsIG1ldGhvZCwgZm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKCFpc1NoYWxsb3coc2VsZikpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCB0b1JlYWN0aXZlKGl0ZW0pLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm4ubGVuZ3RoID4gMykge1xuICAgICAgd3JhcHBlZEZuID0gZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhY2MsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJbbWV0aG9kXSh3cmFwcGVkRm4sIC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gc2VhcmNoUHJveHkoc2VsZiwgbWV0aG9kLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHRvUmF3KHNlbGYpO1xuICB0cmFjayhhcnIsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIGNvbnN0IHJlcyA9IGFyclttZXRob2RdKC4uLmFyZ3MpO1xuICBpZiAoKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkgJiYgaXNQcm94eShhcmdzWzBdKSkge1xuICAgIGFyZ3NbMF0gPSB0b1JhdyhhcmdzWzBdKTtcbiAgICByZXR1cm4gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5vVHJhY2tpbmcoc2VsZiwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgcGF1c2VUcmFja2luZygpO1xuICBzdGFydEJhdGNoKCk7XG4gIGNvbnN0IHJlcyA9IHRvUmF3KHNlbGYpW21ldGhvZF0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVuZEJhdGNoKCk7XG4gIHJlc2V0VHJhY2tpbmcoKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKGtleSkgPT4ga2V5ICE9PSBcImFyZ3VtZW50c1wiICYmIGtleSAhPT0gXCJjYWxsZXJcIikubWFwKChrZXkpID0+IFN5bWJvbFtrZXldKS5maWx0ZXIoaXNTeW1ib2wpXG4pO1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gIGlmICghaXNTeW1ib2woa2V5KSkga2V5ID0gU3RyaW5nKGtleSk7XG4gIGNvbnN0IG9iaiA9IHRvUmF3KHRoaXMpO1xuICB0cmFjayhvYmosIFwiaGFzXCIsIGtleSk7XG4gIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcbn1cbmNsYXNzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihfaXNSZWFkb25seSA9IGZhbHNlLCBfaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9pc1JlYWRvbmx5ID0gX2lzUmVhZG9ubHk7XG4gICAgdGhpcy5faXNTaGFsbG93ID0gX2lzU2hhbGxvdztcbiAgfVxuICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSByZXR1cm4gdGFyZ2V0W1wiX192X3NraXBcIl07XG4gICAgY29uc3QgaXNSZWFkb25seTIgPSB0aGlzLl9pc1JlYWRvbmx5LCBpc1NoYWxsb3cyID0gdGhpcy5faXNTaGFsbG93O1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiKSB7XG4gICAgICByZXR1cm4gaXNTaGFsbG93MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIGlmIChyZWNlaXZlciA9PT0gKGlzUmVhZG9ubHkyID8gaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogaXNTaGFsbG93MiA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSB8fCAvLyByZWNlaXZlciBpcyBub3QgdGhlIHJlYWN0aXZlIHByb3h5LCBidXQgaGFzIHRoZSBzYW1lIHByb3RvdHlwZVxuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgcmVjZWl2ZXIgaXMgYSB1c2VyIHByb3h5IG9mIHRoZSByZWFjdGl2ZSBwcm94eVxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyZWNlaXZlcikpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICBsZXQgZm47XG4gICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiAoZm4gPSBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgcHJveHkgd3JhcHBpbmcgYSByZWYsIHJldHVybiBtZXRob2RzIHVzaW5nIHRoZSByYXcgcmVmXG4gICAgICAvLyBhcyByZWNlaXZlciBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2FsbCBgdG9SYXdgIG9uIHRoZSByZWYgaW4gYWxsXG4gICAgICAvLyBpdHMgY2xhc3MgbWV0aG9kc1xuICAgICAgaXNSZWYodGFyZ2V0KSA/IHRhcmdldCA6IHJlY2VpdmVyXG4gICAgKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICB9XG4gICAgaWYgKGlzU2hhbGxvdzIpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChpc1JlZihyZXMpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5jbGFzcyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKGZhbHNlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmICghdGhpcy5faXNTaGFsbG93KSB7XG4gICAgICBjb25zdCBpc09sZFZhbHVlUmVhZG9ubHkgPSBpc1JlYWRvbmx5KG9sZFZhbHVlKTtcbiAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzT2xkVmFsdWVSZWFkb25seSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGlzUmVmKHRhcmdldCkgPyB0YXJnZXQgOiByZWNlaXZlclxuICAgICk7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2soXG4gICAgICB0YXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9XG59XG5jbGFzcyBSZWFkb25seVJlYWN0aXZlSGFuZGxlciBleHRlbmRzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgICBzdXBlcih0cnVlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgbXV0YWJsZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKCk7XG5jb25zdCByZWFkb25seUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWFkb25seVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE11dGFibGVSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIodHJ1ZSk7XG5cbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG5jb25zdCBnZXRQcm90byA9ICh2KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHYpO1xuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5MiwgaXNTaGFsbG93Mikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xuICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSBcImtleXNcIiAmJiB0YXJnZXRJc01hcDtcbiAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdzIgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhcbiAgICAgIHJhd1RhcmdldCxcbiAgICAgIFwiaXRlcmF0ZVwiLFxuICAgICAgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgdmFsdWUsIGRvbmUgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XG4gICAgICB3YXJuKFxuICAgICAgICBgJHtjYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdG9SYXcodGhpcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0eXBlID09PSBcImNsZWFyXCIgPyB2b2lkIDAgOiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucyhyZWFkb25seSwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgICBpZiAoIXJlYWRvbmx5KSB7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIHJhd0tleSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgICAgIGNvbnN0IHdyYXAgPSBzaGFsbG93ID8gdG9TaGFsbG93IDogcmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgIGlmICghcmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQoa2V5LCByYXdLZXkpKSB7XG4gICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwgcmF3S2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG4gICAgfSxcbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgY29uc3Qgd3JhcCA9IHNoYWxsb3cgPyB0b1NoYWxsb3cgOiByZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgIXJlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGV4dGVuZChcbiAgICBpbnN0cnVtZW50YXRpb25zLFxuICAgIHJlYWRvbmx5ID8ge1xuICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiksXG4gICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIilcbiAgICB9IDoge1xuICAgICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgICAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwgdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmIChoYWRLZXkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICAgICAgY29uc3Qgb2xkVGFyZ2V0ID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGlzTWFwKHRhcmdldCkgPyBuZXcgTWFwKHRhcmdldCkgOiBuZXcgU2V0KHRhcmdldCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xuICAgICAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgICAgICB0cmlnZ2VyKFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgXCJjbGVhclwiLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gW1xuICAgIFwia2V5c1wiLFxuICAgIFwidmFsdWVzXCIsXG4gICAgXCJlbnRyaWVzXCIsXG4gICAgU3ltYm9sLml0ZXJhdG9yXG4gIF07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHJlYWRvbmx5LCBzaGFsbG93KTtcbiAgfSk7XG4gIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHkyLCBzaGFsbG93KSB7XG4gIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSBjcmVhdGVJbnN0cnVtZW50YXRpb25zKGlzUmVhZG9ubHkyLCBzaGFsbG93KTtcbiAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KFxuICAgICAgaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsXG4gICAgICBrZXksXG4gICAgICByZWNlaXZlclxuICAgICk7XG4gIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XG4gICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xuICAgIHdhcm4oXG4gICAgICBgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gIHN3aXRjaCAocmF3VHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwIC8qIElOVkFMSUQgKi87XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIl0gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpID8gMCAvKiBJTlZBTElEICovIDogdGFyZ2V0VHlwZU1hcCh0b1Jhd1R5cGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIG11dGFibGVIYW5kbGVycyxcbiAgICBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsXG4gICAgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgcmVhZG9ubHlIYW5kbGVycyxcbiAgICByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIHRydWUsXG4gICAgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seU1hcFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5MiwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgdmFsdWUgY2Fubm90IGJlIG1hZGUgJHtpc1JlYWRvbmx5MiA/IFwicmVhZG9ubHlcIiA6IFwicmVhY3RpdmVcIn06ICR7U3RyaW5nKFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIl0gJiYgIShpc1JlYWRvbmx5MiAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFjdGl2ZVwiXSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nUHJveHkgPSBwcm94eU1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKGV4aXN0aW5nUHJveHkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgfVxuICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICBpZiAodGFyZ2V0VHlwZSA9PT0gMCAvKiBJTlZBTElEICovKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShcbiAgICB0YXJnZXQsXG4gICAgdGFyZ2V0VHlwZSA9PT0gMiAvKiBDT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzXG4gICk7XG4gIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIl0pO1xuICB9XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCJdKTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIl0pO1xufVxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIl0pO1xufVxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyAhIXZhbHVlW1wiX192X3Jhd1wiXSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICBpZiAoIWhhc093bih2YWx1ZSwgXCJfX3Zfc2tpcFwiKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuXG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gIHJldHVybiByID8gcltcIl9fdl9pc1JlZlwiXSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xufVxuY2xhc3MgUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBpc1NoYWxsb3cyKSB7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBmYWxzZTtcbiAgICB0aGlzLl9yYXdWYWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmF3KHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZSA9IGlzU2hhbGxvdzIgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICAgIHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdID0gaXNTaGFsbG93MjtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICB0eXBlOiBcImdldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwLnRyYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3Jhd1ZhbHVlO1xuICAgIGNvbnN0IHVzZURpcmVjdFZhbHVlID0gdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gfHwgaXNTaGFsbG93KG5ld1ZhbHVlKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbHVlKTtcbiAgICBuZXdWYWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsdWUgOiB0b1JhdyhuZXdWYWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmVhY3RpdmUobmV3VmFsdWUpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgdGhpcy5kZXAudHJpZ2dlcih7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZjIpIHtcbiAgaWYgKHJlZjIuZGVwKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoe1xuICAgICAgICB0YXJnZXQ6IHJlZjIsXG4gICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgICAgICBuZXdWYWx1ZTogcmVmMi5fdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYyLmRlcC50cmlnZ2VyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bnJlZihyZWYyKSB7XG4gIHJldHVybiBpc1JlZihyZWYyKSA/IHJlZjIudmFsdWUgOiByZWYyO1xufVxuZnVuY3Rpb24gdG9WYWx1ZShzb3VyY2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZSgpIDogdW5yZWYoc291cmNlKTtcbn1cbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcbiAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiBrZXkgPT09IFwiX192X3Jhd1wiID8gdGFyZ2V0IDogdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSA/IG9iamVjdFdpdGhSZWZzIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZhY3RvcnkpIHtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgICBjb25zdCBkZXAgPSB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KGRlcC50cmFjay5iaW5kKGRlcCksIGRlcC50cmlnZ2VyLmJpbmQoZGVwKSk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgIHRoaXMuX3NldCA9IHNldDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0KCk7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICB9XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICB3YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgfVxuICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmV0W2tleV0gPSBwcm9wZXJ0eVRvUmVmKG9iamVjdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXksIF9kZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xuICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlID0gX2RlZmF1bHRWYWx1ZTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdmFsID09PSB2b2lkIDAgPyB0aGlzLl9kZWZhdWx0VmFsdWUgOiB2YWw7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICB9XG4gIGdldCBkZXAoKSB7XG4gICAgcmV0dXJuIGdldERlcEZyb21SZWFjdGl2ZSh0b1Jhdyh0aGlzLl9vYmplY3QpLCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgcmV0dXJuIGlzUmVmKHZhbCkgPyB2YWwgOiBuZXcgT2JqZWN0UmVmSW1wbChzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZm4sIHNldHRlciwgaXNTU1IpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAvLyBUT0RPIGlzb2xhdGVkRGVjbGFyYXRpb25zIFwiX192X2lzUmVhZG9ubHlcIlxuICAgIC8vIEEgY29tcHV0ZWQgaXMgYWxzbyBhIHN1YnNjcmliZXIgdGhhdCB0cmFja3Mgb3RoZXIgZGVwc1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxNjtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uIC0gMTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICB0aGlzLmVmZmVjdCA9IHRoaXM7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gIXNldHRlcjtcbiAgICB0aGlzLmlzU1NSID0gaXNTU1I7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIHRoaXMuZmxhZ3MgfD0gMTY7XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpICYmIC8vIGF2b2lkIGluZmluaXRlIHNlbGYgcmVjdXJzaW9uXG4gICAgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICBiYXRjaCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBsaW5rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHRoaXMuZGVwLnRyYWNrKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICBrZXk6IFwidmFsdWVcIlxuICAgIH0pIDogdGhpcy5kZXAudHJhY2soKTtcbiAgICByZWZyZXNoQ29tcHV0ZWQodGhpcyk7XG4gICAgaWYgKGxpbmspIHtcbiAgICAgIGxpbmsudmVyc2lvbiA9IHRoaXMuZGVwLnZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXIpIHtcbiAgICAgIHRoaXMuc2V0dGVyKG5ld1ZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXCJXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBzZXR0ZXI7XG4gIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcbiAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICB9XG4gIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc1NTUik7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICBjUmVmLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICBjUmVmLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgcmV0dXJuIGNSZWY7XG59XG5cbmNvbnN0IFRyYWNrT3BUeXBlcyA9IHtcbiAgXCJHRVRcIjogXCJnZXRcIixcbiAgXCJIQVNcIjogXCJoYXNcIixcbiAgXCJJVEVSQVRFXCI6IFwiaXRlcmF0ZVwiXG59O1xuY29uc3QgVHJpZ2dlck9wVHlwZXMgPSB7XG4gIFwiU0VUXCI6IFwic2V0XCIsXG4gIFwiQUREXCI6IFwiYWRkXCIsXG4gIFwiREVMRVRFXCI6IFwiZGVsZXRlXCIsXG4gIFwiQ0xFQVJcIjogXCJjbGVhclwiXG59O1xuY29uc3QgUmVhY3RpdmVGbGFncyA9IHtcbiAgXCJTS0lQXCI6IFwiX192X3NraXBcIixcbiAgXCJJU19SRUFDVElWRVwiOiBcIl9fdl9pc1JlYWN0aXZlXCIsXG4gIFwiSVNfUkVBRE9OTFlcIjogXCJfX3ZfaXNSZWFkb25seVwiLFxuICBcIklTX1NIQUxMT1dcIjogXCJfX3ZfaXNTaGFsbG93XCIsXG4gIFwiUkFXXCI6IFwiX192X3Jhd1wiLFxuICBcIklTX1JFRlwiOiBcIl9fdl9pc1JlZlwiXG59O1xuXG5jb25zdCBXYXRjaEVycm9yQ29kZXMgPSB7XG4gIFwiV0FUQ0hfR0VUVEVSXCI6IDIsXG4gIFwiMlwiOiBcIldBVENIX0dFVFRFUlwiLFxuICBcIldBVENIX0NBTExCQUNLXCI6IDMsXG4gIFwiM1wiOiBcIldBVENIX0NBTExCQUNLXCIsXG4gIFwiV0FUQ0hfQ0xFQU5VUFwiOiA0LFxuICBcIjRcIjogXCJXQVRDSF9DTEVBTlVQXCJcbn07XG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbmNvbnN0IGNsZWFudXBNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmxldCBhY3RpdmVXYXRjaGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFdhdGNoZXIoKSB7XG4gIHJldHVybiBhY3RpdmVXYXRjaGVyO1xufVxuZnVuY3Rpb24gb25XYXRjaGVyQ2xlYW51cChjbGVhbnVwRm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlLCBvd25lciA9IGFjdGl2ZVdhdGNoZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgbGV0IGNsZWFudXBzID0gY2xlYW51cE1hcC5nZXQob3duZXIpO1xuICAgIGlmICghY2xlYW51cHMpIGNsZWFudXBNYXAuc2V0KG93bmVyLCBjbGVhbnVwcyA9IFtdKTtcbiAgICBjbGVhbnVwcy5wdXNoKGNsZWFudXBGbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbldhdGNoZXJDbGVhbnVwKCkgd2FzIGNhbGxlZCB3aGVuIHRoZXJlIHdhcyBubyBhY3RpdmUgd2F0Y2hlciB0byBhc3NvY2lhdGUgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xuICBjb25zdCB7IGltbWVkaWF0ZSwgZGVlcCwgb25jZSwgc2NoZWR1bGVyLCBhdWdtZW50Sm9iLCBjYWxsIH0gPSBvcHRpb25zO1xuICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgKG9wdGlvbnMub25XYXJuIHx8IHdhcm4pKFxuICAgICAgYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLFxuICAgICAgcyxcbiAgICAgIGBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHJlYWN0aXZlR2V0dGVyID0gKHNvdXJjZTIpID0+IHtcbiAgICBpZiAoZGVlcCkgcmV0dXJuIHNvdXJjZTI7XG4gICAgaWYgKGlzU2hhbGxvdyhzb3VyY2UyKSB8fCBkZWVwID09PSBmYWxzZSB8fCBkZWVwID09PSAwKVxuICAgICAgcmV0dXJuIHRyYXZlcnNlKHNvdXJjZTIsIDEpO1xuICAgIHJldHVybiB0cmF2ZXJzZShzb3VyY2UyKTtcbiAgfTtcbiAgbGV0IGVmZmVjdDtcbiAgbGV0IGdldHRlcjtcbiAgbGV0IGNsZWFudXA7XG4gIGxldCBib3VuZENsZWFudXA7XG4gIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gcmVhY3RpdmVHZXR0ZXIoc291cmNlKTtcbiAgICBmb3JjZVRyaWdnZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKChzKSA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyhzKSk7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcCgocykgPT4ge1xuICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgIHJldHVybiByZWFjdGl2ZUdldHRlcihzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwocywgMikgOiBzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIGlmIChjYikge1xuICAgICAgZ2V0dGVyID0gY2FsbCA/ICgpID0+IGNhbGwoc291cmNlLCAyKSA6IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3QgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjYWxsID8gY2FsbChzb3VyY2UsIDMsIFtib3VuZENsZWFudXBdKSA6IHNvdXJjZShib3VuZENsZWFudXApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIgPSBOT09QO1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgfVxuICBpZiAoY2IgJiYgZGVlcCkge1xuICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgY29uc3QgZGVwdGggPSBkZWVwID09PSB0cnVlID8gSW5maW5pdHkgOiBkZWVwO1xuICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSwgZGVwdGgpO1xuICB9XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IHdhdGNoSGFuZGxlID0gKCkgPT4ge1xuICAgIGVmZmVjdC5zdG9wKCk7XG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgICAgcmVtb3ZlKHNjb3BlLmVmZmVjdHMsIGVmZmVjdCk7XG4gICAgfVxuICB9O1xuICBpZiAob25jZSAmJiBjYikge1xuICAgIGNvbnN0IF9jYiA9IGNiO1xuICAgIGNiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIF9jYiguLi5hcmdzKTtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfTtcbiAgfVxuICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpLmZpbGwoSU5JVElBTF9XQVRDSEVSX1ZBTFVFKSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgY29uc3Qgam9iID0gKGltbWVkaWF0ZUZpcnN0UnVuKSA9PiB7XG4gICAgaWYgKCEoZWZmZWN0LmZsYWdzICYgMSkgfHwgIWVmZmVjdC5kaXJ0eSAmJiAhaW1tZWRpYXRlRmlyc3RSdW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNiKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgIGlmIChkZWVwIHx8IGZvcmNlVHJpZ2dlciB8fCAoaXNNdWx0aVNvdXJjZSA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKSA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFdhdGNoZXIgPSBhY3RpdmVXYXRjaGVyO1xuICAgICAgICBhY3RpdmVXYXRjaGVyID0gZWZmZWN0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdm9pZCAwIDogaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gW10gOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgIGJvdW5kQ2xlYW51cFxuICAgICAgICAgIF07XG4gICAgICAgICAgY2FsbCA/IGNhbGwoY2IsIDMsIGFyZ3MpIDogKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY2IoLi4uYXJncylcbiAgICAgICAgICApO1xuICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGN1cnJlbnRXYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH07XG4gIGlmIChhdWdtZW50Sm9iKSB7XG4gICAgYXVnbWVudEpvYihqb2IpO1xuICB9XG4gIGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIpO1xuICBlZmZlY3Quc2NoZWR1bGVyID0gc2NoZWR1bGVyID8gKCkgPT4gc2NoZWR1bGVyKGpvYiwgZmFsc2UpIDogam9iO1xuICBib3VuZENsZWFudXAgPSAoZm4pID0+IG9uV2F0Y2hlckNsZWFudXAoZm4sIGZhbHNlLCBlZmZlY3QpO1xuICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KGVmZmVjdCk7XG4gICAgaWYgKGNsZWFudXBzKSB7XG4gICAgICBpZiAoY2FsbCkge1xuICAgICAgICBjYWxsKGNsZWFudXBzLCA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgY2xlYW51cDIgb2YgY2xlYW51cHMpIGNsZWFudXAyKCk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwTWFwLmRlbGV0ZShlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBlZmZlY3Qub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICBlZmZlY3Qub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgam9iKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NoZWR1bGVyKSB7XG4gICAgc2NoZWR1bGVyKGpvYi5iaW5kKG51bGwsIHRydWUpLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QucnVuKCk7XG4gIH1cbiAgd2F0Y2hIYW5kbGUucGF1c2UgPSBlZmZlY3QucGF1c2UuYmluZChlZmZlY3QpO1xuICB3YXRjaEhhbmRsZS5yZXN1bWUgPSBlZmZlY3QucmVzdW1lLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUuc3RvcCA9IHdhdGNoSGFuZGxlO1xuICByZXR1cm4gd2F0Y2hIYW5kbGU7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgZGVwdGggPSBJbmZpbml0eSwgc2Vlbikge1xuICBpZiAoZGVwdGggPD0gMCB8fCAhaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlW1wiX192X3NraXBcIl0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZWVuLmFkZCh2YWx1ZSk7XG4gIGRlcHRoLS07XG4gIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgZGVwdGgsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHRyYXZlcnNlKHYsIGRlcHRoLCBzZWVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyBBUlJBWV9JVEVSQVRFX0tFWSwgRWZmZWN0RmxhZ3MsIEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgTUFQX0tFWV9JVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIFJlYWN0aXZlRmxhZ3MsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIFdhdGNoRXJyb3JDb2RlcywgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uRWZmZWN0Q2xlYW51cCwgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWN0aXZlUmVhZEFycmF5LCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkQXJyYXksIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVhY3RpdmUsIHRvUmVhZG9ubHksIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmF2ZXJzZSwgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYsIHdhdGNoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n"));

/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTransition: function() { return /* binding */ BaseTransition; },\n/* harmony export */   BaseTransitionPropsValidators: function() { return /* binding */ BaseTransitionPropsValidators; },\n/* harmony export */   Comment: function() { return /* binding */ Comment; },\n/* harmony export */   DeprecationTypes: function() { return /* binding */ DeprecationTypes; },\n/* harmony export */   EffectScope: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },\n/* harmony export */   ErrorCodes: function() { return /* binding */ ErrorCodes; },\n/* harmony export */   ErrorTypeStrings: function() { return /* binding */ ErrorTypeStrings; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   KeepAlive: function() { return /* binding */ KeepAlive; },\n/* harmony export */   ReactiveEffect: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },\n/* harmony export */   Static: function() { return /* binding */ Static; },\n/* harmony export */   Suspense: function() { return /* binding */ Suspense; },\n/* harmony export */   Teleport: function() { return /* binding */ Teleport; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   TrackOpTypes: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes; },\n/* harmony export */   TriggerOpTypes: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes; },\n/* harmony export */   assertNumber: function() { return /* binding */ assertNumber; },\n/* harmony export */   callWithAsyncErrorHandling: function() { return /* binding */ callWithAsyncErrorHandling; },\n/* harmony export */   callWithErrorHandling: function() { return /* binding */ callWithErrorHandling; },\n/* harmony export */   camelize: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize; },\n/* harmony export */   capitalize: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize; },\n/* harmony export */   cloneVNode: function() { return /* binding */ cloneVNode; },\n/* harmony export */   compatUtils: function() { return /* binding */ compatUtils; },\n/* harmony export */   computed: function() { return /* binding */ computed; },\n/* harmony export */   createBlock: function() { return /* binding */ createBlock; },\n/* harmony export */   createCommentVNode: function() { return /* binding */ createCommentVNode; },\n/* harmony export */   createElementBlock: function() { return /* binding */ createElementBlock; },\n/* harmony export */   createElementVNode: function() { return /* binding */ createBaseVNode; },\n/* harmony export */   createHydrationRenderer: function() { return /* binding */ createHydrationRenderer; },\n/* harmony export */   createPropsRestProxy: function() { return /* binding */ createPropsRestProxy; },\n/* harmony export */   createRenderer: function() { return /* binding */ createRenderer; },\n/* harmony export */   createSlots: function() { return /* binding */ createSlots; },\n/* harmony export */   createStaticVNode: function() { return /* binding */ createStaticVNode; },\n/* harmony export */   createTextVNode: function() { return /* binding */ createTextVNode; },\n/* harmony export */   createVNode: function() { return /* binding */ createVNode; },\n/* harmony export */   customRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef; },\n/* harmony export */   defineAsyncComponent: function() { return /* binding */ defineAsyncComponent; },\n/* harmony export */   defineComponent: function() { return /* binding */ defineComponent; },\n/* harmony export */   defineEmits: function() { return /* binding */ defineEmits; },\n/* harmony export */   defineExpose: function() { return /* binding */ defineExpose; },\n/* harmony export */   defineModel: function() { return /* binding */ defineModel; },\n/* harmony export */   defineOptions: function() { return /* binding */ defineOptions; },\n/* harmony export */   defineProps: function() { return /* binding */ defineProps; },\n/* harmony export */   defineSlots: function() { return /* binding */ defineSlots; },\n/* harmony export */   devtools: function() { return /* binding */ devtools; },\n/* harmony export */   effect: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect; },\n/* harmony export */   effectScope: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope; },\n/* harmony export */   getCurrentInstance: function() { return /* binding */ getCurrentInstance; },\n/* harmony export */   getCurrentScope: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },\n/* harmony export */   getCurrentWatcher: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher; },\n/* harmony export */   getTransitionRawChildren: function() { return /* binding */ getTransitionRawChildren; },\n/* harmony export */   guardReactiveProps: function() { return /* binding */ guardReactiveProps; },\n/* harmony export */   h: function() { return /* binding */ h; },\n/* harmony export */   handleError: function() { return /* binding */ handleError; },\n/* harmony export */   hasInjectionContext: function() { return /* binding */ hasInjectionContext; },\n/* harmony export */   hydrateOnIdle: function() { return /* binding */ hydrateOnIdle; },\n/* harmony export */   hydrateOnInteraction: function() { return /* binding */ hydrateOnInteraction; },\n/* harmony export */   hydrateOnMediaQuery: function() { return /* binding */ hydrateOnMediaQuery; },\n/* harmony export */   hydrateOnVisible: function() { return /* binding */ hydrateOnVisible; },\n/* harmony export */   initCustomFormatter: function() { return /* binding */ initCustomFormatter; },\n/* harmony export */   inject: function() { return /* binding */ inject; },\n/* harmony export */   isMemoSame: function() { return /* binding */ isMemoSame; },\n/* harmony export */   isProxy: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy; },\n/* harmony export */   isReactive: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive; },\n/* harmony export */   isReadonly: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },\n/* harmony export */   isRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef; },\n/* harmony export */   isRuntimeOnly: function() { return /* binding */ isRuntimeOnly; },\n/* harmony export */   isShallow: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow; },\n/* harmony export */   isVNode: function() { return /* binding */ isVNode; },\n/* harmony export */   markRaw: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw; },\n/* harmony export */   mergeDefaults: function() { return /* binding */ mergeDefaults; },\n/* harmony export */   mergeModels: function() { return /* binding */ mergeModels; },\n/* harmony export */   mergeProps: function() { return /* binding */ mergeProps; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   normalizeClass: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass; },\n/* harmony export */   normalizeProps: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps; },\n/* harmony export */   normalizeStyle: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle; },\n/* harmony export */   onActivated: function() { return /* binding */ onActivated; },\n/* harmony export */   onBeforeMount: function() { return /* binding */ onBeforeMount; },\n/* harmony export */   onBeforeUnmount: function() { return /* binding */ onBeforeUnmount; },\n/* harmony export */   onBeforeUpdate: function() { return /* binding */ onBeforeUpdate; },\n/* harmony export */   onDeactivated: function() { return /* binding */ onDeactivated; },\n/* harmony export */   onErrorCaptured: function() { return /* binding */ onErrorCaptured; },\n/* harmony export */   onMounted: function() { return /* binding */ onMounted; },\n/* harmony export */   onRenderTracked: function() { return /* binding */ onRenderTracked; },\n/* harmony export */   onRenderTriggered: function() { return /* binding */ onRenderTriggered; },\n/* harmony export */   onScopeDispose: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },\n/* harmony export */   onServerPrefetch: function() { return /* binding */ onServerPrefetch; },\n/* harmony export */   onUnmounted: function() { return /* binding */ onUnmounted; },\n/* harmony export */   onUpdated: function() { return /* binding */ onUpdated; },\n/* harmony export */   onWatcherCleanup: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup; },\n/* harmony export */   openBlock: function() { return /* binding */ openBlock; },\n/* harmony export */   popScopeId: function() { return /* binding */ popScopeId; },\n/* harmony export */   provide: function() { return /* binding */ provide; },\n/* harmony export */   proxyRefs: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },\n/* harmony export */   pushScopeId: function() { return /* binding */ pushScopeId; },\n/* harmony export */   queuePostFlushCb: function() { return /* binding */ queuePostFlushCb; },\n/* harmony export */   reactive: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive; },\n/* harmony export */   readonly: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly; },\n/* harmony export */   ref: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   registerRuntimeCompiler: function() { return /* binding */ registerRuntimeCompiler; },\n/* harmony export */   renderList: function() { return /* binding */ renderList; },\n/* harmony export */   renderSlot: function() { return /* binding */ renderSlot; },\n/* harmony export */   resolveComponent: function() { return /* binding */ resolveComponent; },\n/* harmony export */   resolveDirective: function() { return /* binding */ resolveDirective; },\n/* harmony export */   resolveDynamicComponent: function() { return /* binding */ resolveDynamicComponent; },\n/* harmony export */   resolveFilter: function() { return /* binding */ resolveFilter; },\n/* harmony export */   resolveTransitionHooks: function() { return /* binding */ resolveTransitionHooks; },\n/* harmony export */   setBlockTracking: function() { return /* binding */ setBlockTracking; },\n/* harmony export */   setDevtoolsHook: function() { return /* binding */ setDevtoolsHook; },\n/* harmony export */   setTransitionHooks: function() { return /* binding */ setTransitionHooks; },\n/* harmony export */   shallowReactive: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },\n/* harmony export */   shallowReadonly: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },\n/* harmony export */   shallowRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },\n/* harmony export */   ssrContextKey: function() { return /* binding */ ssrContextKey; },\n/* harmony export */   ssrUtils: function() { return /* binding */ ssrUtils; },\n/* harmony export */   stop: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop; },\n/* harmony export */   toDisplayString: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString; },\n/* harmony export */   toHandlerKey: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey; },\n/* harmony export */   toHandlers: function() { return /* binding */ toHandlers; },\n/* harmony export */   toRaw: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw; },\n/* harmony export */   toRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef; },\n/* harmony export */   toRefs: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs; },\n/* harmony export */   toValue: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toValue; },\n/* harmony export */   transformVNodeArgs: function() { return /* binding */ transformVNodeArgs; },\n/* harmony export */   triggerRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },\n/* harmony export */   unref: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref; },\n/* harmony export */   useAttrs: function() { return /* binding */ useAttrs; },\n/* harmony export */   useId: function() { return /* binding */ useId; },\n/* harmony export */   useModel: function() { return /* binding */ useModel; },\n/* harmony export */   useSSRContext: function() { return /* binding */ useSSRContext; },\n/* harmony export */   useSlots: function() { return /* binding */ useSlots; },\n/* harmony export */   useTemplateRef: function() { return /* binding */ useTemplateRef; },\n/* harmony export */   useTransitionState: function() { return /* binding */ useTransitionState; },\n/* harmony export */   version: function() { return /* binding */ version; },\n/* harmony export */   warn: function() { return /* binding */ warn; },\n/* harmony export */   watch: function() { return /* binding */ watch; },\n/* harmony export */   watchEffect: function() { return /* binding */ watchEffect; },\n/* harmony export */   watchPostEffect: function() { return /* binding */ watchPostEffect; },\n/* harmony export */   watchSyncEffect: function() { return /* binding */ watchSyncEffect; },\n/* harmony export */   withAsyncContext: function() { return /* binding */ withAsyncContext; },\n/* harmony export */   withCtx: function() { return /* binding */ withCtx; },\n/* harmony export */   withDefaults: function() { return /* binding */ withDefaults; },\n/* harmony export */   withDirectives: function() { return /* binding */ withDirectives; },\n/* harmony export */   withMemo: function() { return /* binding */ withMemo; },\n/* harmony export */   withScopeId: function() { return /* binding */ withScopeId; }\n/* harmony export */ });\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n/**\n* @vue/runtime-core v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n\n\n\n\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nlet isWarning = false;\nfunction warn$1(msg, ...args) {\n  if (isWarning) return;\n  isWarning = true;\n  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(\n      appWarnHandler,\n      instance,\n      11,\n      [\n        // eslint-disable-next-line no-restricted-syntax\n        msg + args.map((a) => {\n          var _a, _b;\n          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);\n        }).join(\"\"),\n        instance && instance.proxy,\n        trace.map(\n          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\n        ).join(\"\\n\"),\n        trace\n      ]\n    );\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    if (trace.length && // avoid spamming console during tests\n    true) {\n      warnArgs.push(`\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n  isWarning = false;\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...i === 0 ? [] : [`\n`], ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(\n    vnode.component,\n    vnode.type,\n    isRoot\n  )}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach((key) => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\nfunction formatProp(key, value, raw) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {\n    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\nfunction assertNumber(val, type) {\n  if (false) {}\n  if (val === void 0) {\n    return;\n  } else if (typeof val !== \"number\") {\n    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    warn$1(`${type} is NaN - the duration expression might be incorrect.`);\n  }\n}\n\nconst ErrorCodes = {\n  \"SETUP_FUNCTION\": 0,\n  \"0\": \"SETUP_FUNCTION\",\n  \"RENDER_FUNCTION\": 1,\n  \"1\": \"RENDER_FUNCTION\",\n  \"NATIVE_EVENT_HANDLER\": 5,\n  \"5\": \"NATIVE_EVENT_HANDLER\",\n  \"COMPONENT_EVENT_HANDLER\": 6,\n  \"6\": \"COMPONENT_EVENT_HANDLER\",\n  \"VNODE_HOOK\": 7,\n  \"7\": \"VNODE_HOOK\",\n  \"DIRECTIVE_HOOK\": 8,\n  \"8\": \"DIRECTIVE_HOOK\",\n  \"TRANSITION_HOOK\": 9,\n  \"9\": \"TRANSITION_HOOK\",\n  \"APP_ERROR_HANDLER\": 10,\n  \"10\": \"APP_ERROR_HANDLER\",\n  \"APP_WARN_HANDLER\": 11,\n  \"11\": \"APP_WARN_HANDLER\",\n  \"FUNCTION_REF\": 12,\n  \"12\": \"FUNCTION_REF\",\n  \"ASYNC_COMPONENT_LOADER\": 13,\n  \"13\": \"ASYNC_COMPONENT_LOADER\",\n  \"SCHEDULER\": 14,\n  \"14\": \"SCHEDULER\",\n  \"COMPONENT_UPDATE\": 15,\n  \"15\": \"COMPONENT_UPDATE\",\n  \"APP_UNMOUNT_CLEANUP\": 16,\n  \"16\": \"APP_UNMOUNT_CLEANUP\"\n};\nconst ErrorTypeStrings$1 = {\n  [\"sp\"]: \"serverPrefetch hook\",\n  [\"bc\"]: \"beforeCreate hook\",\n  [\"c\"]: \"created hook\",\n  [\"bm\"]: \"beforeMount hook\",\n  [\"m\"]: \"mounted hook\",\n  [\"bu\"]: \"beforeUpdate hook\",\n  [\"u\"]: \"updated\",\n  [\"bum\"]: \"beforeUnmount hook\",\n  [\"um\"]: \"unmounted hook\",\n  [\"a\"]: \"activated hook\",\n  [\"da\"]: \"deactivated hook\",\n  [\"ec\"]: \"errorCaptured hook\",\n  [\"rtc\"]: \"renderTracked hook\",\n  [\"rtg\"]: \"renderTriggered hook\",\n  [0]: \"setup function\",\n  [1]: \"render function\",\n  [2]: \"watcher getter\",\n  [3]: \"watcher callback\",\n  [4]: \"watcher cleanup function\",\n  [5]: \"native event handler\",\n  [6]: \"component event handler\",\n  [7]: \"vnode hook\",\n  [8]: \"directive hook\",\n  [9]: \"transition hook\",\n  [10]: \"app errorHandler\",\n  [11]: \"app warnHandler\",\n  [12]: \"ref function\",\n  [13]: \"async component loader\",\n  [14]: \"scheduler flush\",\n  [15]: \"component update\",\n  [16]: \"app unmount cleanup function\"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  try {\n    return args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {\n      res.catch((err) => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {\n    const values = [];\n    for (let i = 0; i < fn.length; i++) {\n      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n    }\n    return values;\n  } else if (true) {\n    warn$1(\n      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`\n    );\n  }\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo =  true ? ErrorTypeStrings$1[type] : 0;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    if (errorHandler) {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n      callWithErrorHandling(errorHandler, null, 10, [\n        err,\n        exposedInstance,\n        errorInfo\n      ]);\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);\n}\nfunction logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {\n  if (true) {\n    const info = ErrorTypeStrings$1[type];\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (contextVNode) {\n      popWarningContext();\n    }\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {}\n}\n\nconst queue = [];\nlet flushIndex = -1;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */ Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJob = queue[middle];\n    const middleJobId = getId(middleJob);\n    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {\n      start = middle + 1;\n    } else {\n      end = middle;\n    }\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!(job.flags & 1)) {\n    const jobId = getId(job);\n    const lastJob = queue[queue.length - 1];\n    if (!lastJob || // fast path when the job id is larger than the tail\n    !(job.flags & 2) && jobId >= getId(lastJob)) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(jobId), 0, job);\n    }\n    job.flags |= 1;\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!currentFlushPromise) {\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {\n    if (activePostFlushCbs && cb.id === -1) {\n      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);\n    } else if (!(cb.flags & 1)) {\n      pendingPostFlushCbs.push(cb);\n      cb.flags |= 1;\n    }\n  } else {\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(instance, seen, i = flushIndex + 1) {\n  if (true) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.flags & 2) {\n      if (instance && cb.id !== instance.uid) {\n        continue;\n      }\n      if ( true && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      queue.splice(i, 1);\n      i--;\n      if (cb.flags & 4) {\n        cb.flags &= ~1;\n      }\n      cb();\n      if (!(cb.flags & 4)) {\n        cb.flags &= ~1;\n      }\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)].sort(\n      (a, b) => getId(a) - getId(b)\n    );\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (true) {\n      seen = seen || /* @__PURE__ */ new Map();\n    }\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      const cb = activePostFlushCbs[postFlushIndex];\n      if ( true && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      if (cb.flags & 4) {\n        cb.flags &= ~1;\n      }\n      if (!(cb.flags & 8)) cb();\n      cb.flags &= ~1;\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;\nfunction flushJobs(seen) {\n  if (true) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  const check =  true ? (job) => checkRecursiveUpdates(seen, job) : 0;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && !(job.flags & 8)) {\n        if ( true && check(job)) {\n          continue;\n        }\n        if (job.flags & 4) {\n          job.flags &= ~1;\n        }\n        callWithErrorHandling(\n          job,\n          job.i,\n          job.i ? 15 : 14\n        );\n        if (!(job.flags & 4)) {\n          job.flags &= ~1;\n        }\n      }\n    }\n  } finally {\n    for (; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job) {\n        job.flags &= ~1;\n      }\n    }\n    flushIndex = -1;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    currentFlushPromise = null;\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  const count = seen.get(fn) || 0;\n  if (count > RECURSION_LIMIT) {\n    const instance = fn.i;\n    const componentName = instance && getComponentName(instance.type);\n    handleError(\n      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,\n      null,\n      10\n    );\n    return true;\n  }\n  seen.set(fn, count + 1);\n  return false;\n}\n\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = /* @__PURE__ */ new Map();\nif (true) {\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  };\n}\nconst map = /* @__PURE__ */ new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: /* @__PURE__ */ new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  record.initialDef.render = newRender;\n  [...record.instances].forEach((instance) => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    isHmrUpdating = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return;\n  newComp = normalizeClassComponent(newComp);\n  updateComponentDef(record.initialDef, newComp);\n  const instances = [...record.instances];\n  for (let i = 0; i < instances.length; i++) {\n    const instance = instances[i];\n    const oldComp = normalizeClassComponent(instance.type);\n    let dirtyInstances = hmrDirtyComponents.get(oldComp);\n    if (!dirtyInstances) {\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());\n    }\n    dirtyInstances.add(instance);\n    instance.appContext.propsCache.delete(instance.type);\n    instance.appContext.emitsCache.delete(instance.type);\n    instance.appContext.optionsCache.delete(instance.type);\n    if (instance.ceReload) {\n      dirtyInstances.add(instance);\n      instance.ceReload(newComp.styles);\n      dirtyInstances.delete(instance);\n    } else if (instance.parent) {\n      queueJob(() => {\n        isHmrUpdating = true;\n        instance.parent.update();\n        isHmrUpdating = false;\n        dirtyInstances.delete(instance);\n      });\n    } else if (instance.appContext.reload) {\n      instance.appContext.reload();\n    } else if (typeof window !== \"undefined\") {\n      window.location.reload();\n    } else {\n      console.warn(\n        \"[HMR] Root or manually mounted instance modified. Full reload required.\"\n      );\n    }\n    if (instance.root.ce && instance !== instance.root) {\n      instance.root.ce._removeChildStyle(oldComp);\n    }\n  }\n  queuePostFlushCb(() => {\n    hmrDirtyComponents.clear();\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== \"__file\" && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(\n        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`\n      );\n    }\n  };\n}\n\nlet devtools$1;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n  if (devtools$1) {\n    devtools$1.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({ event, args });\n  }\n}\nfunction setDevtoolsHook$1(hook, target) {\n  var _a, _b;\n  devtools$1 = hook;\n  if (devtools$1) {\n    devtools$1.enabled = true;\n    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));\n    buffer = [];\n  } else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    typeof window !== \"undefined\" && // some envs mock window but not fully\n    window.HTMLElement && // also exclude jsdom\n    // eslint-disable-next-line no-restricted-syntax\n    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes(\"jsdom\"))\n  ) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push((newHook) => {\n      setDevtoolsHook$1(newHook, target);\n    });\n    setTimeout(() => {\n      if (!devtools$1) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nfunction devtoolsInitApp(app, version) {\n  emit$1(\"app:init\" /* APP_INIT */, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1(\"app:unmount\" /* APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\nconst devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(\n  \"component:removed\" /* COMPONENT_REMOVED */\n);\nconst devtoolsComponentRemoved = (component) => {\n  if (devtools$1 && typeof devtools$1.cleanupBuffer === \"function\" && // remove the component if it wasn't buffered\n  !devtools$1.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction createDevtoolsComponentHook(hook) {\n  return (component) => {\n    emit$1(\n      hook,\n      component.appContext.app,\n      component.uid,\n      component.parent ? component.parent.uid : void 0,\n      component\n    );\n  };\n}\nconst devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(\"perf:start\" /* PERFORMANCE_START */);\nconst devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(\"perf:end\" /* PERFORMANCE_END */);\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1(\n    \"component:emit\" /* COMPONENT_EMIT */,\n    component.appContext.app,\n    component,\n    event,\n    params\n  );\n}\n\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nfunction popScopeId() {\n  currentScopeId = null;\n}\nconst withScopeId = (_id) => withCtx;\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {\n  if (!ctx) return fn;\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if (true) {\n      devtoolsComponentUpdated(ctx);\n    }\n    return res;\n  };\n  renderFnWithContext._n = true;\n  renderFnWithContext._c = true;\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\n\nfunction validateDirectiveName(name) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {\n    warn$1(\"Do not use built-in directive ids as custom directive id: \" + name);\n  }\n}\nfunction withDirectives(vnode, directives) {\n  if (currentRenderingInstance === null) {\n     true && warn$1(`withDirectives can only be used inside render functions.`);\n    return vnode;\n  }\n  const instance = getComponentPublicInstance(currentRenderingInstance);\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.traverse)(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n      callWithAsyncErrorHandling(hook, instance, 8, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode\n      ]);\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n    }\n  }\n}\n\nconst TeleportEndKey = Symbol(\"_vte\");\nconst isTeleport = (type) => type.__isTeleport;\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \"\");\nconst isTeleportDeferred = (props) => props && (props.defer || props.defer === \"\");\nconst isTargetSVG = (target) => typeof SVGElement !== \"undefined\" && target instanceof SVGElement;\nconst isTargetMathML = (target) => typeof MathMLElement === \"function\" && target instanceof MathMLElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {\n    if (!select) {\n       true && warn$1(\n        `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`\n      );\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if ( true && !target && !isTeleportDisabled(props)) {\n        warn$1(\n          `Failed to locate Teleport target with selector \"${targetSelector}\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`\n        );\n      }\n      return target;\n    }\n  } else {\n    if ( true && !targetSelector && !isTeleportDisabled(props)) {\n      warn$1(`Invalid Teleport target: ${targetSelector}`);\n    }\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  name: \"Teleport\",\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: { insert, querySelector, createText, createComment }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let { shapeFlag, children, dynamicChildren } = n2;\n    if ( true && isHmrUpdating) {\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (n1 == null) {\n      const placeholder = n2.el =  true ? createComment(\"teleport start\") : 0;\n      const mainAnchor = n2.anchor =  true ? createComment(\"teleport end\") : 0;\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const mount = (container2, anchor2) => {\n        if (shapeFlag & 16) {\n          if (parentComponent && parentComponent.isCE) {\n            parentComponent.ce._teleportTarget = container2;\n          }\n          mountChildren(\n            children,\n            container2,\n            anchor2,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        }\n      };\n      const mountToTarget = () => {\n        const target = n2.target = resolveTarget(n2.props, querySelector);\n        const targetAnchor = prepareAnchor(target, n2, createText, insert);\n        if (target) {\n          if (namespace !== \"svg\" && isTargetSVG(target)) {\n            namespace = \"svg\";\n          } else if (namespace !== \"mathml\" && isTargetMathML(target)) {\n            namespace = \"mathml\";\n          }\n          if (!disabled) {\n            mount(target, targetAnchor);\n            updateCssVars(n2, false);\n          }\n        } else if ( true && !disabled) {\n          warn$1(\n            \"Invalid Teleport target on mount:\",\n            target,\n            `(${typeof target})`\n          );\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n        updateCssVars(n2, true);\n      }\n      if (isTeleportDeferred(n2.props)) {\n        queuePostRenderEffect(() => {\n          mountToTarget();\n          n2.el.__isMounted = true;\n        }, parentSuspense);\n      } else {\n        mountToTarget();\n      }\n    } else {\n      if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {\n        queuePostRenderEffect(() => {\n          TeleportImpl.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n          delete n1.el.__isMounted;\n        }, parentSuspense);\n        return;\n      }\n      n2.el = n1.el;\n      n2.targetStart = n1.targetStart;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      if (namespace === \"svg\" || isTargetSVG(target)) {\n        namespace = \"svg\";\n      } else if (namespace === \"mathml\" || isTargetMathML(target)) {\n        namespace = \"mathml\";\n      }\n      if (dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          currentContainer,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds\n        );\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(\n          n1,\n          n2,\n          currentContainer,\n          currentAnchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          false\n        );\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          moveTeleport(\n            n2,\n            container,\n            mainAnchor,\n            internals,\n            1\n          );\n        } else {\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\n            n2.props.to = n1.props.to;\n          }\n        }\n      } else {\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(\n            n2.props,\n            querySelector\n          );\n          if (nextTarget) {\n            moveTeleport(\n              n2,\n              nextTarget,\n              null,\n              internals,\n              0\n            );\n          } else if (true) {\n            warn$1(\n              \"Invalid Teleport target on update:\",\n              target,\n              `(${typeof target})`\n            );\n          }\n        } else if (wasDisabled) {\n          moveTeleport(\n            n2,\n            target,\n            targetAnchor,\n            internals,\n            1\n          );\n        }\n      }\n      updateCssVars(n2, disabled);\n    }\n  },\n  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {\n    const {\n      shapeFlag,\n      children,\n      anchor,\n      targetStart,\n      targetAnchor,\n      target,\n      props\n    } = vnode;\n    if (target) {\n      hostRemove(targetStart);\n      hostRemove(targetAnchor);\n    }\n    doRemove && hostRemove(anchor);\n    if (shapeFlag & 16) {\n      const shouldRemove = doRemove || !isTeleportDisabled(props);\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        unmount(\n          child,\n          parentComponent,\n          parentSuspense,\n          shouldRemove,\n          !!child.dynamicChildren\n        );\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {\n  if (moveType === 0) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const { el, anchor, shapeFlag, children, props } = vnode;\n  const isReorder = moveType === 2;\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  if (!isReorder || isTeleportDisabled(props)) {\n    if (shapeFlag & 16) {\n      for (let i = 0; i < children.length; i++) {\n        move(\n          children[i],\n          container,\n          parentAnchor,\n          2\n        );\n      }\n    }\n  }\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: { nextSibling, parentNode, querySelector, insert, createText }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(\n    vnode.props,\n    querySelector\n  );\n  if (target) {\n    const disabled = isTeleportDisabled(vnode.props);\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16) {\n      if (disabled) {\n        vnode.anchor = hydrateChildren(\n          nextSibling(node),\n          vnode,\n          parentNode(node),\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        vnode.targetStart = targetNode;\n        vnode.targetAnchor = targetNode && nextSibling(targetNode);\n      } else {\n        vnode.anchor = nextSibling(node);\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          if (targetAnchor && targetAnchor.nodeType === 8) {\n            if (targetAnchor.data === \"teleport start anchor\") {\n              vnode.targetStart = targetAnchor;\n            } else if (targetAnchor.data === \"teleport anchor\") {\n              vnode.targetAnchor = targetAnchor;\n              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n              break;\n            }\n          }\n          targetAnchor = nextSibling(targetAnchor);\n        }\n        if (!vnode.targetAnchor) {\n          prepareAnchor(target, vnode, createText, insert);\n        }\n        hydrateChildren(\n          targetNode && nextSibling(targetNode),\n          vnode,\n          target,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n    updateCssVars(vnode, disabled);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\nconst Teleport = TeleportImpl;\nfunction updateCssVars(vnode, isDisabled) {\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node, anchor;\n    if (isDisabled) {\n      node = vnode.el;\n      anchor = vnode.anchor;\n    } else {\n      node = vnode.targetStart;\n      anchor = vnode.targetAnchor;\n    }\n    while (node && node !== anchor) {\n      if (node.nodeType === 1) node.setAttribute(\"data-v-owner\", ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\nfunction prepareAnchor(target, vnode, createText, insert) {\n  const targetStart = vnode.targetStart = createText(\"\");\n  const targetAnchor = vnode.targetAnchor = createText(\"\");\n  targetStart[TeleportEndKey] = targetAnchor;\n  if (target) {\n    insert(targetStart, target);\n    insert(targetAnchor, target);\n  }\n  return targetAnchor;\n}\n\nconst leaveCbKey = Symbol(\"_leaveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: /* @__PURE__ */ new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionPropsValidators = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: TransitionHookValidator,\n  onEnter: TransitionHookValidator,\n  onAfterEnter: TransitionHookValidator,\n  onEnterCancelled: TransitionHookValidator,\n  // leave\n  onBeforeLeave: TransitionHookValidator,\n  onLeave: TransitionHookValidator,\n  onAfterLeave: TransitionHookValidator,\n  onLeaveCancelled: TransitionHookValidator,\n  // appear\n  onBeforeAppear: TransitionHookValidator,\n  onAppear: TransitionHookValidator,\n  onAfterAppear: TransitionHookValidator,\n  onAppearCancelled: TransitionHookValidator\n};\nconst recursiveGetSubtree = (instance) => {\n  const subTree = instance.subTree;\n  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;\n};\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: BaseTransitionPropsValidators,\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      const child = findNonCommentChild(children);\n      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n      const { mode } = rawProps;\n      if ( true && mode && mode !== \"in-out\" && mode !== \"out-in\" && mode !== \"default\") {\n        warn$1(`invalid <transition> mode: ${mode}`);\n      }\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      const innerChild = getInnerChild$1(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      let enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance,\n        // #11061, ensure enterHooks is fresh after clone\n        (hooks) => enterHooks = hooks\n      );\n      if (innerChild.type !== Comment) {\n        setTransitionHooks(innerChild, enterHooks);\n      }\n      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);\n      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {\n        let leavingHooks = resolveTransitionHooks(\n          oldInnerChild,\n          rawProps,\n          state,\n          instance\n        );\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        if (mode === \"out-in\" && innerChild.type !== Comment) {\n          state.isLeaving = true;\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            if (!(instance.job.flags & 8)) {\n              instance.update();\n            }\n            delete leavingHooks.afterLeave;\n            oldInnerChild = void 0;\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === \"in-out\" && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(\n              state,\n              oldInnerChild\n            );\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            el[leaveCbKey] = () => {\n              earlyRemove();\n              el[leaveCbKey] = void 0;\n              delete enterHooks.delayedLeave;\n              oldInnerChild = void 0;\n            };\n            enterHooks.delayedLeave = () => {\n              delayedLeave();\n              delete enterHooks.delayedLeave;\n              oldInnerChild = void 0;\n            };\n          };\n        } else {\n          oldInnerChild = void 0;\n        }\n      } else if (oldInnerChild) {\n        oldInnerChild = void 0;\n      }\n      return child;\n    };\n  }\n};\nfunction findNonCommentChild(children) {\n  let child = children[0];\n  if (children.length > 1) {\n    let hasFound = false;\n    for (const c of children) {\n      if (c.type !== Comment) {\n        if ( true && hasFound) {\n          warn$1(\n            \"<transition> can only be used on a single element or component. Use <transition-group> for lists.\"\n          );\n          break;\n        }\n        child = c;\n        hasFound = true;\n        if (false) {}\n      }\n    }\n  }\n  return child;\n}\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const { leavingVNodes } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = /* @__PURE__ */ Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\nfunction resolveTransitionHooks(vnode, props, state, instance, postClone) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(\n      hook,\n      instance,\n      9,\n      args\n    );\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\n      if (hook.every((hook2) => hook2.length <= 1)) done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      if (el[leaveCbKey]) {\n        el[leaveCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {\n        leavingVNode.el[leaveCbKey]();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el[enterCbKey] = (cancelled) => {\n        if (called) return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el[enterCbKey] = void 0;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key2 = String(vnode.key);\n      if (el[enterCbKey]) {\n        el[enterCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el[leaveCbKey] = (cancelled) => {\n        if (called) return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el[leaveCbKey] = void 0;\n        if (leavingVNodesCache[key2] === vnode) {\n          delete leavingVNodesCache[key2];\n        }\n      };\n      leavingVNodesCache[key2] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode2) {\n      const hooks2 = resolveTransitionHooks(\n        vnode2,\n        props,\n        state,\n        instance,\n        postClone\n      );\n      if (postClone) postClone(hooks2);\n      return hooks2;\n    }\n  };\n  return hooks;\n}\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getInnerChild$1(vnode) {\n  if (!isKeepAlive(vnode)) {\n    if (isTeleport(vnode.type) && vnode.children) {\n      return findNonCommentChild(vnode.children);\n    }\n    return vnode;\n  }\n  if ( true && vnode.component) {\n    return vnode.component.subTree;\n  }\n  const { shapeFlag, children } = vnode;\n  if (children) {\n    if (shapeFlag & 16) {\n      return children[0];\n    }\n    if (shapeFlag & 32 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children.default)) {\n      return children.default();\n    }\n  }\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 && vnode.component) {\n    vnode.transition = hooks;\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128) keyedFragmentCount++;\n      ret = ret.concat(\n        getTransitionRawChildren(child.children, keepComment, key)\n      );\n    } else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, { key }) : child);\n    }\n  }\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2;\n    }\n  }\n  return ret;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineComponent(options, extraOptions) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? (\n    // #8236: extend call and options.name access are considered side-effects\n    // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n    /* @__PURE__ */ (() => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ name: options.name }, extraOptions, { setup: options }))()\n  ) : options;\n}\n\nfunction useId() {\n  const i = getCurrentInstance();\n  if (i) {\n    return (i.appContext.config.idPrefix || \"v\") + \"-\" + i.ids[0] + i.ids[1]++;\n  } else if (true) {\n    warn$1(\n      `useId() is called when there is no active component instance to be associated with.`\n    );\n  }\n  return \"\";\n}\nfunction markAsyncBoundary(instance) {\n  instance.ids = [instance.ids[0] + instance.ids[2]++ + \"-\", 0, 0];\n}\n\nconst knownTemplateRefs = /* @__PURE__ */ new WeakSet();\nfunction useTemplateRef(key) {\n  const i = getCurrentInstance();\n  const r = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(null);\n  if (i) {\n    const refs = i.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? i.refs = {} : i.refs;\n    let desc;\n    if ( true && (desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) {\n      warn$1(`useTemplateRef('${key}') already exists.`);\n    } else {\n      Object.defineProperty(refs, key, {\n        enumerable: true,\n        get: () => r.value,\n        set: (val) => r.value = val\n      });\n    }\n  } else if (true) {\n    warn$1(\n      `useTemplateRef() is called when there is no active component instance to be associated with.`\n    );\n  }\n  const ret =  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly)(r) : 0;\n  if (true) {\n    knownTemplateRefs.add(ret);\n  }\n  return ret;\n}\n\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {\n    rawRef.forEach(\n      (r, i) => setRef(\n        r,\n        oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef),\n        parentSuspense,\n        vnode,\n        isUnmount\n      )\n    );\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {\n      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);\n    }\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const { i: owner, r: ref } = rawRef;\n  if ( true && !owner) {\n    warn$1(\n      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`\n    );\n    return;\n  }\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  const rawSetupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState);\n  const canSetSetupRef = setupState === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? () => false : (key) => {\n    if (true) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawSetupState, key) && !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(rawSetupState[key])) {\n        warn$1(\n          `Template ref \"${key}\" used on a non-ref value. It will not work in the production build.`\n        );\n      }\n      if (knownTemplateRefs.has(rawSetupState[key])) {\n        return false;\n      }\n    }\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawSetupState, key);\n  };\n  if (oldRef != null && oldRef !== ref) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {\n      refs[oldRef] = null;\n      if (canSetSetupRef(oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {\n    callWithErrorHandling(ref, owner, 12, [value, refs]);\n  } else {\n    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);\n    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);\n          } else {\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if (canSetSetupRef(ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k) refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if (canSetSetupRef(ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k) refs[rawRef.k] = value;\n        } else if (true) {\n          warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n        }\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    } else if (true) {\n      warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n    }\n  }\n}\n\nlet hasLoggedMismatchError = false;\nconst logMismatchError = () => {\n  if (hasLoggedMismatchError) {\n    return;\n  }\n  console.error(\"Hydration completed but contains mismatches.\");\n  hasLoggedMismatchError = true;\n};\nconst isSVGContainer = (container) => container.namespaceURI.includes(\"svg\") && container.tagName !== \"foreignObject\";\nconst isMathMLContainer = (container) => container.namespaceURI.includes(\"MathML\");\nconst getContainerType = (container) => {\n  if (container.nodeType !== 1) return void 0;\n  if (isSVGContainer(container)) return \"svg\";\n  if (isMathMLContainer(container)) return \"mathml\";\n  return void 0;\n};\nconst isComment = (node) => node.nodeType === 8;\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n      ( true) && warn$1(\n        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`\n      );\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const isFragmentStart = isComment(node) && node.data === \"[\";\n    const onMismatch = () => handleMismatch(\n      node,\n      vnode,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      isFragmentStart\n    );\n    const { type, ref, shapeFlag, patchFlag } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (true) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(node, \"__vnode\", vnode, true);\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(node, \"__vueParentComponent\", parentComponent, true);\n    }\n    if (patchFlag === -2) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3) {\n          if (vnode.children === \"\") {\n            insert(vnode.el = createText(\"\"), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            ( true) && warn$1(\n              `Hydration text mismatch in`,\n              node.parentNode,\n              `\n  - rendered on server: ${JSON.stringify(\n                node.data\n              )}\n  - expected on client: ${JSON.stringify(vnode.children)}`\n            );\n            logMismatchError();\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (isTemplateNode(node)) {\n          nextNode = nextSibling(node);\n          replaceNode(\n            vnode.el = node.content.firstChild,\n            node,\n            parentComponent\n          );\n        } else if (domType !== 8 || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 || domType === 3) {\n          nextNode = node;\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent)\n              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            slotScopeIds,\n            optimized\n          );\n        }\n        break;\n      default:\n        if (shapeFlag & 1) {\n          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized\n            );\n          }\n        } else if (shapeFlag & 6) {\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          if (isFragmentStart) {\n            nextNode = locateClosingAnchor(node);\n          } else if (isComment(node) && node.data === \"teleport start\") {\n            nextNode = locateClosingAnchor(node, node.data, \"teleport end\");\n          } else {\n            nextNode = nextSibling(node);\n          }\n          mountComponent(\n            vnode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            getContainerType(container),\n            optimized\n          );\n          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode(\"\") : createVNode(\"div\");\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64) {\n          if (domType !== 8) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized,\n              rendererInternals,\n              hydrateChildren\n            );\n          }\n        } else if (shapeFlag & 128) {\n          nextNode = vnode.type.hydrate(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            getContainerType(parentNode(node)),\n            slotScopeIds,\n            optimized,\n            rendererInternals,\n            hydrateNode\n          );\n        } else if (true) {\n          warn$1(\"Invalid HostVNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;\n    const forcePatch = type === \"input\" || type === \"option\";\n    if (true) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n      }\n      let needCallTransitionHooks = false;\n      if (isTemplateNode(el)) {\n        needCallTransitionHooks = needTransition(\n          null,\n          // no need check parentSuspense in hydration\n          transition\n        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;\n        const content = el.content.firstChild;\n        if (needCallTransitionHooks) {\n          transition.beforeEnter(content);\n        }\n        replaceNode(content, el, parentComponent);\n        vnode.el = el = content;\n      }\n      if (shapeFlag & 16 && // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(\n          el.firstChild,\n          vnode,\n          el,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        let hasWarned = false;\n        while (next) {\n          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {\n            if (( true) && !hasWarned) {\n              warn$1(\n                `Hydration children mismatch on`,\n                el,\n                `\nServer rendered element contains more child nodes than client vdom.`\n              );\n              hasWarned = true;\n            }\n            logMismatchError();\n          }\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8) {\n        let clientText = vnode.children;\n        if (clientText[0] === \"\\n\" && (el.tagName === \"PRE\" || el.tagName === \"TEXTAREA\")) {\n          clientText = clientText.slice(1);\n        }\n        if (el.textContent !== clientText) {\n          if (!isMismatchAllowed(el, 0 /* TEXT */)) {\n            ( true) && warn$1(\n              `Hydration text content mismatch on`,\n              el,\n              `\n  - rendered on server: ${el.textContent}\n  - expected on client: ${vnode.children}`\n            );\n            logMismatchError();\n          }\n          el.textContent = vnode.children;\n        }\n      }\n      if (props) {\n        if (true) {\n          const isCustomElement = el.tagName.includes(\"-\");\n          for (const key in props) {\n            if (( true) && // #11189 skip if this node has directives that have created hooks\n            // as it could have mutated the DOM in any possible way\n            !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {\n              logMismatchError();\n            }\n            if (forcePatch && (key.endsWith(\"value\") || key === \"indeterminate\") || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) || // force hydrate v-bind with .prop modifiers\n            key[0] === \".\" || isCustomElement) {\n              patchProp(el, key, null, props[key], void 0, parentComponent);\n            }\n          }\n        } else {}\n      }\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          needCallTransitionHooks && transition.enter(el);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n        }, parentSuspense);\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      const isText = vnode.type === Text;\n      if (node) {\n        if (isText && !optimized) {\n          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {\n            insert(\n              createText(\n                node.data.slice(vnode.children.length)\n              ),\n              container,\n              nextSibling(node)\n            );\n            node.data = vnode.children;\n          }\n        }\n        node = hydrateNode(\n          node,\n          vnode,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      } else if (isText && !vnode.children) {\n        insert(vnode.el = createText(\"\"), container);\n      } else {\n        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {\n          if (( true) && !hasWarned) {\n            warn$1(\n              `Hydration children mismatch on`,\n              container,\n              `\nServer rendered element contains fewer child nodes than client vdom.`\n            );\n            hasWarned = true;\n          }\n          logMismatchError();\n        }\n        patch(\n          null,\n          vnode,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          getContainerType(container),\n          slotScopeIds\n        );\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const { slotScopeIds: fragmentSlotScopeIds } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(\n      nextSibling(node),\n      vnode,\n      container,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      optimized\n    );\n    if (next && isComment(next) && next.data === \"]\") {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      logMismatchError();\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {\n      ( true) && warn$1(\n        `Hydration node mismatch:\n- rendered on server:`,\n        node,\n        node.nodeType === 3 ? `(text)` : isComment(node) && node.data === \"[\" ? `(start of fragment)` : ``,\n        `\n- expected on client:`,\n        vnode.type\n      );\n      logMismatchError();\n    }\n    vnode.el = null;\n    if (isFragment) {\n      const end = locateClosingAnchor(node);\n      while (true) {\n        const next2 = nextSibling(node);\n        if (next2 && next2 !== end) {\n          remove(next2);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(\n      null,\n      vnode,\n      container,\n      next,\n      parentComponent,\n      parentSuspense,\n      getContainerType(container),\n      slotScopeIds\n    );\n    if (parentComponent) {\n      parentComponent.vnode.el = vnode.el;\n      updateHOCHostEl(parentComponent, vnode.el);\n    }\n    return next;\n  };\n  const locateClosingAnchor = (node, open = \"[\", close = \"]\") => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === open) match++;\n        if (node.data === close) {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  const replaceNode = (newNode, oldNode, parentComponent) => {\n    const parentNode2 = oldNode.parentNode;\n    if (parentNode2) {\n      parentNode2.replaceChild(newNode, oldNode);\n    }\n    let parent = parentComponent;\n    while (parent) {\n      if (parent.vnode.el === oldNode) {\n        parent.vnode.el = parent.subTree.el = newNode;\n      }\n      parent = parent.parent;\n    }\n  };\n  const isTemplateNode = (node) => {\n    return node.nodeType === 1 && node.tagName === \"TEMPLATE\";\n  };\n  return [hydrate, hydrateNode];\n}\nfunction propHasMismatch(el, key, clientValue, vnode, instance) {\n  let mismatchType;\n  let mismatchKey;\n  let actual;\n  let expected;\n  if (key === \"class\") {\n    actual = el.getAttribute(\"class\");\n    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(clientValue);\n    if (!isSetEqual(toClassSet(actual || \"\"), toClassSet(expected))) {\n      mismatchType = 2 /* CLASS */;\n      mismatchKey = `class`;\n    }\n  } else if (key === \"style\") {\n    actual = el.getAttribute(\"style\") || \"\";\n    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(clientValue) ? clientValue : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.stringifyStyle)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(clientValue));\n    const actualMap = toStyleMap(actual);\n    const expectedMap = toStyleMap(expected);\n    if (vnode.dirs) {\n      for (const { dir, value } of vnode.dirs) {\n        if (dir.name === \"show\" && !value) {\n          expectedMap.set(\"display\", \"none\");\n        }\n      }\n    }\n    if (instance) {\n      resolveCssVars(instance, vnode, expectedMap);\n    }\n    if (!isMapEqual(actualMap, expectedMap)) {\n      mismatchType = 3 /* STYLE */;\n      mismatchKey = \"style\";\n    }\n  } else if (el instanceof SVGElement && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isKnownSvgAttr)(key) || el instanceof HTMLElement && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBooleanAttr)(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isKnownHtmlAttr)(key))) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBooleanAttr)(key)) {\n      actual = el.hasAttribute(key);\n      expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(clientValue);\n    } else if (clientValue == null) {\n      actual = el.hasAttribute(key);\n      expected = false;\n    } else {\n      if (el.hasAttribute(key)) {\n        actual = el.getAttribute(key);\n      } else if (key === \"value\" && el.tagName === \"TEXTAREA\") {\n        actual = el.value;\n      } else {\n        actual = false;\n      }\n      expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRenderableAttrValue)(clientValue) ? String(clientValue) : false;\n    }\n    if (actual !== expected) {\n      mismatchType = 4 /* ATTRIBUTE */;\n      mismatchKey = key;\n    }\n  }\n  if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {\n    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}=\"${v}\"`;\n    const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;\n    const postSegment = `\n  - rendered on server: ${format(actual)}\n  - expected on client: ${format(expected)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`;\n    {\n      warn$1(preSegment, el, postSegment);\n    }\n    return true;\n  }\n  return false;\n}\nfunction toClassSet(str) {\n  return new Set(str.trim().split(/\\s+/));\n}\nfunction isSetEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const s of a) {\n    if (!b.has(s)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toStyleMap(str) {\n  const styleMap = /* @__PURE__ */ new Map();\n  for (const item of str.split(\";\")) {\n    let [key, value] = item.split(\":\");\n    key = key.trim();\n    value = value && value.trim();\n    if (key && value) {\n      styleMap.set(key, value);\n    }\n  }\n  return styleMap;\n}\nfunction isMapEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const [key, value] of a) {\n    if (value !== b.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction resolveCssVars(instance, vnode, expectedMap) {\n  const root = instance.subTree;\n  if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {\n    const cssVars = instance.getCssVars();\n    for (const key in cssVars) {\n      expectedMap.set(\n        `--${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getEscapedCssVarName)(key, false)}`,\n        String(cssVars[key])\n      );\n    }\n  }\n  if (vnode === root && instance.parent) {\n    resolveCssVars(instance.parent, instance.vnode, expectedMap);\n  }\n}\nconst allowMismatchAttr = \"data-allow-mismatch\";\nconst MismatchTypeString = {\n  [0 /* TEXT */]: \"text\",\n  [1 /* CHILDREN */]: \"children\",\n  [2 /* CLASS */]: \"class\",\n  [3 /* STYLE */]: \"style\",\n  [4 /* ATTRIBUTE */]: \"attribute\"\n};\nfunction isMismatchAllowed(el, allowedType) {\n  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {\n    while (el && !el.hasAttribute(allowMismatchAttr)) {\n      el = el.parentElement;\n    }\n  }\n  const allowedAttr = el && el.getAttribute(allowMismatchAttr);\n  if (allowedAttr == null) {\n    return false;\n  } else if (allowedAttr === \"\") {\n    return true;\n  } else {\n    const list = allowedAttr.split(\",\");\n    if (allowedType === 0 /* TEXT */ && list.includes(\"children\")) {\n      return true;\n    }\n    return allowedAttr.split(\",\").includes(MismatchTypeString[allowedType]);\n  }\n}\n\nconst requestIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().requestIdleCallback || ((cb) => setTimeout(cb, 1));\nconst cancelIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().cancelIdleCallback || ((id) => clearTimeout(id));\nconst hydrateOnIdle = (timeout = 1e4) => (hydrate) => {\n  const id = requestIdleCallback(hydrate, { timeout });\n  return () => cancelIdleCallback(id);\n};\nfunction elementIsVisibleInViewport(el) {\n  const { top, left, bottom, right } = el.getBoundingClientRect();\n  const { innerHeight, innerWidth } = window;\n  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);\n}\nconst hydrateOnVisible = (opts) => (hydrate, forEach) => {\n  const ob = new IntersectionObserver((entries) => {\n    for (const e of entries) {\n      if (!e.isIntersecting) continue;\n      ob.disconnect();\n      hydrate();\n      break;\n    }\n  }, opts);\n  forEach((el) => {\n    if (!(el instanceof Element)) return;\n    if (elementIsVisibleInViewport(el)) {\n      hydrate();\n      ob.disconnect();\n      return false;\n    }\n    ob.observe(el);\n  });\n  return () => ob.disconnect();\n};\nconst hydrateOnMediaQuery = (query) => (hydrate) => {\n  if (query) {\n    const mql = matchMedia(query);\n    if (mql.matches) {\n      hydrate();\n    } else {\n      mql.addEventListener(\"change\", hydrate, { once: true });\n      return () => mql.removeEventListener(\"change\", hydrate);\n    }\n  }\n};\nconst hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(interactions)) interactions = [interactions];\n  let hasHydrated = false;\n  const doHydrate = (e) => {\n    if (!hasHydrated) {\n      hasHydrated = true;\n      teardown();\n      hydrate();\n      e.target.dispatchEvent(new e.constructor(e.type, e));\n    }\n  };\n  const teardown = () => {\n    forEach((el) => {\n      for (const i of interactions) {\n        el.removeEventListener(i, doHydrate);\n      }\n    });\n  };\n  forEach((el) => {\n    for (const i of interactions) {\n      el.addEventListener(i, doHydrate, { once: true });\n    }\n  });\n  return teardown;\n};\nfunction forEachElement(node, cb) {\n  if (isComment(node) && node.data === \"[\") {\n    let depth = 1;\n    let next = node.nextSibling;\n    while (next) {\n      if (next.nodeType === 1) {\n        const result = cb(next);\n        if (result === false) {\n          break;\n        }\n      } else if (isComment(next)) {\n        if (next.data === \"]\") {\n          if (--depth === 0) break;\n        } else if (next.data === \"[\") {\n          depth++;\n        }\n      }\n      next = next.nextSibling;\n    }\n  } else {\n    cb(node);\n  }\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineAsyncComponent(source) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {\n    source = { loader: source };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    hydrate: hydrateStrategy,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then((comp) => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if ( true && !comp) {\n        warn$1(\n          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`\n        );\n      }\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === \"Module\")) {\n        comp = comp.default;\n      }\n      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: \"AsyncComponentWrapper\",\n    __asyncLoader: load,\n    __asyncHydrate(el, instance, hydrate) {\n      const doHydrate = hydrateStrategy ? () => {\n        const teardown = hydrateStrategy(\n          hydrate,\n          (cb) => forEachElement(el, cb)\n        );\n        if (teardown) {\n          (instance.bum || (instance.bum = [])).push(teardown);\n        }\n      } : hydrate;\n      if (resolvedComp) {\n        doHydrate();\n      } else {\n        load().then(() => !instance.isUnmounted && doHydrate());\n      }\n    },\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      markAsyncBoundary(instance);\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = (err) => {\n        pendingRequest = null;\n        handleError(\n          err,\n          instance,\n          13,\n          !errorComponent\n        );\n      };\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then((comp) => {\n          return () => createInnerComp(comp, instance);\n        }).catch((err) => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();\n      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            );\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          instance.parent.update();\n        }\n      }).catch((err) => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const { ref: ref2, props, children, ce } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  vnode.ref = ref2;\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const sharedContext = instance.ctx;\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = /* @__PURE__ */ new Map();\n    const keys = /* @__PURE__ */ new Set();\n    let current = null;\n    if (true) {\n      instance.__v_cache = cache;\n    }\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: { createElement }\n      }\n    } = sharedContext;\n    const storageContainer = createElement(\"div\");\n    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {\n      const instance2 = vnode.component;\n      move(vnode, container, anchor, 0, parentSuspense);\n      patch(\n        instance2.vnode,\n        vnode,\n        container,\n        anchor,\n        instance2,\n        parentSuspense,\n        namespace,\n        vnode.slotScopeIds,\n        optimized\n      );\n      queuePostRenderEffect(() => {\n        instance2.isDeactivated = false;\n        if (instance2.a) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n      }, parentSuspense);\n      if (true) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    sharedContext.deactivate = (vnode) => {\n      const instance2 = vnode.component;\n      invalidateMount(instance2.m);\n      invalidateMount(instance2.a);\n      move(vnode, storageContainer, null, 1, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance2.da) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n        instance2.isDeactivated = true;\n      }, parentSuspense);\n      if (true) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    function unmount(vnode) {\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && !filter(name)) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (cached && (!current || !isSameVNodeType(cached, current))) {\n        unmount(cached);\n      } else if (current) {\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    watch(\n      () => [props.include, props.exclude],\n      ([include, exclude]) => {\n        include && pruneCache((name) => matches(include, name));\n        exclude && pruneCache((name) => !matches(exclude, name));\n      },\n      // prune post-render after `current` has been updated\n      { flush: \"post\", deep: true }\n    );\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      if (pendingCacheKey != null) {\n        if (isSuspense(instance.subTree.type)) {\n          queuePostRenderEffect(() => {\n            cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n          }, instance.subTree.suspense);\n        } else {\n          cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n        }\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach((cached) => {\n        const { subTree, suspense } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          resetShapeFlag(vnode);\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return current = null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (true) {\n          warn$1(`KeepAlive should contain exactly one component child.`);\n        }\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      if (vnode.type === Comment) {\n        current = null;\n        return vnode;\n      }\n      const comp = vnode.type;\n      const name = getComponentName(\n        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp\n      );\n      const { include, exclude, max } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        vnode.shapeFlag &= ~256;\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        vnode.shapeFlag |= 512;\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      vnode.shapeFlag |= 256;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\nconst KeepAlive = KeepAliveImpl;\nfunction matches(pattern, name) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {\n    return pattern.some((p) => matches(p, name));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {\n    return pattern.split(\",\").includes(name);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(pattern)) {\n    pattern.lastIndex = 0;\n    return pattern.test(name);\n  }\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\", target);\n}\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\", target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  const injected = injectHook(\n    type,\n    hook,\n    keepAliveRoot,\n    true\n    /* prepend */\n  );\n  onUnmounted(() => {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  vnode.shapeFlag &= ~256;\n  vnode.shapeFlag &= ~512;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n      const reset = setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      reset();\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (true) {\n    const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings$1[type].replace(/ hook$/, \"\"));\n    warn$1(\n      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.` )\n    );\n  }\n}\nconst createHook = (lifecycle) => (hook, target = currentInstance) => {\n  if (!isInSSRComponentSetup || lifecycle === \"sp\") {\n    injectHook(lifecycle, (...args) => hook(...args), target);\n  }\n};\nconst onBeforeMount = createHook(\"bm\");\nconst onMounted = createHook(\"m\");\nconst onBeforeUpdate = createHook(\n  \"bu\"\n);\nconst onUpdated = createHook(\"u\");\nconst onBeforeUnmount = createHook(\n  \"bum\"\n);\nconst onUnmounted = createHook(\"um\");\nconst onServerPrefetch = createHook(\n  \"sp\"\n);\nconst onRenderTriggered = createHook(\"rtg\");\nconst onRenderTracked = createHook(\"rtc\");\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook(\"ec\", hook, target);\n}\n\nconst COMPONENTS = \"components\";\nconst DIRECTIVES = \"directives\";\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol.for(\"v-ndc\");\nfunction resolveDynamicComponent(component) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(\n        Component,\n        false\n      );\n      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {\n        return Component;\n      }\n    }\n    const res = (\n      // local registration\n      // check instance[type] first which is resolved for options API\n      resolve(instance[type] || Component[type], name) || // global registration\n      resolve(instance.appContext[type], name)\n    );\n    if (!res && maybeSelfReference) {\n      return Component;\n    }\n    if ( true && warnMissing && !res) {\n      const extra = type === COMPONENTS ? `\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;\n      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\n    }\n    return res;\n  } else if (true) {\n    warn$1(\n      `resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`\n    );\n  }\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);\n}\n\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  const sourceIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source);\n  if (sourceIsArray || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {\n    const sourceIsReactiveArray = sourceIsArray && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source);\n    let needsWrap = false;\n    if (sourceIsReactiveArray) {\n      needsWrap = !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);\n      source = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadArray)(source);\n    }\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(\n        needsWrap ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toReactive)(source[i]) : source[i],\n        i,\n        void 0,\n        cached && cached[i]\n      );\n    }\n  } else if (typeof source === \"number\") {\n    if ( true && !Number.isInteger(source)) {\n      warn$1(`The v-for range expect an integer value but got ${source}.`);\n    }\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(\n        source,\n        (item, i) => renderItem(item, i, void 0, cached && cached[i])\n      );\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\n\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        if (res) res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\n\nfunction renderSlot(slots, name, props = {}, fallback, noSlotted) {\n  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {\n    if (name !== \"default\") props.name = name;\n    return openBlock(), createBlock(\n      Fragment,\n      null,\n      [createVNode(\"slot\", props, fallback && fallback())],\n      64\n    );\n  }\n  let slot = slots[name];\n  if ( true && slot && slot.length > 1) {\n    warn$1(\n      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`\n    );\n    slot = () => [];\n  }\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch\n  // key attached in the `createSlots` helper, respect that\n  validSlotContent && validSlotContent.key;\n  const rendered = createBlock(\n    Fragment,\n    {\n      key: (slotKey && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content\n      (!validSlotContent && fallback ? \"_fb\" : \"\")\n    },\n    validSlotContent || (fallback ? fallback() : []),\n    validSlotContent && slots._ === 1 ? 64 : -2\n  );\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + \"-s\"];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some((child) => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children))\n      return false;\n    return true;\n  }) ? vnodes : null;\n}\n\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {\n    warn$1(`v-on with no argument expects an object value.`);\n    return ret;\n  }\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];\n  }\n  return ret;\n}\n\nconst getPublicInstance = (i) => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getComponentPublicInstance(i);\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap = (\n  // Move PURE marker to new line to workaround compiler discarding it\n  // due to type annotation\n  /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), {\n    $: (i) => i,\n    $el: (i) => i.vnode.el,\n    $data: (i) => i.data,\n    $props: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0,\n    $attrs: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0,\n    $slots: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0,\n    $refs: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0,\n    $parent: (i) => getPublicInstance(i.parent),\n    $root: (i) => getPublicInstance(i.root),\n    $host: (i) => i.ce,\n    $emit: (i) => i.emit,\n    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n    $forceUpdate: (i) => i.f || (i.f = () => {\n      queueJob(i.update);\n    }),\n    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),\n    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n  })\n);\nconst isReservedPrefix = (key) => key === \"_\" || key === \"$\";\nconst hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    if (key === \"__v_skip\") {\n      return true;\n    }\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\n    if ( true && key === \"__isVue\") {\n      return true;\n    }\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      const n = accessCache[key];\n      if (n !== void 0) {\n        switch (n) {\n          case 1 /* SETUP */:\n            return setupState[key];\n          case 2 /* DATA */:\n            return data[key];\n          case 4 /* CONTEXT */:\n            return ctx[key];\n          case 3 /* PROPS */:\n            return props[key];\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* SETUP */;\n        return setupState[key];\n      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\n        accessCache[key] = 2 /* DATA */;\n        return data[key];\n      } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)\n      ) {\n        accessCache[key] = 3 /* PROPS */;\n        return props[key];\n      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {\n        accessCache[key] = 4 /* CONTEXT */;\n        return ctx[key];\n      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache[key] = 0 /* OTHER */;\n      }\n    }\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      if (key === \"$attrs\") {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance.attrs, \"get\", \"\");\n         true && markAttrsAccessed();\n      } else if ( true && key === \"$slots\") {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, \"get\", key);\n      }\n      return publicGetter(instance);\n    } else if (\n      // css module (injected by vue-loader)\n      (cssModule = type.__cssModules) && (cssModule = cssModule[key])\n    ) {\n      return cssModule;\n    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {\n      accessCache[key] = 4 /* CONTEXT */;\n      return ctx[key];\n    } else if (\n      // global properties\n      globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)\n    ) {\n      {\n        return globalProperties[key];\n      }\n    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    key.indexOf(\"__v\") !== 0)) {\n      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\n        warn$1(\n          `Property ${JSON.stringify(\n            key\n          )} must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.`\n        );\n      } else if (instance === currentRenderingInstance) {\n        warn$1(\n          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`\n        );\n      }\n    }\n  },\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if ( true && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {\n      warn$1(`Cannot mutate <script setup> binding \"${key}\" from Options API.`);\n      return false;\n    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\n      data[key] = value;\n      return true;\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {\n       true && warn$1(`Attempting to mutate prop \"${key}\". Props are readonly.`);\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n       true && warn$1(\n        `Attempting to mutate public property \"${key}\". Properties starting with $ are reserved and readonly.`\n      );\n      return false;\n    } else {\n      if ( true && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        });\n      } else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: { data, setupState, accessCache, ctx, appContext, propsOptions }\n  }, key) {\n    let normalizedProps;\n    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      target._.accessCache[key] = 0;\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, \"value\")) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (true) {\n  PublicInstanceProxyHandlers.ownKeys = (target) => {\n    warn$1(\n      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`\n    );\n    return Reflect.ownKeys(target);\n  };\n}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    if (key === Symbol.unscopables) {\n      return;\n    }\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n  has(_, key) {\n    const has = key[0] !== \"_\" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyAllowed)(key);\n    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {\n      warn$1(\n        `Property ${JSON.stringify(\n          key\n        )} should not start with _ which is a reserved prefix for Vue internals.`\n      );\n    }\n    return has;\n  }\n});\nfunction createDevRenderContext(instance) {\n  const target = {};\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  Object.keys(publicPropertiesMap).forEach((key) => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n    });\n  });\n  return target;\n}\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach((key) => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n      });\n    });\n  }\n}\nfunction exposeSetupStateOnRenderContext(instance) {\n  const { ctx, setupState } = instance;\n  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach((key) => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        warn$1(\n          `setup() return property ${JSON.stringify(\n            key\n          )} should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.`\n        );\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n      });\n    }\n  });\n}\n\nconst warnRuntimeUsage = (method) => warn$1(\n  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`\n);\nfunction defineProps() {\n  if (true) {\n    warnRuntimeUsage(`defineProps`);\n  }\n  return null;\n}\nfunction defineEmits() {\n  if (true) {\n    warnRuntimeUsage(`defineEmits`);\n  }\n  return null;\n}\nfunction defineExpose(exposed) {\n  if (true) {\n    warnRuntimeUsage(`defineExpose`);\n  }\n}\nfunction defineOptions(options) {\n  if (true) {\n    warnRuntimeUsage(`defineOptions`);\n  }\n}\nfunction defineSlots() {\n  if (true) {\n    warnRuntimeUsage(`defineSlots`);\n  }\n  return null;\n}\nfunction defineModel() {\n  if (true) {\n    warnRuntimeUsage(\"defineModel\");\n  }\n}\nfunction withDefaults(props, defaults) {\n  if (true) {\n    warnRuntimeUsage(`withDefaults`);\n  }\n  return null;\n}\nfunction useSlots() {\n  return getContext().slots;\n}\nfunction useAttrs() {\n  return getContext().attrs;\n}\nfunction getContext() {\n  const i = getCurrentInstance();\n  if ( true && !i) {\n    warn$1(`useContext() called without active instance.`);\n  }\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\nfunction normalizePropsOrEmits(props) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props.reduce(\n    (normalized, p) => (normalized[p] = null, normalized),\n    {}\n  ) : props;\n}\nfunction mergeDefaults(raw, defaults) {\n  const props = normalizePropsOrEmits(raw);\n  for (const key in defaults) {\n    if (key.startsWith(\"__skip\")) continue;\n    let opt = props[key];\n    if (opt) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {\n        opt = props[key] = { type: opt, default: defaults[key] };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      opt = props[key] = { default: defaults[key] };\n    } else if (true) {\n      warn$1(`props default key \"${key}\" has no corresponding declaration.`);\n    }\n    if (opt && defaults[`__skip_${key}`]) {\n      opt.skipFactory = true;\n    }\n  }\n  return props;\n}\nfunction mergeModels(a, b) {\n  if (!a || !b) return a || b;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(a) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(b)) return a.concat(b);\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));\n}\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  if ( true && !ctx) {\n    warn$1(\n      `withAsyncContext called without active current instance. This is likely a bug.`\n    );\n  }\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {\n    awaitable = awaitable.catch((e) => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\n\nfunction createDuplicateChecker() {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn$1(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  shouldCacheAccess = false;\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\");\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;\n  if (true) {\n    const [propsOptions] = instance.propsOptions;\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties(\"Props\" /* PROPS */, key);\n      }\n    }\n  }\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {\n        if (true) {\n          Object.defineProperty(ctx, key, {\n            value: methodHandler.bind(publicThis),\n            configurable: true,\n            enumerable: true,\n            writable: true\n          });\n        } else {}\n        if (true) {\n          checkDuplicateProperties(\"Methods\" /* METHODS */, key);\n        }\n      } else if (true) {\n        warn$1(\n          `Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. Did you reference the function correctly?`\n        );\n      }\n    }\n  }\n  if (dataOptions) {\n    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {\n      warn$1(\n        `The data option must be a function. Plain object usage is no longer supported.`\n      );\n    }\n    const data = dataOptions.call(publicThis, publicThis);\n    if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {\n      warn$1(\n        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`\n      );\n    }\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {\n       true && warn$1(`data() should return an object.`);\n    } else {\n      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);\n      if (true) {\n        for (const key in data) {\n          checkDuplicateProperties(\"Data\" /* DATA */, key);\n          if (!isReservedPrefix(key[0])) {\n            Object.defineProperty(ctx, key, {\n              configurable: true,\n              enumerable: true,\n              get: () => data[key],\n              set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n            });\n          }\n        }\n      }\n    }\n  }\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\n        warn$1(`Computed property \"${key}\" has no getter.`);\n      }\n      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {\n        warn$1(\n          `Write operation failed: computed property \"${key}\" is readonly.`\n        );\n      } : 0;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: (v) => c.value = v\n      });\n      if (true) {\n        checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\n      }\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach((key) => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\");\n  }\n  function registerLifecycleHook(register, hook) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\n      hook.forEach((_hook) => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach((key) => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: (val) => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  if (components) instance.components = components;\n  if (directives) instance.directives = directives;\n  if (serverPrefetch) {\n    markAsyncBoundary(instance);\n  }\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {\n      if (\"default\" in opt) {\n        injected = inject(\n          opt.from || key,\n          opt.default,\n          true\n        );\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => injected.value,\n        set: (v) => injected.value = v\n      });\n    } else {\n      ctx[key] = injected;\n    }\n    if (true) {\n      checkDuplicateProperties(\"Inject\" /* INJECT */, key);\n    }\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling(\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),\n    instance,\n    type\n  );\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  let getter = key.includes(\".\") ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {\n    const handler = ctx[raw];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {\n      {\n        watch(getter, handler);\n      }\n    } else if (true) {\n      warn$1(`Invalid watch handler specified by key \"${raw}\"`, handler);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {\n    {\n      watch(getter, raw.bind(publicThis));\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {\n        watch(getter, handler, raw);\n      } else if (true) {\n        warn$1(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n      }\n    }\n  } else if (true) {\n    warn$1(`Invalid watch option: \"${key}\"`, raw);\n  }\n}\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const { mixins, extends: extendsOptions } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: { optionMergeStrategies }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(\n        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)\n      );\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const { mixins, extends: extendsOptions } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(\n      (m) => mergeOptions(to, m, strats, true)\n    );\n  }\n  for (const key in from) {\n    if (asMixin && key === \"expose\") {\n       true && warn$1(\n        `\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`\n      );\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeEmitsOrPropsOptions,\n  emits: mergeEmitsOrPropsOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))(\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to,\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from\n    );\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;\n}\nfunction mergeEmitsOrPropsOptions(to, from) {\n  if (to) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(to) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(from)) {\n      return [.../* @__PURE__ */ new Set([...to, ...from])];\n    }\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(\n      /* @__PURE__ */ Object.create(null),\n      normalizePropsOrEmits(to),\n      normalizePropsOrEmits(from != null ? from : {})\n    );\n  } else {\n    return from;\n  }\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\n\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */ Object.create(null),\n    optionsCache: /* @__PURE__ */ new WeakMap(),\n    propsCache: /* @__PURE__ */ new WeakMap(),\n    emitsCache: /* @__PURE__ */ new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {\n      rootComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, rootComponent);\n    }\n    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {\n       true && warn$1(`root props passed to app.mount() must be an object.`);\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = /* @__PURE__ */ new WeakSet();\n    const pluginCleanupFns = [];\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (true) {\n          warn$1(\n            `app.config cannot be replaced. Modify individual options instead.`\n          );\n        }\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n           true && warn$1(`Plugin has already been applied to target app.`);\n        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (true) {\n          warn$1(\n            `A plugin must either be a function or an object with an \"install\" function.`\n          );\n        }\n        return app;\n      },\n      mixin(mixin) {\n        if (__VUE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (true) {\n            warn$1(\n              \"Mixin has already been applied to target app\" + (mixin.name ? `: ${mixin.name}` : \"\")\n            );\n          }\n        } else if (true) {\n          warn$1(\"Mixins are only available in builds supporting Options API\");\n        }\n        return app;\n      },\n      component(name, component) {\n        if (true) {\n          validateComponentName(name, context.config);\n        }\n        if (!component) {\n          return context.components[name];\n        }\n        if ( true && context.components[name]) {\n          warn$1(`Component \"${name}\" has already been registered in target app.`);\n        }\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (true) {\n          validateDirectiveName(name);\n        }\n        if (!directive) {\n          return context.directives[name];\n        }\n        if ( true && context.directives[name]) {\n          warn$1(`Directive \"${name}\" has already been registered in target app.`);\n        }\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, namespace) {\n        if (!isMounted) {\n          if ( true && rootContainer.__vue_app__) {\n            warn$1(\n              `There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling \\`app.unmount()\\` first.`\n            );\n          }\n          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);\n          vnode.appContext = context;\n          if (namespace === true) {\n            namespace = \"svg\";\n          } else if (namespace === false) {\n            namespace = void 0;\n          }\n          if (true) {\n            context.reload = () => {\n              render(\n                cloneVNode(vnode),\n                rootContainer,\n                namespace\n              );\n            };\n          }\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, namespace);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if (true) {\n            app._instance = vnode.component;\n            devtoolsInitApp(app, version);\n          }\n          return getComponentPublicInstance(vnode.component);\n        } else if (true) {\n          warn$1(\n            `App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \\`const createMyApp = () => createApp(App)\\``\n          );\n        }\n      },\n      onUnmount(cleanupFn) {\n        if ( true && typeof cleanupFn !== \"function\") {\n          warn$1(\n            `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`\n          );\n        }\n        pluginCleanupFns.push(cleanupFn);\n      },\n      unmount() {\n        if (isMounted) {\n          callWithAsyncErrorHandling(\n            pluginCleanupFns,\n            app._instance,\n            16\n          );\n          render(null, app._container);\n          if (true) {\n            app._instance = null;\n            devtoolsUnmountApp(app);\n          }\n          delete app._container.__vue_app__;\n        } else if (true) {\n          warn$1(`Cannot unmount an app that is not mounted.`);\n        }\n      },\n      provide(key, value) {\n        if ( true && key in context.provides) {\n          warn$1(\n            `App already provides property with key \"${String(key)}\". It will be overwritten with the new value.`\n          );\n        }\n        context.provides[key] = value;\n        return app;\n      },\n      runWithContext(fn) {\n        const lastApp = currentApp;\n        currentApp = app;\n        try {\n          return fn();\n        } finally {\n          currentApp = lastApp;\n        }\n      }\n    };\n    return app;\n  };\n}\nlet currentApp = null;\n\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (true) {\n      warn$1(`provide() can only be used inside setup().`);\n    }\n  } else {\n    let provides = currentInstance.provides;\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    provides[key] = value;\n  }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance || currentApp) {\n    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;\n    if (provides && key in provides) {\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;\n    } else if (true) {\n      warn$1(`injection \"${String(key)}\" not found.`);\n    }\n  } else if (true) {\n    warn$1(`inject() can only be used inside setup() or functional components.`);\n  }\n}\nfunction hasInjectionContext() {\n  return !!(currentInstance || currentRenderingInstance || currentApp);\n}\n\nconst internalObjectProto = {};\nconst createInternalObject = () => Object.create(internalObjectProto);\nconst isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;\n\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\n  const props = {};\n  const attrs = createInternalObject();\n  instance.propsDefaults = /* @__PURE__ */ Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = void 0;\n    }\n  }\n  if (true) {\n    validateProps(rawProps || {}, props, instance);\n  }\n  if (isStateful) {\n    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);\n  } else {\n    if (!instance.type.props) {\n      instance.props = attrs;\n    } else {\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId) return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: { patchFlag }\n  } = instance;\n  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    !( true && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)\n  ) {\n    if (patchFlag & 8) {\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        const value = rawProps[key];\n        if (options) {\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\n            props[camelizedKey] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              camelizedKey,\n              value,\n              instance,\n              false\n            );\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps || // for camelCase\n      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && // for camelCase\n          (rawPrevProps[key] !== void 0 || // for kebab-case\n          rawPrevProps[kebabKey] !== void 0)) {\n            props[key] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              key,\n              void 0,\n              instance,\n              true\n            );\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && true) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (hasAttrsChanged) {\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance.attrs, \"set\", \"\");\n  }\n  if (true) {\n    validateProps(rawProps || {}, props, instance);\n  }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      let camelKey;\n      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(\n        options,\n        rawCurrentProps,\n        key,\n        castValues[key],\n        instance,\n        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key)\n      );\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, \"default\");\n    if (hasDefault && value === void 0) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && !opt.skipFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {\n        const { propsDefaults } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          const reset = setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(\n            null,\n            props\n          );\n          reset();\n        }\n      } else {\n        value = defaultValue;\n      }\n      if (instance.ce) {\n        instance.ce._setProp(key, value);\n      }\n    }\n    if (opt[0 /* shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* shouldCastTrue */] && (value === \"\" || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nconst mixinPropsCache = /* @__PURE__ */ new WeakMap();\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\n    const extendProps = (raw2) => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw2, appContext, true);\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);\n    }\n    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {\n        warn$1(`props must be strings when using array syntax.`, raw[i]);\n      }\n      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {\n      warn$1(`invalid props options`, raw);\n    }\n    for (const key in raw) {\n      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, opt);\n        const propType = prop.type;\n        let shouldCast = false;\n        let shouldCastTrue = true;\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propType)) {\n          for (let index = 0; index < propType.length; ++index) {\n            const type = propType[index];\n            const typeName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) && type.name;\n            if (typeName === \"Boolean\") {\n              shouldCast = true;\n              break;\n            } else if (typeName === \"String\") {\n              shouldCastTrue = false;\n            }\n          }\n        } else {\n          shouldCast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(propType) && propType.name === \"Boolean\";\n        }\n        prop[0 /* shouldCast */] = shouldCast;\n        prop[1 /* shouldCastTrue */] = shouldCastTrue;\n        if (shouldCast || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, \"default\")) {\n          needCastKeys.push(normalizedKey);\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== \"$\" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\n    return true;\n  } else if (true) {\n    warn$1(`Invalid prop name: \"${key}\" is a reserved property.`);\n  }\n  return false;\n}\nfunction getType(ctor) {\n  if (ctor === null) {\n    return \"null\";\n  }\n  if (typeof ctor === \"function\") {\n    return ctor.name || \"\";\n  } else if (typeof ctor === \"object\") {\n    const name = ctor.constructor && ctor.constructor.name;\n    return name || \"\";\n  }\n  return \"\";\n}\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n  const options = instance.propsOptions[0];\n  const camelizePropsKey = Object.keys(rawProps).map((key) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key));\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(\n      key,\n      resolvedValues[key],\n      opt,\n       true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(resolvedValues) : 0,\n      !camelizePropsKey.includes(key)\n    );\n  }\n}\nfunction validateProp(name, value, prop, props, isAbsent) {\n  const { type, required, validator, skipCheck } = prop;\n  if (required && isAbsent) {\n    warn$1('Missing required prop: \"' + name + '\"');\n    return;\n  }\n  if (value == null && !required) {\n    return;\n  }\n  if (type != null && type !== true && !skipCheck) {\n    let isValid = false;\n    const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];\n    const expectedTypes = [];\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const { valid, expectedType } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || \"\");\n      isValid = valid;\n    }\n    if (!isValid) {\n      warn$1(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  if (validator && !validator(value, props)) {\n    warn$1('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\nconst isSimpleType = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(\n  \"String,Number,Boolean,Function,Symbol,BigInt\"\n);\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (expectedType === \"null\") {\n    valid = value === null;\n  } else if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    if (!valid && t === \"object\") {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === \"Object\") {\n    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);\n  } else if (expectedType === \"Array\") {\n    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  if (expectedTypes.length === 0) {\n    return `Prop type [] for prop \"${name}\" won't match anything. Did you mean to use type Array instead?`;\n  }\n  let message = `Invalid prop: type check failed for prop \"${name}\". Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(\" | \")}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\nfunction styleValue(value, type) {\n  if (type === \"String\") {\n    return `\"${value}\"`;\n  } else if (type === \"Number\") {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\nfunction isExplicable(type) {\n  const explicitTypes = [\"string\", \"number\", \"boolean\"];\n  return explicitTypes.some((elem) => type.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n  return args.some((elem) => elem.toLowerCase() === \"boolean\");\n}\n\nconst isInternalKey = (key) => key[0] === \"_\" || key === \"$stable\";\nconst normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if ( true && currentInstance && (!ctx || ctx.root === currentInstance.root)) {\n      warn$1(\n        `Slot \"${key}\" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`\n      );\n    }\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (true) {\n        warn$1(\n          `Non-function value encountered for slot \"${key}\". Prefer function slots for better performance.`\n        );\n      }\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if ( true && !isKeepAlive(instance.vnode) && true) {\n    warn$1(\n      `Non-function value encountered for default slot. Prefer function slots for better performance.`\n    );\n  }\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst assignSlots = (slots, children, optimized) => {\n  for (const key in children) {\n    if (optimized || key !== \"_\") {\n      slots[key] = children[key];\n    }\n  }\n};\nconst initSlots = (instance, children, optimized) => {\n  const slots = instance.slots = createInternalObject();\n  if (instance.vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      assignSlots(slots, children, optimized);\n      if (optimized) {\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(slots, \"_\", type, true);\n      }\n    } else {\n      normalizeObjectSlots(children, slots);\n    }\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n  }\n};\nconst updateSlots = (instance, children, optimized) => {\n  const { vnode, slots } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n  if (vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      if ( true && isHmrUpdating) {\n        assignSlots(slots, children, optimized);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, \"set\", \"$slots\");\n      } else if (optimized && type === 1) {\n        needDeletionCheck = false;\n      } else {\n        assignSlots(slots, children, optimized);\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = { default: 1 };\n  }\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\n        delete slots[key];\n      }\n    }\n  }\n};\n\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if (true) {\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(\n      `<${formatComponentName(instance, instance.type)}> ${type}`,\n      startTag,\n      endTag\n    );\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if (true) {\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction isSupported() {\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== \"undefined\" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\n\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (typeof __VUE_OPTIONS_API__ !== \"boolean\") {\n     true && needWarn.push(`__VUE_OPTIONS_API__`);\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;\n  }\n  if (typeof __VUE_PROD_DEVTOOLS__ !== \"boolean\") {\n     true && needWarn.push(`__VUE_PROD_DEVTOOLS__`);\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;\n  }\n  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== \"boolean\") {\n     true && needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;\n  }\n  if ( true && needWarn.length) {\n    const multi = needWarn.length > 1;\n    console.warn(\n      `Feature flag${multi ? `s` : ``} ${needWarn.join(\", \")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.\n\nFor more details, see https://link.vuejs.org/feature-flags.`\n    );\n  }\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense ;\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nfunction baseCreateRenderer(options, createHydrationFns) {\n  {\n    initFeatureFlags();\n  }\n  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();\n  target.__VUE__ = true;\n  if (true) {\n    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized =  true && isHmrUpdating ? false : !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const { type, ref, shapeFlag } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, namespace);\n        } else if (true) {\n          patchStaticNode(n1, n2, container, namespace);\n        }\n        break;\n      case Fragment:\n        processFragment(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        break;\n      default:\n        if (shapeFlag & 1) {\n          processElement(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 6) {\n          processComponent(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 64) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (shapeFlag & 128) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (true) {\n          warn$1(\"Invalid VNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateText(n2.children),\n        container,\n        anchor\n      );\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateComment(n2.children || \"\"),\n        container,\n        anchor\n      );\n    } else {\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, namespace) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(\n      n2.children,\n      container,\n      anchor,\n      namespace,\n      n2.el,\n      n2.anchor\n    );\n  };\n  const patchStaticNode = (n1, n2, container, namespace) => {\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(\n        n2.children,\n        container,\n        anchor,\n        namespace\n      );\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({ el, anchor }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    if (n2.type === \"svg\") {\n      namespace = \"svg\";\n    } else if (n2.type === \"math\") {\n      namespace = \"mathml\";\n    }\n    if (n1 == null) {\n      mountElement(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      patchElement(\n        n1,\n        n2,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const { props, shapeFlag, transition, dirs } = vnode;\n    el = vnode.el = hostCreateElement(\n      vnode.type,\n      namespace,\n      props && props.is,\n      props\n    );\n    if (shapeFlag & 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16) {\n      mountChildren(\n        vnode.children,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(vnode, namespace),\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n    }\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    if (props) {\n      for (const key in props) {\n        if (key !== \"value\" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\n          hostPatchProp(el, key, null, props[key], namespace, parentComponent);\n        }\n      }\n      if (\"value\" in props) {\n        hostPatchProp(el, \"value\", null, props.value, namespace);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (true) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(el, \"__vnode\", vnode, true);\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(el, \"__vueParentComponent\", parentComponent, true);\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n    }\n    const needCallTransitionHooks = needTransition(parentSuspense, transition);\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {\n        subTree = filterSingleRoot(subTree.children) || subTree;\n      }\n      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(\n          el,\n          parentVNode,\n          parentVNode.scopeId,\n          parentVNode.slotScopeIds,\n          parentComponent.parent\n        );\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(\n        null,\n        child,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    if (true) {\n      el.__vnode = n2;\n    }\n    let { patchFlag, dynamicChildren, dirs } = n2;\n    patchFlag |= n1.patchFlag & 16;\n    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    let vnodeHook;\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, \"beforeUpdate\");\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if ( true && isHmrUpdating) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {\n      hostSetElementText(el, \"\");\n    }\n    if (dynamicChildren) {\n      patchBlockChildren(\n        n1.dynamicChildren,\n        dynamicChildren,\n        el,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(n2, namespace),\n        slotScopeIds\n      );\n      if (true) {\n        traverseStaticChildren(n1, n2);\n      }\n    } else if (!optimized) {\n      patchChildren(\n        n1,\n        n2,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(n2, namespace),\n        slotScopeIds,\n        false\n      );\n    }\n    if (patchFlag > 0) {\n      if (patchFlag & 16) {\n        patchProps(el, oldProps, newProps, parentComponent, namespace);\n      } else {\n        if (patchFlag & 2) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, \"class\", null, newProps.class, namespace);\n          }\n        }\n        if (patchFlag & 4) {\n          hostPatchProp(el, \"style\", oldProps.style, newProps.style, namespace);\n        }\n        if (patchFlag & 8) {\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            if (next !== prev || key === \"value\") {\n              hostPatchProp(el, key, prev, next, namespace, parentComponent);\n            }\n          }\n        }\n      }\n      if (patchFlag & 1) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      patchProps(el, oldProps, newProps, parentComponent, namespace);\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, \"updated\");\n      }, parentSuspense);\n    }\n  };\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      const container = (\n        // oldVNode may be an errored async setup() component inside Suspense\n        // which will not have a mounted element\n        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent\n        // of the Fragment itself so it can move its children.\n        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement\n        // which also requires the correct parent container\n        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.\n        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (\n          // In other cases, the parent container is not actually used so we\n          // just pass the block element here to avoid a DOM parentNode call.\n          fallbackContainer\n        )\n      );\n      patch(\n        oldVNode,\n        newVNode,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        true\n      );\n    }\n  };\n  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {\n            hostPatchProp(\n              el,\n              key,\n              oldProps[key],\n              null,\n              namespace,\n              parentComponent\n            );\n          }\n        }\n      }\n      for (const key in newProps) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        if (next !== prev && key !== \"value\") {\n          hostPatchProp(el, key, prev, next, namespace, parentComponent);\n        }\n      }\n      if (\"value\" in newProps) {\n        hostPatchProp(el, \"value\", oldProps.value, newProps.value, namespace);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(\"\");\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText(\"\");\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\n    if ( true && // #5523 dev root fragment may inherit directives\n    (isHmrUpdating || patchFlag & 2048)) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      mountChildren(\n        // #10007\n        // such fragment like `<></>` will be compiled into\n        // a fragment which doesn't have a children.\n        // In this case fallback to an empty array\n        n2.children || [],\n        container,\n        fragmentEndAnchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          container,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds\n        );\n        if (true) {\n          traverseStaticChildren(n1, n2);\n        } else {}\n      } else {\n        patchChildren(\n          n1,\n          n2,\n          container,\n          fragmentEndAnchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512) {\n        parentComponent.ctx.activate(\n          n2,\n          container,\n          anchor,\n          namespace,\n          optimized\n        );\n      } else {\n        mountComponent(\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          optimized\n        );\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {\n    const instance = (initialVNode.component = createComponentInstance(\n      initialVNode,\n      parentComponent,\n      parentSuspense\n    ));\n    if ( true && instance.type.__hmrId) {\n      registerHMR(instance);\n    }\n    if (true) {\n      pushWarningContext(initialVNode);\n      startMeasure(instance, `mount`);\n    }\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    {\n      if (true) {\n        startMeasure(instance, `init`);\n      }\n      setupComponent(instance, false, optimized);\n      if (true) {\n        endMeasure(instance, `init`);\n      }\n    }\n    if (instance.asyncDep) {\n      if ( true && isHmrUpdating) initialVNode.el = null;\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n    } else {\n      setupRenderEffect(\n        instance,\n        initialVNode,\n        container,\n        anchor,\n        parentSuspense,\n        namespace,\n        optimized\n      );\n    }\n    if (true) {\n      popWarningContext();\n      endMeasure(instance, `mount`);\n    }\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        if (true) {\n          pushWarningContext(n2);\n        }\n        updateComponentPreRender(instance, n2, optimized);\n        if (true) {\n          popWarningContext();\n        }\n        return;\n      } else {\n        instance.next = n2;\n        instance.update();\n      }\n    } else {\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const { el, props } = initialVNode;\n        const { bm, m, parent, root, type } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        if (bm) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          const hydrateSubTree = () => {\n            if (true) {\n              startMeasure(instance, `render`);\n            }\n            instance.subTree = renderComponentRoot(instance);\n            if (true) {\n              endMeasure(instance, `render`);\n            }\n            if (true) {\n              startMeasure(instance, `hydrate`);\n            }\n            hydrateNode(\n              el,\n              instance.subTree,\n              instance,\n              parentSuspense,\n              null\n            );\n            if (true) {\n              endMeasure(instance, `hydrate`);\n            }\n          };\n          if (isAsyncWrapperVNode && type.__asyncHydrate) {\n            type.__asyncHydrate(\n              el,\n              instance,\n              hydrateSubTree\n            );\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (root.ce) {\n            root.ce._injectChildStyle(type);\n          }\n          if (true) {\n            startMeasure(instance, `render`);\n          }\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (true) {\n            endMeasure(instance, `render`);\n          }\n          if (true) {\n            startMeasure(instance, `patch`);\n          }\n          patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            namespace\n          );\n          if (true) {\n            endMeasure(instance, `patch`);\n          }\n          initialVNode.el = subTree.el;\n        }\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),\n            parentSuspense\n          );\n        }\n        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if (true) {\n          devtoolsComponentAdded(instance);\n        }\n        initialVNode = container = anchor = null;\n      } else {\n        let { next, bu, u, parent, vnode } = instance;\n        {\n          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);\n          if (nonHydratedAsyncRoot) {\n            if (next) {\n              next.el = vnode.el;\n              updateComponentPreRender(instance, next, optimized);\n            }\n            nonHydratedAsyncRoot.asyncDep.then(() => {\n              if (!instance.isUnmounted) {\n                componentUpdateFn();\n              }\n            });\n            return;\n          }\n        }\n        let originNext = next;\n        let vnodeHook;\n        if (true) {\n          pushWarningContext(next || instance.vnode);\n        }\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        if (bu) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        if (true) {\n          startMeasure(instance, `render`);\n        }\n        const nextTree = renderComponentRoot(instance);\n        if (true) {\n          endMeasure(instance, `render`);\n        }\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (true) {\n          startMeasure(instance, `patch`);\n        }\n        patch(\n          prevTree,\n          nextTree,\n          // parent may have changed if it's in a teleport\n          hostParentNode(prevTree.el),\n          // anchor may have changed if it's in a fragment\n          getNextHostNode(prevTree),\n          instance,\n          parentSuspense,\n          namespace\n        );\n        if (true) {\n          endMeasure(instance, `patch`);\n        }\n        next.el = nextTree.el;\n        if (originNext === null) {\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, next, vnode),\n            parentSuspense\n          );\n        }\n        if (true) {\n          devtoolsComponentUpdated(instance);\n        }\n        if (true) {\n          popWarningContext();\n        }\n      }\n    };\n    instance.scope.on();\n    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn);\n    instance.scope.off();\n    const update = instance.update = effect.run.bind(effect);\n    const job = instance.job = effect.runIfDirty.bind(effect);\n    job.i = instance;\n    job.id = instance.uid;\n    effect.scheduler = () => queueJob(job);\n    toggleRecurse(instance, true);\n    if (true) {\n      effect.onTrack = instance.rtc ? (e) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0;\n      effect.onTrigger = instance.rtg ? (e) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0;\n    }\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n    flushPreFlushCbs(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const { patchFlag, shapeFlag } = n2;\n    if (patchFlag > 0) {\n      if (patchFlag & 128) {\n        patchKeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      } else if (patchFlag & 256) {\n        patchUnkeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      }\n    }\n    if (shapeFlag & 8) {\n      if (prevShapeFlag & 16) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16) {\n        if (shapeFlag & 16) {\n          patchKeyedChildren(\n            c1,\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else {\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        if (prevShapeFlag & 8) {\n          hostSetElementText(container, \"\");\n        }\n        if (shapeFlag & 16) {\n          mountChildren(\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (oldLength > newLength) {\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength\n      );\n    } else {\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        commonLength\n      );\n    }\n  };\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      i++;\n    }\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(\n            null,\n            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    } else {\n      const s1 = i;\n      const s2 = i;\n      const keyToNewIndexMap = /* @__PURE__ */ new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if ( true && keyToNewIndexMap.has(nextChild.key)) {\n            warn$1(\n              `Duplicate keys found during update:`,\n              JSON.stringify(nextChild.key),\n              `Make sure keys are unique.`\n            );\n          }\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === void 0) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(\n            prevChild,\n            c2[newIndex],\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          patched++;\n        }\n      }\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (moved) {\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const { el, type, transition, children, shapeFlag } = vnode;\n    if (shapeFlag & 6) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;\n    if (needTransition2) {\n      if (moveType === 0) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const { leave, delayLeave, afterLeave } = transition;\n        const remove2 = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove2();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove2, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs,\n      cacheIndex\n    } = vnode;\n    if (patchFlag === -2) {\n      optimized = false;\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (cacheIndex != null) {\n      parentComponent.renderCache[cacheIndex] = void 0;\n    }\n    if (shapeFlag & 256) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeUnmount\");\n      }\n      if (shapeFlag & 64) {\n        vnode.type.remove(\n          vnode,\n          parentComponent,\n          parentSuspense,\n          internals,\n          doRemove\n        );\n      } else if (dynamicChildren && // #5154\n      // when v-once is used inside a block, setBlockTracking(-1) marks the\n      // parent block with hasOnce: true\n      // so that it doesn't take the fast path during unmount - otherwise\n      // components nested in v-once are never unmounted.\n      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments\n      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {\n        unmountChildren(\n          dynamicChildren,\n          parentComponent,\n          parentSuspense,\n          false,\n          true\n        );\n      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, \"unmounted\");\n      }, parentSuspense);\n    }\n  };\n  const remove = (vnode) => {\n    const { type, el, anchor, transition } = vnode;\n    if (type === Fragment) {\n      if ( true && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {\n        vnode.children.forEach((child) => {\n          if (child.type === Comment) {\n            hostRemove(child.el);\n          } else {\n            remove(child);\n          }\n        });\n      } else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {\n      const { leave, delayLeave } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if ( true && instance.type.__hmrId) {\n      unregisterHMR(instance);\n    }\n    const { bum, scope, job, subTree, um, m, a } = instance;\n    invalidateMount(m);\n    invalidateMount(a);\n    if (bum) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);\n    }\n    scope.stop();\n    if (job) {\n      job.flags |= 8;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n    if (true) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = (vnode) => {\n    if (vnode.shapeFlag & 6) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128) {\n      return vnode.suspense.next();\n    }\n    const el = hostNextSibling(vnode.anchor || vnode.el);\n    const teleportEnd = el && el[TeleportEndKey];\n    return teleportEnd ? hostNextSibling(teleportEnd) : el;\n  };\n  let isFlushing = false;\n  const render = (vnode, container, namespace) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(\n        container._vnode || null,\n        vnode,\n        container,\n        null,\n        null,\n        null,\n        namespace\n      );\n    }\n    container._vnode = vnode;\n    if (!isFlushing) {\n      isFlushing = true;\n      flushPreFlushCbs();\n      flushPostFlushCbs();\n      isFlushing = false;\n    }\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(\n      internals\n    );\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction resolveChildrenNamespace({ type, props }, currentNamespace) {\n  return currentNamespace === \"svg\" && type === \"foreignObject\" || currentNamespace === \"mathml\" && type === \"annotation-xml\" && props && props.encoding && props.encoding.includes(\"html\") ? void 0 : currentNamespace;\n}\nfunction toggleRecurse({ effect, job }, allowed) {\n  if (allowed) {\n    effect.flags |= 32;\n    job.flags |= 4;\n  } else {\n    effect.flags &= ~32;\n    job.flags &= ~4;\n  }\n}\nfunction needTransition(parentSuspense, transition) {\n  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n}\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow && c2.patchFlag !== -2)\n          traverseStaticChildren(c1, c2);\n      }\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n      if ( true && c2.type === Comment && !c2.el) {\n        c2.el = c1.el;\n      }\n    }\n  }\n}\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nfunction locateNonHydratedAsyncRoot(instance) {\n  const subComponent = instance.subTree.component;\n  if (subComponent) {\n    if (subComponent.asyncDep && !subComponent.asyncResolved) {\n      return subComponent;\n    } else {\n      return locateNonHydratedAsyncRoot(subComponent);\n    }\n  }\n}\nfunction invalidateMount(hooks) {\n  if (hooks) {\n    for (let i = 0; i < hooks.length; i++)\n      hooks[i].flags |= 8;\n  }\n}\n\nconst ssrContextKey = Symbol.for(\"v-scx\");\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    if (!ctx) {\n       true && warn$1(\n        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`\n      );\n    }\n    return ctx;\n  }\n};\n\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n     true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, { flush: \"post\" }) : 0\n  );\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n     true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, { flush: \"sync\" }) : 0\n  );\n}\nfunction watch(source, cb, options) {\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {\n    warn$1(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only supports \\`watch(source, cb, options?) signature.`\n    );\n  }\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n  const { immediate, deep, flush, once } = options;\n  if ( true && !cb) {\n    if (immediate !== void 0) {\n      warn$1(\n        `watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (deep !== void 0) {\n      warn$1(\n        `watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (once !== void 0) {\n      warn$1(\n        `watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n  }\n  const baseWatchOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options);\n  if (true) baseWatchOptions.onWarn = warn$1;\n  const runsImmediately = cb && immediate || !cb && flush !== \"post\";\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    if (flush === \"sync\") {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else if (!runsImmediately) {\n      const watchStopHandle = () => {\n      };\n      watchStopHandle.stop = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n      watchStopHandle.resume = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n      watchStopHandle.pause = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n      return watchStopHandle;\n    }\n  }\n  const instance = currentInstance;\n  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);\n  let isPre = false;\n  if (flush === \"post\") {\n    baseWatchOptions.scheduler = (job) => {\n      queuePostRenderEffect(job, instance && instance.suspense);\n    };\n  } else if (flush !== \"sync\") {\n    isPre = true;\n    baseWatchOptions.scheduler = (job, isFirstRun) => {\n      if (isFirstRun) {\n        job();\n      } else {\n        queueJob(job);\n      }\n    };\n  }\n  baseWatchOptions.augmentJob = (job) => {\n    if (cb) {\n      job.flags |= 4;\n    }\n    if (isPre) {\n      job.flags |= 2;\n      if (instance) {\n        job.id = instance.uid;\n        job.i = instance;\n      }\n    }\n  };\n  const watchHandle = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.watch)(source, cb, baseWatchOptions);\n  if (isInSSRComponentSetup) {\n    if (ssrCleanup) {\n      ssrCleanup.push(watchHandle);\n    } else if (runsImmediately) {\n      watchHandle();\n    }\n  }\n  return watchHandle;\n}\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes(\".\") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const reset = setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  reset();\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split(\".\");\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\n\nfunction useModel(props, name, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n  const i = getCurrentInstance();\n  if ( true && !i) {\n    warn$1(`useModel() called without active instance.`);\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();\n  }\n  const camelizedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name);\n  if ( true && !i.propsOptions[0][camelizedName]) {\n    warn$1(`useModel() called with prop \"${name}\" which is not declared.`);\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();\n  }\n  const hyphenatedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name);\n  const modifiers = getModelModifiers(props, camelizedName);\n  const res = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef)((track, trigger) => {\n    let localValue;\n    let prevSetValue = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    let prevEmittedValue;\n    watchSyncEffect(() => {\n      const propValue = props[camelizedName];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(localValue, propValue)) {\n        localValue = propValue;\n        trigger();\n      }\n    });\n    return {\n      get() {\n        track();\n        return options.get ? options.get(localValue) : localValue;\n      },\n      set(value) {\n        const emittedValue = options.set ? options.set(value) : value;\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(emittedValue, localValue) && !(prevSetValue !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, prevSetValue))) {\n          return;\n        }\n        const rawProps = i.vnode.props;\n        if (!(rawProps && // check if parent has passed v-model\n        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {\n          localValue = value;\n          trigger();\n        }\n        i.emit(`update:${name}`, emittedValue);\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, emittedValue) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, prevSetValue) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(emittedValue, prevEmittedValue)) {\n          trigger();\n        }\n        prevSetValue = value;\n        prevEmittedValue = emittedValue;\n      }\n    };\n  });\n  res[Symbol.iterator] = () => {\n    let i2 = 0;\n    return {\n      next() {\n        if (i2 < 2) {\n          return { value: i2++ ? modifiers || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ : res, done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  };\n  return res;\n}\nconst getModelModifiers = (props, modelName) => {\n  return modelName === \"modelValue\" || modelName === \"model-value\" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(modelName)}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(modelName)}Modifiers`];\n};\n\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted) return;\n  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n  if (true) {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance;\n    if (emitsOptions) {\n      if (!(event in emitsOptions) && true) {\n        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)) in propsOptions)) {\n          warn$1(\n            `Component emitted event \"${event}\" but it is neither declared in the emits option nor as an \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))}\" prop.`\n          );\n        }\n      } else {\n        const validator = emitsOptions[event];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {\n          const isValid = validator(...rawArgs);\n          if (!isValid) {\n            warn$1(\n              `Invalid event arguments: event validation failed for event \"${event}\".`\n            );\n          }\n        }\n      }\n    }\n  }\n  let args = rawArgs;\n  const isModelListener = event.startsWith(\"update:\");\n  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));\n  if (modifiers) {\n    if (modifiers.trim) {\n      args = rawArgs.map((a) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(a) ? a.trim() : a);\n    }\n    if (modifiers.number) {\n      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber);\n    }\n  }\n  if (true) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n  if (true) {\n    const lowerCaseEvent = event.toLowerCase();\n    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {\n      warn$1(\n        `Event \"${lowerCaseEvent}\" is emitted in component ${formatComponentName(\n          instance,\n          instance.type\n        )} but the handler is registered for \"${event}\". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(\n          event\n        )}\" instead of \"${event}\".`\n      );\n    }\n  }\n  let handlerName;\n  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)\n  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))];\n  if (!handler && isModelListener) {\n    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(\n      handler,\n      instance,\n      6,\n      args\n    );\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(\n      onceHandler,\n      instance,\n      6,\n      args\n    );\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== void 0) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\n    const extendEmits = (raw2) => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n    raw.forEach((key) => normalized[key] = null);\n  } else {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\nfunction isEmitListener(options, key) {\n  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, \"\");\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);\n}\n\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    props,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  const prev = setCurrentRenderingInstance(instance);\n  let result;\n  let fallthroughAttrs;\n  if (true) {\n    accessedAttrs = false;\n  }\n  try {\n    if (vnode.shapeFlag & 4) {\n      const proxyToUse = withProxy || proxy;\n      const thisProxy =  true && setupState.__isScriptSetup ? new Proxy(proxyToUse, {\n        get(target, key, receiver) {\n          warn$1(\n            `Property '${String(\n              key\n            )}' was accessed via 'this'. Avoid using 'this' in templates.`\n          );\n          return Reflect.get(target, key, receiver);\n        }\n      }) : proxyToUse;\n      result = normalizeVNode(\n        render.call(\n          thisProxy,\n          proxyToUse,\n          renderCache,\n           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,\n          setupState,\n          data,\n          ctx\n        )\n      );\n      fallthroughAttrs = attrs;\n    } else {\n      const render2 = Component;\n      if ( true && attrs === props) {\n        markAttrsAccessed();\n      }\n      result = normalizeVNode(\n        render2.length > 1 ? render2(\n           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,\n           true ? {\n            get attrs() {\n              markAttrsAccessed();\n              return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(attrs);\n            },\n            slots,\n            emit\n          } : 0\n        ) : render2(\n           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,\n          null\n        )\n      );\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1);\n    result = createVNode(Comment);\n  }\n  let root = result;\n  let setRoot = void 0;\n  if ( true && result.patchFlag > 0 && result.patchFlag & 2048) {\n    [root, setRoot] = getChildRoot(result);\n  }\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const { shapeFlag } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 | 6)) {\n        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {\n          fallthroughAttrs = filterModelListeners(\n            fallthroughAttrs,\n            propsOptions\n          );\n        }\n        root = cloneVNode(root, fallthroughAttrs, false, true);\n      } else if ( true && !accessedAttrs && root.type !== Comment) {\n        const allAttrs = Object.keys(attrs);\n        const eventAttrs = [];\n        const extraAttrs = [];\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\n          const key = allAttrs[i];\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n            }\n          } else {\n            extraAttrs.push(key);\n          }\n        }\n        if (extraAttrs.length) {\n          warn$1(\n            `Extraneous non-props attributes (${extraAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`\n          );\n        }\n        if (eventAttrs.length) {\n          warn$1(\n            `Extraneous non-emits event listeners (${eventAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option.`\n          );\n        }\n      }\n    }\n  }\n  if (vnode.dirs) {\n    if ( true && !isElementRoot(root)) {\n      warn$1(\n        `Runtime directive used on component with non-element root node. The directives will not function as intended.`\n      );\n    }\n    root = cloneVNode(root, null, false, true);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  if (vnode.transition) {\n    if ( true && !isElementRoot(root)) {\n      warn$1(\n        `Component inside <Transition> renders non-element root node that cannot be animated.`\n      );\n    }\n    setTransitionHooks(root, vnode.transition);\n  }\n  if ( true && setRoot) {\n    setRoot(root);\n  } else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\nconst getChildRoot = (vnode) => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren, false);\n  if (!childRoot) {\n    return [vnode, void 0];\n  } else if ( true && childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {\n    return getChildRoot(childRoot);\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = (updatedRoot) => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children, recurse = true) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      if (child.type !== Comment || child.children === \"v-if\") {\n        if (singleRoot) {\n          return;\n        } else {\n          singleRoot = child;\n          if ( true && recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {\n            return filterSingleRoot(singleRoot.children);\n          }\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = (attrs) => {\n  let res;\n  for (const key in attrs) {\n    if (key === \"class\" || key === \"style\" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = (vnode) => {\n  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const { props: prevProps, children: prevChildren, component } = prevVNode;\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\n  const emits = component.emitsOptions;\n  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true;\n  }\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024) {\n      return true;\n    }\n    if (patchFlag & 16) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({ vnode, parent }, el) {\n  while (parent) {\n    const root = parent.subTree;\n    if (root.suspense && root.suspense.activeBranch === vnode) {\n      root.el = vnode.el;\n    }\n    if (root === vnode) {\n      (vnode = parent.vnode).el = el;\n      parent = parent.parent;\n    } else {\n      break;\n    }\n  }\n}\n\nconst isSuspense = (type) => type.__isSuspense;\nlet suspenseId = 0;\nconst SuspenseImpl = {\n  name: \"Suspense\",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    } else {\n      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {\n        n2.suspense = n1.suspense;\n        n2.suspense.vnode = n2;\n        n2.el = n1.el;\n        return;\n      }\n      patchSuspense(\n        n1,\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        namespace,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    }\n  },\n  hydrate: hydrateSuspense,\n  normalize: normalizeSuspenseChildren\n};\nconst Suspense = SuspenseImpl ;\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: { createElement }\n  } = rendererInternals;\n  const hiddenContainer = createElement(\"div\");\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    container,\n    hiddenContainer,\n    anchor,\n    namespace,\n    slotScopeIds,\n    optimized,\n    rendererInternals\n  );\n  patch(\n    null,\n    suspense.pendingBranch = vnode.ssContent,\n    hiddenContainer,\n    null,\n    parentComponent,\n    suspense,\n    namespace,\n    slotScopeIds\n  );\n  if (suspense.deps > 0) {\n    triggerEvent(vnode, \"onPending\");\n    triggerEvent(vnode, \"onFallback\");\n    patch(\n      null,\n      vnode.ssFallback,\n      container,\n      anchor,\n      parentComponent,\n      null,\n      // fallback tree will not have suspense context\n      namespace,\n      slotScopeIds\n    );\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    suspense.resolve(false, true);\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      patch(\n        pendingBranch,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        if (!isHydrating) {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      }\n    } else {\n      suspense.pendingId = suspenseId++;\n      if (isHydrating) {\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      suspense.deps = 0;\n      suspense.effects.length = 0;\n      suspense.hiddenContainer = createElement(\"div\");\n      if (isInFallback) {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        patch(\n          activeBranch,\n          newBranch,\n          container,\n          anchor,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        suspense.resolve(true);\n      } else {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      patch(\n        activeBranch,\n        newBranch,\n        container,\n        anchor,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      setActiveBranch(suspense, newBranch);\n    } else {\n      triggerEvent(n2, \"onPending\");\n      suspense.pendingBranch = newBranch;\n      if (newBranch.shapeFlag & 512) {\n        suspense.pendingId = newBranch.component.suspenseId;\n      } else {\n        suspense.pendingId = suspenseId++;\n      }\n      patch(\n        null,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else {\n        const { timeout, pendingId } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  if ( true && !hasWarned) {\n    hasWarned = true;\n    console[console.info ? \"info\" : \"log\"](\n      `<Suspense> is an experimental feature and its API will likely change.`\n    );\n  }\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: { parentNode, remove }\n  } = rendererInternals;\n  let parentSuspenseId;\n  const isSuspensible = isVNodeSuspensible(vnode);\n  if (isSuspensible) {\n    if (parentSuspense && parentSuspense.pendingBranch) {\n      parentSuspenseId = parentSuspense.pendingId;\n      parentSuspense.deps++;\n    }\n  }\n  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props.timeout) : void 0;\n  if (true) {\n    assertNumber(timeout, `Suspense timeout`);\n  }\n  const initialAnchor = anchor;\n  const suspense = {\n    vnode,\n    parent: parentSuspense,\n    parentComponent,\n    namespace,\n    container,\n    hiddenContainer,\n    deps: 0,\n    pendingId: suspenseId++,\n    timeout: typeof timeout === \"number\" ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: !isHydrating,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false, sync = false) {\n      if (true) {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(\n            `suspense.resolve() is called without a pending branch.`\n          );\n        }\n        if (suspense.isUnmounted) {\n          throw new Error(\n            `suspense.resolve() is called on an already unmounted suspense boundary.`\n          );\n        }\n      }\n      const {\n        vnode: vnode2,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent: parentComponent2,\n        container: container2\n      } = suspense;\n      let delayEnter = false;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === \"out-in\";\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(\n                pendingBranch,\n                container2,\n                anchor === initialAnchor ? next(activeBranch) : anchor,\n                0\n              );\n              queuePostFlushCb(effects);\n            }\n          };\n        }\n        if (activeBranch) {\n          if (parentNode(activeBranch.el) === container2) {\n            anchor = next(activeBranch);\n          }\n          unmount(activeBranch, parentComponent2, suspense, true);\n        }\n        if (!delayEnter) {\n          move(pendingBranch, container2, anchor, 0);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!hasUnresolvedAncestor && !delayEnter) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      if (isSuspensible) {\n        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {\n          parentSuspense.deps--;\n          if (parentSuspense.deps === 0 && !sync) {\n            parentSuspense.resolve();\n          }\n        }\n      }\n      triggerEvent(vnode2, \"onResolve\");\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;\n      triggerEvent(vnode2, \"onFallback\");\n      const anchor2 = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        patch(\n          null,\n          fallbackVNode,\n          container2,\n          anchor2,\n          parentComponent2,\n          null,\n          // fallback tree will not have suspense context\n          namespace2,\n          slotScopeIds,\n          optimized\n        );\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \"out-in\";\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      unmount(\n        activeBranch,\n        parentComponent2,\n        null,\n        // no suspense so unmount hooks fire now\n        true\n        // shouldRemove\n      );\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container2, anchor2, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);\n      suspense.container = container2;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect, optimized2) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch((err) => {\n        handleError(err, instance, 0);\n      }).then((asyncSetupResult) => {\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        instance.asyncResolved = true;\n        const { vnode: vnode2 } = instance;\n        if (true) {\n          pushWarningContext(vnode2);\n        }\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          vnode2.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(\n          instance,\n          vnode2,\n          // component may have been moved before resolve.\n          // if this is not a hydration, instance.subTree will be the comment\n          // placeholder.\n          parentNode(hydratedEl || instance.subTree.el),\n          // anchor will not be used if this is hydration, so only need to\n          // consider the comment placeholder case.\n          hydratedEl ? null : next(instance.subTree),\n          suspense,\n          namespace,\n          optimized2\n        );\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode2.el);\n        if (true) {\n          popWarningContext();\n        }\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense2, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(\n          suspense.activeBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n      if (suspense.pendingBranch) {\n        unmount(\n          suspense.pendingBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    node.parentNode,\n    // eslint-disable-next-line no-restricted-globals\n    document.createElement(\"div\"),\n    null,\n    namespace,\n    slotScopeIds,\n    optimized,\n    rendererInternals,\n    true\n  );\n  const result = hydrateNode(\n    node,\n    suspense.pendingBranch = vnode.ssContent,\n    parentComponent,\n    suspense,\n    slotScopeIds,\n    optimized\n  );\n  if (suspense.deps === 0) {\n    suspense.resolve(false, true);\n  }\n  return result;\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const { shapeFlag, children } = vnode;\n  const isSlotChildren = shapeFlag & 32;\n  vnode.ssContent = normalizeSuspenseSlot(\n    isSlotChildren ? children.default : children\n  );\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {\n    const singleChild = filterSingleRoot(s);\n    if ( true && !singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {\n      warn$1(`<Suspense> slots expect a single root node.`);\n    }\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter((c) => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const { vnode, parentComponent } = suspense;\n  let el = branch.el;\n  while (!el && branch.component) {\n    branch = branch.component.subTree;\n    el = branch.el;\n  }\n  vnode.el = el;\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction isVNodeSuspensible(vnode) {\n  const suspensible = vnode.props && vnode.props.suspensible;\n  return suspensible != null && suspensible !== false;\n}\n\nconst Fragment = Symbol.for(\"v-fgt\");\nconst Text = Symbol.for(\"v-txt\");\nconst Comment = Symbol.for(\"v-cmt\");\nconst Static = Symbol.for(\"v-stc\");\nconst blockStack = [];\nlet currentBlock = null;\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\nlet isBlockTreeEnabled = 1;\nfunction setBlockTracking(value, inVOnce = false) {\n  isBlockTreeEnabled += value;\n  if (value < 0 && currentBlock && inVOnce) {\n    currentBlock.hasOnce = true;\n  }\n}\nfunction setupBlock(vnode) {\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;\n  closeBlock();\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true\n    )\n  );\n}\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(\n    createVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      true\n    )\n  );\n}\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  if ( true && n2.shapeFlag & 6 && n1.component) {\n    const dirtyInstances = hmrDirtyComponents.get(n2.type);\n    if (dirtyInstances && dirtyInstances.has(n1.component)) {\n      n1.shapeFlag &= ~256;\n      n2.shapeFlag &= ~512;\n      return false;\n    }\n  }\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(\n    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args\n  );\n};\nconst normalizeKey = ({ key }) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  if (typeof ref === \"number\") {\n    ref = \"\" + ref;\n  }\n  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetStart: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    if (shapeFlag & 128) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children) ? 8 : 16;\n  }\n  if ( true && vnode.key !== vnode.key) {\n    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n  }\n  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself\n  !isBlockNode && // has current parent block\n  currentBlock && // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst createVNode =  true ? createVNodeWithArgsTransform : 0;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if ( true && !type) {\n      warn$1(`Invalid vnode type when creating vnode: ${type}.`);\n    }\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    const cloned = cloneVNode(\n      type,\n      props,\n      true\n      /* mergeRef: true */\n    );\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag = -2;\n    return cloned;\n  }\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  if (props) {\n    props = guardReactiveProps(props);\n    let { class: klass, style } = props;\n    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {\n      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {\n      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {\n        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);\n      }\n      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);\n    }\n  }\n  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2 : 0;\n  if ( true && shapeFlag & 4 && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {\n    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);\n    warn$1(\n      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \\`markRaw\\` or using \\`shallowRef\\` instead of \\`ref\\`.`,\n      `\nComponent that was made reactive: `,\n      type\n    );\n  }\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  );\n}\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || isInternalObject(props) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {\n  const { props, ref, patchFlag, children, transition } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ? (\n      // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n      // if the vnode itself already has a ref, cloneVNode will need to merge\n      // the refs so the single vnode can be set on multiple refs\n      mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)\n    ) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children:  true && patchFlag === -1 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,\n    target: vnode.target,\n    targetStart: vnode.targetStart,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  if (transition && cloneTransition) {\n    setTransitionHooks(\n      cloned,\n      transition.clone(cloned)\n    );\n  }\n  return cloned;\n}\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\nfunction createTextVNode(text = \" \", flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\nfunction createStaticVNode(content, numberOfNodes) {\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nfunction createCommentVNode(text = \"\", asBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === \"boolean\") {\n    return createVNode(Comment);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {\n    return createVNode(\n      Fragment,\n      null,\n      // #3666, avoid reference pollution when reusing vnode\n      child.slice()\n    );\n  } else if (isVNode(child)) {\n    return cloneIfMounted(child);\n  } else {\n    return createVNode(Text, null, String(child));\n  }\n}\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const { shapeFlag } = vnode;\n  if (children == null) {\n    children = null;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {\n    type = 16;\n  } else if (typeof children === \"object\") {\n    if (shapeFlag & (1 | 64)) {\n      const slot = children.default;\n      if (slot) {\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32;\n      const slotFlag = children._;\n      if (!slotFlag && !isInternalObject(children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 && currentRenderingInstance) {\n        if (currentRenderingInstance.slots._ === 1) {\n          children._ = 1;\n        } else {\n          children._ = 2;\n          vnode.patchFlag |= 1024;\n        }\n      }\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {\n    children = { default: children, _ctx: currentRenderingInstance };\n    type = 32;\n  } else {\n    children = String(children);\n    if (shapeFlag & 64) {\n      type = 16;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === \"class\") {\n        if (ret.class !== toMerge.class) {\n          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);\n        }\n      } else if (key === \"style\") {\n        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== \"\") {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7, [\n    vnode,\n    prevVNode\n  ]);\n}\n\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    job: null,\n    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(\n      true\n      /* detached */\n    ),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    ids: parent ? parent.ids : [\"\", 0, 0],\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n    setupContext: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (true) {\n    instance.ctx = createDevRenderContext(instance);\n  } else {}\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nlet internalSetCurrentInstance;\nlet setInSSRSetupState;\n{\n  const g = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();\n  const registerGlobalSetter = (key, setter) => {\n    let setters;\n    if (!(setters = g[key])) setters = g[key] = [];\n    setters.push(setter);\n    return (v) => {\n      if (setters.length > 1) setters.forEach((set) => set(v));\n      else setters[0](v);\n    };\n  };\n  internalSetCurrentInstance = registerGlobalSetter(\n    `__VUE_INSTANCE_SETTERS__`,\n    (v) => currentInstance = v\n  );\n  setInSSRSetupState = registerGlobalSetter(\n    `__VUE_SSR_SETTERS__`,\n    (v) => isInSSRComponentSetup = v\n  );\n}\nconst setCurrentInstance = (instance) => {\n  const prev = currentInstance;\n  internalSetCurrentInstance(instance);\n  instance.scope.on();\n  return () => {\n    instance.scope.off();\n    internalSetCurrentInstance(prev);\n  };\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  internalSetCurrentInstance(null);\n};\nconst isBuiltInTag = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(\"slot,component\");\nfunction validateComponentName(name, { isNativeTag }) {\n  if (isBuiltInTag(name) || isNativeTag(name)) {\n    warn$1(\n      \"Do not use built-in or reserved HTML elements as component id: \" + name\n    );\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false, optimized = false) {\n  isSSR && setInSSRSetupState(isSSR);\n  const { props, children } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children, optimized);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;\n  isSSR && setInSSRSetupState(false);\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (true) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config);\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components);\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config);\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives);\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i]);\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn$1(\n        `\"compilerOptions\" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`\n      );\n    }\n  }\n  instance.accessCache = /* @__PURE__ */ Object.create(null);\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  if (true) {\n    exposePropsOnRenderContext(instance);\n  }\n  const { setup } = Component;\n  if (setup) {\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    const reset = setCurrentInstance(instance);\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      0,\n      [\n         true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0,\n        setupContext\n      ]\n    );\n    const isAsyncSetup = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n    reset();\n    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {\n      markAsyncBoundary(instance);\n    }\n    if (isAsyncSetup) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        return setupResult.then((resolvedResult) => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch((e) => {\n          handleError(e, instance, 0);\n        });\n      } else {\n        instance.asyncDep = setupResult;\n        if ( true && !instance.suspense) {\n          const name = (_a = Component.name) != null ? _a : \"Anonymous\";\n          warn$1(\n            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`\n          );\n        }\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {\n    if (instance.type.__ssrInlineRender) {\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {\n    if ( true && isVNode(setupResult)) {\n      warn$1(\n        `setup() should not return VNodes directly - return a render function instead.`\n      );\n    }\n    if (true) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);\n    if (true) {\n      exposeSetupStateOnRenderContext(instance);\n    }\n  } else if ( true && setupResult !== void 0) {\n    warn$1(\n      `setup() should return an object. Received: ${setupResult === null ? \"null\" : typeof setupResult}`\n    );\n  }\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = (i) => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  if (!instance.render) {\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || __VUE_OPTIONS_API__ && resolveMergedOptions(instance).template;\n      if (template) {\n        if (true) {\n          startMeasure(instance, `compile`);\n        }\n        const { isCustomElement, compilerOptions } = instance.appContext.config;\n        const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(\n            {\n              isCustomElement,\n              delimiters\n            },\n            compilerOptions\n          ),\n          componentCompilerOptions\n        );\n        Component.render = compile(template, finalCompilerOptions);\n        if (true) {\n          endMeasure(instance, `compile`);\n        }\n      }\n    }\n    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  if (__VUE_OPTIONS_API__ && true) {\n    const reset = setCurrentInstance(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n    try {\n      applyOptions(instance);\n    } finally {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n      reset();\n    }\n  }\n  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {\n    if (!compile && Component.template) {\n      warn$1(\n        `Component provided template option but runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".` )\n      );\n    } else {\n      warn$1(`Component is missing template or render function: `, Component);\n    }\n  }\n}\nconst attrsProxyHandlers =  true ? {\n  get(target, key) {\n    markAttrsAccessed();\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(target, \"get\", \"\");\n    return target[key];\n  },\n  set() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  },\n  deleteProperty() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  }\n} : 0;\nfunction getSlotsProxy(instance) {\n  return new Proxy(instance.slots, {\n    get(target, key) {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, \"get\", \"$slots\");\n      return target[key];\n    }\n  });\n}\nfunction createSetupContext(instance) {\n  const expose = (exposed) => {\n    if (true) {\n      if (instance.exposed) {\n        warn$1(`expose() should be called only once per setup().`);\n      }\n      if (exposed != null) {\n        let exposedType = typeof exposed;\n        if (exposedType === \"object\") {\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(exposed)) {\n            exposedType = \"array\";\n          } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(exposed)) {\n            exposedType = \"ref\";\n          }\n        }\n        if (exposedType !== \"object\") {\n          warn$1(\n            `expose() should be passed a plain object, received ${exposedType}.`\n          );\n        }\n      }\n    }\n    instance.exposed = exposed || {};\n  };\n  if (true) {\n    let attrsProxy;\n    let slotsProxy;\n    return Object.freeze({\n      get attrs() {\n        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));\n      },\n      get slots() {\n        return slotsProxy || (slotsProxy = getSlotsProxy(instance));\n      },\n      get emit() {\n        return (event, ...args) => instance.emit(event, ...args);\n      },\n      expose\n    });\n  } else {}\n}\nfunction getComponentPublicInstance(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  } else {\n    return instance.proxy;\n  }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, \"\");\nfunction getComponentName(Component, includeInferred = true) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    const inferFromRegistry = (registry) => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(\n      instance.components || instance.parent.type.components\n    ) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && \"__vccOpts\" in value;\n}\n\nconst computed = (getterOrOptions, debugOptions) => {\n  const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);\n  if (true) {\n    const i = getCurrentInstance();\n    if (i && i.appContext.config.warnRecursiveComputed) {\n      c._warnRecursive = true;\n    }\n  }\n  return c;\n};\n\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      }\n      return createVNode(type, propsOrChildren);\n    } else {\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return createVNode(type, propsOrChildren, children);\n  }\n}\n\nfunction initCustomFormatter() {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const vueStyle = { style: \"color:#3ba776\" };\n  const numberStyle = { style: \"color:#1677ff\" };\n  const stringStyle = { style: \"color:#f5222d\" };\n  const keywordStyle = { style: \"color:#eb2f96\" };\n  const formatter = {\n    __vue_custom_formatter: true,\n    header(obj) {\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return [\"div\", vueStyle, `VueInstance`];\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, genRefFlag(obj)],\n          \"<\",\n          // avoid debugger accessing value affecting behavior\n          formatValue(\"_value\" in obj ? obj._value : obj),\n          `>`\n        ];\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(obj) ? \"ShallowReactive\" : \"Reactive\"],\n          \"<\",\n          formatValue(obj),\n          `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`\n        ];\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(obj) ? \"ShallowReadonly\" : \"Readonly\"],\n          \"<\",\n          formatValue(obj),\n          \">\"\n        ];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return [\n          \"div\",\n          {},\n          ...formatInstance(obj.$)\n        ];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock(\"props\", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));\n    }\n    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"setup\", instance.setupState));\n    }\n    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"data\", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));\n    }\n    const computed = extractKeys(instance, \"computed\");\n    if (computed) {\n      blocks.push(createInstanceBlock(\"computed\", computed));\n    }\n    const injected = extractKeys(instance, \"inject\");\n    if (injected) {\n      blocks.push(createInstanceBlock(\"injected\", injected));\n    }\n    blocks.push([\n      \"div\",\n      {},\n      [\n        \"span\",\n        {\n          style: keywordStyle.style + \";opacity:0.66\"\n        },\n        \"$ (internal): \"\n      ],\n      [\"object\", { object: instance }]\n    ]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);\n    if (!Object.keys(target).length) {\n      return [\"span\", {}];\n    }\n    return [\n      \"div\",\n      { style: \"line-height:1.25em;margin-bottom:0.6em\" },\n      [\n        \"div\",\n        {\n          style: \"color:#476582\"\n        },\n        type\n      ],\n      [\n        \"div\",\n        {\n          style: \"padding-left:1.25em\"\n        },\n        ...Object.keys(target).map((key) => {\n          return [\n            \"div\",\n            {},\n            [\"span\", keywordStyle, key + \": \"],\n            formatValue(target[key], false)\n          ];\n        })\n      ]\n    ];\n  }\n  function formatValue(v, asRaw = true) {\n    if (typeof v === \"number\") {\n      return [\"span\", numberStyle, v];\n    } else if (typeof v === \"string\") {\n      return [\"span\", stringStyle, JSON.stringify(v)];\n    } else if (typeof v === \"boolean\") {\n      return [\"span\", keywordStyle, v];\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {\n      return [\"object\", { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];\n    } else {\n      return [\"span\", stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\n\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  ret.memo = memo.slice();\n  ret.cacheIndex = index;\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\n\nconst version = \"3.5.13\";\nconst warn =  true ? warn$1 : 0;\nconst ErrorTypeStrings = ErrorTypeStrings$1 ;\nconst devtools =  true ? devtools$1 : 0;\nconst setDevtoolsHook =  true ? setDevtoolsHook$1 : 0;\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode: isVNode,\n  normalizeVNode,\n  getComponentPublicInstance,\n  ensureValidVNode,\n  pushWarningContext,\n  popWarningContext\n};\nconst ssrUtils = _ssrUtils ;\nconst resolveFilter = null;\nconst compatUtils = null;\nconst DeprecationTypes = null;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOFY7QUFDMEM7QUFDZ0o7QUFDdFo7O0FBRWxJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhEQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWEsT0FBTyxZQUFZLDBDQUEwQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOERBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsWUFBWSxLQUEwQyxFQUFFLEVBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFPO0FBQ2Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsNEJBQTRCLGlCQUFpQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBeUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBaUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQVE7QUFDeEMsTUFBTSxJQUF5QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUF5QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0dBQStHO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxZQUFZLElBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU0sU0FBUyxxREFBUTtBQUN2QiwwQkFBMEIsZ0JBQWdCLHNEQUFLLFNBQVM7QUFDeEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQU8sZ0NBQWdDLHFEQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkMsUUFBUSx1REFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxLQUF5QyxZQUFZLENBQUk7QUFDdEU7QUFDQSxpQkFBaUIsS0FBaUQsZ0JBQWdCLENBQU07QUFDeEYsd0JBQXdCLEtBQWlELHVCQUF1QixDQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzP2QyZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEB2dWUvcnVudGltZS1jb3JlIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgdHJhdmVyc2UsIHNoYWxsb3dSZWYsIHJlYWRvbmx5LCBpc1JlYWN0aXZlLCByZWYsIGlzU2hhbGxvdywgc2hhbGxvd1JlYWRBcnJheSwgdG9SZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgUmVhY3RpdmVFZmZlY3QsIHdhdGNoIGFzIHdhdGNoJDEsIGN1c3RvbVJlZiwgaXNQcm94eSwgcHJveHlSZWZzLCBtYXJrUmF3LCBFZmZlY3RTY29wZSwgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBnZXRDdXJyZW50V2F0Y2hlciwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgRU1QVFlfT0JKLCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaGFzT3duLCByZW1vdmUsIGRlZiwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIG5vcm1hbGl6ZUNsYXNzLCBzdHJpbmdpZnlTdHlsZSwgbm9ybWFsaXplU3R5bGUsIGlzS25vd25TdmdBdHRyLCBpc0Jvb2xlYW5BdHRyLCBpc0tub3duSHRtbEF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgaXNPYmplY3QsIGlzUmVnRXhwLCBpbnZva2VBcnJheUZucywgdG9IYW5kbGVyS2V5LCBjYXBpdGFsaXplLCBjYW1lbGl6ZSwgaXNTeW1ib2wsIGlzR2xvYmFsbHlBbGxvd2VkLCBOTywgaHlwaGVuYXRlLCBFTVBUWV9BUlIsIHRvUmF3VHlwZSwgbWFrZU1hcCwgaGFzQ2hhbmdlZCwgbG9vc2VUb051bWJlciwgaXNNb2RlbExpc3RlbmVyLCB0b051bWJlciB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xuICBzdGFjay5wdXNoKHZub2RlKTtcbn1cbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xuICBzdGFjay5wb3AoKTtcbn1cbmxldCBpc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm4kMShtc2csIC4uLmFyZ3MpIHtcbiAgaWYgKGlzV2FybmluZykgcmV0dXJuO1xuICBpc1dhcm5pbmcgPSB0cnVlO1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcbiAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcbiAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xuICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBhcHBXYXJuSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMTEsXG4gICAgICBbXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBtc2cgKyBhcmdzLm1hcCgoYSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGEudG9TdHJpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGEpKSAhPSBudWxsID8gX2IgOiBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgICAgfSkuam9pbihcIlwiKSxcbiAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXG4gICAgICAgIHRyYWNlLm1hcChcbiAgICAgICAgICAoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmBcbiAgICAgICAgKS5qb2luKFwiXFxuXCIpLFxuICAgICAgICB0cmFjZVxuICAgICAgXVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xuICAgIGlmICh0cmFjZS5sZW5ndGggJiYgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcbiAgICB0cnVlKSB7XG4gICAgICB3YXJuQXJncy5wdXNoKGBcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XG4gIH1cbiAgcmVzZXRUcmFja2luZygpO1xuICBpc1dhcm5pbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xuICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XG4gICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcbiAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcbiAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcbiAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xuICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkU3RhY2s7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xuICBjb25zdCBsb2dzID0gW107XG4gIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgbG9ncy5wdXNoKC4uLmkgPT09IDAgPyBbXSA6IFtgXG5gXSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xuICB9KTtcbiAgcmV0dXJuIGxvZ3M7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XG4gIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XG4gIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgIHZub2RlLmNvbXBvbmVudCxcbiAgICB2bm9kZS50eXBlLFxuICAgIGlzUm9vdFxuICApfWA7XG4gIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcbiAgcmV0dXJuIHZub2RlLnByb3BzID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdIDogW29wZW4gKyBjbG9zZV07XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xuICB9KTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMykge1xuICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSByZXR1cm47XG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgd2FybiQxKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgTmFOIC0gdGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LmApO1xuICB9XG59XG5cbmNvbnN0IEVycm9yQ29kZXMgPSB7XG4gIFwiU0VUVVBfRlVOQ1RJT05cIjogMCxcbiAgXCIwXCI6IFwiU0VUVVBfRlVOQ1RJT05cIixcbiAgXCJSRU5ERVJfRlVOQ1RJT05cIjogMSxcbiAgXCIxXCI6IFwiUkVOREVSX0ZVTkNUSU9OXCIsXG4gIFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIjogNSxcbiAgXCI1XCI6IFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIixcbiAgXCJDT01QT05FTlRfRVZFTlRfSEFORExFUlwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRfRVZFTlRfSEFORExFUlwiLFxuICBcIlZOT0RFX0hPT0tcIjogNyxcbiAgXCI3XCI6IFwiVk5PREVfSE9PS1wiLFxuICBcIkRJUkVDVElWRV9IT09LXCI6IDgsXG4gIFwiOFwiOiBcIkRJUkVDVElWRV9IT09LXCIsXG4gIFwiVFJBTlNJVElPTl9IT09LXCI6IDksXG4gIFwiOVwiOiBcIlRSQU5TSVRJT05fSE9PS1wiLFxuICBcIkFQUF9FUlJPUl9IQU5ETEVSXCI6IDEwLFxuICBcIjEwXCI6IFwiQVBQX0VSUk9SX0hBTkRMRVJcIixcbiAgXCJBUFBfV0FSTl9IQU5ETEVSXCI6IDExLFxuICBcIjExXCI6IFwiQVBQX1dBUk5fSEFORExFUlwiLFxuICBcIkZVTkNUSU9OX1JFRlwiOiAxMixcbiAgXCIxMlwiOiBcIkZVTkNUSU9OX1JFRlwiLFxuICBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIjogMTMsXG4gIFwiMTNcIjogXCJBU1lOQ19DT01QT05FTlRfTE9BREVSXCIsXG4gIFwiU0NIRURVTEVSXCI6IDE0LFxuICBcIjE0XCI6IFwiU0NIRURVTEVSXCIsXG4gIFwiQ09NUE9ORU5UX1VQREFURVwiOiAxNSxcbiAgXCIxNVwiOiBcIkNPTVBPTkVOVF9VUERBVEVcIixcbiAgXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCI6IDE2LFxuICBcIjE2XCI6IFwiQVBQX1VOTU9VTlRfQ0xFQU5VUFwiXG59O1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyQxID0ge1xuICBbXCJzcFwiXTogXCJzZXJ2ZXJQcmVmZXRjaCBob29rXCIsXG4gIFtcImJjXCJdOiBcImJlZm9yZUNyZWF0ZSBob29rXCIsXG4gIFtcImNcIl06IFwiY3JlYXRlZCBob29rXCIsXG4gIFtcImJtXCJdOiBcImJlZm9yZU1vdW50IGhvb2tcIixcbiAgW1wibVwiXTogXCJtb3VudGVkIGhvb2tcIixcbiAgW1wiYnVcIl06IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcbiAgW1widVwiXTogXCJ1cGRhdGVkXCIsXG4gIFtcImJ1bVwiXTogXCJiZWZvcmVVbm1vdW50IGhvb2tcIixcbiAgW1widW1cIl06IFwidW5tb3VudGVkIGhvb2tcIixcbiAgW1wiYVwiXTogXCJhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJkYVwiXTogXCJkZWFjdGl2YXRlZCBob29rXCIsXG4gIFtcImVjXCJdOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxuICBbXCJydGNcIl06IFwicmVuZGVyVHJhY2tlZCBob29rXCIsXG4gIFtcInJ0Z1wiXTogXCJyZW5kZXJUcmlnZ2VyZWQgaG9va1wiLFxuICBbMF06IFwic2V0dXAgZnVuY3Rpb25cIixcbiAgWzFdOiBcInJlbmRlciBmdW5jdGlvblwiLFxuICBbMl06IFwid2F0Y2hlciBnZXR0ZXJcIixcbiAgWzNdOiBcIndhdGNoZXIgY2FsbGJhY2tcIixcbiAgWzRdOiBcIndhdGNoZXIgY2xlYW51cCBmdW5jdGlvblwiLFxuICBbNV06IFwibmF0aXZlIGV2ZW50IGhhbmRsZXJcIixcbiAgWzZdOiBcImNvbXBvbmVudCBldmVudCBoYW5kbGVyXCIsXG4gIFs3XTogXCJ2bm9kZSBob29rXCIsXG4gIFs4XTogXCJkaXJlY3RpdmUgaG9va1wiLFxuICBbOV06IFwidHJhbnNpdGlvbiBob29rXCIsXG4gIFsxMF06IFwiYXBwIGVycm9ySGFuZGxlclwiLFxuICBbMTFdOiBcImFwcCB3YXJuSGFuZGxlclwiLFxuICBbMTJdOiBcInJlZiBmdW5jdGlvblwiLFxuICBbMTNdOiBcImFzeW5jIGNvbXBvbmVudCBsb2FkZXJcIixcbiAgWzE0XTogXCJzY2hlZHVsZXIgZmx1c2hcIixcbiAgWzE1XTogXCJjb21wb25lbnQgdXBkYXRlXCIsXG4gIFsxNl06IFwiYXBwIHVubW91bnQgY2xlYW51cCBmdW5jdGlvblwiXG59O1xuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBJbnZhbGlkIHZhbHVlIHR5cGUgcGFzc2VkIHRvIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKCk6ICR7dHlwZW9mIGZufWBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcbiAgY29uc3QgeyBlcnJvckhhbmRsZXIsIHRocm93VW5oYW5kbGVkRXJyb3JJblByb2R1Y3Rpb24gfSA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnIHx8IEVNUFRZX09CSjtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBlcnJvckluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdIDogYGh0dHBzOi8vdnVlanMub3JnL2Vycm9yLXJlZmVyZW5jZS8jcnVudGltZS0ke3R5cGV9YDtcbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XG4gICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgfVxuICAgIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhlcnJvckhhbmRsZXIsIG51bGwsIDEwLCBbXG4gICAgICAgIGVycixcbiAgICAgICAgZXhwb3NlZEluc3RhbmNlLFxuICAgICAgICBlcnJvckluZm9cbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbik7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUsIHRocm93SW5Qcm9kID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgIH1cbiAgICB3YXJuJDEoYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhyb3dJblByb2QpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgZmx1c2hJbmRleCA9IC0xO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+Pj4gMTtcbiAgICBjb25zdCBtaWRkbGVKb2IgPSBxdWV1ZVttaWRkbGVdO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQobWlkZGxlSm9iKTtcbiAgICBpZiAobWlkZGxlSm9iSWQgPCBpZCB8fCBtaWRkbGVKb2JJZCA9PT0gaWQgJiYgbWlkZGxlSm9iLmZsYWdzICYgMikge1xuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBtaWRkbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIShqb2IuZmxhZ3MgJiAxKSkge1xuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcbiAgICBjb25zdCBsYXN0Sm9iID0gcXVldWVbcXVldWUubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFsYXN0Sm9iIHx8IC8vIGZhc3QgcGF0aCB3aGVuIHRoZSBqb2IgaWQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRhaWxcbiAgICAhKGpvYi5mbGFncyAmIDIpICYmIGpvYklkID49IGdldElkKGxhc3RKb2IpKSB7XG4gICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iSWQpLCAwLCBqb2IpO1xuICAgIH1cbiAgICBqb2IuZmxhZ3MgfD0gMTtcbiAgICBxdWV1ZUZsdXNoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghY3VycmVudEZsdXNoUHJvbWlzZSkge1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gIGlmICghaXNBcnJheShjYikpIHtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzICYmIGNiLmlkID09PSAtMSkge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNwbGljZShwb3N0Rmx1c2hJbmRleCArIDEsIDAsIGNiKTtcbiAgICB9IGVsc2UgaWYgKCEoY2IuZmxhZ3MgJiAxKSkge1xuICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICAgIGNiLmZsYWdzIHw9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gIH1cbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSwgc2VlbiwgaSA9IGZsdXNoSW5kZXggKyAxKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2IgPSBxdWV1ZVtpXTtcbiAgICBpZiAoY2IgJiYgY2IuZmxhZ3MgJiAyKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgJiYgY2IuaWQgIT09IGluc3RhbmNlLnVpZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICBpLS07XG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgICAgY2IoKTtcbiAgICAgIGlmICghKGNiLmZsYWdzICYgNCkpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV0uc29ydChcbiAgICAgIChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpXG4gICAgKTtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGNiID0gYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA4KSkgY2IoKTtcbiAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IGpvYi5mbGFncyAmIDIgPyAtMSA6IEluZmluaXR5IDogam9iLmlkO1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbnN0IGNoZWNrID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IChqb2IpID0+IGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpIDogTk9PUDtcbiAgdHJ5IHtcbiAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYiAmJiAhKGpvYi5mbGFncyAmIDgpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrKGpvYikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9iLmZsYWdzICYgNCkge1xuICAgICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICAgICAgam9iLFxuICAgICAgICAgIGpvYi5pLFxuICAgICAgICAgIGpvYi5pID8gMTUgOiAxNFxuICAgICAgICApO1xuICAgICAgICBpZiAoIShqb2IuZmxhZ3MgJiA0KSkge1xuICAgICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaEluZGV4ID0gLTE7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbiAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbikgfHwgMDtcbiAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBmbi5pO1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xuICAgIGhhbmRsZUVycm9yKFxuICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmAsXG4gICAgICBudWxsLFxuICAgICAgMTBcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gIH07XG59XG5jb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gIGlmIChtYXAuaGFzKGlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXAuc2V0KGlkLCB7XG4gICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSByZXR1cm47XG4gIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcbiAgdXBkYXRlQ29tcG9uZW50RGVmKHJlY29yZC5pbml0aWFsRGVmLCBuZXdDb21wKTtcbiAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcbiAgICBsZXQgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG9sZENvbXApO1xuICAgIGlmICghZGlydHlJbnN0YW5jZXMpIHtcbiAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xuICAgICAgICB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgICB9XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuc2V0KG9sZENvbXAsIGRpcnR5SW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5wcm9wc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LmVtaXRzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG4gICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XG4gICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBxdWV1ZUpvYigoKSA9PiB7XG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgZGlydHlJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcbiAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uucm9vdC5jZSAmJiBpbnN0YW5jZSAhPT0gaW5zdGFuY2Uucm9vdCkge1xuICAgICAgaW5zdGFuY2Uucm9vdC5jZS5fcmVtb3ZlQ2hpbGRTdHlsZShvbGRDb21wKTtcbiAgICB9XG4gIH1cbiAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgaG1yRGlydHlDb21wb25lbnRzLmNsZWFyKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgaWYgKGtleSAhPT0gXCJfX2ZpbGVcIiAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBkZXZ0b29scyQxO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayQxKGhvb2ssIHRhcmdldCkge1xuICB2YXIgX2EsIF9iO1xuICBkZXZ0b29scyQxID0gaG9vaztcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVuYWJsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcbiAgICAvLyAoIzQ4MTUpXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJiAvLyBhbHNvIGV4Y2x1ZGUganNkb21cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAhKChfYiA9IChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS51c2VyQWdlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcImpzZG9tXCIpKVxuICApIHtcbiAgICBjb25zdCByZXBsYXkgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdO1xuICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XG4gICAgICBzZXREZXZ0b29sc0hvb2skMShuZXdIb29rLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFkZXZ0b29scyQxKSB7XG4gICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9LCAzZTMpO1xuICB9IGVsc2Uge1xuICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICBGcmFnbWVudCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgU3RhdGljXG4gIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi8pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgaWYgKGRldnRvb2xzJDEgJiYgdHlwZW9mIGRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAhZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gIH1cbn07XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgIGVtaXQkMShcbiAgICAgIGhvb2ssXG4gICAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgICBjb21wb25lbnQudWlkLFxuICAgICAgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdm9pZCAwLFxuICAgICAgY29tcG9uZW50XG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovKTtcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovKTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xuICB9O1xufVxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xuICBlbWl0JDEoXG4gICAgXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLFxuICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICBjb21wb25lbnQsXG4gICAgZXZlbnQsXG4gICAgcGFyYW1zXG4gICk7XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgY3VycmVudFNjb3BlSWQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCB8fCBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xuICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG59XG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCkge1xuICBpZiAoIWN0eCkgcmV0dXJuIGZuO1xuICBpZiAoZm4uX24pIHtcbiAgICByZXR1cm4gZm47XG4gIH1cbiAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBmbiguLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcbiAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgIHdhcm4kMShcIkRvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiBcIiArIG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID09PSBudWxsKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKTtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgaWYgKGRpcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xuICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgbW91bnRlZDogZGlyLFxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpci5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICBkaXIsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgYXJnLFxuICAgICAgICBtb2RpZmllcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcbiAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgaWYgKG9sZEJpbmRpbmdzKSB7XG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XG4gICAgfVxuICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgaWYgKGhvb2spIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4LCBbXG4gICAgICAgIHZub2RlLmVsLFxuICAgICAgICBiaW5kaW5nLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVGVsZXBvcnRFbmRLZXkgPSBTeW1ib2woXCJfdnRlXCIpO1xuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSBcIlwiKTtcbmNvbnN0IGlzVGVsZXBvcnREZWZlcnJlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRlZmVyIHx8IHByb3BzLmRlZmVyID09PSBcIlwiKTtcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbmNvbnN0IGlzVGFyZ2V0TWF0aE1MID0gKHRhcmdldCkgPT4gdHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50O1xuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XG4gIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XG4gIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0ICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICB9XG59O1xuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xuICBuYW1lOiBcIlRlbGVwb3J0XCIsXG4gIF9faXNUZWxlcG9ydDogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgICBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9XG4gICAgfSA9IGludGVybmFscztcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMi5wcm9wcyk7XG4gICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG4yLmVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBlbmRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyMiwgYW5jaG9yMikgPT4ge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5pc0NFKSB7XG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY2UuX3RlbGVwb3J0VGFyZ2V0ID0gY29udGFpbmVyMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBtb3VudFRvVGFyZ2V0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gcHJlcGFyZUFuY2hvcih0YXJnZXQsIG4yLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJzdmdcIiAmJiBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlICE9PSBcIm1hdGhtbFwiICYmIGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XG4gICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykpIHtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICAgICAgbjIuZWwuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGVmZXJyZWQobjIucHJvcHMpICYmICFuMS5lbC5fX2lzTW91bnRlZCkge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIFRlbGVwb3J0SW1wbC5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWxldGUgbjEuZWwuX19pc01vdW50ZWQ7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLnRhcmdldFN0YXJ0ID0gbjEudGFyZ2V0U3RhcnQ7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gbjEudGFyZ2V0O1xuICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gbjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yO1xuICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xuICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KSkge1xuICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgfHwgaXNUYXJnZXRNYXRoTUwodGFyZ2V0KSkge1xuICAgICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgICAgfVxuICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgY3VycmVudEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG1haW5BbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobjIucHJvcHMgJiYgbjEucHJvcHMgJiYgbjIucHJvcHMudG8gIT09IG4xLnByb3BzLnRvKSB7XG4gICAgICAgICAgICBuMi5wcm9wcy50byA9IG4xLnByb3BzLnRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICAgICAgICAgIG4yLnByb3BzLFxuICAgICAgICAgICAgcXVlcnlTZWxlY3RvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIG5leHRUYXJnZXQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiB1cGRhdGU6XCIsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXRBbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgZGlzYWJsZWQpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVGbGFnLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBhbmNob3IsXG4gICAgICB0YXJnZXRTdGFydCxcbiAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgIHRhcmdldCxcbiAgICAgIHByb3BzXG4gICAgfSA9IHZub2RlO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0U3RhcnQpO1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgIH1cbiAgICBkb1JlbW92ZSAmJiBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2hvdWxkUmVtb3ZlLFxuICAgICAgICAgICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yLCBpbnNlcnQsIGNyZWF0ZVRleHQgfVxufSwgaHlkcmF0ZUNoaWxkcmVuKSB7XG4gIGNvbnN0IHRhcmdldCA9IHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgdm5vZGUucHJvcHMsXG4gICAgcXVlcnlTZWxlY3RvclxuICApO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpO1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Tm9kZShub2RlKSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICB2bm9kZS50YXJnZXRTdGFydCA9IHRhcmdldE5vZGU7XG4gICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmIHRhcmdldEFuY2hvci5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBhbmNob3JcIikge1xuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICAgIHRhcmdldC5fbHBhID0gdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdm5vZGUudGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlLCBkaXNhYmxlZCk7XG4gIH1cbiAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5mdW5jdGlvbiB1cGRhdGVDc3NWYXJzKHZub2RlLCBpc0Rpc2FibGVkKSB7XG4gIGNvbnN0IGN0eCA9IHZub2RlLmN0eDtcbiAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICBsZXQgbm9kZSwgYW5jaG9yO1xuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICBub2RlID0gdm5vZGUuZWw7XG4gICAgICBhbmNob3IgPSB2bm9kZS5hbmNob3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSB2bm9kZS50YXJnZXRTdGFydDtcbiAgICAgIGFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvcjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gYW5jaG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtb3duZXJcIiwgY3R4LnVpZCk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgY3R4LnV0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVBbmNob3IodGFyZ2V0LCB2bm9kZSwgY3JlYXRlVGV4dCwgaW5zZXJ0KSB7XG4gIGNvbnN0IHRhcmdldFN0YXJ0ID0gdm5vZGUudGFyZ2V0U3RhcnQgPSBjcmVhdGVUZXh0KFwiXCIpO1xuICBjb25zdCB0YXJnZXRBbmNob3IgPSB2bm9kZS50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KFwiXCIpO1xuICB0YXJnZXRTdGFydFtUZWxlcG9ydEVuZEtleV0gPSB0YXJnZXRBbmNob3I7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBpbnNlcnQodGFyZ2V0U3RhcnQsIHRhcmdldCk7XG4gICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0QW5jaG9yO1xufVxuXG5jb25zdCBsZWF2ZUNiS2V5ID0gU3ltYm9sKFwiX2xlYXZlQ2JcIik7XG5jb25zdCBlbnRlckNiS2V5ID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNMZWF2aW5nOiBmYWxzZSxcbiAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxuICAgIGxlYXZpbmdWTm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICB9KTtcbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBtb2RlOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgcGVyc2lzdGVkOiBCb29sZWFuLFxuICAvLyBlbnRlclxuICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBsZWF2ZVxuICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBhcHBlYXJcbiAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3Jcbn07XG5jb25zdCByZWN1cnNpdmVHZXRTdWJ0cmVlID0gKGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICByZXR1cm4gc3ViVHJlZS5jb21wb25lbnQgPyByZWN1cnNpdmVHZXRTdWJ0cmVlKHN1YlRyZWUuY29tcG9uZW50KSA6IHN1YlRyZWU7XG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pO1xuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbW9kZSAmJiBtb2RlICE9PSBcImluLW91dFwiICYmIG1vZGUgIT09IFwib3V0LWluXCIgJiYgbW9kZSAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgd2FybiQxKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRJbm5lckNoaWxkJDEoY2hpbGQpO1xuICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGxldCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgaW5uZXJDaGlsZCxcbiAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgLy8gIzExMDYxLCBlbnN1cmUgZW50ZXJIb29rcyBpcyBmcmVzaCBhZnRlciBjbG9uZVxuICAgICAgICAoaG9va3MpID0+IGVudGVySG9va3MgPSBob29rc1xuICAgICAgKTtcbiAgICAgIGlmIChpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgfVxuICAgICAgbGV0IG9sZElubmVyQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlICYmIGdldElubmVyQ2hpbGQkMShpbnN0YW5jZS5zdWJUcmVlKTtcbiAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJiAhaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpICYmIHJlY3Vyc2l2ZUdldFN1YnRyZWUoaW5zdGFuY2UpLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgbGV0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2Uuam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmU7XG4gICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiaW4tb3V0XCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcbiAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gKCkgPT4ge1xuICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xuICAgICAgICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICBkZWxheWVkTGVhdmUoKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkSW5uZXJDaGlsZCkge1xuICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKSB7XG4gIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgYyBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGM7XG4gICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xuICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XG4gICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgfVxuICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSwgcG9zdENsb25lKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKSBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtlbnRlckNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbZW50ZXJDYktleV0gPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcbiAgICAgIGNvbnN0IGtleTIgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgICAgICBlbFtlbnRlckNiS2V5XShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2xlYXZlQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID0gdm5vZGU7XG4gICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICBjYWxsQXN5bmNIb29rKG9uTGVhdmUsIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmUodm5vZGUyKSB7XG4gICAgICBjb25zdCBob29rczIgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICB2bm9kZTIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHBvc3RDbG9uZVxuICAgICAgKTtcbiAgICAgIGlmIChwb3N0Q2xvbmUpIHBvc3RDbG9uZShob29rczIpO1xuICAgICAgcmV0dXJuIGhvb2tzMjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCQxKHZub2RlKSB7XG4gIGlmICghaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgaWYgKGlzVGVsZXBvcnQodm5vZGUudHlwZSkgJiYgdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBmaW5kTm9uQ29tbWVudENoaWxkKHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDMyICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4uZGVmYXVsdCkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5kZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2ICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XG4gICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UsIHBhcmVudEtleSkge1xuICBsZXQgcmV0ID0gW107XG4gIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGwgPyBjaGlsZC5rZXkgOiBTdHJpbmcocGFyZW50S2V5KSArIFN0cmluZyhjaGlsZC5rZXkgIT0gbnVsbCA/IGNoaWxkLmtleSA6IGkpO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCkga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICByZXQgPSByZXQuY29uY2F0KFxuICAgICAgICBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50LCBrZXkpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8gKFxuICAgIC8vICM4MjM2OiBleHRlbmQgY2FsbCBhbmQgb3B0aW9ucy5uYW1lIGFjY2VzcyBhcmUgY29uc2lkZXJlZCBzaWRlLWVmZmVjdHNcbiAgICAvLyBieSBSb2xsdXAsIHNvIHdlIGhhdmUgdG8gd3JhcCBpdCBpbiBhIHB1cmUtYW5ub3RhdGVkIElJRkUuXG4gICAgLyogQF9fUFVSRV9fICovICgoKSA9PiBleHRlbmQoeyBuYW1lOiBvcHRpb25zLm5hbWUgfSwgZXh0cmFPcHRpb25zLCB7IHNldHVwOiBvcHRpb25zIH0pKSgpXG4gICkgOiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaSkge1xuICAgIHJldHVybiAoaS5hcHBDb250ZXh0LmNvbmZpZy5pZFByZWZpeCB8fCBcInZcIikgKyBcIi1cIiArIGkuaWRzWzBdICsgaS5pZHNbMV0rKztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHVzZUlkKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5pZHMgPSBbaW5zdGFuY2UuaWRzWzBdICsgaW5zdGFuY2UuaWRzWzJdKysgKyBcIi1cIiwgMCwgMF07XG59XG5cbmNvbnN0IGtub3duVGVtcGxhdGVSZWZzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZihrZXkpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCByID0gc2hhbGxvd1JlZihudWxsKTtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCByZWZzID0gaS5yZWZzID09PSBFTVBUWV9PQkogPyBpLnJlZnMgPSB7fSA6IGkucmVmcztcbiAgICBsZXQgZGVzYztcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVmcywga2V5KSkgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICB3YXJuJDEoYHVzZVRlbXBsYXRlUmVmKCcke2tleX0nKSBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZnMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHIudmFsdWUsXG4gICAgICAgIHNldDogKHZhbCkgPT4gci52YWx1ZSA9IHZhbFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlVGVtcGxhdGVSZWYoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gcmVhZG9ubHkocikgOiByO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGtub3duVGVtcGxhdGVSZWZzLmFkZChyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDUxMiAmJiB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCAmJiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZS5jb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCkgOiB2bm9kZS5lbDtcbiAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhb3duZXIpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xuICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gb3duZXIucmVmcyA9IHt9IDogb3duZXIucmVmcztcbiAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XG4gIGNvbnN0IHJhd1NldHVwU3RhdGUgPSB0b1JhdyhzZXR1cFN0YXRlKTtcbiAgY29uc3QgY2FuU2V0U2V0dXBSZWYgPSBzZXR1cFN0YXRlID09PSBFTVBUWV9PQkogPyAoKSA9PiBmYWxzZSA6IChrZXkpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpICYmICFpc1JlZihyYXdTZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgVGVtcGxhdGUgcmVmIFwiJHtrZXl9XCIgdXNlZCBvbiBhIG5vbi1yZWYgdmFsdWUuIEl0IHdpbGwgbm90IHdvcmsgaW4gdGhlIHByb2R1Y3Rpb24gYnVpbGQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGtub3duVGVtcGxhdGVSZWZzLmhhcyhyYXdTZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpO1xuICB9O1xuICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xuICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcbiAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihvbGRSZWYpKSB7XG4gICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyLCBbdmFsdWUsIHJlZnNdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xuICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcbiAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IGNhblNldFNldHVwUmVmKHJlZikgPyBzZXR1cFN0YXRlW3JlZl0gOiByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspIHJlZnNbcmF3UmVmLmtdID0gcmVmLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihyZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvU2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSBmYWxzZTtcbmNvbnN0IGxvZ01pc21hdGNoRXJyb3IgPSAoKSA9PiB7XG4gIGlmIChoYXNMb2dnZWRNaXNtYXRjaEVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoXCJIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLlwiKTtcbiAgaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvciA9IHRydWU7XG59O1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiBjb250YWluZXIubmFtZXNwYWNlVVJJLmluY2x1ZGVzKFwic3ZnXCIpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSBcImZvcmVpZ25PYmplY3RcIjtcbmNvbnN0IGlzTWF0aE1MQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcIk1hdGhNTFwiKTtcbmNvbnN0IGdldENvbnRhaW5lclR5cGUgPSAoY29udGFpbmVyKSA9PiB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IDEpIHJldHVybiB2b2lkIDA7XG4gIGlmIChpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJzdmdcIjtcbiAgaWYgKGlzTWF0aE1MQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcIm1hdGhtbFwiO1xuICByZXR1cm4gdm9pZCAwO1xufTtcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4O1xuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgcDogcGF0Y2gsXG4gICAgbzoge1xuICAgICAgcGF0Y2hQcm9wLFxuICAgICAgY3JlYXRlVGV4dCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgcGFyZW50Tm9kZSxcbiAgICAgIHJlbW92ZSxcbiAgICAgIGluc2VydCxcbiAgICAgIGNyZWF0ZUNvbW1lbnRcbiAgICB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCI7XG4gICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKFxuICAgICAgbm9kZSxcbiAgICAgIHZub2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBpc0ZyYWdtZW50U3RhcnRcbiAgICApO1xuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgbGV0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihub2RlLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKG5vZGUsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMpIHtcbiAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2ggaW5gLFxuICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhXG4gICAgICAgICAgICAgICl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgcmVwbGFjZU5vZGUoXG4gICAgICAgICAgICB2bm9kZS5lbCA9IG5vZGUuY29udGVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tVHlwZSAhPT0gOCB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgfHwgZG9tVHlwZSA9PT0gMykge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUubm9kZVR5cGUgPT09IDEgPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKChkb21UeXBlICE9PSAxIHx8IHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmICFpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnRcIikge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUsIG5vZGUuZGF0YSwgXCJ0ZWxlcG9ydCBlbmRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIXZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZSA/IG5leHROb2RlLnByZXZpb3VzU2libGluZyA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZShcIlwiKSA6IGNyZWF0ZVZOb2RlKFwiZGl2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDgpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShwYXJlbnROb2RlKG5vZGUpKSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgaHlkcmF0ZU5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycywgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgZm9yY2VQYXRjaCA9IHR5cGUgPT09IFwiaW5wdXRcIiB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2ggfHwgcGF0Y2hGbGFnICE9PSAtMSkge1xuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgICB9XG4gICAgICBsZXQgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBmYWxzZTtcbiAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShlbCkpIHtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIG5vIG5lZWQgY2hlY2sgcGFyZW50U3VzcGVuc2UgaW4gaHlkcmF0aW9uXG4gICAgICAgICAgdHJhbnNpdGlvblxuICAgICAgICApICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzLmFwcGVhcjtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGVsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlTm9kZShjb250ZW50LCBlbCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgdm5vZGUuZWwgPSBlbCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYgJiYgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxuICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgZWwuZmlyc3RDaGlsZCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGBcblNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcmVtb3ZlKGN1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgICBsZXQgY2xpZW50VGV4dCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY2xpZW50VGV4dFswXSA9PT0gXCJcXG5cIiAmJiAoZWwudGFnTmFtZSA9PT0gXCJQUkVcIiB8fCBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpKSB7XG4gICAgICAgICAgY2xpZW50VGV4dCA9IGNsaWVudFRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSBjbGllbnRUZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMCAvKiBURVhUICovKSkge1xuICAgICAgICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7ZWwudGV4dENvbnRlbnR9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke3Zub2RlLmNoaWxkcmVufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gfHwgZm9yY2VQYXRjaCB8fCAhb3B0aW1pemVkIHx8IHBhdGNoRmxhZyAmICgxNiB8IDMyKSkge1xuICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAvLyAjMTExODkgc2tpcCBpZiB0aGlzIG5vZGUgaGFzIGRpcmVjdGl2ZXMgdGhhdCBoYXZlIGNyZWF0ZWQgaG9va3NcbiAgICAgICAgICAgIC8vIGFzIGl0IGNvdWxkIGhhdmUgbXV0YXRlZCB0aGUgRE9NIGluIGFueSBwb3NzaWJsZSB3YXlcbiAgICAgICAgICAgICEoZGlycyAmJiBkaXJzLnNvbWUoKGQpID0+IGQuZGlyLmNyZWF0ZWQpKSAmJiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgcHJvcHNba2V5XSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2ggJiYgKGtleS5lbmRzV2l0aChcInZhbHVlXCIpIHx8IGtleSA9PT0gXCJpbmRldGVybWluYXRlXCIpIHx8IGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSB8fCAvLyBmb3JjZSBoeWRyYXRlIHYtYmluZCB3aXRoIC5wcm9wIG1vZGlmaWVyc1xuICAgICAgICAgICAga2V5WzBdID09PSBcIi5cIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIHZvaWQgMCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgNCAmJiBpc1JlYWN0aXZlKHByb3BzLnN0eWxlKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzLnN0eWxlKSBwcm9wcy5zdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGVIb29rcztcbiAgICAgIGlmICh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkID8gY2hpbGRyZW5baV0gOiBjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHZub2RlLnR5cGUgPT09IFRleHQ7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoaXNUZXh0ICYmICFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPCBsICYmIG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2kgKyAxXSkudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgaW5zZXJ0KFxuICAgICAgICAgICAgICBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5zbGljZSh2bm9kZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChjb250YWluZXIsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKG5vZGUucGFyZW50RWxlbWVudCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIHJlbmRlcmVkIG9uIHNlcnZlcjpgLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgLFxuICAgICAgICBgXG4tIGV4cGVjdGVkIG9uIGNsaWVudDpgLFxuICAgICAgICB2bm9kZS50eXBlXG4gICAgICApO1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgIH1cbiAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0MiA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xuICAgICAgICAgIHJlbW92ZShuZXh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmV4dCxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSB2bm9kZS5lbDtcbiAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIHZub2RlLmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIGNvbnN0IGxvY2F0ZUNsb3NpbmdBbmNob3IgPSAobm9kZSwgb3BlbiA9IFwiW1wiLCBjbG9zZSA9IFwiXVwiKSA9PiB7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IG9wZW4pIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IGNsb3NlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCByZXBsYWNlTm9kZSA9IChuZXdOb2RlLCBvbGROb2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnROb2RlMiA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcbiAgICAgIHBhcmVudE5vZGUyLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnZub2RlLmVsID09PSBvbGROb2RlKSB7XG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RlbXBsYXRlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lID09PSBcIlRFTVBMQVRFXCI7XG4gIH07XG4gIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuZnVuY3Rpb24gcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIGNsaWVudFZhbHVlLCB2bm9kZSwgaW5zdGFuY2UpIHtcbiAgbGV0IG1pc21hdGNoVHlwZTtcbiAgbGV0IG1pc21hdGNoS2V5O1xuICBsZXQgYWN0dWFsO1xuICBsZXQgZXhwZWN0ZWQ7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIGV4cGVjdGVkID0gbm9ybWFsaXplQ2xhc3MoY2xpZW50VmFsdWUpO1xuICAgIGlmICghaXNTZXRFcXVhbCh0b0NsYXNzU2V0KGFjdHVhbCB8fCBcIlwiKSwgdG9DbGFzc1NldChleHBlY3RlZCkpKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSAyIC8qIENMQVNTICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBgY2xhc3NgO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpIHx8IFwiXCI7XG4gICAgZXhwZWN0ZWQgPSBpc1N0cmluZyhjbGllbnRWYWx1ZSkgPyBjbGllbnRWYWx1ZSA6IHN0cmluZ2lmeVN0eWxlKG5vcm1hbGl6ZVN0eWxlKGNsaWVudFZhbHVlKSk7XG4gICAgY29uc3QgYWN0dWFsTWFwID0gdG9TdHlsZU1hcChhY3R1YWwpO1xuICAgIGNvbnN0IGV4cGVjdGVkTWFwID0gdG9TdHlsZU1hcChleHBlY3RlZCk7XG4gICAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICAgIGZvciAoY29uc3QgeyBkaXIsIHZhbHVlIH0gb2Ygdm5vZGUuZGlycykge1xuICAgICAgICBpZiAoZGlyLm5hbWUgPT09IFwic2hvd1wiICYmICF2YWx1ZSkge1xuICAgICAgICAgIGV4cGVjdGVkTWFwLnNldChcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UsIHZub2RlLCBleHBlY3RlZE1hcCk7XG4gICAgfVxuICAgIGlmICghaXNNYXBFcXVhbChhY3R1YWxNYXAsIGV4cGVjdGVkTWFwKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMyAvKiBTVFlMRSAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gXCJzdHlsZVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgaXNLbm93blN2Z0F0dHIoa2V5KSB8fCBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIChpc0Jvb2xlYW5BdHRyKGtleSkgfHwgaXNLbm93bkh0bWxBdHRyKGtleSkpKSB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGluY2x1ZGVCb29sZWFuQXR0cihjbGllbnRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjbGllbnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBhY3R1YWwgPSBlbC5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGV4cGVjdGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgIGFjdHVhbCA9IGVsLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBleHBlY3RlZCA9IGlzUmVuZGVyYWJsZUF0dHJWYWx1ZShjbGllbnRWYWx1ZSkgPyBTdHJpbmcoY2xpZW50VmFsdWUpIDogZmFsc2U7XG4gICAgfVxuICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSA0IC8qIEFUVFJJQlVURSAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0ga2V5O1xuICAgIH1cbiAgfVxuICBpZiAobWlzbWF0Y2hUeXBlICE9IG51bGwgJiYgIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBtaXNtYXRjaFR5cGUpKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gKHYpID0+IHYgPT09IGZhbHNlID8gYChub3QgcmVuZGVyZWQpYCA6IGAke21pc21hdGNoS2V5fT1cIiR7dn1cImA7XG4gICAgY29uc3QgcHJlU2VnbWVudCA9IGBIeWRyYXRpb24gJHtNaXNtYXRjaFR5cGVTdHJpbmdbbWlzbWF0Y2hUeXBlXX0gbWlzbWF0Y2ggb25gO1xuICAgIGNvbnN0IHBvc3RTZWdtZW50ID0gYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtmb3JtYXQoYWN0dWFsKX1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7Zm9ybWF0KGV4cGVjdGVkKX1cbiAgTm90ZTogdGhpcyBtaXNtYXRjaCBpcyBjaGVjay1vbmx5LiBUaGUgRE9NIHdpbGwgbm90IGJlIHJlY3RpZmllZCBpbiBwcm9kdWN0aW9uIGR1ZSB0byBwZXJmb3JtYW5jZSBvdmVyaGVhZC5cbiAgWW91IHNob3VsZCBmaXggdGhlIHNvdXJjZSBvZiB0aGUgbWlzbWF0Y2guYDtcbiAgICB7XG4gICAgICB3YXJuJDEocHJlU2VnbWVudCwgZWwsIHBvc3RTZWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdG9DbGFzc1NldChzdHIpIHtcbiAgcmV0dXJuIG5ldyBTZXQoc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbn1cbmZ1bmN0aW9uIGlzU2V0RXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBzIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9TdHlsZU1hcChzdHIpIHtcbiAgY29uc3Qgc3R5bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RyLnNwbGl0KFwiO1wiKSkge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBpdGVtLnNwbGl0KFwiOlwiKTtcbiAgICBrZXkgPSBrZXkudHJpbSgpO1xuICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWUudHJpbSgpO1xuICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgIHN0eWxlTWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlTWFwO1xufVxuZnVuY3Rpb24gaXNNYXBFcXVhbChhLCBiKSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhKSB7XG4gICAgaWYgKHZhbHVlICE9PSBiLmdldChrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UsIHZub2RlLCBleHBlY3RlZE1hcCkge1xuICBjb25zdCByb290ID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgaWYgKGluc3RhbmNlLmdldENzc1ZhcnMgJiYgKHZub2RlID09PSByb290IHx8IHJvb3QgJiYgcm9vdC50eXBlID09PSBGcmFnbWVudCAmJiByb290LmNoaWxkcmVuLmluY2x1ZGVzKHZub2RlKSkpIHtcbiAgICBjb25zdCBjc3NWYXJzID0gaW5zdGFuY2UuZ2V0Q3NzVmFycygpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNzc1ZhcnMpIHtcbiAgICAgIGV4cGVjdGVkTWFwLnNldChcbiAgICAgICAgYC0tJHtnZXRFc2NhcGVkQ3NzVmFyTmFtZShrZXksIGZhbHNlKX1gLFxuICAgICAgICBTdHJpbmcoY3NzVmFyc1trZXldKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlID09PSByb290ICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2Uudm5vZGUsIGV4cGVjdGVkTWFwKTtcbiAgfVxufVxuY29uc3QgYWxsb3dNaXNtYXRjaEF0dHIgPSBcImRhdGEtYWxsb3ctbWlzbWF0Y2hcIjtcbmNvbnN0IE1pc21hdGNoVHlwZVN0cmluZyA9IHtcbiAgWzAgLyogVEVYVCAqL106IFwidGV4dFwiLFxuICBbMSAvKiBDSElMRFJFTiAqL106IFwiY2hpbGRyZW5cIixcbiAgWzIgLyogQ0xBU1MgKi9dOiBcImNsYXNzXCIsXG4gIFszIC8qIFNUWUxFICovXTogXCJzdHlsZVwiLFxuICBbNCAvKiBBVFRSSUJVVEUgKi9dOiBcImF0dHJpYnV0ZVwiXG59O1xuZnVuY3Rpb24gaXNNaXNtYXRjaEFsbG93ZWQoZWwsIGFsbG93ZWRUeXBlKSB7XG4gIGlmIChhbGxvd2VkVHlwZSA9PT0gMCAvKiBURVhUICovIHx8IGFsbG93ZWRUeXBlID09PSAxIC8qIENISUxEUkVOICovKSB7XG4gICAgd2hpbGUgKGVsICYmICFlbC5oYXNBdHRyaWJ1dGUoYWxsb3dNaXNtYXRjaEF0dHIpKSB7XG4gICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsbG93ZWRBdHRyID0gZWwgJiYgZWwuZ2V0QXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKTtcbiAgaWYgKGFsbG93ZWRBdHRyID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYWxsb3dlZEF0dHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsaXN0ID0gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpO1xuICAgIGlmIChhbGxvd2VkVHlwZSA9PT0gMCAvKiBURVhUICovICYmIGxpc3QuaW5jbHVkZXMoXCJjaGlsZHJlblwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhbGxvd2VkQXR0ci5zcGxpdChcIixcIikuaW5jbHVkZXMoTWlzbWF0Y2hUeXBlU3RyaW5nW2FsbG93ZWRUeXBlXSk7XG4gIH1cbn1cblxuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9IGdldEdsb2JhbFRoaXMoKS5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICgoY2IpID0+IHNldFRpbWVvdXQoY2IsIDEpKTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IGdldEdsb2JhbFRoaXMoKS5jYW5jZWxJZGxlQ2FsbGJhY2sgfHwgKChpZCkgPT4gY2xlYXJUaW1lb3V0KGlkKSk7XG5jb25zdCBoeWRyYXRlT25JZGxlID0gKHRpbWVvdXQgPSAxZTQpID0+IChoeWRyYXRlKSA9PiB7XG4gIGNvbnN0IGlkID0gcmVxdWVzdElkbGVDYWxsYmFjayhoeWRyYXRlLCB7IHRpbWVvdXQgfSk7XG4gIHJldHVybiAoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWQpO1xufTtcbmZ1bmN0aW9uIGVsZW1lbnRJc1Zpc2libGVJblZpZXdwb3J0KGVsKSB7XG4gIGNvbnN0IHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeyBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCB9ID0gd2luZG93O1xuICByZXR1cm4gKHRvcCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgfHwgYm90dG9tID4gMCAmJiBib3R0b20gPCBpbm5lckhlaWdodCkgJiYgKGxlZnQgPiAwICYmIGxlZnQgPCBpbm5lcldpZHRoIHx8IHJpZ2h0ID4gMCAmJiByaWdodCA8IGlubmVyV2lkdGgpO1xufVxuY29uc3QgaHlkcmF0ZU9uVmlzaWJsZSA9IChvcHRzKSA9PiAoaHlkcmF0ZSwgZm9yRWFjaCkgPT4ge1xuICBjb25zdCBvYiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIWUuaXNJbnRlcnNlY3RpbmcpIGNvbnRpbnVlO1xuICAgICAgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9LCBvcHRzKTtcbiAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIEVsZW1lbnQpKSByZXR1cm47XG4gICAgaWYgKGVsZW1lbnRJc1Zpc2libGVJblZpZXdwb3J0KGVsKSkge1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYi5vYnNlcnZlKGVsKTtcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBvYi5kaXNjb25uZWN0KCk7XG59O1xuY29uc3QgaHlkcmF0ZU9uTWVkaWFRdWVyeSA9IChxdWVyeSkgPT4gKGh5ZHJhdGUpID0+IHtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgY29uc3QgbXFsID0gbWF0Y2hNZWRpYShxdWVyeSk7XG4gICAgaWYgKG1xbC5tYXRjaGVzKSB7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1xbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBtcWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBoeWRyYXRlT25JbnRlcmFjdGlvbiA9IChpbnRlcmFjdGlvbnMgPSBbXSkgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgaWYgKGlzU3RyaW5nKGludGVyYWN0aW9ucykpIGludGVyYWN0aW9ucyA9IFtpbnRlcmFjdGlvbnNdO1xuICBsZXQgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgZG9IeWRyYXRlID0gKGUpID0+IHtcbiAgICBpZiAoIWhhc0h5ZHJhdGVkKSB7XG4gICAgICBoYXNIeWRyYXRlZCA9IHRydWU7XG4gICAgICB0ZWFyZG93bigpO1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgZS5jb25zdHJ1Y3RvcihlLnR5cGUsIGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRlYXJkb3duID0gKCkgPT4ge1xuICAgIGZvckVhY2goKGVsKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZWFyZG93bjtcbn07XG5mdW5jdGlvbiBmb3JFYWNoRWxlbWVudChub2RlLCBjYikge1xuICBpZiAoaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIpIHtcbiAgICBsZXQgZGVwdGggPSAxO1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2IobmV4dCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5leHQpKSB7XG4gICAgICAgIGlmIChuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICAgICAgaWYgKC0tZGVwdGggPT09IDApIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHQuZGF0YSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2Iobm9kZSk7XG4gIH1cbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcbiAgICBlcnJvckNvbXBvbmVudCxcbiAgICBkZWxheSA9IDIwMCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3RyYXRlZ3ksXG4gICAgdGltZW91dCxcbiAgICAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsXG4gICAgb25FcnJvcjogdXNlck9uRXJyb3JcbiAgfSA9IHNvdXJjZTtcbiAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgbGV0IHJlc29sdmVkQ29tcDtcbiAgbGV0IHJldHJpZXMgPSAwO1xuICBjb25zdCByZXRyeSA9ICgpID0+IHtcbiAgICByZXRyaWVzKys7XG4gICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIHJldHVybiBsb2FkKCk7XG4gIH07XG4gIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdCB8fCAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSkudGhlbigoY29tcCkgPT4ge1xuICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY29tcCkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICBfX2FzeW5jSHlkcmF0ZShlbCwgaW5zdGFuY2UsIGh5ZHJhdGUpIHtcbiAgICAgIGNvbnN0IGRvSHlkcmF0ZSA9IGh5ZHJhdGVTdHJhdGVneSA/ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGVhcmRvd24gPSBoeWRyYXRlU3RyYXRlZ3koXG4gICAgICAgICAgaHlkcmF0ZSxcbiAgICAgICAgICAoY2IpID0+IGZvckVhY2hFbGVtZW50KGVsLCBjYilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRlYXJkb3duKSB7XG4gICAgICAgICAgKGluc3RhbmNlLmJ1bSB8fCAoaW5zdGFuY2UuYnVtID0gW10pKS5wdXNoKHRlYXJkb3duKTtcbiAgICAgICAgfVxuICAgICAgfSA6IGh5ZHJhdGU7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIGRvSHlkcmF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZCgpLnRoZW4oKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGRvSHlkcmF0ZSgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xuICAgIH0sXG4gICAgc2V0dXAoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRXJyb3IoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgICFlcnJvckNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSB8fCBpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKS50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50ID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XG4gICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgbG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XG4gIGNvbnN0IHsgcmVmOiByZWYyLCBwcm9wcywgY2hpbGRyZW4sIGNlIH0gPSBwYXJlbnQudm5vZGU7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgdm5vZGUucmVmID0gcmVmMjtcbiAgdm5vZGUuY2UgPSBjZTtcbiAgZGVsZXRlIHBhcmVudC52bm9kZS5jZTtcbiAgcmV0dXJuIHZub2RlO1xufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcbiAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XG4gIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XG4gIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcbiAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHA6IHBhdGNoLFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICB1bTogX3VubW91bnQsXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gICAgICB9XG4gICAgfSA9IHNoYXJlZENvbnRleHQ7XG4gICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5hKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLm0pO1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5hKTtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY2FjaGVkICYmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpKSB7XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sXG4gICAgICAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XG4gICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XG4gICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgfSxcbiAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICB7IGZsdXNoOiBcInBvc3RcIiwgZGVlcDogdHJ1ZSB9XG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XG4gICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzU3VzcGVuc2UoaW5zdGFuY2Uuc3ViVHJlZS50eXBlKSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICB9LCBpbnN0YW5jZS5zdWJUcmVlLnN1c3BlbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgaWYgKHZub2RlLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIGlzQXN5bmNXcmFwcGVyKHZub2RlKSA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9IDogY29tcFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgIGlmIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkgfHwgZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpIHtcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xuICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2bm9kZS5lbCkge1xuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcbiAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xuICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xuICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyO1xuICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTY7XG4gICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICByZXR1cm4gaXNTdXNwZW5zZShyYXdWTm9kZS50eXBlKSA/IHJhd1ZOb2RlIDogdm5vZGU7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKGlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhuYW1lKTtcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHwgKGhvb2suX193ZGMgPSAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaG9vaygpO1xuICB9KTtcbiAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayhcbiAgICB0eXBlLFxuICAgIGhvb2ssXG4gICAga2VlcEFsaXZlUm9vdCxcbiAgICB0cnVlXG4gICAgLyogcHJlcGVuZCAqL1xuICApO1xuICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMjtcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkSG9vaztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgXCJcIikpO1xuICAgIHdhcm4kMShcbiAgICAgIGAke2FwaU5hbWV9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLiBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gIClcbiAgICApO1xuICB9XG59XG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xuICBpZiAoIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIikge1xuICAgIGluamVjdEhvb2sobGlmZWN5Y2xlLCAoLi4uYXJncykgPT4gaG9vayguLi5hcmdzKSwgdGFyZ2V0KTtcbiAgfVxufTtcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIik7XG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcbiAgXCJidVwiXG4pO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIik7XG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFxuICBcImJ1bVwiXG4pO1xuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIik7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcbiAgXCJzcFwiXG4pO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIpO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgaW5qZWN0SG9vayhcImVjXCIsIGhvb2ssIHRhcmdldCk7XG59XG5cbmNvbnN0IENPTVBPTkVOVFMgPSBcImNvbXBvbmVudHNcIjtcbmNvbnN0IERJUkVDVElWRVMgPSBcImRpcmVjdGl2ZXNcIjtcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xufVxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbC5mb3IoXCJ2LW5kY1wiKTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlQXNzZXQodHlwZSwgbmFtZSwgd2Fybk1pc3NpbmcgPSB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcbiAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGlmIChzZWxmTmFtZSAmJiAoc2VsZk5hbWUgPT09IG5hbWUgfHwgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8IHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gKFxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcbiAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fCAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXG4gICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpXG4gICAgKTtcbiAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UUyA/IGBcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYCA6IGBgO1xuICAgICAgd2FybiQxKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3R5cGUuc2xpY2UoMCwgLTEpfTogJHtuYW1lfSR7ZXh0cmF9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XG4gIHJldHVybiByZWdpc3RyeSAmJiAocmVnaXN0cnlbbmFtZV0gfHwgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8IHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcbiAgbGV0IHJldDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUgJiYgY2FjaGVbaW5kZXhdO1xuICBjb25zdCBzb3VyY2VJc0FycmF5ID0gaXNBcnJheShzb3VyY2UpO1xuICBpZiAoc291cmNlSXNBcnJheSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgY29uc3Qgc291cmNlSXNSZWFjdGl2ZUFycmF5ID0gc291cmNlSXNBcnJheSAmJiBpc1JlYWN0aXZlKHNvdXJjZSk7XG4gICAgbGV0IG5lZWRzV3JhcCA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VJc1JlYWN0aXZlQXJyYXkpIHtcbiAgICAgIG5lZWRzV3JhcCA9ICFpc1NoYWxsb3coc291cmNlKTtcbiAgICAgIHNvdXJjZSA9IHNoYWxsb3dSZWFkQXJyYXkoc291cmNlKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShcbiAgICAgICAgbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShzb3VyY2VbaV0pIDogc291cmNlW2ldLFxuICAgICAgICBpLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGNhY2hlZCAmJiBjYWNoZWRbaV1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XG4gICAgICB3YXJuJDEoYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gQXJyYXkuZnJvbShcbiAgICAgICAgc291cmNlLFxuICAgICAgICAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlW2luZGV4XSA9IHJldDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3Qua2V5ID8gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gc2xvdC5mbiguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlcykgcmVzLmtleSA9IHNsb3Qua2V5O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSA6IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90cztcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5jZSkge1xuICAgIGlmIChuYW1lICE9PSBcImRlZmF1bHRcIikgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIFtjcmVhdGVWTm9kZShcInNsb3RcIiwgcHJvcHMsIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpXSxcbiAgICAgIDY0XG4gICAgKTtcbiAgfVxuICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgZnVuY3Rpb24uIFlvdSBuZWVkIHRvIG1hcmsgdGhpcyBjb21wb25lbnQgd2l0aCAkZHluYW1pYy1zbG90cyBpbiB0aGUgcGFyZW50IHRlbXBsYXRlLmBcbiAgICApO1xuICAgIHNsb3QgPSAoKSA9PiBbXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IGZhbHNlO1xuICB9XG4gIG9wZW5CbG9jaygpO1xuICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcbiAgY29uc3Qgc2xvdEtleSA9IHByb3BzLmtleSB8fCAvLyBzbG90IGNvbnRlbnQgYXJyYXkgb2YgYSBkeW5hbWljIGNvbmRpdGlvbmFsIHNsb3QgbWF5IGhhdmUgYSBicmFuY2hcbiAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gIHZhbGlkU2xvdENvbnRlbnQgJiYgdmFsaWRTbG90Q29udGVudC5rZXk7XG4gIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soXG4gICAgRnJhZ21lbnQsXG4gICAge1xuICAgICAga2V5OiAoc2xvdEtleSAmJiAhaXNTeW1ib2woc2xvdEtleSkgPyBzbG90S2V5IDogYF8ke25hbWV9YCkgKyAvLyAjNzI1NiBmb3JjZSBkaWZmZXJlbnRpYXRlIGZhbGxiYWNrIGNvbnRlbnQgZnJvbSBhY3R1YWwgY29udGVudFxuICAgICAgKCF2YWxpZFNsb3RDb250ZW50ICYmIGZhbGxiYWNrID8gXCJfZmJcIiA6IFwiXCIpXG4gICAgfSxcbiAgICB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksXG4gICAgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxID8gNjQgOiAtMlxuICApO1xuICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XG4gICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyBcIi1zXCJdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xuICByZXR1cm4gdm5vZGVzLnNvbWUoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiYgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9KSA/IHZub2RlcyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqLCBwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KG9iaikpIHtcbiAgICB3YXJuJDEoYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJldFtwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSAmJiAvW0EtWl0vLnRlc3Qoa2V5KSA/IGBvbjoke2tleX1gIDogdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xuICBpZiAoIWkpIHJldHVybiBudWxsO1xuICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSkgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGkpO1xuICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xufTtcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSAoXG4gIC8vIE1vdmUgUFVSRSBtYXJrZXIgdG8gbmV3IGxpbmUgdG8gd29ya2Fyb3VuZCBjb21waWxlciBkaXNjYXJkaW5nIGl0XG4gIC8vIGR1ZSB0byB0eXBlIGFubm90YXRpb25cbiAgLyogQF9fUFVSRV9fICovIGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICQ6IChpKSA9PiBpLFxuICAgICRlbDogKGkpID0+IGkudm5vZGUuZWwsXG4gICAgJGRhdGE6IChpKSA9PiBpLmRhdGEsXG4gICAgJHByb3BzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMsXG4gICAgJGF0dHJzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMsXG4gICAgJHNsb3RzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMsXG4gICAgJHJlZnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMsXG4gICAgJHBhcmVudDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcbiAgICAkcm9vdDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXG4gICAgJGhvc3Q6IChpKSA9PiBpLmNlLFxuICAgICRlbWl0OiAoaSkgPT4gaS5lbWl0LFxuICAgICRvcHRpb25zOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlLFxuICAgICRmb3JjZVVwZGF0ZTogKGkpID0+IGkuZiB8fCAoaS5mID0gKCkgPT4ge1xuICAgICAgcXVldWVKb2IoaS51cGRhdGUpO1xuICAgIH0pLFxuICAgICRuZXh0VGljazogKGkpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXG4gICAgJHdhdGNoOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1BcbiAgfSlcbik7XG5jb25zdCBpc1Jlc2VydmVkUHJlZml4ID0gKGtleSkgPT4ga2V5ID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJFwiO1xuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBFTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc3RhdGUsIGtleSk7XG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XG4gIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCJfX2lzVnVlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIGlmIChrZXlbMF0gIT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XG4gICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBEQVRBICovO1xuICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KVxuICAgICAgKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIFBST1BTICovO1xuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICB9IGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIE9USEVSICovO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XG4gICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcbiAgICBpZiAocHVibGljR2V0dGVyKSB7XG4gICAgICBpZiAoa2V5ID09PSBcIiRhdHRyc1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLmF0dHJzLCBcImdldFwiLCBcIlwiKTtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCIkc2xvdHNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxuICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJiAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3NzTW9kdWxlO1xuICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcbiAgICAgIGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KVxuICAgICkge1xuICAgICAge1xuICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiYgKCFpc1N0cmluZyhrZXkpIHx8IC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXG4gICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXG4gICAga2V5LmluZGV4T2YoXCJfX3ZcIikgIT09IDApKSB7XG4gICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHdhcm4kMShgQ2Fubm90IG11dGF0ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5nIFwiJHtrZXl9XCIgZnJvbSBPcHRpb25zIEFQSS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5WzBdID09PSBcIiRcIiAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9XG4gIH0sIGtleSkge1xuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgcmV0dXJuICEhYWNjZXNzQ2FjaGVba2V5XSB8fCBkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkgfHwgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHwgKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSB8fCBoYXNPd24oY3R4LCBrZXkpIHx8IGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8IGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybiQxKFxuICAgICAgYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH07XG59XG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICB9LFxuICBoYXMoXywga2V5KSB7XG4gICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseUFsbG93ZWQoa2V5KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBrZXlcbiAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhcztcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICB9KTtcbiAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IE5PT1BcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgY3R4LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgfSA9IGluc3RhbmNlO1xuICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybiQxKFxuICBgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYFxuKTtcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lT3B0aW9uc2ApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVTbG90cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVTbG90c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShcImRlZmluZU1vZGVsXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcbn1cbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgfVxuICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhwcm9wcykge1xuICByZXR1cm4gaXNBcnJheShwcm9wcykgPyBwcm9wcy5yZWR1Y2UoXG4gICAgKG5vcm1hbGl6ZWQsIHApID0+IChub3JtYWxpemVkW3BdID0gbnVsbCwgbm9ybWFsaXplZCksXG4gICAge31cbiAgKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XG4gIGNvbnN0IHByb3BzID0gbm9ybWFsaXplUHJvcHNPckVtaXRzKHJhdyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiX19za2lwXCIpKSBjb250aW51ZTtcbiAgICBsZXQgb3B0ID0gcHJvcHNba2V5XTtcbiAgICBpZiAob3B0KSB7XG4gICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xuICAgICAgICBvcHQgPSBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgIH1cbiAgICBpZiAob3B0ICYmIGRlZmF1bHRzW2BfX3NraXBfJHtrZXl9YF0pIHtcbiAgICAgIG9wdC5za2lwRmFjdG9yeSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlTW9kZWxzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gYSB8fCBiO1xuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSByZXR1cm4gYS5jb25jYXQoYik7XG4gIHJldHVybiBleHRlbmQoe30sIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhhKSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGIpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB3aXRoQXN5bmNDb250ZXh0KGdldEF3YWl0YWJsZSkge1xuICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWN0eCkge1xuICAgIHdhcm4kMShcbiAgICAgIGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgfVxuICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xuICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaCgoZSkgPT4ge1xuICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAodHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHdhcm4kMShgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtrZXldID0gdHlwZTtcbiAgICB9XG4gIH07XG59XG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgY3R4ID0gaW5zdGFuY2UuY3R4O1xuICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcbiAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucyxcbiAgICBtZXRob2RzLFxuICAgIHdhdGNoOiB3YXRjaE9wdGlvbnMsXG4gICAgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsXG4gICAgaW5qZWN0OiBpbmplY3RPcHRpb25zLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsXG4gICAgYmVmb3JlTW91bnQsXG4gICAgbW91bnRlZCxcbiAgICBiZWZvcmVVcGRhdGUsXG4gICAgdXBkYXRlZCxcbiAgICBhY3RpdmF0ZWQsXG4gICAgZGVhY3RpdmF0ZWQsXG4gICAgYmVmb3JlRGVzdHJveSxcbiAgICBiZWZvcmVVbm1vdW50LFxuICAgIGRlc3Ryb3llZCxcbiAgICB1bm1vdW50ZWQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlclRyYWNrZWQsXG4gICAgcmVuZGVyVHJpZ2dlcmVkLFxuICAgIGVycm9yQ2FwdHVyZWQsXG4gICAgc2VydmVyUHJlZmV0Y2gsXG4gICAgLy8gcHVibGljIEFQSVxuICAgIGV4cG9zZSxcbiAgICBpbmhlcml0QXR0cnMsXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cyxcbiAgICBkaXJlY3RpdmVzLFxuICAgIGZpbHRlcnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5qZWN0T3B0aW9ucykge1xuICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKTtcbiAgfVxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YU9wdGlvbnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcbiAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KSA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogaXNGdW5jdGlvbihvcHQuZ2V0KSA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IE5PT1A7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBnZXQgPT09IE5PT1ApIHtcbiAgICAgICAgd2FybiQxKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldCkgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcykgOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYFxuICAgICAgICApO1xuICAgICAgfSA6IE5PT1A7XG4gICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGMudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh3YXRjaE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKSA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcykgOiBwcm92aWRlT3B0aW9ucztcbiAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgIH0pO1xuICB9XG4gIGlmIChjcmVhdGVkKSB7XG4gICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiKTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaG9vay5mb3JFYWNoKChfaG9vaykgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xuICAgIH0gZWxzZSBpZiAoaG9vaykge1xuICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcbiAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICBleHBvc2UuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcbiAgICAgICAgICBzZXQ6ICh2YWwpID0+IHB1YmxpY1RoaXNba2V5XSA9IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcbiAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XG4gIH1cbiAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xuICB9XG4gIGlmIChjb21wb25lbnRzKSBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgaWYgKGRpcmVjdGl2ZXMpIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICBpZiAoc2VydmVyUHJlZmV0Y2gpIHtcbiAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xuICBpZiAoaXNBcnJheShpbmplY3RPcHRpb25zKSkge1xuICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcbiAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBvcHQpIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3QoXG4gICAgICAgICAgb3B0LmZyb20gfHwga2V5LFxuICAgICAgICAgIG9wdC5kZWZhdWx0LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGluamVjdGVkLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICBpc0FycmF5KGhvb2spID8gaG9vay5tYXAoKGgpID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSxcbiAgICBpbnN0YW5jZSxcbiAgICB0eXBlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgbGV0IGdldHRlciA9IGtleS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSkgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XG4gIGlmIChpc1N0cmluZyhyYXcpKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xuICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XG4gICAge1xuICAgICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICByYXcuZm9yRWFjaCgocikgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcikgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XG4gIGNvbnN0IHtcbiAgICBtaXhpbnM6IGdsb2JhbE1peGlucyxcbiAgICBvcHRpb25zQ2FjaGU6IGNhY2hlLFxuICAgIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfVxuICB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICBsZXQgcmVzb2x2ZWQ7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXNvbHZlZCA9IGNhY2hlZDtcbiAgfSBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgIHtcbiAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWQgPSB7fTtcbiAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xuICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2goXG4gICAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSlcbiAgICAgICk7XG4gICAgfVxuICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xuICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xuICB9XG4gIGlmIChtaXhpbnMpIHtcbiAgICBtaXhpbnMuZm9yRWFjaChcbiAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSlcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09IFwiZXhwb3NlXCIpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IHN0cmF0cyAmJiBzdHJhdHNba2V5XTtcbiAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XG4gIGRhdGE6IG1lcmdlRGF0YUZuLFxuICBwcm9wczogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICBlbWl0czogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICAvLyBvYmplY3RzXG4gIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gbGlmZWN5Y2xlXG4gIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxuICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXG4gIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXG4gIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcbiAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcbiAgLy8gYXNzZXRzXG4gIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyB3YXRjaFxuICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXG4gIC8vIHByb3ZpZGUgLyBpbmplY3RcbiAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gIGluamVjdDogbWVyZ2VJbmplY3Rcbn07XG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgaWYgKCF0bykge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgcmV0dXJuIChleHRlbmQpKFxuICAgICAgaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sXG4gICAgICBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xuICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIHJhdztcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8sIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAodG8pIHtcbiAgICBpZiAoaXNBcnJheSh0bykgJiYgaXNBcnJheShmcm9tKSkge1xuICAgICAgcmV0dXJuIFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udG8sIC4uLmZyb21dKV07XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoXG4gICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyh0byksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHMoZnJvbSAhPSBudWxsID8gZnJvbSA6IHt9KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICghdG8pIHJldHVybiBmcm9tO1xuICBpZiAoIWZyb20pIHJldHVybiB0bztcbiAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xuICB9XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgYXBwOiBudWxsLFxuICAgIGNvbmZpZzoge1xuICAgICAgaXNOYXRpdmVUYWc6IE5PLFxuICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXG4gICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxuICAgICAgZXJyb3JIYW5kbGVyOiB2b2lkIDAsXG4gICAgICB3YXJuSGFuZGxlcjogdm9pZCAwLFxuICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxuICAgIH0sXG4gICAgbWl4aW5zOiBbXSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBkaXJlY3RpdmVzOiB7fSxcbiAgICBwcm92aWRlczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgb3B0aW9uc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBwcm9wc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBlbWl0c0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICB9O1xufVxubGV0IHVpZCQxID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XG4gICAgICByb290Q29tcG9uZW50ID0gZXh0ZW5kKHt9LCByb290Q29tcG9uZW50KTtcbiAgICB9XG4gICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICByb290UHJvcHMgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xuICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICBjb25zdCBwbHVnaW5DbGVhbnVwRm5zID0gW107XG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFwcCA9IGNvbnRleHQuYXBwID0ge1xuICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyh2KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xuICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcFwiICsgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgVGhlcmUgaXMgYWxyZWFkeSBhbiBhcHAgaW5zdGFuY2UgbW91bnRlZCBvbiB0aGUgaG9zdCBjb250YWluZXIuXG4gSWYgeW91IHdhbnQgdG8gbW91bnQgYW5vdGhlciBhcHAgb24gdGhlIHNhbWUgaG9zdCBjb250YWluZXIsIHlvdSBuZWVkIHRvIHVubW91bnQgdGhlIHByZXZpb3VzIGFwcCBieSBjYWxsaW5nIFxcYGFwcC51bm1vdW50KClcXGAgZmlyc3QuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgdm5vZGUgPSBhcHAuX2NlVk5vZGUgfHwgY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbmRlcihcbiAgICAgICAgICAgICAgICBjbG9uZVZOb2RlKHZub2RlKSxcbiAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBuYW1lc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcbiAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXG5JZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW5tb3VudChjbGVhbnVwRm4pIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHlwZW9mIGNsZWFudXBGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4cGVjdGVkIGZ1bmN0aW9uIGFzIGZpcnN0IGFyZ3VtZW50IHRvIGFwcC5vblVubW91bnQoKSwgYnV0IGdvdCAke3R5cGVvZiBjbGVhbnVwRm59YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcGx1Z2luQ2xlYW51cEZucy5wdXNoKGNsZWFudXBGbik7XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgICAgICAgcGx1Z2luQ2xlYW51cEZucyxcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UsXG4gICAgICAgICAgICAxNlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIHJ1bldpdGhDb250ZXh0KGZuKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBcHAgPSBjdXJyZW50QXBwO1xuICAgICAgICBjdXJyZW50QXBwID0gYXBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRBcHAgPSBsYXN0QXBwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xuICB9O1xufVxubGV0IGN1cnJlbnRBcHAgPSBudWxsO1xuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xuICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgfVxuICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSB8fCBjdXJyZW50QXBwKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBjdXJyZW50QXBwID8gY3VycmVudEFwcC5fY29udGV4dC5wcm92aWRlcyA6IGluc3RhbmNlID8gaW5zdGFuY2UucGFyZW50ID09IG51bGwgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXMgOiB2b2lkIDA7XG4gICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzSW5qZWN0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XG59XG5cbmNvbnN0IGludGVybmFsT2JqZWN0UHJvdG8gPSB7fTtcbmNvbnN0IGNyZWF0ZUludGVybmFsT2JqZWN0ID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShpbnRlcm5hbE9iamVjdFByb3RvKTtcbmNvbnN0IGlzSW50ZXJuYWxPYmplY3QgPSAob2JqKSA9PiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gaW50ZXJuYWxPYmplY3RQcm90bztcblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IgPSBmYWxzZSkge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBhdHRycyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKSByZXR1cm4gdHJ1ZTtcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICBjb25zdCB7XG4gICAgcHJvcHMsXG4gICAgYXR0cnMsXG4gICAgdm5vZGU6IHsgcGF0Y2hGbGFnIH1cbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XG4gICAgISghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiYgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJiAhKHBhdGNoRmxhZyAmIDE2KVxuICApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgY2FtZWxpemVkS2V5LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQga2ViYWJLZXk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBpZiAoIXJhd1Byb3BzIHx8IC8vIGZvciBjYW1lbENhc2VcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcbiAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJiAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB2b2lkIDAgfHwgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB2b2lkIDApKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xuICAgIHRyaWdnZXIoaW5zdGFuY2UuYXR0cnMsIFwic2V0XCIsIFwiXCIpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XG4gIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCByYXdDYXN0VmFsdWVzO1xuICBpZiAocmF3UHJvcHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgbGV0IGNhbWVsS2V5O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpIHtcbiAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRDYXN0S2V5cykge1xuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgIGtleSxcbiAgICAgICAgY2FzdFZhbHVlc1trZXldLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsIFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcbiAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgIW9wdC5za2lwRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlLmNlKSB7XG4gICAgICAgIGluc3RhbmNlLmNlLl9zZXRQcm9wKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcbiAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBtaXhpblByb3BzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIGFzTWl4aW4gPyBtaXhpblByb3BzQ2FjaGUgOiBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4kMShgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJhdykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChyYXcpKSB7XG4gICAgICB3YXJuJDEoYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcbiAgICAgICAgY29uc3QgcHJvcCA9IG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IGV4dGVuZCh7fSwgb3B0KTtcbiAgICAgICAgY29uc3QgcHJvcFR5cGUgPSBwcm9wLnR5cGU7XG4gICAgICAgIGxldCBzaG91bGRDYXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzaG91bGRDYXN0VHJ1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0FycmF5KHByb3BUeXBlKSkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9wVHlwZS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwcm9wVHlwZVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IGlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZS5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBcIkJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBcIlN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHNob3VsZENhc3RUcnVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZENhc3QgPSBpc0Z1bmN0aW9uKHByb3BUeXBlKSAmJiBwcm9wVHlwZS5uYW1lID09PSBcIkJvb2xlYW5cIjtcbiAgICAgICAgfVxuICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBzaG91bGRDYXN0O1xuICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc2hvdWxkQ2FzdFRydWU7XG4gICAgICAgIGlmIChzaG91bGRDYXN0IHx8IGhhc093bihwcm9wLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gIGlmIChrZXlbMF0gIT09IFwiJFwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcbiAgaWYgKGN0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3Rvci5uYW1lIHx8IFwiXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGN0b3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuYW1lID0gY3Rvci5jb25zdHJ1Y3RvciAmJiBjdG9yLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgfHwgXCJcIjtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xuICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcbiAgY29uc3QgY2FtZWxpemVQcm9wc0tleSA9IE9iamVjdC5rZXlzKHJhd1Byb3BzKS5tYXAoKGtleSkgPT4gY2FtZWxpemUoa2V5KSk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFsaWRhdGVQcm9wKFxuICAgICAga2V5LFxuICAgICAgcmVzb2x2ZWRWYWx1ZXNba2V5XSxcbiAgICAgIG9wdCxcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocmVzb2x2ZWRWYWx1ZXMpIDogcmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAhY2FtZWxpemVQcm9wc0tleS5pbmNsdWRlcyhrZXkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBwcm9wcywgaXNBYnNlbnQpIHtcbiAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yLCBza2lwQ2hlY2sgfSA9IHByb3A7XG4gIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xuICAgIHdhcm4kMSgnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFyZXF1aXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUgJiYgIXNraXBDaGVjaykge1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8IFwiXCIpO1xuICAgICAgaXNWYWxpZCA9IHZhbGlkO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHdhcm4kMShnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlLCBwcm9wcykpIHtcbiAgICB3YXJuJDEoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIm51bGxcIikge1xuICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGBQcm9wIHR5cGUgW10gZm9yIHByb3AgXCIke25hbWV9XCIgd29uJ3QgbWF0Y2ggYW55dGhpbmcuIERpZCB5b3UgbWVhbiB0byB1c2UgdHlwZSBBcnJheSBpbnN0ZWFkP2A7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgcmV0dXJuIHJhd1Nsb3Q7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50SW5zdGFuY2UgJiYgKCFjdHggfHwgY3R4LnJvb3QgPT09IGN1cnJlbnRJbnN0YW5jZS5yb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICB9LCBjdHgpO1xuICBub3JtYWxpemVkLl9jID0gZmFsc2U7XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcbiAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKSBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcbiAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiYgdHJ1ZSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XG4gIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xufTtcbmNvbnN0IGFzc2lnblNsb3RzID0gKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKG9wdGltaXplZCB8fCBrZXkgIT09IFwiX1wiKSB7XG4gICAgICBzbG90c1trZXldID0gY2hpbGRyZW5ba2V5XTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3Qgc2xvdHMgPSBpbnN0YW5jZS5zbG90cyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICBpZiAob3B0aW1pemVkKSB7XG4gICAgICAgIGRlZihzbG90cywgXCJfXCIsIHR5cGUsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgfVxufTtcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcbiAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEpIHtcbiAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xuICB9XG4gIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKFxuICAgICAgYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsXG4gICAgICBzdGFydFRhZyxcbiAgICAgIGVuZFRhZ1xuICAgICk7XG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xuICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oXCIsIFwiKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgcHJvZHVjdGlvbiBidW5kbGUuXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UgO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gIHtcbiAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xuICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIHNldERldnRvb2xzSG9vayQxKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnNlcnQ6IGhvc3RJbnNlcnQsXG4gICAgcmVtb3ZlOiBob3N0UmVtb3ZlLFxuICAgIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCxcbiAgICBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCxcbiAgICBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCxcbiAgICBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCxcbiAgICBzZXRUZXh0OiBob3N0U2V0VGV4dCxcbiAgICBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LFxuICAgIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsXG4gICAgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLFxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBuYW1lc3BhY2UgPSB2b2lkIDAsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgIG4xID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHByb2Nlc3NGcmFnbWVudChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgXCJcIiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICBuMi5jaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG4yLmVsLFxuICAgICAgbjIuYW5jaG9yXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICB9O1xuICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGlmIChuMi50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgIH0gZWxzZSBpZiAobjIudHlwZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudEVsZW1lbnQoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGVsO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgY29uc3QgeyBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQoXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHZub2RlLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKGVsLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUgfHwgaXNTdXNwZW5zZShzdWJUcmVlLnR5cGUpICYmIChzdWJUcmVlLnNzQ29udGVudCA9PT0gdm5vZGUgfHwgc3ViVHJlZS5zc0ZhbGxiYWNrID09PSB2bm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBlbC5fX3Zub2RlID0gbjI7XG4gICAgfVxuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcbiAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTY7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICBpZiAodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVcGRhdGVcIik7XG4gICAgfVxuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9sZFByb3BzLmlubmVySFRNTCAmJiBuZXdQcm9wcy5pbm5lckhUTUwgPT0gbnVsbCB8fCBvbGRQcm9wcy50ZXh0Q29udGVudCAmJiBuZXdQcm9wcy50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMikge1xuICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJzdHlsZVwiLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XG4gICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjb250YWluZXIgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIG9sZFZOb2RlLmVsICYmIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XG4gICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXG4gICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBwYXRjaChcbiAgICAgICAgb2xkVk5vZGUsXG4gICAgICAgIG5ld1ZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gbjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDgpKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIC8vICMxMDAwN1xuICAgICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cbiAgICAgICAgLy8gYSBmcmFnbWVudCB3aGljaCBkb2Vzbid0IGhhdmUgYSBjaGlsZHJlbi5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIG4yLmNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAmJiBkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoXG4gICAgICBpbml0aWFsVk5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgZmFsc2UsIG9wdGltaXplZCk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIGluaXRpYWxWTm9kZS5lbCA9IG51bGw7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZCk7XG4gICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XG4gICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50LCByb290LCB0eXBlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKGJtKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XG4gICAgICAgICAgY29uc3QgaHlkcmF0ZVN1YlRyZWUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlICYmIHR5cGUuX19hc3luY0h5ZHJhdGUpIHtcbiAgICAgICAgICAgIHR5cGUuX19hc3luY0h5ZHJhdGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyb290LmNlKSB7XG4gICAgICAgICAgICByb290LmNlLl9pbmplY3RDaGlsZFN0eWxlKHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiB8fCBwYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJiBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBub25IeWRyYXRlZEFzeW5jUm9vdCA9IGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAobm9uSHlkcmF0ZWRBc3luY1Jvb3QpIHtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9uSHlkcmF0ZWRBc3luY1Jvb3QuYXN5bmNEZXAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRVcGRhdGVGbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1KSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgcHJldlRyZWUsXG4gICAgICAgICAgbmV4dFRyZWUsXG4gICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XG4gICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxuICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xuICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XG4gICAgY29uc3QgZWZmZWN0ID0gaW5zdGFuY2UuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGNvbXBvbmVudFVwZGF0ZUZuKTtcbiAgICBpbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QucnVuLmJpbmQoZWZmZWN0KTtcbiAgICBjb25zdCBqb2IgPSBpbnN0YW5jZS5qb2IgPSBlZmZlY3QucnVuSWZEaXJ0eS5iaW5kKGVmZmVjdCk7XG4gICAgam9iLmkgPSBpbnN0YW5jZTtcbiAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgZWZmZWN0LnNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDA7XG4gICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xuICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xuICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcbiAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gIH07XG4gIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcbiAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xuICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjgpIHtcbiAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2KSB7XG4gICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMiAhPT0gYzEpIHtcbiAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjMVtpXSxcbiAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgYzEsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMyLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcbiAgICBsZXQgZTIgPSBsMiAtIDE7XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtlMV07XG4gICAgICBjb25zdCBuMiA9IGMyW2UyXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSkgOiBub3JtYWxpemVWTm9kZShjMltlMl0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlMS0tO1xuICAgICAgZTItLTtcbiAgICB9XG4gICAgaWYgKGkgPiBlMSkge1xuICAgICAgaWYgKGkgPD0gZTIpIHtcbiAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSksXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpID4gZTIpIHtcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XG4gICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMxID0gaTtcbiAgICAgIGNvbnN0IHMyID0gaTtcbiAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLFxuICAgICAgICAgICAgICBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGo7XG4gICAgICBsZXQgcGF0Y2hlZCA9IDA7XG4gICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xuICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XG4gICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XG4gICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xuICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3SW5kZXg7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJiBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIHByZXZDaGlsZCxcbiAgICAgICAgICAgIGMyW25ld0luZGV4XSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGF0Y2hlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKSA6IEVNUFRZX0FSUjtcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XG4gICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICB9XG4gICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZWVkVHJhbnNpdGlvbjIgPSBtb3ZlVHlwZSAhPT0gMiAmJiBzaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb247XG4gICAgaWYgKG5lZWRUcmFuc2l0aW9uMikge1xuICAgICAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcmVtb3ZlMiA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmUyKCk7XG4gICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUyLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkaXJzLFxuICAgICAgY2FjaGVJbmRleFxuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNhY2hlSW5kZXggIT0gbnVsbCkge1xuICAgICAgcGFyZW50Q29tcG9uZW50LnJlbmRlckNhY2hlW2NhY2hlSW5kZXhdID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAmJiBkaXJzO1xuICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVW5tb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICB2bm9kZS50eXBlLnJlbW92ZShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjNTE1NFxuICAgICAgLy8gd2hlbiB2LW9uY2UgaXMgdXNlZCBpbnNpZGUgYSBibG9jaywgc2V0QmxvY2tUcmFja2luZygtMSkgbWFya3MgdGhlXG4gICAgICAvLyBwYXJlbnQgYmxvY2sgd2l0aCBoYXNPbmNlOiB0cnVlXG4gICAgICAvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgdGFrZSB0aGUgZmFzdCBwYXRoIGR1cmluZyB1bm1vdW50IC0gb3RoZXJ3aXNlXG4gICAgICAvLyBjb21wb25lbnRzIG5lc3RlZCBpbiB2LW9uY2UgYXJlIG5ldmVyIHVubW91bnRlZC5cbiAgICAgICFkeW5hbWljQ2hpbGRyZW4uaGFzT25jZSAmJiAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcbiAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fCBwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0KSkge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZyYWdtZW50ICYmIHBhdGNoRmxhZyAmICgxMjggfCAyNTYpIHx8ICFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlbW92ZSkge1xuICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSB8fCBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIHNob3VsZEludm9rZURpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcInVubW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5wYXRjaEZsYWcgPiAwICYmIHZub2RlLnBhdGNoRmxhZyAmIDIwNDggJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjaGlsZC5lbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xuICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtUmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgY3VyID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShlbmQpO1xuICB9O1xuICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIGpvYiwgc3ViVHJlZSwgdW0sIG0sIGEgfSA9IGluc3RhbmNlO1xuICAgIGludmFsaWRhdGVNb3VudChtKTtcbiAgICBpbnZhbGlkYXRlTW91bnQoYSk7XG4gICAgaWYgKGJ1bSkge1xuICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcbiAgICB9XG4gICAgc2NvcGUuc3RvcCgpO1xuICAgIGlmIChqb2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA4O1xuICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKHVtKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmIGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gICAgY29uc3QgdGVsZXBvcnRFbmQgPSBlbCAmJiBlbFtUZWxlcG9ydEVuZEtleV07XG4gICAgcmV0dXJuIHRlbGVwb3J0RW5kID8gaG9zdE5leHRTaWJsaW5nKHRlbGVwb3J0RW5kKSA6IGVsO1xuICB9O1xuICBsZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xuICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjb250YWluZXIuX3Zub2RlIHx8IG51bGwsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgaXNGbHVzaGluZyA9IHRydWU7XG4gICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHA6IHBhdGNoLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG06IG1vdmUsXG4gICAgcjogcmVtb3ZlLFxuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgbzogb3B0aW9uc1xuICB9O1xuICBsZXQgaHlkcmF0ZTtcbiAgbGV0IGh5ZHJhdGVOb2RlO1xuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhcbiAgICAgIGludGVybmFsc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgaHlkcmF0ZSxcbiAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UoeyB0eXBlLCBwcm9wcyB9LCBjdXJyZW50TmFtZXNwYWNlKSB7XG4gIHJldHVybiBjdXJyZW50TmFtZXNwYWNlID09PSBcInN2Z1wiICYmIHR5cGUgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IGN1cnJlbnROYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgJiYgdHlwZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIHByb3BzICYmIHByb3BzLmVuY29kaW5nICYmIHByb3BzLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IGN1cnJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCBqb2IgfSwgYWxsb3dlZCkge1xuICBpZiAoYWxsb3dlZCkge1xuICAgIGVmZmVjdC5mbGFncyB8PSAzMjtcbiAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QuZmxhZ3MgJj0gfjMyO1xuICAgIGpvYi5mbGFncyAmPSB+NDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiBjMi5wYXRjaEZsYWcgIT09IC0yKVxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjMi50eXBlID09PSBDb21tZW50ICYmICFjMi5lbCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2UoYXJyKSB7XG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICBsZXQgaSwgaiwgdSwgdiwgYztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICBpZiAoYXJySSAhPT0gMCkge1xuICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXJyW2pdIDwgYXJySSkge1xuICAgICAgICBwW2ldID0gajtcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IDA7XG4gICAgICB2ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodSA8IHYpIHtcbiAgICAgICAgYyA9IHUgKyB2ID4+IDE7XG4gICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcbiAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3VdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gIHYgPSByZXN1bHRbdSAtIDFdO1xuICB3aGlsZSAodS0tID4gMCkge1xuICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgdiA9IHBbdl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHN1YkNvbXBvbmVudCA9IGluc3RhbmNlLnN1YlRyZWUuY29tcG9uZW50O1xuICBpZiAoc3ViQ29tcG9uZW50KSB7XG4gICAgaWYgKHN1YkNvbXBvbmVudC5hc3luY0RlcCAmJiAhc3ViQ29tcG9uZW50LmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBzdWJDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChzdWJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZU1vdW50KGhvb2tzKSB7XG4gIGlmIChob29rcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICBob29rc1tpXS5mbGFncyB8PSA4O1xuICB9XG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG59O1xuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvbmNlIH0gPSBvcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJvbmNlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYmFzZVdhdGNoT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBiYXNlV2F0Y2hPcHRpb25zLm9uV2FybiA9IHdhcm4kMTtcbiAgY29uc3QgcnVuc0ltbWVkaWF0ZWx5ID0gY2IgJiYgaW1tZWRpYXRlIHx8ICFjYiAmJiBmbHVzaCAhPT0gXCJwb3N0XCI7XG4gIGxldCBzc3JDbGVhbnVwO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2UgaWYgKCFydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IHdhdGNoU3RvcEhhbmRsZSA9ICgpID0+IHtcbiAgICAgIH07XG4gICAgICB3YXRjaFN0b3BIYW5kbGUuc3RvcCA9IE5PT1A7XG4gICAgICB3YXRjaFN0b3BIYW5kbGUucmVzdW1lID0gTk9PUDtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5wYXVzZSA9IE5PT1A7XG4gICAgICByZXR1cm4gd2F0Y2hTdG9wSGFuZGxlO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgYmFzZVdhdGNoT3B0aW9ucy5jYWxsID0gKGZuLCB0eXBlLCBhcmdzKSA9PiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICBsZXQgaXNQcmUgPSBmYWxzZTtcbiAgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYikgPT4ge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZmx1c2ggIT09IFwic3luY1wiKSB7XG4gICAgaXNQcmUgPSB0cnVlO1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYiwgaXNGaXJzdFJ1bikgPT4ge1xuICAgICAgaWYgKGlzRmlyc3RSdW4pIHtcbiAgICAgICAgam9iKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUpvYihqb2IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYmFzZVdhdGNoT3B0aW9ucy5hdWdtZW50Sm9iID0gKGpvYikgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgam9iLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGlmIChpc1ByZSkge1xuICAgICAgam9iLmZsYWdzIHw9IDI7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICBqb2IuaSA9IGluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSB3YXRjaCQxKHNvdXJjZSwgY2IsIGJhc2VXYXRjaE9wdGlvbnMpO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKHNzckNsZWFudXApIHtcbiAgICAgIHNzckNsZWFudXAucHVzaCh3YXRjaEhhbmRsZSk7XG4gICAgfSBlbHNlIGlmIChydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgbGV0IGNiO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBjYiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cbiAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgcmVzZXQoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGN1ciA9IGN0eDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTW9kZWwocHJvcHMsIG5hbWUsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGNvbnN0IGNhbWVsaXplZE5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkucHJvcHNPcHRpb25zWzBdW2NhbWVsaXplZE5hbWVdKSB7XG4gICAgd2FybiQxKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRoIHByb3AgXCIke25hbWV9XCIgd2hpY2ggaXMgbm90IGRlY2xhcmVkLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBjb25zdCBoeXBoZW5hdGVkTmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGNhbWVsaXplZE5hbWUpO1xuICBjb25zdCByZXMgPSBjdXN0b21SZWYoKHRyYWNrLCB0cmlnZ2VyKSA9PiB7XG4gICAgbGV0IGxvY2FsVmFsdWU7XG4gICAgbGV0IHByZXZTZXRWYWx1ZSA9IEVNUFRZX09CSjtcbiAgICBsZXQgcHJldkVtaXR0ZWRWYWx1ZTtcbiAgICB3YXRjaFN5bmNFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbY2FtZWxpemVkTmFtZV07XG4gICAgICBpZiAoaGFzQ2hhbmdlZChsb2NhbFZhbHVlLCBwcm9wVmFsdWUpKSB7XG4gICAgICAgIGxvY2FsVmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXQgPyBvcHRpb25zLmdldChsb2NhbFZhbHVlKSA6IGxvY2FsVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSA9IG9wdGlvbnMuc2V0ID8gb3B0aW9ucy5zZXQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIGlmICghaGFzQ2hhbmdlZChlbWl0dGVkVmFsdWUsIGxvY2FsVmFsdWUpICYmICEocHJldlNldFZhbHVlICE9PSBFTVBUWV9PQkogJiYgaGFzQ2hhbmdlZCh2YWx1ZSwgcHJldlNldFZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3UHJvcHMgPSBpLnZub2RlLnByb3BzO1xuICAgICAgICBpZiAoIShyYXdQcm9wcyAmJiAvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHBhc3NlZCB2LW1vZGVsXG4gICAgICAgIChuYW1lIGluIHJhd1Byb3BzIHx8IGNhbWVsaXplZE5hbWUgaW4gcmF3UHJvcHMgfHwgaHlwaGVuYXRlZE5hbWUgaW4gcmF3UHJvcHMpICYmIChgb25VcGRhdGU6JHtuYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7Y2FtZWxpemVkTmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2h5cGhlbmF0ZWROYW1lfWAgaW4gcmF3UHJvcHMpKSkge1xuICAgICAgICAgIGxvY2FsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIGVtaXR0ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBlbWl0dGVkVmFsdWUpICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkgJiYgIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBwcmV2RW1pdHRlZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2U2V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcHJldkVtaXR0ZWRWYWx1ZSA9IGVtaXR0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmVzW1N5bWJvbC5pdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgbGV0IGkyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKGkyIDwgMikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpMisrID8gbW9kaWZpZXJzIHx8IEVNUFRZX09CSiA6IHJlcywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gcmVzO1xufVxuY29uc3QgZ2V0TW9kZWxNb2RpZmllcnMgPSAocHJvcHMsIG1vZGVsTmFtZSkgPT4ge1xuICByZXR1cm4gbW9kZWxOYW1lID09PSBcIm1vZGVsVmFsdWVcIiB8fCBtb2RlbE5hbWUgPT09IFwibW9kZWwtdmFsdWVcIiA/IHByb3BzLm1vZGVsTW9kaWZpZXJzIDogcHJvcHNbYCR7bW9kZWxOYW1lfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2NhbWVsaXplKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7aHlwaGVuYXRlKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF07XG59O1xuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHJldHVybjtcbiAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHNPcHRpb25zLFxuICAgICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICAgIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmIHRydWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSl9XCIgcHJvcC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgYXJncyA9IHJhd0FyZ3M7XG4gIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpO1xuICBjb25zdCBtb2RpZmllcnMgPSBpc01vZGVsTGlzdGVuZXIgJiYgZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGV2ZW50LnNsaWNlKDcpKTtcbiAgaWYgKG1vZGlmaWVycykge1xuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKChhKSA9PiBpc1N0cmluZyhhKSA/IGEudHJpbSgpIDogYSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAobG9vc2VUb051bWJlcik7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2UudHlwZVxuICAgICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShcbiAgICAgICAgICBldmVudFxuICAgICAgICApfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGxldCBoYW5kbGVyTmFtZTtcbiAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCldIHx8IC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKV07XG4gIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcbiAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSldO1xuICB9XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBoYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gIGlmIChvbmNlSGFuZGxlcikge1xuICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgb25jZUhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gIGxldCBub3JtYWxpemVkID0ge307XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICB9XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCBcIlwiKTtcbiAgcmV0dXJuIGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHwgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fCBoYXNPd24ob3B0aW9ucywga2V5KTtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBwcm9wcyxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIGNvbnN0IHRoaXNQcm94eSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgPyBuZXcgUHJveHkocHJveHlUb1VzZSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYFByb3BlcnR5ICcke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApfScgd2FzIGFjY2Vzc2VkIHZpYSAndGhpcycuIEF2b2lkIHVzaW5nICd0aGlzJyBpbiB0ZW1wbGF0ZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pIDogcHJveHlUb1VzZTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICB0aGlzUHJveHksXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIHNldHVwU3RhdGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyMiA9IENvbXBvbmVudDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlcjIubGVuZ3RoID4gMSA/IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGF0dHJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycywgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgb3IgdGVsZXBvcnQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzICgke2V2ZW50QXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm5vZGUuZGlycykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgbnVsbCwgZmFsc2UsIHRydWUpO1xuICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICB9XG4gIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHNldFRyYW5zaXRpb25Ib29rcyhyb290LCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XG4gICAgc2V0Um9vdChyb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByb290O1xuICB9XG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4sIGZhbHNlKTtcbiAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICByZXR1cm4gW3Zub2RlLCB2b2lkIDBdO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hpbGRSb290LnBhdGNoRmxhZyA+IDAgJiYgY2hpbGRSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRSb290KGNoaWxkUm9vdCk7XG4gIH1cbiAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbiwgcmVjdXJzZSA9IHRydWUpIHtcbiAgbGV0IHNpbmdsZVJvb3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZWN1cnNlICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnID4gMCAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJTaW5nbGVSb290KHNpbmdsZVJvb3QuY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gIGxldCByZXM7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJzdHlsZVwiIHx8IGlzT24oa2V5KSkge1xuICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAoNiB8IDEpIHx8IHZub2RlLnR5cGUgPT09IENvbW1lbnQ7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICB9XG4gICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsKSB7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBjb25zdCByb290ID0gcGFyZW50LnN1YlRyZWU7XG4gICAgaWYgKHJvb3Quc3VzcGVuc2UgJiYgcm9vdC5zdXNwZW5zZS5hY3RpdmVCcmFuY2ggPT09IHZub2RlKSB7XG4gICAgICByb290LmVsID0gdm5vZGUuZWw7XG4gICAgfVxuICAgIGlmIChyb290ID09PSB2bm9kZSkge1xuICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XG5sZXQgc3VzcGVuc2VJZCA9IDA7XG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XG4gIG5hbWU6IFwiU3VzcGVuc2VcIixcbiAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xuICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcbiAgLy8gaW50ZXJuYWxzLlxuICBfX2lzU3VzcGVuc2U6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRTdXNwZW5zZShcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLmRlcHMgPiAwICYmICFuMS5zdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgICAgICAgbjIuc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGF0Y2hTdXNwZW5zZShcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcbiAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuY29uc3QgU3VzcGVuc2UgPSBTdXNwZW5zZUltcGwgO1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcbiAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcbiAgICBldmVudExpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBhbmNob3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgKTtcbiAgcGF0Y2goXG4gICAgbnVsbCxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBudWxsLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvblBlbmRpbmdcIik7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUuc3NGYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICBzdXNwZW5zZS52bm9kZSA9IG4yO1xuICBuMi5lbCA9IG4xLmVsO1xuICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XG4gIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcbiAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xuICBpZiAocGVuZGluZ0JyYW5jaCkge1xuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFdmVudChuMiwgXCJvblBlbmRpbmdcIik7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgaWYgKG5ld0JyYW5jaC5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gbmV3QnJhbmNoLmNvbXBvbmVudC5zdXNwZW5zZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgfVxuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmICFoYXNXYXJuZWQpIHtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcbiAgICAgIGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbTogbW92ZSxcbiAgICB1bTogdW5tb3VudCxcbiAgICBuOiBuZXh0LFxuICAgIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBsZXQgcGFyZW50U3VzcGVuc2VJZDtcbiAgY29uc3QgaXNTdXNwZW5zaWJsZSA9IGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSk7XG4gIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlSWQgPSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQ7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzKys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/IHRvTnVtYmVyKHZub2RlLnByb3BzLnRpbWVvdXQpIDogdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcih0aW1lb3V0LCBgU3VzcGVuc2UgdGltZW91dGApO1xuICB9XG4gIGNvbnN0IGluaXRpYWxBbmNob3IgPSBhbmNob3I7XG4gIGNvbnN0IHN1c3BlbnNlID0ge1xuICAgIHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIG5hbWVzcGFjZSxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGRlcHM6IDAsXG4gICAgcGVuZGluZ0lkOiBzdXNwZW5zZUlkKyssXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyB0aW1lb3V0IDogLTEsXG4gICAgYWN0aXZlQnJhbmNoOiBudWxsLFxuICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgaXNJbkZhbGxiYWNrOiAhaXNIeWRyYXRpbmcsXG4gICAgaXNIeWRyYXRpbmcsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGVmZmVjdHM6IFtdLFxuICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UsIHN5bmMgPSBmYWxzZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdm5vZGU6IHZub2RlMixcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBwZW5kaW5nSWQsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIyXG4gICAgICB9ID0gc3VzcGVuc2U7XG4gICAgICBsZXQgZGVsYXlFbnRlciA9IGZhbHNlO1xuICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFyZXN1bWUpIHtcbiAgICAgICAgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBtb3ZlKFxuICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgICAgICBhbmNob3IgPT09IGluaXRpYWxBbmNob3IgPyBuZXh0KGFjdGl2ZUJyYW5jaCkgOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xuICAgICAgICAgIGlmIChwYXJlbnROb2RlKGFjdGl2ZUJyYW5jaC5lbCkgPT09IGNvbnRhaW5lcjIpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvciwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3RvciAmJiAhZGVsYXlFbnRlcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIG5hbWVzcGFjZTogbmFtZXNwYWNlMiB9ID0gc3VzcGVuc2U7XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgICBjb25zdCBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmYWxsYmFja1ZOb2RlLFxuICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBuYW1lc3BhY2UyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZDIpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkMlxuICAgICAgICApO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUyLmVsKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlMiwgZG9SZW1vdmUpIHtcbiAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdXNwZW5zZTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgbnVsbCxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFscyxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZFxuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzI7XG4gIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChcbiAgICBpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlblxuICApO1xuICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW4gPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xuICBsZXQgYmxvY2s7XG4gIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gZmFsc2U7XG4gICAgICBvcGVuQmxvY2soKTtcbiAgICB9XG4gICAgcyA9IHMoKTtcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IHRydWU7XG4gICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcbiAgICAgIGNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQXJyYXkocykpIHtcbiAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXNpbmdsZUNoaWxkICYmIHMuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgIT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpLmxlbmd0aCA+IDApIHtcbiAgICAgIHdhcm4kMShgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBsZXQgZWwgPSBicmFuY2guZWw7XG4gIHdoaWxlICghZWwgJiYgYnJhbmNoLmNvbXBvbmVudCkge1xuICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wb25lbnQuc3ViVHJlZTtcbiAgICBlbCA9IGJyYW5jaC5lbDtcbiAgfVxuICB2bm9kZS5lbCA9IGVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNpYmxlID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMuc3VzcGVuc2libGU7XG4gIHJldHVybiBzdXNwZW5zaWJsZSAhPSBudWxsICYmIHN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XG5jb25zdCBUZXh0ID0gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWNtdFwiKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XG4gIGJsb2NrU3RhY2sucHVzaChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgYmxvY2tTdGFjay5wb3AoKTtcbiAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUsIGluVk9uY2UgPSBmYWxzZSkge1xuICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XG4gIGlmICh2YWx1ZSA8IDAgJiYgY3VycmVudEJsb2NrICYmIGluVk9uY2UpIHtcbiAgICBjdXJyZW50QmxvY2suaGFzT25jZSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICBjbG9zZUJsb2NrKCk7XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZUJhc2VWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG4yLnNoYXBlRmxhZyAmIDYgJiYgbjEuY29tcG9uZW50KSB7XG4gICAgY29uc3QgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG4yLnR5cGUpO1xuICAgIGlmIChkaXJ0eUluc3RhbmNlcyAmJiBkaXJ0eUluc3RhbmNlcy5oYXMobjEuY29tcG9uZW50KSkge1xuICAgICAgbjEuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxuICAgIC4uLnZub2RlQXJnc1RyYW5zZm9ybWVyID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSA6IGFyZ3NcbiAgKTtcbn07XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHtcbiAgcmVmLFxuICByZWZfa2V5LFxuICByZWZfZm9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVmID0gXCJcIiArIHJlZjtcbiAgfVxuICByZXR1cm4gcmVmICE9IG51bGwgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH0gOiByZWYgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB2bm9kZSA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXG4gICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRTdGFydDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgfTtcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgIHdhcm4kMShgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAhaXNCbG9ja05vZGUgJiYgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXG4gIGN1cnJlbnRCbG9jayAmJiAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxuICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcbiAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXG4gIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cbiAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNikgJiYgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXG4gIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXG4gIHZub2RlLnBhdGNoRmxhZyAhPT0gMzIpIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuY29uc3QgY3JlYXRlVk5vZGUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0eXBlKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgIH1cbiAgICB0eXBlID0gQ29tbWVudDtcbiAgfVxuICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBtZXJnZVJlZjogdHJ1ZSAqL1xuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZWQucGF0Y2hGbGFnID0gLTI7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcbiAgfVxuICBpZiAocHJvcHMpIHtcbiAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XG4gICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSkgPyAxIDogaXNTdXNwZW5zZSh0eXBlKSA/IDEyOCA6IGlzVGVsZXBvcnQodHlwZSkgPyA2NCA6IGlzT2JqZWN0KHR5cGUpID8gNCA6IGlzRnVuY3Rpb24odHlwZSkgPyAyIDogMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xuICAgIHdhcm4kMShcbiAgICAgIGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgdGhhdCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXG4gICAgICBgXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCxcbiAgICAgIHR5cGVcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIHNoYXBlRmxhZyxcbiAgICBpc0Jsb2NrTm9kZSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBpc0ludGVybmFsT2JqZWN0KHByb3BzKSA/IGV4dGVuZCh7fSwgcHJvcHMpIDogcHJvcHM7XG59XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlLCBjbG9uZVRyYW5zaXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4sIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xuICBjb25zdCBjbG9uZWQgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZTogdm5vZGUudHlwZSxcbiAgICBwcm9wczogbWVyZ2VkUHJvcHMsXG4gICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZiA/IChcbiAgICAgIC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgbWVyZ2VSZWYgJiYgcmVmID8gaXNBcnJheShyZWYpID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXSA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxuICAgICkgOiByZWYsXG4gICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICBjaGlsZHJlbjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBwYXRjaEZsYWcgPT09IC0xICYmIGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKSA6IGNoaWxkcmVuLFxuICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgIHRhcmdldFN0YXJ0OiB2bm9kZS50YXJnZXRTdGFydCxcbiAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxuICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcbiAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgIHRyYW5zaXRpb24sXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXG4gICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcbiAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICBpZiAodHJhbnNpdGlvbiAmJiBjbG9uZVRyYW5zaXRpb24pIHtcbiAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICBjbG9uZWQsXG4gICAgICB0cmFuc2l0aW9uLmNsb25lKGNsb25lZClcbiAgICApO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSBcIiBcIiwgZmxhZyA9IDApIHtcbiAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcbiAgcmV0dXJuIGFzQmxvY2sgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgY2hpbGQuc2xpY2UoKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICFpc0ludGVybmFsT2JqZWN0KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDI7XG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgIHR5cGUgPSAzMjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlID0gMTY7XG4gICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDg7XG4gICAgfVxuICB9XG4gIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZykgOiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3LCBbXG4gICAgdm5vZGUsXG4gICAgcHJldlZOb2RlXG4gIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICB1aWQ6IHVpZCsrLFxuICAgIHZub2RlLFxuICAgIHR5cGUsXG4gICAgcGFyZW50LFxuICAgIGFwcENvbnRleHQsXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGpvYjogbnVsbCxcbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBpZHM6IHBhcmVudCA/IHBhcmVudC5pZHMgOiBbXCJcIiwgMCwgMF0sXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBzZXRJblNTUlNldHVwU3RhdGU7XG57XG4gIGNvbnN0IGcgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIGNvbnN0IHJlZ2lzdGVyR2xvYmFsU2V0dGVyID0gKGtleSwgc2V0dGVyKSA9PiB7XG4gICAgbGV0IHNldHRlcnM7XG4gICAgaWYgKCEoc2V0dGVycyA9IGdba2V5XSkpIHNldHRlcnMgPSBnW2tleV0gPSBbXTtcbiAgICBzZXR0ZXJzLnB1c2goc2V0dGVyKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgIGlmIChzZXR0ZXJzLmxlbmd0aCA+IDEpIHNldHRlcnMuZm9yRWFjaCgoc2V0KSA9PiBzZXQodikpO1xuICAgICAgZWxzZSBzZXR0ZXJzWzBdKHYpO1xuICAgIH07XG4gIH07XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGN1cnJlbnRJbnN0YW5jZSA9IHZcbiAgKTtcbiAgc2V0SW5TU1JTZXR1cFN0YXRlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX1NTUl9TRVRURVJTX19gLFxuICAgICh2KSA9PiBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSB2XG4gICk7XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICB9O1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIHsgaXNOYXRpdmVUYWcgfSkge1xuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGlzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSB7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShpc1NTUik7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGZhbHNlKTtcbiAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaW5zdGFuY2UucHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfVxuICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gIGlmIChzZXR1cCkge1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBzZXR1cENvbnRleHQgPSBpbnN0YW5jZS5zZXR1cENvbnRleHQgPSBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGw7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgc2V0dXAsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDAsXG4gICAgICBbXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsXG4gICAgICAgIHNldHVwQ29udGV4dFxuICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgaXNBc3luY1NldHVwID0gaXNQcm9taXNlKHNldHVwUmVzdWx0KTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoKGlzQXN5bmNTZXR1cCB8fCBpbnN0YW5jZS5zcCkgJiYgIWlzQXN5bmNXcmFwcGVyKGluc3RhbmNlKSkge1xuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoaXNBc3luY1NldHVwKSB7XG4gICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgIHdhcm4kMShcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChcbiAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXIgPSBDb21wb25lbnQucmVuZGVyIHx8IE5PT1A7XG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiB0cnVlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICB0cnkge1xuICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbjogYCwgQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGF0dHJzUHJveHlIYW5kbGVycyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH0sXG4gIHNldCgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSA6IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IGV4cG9zZSA9IChleHBvc2VkKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHdhcm4kMShgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3NlZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgbGV0IGF0dHJzUHJveHk7XG4gICAgbGV0IHNsb3RzUHJveHk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gYXR0cnNQcm94eSB8fCAoYXR0cnNQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICByZXR1cm4gc2xvdHNQcm94eSB8fCAoc2xvdHNQcm94eSA9IGdldFNsb3RzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZXhwb3NlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJzOiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycyksXG4gICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgZXhwb3NlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICB9XG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnN0YW5jZS5wcm94eTtcbiAgfVxufVxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgKGMpID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCBcIlwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudCkgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgOiBDb21wb25lbnQubmFtZSB8fCBpbmNsdWRlSW5mZXJyZWQgJiYgQ29tcG9uZW50Ll9fbmFtZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XG4gIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG5hbWUgPSBpbmZlckZyb21SZWdpc3RyeShcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgfHwgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50c1xuICAgICkgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcbiAgfVxuICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIFwiX192Y2NPcHRzXCIgaW4gdmFsdWU7XG59XG5cbmNvbnN0IGNvbXB1dGVkID0gKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoaSAmJiBpLmFwcENvbnRleHQuY29uZmlnLndhcm5SZWN1cnNpdmVDb21wdXRlZCkge1xuICAgICAgYy5fd2FyblJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjO1xufTtcblxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobCA9PT0gMikge1xuICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGwgPiAzKSB7XG4gICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNmNTIyMmRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNlYjJmOTZcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgX192dWVfY3VzdG9tX2Zvcm1hdHRlcjogdHJ1ZSxcbiAgICBoZWFkZXIob2JqKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgLy8gYXZvaWQgZGVidWdnZXIgYWNjZXNzaW5nIHZhbHVlIGFmZmVjdGluZyBiZWhhdmlvclxuICAgICAgICAgIGZvcm1hdFZhbHVlKFwiX3ZhbHVlXCIgaW4gb2JqID8gb2JqLl92YWx1ZSA6IG9iaiksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldC5jYWNoZUluZGV4ID0gaW5kZXg7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjUuMTNcIjtcbmNvbnN0IHdhcm4gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gd2FybiQxIDogTk9PUDtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSBFcnJvclR5cGVTdHJpbmdzJDEgO1xuY29uc3QgZGV2dG9vbHMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBkZXZ0b29scyQxIDogdm9pZCAwO1xuY29uc3Qgc2V0RGV2dG9vbHNIb29rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gc2V0RGV2dG9vbHNIb29rJDEgOiBOT09QO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGUsXG4gIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlLFxuICBlbnN1cmVWYWxpZFZOb2RlLFxuICBwdXNoV2FybmluZ0NvbnRleHQsXG4gIHBvcFdhcm5pbmdDb250ZXh0XG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5jb25zdCBEZXByZWNhdGlvblR5cGVzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBEZXByZWNhdGlvblR5cGVzLCBFcnJvckNvZGVzLCBFcnJvclR5cGVTdHJpbmdzLCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGh5ZHJhdGVPbklkbGUsIGh5ZHJhdGVPbkludGVyYWN0aW9uLCBoeWRyYXRlT25NZWRpYVF1ZXJ5LCBoeWRyYXRlT25WaXNpYmxlLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlSWQsIHVzZU1vZGVsLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVGVtcGxhdGVSZWYsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n"));

/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transition: function() { return /* binding */ Transition; },\n/* harmony export */   TransitionGroup: function() { return /* binding */ TransitionGroup; },\n/* harmony export */   VueElement: function() { return /* binding */ VueElement; },\n/* harmony export */   createApp: function() { return /* binding */ createApp; },\n/* harmony export */   createSSRApp: function() { return /* binding */ createSSRApp; },\n/* harmony export */   defineCustomElement: function() { return /* binding */ defineCustomElement; },\n/* harmony export */   defineSSRCustomElement: function() { return /* binding */ defineSSRCustomElement; },\n/* harmony export */   hydrate: function() { return /* binding */ hydrate; },\n/* harmony export */   initDirectivesForSSR: function() { return /* binding */ initDirectivesForSSR; },\n/* harmony export */   render: function() { return /* binding */ render; },\n/* harmony export */   useCssModule: function() { return /* binding */ useCssModule; },\n/* harmony export */   useCssVars: function() { return /* binding */ useCssVars; },\n/* harmony export */   useHost: function() { return /* binding */ useHost; },\n/* harmony export */   useShadowRoot: function() { return /* binding */ useShadowRoot; },\n/* harmony export */   vModelCheckbox: function() { return /* binding */ vModelCheckbox; },\n/* harmony export */   vModelDynamic: function() { return /* binding */ vModelDynamic; },\n/* harmony export */   vModelRadio: function() { return /* binding */ vModelRadio; },\n/* harmony export */   vModelSelect: function() { return /* binding */ vModelSelect; },\n/* harmony export */   vModelText: function() { return /* binding */ vModelText; },\n/* harmony export */   vShow: function() { return /* binding */ vShow; },\n/* harmony export */   withKeys: function() { return /* binding */ withKeys; },\n/* harmony export */   withModifiers: function() { return /* binding */ withModifiers; }\n/* harmony export */ });\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"Transition\",\"TransitionGroup\",\"VueElement\",\"createApp\",\"createSSRApp\",\"defineCustomElement\",\"defineSSRCustomElement\",\"hydrate\",\"initDirectivesForSSR\",\"render\",\"useCssModule\",\"useCssVars\",\"useHost\",\"useShadowRoot\",\"vModelCheckbox\",\"vModelDynamic\",\"vModelRadio\",\"vModelSelect\",\"vModelText\",\"vShow\",\"withKeys\",\"withModifiers\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n/**\n* @vue/runtime-dom v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n\n\n\n\nlet policy = void 0;\nconst tt = typeof window !== \"undefined\" && window.trustedTypes;\nif (tt) {\n  try {\n    policy = /* @__PURE__ */ tt.createPolicy(\"vue\", {\n      createHTML: (val) => val\n    });\n  } catch (e) {\n     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Error creating trusted types policy: ${e}`);\n  }\n}\nconst unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst mathmlNS = \"http://www.w3.org/1998/Math/MathML\";\nconst doc = typeof document !== \"undefined\" ? document : null;\nconst templateContainer = doc && /* @__PURE__ */ doc.createElement(\"template\");\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: (child) => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, namespace, is, props) => {\n    const el = namespace === \"svg\" ? doc.createElementNS(svgNS, tag) : namespace === \"mathml\" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);\n    if (tag === \"select\" && props && props.multiple != null) {\n      el.setAttribute(\"multiple\", props.multiple);\n    }\n    return el;\n  },\n  createText: (text) => doc.createTextNode(text),\n  createComment: (text) => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: (node) => node.parentNode,\n  nextSibling: (node) => node.nextSibling,\n  querySelector: (selector) => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, \"\");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, namespace, start, end) {\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    if (start && (start === end || start.nextSibling)) {\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling)) break;\n      }\n    } else {\n      templateContainer.innerHTML = unsafeToTrustedHTML(\n        namespace === \"svg\" ? `<svg>${content}</svg>` : namespace === \"mathml\" ? `<math>${content}</math>` : content\n      );\n      const template = templateContainer.content;\n      if (namespace === \"svg\" || namespace === \"mathml\") {\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n      // first\n      before ? before.nextSibling : parent.firstChild,\n      // last\n      anchor ? anchor.previousSibling : parent.lastChild\n    ];\n  }\n};\n\nconst TRANSITION = \"transition\";\nconst ANIMATION = \"animation\";\nconst vtcKey = Symbol(\"_vtc\");\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(\n  {},\n  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators,\n  DOMTransitionPropsValidators\n);\nconst decorate$1 = (t) => {\n  t.displayName = \"Transition\";\n  t.props = TransitionPropsValidators;\n  return t;\n};\nconst Transition = /* @__PURE__ */ decorate$1(\n  (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots)\n);\nconst callHook = (hook, args = []) => {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\n    hook.forEach((h2) => h2(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\nconst hasExplicitCallback = (hook) => {\n  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = \"v\",\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done, isCancelled) => {\n    el._enterCancelled = isCancelled;\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = (isAppear) => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      if (!el._enterCancelled) {\n        forceReflow();\n        addTransitionClass(el, leaveActiveClass);\n      } else {\n        addTransitionClass(el, leaveActiveClass);\n        forceReflow();\n      }\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false, void 0, true);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true, void 0, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);\n  if (true) {\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber)(res, \"<transition> explicit duration\");\n  }\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.add(c));\n  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.remove(c));\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el[vtcKey] = void 0;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout != null) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + \"end\";\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = (e) => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  const getStyleProperties = (key) => (styles[key] || \"\").split(\", \");\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(\n    getStyleProperties(`${TRANSITION}Property`).toString()\n  );\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\nfunction toMs(s) {\n  if (s === \"auto\") return 0;\n  return Number(s.slice(0, -1).replace(\",\", \".\")) * 1e3;\n}\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\n\nfunction patchClass(el, value, isSVG) {\n  const transitionClasses = el[vtcKey];\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(\" \");\n  }\n  if (value == null) {\n    el.removeAttribute(\"class\");\n  } else if (isSVG) {\n    el.setAttribute(\"class\", value);\n  } else {\n    el.className = value;\n  }\n}\n\nconst vShowOriginalDisplay = Symbol(\"_vod\");\nconst vShowHidden = Symbol(\"_vsh\");\nconst vShow = {\n  beforeMount(el, { value }, { transition }) {\n    el[vShowOriginalDisplay] = el.style.display === \"none\" ? \"\" : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    if (!value === !oldValue) return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, { value }) {\n    setDisplay(el, value);\n  }\n};\nif (true) {\n  vShow.name = \"show\";\n}\nfunction setDisplay(el, value) {\n  el.style.display = value ? el[vShowOriginalDisplay] : \"none\";\n  el[vShowHidden] = !value;\n}\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({ value }) => {\n    if (!value) {\n      return { style: { display: \"none\" } };\n    }\n  };\n}\n\nconst CSS_VAR_TEXT = Symbol( true ? \"CSS_VAR_TEXT\" : 0);\nfunction useCssVars(getter) {\n  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n  if (!instance) {\n     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);\n    return;\n  }\n  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {\n    Array.from(\n      document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)\n    ).forEach((node) => setVarsOnNode(node, vars));\n  };\n  if (true) {\n    instance.getCssVars = () => getter(instance.proxy);\n  }\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    if (instance.ce) {\n      setVarsOnNode(instance.ce, vars);\n    } else {\n      setVarsOnVNode(instance.subTree, vars);\n    }\n    updateTeleports(vars);\n  };\n  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate)(() => {\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb)(setVars);\n  });\n  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch)(setVars, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, { flush: \"post\" });\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, { childList: true });\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());\n  });\n}\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n    vnode.children.forEach((c) => setVarsOnVNode(c, vars));\n  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {\n    let { el, anchor } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor) break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    let cssText = \"\";\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key]);\n      cssText += `--${key}: ${vars[key]};`;\n    }\n    style[CSS_VAR_TEXT] = cssText;\n  }\n}\n\nconst displayRE = /(^|;)\\s*display\\s*:/;\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);\n  let hasControlledDisplay = false;\n  if (next && !isCssString) {\n    if (prev) {\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {\n        for (const key in prev) {\n          if (next[key] == null) {\n            setStyle(style, key, \"\");\n          }\n        }\n      } else {\n        for (const prevStyle of prev.split(\";\")) {\n          const key = prevStyle.slice(0, prevStyle.indexOf(\":\")).trim();\n          if (next[key] == null) {\n            setStyle(style, key, \"\");\n          }\n        }\n      }\n    }\n    for (const key in next) {\n      if (key === \"display\") {\n        hasControlledDisplay = true;\n      }\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    if (isCssString) {\n      if (prev !== next) {\n        const cssVarText = style[CSS_VAR_TEXT];\n        if (cssVarText) {\n          next += \";\" + cssVarText;\n        }\n        style.cssText = next;\n        hasControlledDisplay = displayRE.test(next);\n      }\n    } else if (prev) {\n      el.removeAttribute(\"style\");\n    }\n  }\n  if (vShowOriginalDisplay in el) {\n    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : \"\";\n    if (el[vShowHidden]) {\n      style.display = \"none\";\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {\n    val.forEach((v) => setStyle(style, name, v));\n  } else {\n    if (val == null) val = \"\";\n    if (true) {\n      if (semicolonRE.test(val)) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n          `Unexpected semicolon at the end of '${name}' style value: '${val}'`\n        );\n      }\n    }\n    if (name.startsWith(\"--\")) {\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        style.setProperty(\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed),\n          val.replace(importantRE, \"\"),\n          \"important\"\n        );\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = [\"Webkit\", \"Moz\", \"ms\"];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName);\n  if (name !== \"filter\" && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\n\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nfunction patchAttr(el, key, value, isSVG, instance, isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key)) {\n  if (isSVG && key.startsWith(\"xlink:\")) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(\n        key,\n        isBoolean ? \"\" : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(value) ? String(value) : value\n      );\n    }\n  }\n}\n\nfunction patchDOMProp(el, key, value, parentComponent, attrName) {\n  if (key === \"innerHTML\" || key === \"textContent\") {\n    if (value != null) {\n      el[key] = key === \"innerHTML\" ? unsafeToTrustedHTML(value) : value;\n    }\n    return;\n  }\n  const tag = el.tagName;\n  if (key === \"value\" && tag !== \"PROGRESS\" && // custom elements may use _value internally\n  !tag.includes(\"-\")) {\n    const oldValue = tag === \"OPTION\" ? el.getAttribute(\"value\") || \"\" : el.value;\n    const newValue = value == null ? (\n      // #11647: value should be set as empty string for null and undefined,\n      // but <input type=\"checkbox\"> should be set as 'on'.\n      el.type === \"checkbox\" ? \"on\" : \"\"\n    ) : String(value);\n    if (oldValue !== newValue || !(\"_value\" in el)) {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    el._value = value;\n    return;\n  }\n  let needRemove = false;\n  if (value === \"\" || value == null) {\n    const type = typeof el[key];\n    if (type === \"boolean\") {\n      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);\n    } else if (value == null && type === \"string\") {\n      value = \"\";\n      needRemove = true;\n    } else if (type === \"number\") {\n      value = 0;\n      needRemove = true;\n    }\n  }\n  try {\n    el[key] = value;\n  } catch (e) {\n    if ( true && !needRemove) {\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n        `Failed setting prop \"${key}\" on <${tag.toLowerCase()}>: value ${value} is invalid.`,\n        e\n      );\n    }\n  }\n  needRemove && el.removeAttribute(attrName || key);\n}\n\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nconst veiKey = Symbol(\"_vei\");\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  const invokers = el[veiKey] || (el[veiKey] = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    existingInvoker.value =  true ? sanitizeEventValue(nextValue, rawName) : 0;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      const invoker = invokers[rawName] = createInvoker(\n         true ? sanitizeEventValue(nextValue, rawName) : 0,\n        instance\n      );\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = void 0;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === \":\" ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2));\n  return [event, options];\n}\nlet cachedNow = 0;\nconst p = /* @__PURE__ */ Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = (e) => {\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(\n      patchStopImmediatePropagation(e, invoker.value),\n      instance,\n      5,\n      [e]\n    );\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction sanitizeEventValue(value, propName) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n    return value;\n  }\n  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type ${typeof value}.`\n  );\n  return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(\n      (fn) => (e2) => !e2._stopped && fn && fn(e2)\n    );\n  } else {\n    return value;\n  }\n}\n\nconst isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter\nkey.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;\nconst patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {\n  const isSVG = namespace === \"svg\";\n  if (key === \"class\") {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === \"style\") {\n    patchStyle(el, prevValue, nextValue);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === \".\" ? (key = key.slice(1), true) : key[0] === \"^\" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(el, key, nextValue);\n    if (!el.tagName.includes(\"-\") && (key === \"value\" || key === \"checked\" || key === \"selected\")) {\n      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== \"value\");\n    }\n  } else if (\n    // #11081 force set props for possible async custom element\n    el._isVueCE && (/[A-Z]/.test(key) || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(nextValue))\n  ) {\n    patchDOMProp(el, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), nextValue, parentComponent, key);\n  } else {\n    if (key === \"true-value\") {\n      el._trueValue = nextValue;\n    } else if (key === \"false-value\") {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    if (key === \"innerHTML\" || key === \"textContent\") {\n      return true;\n    }\n    if (key in el && isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n      return true;\n    }\n    return false;\n  }\n  if (key === \"spellcheck\" || key === \"draggable\" || key === \"translate\") {\n    return false;\n  }\n  if (key === \"form\") {\n    return false;\n  }\n  if (key === \"list\" && el.tagName === \"INPUT\") {\n    return false;\n  }\n  if (key === \"type\" && el.tagName === \"TEXTAREA\") {\n    return false;\n  }\n  if (key === \"width\" || key === \"height\") {\n    const tag = el.tagName;\n    if (tag === \"IMG\" || tag === \"VIDEO\" || tag === \"CANVAS\" || tag === \"SOURCE\") {\n      return false;\n    }\n  }\n  if (isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {\n    return false;\n  }\n  return key in el;\n}\n\nconst REMOVAL = {};\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineCustomElement(options, extraOptions, _createApp) {\n  const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options, extraOptions);\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(Comp)) (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Comp, extraOptions);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, _createApp);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\n/*! #__NO_SIDE_EFFECTS__ */\nconst defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {\n  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);\n};\nconst BaseClass = typeof HTMLElement !== \"undefined\" ? HTMLElement : class {\n};\nclass VueElement extends BaseClass {\n  constructor(_def, _props = {}, _createApp = createApp) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    this._createApp = _createApp;\n    this._isVueCE = true;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    /**\n     * @internal\n     */\n    this._app = null;\n    /**\n     * @internal\n     */\n    this._nonce = this._def.nonce;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    this._styleChildren = /* @__PURE__ */ new WeakSet();\n    this._ob = null;\n    if (this.shadowRoot && _createApp !== createApp) {\n      this._root = this.shadowRoot;\n    } else {\n      if ( true && this.shadowRoot) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \\`defineSSRCustomElement\\`.`\n        );\n      }\n      if (_def.shadowRoot !== false) {\n        this.attachShadow({ mode: \"open\" });\n        this._root = this.shadowRoot;\n      } else {\n        this._root = this;\n      }\n    }\n    if (!this._def.__asyncLoader) {\n      this._resolveProps(this._def);\n    }\n  }\n  connectedCallback() {\n    if (!this.isConnected) return;\n    if (!this.shadowRoot) {\n      this._parseSlots();\n    }\n    this._connected = true;\n    let parent = this;\n    while (parent = parent && (parent.parentNode || parent.host)) {\n      if (parent instanceof VueElement) {\n        this._parent = parent;\n        break;\n      }\n    }\n    if (!this._instance) {\n      if (this._resolved) {\n        this._setParent();\n        this._update();\n      } else {\n        if (parent && parent._pendingResolve) {\n          this._pendingResolve = parent._pendingResolve.then(() => {\n            this._pendingResolve = void 0;\n            this._resolveDef();\n          });\n        } else {\n          this._resolveDef();\n        }\n      }\n    }\n  }\n  _setParent(parent = this._parent) {\n    if (parent) {\n      this._instance.parent = parent._instance;\n      this._instance.provides = parent._instance.provides;\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n      if (!this._connected) {\n        if (this._ob) {\n          this._ob.disconnect();\n          this._ob = null;\n        }\n        this._app && this._app.unmount();\n        if (this._instance) this._instance.ce = void 0;\n        this._app = this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    if (this._pendingResolve) {\n      return;\n    }\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    this._ob = new MutationObserver((mutations) => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    });\n    this._ob.observe(this, { attributes: true });\n    const resolve = (def, isAsync = false) => {\n      this._resolved = true;\n      this._pendingResolve = void 0;\n      const { props, styles } = def;\n      let numberProps;\n      if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);\n            }\n            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      if (isAsync) {\n        this._resolveProps(def);\n      }\n      if (this.shadowRoot) {\n        this._applyStyles(styles);\n      } else if ( true && styles) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n          \"Custom element style injection is not supported when using shadowRoot: false\"\n        );\n      }\n      this._mount(def);\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      this._pendingResolve = asyncDef().then(\n        (def) => resolve(this._def = def, true)\n      );\n    } else {\n      resolve(this._def);\n    }\n  }\n  _mount(def) {\n    if (( true) && !def.name) {\n      def.name = \"VueElement\";\n    }\n    this._app = this._createApp(def);\n    if (def.configureApp) {\n      def.configureApp(this._app);\n    }\n    this._app._ceVNode = this._createVNode();\n    this._app.mount(this._root);\n    const exposed = this._instance && this._instance.exposed;\n    if (!exposed) return;\n    for (const key in exposed) {\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(this, key)) {\n        Object.defineProperty(this, key, {\n          // unwrap ref to be consistent with public instance behavior\n          get: () => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref)(exposed[key])\n        });\n      } else if (true) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Exposed property \"${key}\" already exists on custom element.`);\n      }\n    }\n  }\n  _resolveProps(def) {\n    const { props } = def;\n    const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props : Object.keys(props || {});\n    for (const key of Object.keys(this)) {\n      if (key[0] !== \"_\" && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key]);\n      }\n    }\n    for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val, true, true);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    if (key.startsWith(\"data-v-\")) return;\n    const has = this.hasAttribute(key);\n    let value = has ? this.getAttribute(key) : REMOVAL;\n    const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\n    if (has && this._numberProps && this._numberProps[camelKey]) {\n      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);\n    }\n    this._setProp(camelKey, value, false, true);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {\n    if (val !== this._props[key]) {\n      if (val === REMOVAL) {\n        delete this._props[key];\n      } else {\n        this._props[key] = val;\n        if (key === \"key\" && this._app) {\n          this._app._ceVNode.key = val;\n        }\n      }\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      if (shouldReflect) {\n        const ob = this._ob;\n        ob && ob.disconnect();\n        if (val === true) {\n          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), \"\");\n        } else if (typeof val === \"string\" || typeof val === \"number\") {\n          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + \"\");\n        } else if (!val) {\n          this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));\n        }\n        ob && ob.observe(this, { attributes: true });\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this._root);\n  }\n  _createVNode() {\n    const baseProps = {};\n    if (!this.shadowRoot) {\n      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);\n    }\n    const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, this._props));\n    if (!this._instance) {\n      vnode.ce = (instance) => {\n        this._instance = instance;\n        instance.ce = this;\n        instance.isCE = true;\n        if (true) {\n          instance.ceReload = (newStyles) => {\n            if (this._styles) {\n              this._styles.forEach((s) => this._root.removeChild(s));\n              this._styles.length = 0;\n            }\n            this._applyStyles(newStyles);\n            this._instance = null;\n            this._update();\n          };\n        }\n        const dispatch = (event, args) => {\n          this.dispatchEvent(\n            new CustomEvent(\n              event,\n              (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(args[0]) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ detail: args }, args[0]) : { detail: args }\n            )\n          );\n        };\n        instance.emit = (event, ...args) => {\n          dispatch(event, args);\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event) !== event) {\n            dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), args);\n          }\n        };\n        this._setParent();\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles, owner) {\n    if (!styles) return;\n    if (owner) {\n      if (owner === this._def || this._styleChildren.has(owner)) {\n        return;\n      }\n      this._styleChildren.add(owner);\n    }\n    const nonce = this._nonce;\n    for (let i = styles.length - 1; i >= 0; i--) {\n      const s = document.createElement(\"style\");\n      if (nonce) s.setAttribute(\"nonce\", nonce);\n      s.textContent = styles[i];\n      this.shadowRoot.prepend(s);\n      if (true) {\n        if (owner) {\n          if (owner.__hmrId) {\n            if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();\n            let entry = this._childStyles.get(owner.__hmrId);\n            if (!entry) {\n              this._childStyles.set(owner.__hmrId, entry = []);\n            }\n            entry.push(s);\n          }\n        } else {\n          (this._styles || (this._styles = [])).push(s);\n        }\n      }\n    }\n  }\n  /**\n   * Only called when shadowRoot is false\n   */\n  _parseSlots() {\n    const slots = this._slots = {};\n    let n;\n    while (n = this.firstChild) {\n      const slotName = n.nodeType === 1 && n.getAttribute(\"slot\") || \"default\";\n      (slots[slotName] || (slots[slotName] = [])).push(n);\n      this.removeChild(n);\n    }\n  }\n  /**\n   * Only called when shadowRoot is false\n   */\n  _renderSlots() {\n    const outlets = (this._teleportTarget || this).querySelectorAll(\"slot\");\n    const scopeId = this._instance.type.__scopeId;\n    for (let i = 0; i < outlets.length; i++) {\n      const o = outlets[i];\n      const slotName = o.getAttribute(\"name\") || \"default\";\n      const content = this._slots[slotName];\n      const parent = o.parentNode;\n      if (content) {\n        for (const n of content) {\n          if (scopeId && n.nodeType === 1) {\n            const id = scopeId + \"-s\";\n            const walker = document.createTreeWalker(n, 1);\n            n.setAttribute(id, \"\");\n            let child;\n            while (child = walker.nextNode()) {\n              child.setAttribute(id, \"\");\n            }\n          }\n          parent.insertBefore(n, o);\n        }\n      } else {\n        while (o.firstChild) parent.insertBefore(o.firstChild, o);\n      }\n      parent.removeChild(o);\n    }\n  }\n  /**\n   * @internal\n   */\n  _injectChildStyle(comp) {\n    this._applyStyles(comp.styles, comp);\n  }\n  /**\n   * @internal\n   */\n  _removeChildStyle(comp) {\n    if (true) {\n      this._styleChildren.delete(comp);\n      if (this._childStyles && comp.__hmrId) {\n        const oldStyles = this._childStyles.get(comp.__hmrId);\n        if (oldStyles) {\n          oldStyles.forEach((s) => this._root.removeChild(s));\n          oldStyles.length = 0;\n        }\n      }\n    }\n  }\n}\nfunction useHost(caller) {\n  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n  const el = instance && instance.ce;\n  if (el) {\n    return el;\n  } else if (true) {\n    if (!instance) {\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n        `${caller || \"useHost\"} called without an active component instance.`\n      );\n    } else {\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n        `${caller || \"useHost\"} can only be used in components defined via defineCustomElement.`\n      );\n    }\n  }\n  return null;\n}\nfunction useShadowRoot() {\n  const el =  true ? useHost(\"useShadowRoot\") : 0;\n  return el && el.shadowRoot;\n}\n\nfunction useCssModule(name = \"$style\") {\n  {\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n    if (!instance) {\n       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named \"${name}\".`);\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\n\nconst positionMap = /* @__PURE__ */ new WeakMap();\nconst newPositionMap = /* @__PURE__ */ new WeakMap();\nconst moveCbKey = Symbol(\"_moveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nconst decorate = (t) => {\n  delete t.props.mode;\n  return t;\n};\nconst TransitionGroupImpl = /* @__PURE__ */ decorate({\n  name: \"TransitionGroup\",\n  props: /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, { slots }) {\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();\n    let prevChildren;\n    let children;\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || \"v\"}-move`;\n      if (!hasCSSTransform(\n        prevChildren[0].el,\n        instance.vnode.el,\n        moveClass\n      )) {\n        return;\n      }\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      forceReflow();\n      movedChildren.forEach((c) => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = \"\";\n        const cb = el[moveCbKey] = (e) => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(\"transitionend\", cb);\n            el[moveCbKey] = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener(\"transitionend\", cb);\n      });\n    });\n    return () => {\n      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n      prevChildren = [];\n      if (children) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          if (child.el && child.el instanceof Element) {\n            prevChildren.push(child);\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(\n              child,\n              (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(\n                child,\n                cssTransitionProps,\n                state,\n                instance\n              )\n            );\n            positionMap.set(\n              child,\n              child.el.getBoundingClientRect()\n            );\n          }\n        }\n      }\n      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(\n            child,\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance)\n          );\n        } else if ( true && child.type !== _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text) {\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);\n        }\n      }\n      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);\n    };\n  }\n});\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el[moveCbKey]) {\n    el[moveCbKey]();\n  }\n  if (el[enterCbKey]) {\n    el[enterCbKey]();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = \"0s\";\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  const clone = el.cloneNode();\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.forEach((cls) => {\n      cls.split(/\\s+/).forEach((c) => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach((c) => c && clone.classList.add(c));\n  clone.style.display = \"none\";\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const { hasTransform } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\n\nconst getModelAssigner = (vnode) => {\n  const fn = vnode.props[\"onUpdate:modelValue\"] || false;\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event(\"input\"));\n  }\n}\nconst assignKey = Symbol(\"_assign\");\nconst vModelText = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === \"number\";\n    addEventListener(el, lazy ? \"change\" : \"input\", (e) => {\n      if (e.target.composing) return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(domValue);\n      }\n      el[assignKey](domValue);\n    });\n    if (trim) {\n      addEventListener(el, \"change\", () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, \"compositionstart\", onCompositionStart);\n      addEventListener(el, \"compositionend\", onCompositionEnd);\n      addEventListener(el, \"change\", onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, { value }) {\n    el.value = value == null ? \"\" : value;\n  },\n  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (el.composing) return;\n    const elValue = (number || el.type === \"number\") && !/^0\\d/.test(el.value) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(el.value) : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (elValue === newValue) {\n      return;\n    }\n    if (document.activeElement === el && el.type !== \"range\") {\n      if (lazy && value === oldValue) {\n        return;\n      }\n      if (trim && el.value.trim() === newValue) {\n        return;\n      }\n    }\n    el.value = newValue;\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el[assignKey];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {\n        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, { value, oldValue }, vnode) {\n  el._modelValue = value;\n  let checked;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n    checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\n    checked = value.has(vnode.props.value);\n  } else {\n    if (value === oldValue) return;\n    checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));\n  }\n  if (el.checked !== checked) {\n    el.checked = checked;\n  }\n}\nconst vModelRadio = {\n  created(el, { value }, vnode) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      el[assignKey](getValue(el));\n    });\n  },\n  beforeUpdate(el, { value, oldValue }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, { value, modifiers: { number } }, vnode) {\n    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);\n    addEventListener(el, \"change\", () => {\n      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(\n        (o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(getValue(o)) : getValue(o)\n      );\n      el[assignKey](\n        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]\n      );\n      el._assigning = true;\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n        el._assigning = false;\n      });\n    });\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, { value }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  updated(el, { value }) {\n    if (!el._assigning) {\n      setSelected(el, value);\n    }\n  }\n};\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  const isArrayValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);\n  if (isMultiple && !isArrayValue && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\n     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`\n    );\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if (isArrayValue) {\n        const optionType = typeof optionValue;\n        if (optionType === \"string\" || optionType === \"number\") {\n          option.selected = value.some((v) => String(v) === String(optionValue));\n        } else {\n          option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;\n        }\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {\n      if (el.selectedIndex !== i) el.selectedIndex = i;\n      return;\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\nfunction getValue(el) {\n  return \"_value\" in el ? el._value : el.value;\n}\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? \"_trueValue\" : \"_falseValue\";\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"created\");\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"mounted\");\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"beforeUpdate\");\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"updated\");\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case \"SELECT\":\n      return vModelSelect;\n    case \"TEXTAREA\":\n      return vModelText;\n    default:\n      switch (type) {\n        case \"checkbox\":\n          return vModelCheckbox;\n        case \"radio\":\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(\n    el.tagName,\n    vnode.props && vnode.props.type\n  );\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({ value }) => ({ value });\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\n    if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {\n      return { checked: true };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n      if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {\n        return { checked: true };\n      }\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return { checked: true };\n      }\n    } else if (value) {\n      return { checked: true };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== \"string\") {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n      vnode.type.toUpperCase(),\n      vnode.props && vnode.props.type\n    );\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\n\nconst systemModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\"];\nconst modifierGuards = {\n  stop: (e) => e.stopPropagation(),\n  prevent: (e) => e.preventDefault(),\n  self: (e) => e.target !== e.currentTarget,\n  ctrl: (e) => !e.ctrlKey,\n  shift: (e) => !e.shiftKey,\n  alt: (e) => !e.altKey,\n  meta: (e) => !e.metaKey,\n  left: (e) => \"button\" in e && e.button !== 0,\n  middle: (e) => \"button\" in e && e.button !== 1,\n  right: (e) => \"button\" in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))\n};\nconst withModifiers = (fn, modifiers) => {\n  const cache = fn._withMods || (fn._withMods = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers)) return;\n    }\n    return fn(event, ...args);\n  });\n};\nconst keyNames = {\n  esc: \"escape\",\n  space: \" \",\n  up: \"arrow-up\",\n  left: \"arrow-left\",\n  right: \"arrow-right\",\n  down: \"arrow-down\",\n  delete: \"backspace\"\n};\nconst withKeys = (fn, modifiers) => {\n  const cache = fn._withKeys || (fn._withKeys = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = (event) => {\n    if (!(\"key\" in event)) {\n      return;\n    }\n    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);\n    if (modifiers.some(\n      (k) => k === eventKey || keyNames[k] === eventKey\n    )) {\n      return fn(event);\n    }\n  });\n};\n\nconst rendererOptions = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\nconst render = (...args) => {\n  ensureRenderer().render(...args);\n};\nconst hydrate = (...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n};\nconst createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  if (true) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container) return;\n    const component = app._component;\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {\n      component.template = container.innerHTML;\n    }\n    if (container.nodeType === 1) {\n      container.textContent = \"\";\n    }\n    const proxy = mount(container, false, resolveRootNamespace(container));\n    if (container instanceof Element) {\n      container.removeAttribute(\"v-cloak\");\n      container.setAttribute(\"data-v-app\", \"\");\n    }\n    return proxy;\n  };\n  return app;\n};\nconst createSSRApp = (...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  if (true) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, resolveRootNamespace(container));\n    }\n  };\n  return app;\n};\nfunction resolveRootNamespace(container) {\n  if (container instanceof SVGElement) {\n    return \"svg\";\n  }\n  if (typeof MathMLElement === \"function\" && container instanceof MathMLElement) {\n    return \"mathml\";\n  }\n}\nfunction injectNativeTagCheck(app) {\n  Object.defineProperty(app.config, \"isNativeTag\", {\n    value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMathMLTag)(tag),\n    writable: false\n  });\n}\nfunction injectCompilerOptionsCheck(app) {\n  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, \"isCustomElement\", {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n          `The \\`isCustomElement\\` config option is deprecated. Use \\`compilerOptions.isCustomElement\\` instead.`\n        );\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka \"full build\"). Since you are using the runtime-only build, \\`compilerOptions\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\n- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;\n    Object.defineProperty(app.config, \"compilerOptions\", {\n      get() {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);\n        return compilerOptions;\n      },\n      set() {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {\n    const res = document.querySelector(container);\n    if ( true && !res) {\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n        `Failed to mount app: mount target selector \"${container}\" returned null.`\n      );\n    }\n    return res;\n  }\n  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === \"closed\") {\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(\n      `mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`\n    );\n  }\n  return container;\n}\nlet ssrDirectiveInitialized = false;\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n} ;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK2M7QUFDN2E7QUFDMFQ7O0FBRTVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osSUFBSSxLQUF5QyxJQUFJLHVEQUFJLHlDQUF5QyxFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtS0FBbUssSUFBSTtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNDQUFzQyxRQUFRLDRDQUE0QyxRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1EQUFNO0FBQ3hELElBQUk7QUFDSixFQUFFLDRFQUE2QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUF5QztBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFTLFNBQVMscURBQVEsU0FBUyx3REFBVztBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxnRUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVEsdURBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRLHVEQUFJO0FBQ1o7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBUTtBQUNkO0FBQ0EsUUFBUSxLQUF5QztBQUNqRCxNQUFNLHVEQUFJO0FBQ1YsdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXlDO0FBQy9DLElBQUksdURBQUk7QUFDUix3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanM/MjcyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQHZ1ZS9ydW50aW1lLWRvbSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyB3YXJuLCBoLCBCYXNlVHJhbnNpdGlvbiwgYXNzZXJ0TnVtYmVyLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgZ2V0Q3VycmVudEluc3RhbmNlLCBvbkJlZm9yZVVwZGF0ZSwgcXVldWVQb3N0Rmx1c2hDYiwgb25Nb3VudGVkLCB3YXRjaCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGNhbWVsaXplLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgdW5yZWYsIGNyZWF0ZVZOb2RlLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBUZXh0LCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaXNBcnJheSwgTk9PUCwgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1N5bWJvbCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzRnVuY3Rpb24sIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgaXNQbGFpbk9iamVjdCwgaGFzT3duLCBFTVBUWV9PQkosIGxvb3NlVG9OdW1iZXIsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGludm9rZUFycmF5Rm5zLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBpc01hdGhNTFRhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxubGV0IHBvbGljeSA9IHZvaWQgMDtcbmNvbnN0IHR0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuaWYgKHR0KSB7XG4gIHRyeSB7XG4gICAgcG9saWN5ID0gLyogQF9fUFVSRV9fICovIHR0LmNyZWF0ZVBvbGljeShcInZ1ZVwiLCB7XG4gICAgICBjcmVhdGVIVE1MOiAodmFsKSA9PiB2YWxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgRXJyb3IgY3JlYXRpbmcgdHJ1c3RlZCB0eXBlcyBwb2xpY3k6ICR7ZX1gKTtcbiAgfVxufVxuY29uc3QgdW5zYWZlVG9UcnVzdGVkSFRNTCA9IHBvbGljeSA/ICh2YWwpID0+IHBvbGljeS5jcmVhdGVIVE1MKHZhbCkgOiAodmFsKSA9PiB2YWw7XG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNvbnN0IG1hdGhtbE5TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiAvKiBAX19QVVJFX18gKi8gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbmNvbnN0IG5vZGVPcHMgPSB7XG4gIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcbiAgfSxcbiAgcmVtb3ZlOiAoY2hpbGQpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVFbGVtZW50OiAodGFnLCBuYW1lc3BhY2UsIGlzLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IGVsID0gbmFtZXNwYWNlID09PSBcInN2Z1wiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMobWF0aG1sTlMsIHRhZykgOiBpcyA/IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgeyBpcyB9KSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZyA9PT0gXCJzZWxlY3RcIiAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBwcm9wcy5tdWx0aXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSxcbiAgY3JlYXRlVGV4dDogKHRleHQpID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcbiAgY3JlYXRlQ29tbWVudDogKHRleHQpID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxuICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xuICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgfSxcbiAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfSxcbiAgcGFyZW50Tm9kZTogKG5vZGUpID0+IG5vZGUucGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IChub2RlKSA9PiBub2RlLm5leHRTaWJsaW5nLFxuICBxdWVyeVNlbGVjdG9yOiAoc2VsZWN0b3IpID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgc2V0U2NvcGVJZChlbCwgaWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICB9LFxuICAvLyBfX1VOU0FGRV9fXG4gIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxuICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXG4gIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIG5hbWVzcGFjZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gdW5zYWZlVG9UcnVzdGVkSFRNTChcbiAgICAgICAgbmFtZXNwYWNlID09PSBcInN2Z1wiID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBgPG1hdGg+JHtjb250ZW50fTwvbWF0aD5gIDogY29udGVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAvLyBmaXJzdFxuICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAvLyBsYXN0XG4gICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgIF07XG4gIH1cbn07XG5cbmNvbnN0IFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbmNvbnN0IEFOSU1BVElPTiA9IFwiYW5pbWF0aW9uXCI7XG5jb25zdCB2dGNLZXkgPSBTeW1ib2woXCJfdnRjXCIpO1xuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGNzczoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxuICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nXG59O1xuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXG4gIHt9LFxuICBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9yc1xuKTtcbmNvbnN0IGRlY29yYXRlJDEgPSAodCkgPT4ge1xuICB0LmRpc3BsYXlOYW1lID0gXCJUcmFuc2l0aW9uXCI7XG4gIHQucHJvcHMgPSBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzO1xuICByZXR1cm4gdDtcbn07XG5jb25zdCBUcmFuc2l0aW9uID0gLyogQF9fUFVSRV9fICovIGRlY29yYXRlJDEoXG4gIChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpXG4pO1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xuICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICBob29rKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gYmFzZVByb3BzO1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJ2XCIsXG4gICAgdHlwZSxcbiAgICBkdXJhdGlvbixcbiAgICBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcbiAgICBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxuICB9ID0gcmF3UHJvcHM7XG4gIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25MZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlcixcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkXG4gIH0gPSBiYXNlUHJvcHM7XG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSwgaXNDYW5jZWxsZWQpID0+IHtcbiAgICBlbC5fZW50ZXJDYW5jZWxsZWQgPSBpc0NhbmNlbGxlZDtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XG4gICAgZWwuX2lzTGVhdmluZyA9IGZhbHNlO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XG4gICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xuICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XG4gICAgICBjYWxsSG9vayhob29rLCBbZWwsIHJlc29sdmVdKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJGcm9tQ2xhc3MgOiBlbnRlckZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcbiAgICBvbkJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUVudGVyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcbiAgICB9LFxuICAgIG9uRW50ZXI6IG1ha2VFbnRlckhvb2soZmFsc2UpLFxuICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxuICAgIG9uTGVhdmUoZWwsIGRvbmUpIHtcbiAgICAgIGVsLl9pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgaWYgKCFlbC5fZW50ZXJDYW5jZWxsZWQpIHtcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICB9XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoIWVsLl9pc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcbiAgICB9LFxuICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlLCB2b2lkIDAsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoTGVhdmUoZWwpO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gW24sIG5dO1xuICB9XG59XG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcbiAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIocmVzLCBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvblwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgKGVsW3Z0Y0tleV0gfHwgKGVsW3Z0Y0tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICBlbFt2dGNLZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICBjb25zdCBpZCA9IGVsLl9lbmRJZCA9ICsrZW5kSWQ7XG4gIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoZXhwbGljaXRUaW1lb3V0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcbiAgfVxuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiByZXNvbHZlKCk7XG4gIH1cbiAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgXCJlbmRcIjtcbiAgbGV0IGVuZGVkID0gMDtcbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbiAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8IFwiXCIpLnNwbGl0KFwiLCBcIik7XG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EZWxheWApO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfURlbGF5YCk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0aW1lb3V0ID0gMDtcbiAgbGV0IHByb3BDb3VudCA9IDA7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXQgPyBUUkFOU0lUSU9OIDogQU5JTUFUSU9OIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlID8gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aCA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJiAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvLnRlc3QoXG4gICAgZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059UHJvcGVydHlgKS50b1N0cmluZygpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XG59XG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgaWYgKHMgPT09IFwiYXV0b1wiKSByZXR1cm4gMDtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpICogMWUzO1xufVxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWxbdnRjS2V5XTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXSA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oXCIgXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIH0gZWxzZSBpZiAoaXNTVkcpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgdlNob3dPcmlnaW5hbERpc3BsYXkgPSBTeW1ib2woXCJfdm9kXCIpO1xuY29uc3QgdlNob3dIaWRkZW4gPSBTeW1ib2woXCJfdnNoXCIpO1xuY29uc3QgdlNob3cgPSB7XG4gIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgcmV0dXJuO1xuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xuICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gIH1cbn07XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICB2U2hvdy5uYW1lID0gXCJzaG93XCI7XG59XG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gOiBcIm5vbmVcIjtcbiAgZWxbdlNob3dIaWRkZW5dID0gIXZhbHVlO1xufVxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xuICB2U2hvdy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH07XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBDU1NfVkFSX1RFWFQgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiQ1NTX1ZBUl9URVhUXCIgOiBcIlwiKTtcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cGRhdGVUZWxlcG9ydHMgPSBpbnN0YW5jZS51dCA9ICh2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KSkgPT4ge1xuICAgIEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYClcbiAgICApLmZvckVhY2goKG5vZGUpID0+IHNldFZhcnNPbk5vZGUobm9kZSwgdmFycykpO1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmdldENzc1ZhcnMgPSAoKSA9PiBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICB9XG4gIGNvbnN0IHNldFZhcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gICAgaWYgKGluc3RhbmNlLmNlKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGluc3RhbmNlLmNlLCB2YXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgdmFycyk7XG4gICAgfVxuICAgIHVwZGF0ZVRlbGVwb3J0cyh2YXJzKTtcbiAgfTtcbiAgb25CZWZvcmVVcGRhdGUoKCkgPT4ge1xuICAgIHF1ZXVlUG9zdEZsdXNoQ2Ioc2V0VmFycyk7XG4gIH0pO1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHdhdGNoKHNldFZhcnMsIE5PT1AsIHsgZmx1c2g6IFwicG9zdFwiIH0pO1xuICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XG4gICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XG4gICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xuICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHZub2RlLmVsKSB7XG4gICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XG4gICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgIGlmIChlbCA9PT0gYW5jaG9yKSBicmVhaztcbiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgbGV0IGNzc1RleHQgPSBcIlwiO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XG4gICAgICBjc3NUZXh0ICs9IGAtLSR7a2V5fTogJHt2YXJzW2tleV19O2A7XG4gICAgfVxuICAgIHN0eWxlW0NTU19WQVJfVEVYVF0gPSBjc3NUZXh0O1xuICB9XG59XG5cbmNvbnN0IGRpc3BsYXlSRSA9IC8oXnw7KVxccypkaXNwbGF5XFxzKjovO1xuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xuICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xuICBsZXQgaGFzQ29udHJvbGxlZERpc3BsYXkgPSBmYWxzZTtcbiAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICghaXNTdHJpbmcocHJldikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHByZXZTdHlsZSBvZiBwcmV2LnNwbGl0KFwiO1wiKSkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IHByZXZTdHlsZS5zbGljZSgwLCBwcmV2U3R5bGUuaW5kZXhPZihcIjpcIikpLnRyaW0oKTtcbiAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBpZiAoa2V5ID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNDc3NTdHJpbmcpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGNzc1ZhclRleHQgPSBzdHlsZVtDU1NfVkFSX1RFWFRdO1xuICAgICAgICBpZiAoY3NzVmFyVGV4dCkge1xuICAgICAgICAgIG5leHQgKz0gXCI7XCIgKyBjc3NWYXJUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IGRpc3BsYXlSRS50ZXN0KG5leHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfVxuICB9XG4gIGlmICh2U2hvd09yaWdpbmFsRGlzcGxheSBpbiBlbCkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGhhc0NvbnRyb2xsZWREaXNwbGF5ID8gc3R5bGUuZGlzcGxheSA6IFwiXCI7XG4gICAgaWYgKGVsW3ZTaG93SGlkZGVuXSkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgc2VtaWNvbG9uUkUgPSAvW15cXFxcXTtcXHMqJC87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xuICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsLmZvckVhY2goKHYpID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB2YWwgPSBcIlwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoc2VtaWNvbG9uUkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgJyR7bmFtZX0nIHN0eWxlIHZhbHVlOiAnJHt2YWx9J2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xuICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICBoeXBoZW5hdGUocHJlZml4ZWQpLFxuICAgICAgICAgIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCBcIlwiKSxcbiAgICAgICAgICBcImltcG9ydGFudFwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBwcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdO1xuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcbiAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XG4gIGlmIChuYW1lICE9PSBcImZpbHRlclwiICYmIG5hbWUgaW4gc3R5bGUpIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lO1xuICB9XG4gIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd05hbWU7XG59XG5cbmNvbnN0IHhsaW5rTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlLCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpKSB7XG4gIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aChcInhsaW5rOlwiKSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgaXNCb29sZWFuICYmICFpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFxuICAgICAgICBrZXksXG4gICAgICAgIGlzQm9vbGVhbiA/IFwiXCIgOiBpc1N5bWJvbCh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogdmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcGFyZW50Q29tcG9uZW50LCBhdHRyTmFtZSkge1xuICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGVsW2tleV0gPSBrZXkgPT09IFwiaW5uZXJIVE1MXCIgPyB1bnNhZmVUb1RydXN0ZWRIVE1MKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIHRhZyAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YWcgPT09IFwiT1BUSU9OXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlwiIDogZWwudmFsdWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gKFxuICAgICAgLy8gIzExNjQ3OiB2YWx1ZSBzaG91bGQgYmUgc2V0IGFzIGVtcHR5IHN0cmluZyBmb3IgbnVsbCBhbmQgdW5kZWZpbmVkLFxuICAgICAgLy8gYnV0IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIj4gc2hvdWxkIGJlIHNldCBhcyAnb24nLlxuICAgICAgZWwudHlwZSA9PT0gXCJjaGVja2JveFwiID8gXCJvblwiIDogXCJcIlxuICAgICkgOiBTdHJpbmcodmFsdWUpO1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUgfHwgIShcIl92YWx1ZVwiIGluIGVsKSkge1xuICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG5lZWRSZW1vdmUgPSBmYWxzZTtcbiAgaWYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XG4gICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB2YWx1ZSA9IGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWUgPSAwO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgZWxba2V5XSA9IHZhbHVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW5lZWRSZW1vdmUpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7dGFnLnRvTG93ZXJDYXNlKCl9PjogdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBuZWVkUmVtb3ZlICYmIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSB8fCBrZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuY29uc3QgdmVpS2V5ID0gU3ltYm9sKFwiX3ZlaVwiKTtcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcbiAgY29uc3QgaW52b2tlcnMgPSBlbFt2ZWlLZXldIHx8IChlbFt2ZWlLZXldID0ge30pO1xuICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcbiAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcbiAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2FuaXRpemVFdmVudFZhbHVlKG5leHRWYWx1ZSwgcmF3TmFtZSkgOiBuZXh0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xuICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgIGNvbnN0IGludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIoXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZSxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcbiAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcbiAgICBvcHRpb25zID0ge307XG4gICAgbGV0IG07XG4gICAgd2hpbGUgKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XG4gICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudCA9IG5hbWVbMl0gPT09IFwiOlwiID8gbmFtZS5zbGljZSgzKSA6IGh5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKTtcbiAgcmV0dXJuIFtldmVudCwgb3B0aW9uc107XG59XG5sZXQgY2FjaGVkTm93ID0gMDtcbmNvbnN0IHAgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbigoKSA9PiBjYWNoZWROb3cgPSAwKSwgY2FjaGVkTm93ID0gRGF0ZS5ub3coKSk7XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XG4gICAgaWYgKCFlLl92dHMpIHtcbiAgICAgIGUuX3Z0cyA9IERhdGUubm93KCk7XG4gICAgfSBlbHNlIGlmIChlLl92dHMgPD0gaW52b2tlci5hdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA1LFxuICAgICAgW2VdXG4gICAgKTtcbiAgfTtcbiAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xuICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXZlbnRWYWx1ZSh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHdhcm4oXG4gICAgYFdyb25nIHR5cGUgcGFzc2VkIGFzIGV2ZW50IGhhbmRsZXIgdG8gJHtwcm9wTmFtZX0gLSBkaWQgeW91IGZvcmdldCBAIG9yIDogaW4gZnJvbnQgb2YgeW91ciBwcm9wP1xuRXhwZWN0ZWQgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zLCByZWNlaXZlZCB0eXBlICR7dHlwZW9mIHZhbHVlfS5gXG4gICk7XG4gIHJldHVybiBOT09QO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlLm1hcChcbiAgICAgIChmbikgPT4gKGUyKSA9PiAhZTIuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZTIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgaXNOYXRpdmVPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyBsb3dlcmNhc2UgbGV0dGVyXG5rZXkuY2hhckNvZGVBdCgyKSA+IDk2ICYmIGtleS5jaGFyQ29kZUF0KDIpIDwgMTIzO1xuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICBjb25zdCBpc1NWRyA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIjtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5WzBdID09PSBcIi5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIHRydWUpIDoga2V5WzBdID09PSBcIl5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIGZhbHNlKSA6IHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xuICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUpO1xuICAgIGlmICghZWwudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikgJiYgKGtleSA9PT0gXCJ2YWx1ZVwiIHx8IGtleSA9PT0gXCJjaGVja2VkXCIgfHwga2V5ID09PSBcInNlbGVjdGVkXCIpKSB7XG4gICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRywgcGFyZW50Q29tcG9uZW50LCBrZXkgIT09IFwidmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIC8vICMxMTA4MSBmb3JjZSBzZXQgcHJvcHMgZm9yIHBvc3NpYmxlIGFzeW5jIGN1c3RvbSBlbGVtZW50XG4gICAgZWwuX2lzVnVlQ0UgJiYgKC9bQS1aXS8udGVzdChrZXkpIHx8ICFpc1N0cmluZyhuZXh0VmFsdWUpKVxuICApIHtcbiAgICBwYXRjaERPTVByb3AoZWwsIGNhbWVsaXplJDEoa2V5KSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSA9PT0gXCJ0cnVlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xuICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgaWYgKGlzU1ZHKSB7XG4gICAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gZWwgJiYgaXNOYXRpdmVPbihrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwic3BlbGxjaGVja1wiIHx8IGtleSA9PT0gXCJkcmFnZ2FibGVcIiB8fCBrZXkgPT09IFwidHJhbnNsYXRlXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJmb3JtXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJsaXN0XCIgJiYgZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwidHlwZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcIndpZHRoXCIgfHwga2V5ID09PSBcImhlaWdodFwiKSB7XG4gICAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgICBpZiAodGFnID09PSBcIklNR1wiIHx8IHRhZyA9PT0gXCJWSURFT1wiIHx8IHRhZyA9PT0gXCJDQU5WQVNcIiB8fCB0YWcgPT09IFwiU09VUkNFXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTmF0aXZlT24oa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleSBpbiBlbDtcbn1cblxuY29uc3QgUkVNT1ZBTCA9IHt9O1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIF9jcmVhdGVBcHApIHtcbiAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICBpZiAoaXNQbGFpbk9iamVjdChDb21wKSkgZXh0ZW5kKENvbXAsIGV4dHJhT3B0aW9ucyk7XG4gIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgX2NyZWF0ZUFwcCk7XG4gICAgfVxuICB9XG4gIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XG59XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAob3B0aW9ucywgZXh0cmFPcHRpb25zKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIGNyZWF0ZVNTUkFwcCk7XG59O1xuY29uc3QgQmFzZUNsYXNzID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XG59O1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBfY3JlYXRlQXBwID0gY3JlYXRlQXBwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgIHRoaXMuX2NyZWF0ZUFwcCA9IF9jcmVhdGVBcHA7XG4gICAgdGhpcy5faXNWdWVDRSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FwcCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbm9uY2UgPSB0aGlzLl9kZWYubm9uY2U7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGVDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX29iID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIF9jcmVhdGVBcHAgIT09IGNyZWF0ZUFwcCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGVmLnNoYWRvd1Jvb3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLl9wYXJzZVNsb3RzKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSB7XG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRQYXJlbnQocGFyZW50ID0gdGhpcy5fcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5faW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX29iKSB7XG4gICAgICAgICAgdGhpcy5fb2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuX29iID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHAgJiYgdGhpcy5fYXBwLnVubW91bnQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB0aGlzLl9pbnN0YW5jZS5jZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fYXBwID0gdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXNvbHZlIGlubmVyIGNvbXBvbmVudCBkZWZpbml0aW9uIChoYW5kbGUgcG9zc2libGUgYXN5bmMgY29tcG9uZW50KVxuICAgKi9cbiAgX3Jlc29sdmVEZWYoKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyKHRoaXMuYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9vYi5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xuICAgICAgbGV0IG51bWJlclByb3BzO1xuICAgICAgaWYgKHByb3BzICYmICFpc0FycmF5KHByb3BzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgICAgaWYgKG9wdCA9PT0gTnVtYmVyIHx8IG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2NhbWVsaXplJDEoa2V5KV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcbiAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyhkZWYpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhzdHlsZXMpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHN0eWxlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiQ3VzdG9tIGVsZW1lbnQgc3R5bGUgaW5qZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiB1c2luZyBzaGFkb3dSb290OiBmYWxzZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3VudChkZWYpO1xuICAgIH07XG4gICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICBpZiAoYXN5bmNEZWYpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gYXN5bmNEZWYoKS50aGVuKFxuICAgICAgICAoZGVmKSA9PiByZXNvbHZlKHRoaXMuX2RlZiA9IGRlZiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUodGhpcy5fZGVmKTtcbiAgICB9XG4gIH1cbiAgX21vdW50KGRlZikge1xuICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmICFkZWYubmFtZSkge1xuICAgICAgZGVmLm5hbWUgPSBcIlZ1ZUVsZW1lbnRcIjtcbiAgICB9XG4gICAgdGhpcy5fYXBwID0gdGhpcy5fY3JlYXRlQXBwKGRlZik7XG4gICAgaWYgKGRlZi5jb25maWd1cmVBcHApIHtcbiAgICAgIGRlZi5jb25maWd1cmVBcHAodGhpcy5fYXBwKTtcbiAgICB9XG4gICAgdGhpcy5fYXBwLl9jZVZOb2RlID0gdGhpcy5fY3JlYXRlVk5vZGUoKTtcbiAgICB0aGlzLl9hcHAubW91bnQodGhpcy5fcm9vdCk7XG4gICAgY29uc3QgZXhwb3NlZCA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmV4cG9zZWQ7XG4gICAgaWYgKCFleHBvc2VkKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXhwb3NlZCkge1xuICAgICAgaWYgKCFoYXNPd24odGhpcywga2V5KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgLy8gdW53cmFwIHJlZiB0byBiZSBjb25zaXN0ZW50IHdpdGggcHVibGljIGluc3RhbmNlIGJlaGF2aW9yXG4gICAgICAgICAgZ2V0OiAoKSA9PiB1bnJlZihleHBvc2VkW2tleV0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4oYEV4cG9zZWQgcHJvcGVydHkgXCIke2tleX1cIiBhbHJlYWR5IGV4aXN0cyBvbiBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Jlc29sdmVQcm9wcyhkZWYpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBkZWY7XG4gICAgY29uc3QgZGVjbGFyZWRQcm9wS2V5cyA9IGlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBPYmplY3Qua2V5cyhwcm9wcyB8fCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGlmIChrZXlbMF0gIT09IFwiX1wiICYmIGRlY2xhcmVkUHJvcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRBdHRyKGtleSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImRhdGEtdi1cIikpIHJldHVybjtcbiAgICBjb25zdCBoYXMgPSB0aGlzLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgIGxldCB2YWx1ZSA9IGhhcyA/IHRoaXMuZ2V0QXR0cmlidXRlKGtleSkgOiBSRU1PVkFMO1xuICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xuICAgIGlmIChoYXMgJiYgdGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0UHJvcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgaWYgKHZhbCA9PT0gUkVNT1ZBTCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2V5XCIgJiYgdGhpcy5fYXBwKSB7XG4gICAgICAgICAgdGhpcy5fYXBwLl9jZVZOb2RlLmtleSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iID0gdGhpcy5fb2I7XG4gICAgICAgIG9iICYmIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgdmFsICsgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBvYiAmJiBvYi5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZSgpIHtcbiAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5fcm9vdCk7XG4gIH1cbiAgX2NyZWF0ZVZOb2RlKCkge1xuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICBiYXNlUHJvcHMub25Wbm9kZU1vdW50ZWQgPSBiYXNlUHJvcHMub25Wbm9kZVVwZGF0ZWQgPSB0aGlzLl9yZW5kZXJTbG90cy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKGJhc2VQcm9wcywgdGhpcy5fcHJvcHMpKTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB2bm9kZS5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZS5jZSA9IHRoaXM7XG4gICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gKG5ld1N0eWxlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KGFyZ3NbMF0pID8gZXh0ZW5kKHsgZGV0YWlsOiBhcmdzIH0sIGFyZ3NbMF0pIDogeyBkZXRhaWw6IGFyZ3MgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaChldmVudCwgYXJncyk7XG4gICAgICAgICAgaWYgKGh5cGhlbmF0ZShldmVudCkgIT09IGV2ZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIF9hcHBseVN0eWxlcyhzdHlsZXMsIG93bmVyKSB7XG4gICAgaWYgKCFzdHlsZXMpIHJldHVybjtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIGlmIChvd25lciA9PT0gdGhpcy5fZGVmIHx8IHRoaXMuX3N0eWxlQ2hpbGRyZW4uaGFzKG93bmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmFkZChvd25lcik7XG4gICAgfVxuICAgIGNvbnN0IG5vbmNlID0gdGhpcy5fbm9uY2U7XG4gICAgZm9yIChsZXQgaSA9IHN0eWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIGlmIChub25jZSkgcy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICBzLnRleHRDb250ZW50ID0gc3R5bGVzW2ldO1xuICAgICAgdGhpcy5zaGFkb3dSb290LnByZXBlbmQocyk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICBpZiAob3duZXIuX19obXJJZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGlsZFN0eWxlcykgdGhpcy5fY2hpbGRTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KG93bmVyLl9faG1ySWQpO1xuICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICB0aGlzLl9jaGlsZFN0eWxlcy5zZXQob3duZXIuX19obXJJZCwgZW50cnkgPSBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeS5wdXNoKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZG93Um9vdCBpcyBmYWxzZVxuICAgKi9cbiAgX3BhcnNlU2xvdHMoKSB7XG4gICAgY29uc3Qgc2xvdHMgPSB0aGlzLl9zbG90cyA9IHt9O1xuICAgIGxldCBuO1xuICAgIHdoaWxlIChuID0gdGhpcy5maXJzdENoaWxkKSB7XG4gICAgICBjb25zdCBzbG90TmFtZSA9IG4ubm9kZVR5cGUgPT09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgKHNsb3RzW3Nsb3ROYW1lXSB8fCAoc2xvdHNbc2xvdE5hbWVdID0gW10pKS5wdXNoKG4pO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChuKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZG93Um9vdCBpcyBmYWxzZVxuICAgKi9cbiAgX3JlbmRlclNsb3RzKCkge1xuICAgIGNvbnN0IG91dGxldHMgPSAodGhpcy5fdGVsZXBvcnRUYXJnZXQgfHwgdGhpcykucXVlcnlTZWxlY3RvckFsbChcInNsb3RcIik7XG4gICAgY29uc3Qgc2NvcGVJZCA9IHRoaXMuX2luc3RhbmNlLnR5cGUuX19zY29wZUlkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbyA9IG91dGxldHNbaV07XG4gICAgICBjb25zdCBzbG90TmFtZSA9IG8uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9zbG90c1tzbG90TmFtZV07XG4gICAgICBjb25zdCBwYXJlbnQgPSBvLnBhcmVudE5vZGU7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgY29udGVudCkge1xuICAgICAgICAgIGlmIChzY29wZUlkICYmIG4ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NvcGVJZCArIFwiLXNcIjtcbiAgICAgICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobiwgMSk7XG4gICAgICAgICAgICBuLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoby5maXJzdENoaWxkKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG8uZmlyc3RDaGlsZCwgbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pbmplY3RDaGlsZFN0eWxlKGNvbXApIHtcbiAgICB0aGlzLl9hcHBseVN0eWxlcyhjb21wLnN0eWxlcywgY29tcCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JlbW92ZUNoaWxkU3R5bGUoY29tcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmRlbGV0ZShjb21wKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZFN0eWxlcyAmJiBjb21wLl9faG1ySWQpIHtcbiAgICAgICAgY29uc3Qgb2xkU3R5bGVzID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KGNvbXAuX19obXJJZCk7XG4gICAgICAgIGlmIChvbGRTdHlsZXMpIHtcbiAgICAgICAgICBvbGRTdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgb2xkU3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUhvc3QoY2FsbGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IGVsID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY2U7XG4gIGlmIChlbCkge1xuICAgIHJldHVybiBlbDtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FsbGVyIHx8IFwidXNlSG9zdFwifSBjYWxsZWQgd2l0aG91dCBhbiBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FuIG9ubHkgYmUgdXNlZCBpbiBjb21wb25lbnRzIGRlZmluZWQgdmlhIGRlZmluZUN1c3RvbUVsZW1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTaGFkb3dSb290KCkge1xuICBjb25zdCBlbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB1c2VIb3N0KFwidXNlU2hhZG93Um9vdFwiKSA6IHVzZUhvc3QoKTtcbiAgcmV0dXJuIGVsICYmIGVsLnNoYWRvd1Jvb3Q7XG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gXCIkc3R5bGVcIikge1xuICB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xuICAgIGlmICghbW9kKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZDtcbiAgfVxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1vdmVDYktleSA9IFN5bWJvbChcIl9tb3ZlQ2JcIik7XG5jb25zdCBlbnRlckNiS2V5ID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5jb25zdCBkZWNvcmF0ZSA9ICh0KSA9PiB7XG4gIGRlbGV0ZSB0LnByb3BzLm1vZGU7XG4gIHJldHVybiB0O1xufTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUoe1xuICBuYW1lOiBcIlRyYW5zaXRpb25Hcm91cFwiLFxuICBwcm9wczogLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0pLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIG9uVXBkYXRlZCgoKSA9PiB7XG4gICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgXCJ2XCJ9LW1vdmVgO1xuICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0oXG4gICAgICAgIHByZXZDaGlsZHJlblswXS5lbCxcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUuZWwsXG4gICAgICAgIG1vdmVDbGFzc1xuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGNiID0gZWxbbW92ZUNiS2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgICAgICAgIGVsW21vdmVDYktleV0gPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgcHJldkNoaWxkcmVuID0gW107XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgaWYgKGNoaWxkLmVsICYmIGNoaWxkLmVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBjc3NUcmFuc2l0aW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hpbGQudHlwZSAhPT0gVGV4dCkge1xuICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gIGNvbnN0IGVsID0gYy5lbDtcbiAgaWYgKGVsW21vdmVDYktleV0pIHtcbiAgICBlbFttb3ZlQ2JLZXldKCk7XG4gIH1cbiAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgZWxbZW50ZXJDYktleV0oKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcbiAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0pO1xuICB9XG4gIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGNsb25lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XG4gIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1tcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIl0gfHwgZmFsc2U7XG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcbiAgfVxufVxuY29uc3QgYXNzaWduS2V5ID0gU3ltYm9sKFwiX2Fzc2lnblwiKTtcbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSBcIm51bWJlclwiO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyBcImNoYW5nZVwiIDogXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuO1xuICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XG4gICAgICBpZiAodHJpbSkge1xuICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgZG9tVmFsdWUgPSBsb29zZVRvTnVtYmVyKGRvbVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsW2Fzc2lnbktleV0oZG9tVmFsdWUpO1xuICAgIH0pO1xuICAgIGlmICh0cmltKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbGF6eSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uZW5kXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICB9LFxuICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSwgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmIChlbC5jb21wb3NpbmcpIHJldHVybjtcbiAgICBjb25zdCBlbFZhbHVlID0gKG51bWJlciB8fCBlbC50eXBlID09PSBcIm51bWJlclwiKSAmJiAhL14wXFxkLy50ZXN0KGVsLnZhbHVlKSA/IGxvb3NlVG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIGlmIChlbFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gXCJyYW5nZVwiKSB7XG4gICAgICBpZiAobGF6eSAmJiB2YWx1ZSA9PT0gb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gIH1cbn07XG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcbiAgLy8gIzQwOTYgYXJyYXkgY2hlY2tib3hlcyBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcbiAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcbiAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xuICAgICAgY29uc3QgYXNzaWduID0gZWxbYXNzaWduS2V5XTtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG9vc2VJbmRleE9mKG1vZGVsVmFsdWUsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xuICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcbiAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcbiAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbihjbG9uZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXG4gIG1vdW50ZWQ6IHNldENoZWNrZWQsXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0Q2hlY2tlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgbGV0IGNoZWNrZWQ7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIGNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcbiAgICBjaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICB9XG4gIGlmIChlbC5jaGVja2VkICE9PSBjaGVja2VkKSB7XG4gICAgZWwuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgZWxbYXNzaWduS2V5XShnZXRWYWx1ZShlbCkpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpLm1hcChcbiAgICAgICAgKG8pID0+IG51bWJlciA/IGxvb3NlVG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobylcbiAgICAgICk7XG4gICAgICBlbFthc3NpZ25LZXldKFxuICAgICAgICBlbC5tdWx0aXBsZSA/IGlzU2V0TW9kZWwgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKSA6IHNlbGVjdGVkVmFsIDogc2VsZWN0ZWRWYWxbMF1cbiAgICAgICk7XG4gICAgICBlbC5fYXNzaWduaW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgZWwuX2Fzc2lnbmluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gIC8vIDxvcHRpb24+cy5cbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIGlmICghZWwuX2Fzc2lnbmluZykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBjb25zdCBpc0FycmF5VmFsdWUgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXlWYWx1ZSAmJiAhaXNTZXQodmFsdWUpKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uVHlwZSA9IHR5cGVvZiBvcHRpb25WYWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvblR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3B0aW9uVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLnNvbWUoKHYpID0+IFN0cmluZyh2KSA9PT0gU3RyaW5nKG9wdGlvblZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcbiAgcmV0dXJuIFwiX3ZhbHVlXCIgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcbiAgY29uc3Qga2V5ID0gY2hlY2tlZCA/IFwiX3RydWVWYWx1ZVwiIDogXCJfZmFsc2VWYWx1ZVwiO1xuICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XG59XG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xuICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcImNyZWF0ZWRcIik7XG4gIH0sXG4gIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwibW91bnRlZFwiKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJiZWZvcmVVcGRhdGVcIik7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcInVwZGF0ZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY01vZGVsKHRhZ05hbWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcIlNFTEVDVFwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbENoZWNrYm94O1xuICAgICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsUmFkaW87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcbiAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgZWwudGFnTmFtZSxcbiAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICk7XG4gIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcbiAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xufVxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcbiAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xuICB2TW9kZWxSYWRpby5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxuICAgICAgdm5vZGUudHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICAgICk7XG4gICAgaWYgKG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMpIHtcbiAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIl07XG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcbiAgc3RvcDogKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXG4gIHByZXZlbnQ6IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gIHNlbGY6IChlKSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxuICBjdHJsOiAoZSkgPT4gIWUuY3RybEtleSxcbiAgc2hpZnQ6IChlKSA9PiAhZS5zaGlmdEtleSxcbiAgYWx0OiAoZSkgPT4gIWUuYWx0S2V5LFxuICBtZXRhOiAoZSkgPT4gIWUubWV0YUtleSxcbiAgbGVmdDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcbiAgbWlkZGxlOiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxuICByaWdodDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcbiAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKChtKSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcbn07XG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aE1vZHMgfHwgKGZuLl93aXRoTW9kcyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XG4gICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcbiAgfSk7XG59O1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufTtcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aEtleXMgfHwgKGZuLl93aXRoS2V5cyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCkgPT4ge1xuICAgIGlmICghKFwia2V5XCIgaW4gZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XG4gICAgaWYgKG1vZGlmaWVycy5zb21lKFxuICAgICAgKGspID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleVxuICAgICkpIHtcbiAgICAgIHJldHVybiBmbihldmVudCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb24gPyByZW5kZXJlciA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyZXI7XG59XG5jb25zdCByZW5kZXIgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn07XG5jb25zdCBoeWRyYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcInYtY2xvYWtcIik7XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS12LWFwcFwiLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5mdW5jdGlvbiByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJzdmdcIjtcbiAgfVxuICBpZiAodHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBjb250YWluZXIgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwibWF0aG1sXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc05hdGl2ZVRhZ1wiLCB7XG4gICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZykgfHwgaXNNYXRoTUxUYWcodGFnKSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcbiAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzQ3VzdG9tRWxlbWVudFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxuLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxuLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmY2A7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiY29tcGlsZXJPcHRpb25zXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyLm1vZGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICB3YXJuKFxuICAgICAgYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyO1xufVxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcbiAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xuICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgaW5pdFZTaG93Rm9yU1NSKCk7XG4gIH1cbn0gO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHVzZUhvc3QsIHVzZVNoYWRvd1Jvb3QsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n"));

/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY_ARR: function() { return /* binding */ EMPTY_ARR; },\n/* harmony export */   EMPTY_OBJ: function() { return /* binding */ EMPTY_OBJ; },\n/* harmony export */   NO: function() { return /* binding */ NO; },\n/* harmony export */   NOOP: function() { return /* binding */ NOOP; },\n/* harmony export */   PatchFlagNames: function() { return /* binding */ PatchFlagNames; },\n/* harmony export */   PatchFlags: function() { return /* binding */ PatchFlags; },\n/* harmony export */   ShapeFlags: function() { return /* binding */ ShapeFlags; },\n/* harmony export */   SlotFlags: function() { return /* binding */ SlotFlags; },\n/* harmony export */   camelize: function() { return /* binding */ camelize; },\n/* harmony export */   capitalize: function() { return /* binding */ capitalize; },\n/* harmony export */   cssVarNameEscapeSymbolsRE: function() { return /* binding */ cssVarNameEscapeSymbolsRE; },\n/* harmony export */   def: function() { return /* binding */ def; },\n/* harmony export */   escapeHtml: function() { return /* binding */ escapeHtml; },\n/* harmony export */   escapeHtmlComment: function() { return /* binding */ escapeHtmlComment; },\n/* harmony export */   extend: function() { return /* binding */ extend; },\n/* harmony export */   genCacheKey: function() { return /* binding */ genCacheKey; },\n/* harmony export */   genPropsAccessExp: function() { return /* binding */ genPropsAccessExp; },\n/* harmony export */   generateCodeFrame: function() { return /* binding */ generateCodeFrame; },\n/* harmony export */   getEscapedCssVarName: function() { return /* binding */ getEscapedCssVarName; },\n/* harmony export */   getGlobalThis: function() { return /* binding */ getGlobalThis; },\n/* harmony export */   hasChanged: function() { return /* binding */ hasChanged; },\n/* harmony export */   hasOwn: function() { return /* binding */ hasOwn; },\n/* harmony export */   hyphenate: function() { return /* binding */ hyphenate; },\n/* harmony export */   includeBooleanAttr: function() { return /* binding */ includeBooleanAttr; },\n/* harmony export */   invokeArrayFns: function() { return /* binding */ invokeArrayFns; },\n/* harmony export */   isArray: function() { return /* binding */ isArray; },\n/* harmony export */   isBooleanAttr: function() { return /* binding */ isBooleanAttr; },\n/* harmony export */   isBuiltInDirective: function() { return /* binding */ isBuiltInDirective; },\n/* harmony export */   isDate: function() { return /* binding */ isDate; },\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isGloballyAllowed: function() { return /* binding */ isGloballyAllowed; },\n/* harmony export */   isGloballyWhitelisted: function() { return /* binding */ isGloballyWhitelisted; },\n/* harmony export */   isHTMLTag: function() { return /* binding */ isHTMLTag; },\n/* harmony export */   isIntegerKey: function() { return /* binding */ isIntegerKey; },\n/* harmony export */   isKnownHtmlAttr: function() { return /* binding */ isKnownHtmlAttr; },\n/* harmony export */   isKnownMathMLAttr: function() { return /* binding */ isKnownMathMLAttr; },\n/* harmony export */   isKnownSvgAttr: function() { return /* binding */ isKnownSvgAttr; },\n/* harmony export */   isMap: function() { return /* binding */ isMap; },\n/* harmony export */   isMathMLTag: function() { return /* binding */ isMathMLTag; },\n/* harmony export */   isModelListener: function() { return /* binding */ isModelListener; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isOn: function() { return /* binding */ isOn; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isPromise: function() { return /* binding */ isPromise; },\n/* harmony export */   isRegExp: function() { return /* binding */ isRegExp; },\n/* harmony export */   isRenderableAttrValue: function() { return /* binding */ isRenderableAttrValue; },\n/* harmony export */   isReservedProp: function() { return /* binding */ isReservedProp; },\n/* harmony export */   isSSRSafeAttrName: function() { return /* binding */ isSSRSafeAttrName; },\n/* harmony export */   isSVGTag: function() { return /* binding */ isSVGTag; },\n/* harmony export */   isSet: function() { return /* binding */ isSet; },\n/* harmony export */   isSpecialBooleanAttr: function() { return /* binding */ isSpecialBooleanAttr; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   isSymbol: function() { return /* binding */ isSymbol; },\n/* harmony export */   isVoidTag: function() { return /* binding */ isVoidTag; },\n/* harmony export */   looseEqual: function() { return /* binding */ looseEqual; },\n/* harmony export */   looseIndexOf: function() { return /* binding */ looseIndexOf; },\n/* harmony export */   looseToNumber: function() { return /* binding */ looseToNumber; },\n/* harmony export */   makeMap: function() { return /* binding */ makeMap; },\n/* harmony export */   normalizeClass: function() { return /* binding */ normalizeClass; },\n/* harmony export */   normalizeProps: function() { return /* binding */ normalizeProps; },\n/* harmony export */   normalizeStyle: function() { return /* binding */ normalizeStyle; },\n/* harmony export */   objectToString: function() { return /* binding */ objectToString; },\n/* harmony export */   parseStringStyle: function() { return /* binding */ parseStringStyle; },\n/* harmony export */   propsToAttrMap: function() { return /* binding */ propsToAttrMap; },\n/* harmony export */   remove: function() { return /* binding */ remove; },\n/* harmony export */   slotFlagsText: function() { return /* binding */ slotFlagsText; },\n/* harmony export */   stringifyStyle: function() { return /* binding */ stringifyStyle; },\n/* harmony export */   toDisplayString: function() { return /* binding */ toDisplayString; },\n/* harmony export */   toHandlerKey: function() { return /* binding */ toHandlerKey; },\n/* harmony export */   toNumber: function() { return /* binding */ toNumber; },\n/* harmony export */   toRawType: function() { return /* binding */ toRawType; },\n/* harmony export */   toTypeString: function() { return /* binding */ toTypeString; }\n/* harmony export */ });\n/**\n* @vue/shared v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ =  true ? Object.freeze({}) : 0;\nconst EMPTY_ARR =  true ? Object.freeze([]) : 0;\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction(\n  (str) => {\n    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n  }\n);\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(\n  (str) => {\n    const s = str ? `on${capitalize(str)}` : ``;\n    return s;\n  }\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, ...arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](...arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nfunction genCacheKey(source, options) {\n  return source + JSON.stringify(\n    options,\n    (_, val) => typeof val === \"function\" ? val.toString() : val\n  );\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"CACHED\": -1,\n  \"-1\": \"CACHED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  start = Math.max(0, Math.min(start, source.length));\n  end = Math.max(0, Math.min(end, source.length));\n  if (start > end) return \"\";\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  if (!styles) return \"\";\n  if (isString(styles)) return styles;\n  let ret = \"\";\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nconst isKnownMathMLAttr = /* @__PURE__ */ makeMap(\n  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nconst cssVarNameEscapeSymbolsRE = /[ !\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~]/g;\nfunction getEscapedCssVarName(key, doubleEscape) {\n  return key.replace(\n    cssVarNameEscapeSymbolsRE,\n    (s) => doubleEscape ? s === '\"' ? '\\\\\\\\\\\\\"' : `\\\\\\\\${s}` : `\\\\${s}`\n  );\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst isRef = (val) => {\n  return !!(val && val[\"__v_isRef\"] === true);\n};\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (isRef(val)) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixLQUF5QyxtQkFBbUIsSUFBSSxDQUFFO0FBQ3BGLGtCQUFrQixLQUF5Qyx1QkFBdUIsQ0FBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2S0FBNksscUJBQU0sbUJBQW1CLHFCQUFNLEtBQUs7QUFDak47QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssZUFBZSxxQkFBcUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBOztBQUVrK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzPzY5YTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEB2dWUvc2hhcmVkIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyKSB7XG4gIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBzdHIuc3BsaXQoXCIsXCIpKSBtYXBba2V5XSA9IDE7XG4gIHJldHVybiAodmFsKSA9PiB2YWwgaW4gbWFwO1xufVxuXG5jb25zdCBFTVBUWV9PQkogPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbn07XG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyB1cHBlcmNhc2UgbGV0dGVyXG4oa2V5LmNoYXJDb2RlQXQoMikgPiAxMjIgfHwga2V5LmNoYXJDb2RlQXQoMikgPCA5Nyk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICBpZiAoaSA+IC0xKSB7XG4gICAgYXJyLnNwbGljZShpLCAxKTtcbiAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBNYXBdXCI7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgU2V0XVwiO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3ltYm9sXCI7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgfHwgaXNGdW5jdGlvbih2YWwpKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIC8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbiAgXCIsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLG9uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZFwiXG4pO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiKTtcbiAgfVxuKTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgICByZXR1cm4gcztcbiAgfVxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIC4uLmFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXSguLi5hcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cbmZ1bmN0aW9uIGdlbkNhY2hlS2V5KHNvdXJjZSwgb3B0aW9ucykge1xuICByZXR1cm4gc291cmNlICsgSlNPTi5zdHJpbmdpZnkoXG4gICAgb3B0aW9ucyxcbiAgICAoXywgdmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwudG9TdHJpbmcoKSA6IHZhbFxuICApO1xufVxuXG5jb25zdCBQYXRjaEZsYWdzID0ge1xuICBcIlRFWFRcIjogMSxcbiAgXCIxXCI6IFwiVEVYVFwiLFxuICBcIkNMQVNTXCI6IDIsXG4gIFwiMlwiOiBcIkNMQVNTXCIsXG4gIFwiU1RZTEVcIjogNCxcbiAgXCI0XCI6IFwiU1RZTEVcIixcbiAgXCJQUk9QU1wiOiA4LFxuICBcIjhcIjogXCJQUk9QU1wiLFxuICBcIkZVTExfUFJPUFNcIjogMTYsXG4gIFwiMTZcIjogXCJGVUxMX1BST1BTXCIsXG4gIFwiTkVFRF9IWURSQVRJT05cIjogMzIsXG4gIFwiMzJcIjogXCJORUVEX0hZRFJBVElPTlwiLFxuICBcIlNUQUJMRV9GUkFHTUVOVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlNUQUJMRV9GUkFHTUVOVFwiLFxuICBcIktFWUVEX0ZSQUdNRU5UXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJLRVlFRF9GUkFHTUVOVFwiLFxuICBcIlVOS0VZRURfRlJBR01FTlRcIjogMjU2LFxuICBcIjI1NlwiOiBcIlVOS0VZRURfRlJBR01FTlRcIixcbiAgXCJORUVEX1BBVENIXCI6IDUxMixcbiAgXCI1MTJcIjogXCJORUVEX1BBVENIXCIsXG4gIFwiRFlOQU1JQ19TTE9UU1wiOiAxMDI0LFxuICBcIjEwMjRcIjogXCJEWU5BTUlDX1NMT1RTXCIsXG4gIFwiREVWX1JPT1RfRlJBR01FTlRcIjogMjA0OCxcbiAgXCIyMDQ4XCI6IFwiREVWX1JPT1RfRlJBR01FTlRcIixcbiAgXCJDQUNIRURcIjogLTEsXG4gIFwiLTFcIjogXCJDQUNIRURcIixcbiAgXCJCQUlMXCI6IC0yLFxuICBcIi0yXCI6IFwiQkFJTFwiXG59O1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBORUVEX0hZRFJBVElPTmAsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYEhPSVNURURgLFxuICBbLTJdOiBgQkFJTGBcbn07XG5cbmNvbnN0IFNoYXBlRmxhZ3MgPSB7XG4gIFwiRUxFTUVOVFwiOiAxLFxuICBcIjFcIjogXCJFTEVNRU5UXCIsXG4gIFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIjogMixcbiAgXCIyXCI6IFwiRlVOQ1RJT05BTF9DT01QT05FTlRcIixcbiAgXCJTVEFURUZVTF9DT01QT05FTlRcIjogNCxcbiAgXCI0XCI6IFwiU1RBVEVGVUxfQ09NUE9ORU5UXCIsXG4gIFwiVEVYVF9DSElMRFJFTlwiOiA4LFxuICBcIjhcIjogXCJURVhUX0NISUxEUkVOXCIsXG4gIFwiQVJSQVlfQ0hJTERSRU5cIjogMTYsXG4gIFwiMTZcIjogXCJBUlJBWV9DSElMRFJFTlwiLFxuICBcIlNMT1RTX0NISUxEUkVOXCI6IDMyLFxuICBcIjMyXCI6IFwiU0xPVFNfQ0hJTERSRU5cIixcbiAgXCJURUxFUE9SVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlRFTEVQT1JUXCIsXG4gIFwiU1VTUEVOU0VcIjogMTI4LFxuICBcIjEyOFwiOiBcIlNVU1BFTlNFXCIsXG4gIFwiQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFXCI6IDI1NixcbiAgXCIyNTZcIjogXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIixcbiAgXCJDT01QT05FTlRfS0VQVF9BTElWRVwiOiA1MTIsXG4gIFwiNTEyXCI6IFwiQ09NUE9ORU5UX0tFUFRfQUxJVkVcIixcbiAgXCJDT01QT05FTlRcIjogNixcbiAgXCI2XCI6IFwiQ09NUE9ORU5UXCJcbn07XG5cbmNvbnN0IFNsb3RGbGFncyA9IHtcbiAgXCJTVEFCTEVcIjogMSxcbiAgXCIxXCI6IFwiU1RBQkxFXCIsXG4gIFwiRFlOQU1JQ1wiOiAyLFxuICBcIjJcIjogXCJEWU5BTUlDXCIsXG4gIFwiRk9SV0FSREVEXCI6IDMsXG4gIFwiM1wiOiBcIkZPUldBUkRFRFwiXG59O1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgWzFdOiBcIlNUQUJMRVwiLFxuICBbMl06IFwiRFlOQU1JQ1wiLFxuICBbM106IFwiRk9SV0FSREVEXCJcbn07XG5cbmNvbnN0IEdMT0JBTFNfQUxMT1dFRCA9IFwiSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LGNvbnNvbGUsRXJyb3IsU3ltYm9sXCI7XG5jb25zdCBpc0dsb2JhbGx5QWxsb3dlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfQUxMT1dFRCk7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSBpc0dsb2JhbGx5QWxsb3dlZDtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCwgc291cmNlLmxlbmd0aCkpO1xuICBlbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlbmQsIHNvdXJjZS5sZW5ndGgpKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gXCJcIjtcbiAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGggfHwgMCk7XG4gICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgcmVzLnB1c2goXG4gICAgICAgICAgYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gbmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnRcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqW15dKj9cXCpcXC8vZztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY3NzVGV4dC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCBcIlwiKS5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gIGlmICghc3R5bGVzKSByZXR1cm4gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHN0eWxlcykpIHJldHVybiBzdHlsZXM7XG4gIGxldCByZXQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXMgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHJldHVybiBudWxsO1xuICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbmNvbnN0IEhUTUxfVEFHUyA9IFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LHN1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIjtcbmNvbnN0IFNWR19UQUdTID0gXCJzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlcixmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLGZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbmNvbnN0IE1BVEhfVEFHUyA9IFwiYW5ub3RhdGlvbixhbm5vdGF0aW9uLXhtbCxtYWN0aW9uLG1hbGlnbmdyb3VwLG1hbGlnbm1hcmssbWF0aCxtZW5jbG9zZSxtZXJyb3IsbWZlbmNlZCxtZnJhYyxtZnJhY3Rpb24sbWdseXBoLG1pLG1sYWJlbGVkdHIsbWxvbmdkaXYsbW11bHRpc2NyaXB0cyxtbixtbyxtb3ZlcixtcGFkZGVkLG1waGFudG9tLG1wcmVzY3JpcHRzLG1yb290LG1yb3csbXMsbXNjYXJyaWVzLG1zY2FycnksbXNncm91cCxtc2xpbmUsbXNwYWNlLG1zcXJ0LG1zcm93LG1zdGFjayxtc3R5bGUsbXN1Yixtc3Vic3VwLG1zdXAsbXRhYmxlLG10ZCxtdGV4dCxtdHIsbXVuZGVyLG11bmRlcm92ZXIsbm9uZSxzZW1hbnRpY3NcIjtcbmNvbnN0IFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbmNvbnN0IGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG5jb25zdCBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbmNvbnN0IGlzTWF0aE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoTUFUSF9UQUdTKTtcbmNvbnN0IGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixpbmVydCxsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgXG4pO1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSBcIlwiO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICB9XG4gIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICBpZiAoaXNVbnNhZmUpIHtcbiAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgfVxuICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICBhY2NlcHRDaGFyc2V0OiBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiLFxuICBodHRwRXF1aXY6IFwiaHR0cC1lcXVpdlwiXG59O1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGluZXJ0LGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcGBcbik7XG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICBgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxyZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxyZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2Usc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyx3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbG5zOnhsaW5rLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYFxuKTtcbmNvbnN0IGlzS25vd25NYXRoTUxBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGBhY2NlbnQsYWNjZW50dW5kZXIsYWN0aW9udHlwZSxhbGlnbixhbGlnbm1lbnRzY29wZSxhbHRpbWcsYWx0aW1nLWhlaWdodCxhbHRpbWctdmFsaWduLGFsdGltZy13aWR0aCxhbHR0ZXh0LGJldmVsbGVkLGNsb3NlLGNvbHVtbnNhbGlnbixjb2x1bW5saW5lcyxjb2x1bW5zcGFuLGRlbm9tYWxpZ24sZGVwdGgsZGlyLGRpc3BsYXksZGlzcGxheXN0eWxlLGVuY29kaW5nLGVxdWFsY29sdW1ucyxlcXVhbHJvd3MsZmVuY2UsZm9udHN0eWxlLGZvbnR3ZWlnaHQsZm9ybSxmcmFtZSxmcmFtZXNwYWNpbmcsZ3JvdXBhbGlnbixoZWlnaHQsaHJlZixpZCxpbmRlbnRhbGlnbixpbmRlbnRhbGlnbmZpcnN0LGluZGVudGFsaWdubGFzdCxpbmRlbnRzaGlmdCxpbmRlbnRzaGlmdGZpcnN0LGluZGVudHNoaWZ0bGFzdCxpbmRleHR5cGUsanVzdGlmeSxsYXJnZXRvcCxsYXJnZW9wLGxxdW90ZSxsc3BhY2UsbWF0aGJhY2tncm91bmQsbWF0aGNvbG9yLG1hdGhzaXplLG1hdGh2YXJpYW50LG1heHNpemUsbWlubGFiZWxzcGFjaW5nLG1vZGUsb3RoZXIsb3ZlcmZsb3cscG9zaXRpb24scm93YWxpZ24scm93bGluZXMscm93c3BhbixycXVvdGUscnNwYWNlLHNjcmlwdGxldmVsLHNjcmlwdG1pbnNpemUsc2NyaXB0c2l6ZW11bHRpcGxpZXIsc2VsZWN0aW9uLHNlcGFyYXRvcixzZXBhcmF0b3JzLHNoaWZ0LHNpZGUsc3JjLHN0YWNrYWxpZ24sc3RyZXRjaHksc3Vic2NyaXB0c2hpZnQsc3VwZXJzY3JpcHRzaGlmdCxzeW1tZXRyaWMsdm9mZnNldCx3aWR0aCx3aWR0aHMseGxpbms6aHJlZix4bGluazpzaG93LHhsaW5rOnR5cGUseG1sbnNgXG4pO1xuZnVuY3Rpb24gaXNSZW5kZXJhYmxlQXR0clZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIGNvbnN0IHN0ciA9IFwiXCIgKyBzdHJpbmc7XG4gIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBsZXQgaHRtbCA9IFwiXCI7XG4gIGxldCBlc2NhcGVkO1xuICBsZXQgaW5kZXg7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICBlc2NhcGVkID0gXCImcXVvdDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBlc2NhcGVkID0gXCImYW1wO1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIGVzY2FwZWQgPSBcIiYjMzk7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmx0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZndDtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGVkO1xuICB9XG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgXCJcIik7XG59XG5jb25zdCBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFID0gL1sgIVwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXFxdXmB7fH1+XS9nO1xuZnVuY3Rpb24gZ2V0RXNjYXBlZENzc1Zhck5hbWUoa2V5LCBkb3VibGVFc2NhcGUpIHtcbiAgcmV0dXJuIGtleS5yZXBsYWNlKFxuICAgIGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUsXG4gICAgKHMpID0+IGRvdWJsZUVzY2FwZSA/IHMgPT09ICdcIicgPyAnXFxcXFxcXFxcXFxcXCInIDogYFxcXFxcXFxcJHtzfWAgOiBgXFxcXCR7c31gXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICB9XG4gIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgfVxuICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICByZXR1cm4gYXJyLmZpbmRJbmRleCgoaXRlbSkgPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuY29uc3QgaXNSZWYgPSAodmFsKSA9PiB7XG4gIHJldHVybiAhISh2YWwgJiYgdmFsW1wiX192X2lzUmVmXCJdID09PSB0cnVlKTtcbn07XG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsID09IG51bGwgPyBcIlwiIDogaXNBcnJheSh2YWwpIHx8IGlzT2JqZWN0KHZhbCkgJiYgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkgPyBpc1JlZih2YWwpID8gdG9EaXNwbGF5U3RyaW5nKHZhbC52YWx1ZSkgOiBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKSA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICBpZiAoaXNSZWYodmFsKSkge1xuICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoXG4gICAgICAgIChlbnRyaWVzLCBba2V5LCB2YWwyXSwgaSkgPT4ge1xuICAgICAgICAgIGVudHJpZXNbc3RyaW5naWZ5U3ltYm9sKGtleSwgaSkgKyBcIiA9PlwiXSA9IHZhbDI7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXS5tYXAoKHYpID0+IHN0cmluZ2lmeVN5bWJvbCh2KSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU3ltYm9sKHZhbCkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3ltYm9sKHZhbCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAodiwgaSA9IFwiXCIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKFxuICAgIC8vIFN5bWJvbC5kZXNjcmlwdGlvbiBpbiBlczIwMTkrIHNvIHdlIG5lZWQgdG8gY2FzdCBoZXJlIHRvIHBhc3NcbiAgICAvLyB0aGUgbGliOiBlczIwMTYgY2hlY2tcbiAgICBpc1N5bWJvbCh2KSA/IGBTeW1ib2woJHsoX2EgPSB2LmRlc2NyaXB0aW9uKSAhPSBudWxsID8gX2EgOiBpfSlgIDogdlxuICApO1xufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5DYWNoZUtleSwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duTWF0aE1MQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/shared/dist/shared.esm-bundler.js\n"));

/***/ }),

/***/ "./node_modules/autosize/dist/autosize.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/autosize/dist/autosize.esm.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar e=new Map;function t(t){var o=e.get(t);o&&o.destroy()}function o(t){var o=e.get(t);o&&o.update()}var r=null;\"undefined\"==typeof window?((r=function(e){return e}).destroy=function(e){return e},r.update=function(e){return e}):((r=function(t,o){return t&&Array.prototype.forEach.call(t.length?t:[t],function(t){return function(t){if(t&&t.nodeName&&\"TEXTAREA\"===t.nodeName&&!e.has(t)){var o,r=null,n=window.getComputedStyle(t),i=(o=t.value,function(){a({testForHeightReduction:\"\"===o||!t.value.startsWith(o),restoreTextAlign:null}),o=t.value}),l=function(o){t.removeEventListener(\"autosize:destroy\",l),t.removeEventListener(\"autosize:update\",s),t.removeEventListener(\"input\",i),window.removeEventListener(\"resize\",s),Object.keys(o).forEach(function(e){return t.style[e]=o[e]}),e.delete(t)}.bind(t,{height:t.style.height,resize:t.style.resize,textAlign:t.style.textAlign,overflowY:t.style.overflowY,overflowX:t.style.overflowX,wordWrap:t.style.wordWrap});t.addEventListener(\"autosize:destroy\",l),t.addEventListener(\"autosize:update\",s),t.addEventListener(\"input\",i),window.addEventListener(\"resize\",s),t.style.overflowX=\"hidden\",t.style.wordWrap=\"break-word\",e.set(t,{destroy:l,update:s}),s()}function a(e){var o,i,l=e.restoreTextAlign,s=void 0===l?null:l,d=e.testForHeightReduction,u=void 0===d||d,c=n.overflowY;if(0!==t.scrollHeight&&(\"vertical\"===n.resize?t.style.resize=\"none\":\"both\"===n.resize&&(t.style.resize=\"horizontal\"),u&&(o=function(e){for(var t=[];e&&e.parentNode&&e.parentNode instanceof Element;)e.parentNode.scrollTop&&t.push([e.parentNode,e.parentNode.scrollTop]),e=e.parentNode;return function(){return t.forEach(function(e){var t=e[0],o=e[1];t.style.scrollBehavior=\"auto\",t.scrollTop=o,t.style.scrollBehavior=null})}}(t),t.style.height=\"\"),i=\"content-box\"===n.boxSizing?t.scrollHeight-(parseFloat(n.paddingTop)+parseFloat(n.paddingBottom)):t.scrollHeight+parseFloat(n.borderTopWidth)+parseFloat(n.borderBottomWidth),\"none\"!==n.maxHeight&&i>parseFloat(n.maxHeight)?(\"hidden\"===n.overflowY&&(t.style.overflow=\"scroll\"),i=parseFloat(n.maxHeight)):\"hidden\"!==n.overflowY&&(t.style.overflow=\"hidden\"),t.style.height=i+\"px\",s&&(t.style.textAlign=s),o&&o(),r!==i&&(t.dispatchEvent(new Event(\"autosize:resized\",{bubbles:!0})),r=i),c!==n.overflow&&!s)){var v=n.textAlign;\"hidden\"===n.overflow&&(t.style.textAlign=\"start\"===v?\"end\":\"start\"),a({restoreTextAlign:v,testForHeightReduction:!0})}}function s(){a({testForHeightReduction:!0,restoreTextAlign:null})}}(t)}),t}).destroy=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],t),e},r.update=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],o),e});var n=r;/* harmony default export */ __webpack_exports__[\"default\"] = (n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXV0b3NpemUvZGlzdC9hdXRvc2l6ZS5lc20uanMiLCJtYXBwaW5ncyI6IjtBQUFBLGNBQWMsY0FBYyxlQUFlLGVBQWUsY0FBYyxlQUFlLGNBQWMsV0FBVywyQ0FBMkMsU0FBUyxzQkFBc0IsU0FBUyxzQkFBc0IsU0FBUyxvQkFBb0Isa0VBQWtFLG1CQUFtQixzREFBc0Qsa0VBQWtFLEdBQUcsNEVBQTRFLFlBQVksZ0JBQWdCLGtNQUFrTSx1QkFBdUIsY0FBYyxTQUFTLDBKQUEwSixFQUFFLHFOQUFxTixtQkFBbUIsTUFBTSxjQUFjLDBHQUEwRyx1SUFBdUksYUFBYSxpREFBaUQsc0ZBQXNGLGtCQUFrQiw2QkFBNkIsa0JBQWtCLHdFQUF3RSxHQUFHLHVlQUF1ZSxXQUFXLDZCQUE2QixrQkFBa0Isd0VBQXdFLDZDQUE2QyxHQUFHLGFBQWEsR0FBRyxnREFBZ0QsR0FBRyxJQUFJLElBQUksc0JBQXNCLDJEQUEyRCxzQkFBc0IsMkRBQTJELEVBQUUsUUFBUSwrREFBZSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F1dG9zaXplL2Rpc3QvYXV0b3NpemUuZXNtLmpzPzkzYjgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGU9bmV3IE1hcDtmdW5jdGlvbiB0KHQpe3ZhciBvPWUuZ2V0KHQpO28mJm8uZGVzdHJveSgpfWZ1bmN0aW9uIG8odCl7dmFyIG89ZS5nZXQodCk7byYmby51cGRhdGUoKX12YXIgcj1udWxsO1widW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/KChyPWZ1bmN0aW9uKGUpe3JldHVybiBlfSkuZGVzdHJveT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sci51cGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9KTooKHI9ZnVuY3Rpb24odCxvKXtyZXR1cm4gdCYmQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCh0Lmxlbmd0aD90Olt0XSxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCl7aWYodCYmdC5ub2RlTmFtZSYmXCJURVhUQVJFQVwiPT09dC5ub2RlTmFtZSYmIWUuaGFzKHQpKXt2YXIgbyxyPW51bGwsbj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KSxpPShvPXQudmFsdWUsZnVuY3Rpb24oKXthKHt0ZXN0Rm9ySGVpZ2h0UmVkdWN0aW9uOlwiXCI9PT1vfHwhdC52YWx1ZS5zdGFydHNXaXRoKG8pLHJlc3RvcmVUZXh0QWxpZ246bnVsbH0pLG89dC52YWx1ZX0pLGw9ZnVuY3Rpb24obyl7dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYXV0b3NpemU6ZGVzdHJveVwiLGwpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImF1dG9zaXplOnVwZGF0ZVwiLHMpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsaSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixzKSxPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LnN0eWxlW2VdPW9bZV19KSxlLmRlbGV0ZSh0KX0uYmluZCh0LHtoZWlnaHQ6dC5zdHlsZS5oZWlnaHQscmVzaXplOnQuc3R5bGUucmVzaXplLHRleHRBbGlnbjp0LnN0eWxlLnRleHRBbGlnbixvdmVyZmxvd1k6dC5zdHlsZS5vdmVyZmxvd1ksb3ZlcmZsb3dYOnQuc3R5bGUub3ZlcmZsb3dYLHdvcmRXcmFwOnQuc3R5bGUud29yZFdyYXB9KTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJhdXRvc2l6ZTpkZXN0cm95XCIsbCksdC5hZGRFdmVudExpc3RlbmVyKFwiYXV0b3NpemU6dXBkYXRlXCIscyksdC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIixpKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHMpLHQuc3R5bGUub3ZlcmZsb3dYPVwiaGlkZGVuXCIsdC5zdHlsZS53b3JkV3JhcD1cImJyZWFrLXdvcmRcIixlLnNldCh0LHtkZXN0cm95OmwsdXBkYXRlOnN9KSxzKCl9ZnVuY3Rpb24gYShlKXt2YXIgbyxpLGw9ZS5yZXN0b3JlVGV4dEFsaWduLHM9dm9pZCAwPT09bD9udWxsOmwsZD1lLnRlc3RGb3JIZWlnaHRSZWR1Y3Rpb24sdT12b2lkIDA9PT1kfHxkLGM9bi5vdmVyZmxvd1k7aWYoMCE9PXQuc2Nyb2xsSGVpZ2h0JiYoXCJ2ZXJ0aWNhbFwiPT09bi5yZXNpemU/dC5zdHlsZS5yZXNpemU9XCJub25lXCI6XCJib3RoXCI9PT1uLnJlc2l6ZSYmKHQuc3R5bGUucmVzaXplPVwiaG9yaXpvbnRhbFwiKSx1JiYobz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W107ZSYmZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50OyllLnBhcmVudE5vZGUuc2Nyb2xsVG9wJiZ0LnB1c2goW2UucGFyZW50Tm9kZSxlLnBhcmVudE5vZGUuc2Nyb2xsVG9wXSksZT1lLnBhcmVudE5vZGU7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLG89ZVsxXTt0LnN0eWxlLnNjcm9sbEJlaGF2aW9yPVwiYXV0b1wiLHQuc2Nyb2xsVG9wPW8sdC5zdHlsZS5zY3JvbGxCZWhhdmlvcj1udWxsfSl9fSh0KSx0LnN0eWxlLmhlaWdodD1cIlwiKSxpPVwiY29udGVudC1ib3hcIj09PW4uYm94U2l6aW5nP3Quc2Nyb2xsSGVpZ2h0LShwYXJzZUZsb2F0KG4ucGFkZGluZ1RvcCkrcGFyc2VGbG9hdChuLnBhZGRpbmdCb3R0b20pKTp0LnNjcm9sbEhlaWdodCtwYXJzZUZsb2F0KG4uYm9yZGVyVG9wV2lkdGgpK3BhcnNlRmxvYXQobi5ib3JkZXJCb3R0b21XaWR0aCksXCJub25lXCIhPT1uLm1heEhlaWdodCYmaT5wYXJzZUZsb2F0KG4ubWF4SGVpZ2h0KT8oXCJoaWRkZW5cIj09PW4ub3ZlcmZsb3dZJiYodC5zdHlsZS5vdmVyZmxvdz1cInNjcm9sbFwiKSxpPXBhcnNlRmxvYXQobi5tYXhIZWlnaHQpKTpcImhpZGRlblwiIT09bi5vdmVyZmxvd1kmJih0LnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIpLHQuc3R5bGUuaGVpZ2h0PWkrXCJweFwiLHMmJih0LnN0eWxlLnRleHRBbGlnbj1zKSxvJiZvKCksciE9PWkmJih0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiYXV0b3NpemU6cmVzaXplZFwiLHtidWJibGVzOiEwfSkpLHI9aSksYyE9PW4ub3ZlcmZsb3cmJiFzKSl7dmFyIHY9bi50ZXh0QWxpZ247XCJoaWRkZW5cIj09PW4ub3ZlcmZsb3cmJih0LnN0eWxlLnRleHRBbGlnbj1cInN0YXJ0XCI9PT12P1wiZW5kXCI6XCJzdGFydFwiKSxhKHtyZXN0b3JlVGV4dEFsaWduOnYsdGVzdEZvckhlaWdodFJlZHVjdGlvbjohMH0pfX1mdW5jdGlvbiBzKCl7YSh7dGVzdEZvckhlaWdodFJlZHVjdGlvbjohMCxyZXN0b3JlVGV4dEFsaWduOm51bGx9KX19KHQpfSksdH0pLmRlc3Ryb3k9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJkFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZS5sZW5ndGg/ZTpbZV0sdCksZX0sci51cGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJkFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZS5sZW5ndGg/ZTpbZV0sbyksZX0pO3ZhciBuPXI7ZXhwb3J0IGRlZmF1bHQgbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/autosize/dist/autosize.esm.js\n"));

/***/ }),

/***/ "./themes/simple/components/ExampleRecentComments.js":
/*!***********************************************************!*\
  !*** ./themes/simple/components/ExampleRecentComments.js ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_SmartLink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/SmartLink */ \"./components/SmartLink.js\");\n/* harmony import */ var _waline_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @waline/client */ \"./node_modules/@waline/client/dist/shim.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lib_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/config */ \"./lib/config.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n/**\n * @see https://waline.js.org/guide/get-started.html\n * @param {*} props\n * @returns\n */ const ExampleRecentComments = (props)=>{\n    _s();\n    const [comments, updateComments] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [onLoading, changeLoading] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        (0,_waline_client__WEBPACK_IMPORTED_MODULE_2__.RecentComments)({\n            serverURL: (0,_lib_config__WEBPACK_IMPORTED_MODULE_4__.siteConfig)(\"COMMENT_WALINE_SERVER_URL\"),\n            count: 5\n        }).then((param)=>{\n            let { comments } = param;\n            changeLoading(false);\n            updateComments(comments);\n        });\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            onLoading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    \"Loading...\",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                        className: \"ml-2 fas fa-spinner animate-spin\"\n                    }, void 0, false, {\n                        fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                        lineNumber: 25,\n                        columnNumber: 39\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                lineNumber: 25,\n                columnNumber: 24\n            }, undefined),\n            !onLoading && comments && comments.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: \"No Comments\"\n            }, void 0, false, {\n                fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                lineNumber: 26,\n                columnNumber: 61\n            }, undefined),\n            !onLoading && comments && comments.length > 0 && comments.map((comment)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"pb-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"dark:text-gray-300 text-gray-600 text-xs waline-recent-content wl-content\",\n                            dangerouslySetInnerHTML: {\n                                __html: comment.comment\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                            lineNumber: 28,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"dark:text-gray-400 text-gray-400  text-sm text-right cursor-pointer hover:text-red-500 hover:underline pt-1\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SmartLink__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                href: {\n                                    pathname: comment.url,\n                                    hash: comment.objectId,\n                                    query: {\n                                        target: \"comment\"\n                                    }\n                                },\n                                children: [\n                                    \"--\",\n                                    comment.nick\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                                lineNumber: 29,\n                                columnNumber: 138\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                            lineNumber: 29,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, comment.objectId, true, {\n                    fileName: \"/Users/Apple/Documents/GitHub/NotionNext/autos/themes/simple/components/ExampleRecentComments.js\",\n                    lineNumber: 27,\n                    columnNumber: 85\n                }, undefined))\n        ]\n    }, void 0, true);\n};\n_s(ExampleRecentComments, \"E7oqBbX+qvR7qyrbs9998qdV8Pg=\");\n_c = ExampleRecentComments;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExampleRecentComments);\nvar _c;\n$RefreshReg$(_c, \"ExampleRecentComments\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90aGVtZXMvc2ltcGxlL2NvbXBvbmVudHMvRXhhbXBsZVJlY2VudENvbW1lbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEM7QUFDQztBQUNKO0FBQ0Y7QUFFekM7Ozs7Q0FJQyxHQUNELE1BQU1LLHdCQUF3QixDQUFDQzs7SUFDN0IsTUFBTSxDQUFDQyxVQUFVQyxlQUFlLEdBQUdMLCtDQUFRQSxDQUFDLEVBQUU7SUFDOUMsTUFBTSxDQUFDTSxXQUFXQyxjQUFjLEdBQUdQLCtDQUFRQSxDQUFDO0lBQzVDRCxnREFBU0EsQ0FBQztRQUNSRCw4REFBY0EsQ0FBQztZQUNiVSxXQUFXUCx1REFBVUEsQ0FBQztZQUN0QlEsT0FBTztRQUNULEdBQUdDLElBQUksQ0FBQztnQkFBQyxFQUFFTixRQUFRLEVBQUU7WUFDbkJHLGNBQWM7WUFDZEYsZUFBZUQ7UUFDakI7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFBTzs7WUFDQ0UsMkJBQWEsOERBQUNLOztvQkFBSTtrQ0FBVSw4REFBQ0M7d0JBQUVDLFdBQVU7Ozs7Ozs7Ozs7OztZQUMxQyxDQUFDUCxhQUFhRixZQUFZQSxTQUFTVSxNQUFNLEtBQUssbUJBQUssOERBQUNIOzBCQUFJOzs7Ozs7WUFDeEQsQ0FBQ0wsYUFBYUYsWUFBWUEsU0FBU1UsTUFBTSxHQUFHLEtBQUtWLFNBQVNXLEdBQUcsQ0FBQyxDQUFDQyx3QkFBWSw4REFBQ0w7b0JBQTJCRSxXQUFVOztzQ0FDOUcsOERBQUNGOzRCQUFJRSxXQUFVOzRCQUE0RUkseUJBQXlCO2dDQUFFQyxRQUFRRixRQUFRQSxPQUFPOzRCQUFDOzs7Ozs7c0NBQzlJLDhEQUFDTDs0QkFBSUUsV0FBVTtzQ0FBOEcsNEVBQUNoQiw2REFBU0E7Z0NBQUNzQixNQUFNO29DQUFFQyxVQUFVSixRQUFRSyxHQUFHO29DQUFFQyxNQUFNTixRQUFRTyxRQUFRO29DQUFFQyxPQUFPO3dDQUFFQyxRQUFRO29DQUFVO2dDQUFFOztvQ0FBRztvQ0FBR1QsUUFBUVUsSUFBSTs7Ozs7Ozs7Ozs7OzttQkFGNUpWLFFBQVFPLFFBQVE7Ozs7Ozs7QUFNOUc7R0F0Qk1yQjtLQUFBQTtBQXdCTiwrREFBZUEscUJBQXFCQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3RoZW1lcy9zaW1wbGUvY29tcG9uZW50cy9FeGFtcGxlUmVjZW50Q29tbWVudHMuanM/MTBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU21hcnRMaW5rIGZyb20gJ0AvY29tcG9uZW50cy9TbWFydExpbmsnXG5pbXBvcnQgeyBSZWNlbnRDb21tZW50cyB9IGZyb20gJ0B3YWxpbmUvY2xpZW50J1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgc2l0ZUNvbmZpZyB9IGZyb20gJ0AvbGliL2NvbmZpZydcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2FsaW5lLmpzLm9yZy9ndWlkZS9nZXQtc3RhcnRlZC5odG1sXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBFeGFtcGxlUmVjZW50Q29tbWVudHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW2NvbW1lbnRzLCB1cGRhdGVDb21tZW50c10gPSB1c2VTdGF0ZShbXSlcbiAgY29uc3QgW29uTG9hZGluZywgY2hhbmdlTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIFJlY2VudENvbW1lbnRzKHtcbiAgICAgIHNlcnZlclVSTDogc2l0ZUNvbmZpZygnQ09NTUVOVF9XQUxJTkVfU0VSVkVSX1VSTCcpLFxuICAgICAgY291bnQ6IDVcbiAgICB9KS50aGVuKCh7IGNvbW1lbnRzIH0pID0+IHtcbiAgICAgIGNoYW5nZUxvYWRpbmcoZmFsc2UpXG4gICAgICB1cGRhdGVDb21tZW50cyhjb21tZW50cylcbiAgICB9KVxuICB9LCBbXSlcblxuICByZXR1cm4gPD5cbiAgICAgICAgIHtvbkxvYWRpbmcgJiYgPGRpdj5Mb2FkaW5nLi4uPGkgY2xhc3NOYW1lPSdtbC0yIGZhcyBmYS1zcGlubmVyIGFuaW1hdGUtc3BpbicgLz48L2Rpdj59XG4gICAgICAgIHshb25Mb2FkaW5nICYmIGNvbW1lbnRzICYmIGNvbW1lbnRzLmxlbmd0aCA9PT0gMCAmJiA8ZGl2Pk5vIENvbW1lbnRzPC9kaXY+fVxuICAgICAgICB7IW9uTG9hZGluZyAmJiBjb21tZW50cyAmJiBjb21tZW50cy5sZW5ndGggPiAwICYmIGNvbW1lbnRzLm1hcCgoY29tbWVudCkgPT4gPGRpdiBrZXk9e2NvbW1lbnQub2JqZWN0SWR9IGNsYXNzTmFtZT0ncGItMic+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nZGFyazp0ZXh0LWdyYXktMzAwIHRleHQtZ3JheS02MDAgdGV4dC14cyB3YWxpbmUtcmVjZW50LWNvbnRlbnQgd2wtY29udGVudCcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBjb21tZW50LmNvbW1lbnQgfX0gLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdkYXJrOnRleHQtZ3JheS00MDAgdGV4dC1ncmF5LTQwMCAgdGV4dC1zbSB0ZXh0LXJpZ2h0IGN1cnNvci1wb2ludGVyIGhvdmVyOnRleHQtcmVkLTUwMCBob3Zlcjp1bmRlcmxpbmUgcHQtMSc+PFNtYXJ0TGluayBocmVmPXt7IHBhdGhuYW1lOiBjb21tZW50LnVybCwgaGFzaDogY29tbWVudC5vYmplY3RJZCwgcXVlcnk6IHsgdGFyZ2V0OiAnY29tbWVudCcgfSB9fT4tLXtjb21tZW50Lm5pY2t9PC9TbWFydExpbms+PC9kaXY+XG4gICAgICAgIDwvZGl2Pil9XG5cbiAgPC8+XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4YW1wbGVSZWNlbnRDb21tZW50c1xuIl0sIm5hbWVzIjpbIlNtYXJ0TGluayIsIlJlY2VudENvbW1lbnRzIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJzaXRlQ29uZmlnIiwiRXhhbXBsZVJlY2VudENvbW1lbnRzIiwicHJvcHMiLCJjb21tZW50cyIsInVwZGF0ZUNvbW1lbnRzIiwib25Mb2FkaW5nIiwiY2hhbmdlTG9hZGluZyIsInNlcnZlclVSTCIsImNvdW50IiwidGhlbiIsImRpdiIsImkiLCJjbGFzc05hbWUiLCJsZW5ndGgiLCJtYXAiLCJjb21tZW50IiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJocmVmIiwicGF0aG5hbWUiLCJ1cmwiLCJoYXNoIiwib2JqZWN0SWQiLCJxdWVyeSIsInRhcmdldCIsIm5pY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./themes/simple/components/ExampleRecentComments.js\n"));

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compile: function() { return /* binding */ compile; }\n/* harmony export */ });\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"compile\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/**\n* vue v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n\n\n\nfunction initDev() {\n  {\n    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter)();\n  }\n}\n\nif (true) {\n  initDev();\n}\nconst compile = () => {\n  if (true) {\n    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn)(\n      `Runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".` )\n    );\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQzVCOztBQUVqQztBQUNBO0FBQ0EsSUFBSSxxRUFBbUI7QUFDdkI7QUFDQTs7QUFFQSxJQUFJLElBQXlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBeUM7QUFDL0MsSUFBSSxzREFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanM/YWMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogdnVlIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xuICB7XG4gICAgaW5pdEN1c3RvbUZvcm1hdHRlcigpO1xuICB9XG59XG5cbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gIGluaXREZXYoKTtcbn1cbmNvbnN0IGNvbXBpbGUgPSAoKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybihcbiAgICAgIGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmAgKVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNvbXBpbGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.runtime.esm-bundler.js\n"));

/***/ }),

/***/ "./node_modules/@vueuse/core/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/@vueuse/core/index.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultMagicKeysAliasMap: function() { return /* binding */ DefaultMagicKeysAliasMap; },\n/* harmony export */   StorageSerializers: function() { return /* binding */ StorageSerializers; },\n/* harmony export */   TransitionPresets: function() { return /* binding */ TransitionPresets; },\n/* harmony export */   asyncComputed: function() { return /* binding */ computedAsync; },\n/* harmony export */   breakpointsAntDesign: function() { return /* binding */ breakpointsAntDesign; },\n/* harmony export */   breakpointsBootstrapV5: function() { return /* binding */ breakpointsBootstrapV5; },\n/* harmony export */   breakpointsMasterCss: function() { return /* binding */ breakpointsMasterCss; },\n/* harmony export */   breakpointsPrimeFlex: function() { return /* binding */ breakpointsPrimeFlex; },\n/* harmony export */   breakpointsQuasar: function() { return /* binding */ breakpointsQuasar; },\n/* harmony export */   breakpointsSematic: function() { return /* binding */ breakpointsSematic; },\n/* harmony export */   breakpointsTailwind: function() { return /* binding */ breakpointsTailwind; },\n/* harmony export */   breakpointsVuetify: function() { return /* binding */ breakpointsVuetify; },\n/* harmony export */   breakpointsVuetifyV2: function() { return /* binding */ breakpointsVuetifyV2; },\n/* harmony export */   breakpointsVuetifyV3: function() { return /* binding */ breakpointsVuetifyV3; },\n/* harmony export */   cloneFnJSON: function() { return /* binding */ cloneFnJSON; },\n/* harmony export */   computedAsync: function() { return /* binding */ computedAsync; },\n/* harmony export */   computedInject: function() { return /* binding */ computedInject; },\n/* harmony export */   createFetch: function() { return /* binding */ createFetch; },\n/* harmony export */   createReusableTemplate: function() { return /* binding */ createReusableTemplate; },\n/* harmony export */   createTemplatePromise: function() { return /* binding */ createTemplatePromise; },\n/* harmony export */   createUnrefFn: function() { return /* binding */ createUnrefFn; },\n/* harmony export */   customStorageEventName: function() { return /* binding */ customStorageEventName; },\n/* harmony export */   defaultDocument: function() { return /* binding */ defaultDocument; },\n/* harmony export */   defaultLocation: function() { return /* binding */ defaultLocation; },\n/* harmony export */   defaultNavigator: function() { return /* binding */ defaultNavigator; },\n/* harmony export */   defaultWindow: function() { return /* binding */ defaultWindow; },\n/* harmony export */   executeTransition: function() { return /* binding */ executeTransition; },\n/* harmony export */   formatTimeAgo: function() { return /* binding */ formatTimeAgo; },\n/* harmony export */   getSSRHandler: function() { return /* binding */ getSSRHandler; },\n/* harmony export */   mapGamepadToXbox360Controller: function() { return /* binding */ mapGamepadToXbox360Controller; },\n/* harmony export */   onClickOutside: function() { return /* binding */ onClickOutside; },\n/* harmony export */   onKeyDown: function() { return /* binding */ onKeyDown; },\n/* harmony export */   onKeyPressed: function() { return /* binding */ onKeyPressed; },\n/* harmony export */   onKeyStroke: function() { return /* binding */ onKeyStroke; },\n/* harmony export */   onKeyUp: function() { return /* binding */ onKeyUp; },\n/* harmony export */   onLongPress: function() { return /* binding */ onLongPress; },\n/* harmony export */   onStartTyping: function() { return /* binding */ onStartTyping; },\n/* harmony export */   setSSRHandler: function() { return /* binding */ setSSRHandler; },\n/* harmony export */   templateRef: function() { return /* binding */ templateRef; },\n/* harmony export */   unrefElement: function() { return /* binding */ unrefElement; },\n/* harmony export */   useActiveElement: function() { return /* binding */ useActiveElement; },\n/* harmony export */   useAnimate: function() { return /* binding */ useAnimate; },\n/* harmony export */   useAsyncQueue: function() { return /* binding */ useAsyncQueue; },\n/* harmony export */   useAsyncState: function() { return /* binding */ useAsyncState; },\n/* harmony export */   useBase64: function() { return /* binding */ useBase64; },\n/* harmony export */   useBattery: function() { return /* binding */ useBattery; },\n/* harmony export */   useBluetooth: function() { return /* binding */ useBluetooth; },\n/* harmony export */   useBreakpoints: function() { return /* binding */ useBreakpoints; },\n/* harmony export */   useBroadcastChannel: function() { return /* binding */ useBroadcastChannel; },\n/* harmony export */   useBrowserLocation: function() { return /* binding */ useBrowserLocation; },\n/* harmony export */   useCached: function() { return /* binding */ useCached; },\n/* harmony export */   useClipboard: function() { return /* binding */ useClipboard; },\n/* harmony export */   useClipboardItems: function() { return /* binding */ useClipboardItems; },\n/* harmony export */   useCloned: function() { return /* binding */ useCloned; },\n/* harmony export */   useColorMode: function() { return /* binding */ useColorMode; },\n/* harmony export */   useConfirmDialog: function() { return /* binding */ useConfirmDialog; },\n/* harmony export */   useCssVar: function() { return /* binding */ useCssVar; },\n/* harmony export */   useCurrentElement: function() { return /* binding */ useCurrentElement; },\n/* harmony export */   useCycleList: function() { return /* binding */ useCycleList; },\n/* harmony export */   useDark: function() { return /* binding */ useDark; },\n/* harmony export */   useDebouncedRefHistory: function() { return /* binding */ useDebouncedRefHistory; },\n/* harmony export */   useDeviceMotion: function() { return /* binding */ useDeviceMotion; },\n/* harmony export */   useDeviceOrientation: function() { return /* binding */ useDeviceOrientation; },\n/* harmony export */   useDevicePixelRatio: function() { return /* binding */ useDevicePixelRatio; },\n/* harmony export */   useDevicesList: function() { return /* binding */ useDevicesList; },\n/* harmony export */   useDisplayMedia: function() { return /* binding */ useDisplayMedia; },\n/* harmony export */   useDocumentVisibility: function() { return /* binding */ useDocumentVisibility; },\n/* harmony export */   useDraggable: function() { return /* binding */ useDraggable; },\n/* harmony export */   useDropZone: function() { return /* binding */ useDropZone; },\n/* harmony export */   useElementBounding: function() { return /* binding */ useElementBounding; },\n/* harmony export */   useElementByPoint: function() { return /* binding */ useElementByPoint; },\n/* harmony export */   useElementHover: function() { return /* binding */ useElementHover; },\n/* harmony export */   useElementSize: function() { return /* binding */ useElementSize; },\n/* harmony export */   useElementVisibility: function() { return /* binding */ useElementVisibility; },\n/* harmony export */   useEventBus: function() { return /* binding */ useEventBus; },\n/* harmony export */   useEventListener: function() { return /* binding */ useEventListener; },\n/* harmony export */   useEventSource: function() { return /* binding */ useEventSource; },\n/* harmony export */   useEyeDropper: function() { return /* binding */ useEyeDropper; },\n/* harmony export */   useFavicon: function() { return /* binding */ useFavicon; },\n/* harmony export */   useFetch: function() { return /* binding */ useFetch; },\n/* harmony export */   useFileDialog: function() { return /* binding */ useFileDialog; },\n/* harmony export */   useFileSystemAccess: function() { return /* binding */ useFileSystemAccess; },\n/* harmony export */   useFocus: function() { return /* binding */ useFocus; },\n/* harmony export */   useFocusWithin: function() { return /* binding */ useFocusWithin; },\n/* harmony export */   useFps: function() { return /* binding */ useFps; },\n/* harmony export */   useFullscreen: function() { return /* binding */ useFullscreen; },\n/* harmony export */   useGamepad: function() { return /* binding */ useGamepad; },\n/* harmony export */   useGeolocation: function() { return /* binding */ useGeolocation; },\n/* harmony export */   useIdle: function() { return /* binding */ useIdle; },\n/* harmony export */   useImage: function() { return /* binding */ useImage; },\n/* harmony export */   useInfiniteScroll: function() { return /* binding */ useInfiniteScroll; },\n/* harmony export */   useIntersectionObserver: function() { return /* binding */ useIntersectionObserver; },\n/* harmony export */   useKeyModifier: function() { return /* binding */ useKeyModifier; },\n/* harmony export */   useLocalStorage: function() { return /* binding */ useLocalStorage; },\n/* harmony export */   useMagicKeys: function() { return /* binding */ useMagicKeys; },\n/* harmony export */   useManualRefHistory: function() { return /* binding */ useManualRefHistory; },\n/* harmony export */   useMediaControls: function() { return /* binding */ useMediaControls; },\n/* harmony export */   useMediaQuery: function() { return /* binding */ useMediaQuery; },\n/* harmony export */   useMemoize: function() { return /* binding */ useMemoize; },\n/* harmony export */   useMemory: function() { return /* binding */ useMemory; },\n/* harmony export */   useMounted: function() { return /* binding */ useMounted; },\n/* harmony export */   useMouse: function() { return /* binding */ useMouse; },\n/* harmony export */   useMouseInElement: function() { return /* binding */ useMouseInElement; },\n/* harmony export */   useMousePressed: function() { return /* binding */ useMousePressed; },\n/* harmony export */   useMutationObserver: function() { return /* binding */ useMutationObserver; },\n/* harmony export */   useNavigatorLanguage: function() { return /* binding */ useNavigatorLanguage; },\n/* harmony export */   useNetwork: function() { return /* binding */ useNetwork; },\n/* harmony export */   useNow: function() { return /* binding */ useNow; },\n/* harmony export */   useObjectUrl: function() { return /* binding */ useObjectUrl; },\n/* harmony export */   useOffsetPagination: function() { return /* binding */ useOffsetPagination; },\n/* harmony export */   useOnline: function() { return /* binding */ useOnline; },\n/* harmony export */   usePageLeave: function() { return /* binding */ usePageLeave; },\n/* harmony export */   useParallax: function() { return /* binding */ useParallax; },\n/* harmony export */   useParentElement: function() { return /* binding */ useParentElement; },\n/* harmony export */   usePerformanceObserver: function() { return /* binding */ usePerformanceObserver; },\n/* harmony export */   usePermission: function() { return /* binding */ usePermission; },\n/* harmony export */   usePointer: function() { return /* binding */ usePointer; },\n/* harmony export */   usePointerLock: function() { return /* binding */ usePointerLock; },\n/* harmony export */   usePointerSwipe: function() { return /* binding */ usePointerSwipe; },\n/* harmony export */   usePreferredColorScheme: function() { return /* binding */ usePreferredColorScheme; },\n/* harmony export */   usePreferredContrast: function() { return /* binding */ usePreferredContrast; },\n/* harmony export */   usePreferredDark: function() { return /* binding */ usePreferredDark; },\n/* harmony export */   usePreferredLanguages: function() { return /* binding */ usePreferredLanguages; },\n/* harmony export */   usePreferredReducedMotion: function() { return /* binding */ usePreferredReducedMotion; },\n/* harmony export */   usePrevious: function() { return /* binding */ usePrevious; },\n/* harmony export */   useRafFn: function() { return /* binding */ useRafFn; },\n/* harmony export */   useRefHistory: function() { return /* binding */ useRefHistory; },\n/* harmony export */   useResizeObserver: function() { return /* binding */ useResizeObserver; },\n/* harmony export */   useScreenOrientation: function() { return /* binding */ useScreenOrientation; },\n/* harmony export */   useScreenSafeArea: function() { return /* binding */ useScreenSafeArea; },\n/* harmony export */   useScriptTag: function() { return /* binding */ useScriptTag; },\n/* harmony export */   useScroll: function() { return /* binding */ useScroll; },\n/* harmony export */   useScrollLock: function() { return /* binding */ useScrollLock; },\n/* harmony export */   useSessionStorage: function() { return /* binding */ useSessionStorage; },\n/* harmony export */   useShare: function() { return /* binding */ useShare; },\n/* harmony export */   useSorted: function() { return /* binding */ useSorted; },\n/* harmony export */   useSpeechRecognition: function() { return /* binding */ useSpeechRecognition; },\n/* harmony export */   useSpeechSynthesis: function() { return /* binding */ useSpeechSynthesis; },\n/* harmony export */   useStepper: function() { return /* binding */ useStepper; },\n/* harmony export */   useStorage: function() { return /* binding */ useStorage; },\n/* harmony export */   useStorageAsync: function() { return /* binding */ useStorageAsync; },\n/* harmony export */   useStyleTag: function() { return /* binding */ useStyleTag; },\n/* harmony export */   useSupported: function() { return /* binding */ useSupported; },\n/* harmony export */   useSwipe: function() { return /* binding */ useSwipe; },\n/* harmony export */   useTemplateRefsList: function() { return /* binding */ useTemplateRefsList; },\n/* harmony export */   useTextDirection: function() { return /* binding */ useTextDirection; },\n/* harmony export */   useTextSelection: function() { return /* binding */ useTextSelection; },\n/* harmony export */   useTextareaAutosize: function() { return /* binding */ useTextareaAutosize; },\n/* harmony export */   useThrottledRefHistory: function() { return /* binding */ useThrottledRefHistory; },\n/* harmony export */   useTimeAgo: function() { return /* binding */ useTimeAgo; },\n/* harmony export */   useTimeoutPoll: function() { return /* binding */ useTimeoutPoll; },\n/* harmony export */   useTimestamp: function() { return /* binding */ useTimestamp; },\n/* harmony export */   useTitle: function() { return /* binding */ useTitle; },\n/* harmony export */   useTransition: function() { return /* binding */ useTransition; },\n/* harmony export */   useUrlSearchParams: function() { return /* binding */ useUrlSearchParams; },\n/* harmony export */   useUserMedia: function() { return /* binding */ useUserMedia; },\n/* harmony export */   useVModel: function() { return /* binding */ useVModel; },\n/* harmony export */   useVModels: function() { return /* binding */ useVModels; },\n/* harmony export */   useVibrate: function() { return /* binding */ useVibrate; },\n/* harmony export */   useVirtualList: function() { return /* binding */ useVirtualList; },\n/* harmony export */   useWakeLock: function() { return /* binding */ useWakeLock; },\n/* harmony export */   useWebNotification: function() { return /* binding */ useWebNotification; },\n/* harmony export */   useWebSocket: function() { return /* binding */ useWebSocket; },\n/* harmony export */   useWebWorker: function() { return /* binding */ useWebWorker; },\n/* harmony export */   useWebWorkerFn: function() { return /* binding */ useWebWorkerFn; },\n/* harmony export */   useWindowFocus: function() { return /* binding */ useWindowFocus; },\n/* harmony export */   useWindowScroll: function() { return /* binding */ useWindowScroll; },\n/* harmony export */   useWindowSize: function() { return /* binding */ useWindowSize; }\n/* harmony export */ });\n/* harmony import */ var _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vueuse/shared */ \"./node_modules/@vueuse/shared/index.mjs\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"DefaultMagicKeysAliasMap\",\"StorageSerializers\",\"TransitionPresets\",\"asyncComputed\",\"breakpointsAntDesign\",\"breakpointsBootstrapV5\",\"breakpointsMasterCss\",\"breakpointsPrimeFlex\",\"breakpointsQuasar\",\"breakpointsSematic\",\"breakpointsTailwind\",\"breakpointsVuetify\",\"breakpointsVuetifyV2\",\"breakpointsVuetifyV3\",\"cloneFnJSON\",\"computedAsync\",\"computedInject\",\"createFetch\",\"createReusableTemplate\",\"createTemplatePromise\",\"createUnrefFn\",\"customStorageEventName\",\"defaultDocument\",\"defaultLocation\",\"defaultNavigator\",\"defaultWindow\",\"executeTransition\",\"formatTimeAgo\",\"getSSRHandler\",\"mapGamepadToXbox360Controller\",\"onClickOutside\",\"onKeyDown\",\"onKeyPressed\",\"onKeyStroke\",\"onKeyUp\",\"onLongPress\",\"onStartTyping\",\"setSSRHandler\",\"templateRef\",\"unrefElement\",\"useActiveElement\",\"useAnimate\",\"useAsyncQueue\",\"useAsyncState\",\"useBase64\",\"useBattery\",\"useBluetooth\",\"useBreakpoints\",\"useBroadcastChannel\",\"useBrowserLocation\",\"useCached\",\"useClipboard\",\"useClipboardItems\",\"useCloned\",\"useColorMode\",\"useConfirmDialog\",\"useCssVar\",\"useCurrentElement\",\"useCycleList\",\"useDark\",\"useDebouncedRefHistory\",\"useDeviceMotion\",\"useDeviceOrientation\",\"useDevicePixelRatio\",\"useDevicesList\",\"useDisplayMedia\",\"useDocumentVisibility\",\"useDraggable\",\"useDropZone\",\"useElementBounding\",\"useElementByPoint\",\"useElementHover\",\"useElementSize\",\"useElementVisibility\",\"useEventBus\",\"useEventListener\",\"useEventSource\",\"useEyeDropper\",\"useFavicon\",\"useFetch\",\"useFileDialog\",\"useFileSystemAccess\",\"useFocus\",\"useFocusWithin\",\"useFps\",\"useFullscreen\",\"useGamepad\",\"useGeolocation\",\"useIdle\",\"useImage\",\"useInfiniteScroll\",\"useIntersectionObserver\",\"useKeyModifier\",\"useLocalStorage\",\"useMagicKeys\",\"useManualRefHistory\",\"useMediaControls\",\"useMediaQuery\",\"useMemoize\",\"useMemory\",\"useMounted\",\"useMouse\",\"useMouseInElement\",\"useMousePressed\",\"useMutationObserver\",\"useNavigatorLanguage\",\"useNetwork\",\"useNow\",\"useObjectUrl\",\"useOffsetPagination\",\"useOnline\",\"usePageLeave\",\"useParallax\",\"useParentElement\",\"usePerformanceObserver\",\"usePermission\",\"usePointer\",\"usePointerLock\",\"usePointerSwipe\",\"usePreferredColorScheme\",\"usePreferredContrast\",\"usePreferredDark\",\"usePreferredLanguages\",\"usePreferredReducedMotion\",\"usePrevious\",\"useRafFn\",\"useRefHistory\",\"useResizeObserver\",\"useScreenOrientation\",\"useScreenSafeArea\",\"useScriptTag\",\"useScroll\",\"useScrollLock\",\"useSessionStorage\",\"useShare\",\"useSorted\",\"useSpeechRecognition\",\"useSpeechSynthesis\",\"useStepper\",\"useStorage\",\"useStorageAsync\",\"useStyleTag\",\"useSupported\",\"useSwipe\",\"useTemplateRefsList\",\"useTextDirection\",\"useTextSelection\",\"useTextareaAutosize\",\"useThrottledRefHistory\",\"useTimeAgo\",\"useTimeoutPoll\",\"useTimestamp\",\"useTitle\",\"useTransition\",\"useUrlSearchParams\",\"useUserMedia\",\"useVModel\",\"useVModels\",\"useVibrate\",\"useVirtualList\",\"useWakeLock\",\"useWebNotification\",\"useWebSocket\",\"useWebWorker\",\"useWebWorkerFn\",\"useWindowFocus\",\"useWindowScroll\",\"useWindowSize\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-demi */ \"./node_modules/@vueuse/core/node_modules/vue-demi/lib/index.mjs\");\n\n\n\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop\n  } = options;\n  const started = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(!lazy);\n  const current = shallow ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(initialState) : (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialState);\n  let counter = 0;\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.inject)(key);\n  if (defaultSource)\n    source = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.inject)(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.inject)(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)((ctx) => options(source, ctx));\n  } else {\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!vue_demi__WEBPACK_IMPORTED_MODULE_1__.isVue3 && !vue_demi__WEBPACK_IMPORTED_MODULE_1__.version.startsWith(\"2.7.\")) {\n    if (true)\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)();\n  const define = /* #__PURE__ */ (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.defineComponent)({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.defineComponent)({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && \"development\" !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.makeDestructurable)(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!vue_demi__WEBPACK_IMPORTED_MODULE_1__.isVue3) {\n    if (true)\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  function create(...args) {\n    const props = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.defineComponent)((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.h)(vue_demi__WEBPACK_IMPORTED_MODULE_1__.Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.h)(vue_demi__WEBPACK_IMPORTED_MODULE_1__.TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient ? window : void 0;\nconst defaultDocument = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient ? window.document : void 0;\nconst defaultNavigator = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient ? window.navigator : void 0;\nconst defaultLocation = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => [unrefElement(target), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop;\n  if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop));\n    window.document.documentElement.addEventListener(\"click\", _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n  let _trigger = () => {\n  };\n  const element = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.customRef)((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(_trigger);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.onUpdated)(_trigger);\n  return element;\n}\n\nfunction useMounted() {\n  const isMounted = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const instance = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n  if (instance) {\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {\n      isMounted.value = true;\n    }, vue_demi__WEBPACK_IMPORTED_MODULE_1__.isVue2 ? void 0 : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    const value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.notNullish);\n    return new Set(items);\n  });\n  const stopWatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true,\n    triggerOnRemoval = false\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      trigger();\n    }, true);\n    useEventListener(window, \"focus\", trigger, true);\n  }\n  if (triggerOnRemoval) {\n    useMutationObserver(document, (mutations) => {\n      mutations.filter((m) => m.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node) => {\n        if (node === activeElement.value)\n          trigger();\n      });\n    }, {\n      childList: true,\n      subtree: true\n    });\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(pause);\n  return {\n    isActive: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) {\n    config = options;\n    animateOptions = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.objectOmit)(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(void 0);\n  const store = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => store.pending);\n  const playState = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => store.playState);\n  const replaceState = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => store.replaceState);\n  const startTime = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => update(true));\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(keyframes), animateOptions);\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  useEventListener(animate, \"finish\", () => {\n    var _a;\n    if (commitStyles)\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\n  });\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    onFinished = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(initialResult);\n  const activeIndex = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    onSuccess = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(initialState) : (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialState);\n  const isReady = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const isLoading = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.promiseTimeout)(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.until)(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  const promise = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  function execute() {\n    if (!_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(target) || typeof target === \"function\")\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const chargingTime = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const dischargingTime = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const level = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(void 0);\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const isConnected = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(breakpoints[(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(k)]);\n    if (delta != null)\n      v = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.increaseWithUnit)(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\" } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current,\n    active() {\n      const bps = current();\n      return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => bps.value.length === 0 ? \"\" : bps.value.at(-1));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const channel = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)()])\n  );\n  for (const [key, ref2] of (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.objectEntries)(refs)) {\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(refValue.value);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createSingletonPromise)(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => isClipboardApiSupported.value || legacy);\n  const text = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  const copied = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const timeout = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useTimeoutFn)(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const copied = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const timeout = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useTimeoutFn)(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source));\n  }\n  if (!manual && ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(source) || typeof source === \"function\")) {\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef : vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.pausableWatch)(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      window.dispatchEvent(new CustomEvent(customStorageEventName, {\n        detail: {\n          key,\n          oldValue,\n          newValue,\n          storageArea: storage\n        }\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.nextTick)(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(state, onChanged, { flush: \"post\", immediate: true });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => onChanged(state.value));\n  const auto = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false)) {\n  const confirmHook = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const cancelHook = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const revealHook = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  let _resolve = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue);\n  const elRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(prop);\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    [elRef, () => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n  const currentElement = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.computedWithControl)(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.onUpdated)(currentElement.trigger);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.onMounted)(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(getInitialValue());\n  const listRef = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(list);\n  const index = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)((_a = options == null ? void 0 : options.initialValue) != null ? _a : (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(list)[0])) != null ? _b : void 0;\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (mode.system) {\n      return mode.system.value;\n    } else {\n      const preferredDark = usePreferredDark({ window });\n      return preferredDark.value ? \"dark\" : \"light\";\n    }\n  });\n  const isDark = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.markRaw)({\n      snapshot: dump(source.value),\n      timestamp: (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.timestamp)()\n    });\n  }\n  const last = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(_createHistoryRecord());\n  const undoStack = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const redoStack = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => [last.value, ...undoStack.value]);\n  const canUndo = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => undoStack.value.length > 0);\n  const canRedo = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.pausableFilter)(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.watchIgnorable)(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.debounceFilter)(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.bypassFilter\n  } = options;\n  const acceleration = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({ x: null, y: null, z: null });\n  const rotationRate = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({ alpha: null, beta: null, gamma: null });\n  const interval = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const accelerationIncludingGravity = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createFilterWrapper)(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const alpha = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const beta = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const gamma = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const videoInputs = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)();\n  async function _start() {\n    var _a2;\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.addEventListener(\"ended\", stop));\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"visible\");\n  const visibility = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target\n  } = options;\n  const position = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\n    (_a = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(preventDefault))\n      e.preventDefault();\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (e.button !== 0)\n      return;\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.disabled) || !filterEvent(e))\n      return;\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(exact) && e.target !== (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target))\n      return;\n    const container = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(containerElement);\n    const targetRect = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRefs)(position),\n    position,\n    isDragging: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => !!pressedDelta.value),\n    style: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  const isOverDropZone = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const files = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  let counter = 0;\n  let isDataTypeIncluded = true;\n  if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const getFiles = (event) => {\n      var _a, _b;\n      const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      return files.value = list.length === 0 ? null : list;\n    };\n    useEventListener(target, \"dragenter\", (event) => {\n      var _a, _b;\n      const types = Array.from(((_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.items) || []).map((i) => i.kind === \"file\" ? i.type : null).filter(_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.notNullish);\n      if (_options.dataTypes && event.dataTransfer) {\n        const dataTypes = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.unref)(_options.dataTypes);\n        isDataTypeIncluded = typeof dataTypes === \"function\" ? dataTypes(types) : dataTypes ? dataTypes.some((item) => types.includes(item)) : true;\n        if (!isDataTypeIncluded)\n          return;\n      }\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const bottom = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const left = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const right = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const top = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const width = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const x = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const y = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(x), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(x), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useIntervalFn)(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialSize.width);\n  const height = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    const _target = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.notNullish);\n  });\n  let cleanup = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop;\n  const isActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(immediate);\n  const stopWatch = isSupported.value ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.getCurrentScope)();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const status = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"CONNECTING\");\n  const eventSource = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  const urlRef = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(url);\n  const lastEventId = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true\n  } = options;\n  const close = () => {\n    if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      event.value = null;\n      data.value = e.data;\n      lastEventId.value = e.lastEventId;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        event.value = event_name;\n        data.value = e.data || null;\n      });\n    }\n  };\n  const open = () => {\n    if (!_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(urlRef, open, { immediate: true });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close,\n    lastEventId\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.containsProp)(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n  return reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n      const baseUrl = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(config.baseUrl);\n      const targetUrl = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const errorEvent = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const finallyEvent = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const isFinished = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const isFetching = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const aborted = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const statusCode = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const response = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(initialData || null);\n  const canAbort = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useTimeoutFn)(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(config.payload);\n      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(options.refetch);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    [\n      refetch,\n      (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(isFinished),\n    isFetching: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(config.payload)) {\n          (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n            [\n              refetch,\n              (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.until)(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const { on: onChange, trigger } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input && input.value) {\n      input.value = \"\";\n      trigger(null);\n    }\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const file = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const fileName = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\n  const innerFocused = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const targetElement = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\n    }\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => unrefElement(target));\n  const focused = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const requestMethod = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const onConnectedHook = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const onDisconnectedHook = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      index: gamepad.index,\n      connected: gamepad.connected,\n      mapping: gamepad.mapping,\n      timestamp: gamepad.timestamp,\n      vibrationActuator: gamepad.vibrationActuator,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(null);\n  const coords = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.throttleFilter)(50)\n  } = options;\n  const idle = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialState);\n  const lastActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.timestamp)());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createFilterWrapper)(\n    eventFilter,\n    () => {\n      lastActive.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.timestamp)();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    onScroll = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const internalY = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const x = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(_y)) != null ? _a : y.value,\n      left: (_b = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(_x)) != null ? _b : x.value,\n      behavior: (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const arrivedState = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useDebounceFn)(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useThrottleFn)(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    try {\n      const _element = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const isLoading = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => !!promise.value);\n  const observedElement = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return resolveElement((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop\n  } = options;\n  const current = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => keys.every((key) => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(proxy[key])));\n          } else {\n            refs[prop] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source))\n    cb((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  target = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(target);\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const duration = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const seeking = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const volume = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(1);\n  const waiting = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const ended = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const playing = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const rate = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(1);\n  const stalled = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const buffered = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const tracks = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const selectedTrack = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(-1);\n  const isPictureInPicture = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const muted = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n    if (!document)\n      return;\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    const src = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)([target, volume], () => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)([target, muted], () => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)([target, rate], () => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n    if (!document)\n      return;\n    const textTracks = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.tracks);\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.watchIgnorable)(currentTime, (time) => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.watchIgnorable)(playing, (isPlaying) => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)([target], () => {\n    const el = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.set)(data, key, value),\n    has: (key) => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(data, key),\n    delete: (key) => (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.del)(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.del)(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)(options.cache);\n    if (vue_demi__WEBPACK_IMPORTED_MODULE_1__.isVue2)\n      return getMapVue2Compat();\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useIntervalFn)(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  const x = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue.x);\n  const y = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue.y);\n  const sourceType = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX;\n      y.value = pos[1] + window.scrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const elementY = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const elementPositionX = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const elementPositionY = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const elementHeight = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const elementWidth = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0);\n  const isOutside = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue);\n  const sourceType = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(true);\n  const saveData = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const offlineAt = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(void 0);\n  const onlineAt = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(void 0);\n  const downlink = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(void 0);\n  const downlinkMax = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(void 0);\n  const rtt = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(void 0);\n  const effectiveType = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(void 0);\n  const type = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useIntervalFn)(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    () => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(release);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isReadonly)(value))\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.clamp)((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(value), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(min), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(max)));\n  const _value = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(value);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return _value.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.clamp)(_value.value, (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(min), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(max));\n    },\n    set(value2) {\n      _value.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.clamp)(value2, (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(min), (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    onPageSizeChange = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n    onPageCountChange = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => Math.max(\n    1,\n    Math.ceil((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(total) / (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => currentPage.value === 1);\n  const isLastPage = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => currentPage.value === pageCount.value);\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(page)) {\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.syncRef)(page, currentPage, {\n      direction: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isReadonly)(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(pageSize)) {\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.syncRef)(pageSize, currentPageSize, {\n      direction: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isReadonly)(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(currentPage, () => {\n    onPageChange((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(returnValue));\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(currentPageSize, () => {\n    onPageSizeChange((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(returnValue));\n  });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(pageCount, () => {\n    onPageCountChange((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(screenOrientation.type);\n  const angle = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(useDeviceOrientation({ window }));\n  const screenOrientation = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\n      return \"deviceOrientation\";\n    }\n    return \"mouse\";\n  });\n  const roll = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(update);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.objectPick)(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRefs)(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const triggerElement = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.until)(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.until)(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => posStart.x - posEnd.x);\n  const distanceY = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const isPointerDown = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const direction = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    })\n  ];\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(isSwiping),\n    direction: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(direction),\n    posStart: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(posStart),\n    posEnd: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([\"en\"]);\n  const navigator = window.navigator;\n  const value = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(initialValue);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  const right = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  const bottom = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  const left = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useDebounceFn)(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(load);\n  if (!manual)\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnUnmounted)(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(element), (el) => {\n    const target = resolveElement((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element));\n    if (!el || isLocked.value)\n      return;\n    if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(element));\n    if (!el || !isLocked.value)\n      return;\n    _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(unlock);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(shareOptions),\n        ...(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => sortFn([...(0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source)], compareFn));\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n    const result = sortFn((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source), compareFn);\n    if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.isRef)(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(options.lang || \"en-US\");\n  const isListening = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const isFinal = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const result = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"\");\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n      isFinal.value = currentResult.isFinal;\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(lang);\n    };\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const status = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"init\");\n  const spokenText = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(text || \"\");\n  const lang = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(options.lang || \"en-US\");\n  const error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(lang);\n    utterance2.voice = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.voice) || null;\n    utterance2.pitch = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(pitch);\n    utterance2.rate = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(steps);\n  const stepNames = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => at(index.value));\n  const isFirst = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => index.value === 0);\n  const isLast = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => index.value === stepNames.value.length - 1);\n  const next = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => stepNames.value[index.value + 1]);\n  const previous = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef : vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.watchWithFilter)(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(load);\n  if (!manual)\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.readonly)(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({ x: 0, y: 0 });\n  const coordsEnd = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({ x: 0, y: 0 });\n  const diffX = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => coordsStart.x - coordsEnd.x);\n  const diffY = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const direction = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop, optionsBlock);\n  document.removeEventListener(\"x\", _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.onBeforeUpdate)(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(getValue());\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const text = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  var _a;\n  const textarea = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(options == null ? void 0 : options.element);\n  const input = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(options == null ? void 0 : options.input);\n  const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : \"height\";\n  const textareaScrollHeight = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(1);\n  function triggerResize() {\n    var _a2;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.styleTarget).style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)([input, textarea], () => (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.nextTick)(triggerResize), { immediate: true });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(textareaScrollHeight, () => {\n    var _a2;\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\n  });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.throttleFilter)(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => formatTimeAgo(new Date((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(time)), options, (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useTimeoutFn)(loop, interval, { immediate: false });\n  const isActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.timestamp)() + offset);\n  const update = () => ts.value = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.timestamp)() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useIntervalFn)(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(template).replace(/%s/g, t);\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnBeforeUnmount)(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(from);\n  const toVal = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.transition)) != null ? _b : _vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(source);\n    return typeof v === \"number\" ? v : v.map(_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue);\n  };\n  const outputRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(sourceVal());\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(sourceVal, async (to) => {\n    var _a, _b;\n    if ((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.promiseTimeout)((0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue) : (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(() => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    currentId++;\n  });\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toValue)(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)(initialValue);\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.reactive)({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.pausableWatch)(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else _stop();\n    },\n    { immediate: true }\n  );\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (vue_demi__WEBPACK_IMPORTED_MODULE_1__.isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isDef)(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialValue);\n    let isUpdating = false;\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => isUpdating = false);\n        }\n      }\n    );\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useIntervalFn)(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const size = useElementSize(containerRef);\n  const currentList = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n  const source = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)(list);\n  const state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)([size.width, size.height, list, containerRef], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => {\n    if (!window || !(\"Notification\" in window))\n      return false;\n    try {\n      new Notification(\"\");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  });\n  const permissionGranted = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const { on: onShow, trigger: showTrigger } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const { on: onError, trigger: errorTrigger } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const { on: onClose, trigger: closeTrigger } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.createEventHook)();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(ensurePermissions);\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const status = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"CLOSED\");\n  const wsRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const urlRef = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.toRef)(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.useIntervalFn)(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient)\n      useEventListener(\"beforeunload\", () => close());\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(close);\n  }\n  const open = () => {\n    if (!_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isClient && !_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(urlRef, open);\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n  const worker = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.shallowRef)();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps, localDeps) {\n  if (deps.length === 0 && localDeps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n    const str = fn.toString();\n    if (str.trim().startsWith(\"function\")) {\n      return str;\n    } else {\n      const name = fn.name;\n      return `const ${name} = ${str}`;\n    }\n  }).join(\";\");\n  const importString = `importScripts(${depsString});`;\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\n\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    localDependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const workerStatus = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(\"PENDING\");\n  const promise = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)({});\n  const timeoutId = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnScopeDispose)(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n  const focused = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0),\n      y: (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(0)\n    };\n  }\n  const internalX = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(window.scrollX);\n  const internalY = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(window.scrollY);\n  const x = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.computed)({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialWidth);\n  const height = (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.ref)(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  (0,_vueuse_shared__WEBPACK_IMPORTED_MODULE_0__.tryOnMounted)(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_1__.watch)(matches, () => update());\n  }\n  return { width, height };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZXVzZS9jb3JlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnbUI7QUFDamtCO0FBQzRTOztBQUUzVTtBQUNBO0FBQ0EsTUFBTSwrQ0FBSztBQUNYO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdEQUFJO0FBQ2xCLElBQUk7QUFDSixrQkFBa0IsNkNBQUc7QUFDckIsNEJBQTRCLG9EQUFVLGlCQUFpQiw2Q0FBRztBQUMxRDtBQUNBLEVBQUUscURBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLGtEQUFRO0FBQ25CO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0RBQU07QUFDckI7QUFDQSxhQUFhLGdEQUFNO0FBQ25CO0FBQ0EsYUFBYSxnREFBTTtBQUNuQjtBQUNBLFdBQVcsa0RBQVE7QUFDbkIsSUFBSTtBQUNKLFdBQVcsa0RBQVE7QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLDRDQUE0QztBQUM1QyxPQUFPLDRDQUFNLEtBQUssNkNBQU87QUFDekIsUUFBUSxJQUFxQztBQUM3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QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLDZDQUFHO0FBQ25CLGlCQUFpQiw2Q0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNERBQVk7QUFDZCx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0EsSUFBSSwrQ0FBSztBQUNUO0FBQ0EsV0FBVztBQUNYOztBQUVtdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B2dWV1c2UvY29yZS9pbmRleC5tanM/OGRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub29wLCBtYWtlRGVzdHJ1Y3R1cmFibGUsIGNhbWVsaXplLCB0b1ZhbHVlLCBpc0NsaWVudCwgaXNPYmplY3QsIHRyeU9uU2NvcGVEaXNwb3NlLCBpc0lPUywgdHJ5T25Nb3VudGVkLCBub3ROdWxsaXNoLCBvYmplY3RPbWl0LCBwcm9taXNlVGltZW91dCwgdW50aWwsIGluY3JlYXNlV2l0aFVuaXQsIG9iamVjdEVudHJpZXMsIGNyZWF0ZVNpbmdsZXRvblByb21pc2UsIHVzZVRpbWVvdXRGbiwgcGF1c2FibGVXYXRjaCwgdG9SZWYsIGNyZWF0ZUV2ZW50SG9vaywgY29tcHV0ZWRXaXRoQ29udHJvbCwgdGltZXN0YW1wLCBwYXVzYWJsZUZpbHRlciwgd2F0Y2hJZ25vcmFibGUsIGRlYm91bmNlRmlsdGVyLCBjcmVhdGVGaWx0ZXJXcmFwcGVyLCBieXBhc3NGaWx0ZXIsIHRvUmVmcywgdXNlSW50ZXJ2YWxGbiwgY29udGFpbnNQcm9wLCBoYXNPd24sIHRocm90dGxlRmlsdGVyLCB1c2VEZWJvdW5jZUZuLCB1c2VUaHJvdHRsZUZuLCBjbGFtcCwgc3luY1JlZiwgb2JqZWN0UGljaywgdHJ5T25Vbm1vdW50ZWQsIHdhdGNoV2l0aEZpbHRlciwgdHJ5T25CZWZvcmVVbm1vdW50LCBpZGVudGl0eSwgaXNEZWYsIGlzV29ya2VyIH0gZnJvbSAnQHZ1ZXVzZS9zaGFyZWQnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZXVzZS9zaGFyZWQnO1xuaW1wb3J0IHsgaXNSZWYsIHJlZiwgc2hhbGxvd1JlZiwgd2F0Y2hFZmZlY3QsIGNvbXB1dGVkLCBpbmplY3QsIGlzVnVlMywgdmVyc2lvbiwgZGVmaW5lQ29tcG9uZW50LCBoLCBUcmFuc2l0aW9uR3JvdXAsIHNoYWxsb3dSZWFjdGl2ZSwgRnJhZ21lbnQsIHdhdGNoLCBnZXRDdXJyZW50SW5zdGFuY2UsIGN1c3RvbVJlZiwgb25VcGRhdGVkLCBvbk1vdW50ZWQsIGlzVnVlMiwgcmVhZG9ubHksIG5leHRUaWNrLCByZWFjdGl2ZSwgbWFya1JhdywgdW5yZWYsIGdldEN1cnJlbnRTY29wZSwgc2V0LCBkZWwsIGlzUmVhZG9ubHksIG9uQmVmb3JlVXBkYXRlIH0gZnJvbSAndnVlLWRlbWknO1xuXG5mdW5jdGlvbiBjb21wdXRlZEFzeW5jKGV2YWx1YXRpb25DYWxsYmFjaywgaW5pdGlhbFN0YXRlLCBvcHRpb25zT3JSZWYpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChpc1JlZihvcHRpb25zT3JSZWYpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGV2YWx1YXRpbmc6IG9wdGlvbnNPclJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnNPclJlZiB8fCB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgbGF6eSA9IGZhbHNlLFxuICAgIGV2YWx1YXRpbmcgPSB2b2lkIDAsXG4gICAgc2hhbGxvdyA9IHRydWUsXG4gICAgb25FcnJvciA9IG5vb3BcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHN0YXJ0ZWQgPSByZWYoIWxhenkpO1xuICBjb25zdCBjdXJyZW50ID0gc2hhbGxvdyA/IHNoYWxsb3dSZWYoaW5pdGlhbFN0YXRlKSA6IHJlZihpbml0aWFsU3RhdGUpO1xuICBsZXQgY291bnRlciA9IDA7XG4gIHdhdGNoRWZmZWN0KGFzeW5jIChvbkludmFsaWRhdGUpID0+IHtcbiAgICBpZiAoIXN0YXJ0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY291bnRlcisrO1xuICAgIGNvbnN0IGNvdW50ZXJBdEJlZ2lubmluZyA9IGNvdW50ZXI7XG4gICAgbGV0IGhhc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgaWYgKGV2YWx1YXRpbmcpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBldmFsdWF0aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZhbHVhdGlvbkNhbGxiYWNrKChjYW5jZWxDYWxsYmFjaykgPT4ge1xuICAgICAgICBvbkludmFsaWRhdGUoKCkgPT4ge1xuICAgICAgICAgIGlmIChldmFsdWF0aW5nKVxuICAgICAgICAgICAgZXZhbHVhdGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmICghaGFzRmluaXNoZWQpXG4gICAgICAgICAgICBjYW5jZWxDYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNvdW50ZXJBdEJlZ2lubmluZyA9PT0gY291bnRlcilcbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXZhbHVhdGluZyAmJiBjb3VudGVyQXRCZWdpbm5pbmcgPT09IGNvdW50ZXIpXG4gICAgICAgIGV2YWx1YXRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICAgIGhhc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobGF6eSkge1xuICAgIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgICBzdGFydGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVkSW5qZWN0KGtleSwgb3B0aW9ucywgZGVmYXVsdFNvdXJjZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5KSB7XG4gIGxldCBzb3VyY2UgPSBpbmplY3Qoa2V5KTtcbiAgaWYgKGRlZmF1bHRTb3VyY2UpXG4gICAgc291cmNlID0gaW5qZWN0KGtleSwgZGVmYXVsdFNvdXJjZSk7XG4gIGlmICh0cmVhdERlZmF1bHRBc0ZhY3RvcnkpXG4gICAgc291cmNlID0gaW5qZWN0KGtleSwgZGVmYXVsdFNvdXJjZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5KTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKGN0eCkgPT4gb3B0aW9ucyhzb3VyY2UsIGN0eCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb21wdXRlZCh7XG4gICAgICBnZXQ6IChjdHgpID0+IG9wdGlvbnMuZ2V0KHNvdXJjZSwgY3R4KSxcbiAgICAgIHNldDogb3B0aW9ucy5zZXRcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXVzYWJsZVRlbXBsYXRlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWlzVnVlMyAmJiAhdmVyc2lvbi5zdGFydHNXaXRoKFwiMi43LlwiKSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbVnVlVXNlXSBjcmVhdGVSZXVzYWJsZVRlbXBsYXRlIG9ubHkgd29ya3MgaW4gVnVlIDIuNyBvciBhYm92ZS5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbmhlcml0QXR0cnMgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZW5kZXIgPSBzaGFsbG93UmVmKCk7XG4gIGNvbnN0IGRlZmluZSA9IC8qICNfX1BVUkVfXyAqLyBkZWZpbmVDb21wb25lbnQoe1xuICAgIHNldHVwKF8sIHsgc2xvdHMgfSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVuZGVyLnZhbHVlID0gc2xvdHMuZGVmYXVsdDtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmV1c2UgPSAvKiAjX19QVVJFX18gKi8gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBpbmhlcml0QXR0cnMsXG4gICAgc2V0dXAoXywgeyBhdHRycywgc2xvdHMgfSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlbmRlci52YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Z1ZVVzZV0gRmFpbGVkIHRvIGZpbmQgdGhlIGRlZmluaXRpb24gb2YgcmV1c2FibGUgdGVtcGxhdGVcIik7XG4gICAgICAgIGNvbnN0IHZub2RlID0gKF9hID0gcmVuZGVyLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChyZW5kZXIsIHsgLi4ua2V5c1RvQ2FtZWxLZWJhYkNhc2UoYXR0cnMpLCAkc2xvdHM6IHNsb3RzIH0pO1xuICAgICAgICByZXR1cm4gaW5oZXJpdEF0dHJzICYmICh2bm9kZSA9PSBudWxsID8gdm9pZCAwIDogdm5vZGUubGVuZ3RoKSA9PT0gMSA/IHZub2RlWzBdIDogdm5vZGU7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYWtlRGVzdHJ1Y3R1cmFibGUoXG4gICAgeyBkZWZpbmUsIHJldXNlIH0sXG4gICAgW2RlZmluZSwgcmV1c2VdXG4gICk7XG59XG5mdW5jdGlvbiBrZXlzVG9DYW1lbEtlYmFiQ2FzZShvYmopIHtcbiAgY29uc3QgbmV3T2JqID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iailcbiAgICBuZXdPYmpbY2FtZWxpemUoa2V5KV0gPSBvYmpba2V5XTtcbiAgcmV0dXJuIG5ld09iajtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVQcm9taXNlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWlzVnVlMykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbVnVlVXNlXSBjcmVhdGVUZW1wbGF0ZVByb21pc2Ugb25seSB3b3JrcyBpbiBWdWUgMyBvciBhYm92ZS5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGluc3RhbmNlcyA9IHJlZihbXSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBzaGFsbG93UmVhY3RpdmUoe1xuICAgICAga2V5OiBpbmRleCsrLFxuICAgICAgYXJncyxcbiAgICAgIHByb21pc2U6IHZvaWQgMCxcbiAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBpc1Jlc29sdmluZzogZmFsc2UsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgaW5zdGFuY2VzLnZhbHVlLnB1c2gocHJvcHMpO1xuICAgIHByb3BzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIHByb3BzLnJlc29sdmUgPSAodikgPT4ge1xuICAgICAgICBwcm9wcy5pc1Jlc29sdmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBfcmVzb2x2ZSh2KTtcbiAgICAgIH07XG4gICAgICBwcm9wcy5yZWplY3QgPSBfcmVqZWN0O1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgcHJvcHMucHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGluZGV4MiA9IGluc3RhbmNlcy52YWx1ZS5pbmRleE9mKHByb3BzKTtcbiAgICAgIGlmIChpbmRleDIgIT09IC0xKVxuICAgICAgICBpbnN0YW5jZXMudmFsdWUuc3BsaWNlKGluZGV4MiwgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3BzLnByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoLi4uYXJncykge1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbiAmJiBpbnN0YW5jZXMudmFsdWUubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBpbnN0YW5jZXMudmFsdWVbMF0ucHJvbWlzZTtcbiAgICByZXR1cm4gY3JlYXRlKC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudCA9IC8qICNfX1BVUkVfXyAqLyBkZWZpbmVDb21wb25lbnQoKF8sIHsgc2xvdHMgfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlckxpc3QgPSAoKSA9PiBpbnN0YW5jZXMudmFsdWUubWFwKChwcm9wcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIGgoRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfSwgKF9hID0gc2xvdHMuZGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc2xvdHMsIHByb3BzKSk7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbilcbiAgICAgIHJldHVybiAoKSA9PiBoKFRyYW5zaXRpb25Hcm91cCwgb3B0aW9ucy50cmFuc2l0aW9uLCByZW5kZXJMaXN0KTtcbiAgICByZXR1cm4gcmVuZGVyTGlzdDtcbiAgfSk7XG4gIGNvbXBvbmVudC5zdGFydCA9IHN0YXJ0O1xuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbnJlZkZuKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MubWFwKChpKSA9PiB0b1ZhbHVlKGkpKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVucmVmRWxlbWVudChlbFJlZikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHBsYWluID0gdG9WYWx1ZShlbFJlZik7XG4gIHJldHVybiAoX2EgPSBwbGFpbiA9PSBudWxsID8gdm9pZCAwIDogcGxhaW4uJGVsKSAhPSBudWxsID8gX2EgOiBwbGFpbjtcbn1cblxuY29uc3QgZGVmYXVsdFdpbmRvdyA9IGlzQ2xpZW50ID8gd2luZG93IDogdm9pZCAwO1xuY29uc3QgZGVmYXVsdERvY3VtZW50ID0gaXNDbGllbnQgPyB3aW5kb3cuZG9jdW1lbnQgOiB2b2lkIDA7XG5jb25zdCBkZWZhdWx0TmF2aWdhdG9yID0gaXNDbGllbnQgPyB3aW5kb3cubmF2aWdhdG9yIDogdm9pZCAwO1xuY29uc3QgZGVmYXVsdExvY2F0aW9uID0gaXNDbGllbnQgPyB3aW5kb3cubG9jYXRpb24gOiB2b2lkIDA7XG5cbmZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoLi4uYXJncykge1xuICBsZXQgdGFyZ2V0O1xuICBsZXQgZXZlbnRzO1xuICBsZXQgbGlzdGVuZXJzO1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICBbZXZlbnRzLCBsaXN0ZW5lcnMsIG9wdGlvbnNdID0gYXJncztcbiAgICB0YXJnZXQgPSBkZWZhdWx0V2luZG93O1xuICB9IGVsc2Uge1xuICAgIFt0YXJnZXQsIGV2ZW50cywgbGlzdGVuZXJzLCBvcHRpb25zXSA9IGFyZ3M7XG4gIH1cbiAgaWYgKCF0YXJnZXQpXG4gICAgcmV0dXJuIG5vb3A7XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpKVxuICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSlcbiAgICBsaXN0ZW5lcnMgPSBbbGlzdGVuZXJzXTtcbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBjbGVhbnVwcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgY2xlYW51cHMubGVuZ3RoID0gMDtcbiAgfTtcbiAgY29uc3QgcmVnaXN0ZXIgPSAoZWwsIGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9uczIpID0+IHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9uczIpO1xuICAgIHJldHVybiAoKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9uczIpO1xuICB9O1xuICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaChcbiAgICAoKSA9PiBbdW5yZWZFbGVtZW50KHRhcmdldCksIHRvVmFsdWUob3B0aW9ucyldLFxuICAgIChbZWwsIG9wdGlvbnMyXSkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKCFlbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgb3B0aW9uc0Nsb25lID0gaXNPYmplY3Qob3B0aW9uczIpID8geyAuLi5vcHRpb25zMiB9IDogb3B0aW9uczI7XG4gICAgICBjbGVhbnVwcy5wdXNoKFxuICAgICAgICAuLi5ldmVudHMuZmxhdE1hcCgoZXZlbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLm1hcCgobGlzdGVuZXIpID0+IHJlZ2lzdGVyKGVsLCBldmVudCwgbGlzdGVuZXIsIG9wdGlvbnNDbG9uZSkpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIHN0b3BXYXRjaCgpO1xuICAgIGNsZWFudXAoKTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiBzdG9wO1xufVxuXG5sZXQgX2lPU1dvcmthcm91bmQgPSBmYWxzZTtcbmZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlKHRhcmdldCwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgaWdub3JlID0gW10sIGNhcHR1cmUgPSB0cnVlLCBkZXRlY3RJZnJhbWUgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgaWYgKCF3aW5kb3cpXG4gICAgcmV0dXJuIG5vb3A7XG4gIGlmIChpc0lPUyAmJiAhX2lPU1dvcmthcm91bmQpIHtcbiAgICBfaU9TV29ya2Fyb3VuZCA9IHRydWU7XG4gICAgQXJyYXkuZnJvbSh3aW5kb3cuZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBub29wKSk7XG4gICAgd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgbm9vcCk7XG4gIH1cbiAgbGV0IHNob3VsZExpc3RlbiA9IHRydWU7XG4gIGNvbnN0IHNob3VsZElnbm9yZSA9IChldmVudCkgPT4ge1xuICAgIHJldHVybiBpZ25vcmUuc29tZSgodGFyZ2V0MikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldDIpKS5zb21lKChlbCkgPT4gZWwgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0Mik7XG4gICAgICAgIHJldHVybiBlbCAmJiAoZXZlbnQudGFyZ2V0ID09PSBlbCB8fCBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlbCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgaWYgKCFlbCB8fCBlbCA9PT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGVsKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQuZGV0YWlsID09PSAwKVxuICAgICAgc2hvdWxkTGlzdGVuID0gIXNob3VsZElnbm9yZShldmVudCk7XG4gICAgaWYgKCFzaG91bGRMaXN0ZW4pIHtcbiAgICAgIHNob3VsZExpc3RlbiA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZXIoZXZlbnQpO1xuICB9O1xuICBjb25zdCBjbGVhbnVwID0gW1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImNsaWNrXCIsIGxpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmUgfSksXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwicG9pbnRlcmRvd25cIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgICBzaG91bGRMaXN0ZW4gPSAhc2hvdWxkSWdub3JlKGUpICYmICEhKGVsICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGVsKSk7XG4gICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pLFxuICAgIGRldGVjdElmcmFtZSAmJiB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJibHVyXCIsIChldmVudCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCgoX2EgPSB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRhZ05hbWUpID09PSBcIklGUkFNRVwiICYmICEoZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmNvbnRhaW5zKHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50KSkpIHtcbiAgICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSlcbiAgXS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiBjbGVhbnVwLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVByZWRpY2F0ZShrZXlGaWx0ZXIpIHtcbiAgaWYgKHR5cGVvZiBrZXlGaWx0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4ga2V5RmlsdGVyO1xuICBlbHNlIGlmICh0eXBlb2Yga2V5RmlsdGVyID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiAoZXZlbnQpID0+IGV2ZW50LmtleSA9PT0ga2V5RmlsdGVyO1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleUZpbHRlcikpXG4gICAgcmV0dXJuIChldmVudCkgPT4ga2V5RmlsdGVyLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gIHJldHVybiAoKSA9PiB0cnVlO1xufVxuZnVuY3Rpb24gb25LZXlTdHJva2UoLi4uYXJncykge1xuICBsZXQga2V5O1xuICBsZXQgaGFuZGxlcjtcbiAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAga2V5ID0gYXJnc1swXTtcbiAgICBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICBvcHRpb25zID0gYXJnc1syXTtcbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAga2V5ID0gdHJ1ZTtcbiAgICAgIGhhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGFyZ3NbMF07XG4gICAgICBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gdHJ1ZTtcbiAgICBoYW5kbGVyID0gYXJnc1swXTtcbiAgfVxuICBjb25zdCB7XG4gICAgdGFyZ2V0ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudE5hbWUgPSBcImtleWRvd25cIixcbiAgICBwYXNzaXZlID0gZmFsc2UsXG4gICAgZGVkdXBlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByZWRpY2F0ZSA9IGNyZWF0ZUtleVByZWRpY2F0ZShrZXkpO1xuICBjb25zdCBsaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgaWYgKGUucmVwZWF0ICYmIHRvVmFsdWUoZGVkdXBlKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAocHJlZGljYXRlKGUpKVxuICAgICAgaGFuZGxlcihlKTtcbiAgfTtcbiAgcmV0dXJuIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGxpc3RlbmVyLCBwYXNzaXZlKTtcbn1cbmZ1bmN0aW9uIG9uS2V5RG93bihrZXksIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gb25LZXlTdHJva2Uoa2V5LCBoYW5kbGVyLCB7IC4uLm9wdGlvbnMsIGV2ZW50TmFtZTogXCJrZXlkb3duXCIgfSk7XG59XG5mdW5jdGlvbiBvbktleVByZXNzZWQoa2V5LCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG9uS2V5U3Ryb2tlKGtleSwgaGFuZGxlciwgeyAuLi5vcHRpb25zLCBldmVudE5hbWU6IFwia2V5cHJlc3NcIiB9KTtcbn1cbmZ1bmN0aW9uIG9uS2V5VXAoa2V5LCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG9uS2V5U3Ryb2tlKGtleSwgaGFuZGxlciwgeyAuLi5vcHRpb25zLCBldmVudE5hbWU6IFwia2V5dXBcIiB9KTtcbn1cblxuY29uc3QgREVGQVVMVF9ERUxBWSA9IDUwMDtcbmNvbnN0IERFRkFVTFRfVEhSRVNIT0xEID0gMTA7XG5mdW5jdGlvbiBvbkxvbmdQcmVzcyh0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZWxlbWVudFJlZiA9IGNvbXB1dGVkKCgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpKTtcbiAgbGV0IHRpbWVvdXQ7XG4gIGxldCBwb3NTdGFydDtcbiAgbGV0IHN0YXJ0VGltZXN0YW1wO1xuICBsZXQgaGFzTG9uZ1ByZXNzZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHBvc1N0YXJ0ID0gdm9pZCAwO1xuICAgIHN0YXJ0VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIGhhc0xvbmdQcmVzc2VkID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gb25SZWxlYXNlKGV2KSB7XG4gICAgdmFyIF9hMiwgX2IyLCBfYztcbiAgICBjb25zdCBbX3N0YXJ0VGltZXN0YW1wLCBfcG9zU3RhcnQsIF9oYXNMb25nUHJlc3NlZF0gPSBbc3RhcnRUaW1lc3RhbXAsIHBvc1N0YXJ0LCBoYXNMb25nUHJlc3NlZF07XG4gICAgY2xlYXIoKTtcbiAgICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uTW91c2VVcCkgfHwgIV9wb3NTdGFydCB8fCAhX3N0YXJ0VGltZXN0YW1wKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICgoKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNlbGYpICYmIGV2LnRhcmdldCAhPT0gZWxlbWVudFJlZi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKF9iMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnByZXZlbnQpXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0b3ApXG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBkeCA9IGV2LnggLSBfcG9zU3RhcnQueDtcbiAgICBjb25zdCBkeSA9IGV2LnkgLSBfcG9zU3RhcnQueTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgb3B0aW9ucy5vbk1vdXNlVXAoZXYudGltZVN0YW1wIC0gX3N0YXJ0VGltZXN0YW1wLCBkaXN0YW5jZSwgX2hhc0xvbmdQcmVzc2VkKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRvd24oZXYpIHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jLCBfZDtcbiAgICBpZiAoKChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZWxmKSAmJiBldi50YXJnZXQgIT09IGVsZW1lbnRSZWYudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXIoKTtcbiAgICBpZiAoKF9iMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnByZXZlbnQpXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0b3ApXG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBwb3NTdGFydCA9IHtcbiAgICAgIHg6IGV2LngsXG4gICAgICB5OiBldi55XG4gICAgfTtcbiAgICBzdGFydFRpbWVzdGFtcCA9IGV2LnRpbWVTdGFtcDtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgaGFzTG9uZ1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVyKGV2KTtcbiAgICAgIH0sXG4gICAgICAoX2QgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5KSAhPSBudWxsID8gX2QgOiBERUZBVUxUX0RFTEFZXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBvbk1vdmUoZXYpIHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jLCBfZDtcbiAgICBpZiAoKChfYTIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZWxmKSAmJiBldi50YXJnZXQgIT09IGVsZW1lbnRSZWYudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwb3NTdGFydCB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXN0YW5jZVRocmVzaG9sZCkgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICgoX2IyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYjIucHJldmVudClcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kaWZpZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RvcClcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IGR4ID0gZXYueCAtIHBvc1N0YXJ0Lng7XG4gICAgY29uc3QgZHkgPSBldi55IC0gcG9zU3RhcnQueTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKGRpc3RhbmNlID49ICgoX2QgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc3RhbmNlVGhyZXNob2xkKSAhPSBudWxsID8gX2QgOiBERUZBVUxUX1RIUkVTSE9MRCkpXG4gICAgICBjbGVhcigpO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICBjYXB0dXJlOiAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGlmaWVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhcHR1cmUsXG4gICAgb25jZTogKF9iID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RpZmllcnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vbmNlXG4gIH07XG4gIGNvbnN0IGNsZWFudXAgPSBbXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihlbGVtZW50UmVmLCBcInBvaW50ZXJkb3duXCIsIG9uRG93biwgbGlzdGVuZXJPcHRpb25zKSxcbiAgICB1c2VFdmVudExpc3RlbmVyKGVsZW1lbnRSZWYsIFwicG9pbnRlcm1vdmVcIiwgb25Nb3ZlLCBsaXN0ZW5lck9wdGlvbnMpLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIoZWxlbWVudFJlZiwgW1wicG9pbnRlcnVwXCIsIFwicG9pbnRlcmxlYXZlXCJdLCBvblJlbGVhc2UsIGxpc3RlbmVyT3B0aW9ucylcbiAgXTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IGNsZWFudXAuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICByZXR1cm4gc3RvcDtcbn1cblxuZnVuY3Rpb24gaXNGb2N1c2VkRWxlbWVudEVkaXRhYmxlKCkge1xuICBjb25zdCB7IGFjdGl2ZUVsZW1lbnQsIGJvZHkgfSA9IGRvY3VtZW50O1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gYm9keSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAoYWN0aXZlRWxlbWVudC50YWdOYW1lKSB7XG4gICAgY2FzZSBcIklOUFVUXCI6XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIik7XG59XG5mdW5jdGlvbiBpc1R5cGVkQ2hhclZhbGlkKHtcbiAga2V5Q29kZSxcbiAgbWV0YUtleSxcbiAgY3RybEtleSxcbiAgYWx0S2V5XG59KSB7XG4gIGlmIChtZXRhS2V5IHx8IGN0cmxLZXkgfHwgYWx0S2V5KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1NylcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGtleUNvZGUgPj0gNjUgJiYga2V5Q29kZSA8PSA5MClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGtleUNvZGUgPj0gOTcgJiYga2V5Q29kZSA8PSAxMjIpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uU3RhcnRUeXBpbmcoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGRvY3VtZW50OiBkb2N1bWVudDIgPSBkZWZhdWx0RG9jdW1lbnQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAhaXNGb2N1c2VkRWxlbWVudEVkaXRhYmxlKCkgJiYgaXNUeXBlZENoYXJWYWxpZChldmVudCkgJiYgY2FsbGJhY2soZXZlbnQpO1xuICB9O1xuICBpZiAoZG9jdW1lbnQyKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQyLCBcImtleWRvd25cIiwga2V5ZG93biwgeyBwYXNzaXZlOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZVJlZihrZXksIGluaXRpYWxWYWx1ZSA9IG51bGwpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgbGV0IF90cmlnZ2VyID0gKCkgPT4ge1xuICB9O1xuICBjb25zdCBlbGVtZW50ID0gY3VzdG9tUmVmKCh0cmFjaywgdHJpZ2dlcikgPT4ge1xuICAgIF90cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuJHJlZnNba2V5XSkgIT0gbnVsbCA/IF9iIDogaW5pdGlhbFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgdHJ5T25Nb3VudGVkKF90cmlnZ2VyKTtcbiAgb25VcGRhdGVkKF90cmlnZ2VyKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZU1vdW50ZWQoKSB7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICBpc01vdW50ZWQudmFsdWUgPSB0cnVlO1xuICAgIH0sIGlzVnVlMiA/IHZvaWQgMCA6IGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaXNNb3VudGVkO1xufVxuXG5mdW5jdGlvbiB1c2VTdXBwb3J0ZWQoY2FsbGJhY2spIHtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlTW91bnRlZCgpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlzTW91bnRlZC52YWx1ZTtcbiAgICByZXR1cm4gQm9vbGVhbihjYWxsYmFjaygpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIodGFyZ2V0LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdywgLi4ubXV0YXRpb25PcHRpb25zIH0gPSBvcHRpb25zO1xuICBsZXQgb2JzZXJ2ZXI7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIk11dGF0aW9uT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpO1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgb2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xuICBjb25zdCB0YXJnZXRzID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGNvbnN0IGl0ZW1zID0gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKS5tYXAodW5yZWZFbGVtZW50KS5maWx0ZXIobm90TnVsbGlzaCk7XG4gICAgcmV0dXJuIG5ldyBTZXQoaXRlbXMpO1xuICB9KTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gd2F0Y2goXG4gICAgKCkgPT4gdGFyZ2V0cy52YWx1ZSxcbiAgICAodGFyZ2V0czIpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB0YXJnZXRzMi5zaXplKSB7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgICAgICB0YXJnZXRzMi5mb3JFYWNoKChlbCkgPT4gb2JzZXJ2ZXIub2JzZXJ2ZShlbCwgbXV0YXRpb25PcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSwgZmx1c2g6IFwicG9zdFwiIH1cbiAgKTtcbiAgY29uc3QgdGFrZVJlY29yZHMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBzdG9wV2F0Y2goKTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RvcCxcbiAgICB0YWtlUmVjb3Jkc1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGRlZXAgPSB0cnVlLFxuICAgIHRyaWdnZXJPblJlbW92YWwgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZG9jdW1lbnQgPSAoX2EgPSBvcHRpb25zLmRvY3VtZW50KSAhPSBudWxsID8gX2EgOiB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudDtcbiAgY29uc3QgZ2V0RGVlcEFjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChkZWVwKSB7XG4gICAgICB3aGlsZSAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5zaGFkb3dSb290KVxuICAgICAgICBlbGVtZW50ID0gKF9hMiA9IGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHJlZigpO1xuICBjb25zdCB0cmlnZ2VyID0gKCkgPT4ge1xuICAgIGFjdGl2ZUVsZW1lbnQudmFsdWUgPSBnZXREZWVwQWN0aXZlRWxlbWVudCgpO1xuICB9O1xuICBpZiAod2luZG93KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmx1clwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICB0cmlnZ2VyKCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiZm9jdXNcIiwgdHJpZ2dlciwgdHJ1ZSk7XG4gIH1cbiAgaWYgKHRyaWdnZXJPblJlbW92YWwpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKGRvY3VtZW50LCAobXV0YXRpb25zKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZmlsdGVyKChtKSA9PiBtLnJlbW92ZWROb2Rlcy5sZW5ndGgpLm1hcCgobikgPT4gQXJyYXkuZnJvbShuLnJlbW92ZWROb2RlcykpLmZsYXQoKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlID09PSBhY3RpdmVFbGVtZW50LnZhbHVlKVxuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgfVxuICB0cmlnZ2VyKCk7XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB1c2VSYWZGbihmbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGZwc0xpbWl0ID0gdm9pZCAwLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzQWN0aXZlID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgaW50ZXJ2YWxMaW1pdCA9IGZwc0xpbWl0ID8gMWUzIC8gZnBzTGltaXQgOiBudWxsO1xuICBsZXQgcHJldmlvdXNGcmFtZVRpbWVzdGFtcCA9IDA7XG4gIGxldCByYWZJZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGxvb3AodGltZXN0YW1wKSB7XG4gICAgaWYgKCFpc0FjdGl2ZS52YWx1ZSB8fCAhd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcHJldmlvdXNGcmFtZVRpbWVzdGFtcClcbiAgICAgIHByZXZpb3VzRnJhbWVUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSBwcmV2aW91c0ZyYW1lVGltZXN0YW1wO1xuICAgIGlmIChpbnRlcnZhbExpbWl0ICYmIGRlbHRhIDwgaW50ZXJ2YWxMaW1pdCkge1xuICAgICAgcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmV2aW91c0ZyYW1lVGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIGZuKHsgZGVsdGEsIHRpbWVzdGFtcCB9KTtcbiAgICByYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmICghaXNBY3RpdmUudmFsdWUgJiYgd2luZG93KSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZXN0YW1wID0gMDtcbiAgICAgIHJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgICBpZiAocmFmSWQgIT0gbnVsbCAmJiB3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICByYWZJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgcmVzdW1lKCk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZTogcmVhZG9ubHkoaXNBY3RpdmUpLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VBbmltYXRlKHRhcmdldCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gIGxldCBjb25maWc7XG4gIGxldCBhbmltYXRlT3B0aW9ucztcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgY29uZmlnID0gb3B0aW9ucztcbiAgICBhbmltYXRlT3B0aW9ucyA9IG9iamVjdE9taXQob3B0aW9ucywgW1wid2luZG93XCIsIFwiaW1tZWRpYXRlXCIsIFwiY29tbWl0U3R5bGVzXCIsIFwicGVyc2lzdFwiLCBcIm9uUmVhZHlcIiwgXCJvbkVycm9yXCJdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSB7IGR1cmF0aW9uOiBvcHRpb25zIH07XG4gICAgYW5pbWF0ZU9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgY29tbWl0U3R5bGVzLFxuICAgIHBlcnNpc3QsXG4gICAgcGxheWJhY2tSYXRlOiBfcGxheWJhY2tSYXRlID0gMSxcbiAgICBvblJlYWR5LFxuICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBIVE1MRWxlbWVudCAmJiBcImFuaW1hdGVcIiBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuICBjb25zdCBhbmltYXRlID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCBzdG9yZSA9IHNoYWxsb3dSZWFjdGl2ZSh7XG4gICAgc3RhcnRUaW1lOiBudWxsLFxuICAgIGN1cnJlbnRUaW1lOiBudWxsLFxuICAgIHRpbWVsaW5lOiBudWxsLFxuICAgIHBsYXliYWNrUmF0ZTogX3BsYXliYWNrUmF0ZSxcbiAgICBwZW5kaW5nOiBmYWxzZSxcbiAgICBwbGF5U3RhdGU6IGltbWVkaWF0ZSA/IFwiaWRsZVwiIDogXCJwYXVzZWRcIixcbiAgICByZXBsYWNlU3RhdGU6IFwiYWN0aXZlXCJcbiAgfSk7XG4gIGNvbnN0IHBlbmRpbmcgPSBjb21wdXRlZCgoKSA9PiBzdG9yZS5wZW5kaW5nKTtcbiAgY29uc3QgcGxheVN0YXRlID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUucGxheVN0YXRlKTtcbiAgY29uc3QgcmVwbGFjZVN0YXRlID0gY29tcHV0ZWQoKCkgPT4gc3RvcmUucmVwbGFjZVN0YXRlKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzdG9yZS5zdGFydFRpbWU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHN0b3JlLnN0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpXG4gICAgICAgIGFuaW1hdGUudmFsdWUuc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRUaW1lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBzdG9yZS5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpIHtcbiAgICAgICAgYW5pbWF0ZS52YWx1ZS5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgICAgICBzeW5jUmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgdGltZWxpbmUgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHN0b3JlLnRpbWVsaW5lO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBzdG9yZS50aW1lbGluZSA9IHZhbHVlO1xuICAgICAgaWYgKGFuaW1hdGUudmFsdWUpXG4gICAgICAgIGFuaW1hdGUudmFsdWUudGltZWxpbmUgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwbGF5YmFja1JhdGUgPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHN0b3JlLnBsYXliYWNrUmF0ZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc3RvcmUucGxheWJhY2tSYXRlID0gdmFsdWU7XG4gICAgICBpZiAoYW5pbWF0ZS52YWx1ZSlcbiAgICAgICAgYW5pbWF0ZS52YWx1ZS5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwbGF5ID0gKCkgPT4ge1xuICAgIGlmIChhbmltYXRlLnZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhbmltYXRlLnZhbHVlLnBsYXkoKTtcbiAgICAgICAgc3luY1Jlc3VtZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzeW5jUGF1c2UoKTtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIChfYSA9IGFuaW1hdGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgICAgc3luY1BhdXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJldmVyc2UgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICFhbmltYXRlLnZhbHVlICYmIHVwZGF0ZSgpO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmV2ZXJzZSgpO1xuICAgICAgc3luY1Jlc3VtZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN5bmNQYXVzZSgpO1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGZpbmlzaCA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIChfYSA9IGFuaW1hdGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5pc2goKTtcbiAgICAgIHN5bmNQYXVzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhbmltYXRlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FuY2VsKCk7XG4gICAgICBzeW5jUGF1c2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfTtcbiAgd2F0Y2goKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCksIChlbCkgPT4ge1xuICAgIGVsICYmIHVwZGF0ZSgpO1xuICB9KTtcbiAgd2F0Y2goKCkgPT4ga2V5ZnJhbWVzLCAodmFsdWUpID0+IHtcbiAgICAhYW5pbWF0ZS52YWx1ZSAmJiB1cGRhdGUoKTtcbiAgICBpZiAoIXVucmVmRWxlbWVudCh0YXJnZXQpICYmIGFuaW1hdGUudmFsdWUpIHtcbiAgICAgIGFuaW1hdGUudmFsdWUuZWZmZWN0ID0gbmV3IEtleWZyYW1lRWZmZWN0KFxuICAgICAgICB1bnJlZkVsZW1lbnQodGFyZ2V0KSxcbiAgICAgICAgdG9WYWx1ZSh2YWx1ZSksXG4gICAgICAgIGFuaW1hdGVPcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgfSwgeyBkZWVwOiB0cnVlIH0pO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIG5leHRUaWNrKCgpID0+IHVwZGF0ZSh0cnVlKSk7XG4gIH0pO1xuICB0cnlPblNjb3BlRGlzcG9zZShjYW5jZWwpO1xuICBmdW5jdGlvbiB1cGRhdGUoaW5pdCkge1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSB8fCAhZWwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFhbmltYXRlLnZhbHVlKVxuICAgICAgYW5pbWF0ZS52YWx1ZSA9IGVsLmFuaW1hdGUodG9WYWx1ZShrZXlmcmFtZXMpLCBhbmltYXRlT3B0aW9ucyk7XG4gICAgaWYgKHBlcnNpc3QpXG4gICAgICBhbmltYXRlLnZhbHVlLnBlcnNpc3QoKTtcbiAgICBpZiAoX3BsYXliYWNrUmF0ZSAhPT0gMSlcbiAgICAgIGFuaW1hdGUudmFsdWUucGxheWJhY2tSYXRlID0gX3BsYXliYWNrUmF0ZTtcbiAgICBpZiAoaW5pdCAmJiAhaW1tZWRpYXRlKVxuICAgICAgYW5pbWF0ZS52YWx1ZS5wYXVzZSgpO1xuICAgIGVsc2VcbiAgICAgIHN5bmNSZXN1bWUoKTtcbiAgICBvblJlYWR5ID09IG51bGwgPyB2b2lkIDAgOiBvblJlYWR5KGFuaW1hdGUudmFsdWUpO1xuICB9XG4gIHVzZUV2ZW50TGlzdGVuZXIoYW5pbWF0ZSwgW1wiY2FuY2VsXCIsIFwiZmluaXNoXCIsIFwicmVtb3ZlXCJdLCBzeW5jUGF1c2UpO1xuICB1c2VFdmVudExpc3RlbmVyKGFuaW1hdGUsIFwiZmluaXNoXCIsICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGNvbW1pdFN0eWxlcylcbiAgICAgIChfYSA9IGFuaW1hdGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb21taXRTdHlsZXMoKTtcbiAgfSk7XG4gIGNvbnN0IHsgcmVzdW1lOiByZXN1bWVSZWYsIHBhdXNlOiBwYXVzZVJlZiB9ID0gdXNlUmFmRm4oKCkgPT4ge1xuICAgIGlmICghYW5pbWF0ZS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdG9yZS5wZW5kaW5nID0gYW5pbWF0ZS52YWx1ZS5wZW5kaW5nO1xuICAgIHN0b3JlLnBsYXlTdGF0ZSA9IGFuaW1hdGUudmFsdWUucGxheVN0YXRlO1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSA9IGFuaW1hdGUudmFsdWUucmVwbGFjZVN0YXRlO1xuICAgIHN0b3JlLnN0YXJ0VGltZSA9IGFuaW1hdGUudmFsdWUuc3RhcnRUaW1lO1xuICAgIHN0b3JlLmN1cnJlbnRUaW1lID0gYW5pbWF0ZS52YWx1ZS5jdXJyZW50VGltZTtcbiAgICBzdG9yZS50aW1lbGluZSA9IGFuaW1hdGUudmFsdWUudGltZWxpbmU7XG4gICAgc3RvcmUucGxheWJhY2tSYXRlID0gYW5pbWF0ZS52YWx1ZS5wbGF5YmFja1JhdGU7XG4gIH0sIHsgaW1tZWRpYXRlOiBmYWxzZSB9KTtcbiAgZnVuY3Rpb24gc3luY1Jlc3VtZSgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXN1bWVSZWYoKTtcbiAgfVxuICBmdW5jdGlvbiBzeW5jUGF1c2UoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHdpbmRvdylcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGF1c2VSZWYpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgYW5pbWF0ZSxcbiAgICAvLyBhY3Rpb25zXG4gICAgcGxheSxcbiAgICBwYXVzZSxcbiAgICByZXZlcnNlLFxuICAgIGZpbmlzaCxcbiAgICBjYW5jZWwsXG4gICAgLy8gc3RhdGVcbiAgICBwZW5kaW5nLFxuICAgIHBsYXlTdGF0ZSxcbiAgICByZXBsYWNlU3RhdGUsXG4gICAgc3RhcnRUaW1lLFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIHRpbWVsaW5lLFxuICAgIHBsYXliYWNrUmF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VBc3luY1F1ZXVlKHRhc2tzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcnJ1cHQgPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBub29wLFxuICAgIG9uRmluaXNoZWQgPSBub29wLFxuICAgIHNpZ25hbFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcHJvbWlzZVN0YXRlID0ge1xuICAgIGFib3J0ZWQ6IFwiYWJvcnRlZFwiLFxuICAgIGZ1bGZpbGxlZDogXCJmdWxmaWxsZWRcIixcbiAgICBwZW5kaW5nOiBcInBlbmRpbmdcIixcbiAgICByZWplY3RlZDogXCJyZWplY3RlZFwiXG4gIH07XG4gIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBBcnJheS5mcm9tKEFycmF5LmZyb20oeyBsZW5ndGg6IHRhc2tzLmxlbmd0aCB9KSwgKCkgPT4gKHsgc3RhdGU6IHByb21pc2VTdGF0ZS5wZW5kaW5nLCBkYXRhOiBudWxsIH0pKTtcbiAgY29uc3QgcmVzdWx0ID0gcmVhY3RpdmUoaW5pdGlhbFJlc3VsdCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gcmVmKC0xKTtcbiAgaWYgKCF0YXNrcyB8fCB0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICBvbkZpbmlzaGVkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgcmVzdWx0XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVSZXN1bHQoc3RhdGUsIHJlcykge1xuICAgIGFjdGl2ZUluZGV4LnZhbHVlKys7XG4gICAgcmVzdWx0W2FjdGl2ZUluZGV4LnZhbHVlXS5kYXRhID0gcmVzO1xuICAgIHJlc3VsdFthY3RpdmVJbmRleC52YWx1ZV0uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuICB0YXNrcy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICByZXR1cm4gcHJldi50aGVuKChwcmV2UmVzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB1cGRhdGVSZXN1bHQocHJvbWlzZVN0YXRlLmFib3J0ZWQsIG5ldyBFcnJvcihcImFib3J0ZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKChfYSA9IHJlc3VsdFthY3RpdmVJbmRleC52YWx1ZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgPT09IHByb21pc2VTdGF0ZS5yZWplY3RlZCAmJiBpbnRlcnJ1cHQpIHtcbiAgICAgICAgb25GaW5pc2hlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkb25lID0gY3VycihwcmV2UmVzKS50aGVuKChjdXJyZW50UmVzKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJlc3VsdChwcm9taXNlU3RhdGUuZnVsZmlsbGVkLCBjdXJyZW50UmVzKTtcbiAgICAgICAgYWN0aXZlSW5kZXgudmFsdWUgPT09IHRhc2tzLmxlbmd0aCAtIDEgJiYgb25GaW5pc2hlZCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaWduYWwpXG4gICAgICAgIHJldHVybiBkb25lO1xuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZG9uZSwgd2hlbkFib3J0ZWQoc2lnbmFsKV0pO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB1cGRhdGVSZXN1bHQocHJvbWlzZVN0YXRlLmFib3J0ZWQsIGUpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVJlc3VsdChwcm9taXNlU3RhdGUucmVqZWN0ZWQsIGUpO1xuICAgICAgb25FcnJvcigpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0sIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICByZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHdoZW5BYm9ydGVkKHNpZ25hbCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiYWJvcnRlZFwiKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gcmVqZWN0KGVycm9yKSwgeyBvbmNlOiB0cnVlIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQXN5bmNTdGF0ZShwcm9taXNlLCBpbml0aWFsU3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgZGVsYXkgPSAwLFxuICAgIG9uRXJyb3IgPSBub29wLFxuICAgIG9uU3VjY2VzcyA9IG5vb3AsXG4gICAgcmVzZXRPbkV4ZWN1dGUgPSB0cnVlLFxuICAgIHNoYWxsb3cgPSB0cnVlLFxuICAgIHRocm93RXJyb3JcbiAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgY29uc3Qgc3RhdGUgPSBzaGFsbG93ID8gc2hhbGxvd1JlZihpbml0aWFsU3RhdGUpIDogcmVmKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IGlzUmVhZHkgPSByZWYoZmFsc2UpO1xuICBjb25zdCBpc0xvYWRpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZShkZWxheTIgPSAwLCAuLi5hcmdzKSB7XG4gICAgaWYgKHJlc2V0T25FeGVjdXRlKVxuICAgICAgc3RhdGUudmFsdWUgPSBpbml0aWFsU3RhdGU7XG4gICAgZXJyb3IudmFsdWUgPSB2b2lkIDA7XG4gICAgaXNSZWFkeS52YWx1ZSA9IGZhbHNlO1xuICAgIGlzTG9hZGluZy52YWx1ZSA9IHRydWU7XG4gICAgaWYgKGRlbGF5MiA+IDApXG4gICAgICBhd2FpdCBwcm9taXNlVGltZW91dChkZWxheTIpO1xuICAgIGNvbnN0IF9wcm9taXNlID0gdHlwZW9mIHByb21pc2UgPT09IFwiZnVuY3Rpb25cIiA/IHByb21pc2UoLi4uYXJncykgOiBwcm9taXNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgX3Byb21pc2U7XG4gICAgICBzdGF0ZS52YWx1ZSA9IGRhdGE7XG4gICAgICBpc1JlYWR5LnZhbHVlID0gdHJ1ZTtcbiAgICAgIG9uU3VjY2VzcyhkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvci52YWx1ZSA9IGU7XG4gICAgICBvbkVycm9yKGUpO1xuICAgICAgaWYgKHRocm93RXJyb3IpXG4gICAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzTG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUudmFsdWU7XG4gIH1cbiAgaWYgKGltbWVkaWF0ZSlcbiAgICBleGVjdXRlKGRlbGF5KTtcbiAgY29uc3Qgc2hlbGwgPSB7XG4gICAgc3RhdGUsXG4gICAgaXNSZWFkeSxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgZXhlY3V0ZVxuICB9O1xuICBmdW5jdGlvbiB3YWl0VW50aWxJc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdW50aWwoaXNMb2FkaW5nKS50b0JlKGZhbHNlKS50aGVuKCgpID0+IHJlc29sdmUoc2hlbGwpKS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2hlbGwsXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHdhaXRVbnRpbElzTG9hZGVkKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYXJyYXk6ICh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KSxcbiAgb2JqZWN0OiAodikgPT4gSlNPTi5zdHJpbmdpZnkodiksXG4gIHNldDogKHYpID0+IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odikpLFxuICBtYXA6ICh2KSA9PiBKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXModikpLFxuICBudWxsOiAoKSA9PiBcIlwiXG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFNlcmlhbGl6YXRpb24odGFyZ2V0KSB7XG4gIGlmICghdGFyZ2V0KVxuICAgIHJldHVybiBkZWZhdWx0cy5udWxsO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwKVxuICAgIHJldHVybiBkZWZhdWx0cy5tYXA7XG4gIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldClcbiAgICByZXR1cm4gZGVmYXVsdHMuc2V0O1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpXG4gICAgcmV0dXJuIGRlZmF1bHRzLmFycmF5O1xuICBlbHNlXG4gICAgcmV0dXJuIGRlZmF1bHRzLm9iamVjdDtcbn1cblxuZnVuY3Rpb24gdXNlQmFzZTY0KHRhcmdldCwgb3B0aW9ucykge1xuICBjb25zdCBiYXNlNjQgPSByZWYoXCJcIik7XG4gIGNvbnN0IHByb21pc2UgPSByZWYoKTtcbiAgZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICBpZiAoIWlzQ2xpZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHByb21pc2UudmFsdWUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBfdGFyZ2V0ID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoX3RhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgcmVzb2x2ZShcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlc29sdmUoYmxvYlRvQmFzZTY0KG5ldyBCbG9iKFtfdGFyZ2V0XSwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KSkpO1xuICAgICAgICB9IGVsc2UgaWYgKF90YXJnZXQgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgcmVzb2x2ZShibG9iVG9CYXNlNjQoX3RhcmdldCkpO1xuICAgICAgICB9IGVsc2UgaWYgKF90YXJnZXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJlc29sdmUod2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShfdGFyZ2V0KSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGFyZ2V0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICByZXNvbHZlKF90YXJnZXQudG9EYXRhVVJMKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5xdWFsaXR5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RhcmdldCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBpbWcgPSBfdGFyZ2V0LmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICBpbWdMb2FkZWQoaW1nKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJlc29sdmUoY2FudmFzLnRvRGF0YVVSTChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVhbGl0eSkpO1xuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90YXJnZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBjb25zdCBfc2VyaWFsaXplRm4gPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZXJpYWxpemVyKSB8fCBnZXREZWZhdWx0U2VyaWFsaXphdGlvbihfdGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gX3NlcmlhbGl6ZUZuKF90YXJnZXQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGJsb2JUb0Jhc2U2NChuZXcgQmxvYihbc2VyaWFsaXplZF0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidGFyZ2V0IGlzIHVuc3VwcG9ydGVkIHR5cGVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwcm9taXNlLnZhbHVlLnRoZW4oKHJlcykgPT4gYmFzZTY0LnZhbHVlID0gcmVzKTtcbiAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgfVxuICBpZiAoaXNSZWYodGFyZ2V0KSB8fCB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgd2F0Y2godGFyZ2V0LCBleGVjdXRlLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgZWxzZVxuICAgIGV4ZWN1dGUoKTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlNjQsXG4gICAgcHJvbWlzZSxcbiAgICBleGVjdXRlXG4gIH07XG59XG5mdW5jdGlvbiBpbWdMb2FkZWQoaW1nKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFpbWcuY29tcGxldGUpIHtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBibG9iVG9CYXNlNjQoYmxvYikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgIH07XG4gICAgZnIub25lcnJvciA9IHJlamVjdDtcbiAgICBmci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQmF0dGVyeShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yIH0gPSBvcHRpb25zO1xuICBjb25zdCBldmVudHMgPSBbXCJjaGFyZ2luZ2NoYW5nZVwiLCBcImNoYXJnaW5ndGltZWNoYW5nZVwiLCBcImRpc2NoYXJnaW5ndGltZWNoYW5nZVwiLCBcImxldmVsY2hhbmdlXCJdO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZXRCYXR0ZXJ5XCIgaW4gbmF2aWdhdG9yICYmIHR5cGVvZiBuYXZpZ2F0b3IuZ2V0QmF0dGVyeSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgY29uc3QgY2hhcmdpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBjaGFyZ2luZ1RpbWUgPSByZWYoMCk7XG4gIGNvbnN0IGRpc2NoYXJnaW5nVGltZSA9IHJlZigwKTtcbiAgY29uc3QgbGV2ZWwgPSByZWYoMSk7XG4gIGxldCBiYXR0ZXJ5O1xuICBmdW5jdGlvbiB1cGRhdGVCYXR0ZXJ5SW5mbygpIHtcbiAgICBjaGFyZ2luZy52YWx1ZSA9IHRoaXMuY2hhcmdpbmc7XG4gICAgY2hhcmdpbmdUaW1lLnZhbHVlID0gdGhpcy5jaGFyZ2luZ1RpbWUgfHwgMDtcbiAgICBkaXNjaGFyZ2luZ1RpbWUudmFsdWUgPSB0aGlzLmRpc2NoYXJnaW5nVGltZSB8fCAwO1xuICAgIGxldmVsLnZhbHVlID0gdGhpcy5sZXZlbDtcbiAgfVxuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0QmF0dGVyeSgpLnRoZW4oKF9iYXR0ZXJ5KSA9PiB7XG4gICAgICBiYXR0ZXJ5ID0gX2JhdHRlcnk7XG4gICAgICB1cGRhdGVCYXR0ZXJ5SW5mby5jYWxsKGJhdHRlcnkpO1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihiYXR0ZXJ5LCBldmVudHMsIHVwZGF0ZUJhdHRlcnlJbmZvLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjaGFyZ2luZyxcbiAgICBjaGFyZ2luZ1RpbWUsXG4gICAgZGlzY2hhcmdpbmdUaW1lLFxuICAgIGxldmVsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUJsdWV0b290aChvcHRpb25zKSB7XG4gIGxldCB7XG4gICAgYWNjZXB0QWxsRGV2aWNlcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB7XG4gICAgZmlsdGVycyA9IHZvaWQgMCxcbiAgICBvcHRpb25hbFNlcnZpY2VzID0gdm9pZCAwLFxuICAgIG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3JcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImJsdWV0b290aFwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGRldmljZSA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3QgZXJyb3IgPSBzaGFsbG93UmVmKG51bGwpO1xuICB3YXRjaChkZXZpY2UsICgpID0+IHtcbiAgICBjb25uZWN0VG9CbHVldG9vdGhHQVRUU2VydmVyKCk7XG4gIH0pO1xuICBhc3luYyBmdW5jdGlvbiByZXF1ZXN0RGV2aWNlKCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoID4gMClcbiAgICAgIGFjY2VwdEFsbERldmljZXMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZGV2aWNlLnZhbHVlID0gYXdhaXQgKG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLmJsdWV0b290aC5yZXF1ZXN0RGV2aWNlKHtcbiAgICAgICAgYWNjZXB0QWxsRGV2aWNlcyxcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgb3B0aW9uYWxTZXJ2aWNlc1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlcnZlciA9IHJlZigpO1xuICBjb25zdCBpc0Nvbm5lY3RlZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzZXJ2ZXIudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb25uZWN0ZWQpIHx8IGZhbHNlO1xuICB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdFRvQmx1ZXRvb3RoR0FUVFNlcnZlcigpIHtcbiAgICBlcnJvci52YWx1ZSA9IG51bGw7XG4gICAgaWYgKGRldmljZS52YWx1ZSAmJiBkZXZpY2UudmFsdWUuZ2F0dCkge1xuICAgICAgZGV2aWNlLnZhbHVlLmFkZEV2ZW50TGlzdGVuZXIoXCJnYXR0c2VydmVyZGlzY29ubmVjdGVkXCIsICgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VydmVyLnZhbHVlID0gYXdhaXQgZGV2aWNlLnZhbHVlLmdhdHQuY29ubmVjdCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cnlPbk1vdW50ZWQoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZGV2aWNlLnZhbHVlKVxuICAgICAgKF9hID0gZGV2aWNlLnZhbHVlLmdhdHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb25uZWN0KCk7XG4gIH0pO1xuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChkZXZpY2UudmFsdWUpXG4gICAgICAoX2EgPSBkZXZpY2UudmFsdWUuZ2F0dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNDb25uZWN0ZWQsXG4gICAgLy8gRGV2aWNlOlxuICAgIGRldmljZSxcbiAgICByZXF1ZXN0RGV2aWNlLFxuICAgIC8vIFNlcnZlcjpcbiAgICBzZXJ2ZXIsXG4gICAgLy8gRXJyb3JzOlxuICAgIGVycm9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1lZGlhUXVlcnkocXVlcnksIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIm1hdGNoTWVkaWFcIiBpbiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5tYXRjaE1lZGlhID09PSBcImZ1bmN0aW9uXCIpO1xuICBsZXQgbWVkaWFRdWVyeTtcbiAgY29uc3QgbWF0Y2hlcyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBtYXRjaGVzLnZhbHVlID0gZXZlbnQubWF0Y2hlcztcbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBpZiAoIW1lZGlhUXVlcnkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIG1lZGlhUXVlcnkpXG4gICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlcik7XG4gICAgZWxzZVxuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVMaXN0ZW5lcihoYW5kbGVyKTtcbiAgfTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICAgIG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYSh0b1ZhbHVlKHF1ZXJ5KSk7XG4gICAgaWYgKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIG1lZGlhUXVlcnkpXG4gICAgICBtZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlcik7XG4gICAgZWxzZVxuICAgICAgbWVkaWFRdWVyeS5hZGRMaXN0ZW5lcihoYW5kbGVyKTtcbiAgICBtYXRjaGVzLnZhbHVlID0gbWVkaWFRdWVyeS5tYXRjaGVzO1xuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIHN0b3BXYXRjaCgpO1xuICAgIGNsZWFudXAoKTtcbiAgICBtZWRpYVF1ZXJ5ID0gdm9pZCAwO1xuICB9KTtcbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmNvbnN0IGJyZWFrcG9pbnRzVGFpbHdpbmQgPSB7XG4gIFwic21cIjogNjQwLFxuICBcIm1kXCI6IDc2OCxcbiAgXCJsZ1wiOiAxMDI0LFxuICBcInhsXCI6IDEyODAsXG4gIFwiMnhsXCI6IDE1MzZcbn07XG5jb25zdCBicmVha3BvaW50c0Jvb3RzdHJhcFY1ID0ge1xuICB4czogMCxcbiAgc206IDU3NixcbiAgbWQ6IDc2OCxcbiAgbGc6IDk5MixcbiAgeGw6IDEyMDAsXG4gIHh4bDogMTQwMFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzVnVldGlmeVYyID0ge1xuICB4czogMCxcbiAgc206IDYwMCxcbiAgbWQ6IDk2MCxcbiAgbGc6IDEyNjQsXG4gIHhsOiAxOTA0XG59O1xuY29uc3QgYnJlYWtwb2ludHNWdWV0aWZ5VjMgPSB7XG4gIHhzOiAwLFxuICBzbTogNjAwLFxuICBtZDogOTYwLFxuICBsZzogMTI4MCxcbiAgeGw6IDE5MjAsXG4gIHh4bDogMjU2MFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzVnVldGlmeSA9IGJyZWFrcG9pbnRzVnVldGlmeVYyO1xuY29uc3QgYnJlYWtwb2ludHNBbnREZXNpZ24gPSB7XG4gIHhzOiA0ODAsXG4gIHNtOiA1NzYsXG4gIG1kOiA3NjgsXG4gIGxnOiA5OTIsXG4gIHhsOiAxMjAwLFxuICB4eGw6IDE2MDBcbn07XG5jb25zdCBicmVha3BvaW50c1F1YXNhciA9IHtcbiAgeHM6IDAsXG4gIHNtOiA2MDAsXG4gIG1kOiAxMDI0LFxuICBsZzogMTQ0MCxcbiAgeGw6IDE5MjBcbn07XG5jb25zdCBicmVha3BvaW50c1NlbWF0aWMgPSB7XG4gIG1vYmlsZVM6IDMyMCxcbiAgbW9iaWxlTTogMzc1LFxuICBtb2JpbGVMOiA0MjUsXG4gIHRhYmxldDogNzY4LFxuICBsYXB0b3A6IDEwMjQsXG4gIGxhcHRvcEw6IDE0NDAsXG4gIGRlc2t0b3A0SzogMjU2MFxufTtcbmNvbnN0IGJyZWFrcG9pbnRzTWFzdGVyQ3NzID0ge1xuICBcIjN4c1wiOiAzNjAsXG4gIFwiMnhzXCI6IDQ4MCxcbiAgXCJ4c1wiOiA2MDAsXG4gIFwic21cIjogNzY4LFxuICBcIm1kXCI6IDEwMjQsXG4gIFwibGdcIjogMTI4MCxcbiAgXCJ4bFwiOiAxNDQwLFxuICBcIjJ4bFwiOiAxNjAwLFxuICBcIjN4bFwiOiAxOTIwLFxuICBcIjR4bFwiOiAyNTYwXG59O1xuY29uc3QgYnJlYWtwb2ludHNQcmltZUZsZXggPSB7XG4gIHNtOiA1NzYsXG4gIG1kOiA3NjgsXG4gIGxnOiA5OTIsXG4gIHhsOiAxMjAwXG59O1xuXG5mdW5jdGlvbiB1c2VCcmVha3BvaW50cyhicmVha3BvaW50cywgb3B0aW9ucyA9IHt9KSB7XG4gIGZ1bmN0aW9uIGdldFZhbHVlKGssIGRlbHRhKSB7XG4gICAgbGV0IHYgPSB0b1ZhbHVlKGJyZWFrcG9pbnRzW3RvVmFsdWUoayldKTtcbiAgICBpZiAoZGVsdGEgIT0gbnVsbClcbiAgICAgIHYgPSBpbmNyZWFzZVdpdGhVbml0KHYsIGRlbHRhKTtcbiAgICBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpXG4gICAgICB2ID0gYCR7dn1weGA7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBzdHJhdGVneSA9IFwibWluLXdpZHRoXCIgfSA9IG9wdGlvbnM7XG4gIGZ1bmN0aW9uIG1hdGNoKHF1ZXJ5KSB7XG4gICAgaWYgKCF3aW5kb3cpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICB9XG4gIGNvbnN0IGdyZWF0ZXJPckVxdWFsID0gKGspID0+IHtcbiAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShrKX0pYCwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IHNtYWxsZXJPckVxdWFsID0gKGspID0+IHtcbiAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1heC13aWR0aDogJHtnZXRWYWx1ZShrKX0pYCwgb3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IHNob3J0Y3V0TWV0aG9kcyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5yZWR1Y2UoKHNob3J0Y3V0cywgaykgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaG9ydGN1dHMsIGssIHtcbiAgICAgIGdldDogKCkgPT4gc3RyYXRlZ3kgPT09IFwibWluLXdpZHRoXCIgPyBncmVhdGVyT3JFcXVhbChrKSA6IHNtYWxsZXJPckVxdWFsKGspLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBzaG9ydGN1dHM7XG4gIH0sIHt9KTtcbiAgZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICBjb25zdCBwb2ludHMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykubWFwKChpKSA9PiBbaSwgZ3JlYXRlck9yRXF1YWwoaSldKTtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gcG9pbnRzLmZpbHRlcigoWywgdl0pID0+IHYudmFsdWUpLm1hcCgoW2tdKSA9PiBrKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2hvcnRjdXRNZXRob2RzLCB7XG4gICAgZ3JlYXRlck9yRXF1YWwsXG4gICAgc21hbGxlck9yRXF1YWwsXG4gICAgZ3JlYXRlcihrKSB7XG4gICAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShrLCAwLjEpfSlgLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHNtYWxsZXIoaykge1xuICAgICAgcmV0dXJuIHVzZU1lZGlhUXVlcnkoKCkgPT4gYChtYXgtd2lkdGg6ICR7Z2V0VmFsdWUoaywgLTAuMSl9KWAsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYmV0d2VlbihhLCBiKSB7XG4gICAgICByZXR1cm4gdXNlTWVkaWFRdWVyeSgoKSA9PiBgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShhKX0pIGFuZCAobWF4LXdpZHRoOiAke2dldFZhbHVlKGIsIC0wLjEpfSlgLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGlzR3JlYXRlcihrKSB7XG4gICAgICByZXR1cm4gbWF0Y2goYChtaW4td2lkdGg6ICR7Z2V0VmFsdWUoaywgMC4xKX0pYCk7XG4gICAgfSxcbiAgICBpc0dyZWF0ZXJPckVxdWFsKGspIHtcbiAgICAgIHJldHVybiBtYXRjaChgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShrKX0pYCk7XG4gICAgfSxcbiAgICBpc1NtYWxsZXIoaykge1xuICAgICAgcmV0dXJuIG1hdGNoKGAobWF4LXdpZHRoOiAke2dldFZhbHVlKGssIC0wLjEpfSlgKTtcbiAgICB9LFxuICAgIGlzU21hbGxlck9yRXF1YWwoaykge1xuICAgICAgcmV0dXJuIG1hdGNoKGAobWF4LXdpZHRoOiAke2dldFZhbHVlKGspfSlgKTtcbiAgICB9LFxuICAgIGlzSW5CZXR3ZWVuKGEsIGIpIHtcbiAgICAgIHJldHVybiBtYXRjaChgKG1pbi13aWR0aDogJHtnZXRWYWx1ZShhKX0pIGFuZCAobWF4LXdpZHRoOiAke2dldFZhbHVlKGIsIC0wLjEpfSlgKTtcbiAgICB9LFxuICAgIGN1cnJlbnQsXG4gICAgYWN0aXZlKCkge1xuICAgICAgY29uc3QgYnBzID0gY3VycmVudCgpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IGJwcy52YWx1ZS5sZW5ndGggPT09IDAgPyBcIlwiIDogYnBzLnZhbHVlLmF0KC0xKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlQnJvYWRjYXN0Q2hhbm5lbChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIkJyb2FkY2FzdENoYW5uZWxcIiBpbiB3aW5kb3cpO1xuICBjb25zdCBpc0Nsb3NlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGNoYW5uZWwgPSByZWYoKTtcbiAgY29uc3QgZGF0YSA9IHJlZigpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IHBvc3QgPSAoZGF0YTIpID0+IHtcbiAgICBpZiAoY2hhbm5lbC52YWx1ZSlcbiAgICAgIGNoYW5uZWwudmFsdWUucG9zdE1lc3NhZ2UoZGF0YTIpO1xuICB9O1xuICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICBpZiAoY2hhbm5lbC52YWx1ZSlcbiAgICAgIGNoYW5uZWwudmFsdWUuY2xvc2UoKTtcbiAgICBpc0Nsb3NlZC52YWx1ZSA9IHRydWU7XG4gIH07XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgICBlcnJvci52YWx1ZSA9IG51bGw7XG4gICAgICBjaGFubmVsLnZhbHVlID0gbmV3IEJyb2FkY2FzdENoYW5uZWwobmFtZSk7XG4gICAgICBjaGFubmVsLnZhbHVlLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICBjaGFubmVsLnZhbHVlLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgZXJyb3IudmFsdWUgPSBlO1xuICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgY2hhbm5lbC52YWx1ZS5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICBpc0Nsb3NlZC52YWx1ZSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgY2xvc2UoKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgY2hhbm5lbCxcbiAgICBkYXRhLFxuICAgIHBvc3QsXG4gICAgY2xvc2UsXG4gICAgZXJyb3IsXG4gICAgaXNDbG9zZWRcbiAgfTtcbn1cblxuY29uc3QgV1JJVEFCTEVfUFJPUEVSVElFUyA9IFtcbiAgXCJoYXNoXCIsXG4gIFwiaG9zdFwiLFxuICBcImhvc3RuYW1lXCIsXG4gIFwiaHJlZlwiLFxuICBcInBhdGhuYW1lXCIsXG4gIFwicG9ydFwiLFxuICBcInByb3RvY29sXCIsXG4gIFwic2VhcmNoXCJcbl07XG5mdW5jdGlvbiB1c2VCcm93c2VyTG9jYXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBXUklUQUJMRV9QUk9QRVJUSUVTLm1hcCgoa2V5KSA9PiBba2V5LCByZWYoKV0pXG4gICk7XG4gIGZvciAoY29uc3QgW2tleSwgcmVmMl0gb2Ygb2JqZWN0RW50cmllcyhyZWZzKSkge1xuICAgIHdhdGNoKHJlZjIsICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCEod2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pIHx8IHdpbmRvdy5sb2NhdGlvbltrZXldID09PSB2YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgd2luZG93LmxvY2F0aW9uW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBidWlsZFN0YXRlID0gKHRyaWdnZXIpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzdGF0ZTogc3RhdGUyLCBsZW5ndGggfSA9ICh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5oaXN0b3J5KSB8fCB7fTtcbiAgICBjb25zdCB7IG9yaWdpbiB9ID0gKHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBXUklUQUJMRV9QUk9QRVJUSUVTKVxuICAgICAgcmVmc1trZXldLnZhbHVlID0gKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYVtrZXldO1xuICAgIHJldHVybiByZWFjdGl2ZSh7XG4gICAgICB0cmlnZ2VyLFxuICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9yaWdpbixcbiAgICAgIC4uLnJlZnNcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3RhdGUgPSByZWYoYnVpbGRTdGF0ZShcImxvYWRcIikpO1xuICBpZiAod2luZG93KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwicG9wc3RhdGVcIiwgKCkgPT4gc3RhdGUudmFsdWUgPSBidWlsZFN0YXRlKFwicG9wc3RhdGVcIiksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsICgpID0+IHN0YXRlLnZhbHVlID0gYnVpbGRTdGF0ZShcImhhc2hjaGFuZ2VcIiksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVzZUNhY2hlZChyZWZWYWx1ZSwgY29tcGFyYXRvciA9IChhLCBiKSA9PiBhID09PSBiLCB3YXRjaE9wdGlvbnMpIHtcbiAgY29uc3QgY2FjaGVkVmFsdWUgPSByZWYocmVmVmFsdWUudmFsdWUpO1xuICB3YXRjaCgoKSA9PiByZWZWYWx1ZS52YWx1ZSwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFjb21wYXJhdG9yKHZhbHVlLCBjYWNoZWRWYWx1ZS52YWx1ZSkpXG4gICAgICBjYWNoZWRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICB9LCB3YXRjaE9wdGlvbnMpO1xuICByZXR1cm4gY2FjaGVkVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVBlcm1pc3Npb24ocGVybWlzc2lvbkRlc2MsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHMgPSBmYWxzZSxcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJwZXJtaXNzaW9uc1wiIGluIG5hdmlnYXRvcik7XG4gIGxldCBwZXJtaXNzaW9uU3RhdHVzO1xuICBjb25zdCBkZXNjID0gdHlwZW9mIHBlcm1pc3Npb25EZXNjID09PSBcInN0cmluZ1wiID8geyBuYW1lOiBwZXJtaXNzaW9uRGVzYyB9IDogcGVybWlzc2lvbkRlc2M7XG4gIGNvbnN0IHN0YXRlID0gcmVmKCk7XG4gIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChwZXJtaXNzaW9uU3RhdHVzKVxuICAgICAgc3RhdGUudmFsdWUgPSBwZXJtaXNzaW9uU3RhdHVzLnN0YXRlO1xuICB9O1xuICBjb25zdCBxdWVyeSA9IGNyZWF0ZVNpbmdsZXRvblByb21pc2UoYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwZXJtaXNzaW9uU3RhdHVzID0gYXdhaXQgbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KGRlc2MpO1xuICAgICAgICB1c2VFdmVudExpc3RlbmVyKHBlcm1pc3Npb25TdGF0dXMsIFwiY2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3RhdGUudmFsdWUgPSBcInByb21wdFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGVybWlzc2lvblN0YXR1cztcbiAgfSk7XG4gIHF1ZXJ5KCk7XG4gIGlmIChjb250cm9scykge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZSxcbiAgICAgIGlzU3VwcG9ydGVkLFxuICAgICAgcXVlcnlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDbGlwYm9hcmQob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIHJlYWQgPSBmYWxzZSxcbiAgICBzb3VyY2UsXG4gICAgY29waWVkRHVyaW5nID0gMTUwMCxcbiAgICBsZWdhY3kgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwiY2xpcGJvYXJkXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgcGVybWlzc2lvblJlYWQgPSB1c2VQZXJtaXNzaW9uKFwiY2xpcGJvYXJkLXJlYWRcIik7XG4gIGNvbnN0IHBlcm1pc3Npb25Xcml0ZSA9IHVzZVBlcm1pc3Npb24oXCJjbGlwYm9hcmQtd3JpdGVcIik7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gY29tcHV0ZWQoKCkgPT4gaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQudmFsdWUgfHwgbGVnYWN5KTtcbiAgY29uc3QgdGV4dCA9IHJlZihcIlwiKTtcbiAgY29uc3QgY29waWVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgdGltZW91dCA9IHVzZVRpbWVvdXRGbigoKSA9PiBjb3BpZWQudmFsdWUgPSBmYWxzZSwgY29waWVkRHVyaW5nKTtcbiAgZnVuY3Rpb24gdXBkYXRlVGV4dCgpIHtcbiAgICBpZiAoaXNDbGlwYm9hcmRBcGlTdXBwb3J0ZWQudmFsdWUgJiYgaXNBbGxvd2VkKHBlcm1pc3Npb25SZWFkLnZhbHVlKSkge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgIHRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0LnZhbHVlID0gbGVnYWN5UmVhZCgpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgcmVhZClcbiAgICB1c2VFdmVudExpc3RlbmVyKFtcImNvcHlcIiwgXCJjdXRcIl0sIHVwZGF0ZVRleHQpO1xuICBhc3luYyBmdW5jdGlvbiBjb3B5KHZhbHVlID0gdG9WYWx1ZShzb3VyY2UpKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChpc0NsaXBib2FyZEFwaVN1cHBvcnRlZC52YWx1ZSAmJiBpc0FsbG93ZWQocGVybWlzc2lvbldyaXRlLnZhbHVlKSlcbiAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodmFsdWUpO1xuICAgICAgZWxzZVxuICAgICAgICBsZWdhY3lDb3B5KHZhbHVlKTtcbiAgICAgIHRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGNvcGllZC52YWx1ZSA9IHRydWU7XG4gICAgICB0aW1lb3V0LnN0YXJ0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxlZ2FjeUNvcHkodmFsdWUpIHtcbiAgICBjb25zdCB0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICB0YS52YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiXCI7XG4gICAgdGEuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgdGEuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGEpO1xuICAgIHRhLnNlbGVjdCgpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKTtcbiAgICB0YS5yZW1vdmUoKTtcbiAgfVxuICBmdW5jdGlvbiBsZWdhY3lSZWFkKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChkb2N1bWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpKSAhPSBudWxsID8gX2MgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxsb3dlZChzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID09PSBcImdyYW50ZWRcIiB8fCBzdGF0dXMgPT09IFwicHJvbXB0XCI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICB0ZXh0LFxuICAgIGNvcGllZCxcbiAgICBjb3B5XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUNsaXBib2FyZEl0ZW1zKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICByZWFkID0gZmFsc2UsXG4gICAgc291cmNlLFxuICAgIGNvcGllZER1cmluZyA9IDE1MDBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBcImNsaXBib2FyZFwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGNvbnRlbnQgPSByZWYoW10pO1xuICBjb25zdCBjb3BpZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0ID0gdXNlVGltZW91dEZuKCgpID0+IGNvcGllZC52YWx1ZSA9IGZhbHNlLCBjb3BpZWREdXJpbmcpO1xuICBmdW5jdGlvbiB1cGRhdGVDb250ZW50KCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkKCkudGhlbigoaXRlbXMpID0+IHtcbiAgICAgICAgY29udGVudC52YWx1ZSA9IGl0ZW1zO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiByZWFkKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoW1wiY29weVwiLCBcImN1dFwiXSwgdXBkYXRlQ29udGVudCk7XG4gIGFzeW5jIGZ1bmN0aW9uIGNvcHkodmFsdWUgPSB0b1ZhbHVlKHNvdXJjZSkpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZSh2YWx1ZSk7XG4gICAgICBjb250ZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICBjb3BpZWQudmFsdWUgPSB0cnVlO1xuICAgICAgdGltZW91dC5zdGFydCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGNvbnRlbnQsXG4gICAgY29waWVkLFxuICAgIGNvcHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xvbmVGbkpTT04oc291cmNlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZSkpO1xufVxuZnVuY3Rpb24gdXNlQ2xvbmVkKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGNsb25lZCA9IHJlZih7fSk7XG4gIGNvbnN0IHtcbiAgICBtYW51YWwsXG4gICAgY2xvbmUgPSBjbG9uZUZuSlNPTixcbiAgICAvLyB3YXRjaCBvcHRpb25zXG4gICAgZGVlcCA9IHRydWUsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgZnVuY3Rpb24gc3luYygpIHtcbiAgICBjbG9uZWQudmFsdWUgPSBjbG9uZSh0b1ZhbHVlKHNvdXJjZSkpO1xuICB9XG4gIGlmICghbWFudWFsICYmIChpc1JlZihzb3VyY2UpIHx8IHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB3YXRjaChzb3VyY2UsIHN5bmMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBkZWVwLFxuICAgICAgaW1tZWRpYXRlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3luYygpO1xuICB9XG4gIHJldHVybiB7IGNsb25lZCwgc3luYyB9O1xufVxuXG5jb25zdCBfZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB7fTtcbmNvbnN0IGdsb2JhbEtleSA9IFwiX192dWV1c2Vfc3NyX2hhbmRsZXJzX19cIjtcbmNvbnN0IGhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIGdldEhhbmRsZXJzKCk7XG5mdW5jdGlvbiBnZXRIYW5kbGVycygpIHtcbiAgaWYgKCEoZ2xvYmFsS2V5IGluIF9nbG9iYWwpKVxuICAgIF9nbG9iYWxbZ2xvYmFsS2V5XSA9IF9nbG9iYWxbZ2xvYmFsS2V5XSB8fCB7fTtcbiAgcmV0dXJuIF9nbG9iYWxbZ2xvYmFsS2V5XTtcbn1cbmZ1bmN0aW9uIGdldFNTUkhhbmRsZXIoa2V5LCBmYWxsYmFjaykge1xuICByZXR1cm4gaGFuZGxlcnNba2V5XSB8fCBmYWxsYmFjaztcbn1cbmZ1bmN0aW9uIHNldFNTUkhhbmRsZXIoa2V5LCBmbikge1xuICBoYW5kbGVyc1trZXldID0gZm47XG59XG5cbmZ1bmN0aW9uIGd1ZXNzU2VyaWFsaXplclR5cGUocmF3SW5pdCkge1xuICByZXR1cm4gcmF3SW5pdCA9PSBudWxsID8gXCJhbnlcIiA6IHJhd0luaXQgaW5zdGFuY2VvZiBTZXQgPyBcInNldFwiIDogcmF3SW5pdCBpbnN0YW5jZW9mIE1hcCA/IFwibWFwXCIgOiByYXdJbml0IGluc3RhbmNlb2YgRGF0ZSA/IFwiZGF0ZVwiIDogdHlwZW9mIHJhd0luaXQgPT09IFwiYm9vbGVhblwiID8gXCJib29sZWFuXCIgOiB0eXBlb2YgcmF3SW5pdCA9PT0gXCJzdHJpbmdcIiA/IFwic3RyaW5nXCIgOiB0eXBlb2YgcmF3SW5pdCA9PT0gXCJvYmplY3RcIiA/IFwib2JqZWN0XCIgOiAhTnVtYmVyLmlzTmFOKHJhd0luaXQpID8gXCJudW1iZXJcIiA6IFwiYW55XCI7XG59XG5cbmNvbnN0IFN0b3JhZ2VTZXJpYWxpemVycyA9IHtcbiAgYm9vbGVhbjoge1xuICAgIHJlYWQ6ICh2KSA9PiB2ID09PSBcInRydWVcIixcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBvYmplY3Q6IHtcbiAgICByZWFkOiAodikgPT4gSlNPTi5wYXJzZSh2KSxcbiAgICB3cml0ZTogKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpXG4gIH0sXG4gIG51bWJlcjoge1xuICAgIHJlYWQ6ICh2KSA9PiBOdW1iZXIucGFyc2VGbG9hdCh2KSxcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBhbnk6IHtcbiAgICByZWFkOiAodikgPT4gdixcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBzdHJpbmc6IHtcbiAgICByZWFkOiAodikgPT4gdixcbiAgICB3cml0ZTogKHYpID0+IFN0cmluZyh2KVxuICB9LFxuICBtYXA6IHtcbiAgICByZWFkOiAodikgPT4gbmV3IE1hcChKU09OLnBhcnNlKHYpKSxcbiAgICB3cml0ZTogKHYpID0+IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odi5lbnRyaWVzKCkpKVxuICB9LFxuICBzZXQ6IHtcbiAgICByZWFkOiAodikgPT4gbmV3IFNldChKU09OLnBhcnNlKHYpKSxcbiAgICB3cml0ZTogKHYpID0+IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odikpXG4gIH0sXG4gIGRhdGU6IHtcbiAgICByZWFkOiAodikgPT4gbmV3IERhdGUodiksXG4gICAgd3JpdGU6ICh2KSA9PiB2LnRvSVNPU3RyaW5nKClcbiAgfVxufTtcbmNvbnN0IGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUgPSBcInZ1ZXVzZS1zdG9yYWdlXCI7XG5mdW5jdGlvbiB1c2VTdG9yYWdlKGtleSwgZGVmYXVsdHMsIHN0b3JhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBmbHVzaCA9IFwicHJlXCIsXG4gICAgZGVlcCA9IHRydWUsXG4gICAgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyA9IHRydWUsXG4gICAgd3JpdGVEZWZhdWx0cyA9IHRydWUsXG4gICAgbWVyZ2VEZWZhdWx0cyA9IGZhbHNlLFxuICAgIHNoYWxsb3csXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudEZpbHRlcixcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfSxcbiAgICBpbml0T25Nb3VudGVkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhID0gKHNoYWxsb3cgPyBzaGFsbG93UmVmIDogcmVmKSh0eXBlb2YgZGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRzKCkgOiBkZWZhdWx0cyk7XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHRyeSB7XG4gICAgICBzdG9yYWdlID0gZ2V0U1NSSGFuZGxlcihcImdldERlZmF1bHRTdG9yYWdlXCIsICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSBkZWZhdWx0V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmxvY2FsU3RvcmFnZTtcbiAgICAgIH0pKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFzdG9yYWdlKVxuICAgIHJldHVybiBkYXRhO1xuICBjb25zdCByYXdJbml0ID0gdG9WYWx1ZShkZWZhdWx0cyk7XG4gIGNvbnN0IHR5cGUgPSBndWVzc1NlcmlhbGl6ZXJUeXBlKHJhd0luaXQpO1xuICBjb25zdCBzZXJpYWxpemVyID0gKF9hID0gb3B0aW9ucy5zZXJpYWxpemVyKSAhPSBudWxsID8gX2EgOiBTdG9yYWdlU2VyaWFsaXplcnNbdHlwZV07XG4gIGNvbnN0IHsgcGF1c2U6IHBhdXNlV2F0Y2gsIHJlc3VtZTogcmVzdW1lV2F0Y2ggfSA9IHBhdXNhYmxlV2F0Y2goXG4gICAgZGF0YSxcbiAgICAoKSA9PiB3cml0ZShkYXRhLnZhbHVlKSxcbiAgICB7IGZsdXNoLCBkZWVwLCBldmVudEZpbHRlciB9XG4gICk7XG4gIGlmICh3aW5kb3cgJiYgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcykge1xuICAgIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJzdG9yYWdlXCIsIHVwZGF0ZSk7XG4gICAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgY3VzdG9tU3RvcmFnZUV2ZW50TmFtZSwgdXBkYXRlRnJvbUN1c3RvbUV2ZW50KTtcbiAgICAgIGlmIChpbml0T25Nb3VudGVkKVxuICAgICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIWluaXRPbk1vdW50ZWQpXG4gICAgdXBkYXRlKCk7XG4gIGZ1bmN0aW9uIGRpc3BhdGNoV3JpdGVFdmVudChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoY3VzdG9tU3RvcmFnZUV2ZW50TmFtZSwge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgc3RvcmFnZUFyZWE6IHN0b3JhZ2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cml0ZSh2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BhdGNoV3JpdGVFdmVudChvbGRWYWx1ZSwgbnVsbCk7XG4gICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZXIud3JpdGUodik7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gc2VyaWFsaXplZCkge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgIGRpc3BhdGNoV3JpdGVFdmVudChvbGRWYWx1ZSwgc2VyaWFsaXplZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgY29uc3QgcmF3VmFsdWUgPSBldmVudCA/IGV2ZW50Lm5ld1ZhbHVlIDogc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKHJhd1ZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmICh3cml0ZURlZmF1bHRzICYmIHJhd0luaXQgIT0gbnVsbClcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplci53cml0ZShyYXdJbml0KSk7XG4gICAgICByZXR1cm4gcmF3SW5pdDtcbiAgICB9IGVsc2UgaWYgKCFldmVudCAmJiBtZXJnZURlZmF1bHRzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZXIucmVhZChyYXdWYWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIG1lcmdlRGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHModmFsdWUsIHJhd0luaXQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB7IC4uLnJhd0luaXQsIC4uLnZhbHVlIH07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmF3VmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIucmVhZChyYXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC5zdG9yYWdlQXJlYSAhPT0gc3RvcmFnZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5ID09IG51bGwpIHtcbiAgICAgIGRhdGEudmFsdWUgPSByYXdJbml0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5ICE9PSBrZXkpXG4gICAgICByZXR1cm47XG4gICAgcGF1c2VXYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoKGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5uZXdWYWx1ZSkgIT09IHNlcmlhbGl6ZXIud3JpdGUoZGF0YS52YWx1ZSkpXG4gICAgICAgIGRhdGEudmFsdWUgPSByZWFkKGV2ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXZlbnQpXG4gICAgICAgIG5leHRUaWNrKHJlc3VtZVdhdGNoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdW1lV2F0Y2goKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbUN1c3RvbUV2ZW50KGV2ZW50KSB7XG4gICAgdXBkYXRlKGV2ZW50LmRldGFpbCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHVzZVByZWZlcnJlZERhcmsob3B0aW9ucykge1xuICByZXR1cm4gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIiwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbG9yTW9kZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdG9yID0gXCJodG1sXCIsXG4gICAgYXR0cmlidXRlID0gXCJjbGFzc1wiLFxuICAgIGluaXRpYWxWYWx1ZSA9IFwiYXV0b1wiLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgc3RvcmFnZSxcbiAgICBzdG9yYWdlS2V5ID0gXCJ2dWV1c2UtY29sb3Itc2NoZW1lXCIsXG4gICAgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyA9IHRydWUsXG4gICAgc3RvcmFnZVJlZixcbiAgICBlbWl0QXV0byxcbiAgICBkaXNhYmxlVHJhbnNpdGlvbiA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGVzID0ge1xuICAgIGF1dG86IFwiXCIsXG4gICAgbGlnaHQ6IFwibGlnaHRcIixcbiAgICBkYXJrOiBcImRhcmtcIixcbiAgICAuLi5vcHRpb25zLm1vZGVzIHx8IHt9XG4gIH07XG4gIGNvbnN0IHByZWZlcnJlZERhcmsgPSB1c2VQcmVmZXJyZWREYXJrKHsgd2luZG93IH0pO1xuICBjb25zdCBzeXN0ZW0gPSBjb21wdXRlZCgoKSA9PiBwcmVmZXJyZWREYXJrLnZhbHVlID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xuICBjb25zdCBzdG9yZSA9IHN0b3JhZ2VSZWYgfHwgKHN0b3JhZ2VLZXkgPT0gbnVsbCA/IHRvUmVmKGluaXRpYWxWYWx1ZSkgOiB1c2VTdG9yYWdlKHN0b3JhZ2VLZXksIGluaXRpYWxWYWx1ZSwgc3RvcmFnZSwgeyB3aW5kb3csIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMgfSkpO1xuICBjb25zdCBzdGF0ZSA9IGNvbXB1dGVkKCgpID0+IHN0b3JlLnZhbHVlID09PSBcImF1dG9cIiA/IHN5c3RlbS52YWx1ZSA6IHN0b3JlLnZhbHVlKTtcbiAgY29uc3QgdXBkYXRlSFRNTEF0dHJzID0gZ2V0U1NSSGFuZGxlcihcbiAgICBcInVwZGF0ZUhUTUxBdHRyc1wiLFxuICAgIChzZWxlY3RvcjIsIGF0dHJpYnV0ZTIsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IHR5cGVvZiBzZWxlY3RvcjIgPT09IFwic3RyaW5nXCIgPyB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yMikgOiB1bnJlZkVsZW1lbnQoc2VsZWN0b3IyKTtcbiAgICAgIGlmICghZWwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBzdHlsZTtcbiAgICAgIGlmIChkaXNhYmxlVHJhbnNpdGlvbikge1xuICAgICAgICBzdHlsZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGNvbnN0IHN0eWxlU3RyaW5nID0gXCIqLCo6OmJlZm9yZSwqOjphZnRlcnstd2Via2l0LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1vei10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50Oy1vLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1zLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH1cIjtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVTdHJpbmcpKTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZTIgPT09IFwiY2xhc3NcIikge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdmFsdWUuc3BsaXQoL1xccy9nKTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhtb2RlcykuZmxhdE1hcCgoaSkgPT4gKGkgfHwgXCJcIikuc3BsaXQoL1xccy9nKSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICBpZiAoY3VycmVudC5pbmNsdWRlcyh2KSlcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSh2KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlMiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVUcmFuc2l0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHN0eWxlKS5vcGFjaXR5O1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGZ1bmN0aW9uIGRlZmF1bHRPbkNoYW5nZWQobW9kZSkge1xuICAgIHZhciBfYTtcbiAgICB1cGRhdGVIVE1MQXR0cnMoc2VsZWN0b3IsIGF0dHJpYnV0ZSwgKF9hID0gbW9kZXNbbW9kZV0pICE9IG51bGwgPyBfYSA6IG1vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ2hhbmdlZChtb2RlKSB7XG4gICAgaWYgKG9wdGlvbnMub25DaGFuZ2VkKVxuICAgICAgb3B0aW9ucy5vbkNoYW5nZWQobW9kZSwgZGVmYXVsdE9uQ2hhbmdlZCk7XG4gICAgZWxzZVxuICAgICAgZGVmYXVsdE9uQ2hhbmdlZChtb2RlKTtcbiAgfVxuICB3YXRjaChzdGF0ZSwgb25DaGFuZ2VkLCB7IGZsdXNoOiBcInBvc3RcIiwgaW1tZWRpYXRlOiB0cnVlIH0pO1xuICB0cnlPbk1vdW50ZWQoKCkgPT4gb25DaGFuZ2VkKHN0YXRlLnZhbHVlKSk7XG4gIGNvbnN0IGF1dG8gPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGVtaXRBdXRvID8gc3RvcmUudmFsdWUgOiBzdGF0ZS52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBzdG9yZS52YWx1ZSA9IHY7XG4gICAgfVxuICB9KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhdXRvLCB7IHN0b3JlLCBzeXN0ZW0sIHN0YXRlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGF1dG87XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ29uZmlybURpYWxvZyhyZXZlYWxlZCA9IHJlZihmYWxzZSkpIHtcbiAgY29uc3QgY29uZmlybUhvb2sgPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgY29uc3QgY2FuY2VsSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCByZXZlYWxIb29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGxldCBfcmVzb2x2ZSA9IG5vb3A7XG4gIGNvbnN0IHJldmVhbCA9IChkYXRhKSA9PiB7XG4gICAgcmV2ZWFsSG9vay50cmlnZ2VyKGRhdGEpO1xuICAgIHJldmVhbGVkLnZhbHVlID0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgY29uZmlybSA9IChkYXRhKSA9PiB7XG4gICAgcmV2ZWFsZWQudmFsdWUgPSBmYWxzZTtcbiAgICBjb25maXJtSG9vay50cmlnZ2VyKGRhdGEpO1xuICAgIF9yZXNvbHZlKHsgZGF0YSwgaXNDYW5jZWxlZDogZmFsc2UgfSk7XG4gIH07XG4gIGNvbnN0IGNhbmNlbCA9IChkYXRhKSA9PiB7XG4gICAgcmV2ZWFsZWQudmFsdWUgPSBmYWxzZTtcbiAgICBjYW5jZWxIb29rLnRyaWdnZXIoZGF0YSk7XG4gICAgX3Jlc29sdmUoeyBkYXRhLCBpc0NhbmNlbGVkOiB0cnVlIH0pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGlzUmV2ZWFsZWQ6IGNvbXB1dGVkKCgpID0+IHJldmVhbGVkLnZhbHVlKSxcbiAgICByZXZlYWwsXG4gICAgY29uZmlybSxcbiAgICBjYW5jZWwsXG4gICAgb25SZXZlYWw6IHJldmVhbEhvb2sub24sXG4gICAgb25Db25maXJtOiBjb25maXJtSG9vay5vbixcbiAgICBvbkNhbmNlbDogY2FuY2VsSG9vay5vblxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VDc3NWYXIocHJvcCwgdGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBpbml0aWFsVmFsdWUgPSBcIlwiLCBvYnNlcnZlID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHZhcmlhYmxlID0gcmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IGVsUmVmID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gdW5yZWZFbGVtZW50KHRhcmdldCkgfHwgKChfYSA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZG9jdW1lbnRFbGVtZW50KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZUNzc1ZhcigpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qga2V5ID0gdG9WYWx1ZShwcm9wKTtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUoZWxSZWYpO1xuICAgIGlmIChlbCAmJiB3aW5kb3cpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKF9hID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRyaW0oKTtcbiAgICAgIHZhcmlhYmxlLnZhbHVlID0gdmFsdWUgfHwgaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAob2JzZXJ2ZSkge1xuICAgIHVzZU11dGF0aW9uT2JzZXJ2ZXIoZWxSZWYsIHVwZGF0ZUNzc1Zhciwge1xuICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJzdHlsZVwiLCBcImNsYXNzXCJdLFxuICAgICAgd2luZG93XG4gICAgfSk7XG4gIH1cbiAgd2F0Y2goXG4gICAgW2VsUmVmLCAoKSA9PiB0b1ZhbHVlKHByb3ApXSxcbiAgICB1cGRhdGVDc3NWYXIsXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB3YXRjaChcbiAgICB2YXJpYWJsZSxcbiAgICAodmFsKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoKF9hID0gZWxSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdHlsZSlcbiAgICAgICAgZWxSZWYudmFsdWUuc3R5bGUuc2V0UHJvcGVydHkodG9WYWx1ZShwcm9wKSwgdmFsKTtcbiAgICB9XG4gICk7XG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZnVuY3Rpb24gdXNlQ3VycmVudEVsZW1lbnQocm9vdENvbXBvbmVudCkge1xuICBjb25zdCB2bSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGNvbXB1dGVkV2l0aENvbnRyb2woXG4gICAgKCkgPT4gbnVsbCxcbiAgICAoKSA9PiByb290Q29tcG9uZW50ID8gdW5yZWZFbGVtZW50KHJvb3RDb21wb25lbnQpIDogdm0ucHJveHkuJGVsXG4gICk7XG4gIG9uVXBkYXRlZChjdXJyZW50RWxlbWVudC50cmlnZ2VyKTtcbiAgb25Nb3VudGVkKGN1cnJlbnRFbGVtZW50LnRyaWdnZXIpO1xuICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZUN5Y2xlTGlzdChsaXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YXRlID0gc2hhbGxvd1JlZihnZXRJbml0aWFsVmFsdWUoKSk7XG4gIGNvbnN0IGxpc3RSZWYgPSB0b1JlZihsaXN0KTtcbiAgY29uc3QgaW5kZXggPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGFyZ2V0TGlzdCA9IGxpc3RSZWYudmFsdWU7XG4gICAgICBsZXQgaW5kZXgyID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0SW5kZXhPZikgPyBvcHRpb25zLmdldEluZGV4T2Yoc3RhdGUudmFsdWUsIHRhcmdldExpc3QpIDogdGFyZ2V0TGlzdC5pbmRleE9mKHN0YXRlLnZhbHVlKTtcbiAgICAgIGlmIChpbmRleDIgPCAwKVxuICAgICAgICBpbmRleDIgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrSW5kZXgpICE9IG51bGwgPyBfYSA6IDA7XG4gICAgICByZXR1cm4gaW5kZXgyO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIHNldCh2KTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBzZXQoaSkge1xuICAgIGNvbnN0IHRhcmdldExpc3QgPSBsaXN0UmVmLnZhbHVlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRhcmdldExpc3QubGVuZ3RoO1xuICAgIGNvbnN0IGluZGV4MiA9IChpICUgbGVuZ3RoICsgbGVuZ3RoKSAlIGxlbmd0aDtcbiAgICBjb25zdCB2YWx1ZSA9IHRhcmdldExpc3RbaW5kZXgyXTtcbiAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBzaGlmdChkZWx0YSA9IDEpIHtcbiAgICByZXR1cm4gc2V0KGluZGV4LnZhbHVlICsgZGVsdGEpO1xuICB9XG4gIGZ1bmN0aW9uIG5leHQobiA9IDEpIHtcbiAgICByZXR1cm4gc2hpZnQobik7XG4gIH1cbiAgZnVuY3Rpb24gcHJldihuID0gMSkge1xuICAgIHJldHVybiBzaGlmdCgtbik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IHRvVmFsdWUoKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0aWFsVmFsdWUpICE9IG51bGwgPyBfYSA6IHRvVmFsdWUobGlzdClbMF0pKSAhPSBudWxsID8gX2IgOiB2b2lkIDA7XG4gIH1cbiAgd2F0Y2gobGlzdFJlZiwgKCkgPT4gc2V0KGluZGV4LnZhbHVlKSk7XG4gIHJldHVybiB7XG4gICAgc3RhdGUsXG4gICAgaW5kZXgsXG4gICAgbmV4dCxcbiAgICBwcmV2LFxuICAgIGdvOiBzZXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGFyayhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHZhbHVlRGFyayA9IFwiZGFya1wiLFxuICAgIHZhbHVlTGlnaHQgPSBcIlwiLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1vZGUgPSB1c2VDb2xvck1vZGUoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25DaGFuZ2VkOiAobW9kZTIsIGRlZmF1bHRIYW5kbGVyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAob3B0aW9ucy5vbkNoYW5nZWQpXG4gICAgICAgIChfYSA9IG9wdGlvbnMub25DaGFuZ2VkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBtb2RlMiA9PT0gXCJkYXJrXCIsIGRlZmF1bHRIYW5kbGVyLCBtb2RlMik7XG4gICAgICBlbHNlXG4gICAgICAgIGRlZmF1bHRIYW5kbGVyKG1vZGUyKTtcbiAgICB9LFxuICAgIG1vZGVzOiB7XG4gICAgICBkYXJrOiB2YWx1ZURhcmssXG4gICAgICBsaWdodDogdmFsdWVMaWdodFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN5c3RlbSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAobW9kZS5zeXN0ZW0pIHtcbiAgICAgIHJldHVybiBtb2RlLnN5c3RlbS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlZmVycmVkRGFyayA9IHVzZVByZWZlcnJlZERhcmsoeyB3aW5kb3cgfSk7XG4gICAgICByZXR1cm4gcHJlZmVycmVkRGFyay52YWx1ZSA/IFwiZGFya1wiIDogXCJsaWdodFwiO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGlzRGFyayA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gbW9kZS52YWx1ZSA9PT0gXCJkYXJrXCI7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgY29uc3QgbW9kZVZhbCA9IHYgPyBcImRhcmtcIiA6IFwibGlnaHRcIjtcbiAgICAgIGlmIChzeXN0ZW0udmFsdWUgPT09IG1vZGVWYWwpXG4gICAgICAgIG1vZGUudmFsdWUgPSBcImF1dG9cIjtcbiAgICAgIGVsc2VcbiAgICAgICAgbW9kZS52YWx1ZSA9IG1vZGVWYWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGlzRGFyaztcbn1cblxuZnVuY3Rpb24gZm5CeXBhc3Modikge1xuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGZuU2V0U291cmNlKHNvdXJjZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNvdXJjZS52YWx1ZSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gZGVmYXVsdER1bXAoY2xvbmUpIHtcbiAgcmV0dXJuIGNsb25lID8gdHlwZW9mIGNsb25lID09PSBcImZ1bmN0aW9uXCIgPyBjbG9uZSA6IGNsb25lRm5KU09OIDogZm5CeXBhc3M7XG59XG5mdW5jdGlvbiBkZWZhdWx0UGFyc2UoY2xvbmUpIHtcbiAgcmV0dXJuIGNsb25lID8gdHlwZW9mIGNsb25lID09PSBcImZ1bmN0aW9uXCIgPyBjbG9uZSA6IGNsb25lRm5KU09OIDogZm5CeXBhc3M7XG59XG5mdW5jdGlvbiB1c2VNYW51YWxSZWZIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBjbG9uZSA9IGZhbHNlLFxuICAgIGR1bXAgPSBkZWZhdWx0RHVtcChjbG9uZSksXG4gICAgcGFyc2UgPSBkZWZhdWx0UGFyc2UoY2xvbmUpLFxuICAgIHNldFNvdXJjZSA9IGZuU2V0U291cmNlXG4gIH0gPSBvcHRpb25zO1xuICBmdW5jdGlvbiBfY3JlYXRlSGlzdG9yeVJlY29yZCgpIHtcbiAgICByZXR1cm4gbWFya1Jhdyh7XG4gICAgICBzbmFwc2hvdDogZHVtcChzb3VyY2UudmFsdWUpLFxuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAoKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGxhc3QgPSByZWYoX2NyZWF0ZUhpc3RvcnlSZWNvcmQoKSk7XG4gIGNvbnN0IHVuZG9TdGFjayA9IHJlZihbXSk7XG4gIGNvbnN0IHJlZG9TdGFjayA9IHJlZihbXSk7XG4gIGNvbnN0IF9zZXRTb3VyY2UgPSAocmVjb3JkKSA9PiB7XG4gICAgc2V0U291cmNlKHNvdXJjZSwgcGFyc2UocmVjb3JkLnNuYXBzaG90KSk7XG4gICAgbGFzdC52YWx1ZSA9IHJlY29yZDtcbiAgfTtcbiAgY29uc3QgY29tbWl0ID0gKCkgPT4ge1xuICAgIHVuZG9TdGFjay52YWx1ZS51bnNoaWZ0KGxhc3QudmFsdWUpO1xuICAgIGxhc3QudmFsdWUgPSBfY3JlYXRlSGlzdG9yeVJlY29yZCgpO1xuICAgIGlmIChvcHRpb25zLmNhcGFjaXR5ICYmIHVuZG9TdGFjay52YWx1ZS5sZW5ndGggPiBvcHRpb25zLmNhcGFjaXR5KVxuICAgICAgdW5kb1N0YWNrLnZhbHVlLnNwbGljZShvcHRpb25zLmNhcGFjaXR5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIGlmIChyZWRvU3RhY2sudmFsdWUubGVuZ3RoKVxuICAgICAgcmVkb1N0YWNrLnZhbHVlLnNwbGljZSgwLCByZWRvU3RhY2sudmFsdWUubGVuZ3RoKTtcbiAgfTtcbiAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgdW5kb1N0YWNrLnZhbHVlLnNwbGljZSgwLCB1bmRvU3RhY2sudmFsdWUubGVuZ3RoKTtcbiAgICByZWRvU3RhY2sudmFsdWUuc3BsaWNlKDAsIHJlZG9TdGFjay52YWx1ZS5sZW5ndGgpO1xuICB9O1xuICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gdW5kb1N0YWNrLnZhbHVlLnNoaWZ0KCk7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICByZWRvU3RhY2sudmFsdWUudW5zaGlmdChsYXN0LnZhbHVlKTtcbiAgICAgIF9zZXRTb3VyY2Uoc3RhdGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVkbyA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHJlZG9TdGFjay52YWx1ZS5zaGlmdCgpO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdW5kb1N0YWNrLnZhbHVlLnVuc2hpZnQobGFzdC52YWx1ZSk7XG4gICAgICBfc2V0U291cmNlKHN0YXRlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIF9zZXRTb3VyY2UobGFzdC52YWx1ZSk7XG4gIH07XG4gIGNvbnN0IGhpc3RvcnkgPSBjb21wdXRlZCgoKSA9PiBbbGFzdC52YWx1ZSwgLi4udW5kb1N0YWNrLnZhbHVlXSk7XG4gIGNvbnN0IGNhblVuZG8gPSBjb21wdXRlZCgoKSA9PiB1bmRvU3RhY2sudmFsdWUubGVuZ3RoID4gMCk7XG4gIGNvbnN0IGNhblJlZG8gPSBjb21wdXRlZCgoKSA9PiByZWRvU3RhY2sudmFsdWUubGVuZ3RoID4gMCk7XG4gIHJldHVybiB7XG4gICAgc291cmNlLFxuICAgIHVuZG9TdGFjayxcbiAgICByZWRvU3RhY2ssXG4gICAgbGFzdCxcbiAgICBoaXN0b3J5LFxuICAgIGNhblVuZG8sXG4gICAgY2FuUmVkbyxcbiAgICBjbGVhcixcbiAgICBjb21taXQsXG4gICAgcmVzZXQsXG4gICAgdW5kbyxcbiAgICByZWRvXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZkhpc3Rvcnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRlZXAgPSBmYWxzZSxcbiAgICBmbHVzaCA9IFwicHJlXCIsXG4gICAgZXZlbnRGaWx0ZXJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBldmVudEZpbHRlcjogY29tcG9zZWRGaWx0ZXIsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lOiByZXN1bWVUcmFja2luZyxcbiAgICBpc0FjdGl2ZTogaXNUcmFja2luZ1xuICB9ID0gcGF1c2FibGVGaWx0ZXIoZXZlbnRGaWx0ZXIpO1xuICBjb25zdCB7XG4gICAgaWdub3JlVXBkYXRlcyxcbiAgICBpZ25vcmVQcmV2QXN5bmNVcGRhdGVzLFxuICAgIHN0b3BcbiAgfSA9IHdhdGNoSWdub3JhYmxlKFxuICAgIHNvdXJjZSxcbiAgICBjb21taXQsXG4gICAgeyBkZWVwLCBmbHVzaCwgZXZlbnRGaWx0ZXI6IGNvbXBvc2VkRmlsdGVyIH1cbiAgKTtcbiAgZnVuY3Rpb24gc2V0U291cmNlKHNvdXJjZTIsIHZhbHVlKSB7XG4gICAgaWdub3JlUHJldkFzeW5jVXBkYXRlcygpO1xuICAgIGlnbm9yZVVwZGF0ZXMoKCkgPT4ge1xuICAgICAgc291cmNlMi52YWx1ZSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1hbnVhbEhpc3RvcnkgPSB1c2VNYW51YWxSZWZIaXN0b3J5KHNvdXJjZSwgeyAuLi5vcHRpb25zLCBjbG9uZTogb3B0aW9ucy5jbG9uZSB8fCBkZWVwLCBzZXRTb3VyY2UgfSk7XG4gIGNvbnN0IHsgY2xlYXIsIGNvbW1pdDogbWFudWFsQ29tbWl0IH0gPSBtYW51YWxIaXN0b3J5O1xuICBmdW5jdGlvbiBjb21taXQoKSB7XG4gICAgaWdub3JlUHJldkFzeW5jVXBkYXRlcygpO1xuICAgIG1hbnVhbENvbW1pdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZShjb21taXROb3cpIHtcbiAgICByZXN1bWVUcmFja2luZygpO1xuICAgIGlmIChjb21taXROb3cpXG4gICAgICBjb21taXQoKTtcbiAgfVxuICBmdW5jdGlvbiBiYXRjaChmbikge1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IGNhbmNlbGVkID0gdHJ1ZTtcbiAgICBpZ25vcmVVcGRhdGVzKCgpID0+IHtcbiAgICAgIGZuKGNhbmNlbCk7XG4gICAgfSk7XG4gICAgaWYgKCFjYW5jZWxlZClcbiAgICAgIGNvbW1pdCgpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgc3RvcCgpO1xuICAgIGNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5tYW51YWxIaXN0b3J5LFxuICAgIGlzVHJhY2tpbmcsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lLFxuICAgIGNvbW1pdCxcbiAgICBiYXRjaCxcbiAgICBkaXNwb3NlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURlYm91bmNlZFJlZkhpc3Rvcnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZmlsdGVyID0gb3B0aW9ucy5kZWJvdW5jZSA/IGRlYm91bmNlRmlsdGVyKG9wdGlvbnMuZGVib3VuY2UpIDogdm9pZCAwO1xuICBjb25zdCBoaXN0b3J5ID0gdXNlUmVmSGlzdG9yeShzb3VyY2UsIHsgLi4ub3B0aW9ucywgZXZlbnRGaWx0ZXI6IGZpbHRlciB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5oaXN0b3J5XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURldmljZU1vdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZXZlbnRGaWx0ZXIgPSBieXBhc3NGaWx0ZXJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGFjY2VsZXJhdGlvbiA9IHJlZih7IHg6IG51bGwsIHk6IG51bGwsIHo6IG51bGwgfSk7XG4gIGNvbnN0IHJvdGF0aW9uUmF0ZSA9IHJlZih7IGFscGhhOiBudWxsLCBiZXRhOiBudWxsLCBnYW1tYTogbnVsbCB9KTtcbiAgY29uc3QgaW50ZXJ2YWwgPSByZWYoMCk7XG4gIGNvbnN0IGFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgPSByZWYoe1xuICAgIHg6IG51bGwsXG4gICAgeTogbnVsbCxcbiAgICB6OiBudWxsXG4gIH0pO1xuICBpZiAod2luZG93KSB7XG4gICAgY29uc3Qgb25EZXZpY2VNb3Rpb24gPSBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgICAgZXZlbnRGaWx0ZXIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgYWNjZWxlcmF0aW9uLnZhbHVlID0gZXZlbnQuYWNjZWxlcmF0aW9uO1xuICAgICAgICBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnZhbHVlID0gZXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eTtcbiAgICAgICAgcm90YXRpb25SYXRlLnZhbHVlID0gZXZlbnQucm90YXRpb25SYXRlO1xuICAgICAgICBpbnRlcnZhbC52YWx1ZSA9IGV2ZW50LmludGVydmFsO1xuICAgICAgfVxuICAgICk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiZGV2aWNlbW90aW9uXCIsIG9uRGV2aWNlTW90aW9uKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFjY2VsZXJhdGlvbixcbiAgICBhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LFxuICAgIHJvdGF0aW9uUmF0ZSxcbiAgICBpbnRlcnZhbFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZXZpY2VPcmllbnRhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJEZXZpY2VPcmllbnRhdGlvbkV2ZW50XCIgaW4gd2luZG93KTtcbiAgY29uc3QgaXNBYnNvbHV0ZSA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGFscGhhID0gcmVmKG51bGwpO1xuICBjb25zdCBiZXRhID0gcmVmKG51bGwpO1xuICBjb25zdCBnYW1tYSA9IHJlZihudWxsKTtcbiAgaWYgKHdpbmRvdyAmJiBpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImRldmljZW9yaWVudGF0aW9uXCIsIChldmVudCkgPT4ge1xuICAgICAgaXNBYnNvbHV0ZS52YWx1ZSA9IGV2ZW50LmFic29sdXRlO1xuICAgICAgYWxwaGEudmFsdWUgPSBldmVudC5hbHBoYTtcbiAgICAgIGJldGEudmFsdWUgPSBldmVudC5iZXRhO1xuICAgICAgZ2FtbWEudmFsdWUgPSBldmVudC5nYW1tYTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzQWJzb2x1dGUsXG4gICAgYWxwaGEsXG4gICAgYmV0YSxcbiAgICBnYW1tYVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZXZpY2VQaXhlbFJhdGlvKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHJlZigxKTtcbiAgaWYgKHdpbmRvdykge1xuICAgIGxldCBvYnNlcnZlMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGl4ZWxSYXRpby52YWx1ZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgY2xlYW51cDIoKTtcbiAgICAgIG1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEoYChyZXNvbHV0aW9uOiAke3BpeGVsUmF0aW8udmFsdWV9ZHBweClgKTtcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgb2JzZXJ2ZTIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9LCBjbGVhbnVwMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgb2JzZXJ2ZTIpO1xuICAgIH07XG4gICAgbGV0IG1lZGlhO1xuICAgIG9ic2VydmUyKCk7XG4gICAgdHJ5T25TY29wZURpc3Bvc2UoY2xlYW51cDIpO1xuICB9XG4gIHJldHVybiB7IHBpeGVsUmF0aW8gfTtcbn1cblxuZnVuY3Rpb24gdXNlRGV2aWNlc0xpc3Qob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9ucyA9IGZhbHNlLFxuICAgIGNvbnN0cmFpbnRzID0geyBhdWRpbzogdHJ1ZSwgdmlkZW86IHRydWUgfSxcbiAgICBvblVwZGF0ZWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRldmljZXMgPSByZWYoW10pO1xuICBjb25zdCB2aWRlb0lucHV0cyA9IGNvbXB1dGVkKCgpID0+IGRldmljZXMudmFsdWUuZmlsdGVyKChpKSA9PiBpLmtpbmQgPT09IFwidmlkZW9pbnB1dFwiKSk7XG4gIGNvbnN0IGF1ZGlvSW5wdXRzID0gY29tcHV0ZWQoKCkgPT4gZGV2aWNlcy52YWx1ZS5maWx0ZXIoKGkpID0+IGkua2luZCA9PT0gXCJhdWRpb2lucHV0XCIpKTtcbiAgY29uc3QgYXVkaW9PdXRwdXRzID0gY29tcHV0ZWQoKCkgPT4gZGV2aWNlcy52YWx1ZS5maWx0ZXIoKGkpID0+IGkua2luZCA9PT0gXCJhdWRpb291dHB1dFwiKSk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyk7XG4gIGNvbnN0IHBlcm1pc3Npb25HcmFudGVkID0gcmVmKGZhbHNlKTtcbiAgbGV0IHN0cmVhbTtcbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZGV2aWNlcy52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIG9uVXBkYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25VcGRhdGVkKGRldmljZXMudmFsdWUpO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiB0LnN0b3AoKSk7XG4gICAgICBzdHJlYW0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlbnN1cmVQZXJtaXNzaW9ucygpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHsgc3RhdGUsIHF1ZXJ5IH0gPSB1c2VQZXJtaXNzaW9uKFwiY2FtZXJhXCIsIHsgY29udHJvbHM6IHRydWUgfSk7XG4gICAgYXdhaXQgcXVlcnkoKTtcbiAgICBpZiAoc3RhdGUudmFsdWUgIT09IFwiZ3JhbnRlZFwiKSB7XG4gICAgICBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIHBlcm1pc3Npb25HcmFudGVkLnZhbHVlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVybWlzc2lvbkdyYW50ZWQudmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGVybWlzc2lvbkdyYW50ZWQudmFsdWU7XG4gIH1cbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgaWYgKHJlcXVlc3RQZXJtaXNzaW9ucylcbiAgICAgIGVuc3VyZVBlcm1pc3Npb25zKCk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLCBcImRldmljZWNoYW5nZVwiLCB1cGRhdGUpO1xuICAgIHVwZGF0ZSgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGV2aWNlcyxcbiAgICBlbnN1cmVQZXJtaXNzaW9ucyxcbiAgICBwZXJtaXNzaW9uR3JhbnRlZCxcbiAgICB2aWRlb0lucHV0cyxcbiAgICBhdWRpb0lucHV0cyxcbiAgICBhdWRpb091dHB1dHMsXG4gICAgaXNTdXBwb3J0ZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGlzcGxheU1lZGlhKG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGVuYWJsZWQgPSByZWYoKF9hID0gb3B0aW9ucy5lbmFibGVkKSAhPSBudWxsID8gX2EgOiBmYWxzZSk7XG4gIGNvbnN0IHZpZGVvID0gb3B0aW9ucy52aWRlbztcbiAgY29uc3QgYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICBjb25zdCB7IG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldERpc3BsYXlNZWRpYTtcbiAgfSk7XG4gIGNvbnN0IGNvbnN0cmFpbnQgPSB7IGF1ZGlvLCB2aWRlbyB9O1xuICBjb25zdCBzdHJlYW0gPSBzaGFsbG93UmVmKCk7XG4gIGFzeW5jIGZ1bmN0aW9uIF9zdGFydCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgc3RyZWFtLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHN0cmVhbS52YWx1ZSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnQpO1xuICAgIChfYTIgPSBzdHJlYW0udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgc3RvcCkpO1xuICAgIHJldHVybiBzdHJlYW0udmFsdWU7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgdmFyIF9hMjtcbiAgICAoX2EyID0gc3RyZWFtLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHQuc3RvcCgpKTtcbiAgICBzdHJlYW0udmFsdWUgPSB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBfc3RvcCgpO1xuICAgIGVuYWJsZWQudmFsdWUgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBhd2FpdCBfc3RhcnQoKTtcbiAgICBpZiAoc3RyZWFtLnZhbHVlKVxuICAgICAgZW5hYmxlZC52YWx1ZSA9IHRydWU7XG4gICAgcmV0dXJuIHN0cmVhbS52YWx1ZTtcbiAgfVxuICB3YXRjaChcbiAgICBlbmFibGVkLFxuICAgICh2KSA9PiB7XG4gICAgICBpZiAodilcbiAgICAgICAgX3N0YXJ0KCk7XG4gICAgICBlbHNlXG4gICAgICAgIF9zdG9wKCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RyZWFtLFxuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgZW5hYmxlZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEb2N1bWVudFZpc2liaWxpdHkob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQgfSA9IG9wdGlvbnM7XG4gIGlmICghZG9jdW1lbnQpXG4gICAgcmV0dXJuIHJlZihcInZpc2libGVcIik7XG4gIGNvbnN0IHZpc2liaWxpdHkgPSByZWYoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsICgpID0+IHtcbiAgICB2aXNpYmlsaXR5LnZhbHVlID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xuICB9KTtcbiAgcmV0dXJuIHZpc2liaWxpdHk7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdnYWJsZSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB7XG4gICAgcG9pbnRlclR5cGVzLFxuICAgIHByZXZlbnREZWZhdWx0LFxuICAgIHN0b3BQcm9wYWdhdGlvbixcbiAgICBleGFjdCxcbiAgICBvbk1vdmUsXG4gICAgb25FbmQsXG4gICAgb25TdGFydCxcbiAgICBpbml0aWFsVmFsdWUsXG4gICAgYXhpcyA9IFwiYm90aFwiLFxuICAgIGRyYWdnaW5nRWxlbWVudCA9IGRlZmF1bHRXaW5kb3csXG4gICAgY29udGFpbmVyRWxlbWVudCxcbiAgICBoYW5kbGU6IGRyYWdnaW5nSGFuZGxlID0gdGFyZ2V0XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwb3NpdGlvbiA9IHJlZihcbiAgICAoX2EgPSB0b1ZhbHVlKGluaXRpYWxWYWx1ZSkpICE9IG51bGwgPyBfYSA6IHsgeDogMCwgeTogMCB9XG4gICk7XG4gIGNvbnN0IHByZXNzZWREZWx0YSA9IHJlZigpO1xuICBjb25zdCBmaWx0ZXJFdmVudCA9IChlKSA9PiB7XG4gICAgaWYgKHBvaW50ZXJUeXBlcylcbiAgICAgIHJldHVybiBwb2ludGVyVHlwZXMuaW5jbHVkZXMoZS5wb2ludGVyVHlwZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUV2ZW50ID0gKGUpID0+IHtcbiAgICBpZiAodG9WYWx1ZShwcmV2ZW50RGVmYXVsdCkpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRvVmFsdWUoc3RvcFByb3BhZ2F0aW9uKSlcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gKGUpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmIChlLmJ1dHRvbiAhPT0gMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSB8fCAhZmlsdGVyRXZlbnQoZSkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRvVmFsdWUoZXhhY3QpICYmIGUudGFyZ2V0ICE9PSB0b1ZhbHVlKHRhcmdldCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29udGFpbmVyID0gdG9WYWx1ZShjb250YWluZXJFbGVtZW50KTtcbiAgICBjb25zdCBjb250YWluZXJSZWN0ID0gKF9hMiA9IGNvbnRhaW5lciA9PSBudWxsID8gdm9pZCAwIDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKGNvbnRhaW5lcik7XG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRvVmFsdWUodGFyZ2V0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwb3MgPSB7XG4gICAgICB4OiBlLmNsaWVudFggLSAoY29udGFpbmVyID8gdGFyZ2V0UmVjdC5sZWZ0IC0gY29udGFpbmVyUmVjdC5sZWZ0ICsgY29udGFpbmVyLnNjcm9sbExlZnQgOiB0YXJnZXRSZWN0LmxlZnQpLFxuICAgICAgeTogZS5jbGllbnRZIC0gKGNvbnRhaW5lciA/IHRhcmdldFJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXIuc2Nyb2xsVG9wIDogdGFyZ2V0UmVjdC50b3ApXG4gICAgfTtcbiAgICBpZiAoKG9uU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RhcnQocG9zLCBlKSkgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuO1xuICAgIHByZXNzZWREZWx0YS52YWx1ZSA9IHBvcztcbiAgICBoYW5kbGVFdmVudChlKTtcbiAgfTtcbiAgY29uc3QgbW92ZSA9IChlKSA9PiB7XG4gICAgaWYgKHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkgfHwgIWZpbHRlckV2ZW50KGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcHJlc3NlZERlbHRhLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRvVmFsdWUoY29udGFpbmVyRWxlbWVudCk7XG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRvVmFsdWUodGFyZ2V0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgeyB4LCB5IH0gPSBwb3NpdGlvbi52YWx1ZTtcbiAgICBpZiAoYXhpcyA9PT0gXCJ4XCIgfHwgYXhpcyA9PT0gXCJib3RoXCIpIHtcbiAgICAgIHggPSBlLmNsaWVudFggLSBwcmVzc2VkRGVsdGEudmFsdWUueDtcbiAgICAgIGlmIChjb250YWluZXIpXG4gICAgICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCgwLCB4KSwgY29udGFpbmVyLnNjcm9sbFdpZHRoIC0gdGFyZ2V0UmVjdC53aWR0aCk7XG4gICAgfVxuICAgIGlmIChheGlzID09PSBcInlcIiB8fCBheGlzID09PSBcImJvdGhcIikge1xuICAgICAgeSA9IGUuY2xpZW50WSAtIHByZXNzZWREZWx0YS52YWx1ZS55O1xuICAgICAgaWYgKGNvbnRhaW5lcilcbiAgICAgICAgeSA9IE1hdGgubWluKE1hdGgubWF4KDAsIHkpLCBjb250YWluZXIuc2Nyb2xsSGVpZ2h0IC0gdGFyZ2V0UmVjdC5oZWlnaHQpO1xuICAgIH1cbiAgICBwb3NpdGlvbi52YWx1ZSA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBvbk1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTW92ZShwb3NpdGlvbi52YWx1ZSwgZSk7XG4gICAgaGFuZGxlRXZlbnQoZSk7XG4gIH07XG4gIGNvbnN0IGVuZCA9IChlKSA9PiB7XG4gICAgaWYgKHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkgfHwgIWZpbHRlckV2ZW50KGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghcHJlc3NlZERlbHRhLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHByZXNzZWREZWx0YS52YWx1ZSA9IHZvaWQgMDtcbiAgICBvbkVuZCA9PSBudWxsID8gdm9pZCAwIDogb25FbmQocG9zaXRpb24udmFsdWUsIGUpO1xuICAgIGhhbmRsZUV2ZW50KGUpO1xuICB9O1xuICBpZiAoaXNDbGllbnQpIHtcbiAgICBjb25zdCBjb25maWcgPSB7IGNhcHR1cmU6IChfYiA9IG9wdGlvbnMuY2FwdHVyZSkgIT0gbnVsbCA/IF9iIDogdHJ1ZSB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZHJhZ2dpbmdIYW5kbGUsIFwicG9pbnRlcmRvd25cIiwgc3RhcnQsIGNvbmZpZyk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkcmFnZ2luZ0VsZW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgbW92ZSwgY29uZmlnKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRyYWdnaW5nRWxlbWVudCwgXCJwb2ludGVydXBcIiwgZW5kLCBjb25maWcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4udG9SZWZzKHBvc2l0aW9uKSxcbiAgICBwb3NpdGlvbixcbiAgICBpc0RyYWdnaW5nOiBjb21wdXRlZCgoKSA9PiAhIXByZXNzZWREZWx0YS52YWx1ZSksXG4gICAgc3R5bGU6IGNvbXB1dGVkKFxuICAgICAgKCkgPT4gYGxlZnQ6JHtwb3NpdGlvbi52YWx1ZS54fXB4O3RvcDoke3Bvc2l0aW9uLnZhbHVlLnl9cHg7YFxuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRHJvcFpvbmUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaXNPdmVyRHJvcFpvbmUgPSByZWYoZmFsc2UpO1xuICBjb25zdCBmaWxlcyA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgbGV0IGlzRGF0YVR5cGVJbmNsdWRlZCA9IHRydWU7XG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnN0IF9vcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgb25Ecm9wOiBvcHRpb25zIH0gOiBvcHRpb25zO1xuICAgIGNvbnN0IGdldEZpbGVzID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmZyb20oKF9iID0gKF9hID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlsZXMpICE9IG51bGwgPyBfYiA6IFtdKTtcbiAgICAgIHJldHVybiBmaWxlcy52YWx1ZSA9IGxpc3QubGVuZ3RoID09PSAwID8gbnVsbCA6IGxpc3Q7XG4gICAgfTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJkcmFnZW50ZXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgdHlwZXMgPSBBcnJheS5mcm9tKCgoX2EgPSBldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQuZGF0YVRyYW5zZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXRlbXMpIHx8IFtdKS5tYXAoKGkpID0+IGkua2luZCA9PT0gXCJmaWxlXCIgPyBpLnR5cGUgOiBudWxsKS5maWx0ZXIobm90TnVsbGlzaCk7XG4gICAgICBpZiAoX29wdGlvbnMuZGF0YVR5cGVzICYmIGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSB1bnJlZihfb3B0aW9ucy5kYXRhVHlwZXMpO1xuICAgICAgICBpc0RhdGFUeXBlSW5jbHVkZWQgPSB0eXBlb2YgZGF0YVR5cGVzID09PSBcImZ1bmN0aW9uXCIgPyBkYXRhVHlwZXModHlwZXMpIDogZGF0YVR5cGVzID8gZGF0YVR5cGVzLnNvbWUoKGl0ZW0pID0+IHR5cGVzLmluY2x1ZGVzKGl0ZW0pKSA6IHRydWU7XG4gICAgICAgIGlmICghaXNEYXRhVHlwZUluY2x1ZGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb3VudGVyICs9IDE7XG4gICAgICBpc092ZXJEcm9wWm9uZS52YWx1ZSA9IHRydWU7XG4gICAgICAoX2IgPSBfb3B0aW9ucy5vbkVudGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfb3B0aW9ucywgZ2V0RmlsZXMoZXZlbnQpLCBldmVudCk7XG4gICAgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHJhZ292ZXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWlzRGF0YVR5cGVJbmNsdWRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIChfYSA9IF9vcHRpb25zLm9uT3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoX29wdGlvbnMsIGdldEZpbGVzKGV2ZW50KSwgZXZlbnQpO1xuICAgIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdsZWF2ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghaXNEYXRhVHlwZUluY2x1ZGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY291bnRlciAtPSAxO1xuICAgICAgaWYgKGNvdW50ZXIgPT09IDApXG4gICAgICAgIGlzT3ZlckRyb3Bab25lLnZhbHVlID0gZmFsc2U7XG4gICAgICAoX2EgPSBfb3B0aW9ucy5vbkxlYXZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChfb3B0aW9ucywgZ2V0RmlsZXMoZXZlbnQpLCBldmVudCk7XG4gICAgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZHJvcFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb3VudGVyID0gMDtcbiAgICAgIGlzT3ZlckRyb3Bab25lLnZhbHVlID0gZmFsc2U7XG4gICAgICAoX2EgPSBfb3B0aW9ucy5vbkRyb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKF9vcHRpb25zLCBnZXRGaWxlcyhldmVudCksIGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGVzLFxuICAgIGlzT3ZlckRyb3Bab25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlc2l6ZU9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIC4uLm9ic2VydmVyT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgbGV0IG9ic2VydmVyO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB3aW5kb3cgJiYgXCJSZXNpemVPYnNlcnZlclwiIGluIHdpbmRvdyk7XG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBvYnNlcnZlciA9IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRhcmdldHMgPSBjb21wdXRlZCgoKSA9PiBBcnJheS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubWFwKChlbCkgPT4gdW5yZWZFbGVtZW50KGVsKSkgOiBbdW5yZWZFbGVtZW50KHRhcmdldCldKTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gd2F0Y2goXG4gICAgdGFyZ2V0cyxcbiAgICAoZWxzKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgd2luZG93KSB7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgICAgZm9yIChjb25zdCBfZWwgb2YgZWxzKVxuICAgICAgICAgIF9lbCAmJiBvYnNlcnZlci5vYnNlcnZlKF9lbCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBzdG9wV2F0Y2goKTtcbiAgfTtcbiAgdHJ5T25TY29wZURpc3Bvc2Uoc3RvcCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50Qm91bmRpbmcodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHJlc2V0ID0gdHJ1ZSxcbiAgICB3aW5kb3dSZXNpemUgPSB0cnVlLFxuICAgIHdpbmRvd1Njcm9sbCA9IHRydWUsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaGVpZ2h0ID0gcmVmKDApO1xuICBjb25zdCBib3R0b20gPSByZWYoMCk7XG4gIGNvbnN0IGxlZnQgPSByZWYoMCk7XG4gIGNvbnN0IHJpZ2h0ID0gcmVmKDApO1xuICBjb25zdCB0b3AgPSByZWYoMCk7XG4gIGNvbnN0IHdpZHRoID0gcmVmKDApO1xuICBjb25zdCB4ID0gcmVmKDApO1xuICBjb25zdCB5ID0gcmVmKDApO1xuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgY29uc3QgZWwgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaGVpZ2h0LnZhbHVlID0gMDtcbiAgICAgICAgYm90dG9tLnZhbHVlID0gMDtcbiAgICAgICAgbGVmdC52YWx1ZSA9IDA7XG4gICAgICAgIHJpZ2h0LnZhbHVlID0gMDtcbiAgICAgICAgdG9wLnZhbHVlID0gMDtcbiAgICAgICAgd2lkdGgudmFsdWUgPSAwO1xuICAgICAgICB4LnZhbHVlID0gMDtcbiAgICAgICAgeS52YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBoZWlnaHQudmFsdWUgPSByZWN0LmhlaWdodDtcbiAgICBib3R0b20udmFsdWUgPSByZWN0LmJvdHRvbTtcbiAgICBsZWZ0LnZhbHVlID0gcmVjdC5sZWZ0O1xuICAgIHJpZ2h0LnZhbHVlID0gcmVjdC5yaWdodDtcbiAgICB0b3AudmFsdWUgPSByZWN0LnRvcDtcbiAgICB3aWR0aC52YWx1ZSA9IHJlY3Qud2lkdGg7XG4gICAgeC52YWx1ZSA9IHJlY3QueDtcbiAgICB5LnZhbHVlID0gcmVjdC55O1xuICB9XG4gIHVzZVJlc2l6ZU9ic2VydmVyKHRhcmdldCwgdXBkYXRlKTtcbiAgd2F0Y2goKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCksIChlbGUpID0+ICFlbGUgJiYgdXBkYXRlKCkpO1xuICB1c2VNdXRhdGlvbk9ic2VydmVyKHRhcmdldCwgdXBkYXRlLCB7XG4gICAgYXR0cmlidXRlRmlsdGVyOiBbXCJzdHlsZVwiLCBcImNsYXNzXCJdXG4gIH0pO1xuICBpZiAod2luZG93U2Nyb2xsKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdXBkYXRlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gIGlmICh3aW5kb3dSZXNpemUpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1cGRhdGUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICBpZiAoaW1tZWRpYXRlKVxuICAgICAgdXBkYXRlKCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGhlaWdodCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0b3AsXG4gICAgd2lkdGgsXG4gICAgeCxcbiAgICB5LFxuICAgIHVwZGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50QnlQb2ludChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgbXVsdGlwbGUsXG4gICAgaW50ZXJ2YWwgPSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHtcbiAgICBpZiAodG9WYWx1ZShtdWx0aXBsZSkpXG4gICAgICByZXR1cm4gZG9jdW1lbnQgJiYgXCJlbGVtZW50c0Zyb21Qb2ludFwiIGluIGRvY3VtZW50O1xuICAgIHJldHVybiBkb2N1bWVudCAmJiBcImVsZW1lbnRGcm9tUG9pbnRcIiBpbiBkb2N1bWVudDtcbiAgfSk7XG4gIGNvbnN0IGVsZW1lbnQgPSByZWYobnVsbCk7XG4gIGNvbnN0IGNiID0gKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgZWxlbWVudC52YWx1ZSA9IHRvVmFsdWUobXVsdGlwbGUpID8gKF9hID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KHRvVmFsdWUoeCksIHRvVmFsdWUoeSkpKSAhPSBudWxsID8gX2EgOiBbXSA6IChfYiA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvVmFsdWUoeCksIHRvVmFsdWUoeSkpKSAhPSBudWxsID8gX2IgOiBudWxsO1xuICB9O1xuICBjb25zdCBjb250cm9scyA9IGludGVydmFsID09PSBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiID8gdXNlUmFmRm4oY2IsIHsgaW1tZWRpYXRlIH0pIDogdXNlSW50ZXJ2YWxGbihjYiwgaW50ZXJ2YWwsIHsgaW1tZWRpYXRlIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGVsZW1lbnQsXG4gICAgLi4uY29udHJvbHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRWxlbWVudEhvdmVyKGVsLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRlbGF5RW50ZXIgPSAwLFxuICAgIGRlbGF5TGVhdmUgPSAwLFxuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzSG92ZXJlZCA9IHJlZihmYWxzZSk7XG4gIGxldCB0aW1lcjtcbiAgY29uc3QgdG9nZ2xlID0gKGVudGVyaW5nKSA9PiB7XG4gICAgY29uc3QgZGVsYXkgPSBlbnRlcmluZyA/IGRlbGF5RW50ZXIgOiBkZWxheUxlYXZlO1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoZGVsYXkpXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gaXNIb3ZlcmVkLnZhbHVlID0gZW50ZXJpbmcsIGRlbGF5KTtcbiAgICBlbHNlXG4gICAgICBpc0hvdmVyZWQudmFsdWUgPSBlbnRlcmluZztcbiAgfTtcbiAgaWYgKCF3aW5kb3cpXG4gICAgcmV0dXJuIGlzSG92ZXJlZDtcbiAgdXNlRXZlbnRMaXN0ZW5lcihlbCwgXCJtb3VzZWVudGVyXCIsICgpID0+IHRvZ2dsZSh0cnVlKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKGVsLCBcIm1vdXNlbGVhdmVcIiwgKCkgPT4gdG9nZ2xlKGZhbHNlKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICByZXR1cm4gaXNIb3ZlcmVkO1xufVxuXG5mdW5jdGlvbiB1c2VFbGVtZW50U2l6ZSh0YXJnZXQsIGluaXRpYWxTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIGJveCA9IFwiY29udGVudC1ib3hcIiB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTVkcgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdW5yZWZFbGVtZW50KHRhcmdldCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5uYW1lc3BhY2VVUkkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcInN2Z1wiKTtcbiAgfSk7XG4gIGNvbnN0IHdpZHRoID0gcmVmKGluaXRpYWxTaXplLndpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gcmVmKGluaXRpYWxTaXplLmhlaWdodCk7XG4gIGNvbnN0IHsgc3RvcDogc3RvcDEgfSA9IHVzZVJlc2l6ZU9ic2VydmVyKFxuICAgIHRhcmdldCxcbiAgICAoW2VudHJ5XSkgPT4ge1xuICAgICAgY29uc3QgYm94U2l6ZSA9IGJveCA9PT0gXCJib3JkZXItYm94XCIgPyBlbnRyeS5ib3JkZXJCb3hTaXplIDogYm94ID09PSBcImNvbnRlbnQtYm94XCIgPyBlbnRyeS5jb250ZW50Qm94U2l6ZSA6IGVudHJ5LmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgICBpZiAod2luZG93ICYmIGlzU1ZHLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0ICRlbGVtID0gdW5yZWZFbGVtZW50KHRhcmdldCk7XG4gICAgICAgIGlmICgkZWxlbSkge1xuICAgICAgICAgIGNvbnN0IHJlY3QgPSAkZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB3aWR0aC52YWx1ZSA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0LnZhbHVlID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChib3hTaXplKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0Qm94U2l6ZSA9IEFycmF5LmlzQXJyYXkoYm94U2l6ZSkgPyBib3hTaXplIDogW2JveFNpemVdO1xuICAgICAgICAgIHdpZHRoLnZhbHVlID0gZm9ybWF0Qm94U2l6ZS5yZWR1Y2UoKGFjYywgeyBpbmxpbmVTaXplIH0pID0+IGFjYyArIGlubGluZVNpemUsIDApO1xuICAgICAgICAgIGhlaWdodC52YWx1ZSA9IGZvcm1hdEJveFNpemUucmVkdWNlKChhY2MsIHsgYmxvY2tTaXplIH0pID0+IGFjYyArIGJsb2NrU2l6ZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGgudmFsdWUgPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICAgICAgICBoZWlnaHQudmFsdWUgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgdHJ5T25Nb3VudGVkKCgpID0+IHtcbiAgICBjb25zdCBlbGUgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB3aWR0aC52YWx1ZSA9IFwib2Zmc2V0V2lkdGhcIiBpbiBlbGUgPyBlbGUub2Zmc2V0V2lkdGggOiBpbml0aWFsU2l6ZS53aWR0aDtcbiAgICAgIGhlaWdodC52YWx1ZSA9IFwib2Zmc2V0SGVpZ2h0XCIgaW4gZWxlID8gZWxlLm9mZnNldEhlaWdodCA6IGluaXRpYWxTaXplLmhlaWdodDtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdG9wMiA9IHdhdGNoKFxuICAgICgpID0+IHVucmVmRWxlbWVudCh0YXJnZXQpLFxuICAgIChlbGUpID0+IHtcbiAgICAgIHdpZHRoLnZhbHVlID0gZWxlID8gaW5pdGlhbFNpemUud2lkdGggOiAwO1xuICAgICAgaGVpZ2h0LnZhbHVlID0gZWxlID8gaW5pdGlhbFNpemUuaGVpZ2h0IDogMDtcbiAgICB9XG4gICk7XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgc3RvcDEoKTtcbiAgICBzdG9wMigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIodGFyZ2V0LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICByb290LFxuICAgIHJvb3RNYXJnaW4gPSBcIjBweFwiLFxuICAgIHRocmVzaG9sZCA9IDAuMSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGltbWVkaWF0ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIkludGVyc2VjdGlvbk9ic2VydmVyXCIgaW4gd2luZG93KTtcbiAgY29uc3QgdGFyZ2V0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBfdGFyZ2V0ID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShfdGFyZ2V0KSA/IF90YXJnZXQgOiBbX3RhcmdldF0pLm1hcCh1bnJlZkVsZW1lbnQpLmZpbHRlcihub3ROdWxsaXNoKTtcbiAgfSk7XG4gIGxldCBjbGVhbnVwID0gbm9vcDtcbiAgY29uc3QgaXNBY3RpdmUgPSByZWYoaW1tZWRpYXRlKTtcbiAgY29uc3Qgc3RvcFdhdGNoID0gaXNTdXBwb3J0ZWQudmFsdWUgPyB3YXRjaChcbiAgICAoKSA9PiBbdGFyZ2V0cy52YWx1ZSwgdW5yZWZFbGVtZW50KHJvb3QpLCBpc0FjdGl2ZS52YWx1ZV0sXG4gICAgKFt0YXJnZXRzMiwgcm9vdDJdKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoIWlzQWN0aXZlLnZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoIXRhcmdldHMyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB7XG4gICAgICAgICAgcm9vdDogdW5yZWZFbGVtZW50KHJvb3QyKSxcbiAgICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAgIHRocmVzaG9sZFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGFyZ2V0czIuZm9yRWFjaCgoZWwpID0+IGVsICYmIG9ic2VydmVyLm9ic2VydmUoZWwpKTtcbiAgICAgIGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY2xlYW51cCA9IG5vb3A7XG4gICAgICB9O1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGUsIGZsdXNoOiBcInBvc3RcIiB9XG4gICkgOiBub29wO1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgICBzdG9wV2F0Y2goKTtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSgpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlzQWN0aXZlLnZhbHVlID0gZmFsc2U7XG4gICAgfSxcbiAgICByZXN1bWUoKSB7XG4gICAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgfSxcbiAgICBzdG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUVsZW1lbnRWaXNpYmlsaXR5KGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csIHNjcm9sbFRhcmdldCwgdGhyZXNob2xkID0gMCB9ID0gb3B0aW9ucztcbiAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IHJlZihmYWxzZSk7XG4gIHVzZUludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgIGVsZW1lbnQsXG4gICAgKGludGVyc2VjdGlvbk9ic2VydmVyRW50cmllcykgPT4ge1xuICAgICAgbGV0IGlzSW50ZXJzZWN0aW5nID0gZWxlbWVudElzVmlzaWJsZS52YWx1ZTtcbiAgICAgIGxldCBsYXRlc3RUaW1lID0gMDtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS50aW1lID49IGxhdGVzdFRpbWUpIHtcbiAgICAgICAgICBsYXRlc3RUaW1lID0gZW50cnkudGltZTtcbiAgICAgICAgICBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbGVtZW50SXNWaXNpYmxlLnZhbHVlID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgfSxcbiAgICB7XG4gICAgICByb290OiBzY3JvbGxUYXJnZXQsXG4gICAgICB3aW5kb3csXG4gICAgICB0aHJlc2hvbGRcbiAgICB9XG4gICk7XG4gIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xufVxuXG5jb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiB1c2VFdmVudEJ1cyhrZXkpIHtcbiAgY29uc3Qgc2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgZnVuY3Rpb24gb24obGlzdGVuZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gZXZlbnRzLmdldChrZXkpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgZXZlbnRzLnNldChrZXksIGxpc3RlbmVycyk7XG4gICAgY29uc3QgX29mZiA9ICgpID0+IG9mZihsaXN0ZW5lcik7XG4gICAgKF9hID0gc2NvcGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNjb3BlLmNsZWFudXBzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucHVzaChfb2ZmKTtcbiAgICByZXR1cm4gX29mZjtcbiAgfVxuICBmdW5jdGlvbiBvbmNlKGxpc3RlbmVyKSB7XG4gICAgZnVuY3Rpb24gX2xpc3RlbmVyKC4uLmFyZ3MpIHtcbiAgICAgIG9mZihfbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXIoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBvbihfbGlzdGVuZXIpO1xuICB9XG4gIGZ1bmN0aW9uIG9mZihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGV2ZW50cy5nZXQoa2V5KTtcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgIHJldHVybjtcbiAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICBpZiAoIWxpc3RlbmVycy5zaXplKVxuICAgICAgcmVzZXQoKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBldmVudHMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gZW1pdChldmVudCwgcGF5bG9hZCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBldmVudHMuZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKCh2KSA9PiB2KGV2ZW50LCBwYXlsb2FkKSk7XG4gIH1cbiAgcmV0dXJuIHsgb24sIG9uY2UsIG9mZiwgZW1pdCwgcmVzZXQgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5lc3RlZE9wdGlvbnMkMShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB0cnVlKVxuICAgIHJldHVybiB7fTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiB1c2VFdmVudFNvdXJjZSh1cmwsIGV2ZW50cyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZXZlbnQgPSByZWYobnVsbCk7XG4gIGNvbnN0IGRhdGEgPSByZWYobnVsbCk7XG4gIGNvbnN0IHN0YXR1cyA9IHJlZihcIkNPTk5FQ1RJTkdcIik7XG4gIGNvbnN0IGV2ZW50U291cmNlID0gcmVmKG51bGwpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IHVybFJlZiA9IHRvUmVmKHVybCk7XG4gIGNvbnN0IGxhc3RFdmVudElkID0gc2hhbGxvd1JlZihudWxsKTtcbiAgbGV0IGV4cGxpY2l0bHlDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHJldHJpZWQgPSAwO1xuICBjb25zdCB7XG4gICAgd2l0aENyZWRlbnRpYWxzID0gZmFsc2UsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKGlzQ2xpZW50ICYmIGV2ZW50U291cmNlLnZhbHVlKSB7XG4gICAgICBldmVudFNvdXJjZS52YWx1ZS5jbG9zZSgpO1xuICAgICAgZXZlbnRTb3VyY2UudmFsdWUgPSBudWxsO1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJDTE9TRURcIjtcbiAgICAgIGV4cGxpY2l0bHlDbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgX2luaXQgPSAoKSA9PiB7XG4gICAgaWYgKGV4cGxpY2l0bHlDbG9zZWQgfHwgdHlwZW9mIHVybFJlZi52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlcyA9IG5ldyBFdmVudFNvdXJjZSh1cmxSZWYudmFsdWUsIHsgd2l0aENyZWRlbnRpYWxzIH0pO1xuICAgIHN0YXR1cy52YWx1ZSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIGV2ZW50U291cmNlLnZhbHVlID0gZXM7XG4gICAgZXMub25vcGVuID0gKCkgPT4ge1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJPUEVOXCI7XG4gICAgICBlcnJvci52YWx1ZSA9IG51bGw7XG4gICAgfTtcbiAgICBlcy5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiQ0xPU0VEXCI7XG4gICAgICBlcnJvci52YWx1ZSA9IGU7XG4gICAgICBpZiAoZXMucmVhZHlTdGF0ZSA9PT0gMiAmJiAhZXhwbGljaXRseUNsb3NlZCAmJiBvcHRpb25zLmF1dG9SZWNvbm5lY3QpIHtcbiAgICAgICAgZXMuY2xvc2UoKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJldHJpZXMgPSAtMSxcbiAgICAgICAgICBkZWxheSA9IDFlMyxcbiAgICAgICAgICBvbkZhaWxlZFxuICAgICAgICB9ID0gcmVzb2x2ZU5lc3RlZE9wdGlvbnMkMShvcHRpb25zLmF1dG9SZWNvbm5lY3QpO1xuICAgICAgICByZXRyaWVkICs9IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0cmllcyA9PT0gXCJudW1iZXJcIiAmJiAocmV0cmllcyA8IDAgfHwgcmV0cmllZCA8IHJldHJpZXMpKVxuICAgICAgICAgIHNldFRpbWVvdXQoX2luaXQsIGRlbGF5KTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJldHJpZXMgPT09IFwiZnVuY3Rpb25cIiAmJiByZXRyaWVzKCkpXG4gICAgICAgICAgc2V0VGltZW91dChfaW5pdCwgZGVsYXkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb25GYWlsZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmFpbGVkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlcy5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgZXZlbnQudmFsdWUgPSBudWxsO1xuICAgICAgZGF0YS52YWx1ZSA9IGUuZGF0YTtcbiAgICAgIGxhc3RFdmVudElkLnZhbHVlID0gZS5sYXN0RXZlbnRJZDtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZXZlbnRfbmFtZSBvZiBldmVudHMpIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoZXMsIGV2ZW50X25hbWUsIChlKSA9PiB7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gZXZlbnRfbmFtZTtcbiAgICAgICAgZGF0YS52YWx1ZSA9IGUuZGF0YSB8fCBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvcGVuID0gKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQpXG4gICAgICByZXR1cm47XG4gICAgY2xvc2UoKTtcbiAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgcmV0cmllZCA9IDA7XG4gICAgX2luaXQoKTtcbiAgfTtcbiAgaWYgKGltbWVkaWF0ZSlcbiAgICB3YXRjaCh1cmxSZWYsIG9wZW4sIHsgaW1tZWRpYXRlOiB0cnVlIH0pO1xuICB0cnlPblNjb3BlRGlzcG9zZShjbG9zZSk7XG4gIHJldHVybiB7XG4gICAgZXZlbnRTb3VyY2UsXG4gICAgZXZlbnQsXG4gICAgZGF0YSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gICAgb3BlbixcbiAgICBjbG9zZSxcbiAgICBsYXN0RXZlbnRJZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VFeWVEcm9wcGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGluaXRpYWxWYWx1ZSA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJFeWVEcm9wcGVyXCIgaW4gd2luZG93KTtcbiAgY29uc3Qgc1JHQkhleCA9IHJlZihpbml0aWFsVmFsdWUpO1xuICBhc3luYyBmdW5jdGlvbiBvcGVuKG9wZW5PcHRpb25zKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBleWVEcm9wcGVyID0gbmV3IHdpbmRvdy5FeWVEcm9wcGVyKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXllRHJvcHBlci5vcGVuKG9wZW5PcHRpb25zKTtcbiAgICBzUkdCSGV4LnZhbHVlID0gcmVzdWx0LnNSR0JIZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4geyBpc1N1cHBvcnRlZCwgc1JHQkhleCwgb3BlbiB9O1xufVxuXG5mdW5jdGlvbiB1c2VGYXZpY29uKG5ld0ljb24gPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwgPSBcIlwiLFxuICAgIHJlbCA9IFwiaWNvblwiLFxuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBmYXZpY29uID0gdG9SZWYobmV3SWNvbik7XG4gIGNvbnN0IGFwcGx5SWNvbiA9IChpY29uKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yQWxsKGBsaW5rW3JlbCo9XCIke3JlbH1cIl1gKTtcbiAgICBpZiAoIWVsZW1lbnRzIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgIGxpbmsucmVsID0gcmVsO1xuICAgICAgICBsaW5rLmhyZWYgPSBgJHtiYXNlVXJsfSR7aWNvbn1gO1xuICAgICAgICBsaW5rLnR5cGUgPSBgaW1hZ2UvJHtpY29uLnNwbGl0KFwiLlwiKS5wb3AoKX1gO1xuICAgICAgICBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQuaGVhZC5hcHBlbmQobGluayk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4gZWwuaHJlZiA9IGAke2Jhc2VVcmx9JHtpY29ufWApO1xuICB9O1xuICB3YXRjaChcbiAgICBmYXZpY29uLFxuICAgIChpLCBvKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkgPT09IFwic3RyaW5nXCIgJiYgaSAhPT0gbylcbiAgICAgICAgYXBwbHlJY29uKGkpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICByZXR1cm4gZmF2aWNvbjtcbn1cblxuY29uc3QgcGF5bG9hZE1hcHBpbmcgPSB7XG4gIGpzb246IFwiYXBwbGljYXRpb24vanNvblwiLFxuICB0ZXh0OiBcInRleHQvcGxhaW5cIlxufTtcbmZ1bmN0aW9uIGlzRmV0Y2hPcHRpb25zKG9iaikge1xuICByZXR1cm4gb2JqICYmIGNvbnRhaW5zUHJvcChvYmosIFwiaW1tZWRpYXRlXCIsIFwicmVmZXRjaFwiLCBcImluaXRpYWxEYXRhXCIsIFwidGltZW91dFwiLCBcImJlZm9yZUZldGNoXCIsIFwiYWZ0ZXJGZXRjaFwiLCBcIm9uRmV0Y2hFcnJvclwiLCBcImZldGNoXCIsIFwidXBkYXRlRGF0YU9uRXJyb3JcIik7XG59XG5jb25zdCByZUFic29sdXRlID0gL14oPzpbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2k7XG5mdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICByZXR1cm4gcmVBYnNvbHV0ZS50ZXN0KHVybCk7XG59XG5mdW5jdGlvbiBoZWFkZXJzVG9PYmplY3QoaGVhZGVycykge1xuICBpZiAodHlwZW9mIEhlYWRlcnMgIT09IFwidW5kZWZpbmVkXCIgJiYgaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzLmVudHJpZXMoKSk7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gY29tYmluZUNhbGxiYWNrcyhjb21iaW5hdGlvbiwgLi4uY2FsbGJhY2tzKSB7XG4gIGlmIChjb21iaW5hdGlvbiA9PT0gXCJvdmVyd3JpdGVcIikge1xuICAgIHJldHVybiBhc3luYyAoY3R4KSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tjYWxsYmFja3MubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB7IC4uLmN0eCwgLi4uYXdhaXQgY2FsbGJhY2soY3R4KSB9O1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3luYyAoY3R4KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgY3R4ID0geyAuLi5jdHgsIC4uLmF3YWl0IGNhbGxiYWNrKGN0eCkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2goY29uZmlnID0ge30pIHtcbiAgY29uc3QgX2NvbWJpbmF0aW9uID0gY29uZmlnLmNvbWJpbmF0aW9uIHx8IFwiY2hhaW5cIjtcbiAgY29uc3QgX29wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgX2ZldGNoT3B0aW9ucyA9IGNvbmZpZy5mZXRjaE9wdGlvbnMgfHwge307XG4gIGZ1bmN0aW9uIHVzZUZhY3RvcnlGZXRjaCh1cmwsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb21wdXRlZFVybCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSB0b1ZhbHVlKGNvbmZpZy5iYXNlVXJsKTtcbiAgICAgIGNvbnN0IHRhcmdldFVybCA9IHRvVmFsdWUodXJsKTtcbiAgICAgIHJldHVybiBiYXNlVXJsICYmICFpc0Fic29sdXRlVVJMKHRhcmdldFVybCkgPyBqb2luUGF0aHMoYmFzZVVybCwgdGFyZ2V0VXJsKSA6IHRhcmdldFVybDtcbiAgICB9KTtcbiAgICBsZXQgb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIGxldCBmZXRjaE9wdGlvbnMgPSBfZmV0Y2hPcHRpb25zO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChpc0ZldGNoT3B0aW9ucyhhcmdzWzBdKSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uYXJnc1swXSxcbiAgICAgICAgICBiZWZvcmVGZXRjaDogY29tYmluZUNhbGxiYWNrcyhfY29tYmluYXRpb24sIF9vcHRpb25zLmJlZm9yZUZldGNoLCBhcmdzWzBdLmJlZm9yZUZldGNoKSxcbiAgICAgICAgICBhZnRlckZldGNoOiBjb21iaW5lQ2FsbGJhY2tzKF9jb21iaW5hdGlvbiwgX29wdGlvbnMuYWZ0ZXJGZXRjaCwgYXJnc1swXS5hZnRlckZldGNoKSxcbiAgICAgICAgICBvbkZldGNoRXJyb3I6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5vbkZldGNoRXJyb3IsIGFyZ3NbMF0ub25GZXRjaEVycm9yKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hPcHRpb25zID0ge1xuICAgICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAuLi5hcmdzWzBdLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIC4uLmhlYWRlcnNUb09iamVjdChmZXRjaE9wdGlvbnMuaGVhZGVycykgfHwge30sXG4gICAgICAgICAgICAuLi5oZWFkZXJzVG9PYmplY3QoYXJnc1swXS5oZWFkZXJzKSB8fCB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSAmJiBpc0ZldGNoT3B0aW9ucyhhcmdzWzFdKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4uYXJnc1sxXSxcbiAgICAgICAgYmVmb3JlRmV0Y2g6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5iZWZvcmVGZXRjaCwgYXJnc1sxXS5iZWZvcmVGZXRjaCksXG4gICAgICAgIGFmdGVyRmV0Y2g6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5hZnRlckZldGNoLCBhcmdzWzFdLmFmdGVyRmV0Y2gpLFxuICAgICAgICBvbkZldGNoRXJyb3I6IGNvbWJpbmVDYWxsYmFja3MoX2NvbWJpbmF0aW9uLCBfb3B0aW9ucy5vbkZldGNoRXJyb3IsIGFyZ3NbMV0ub25GZXRjaEVycm9yKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZUZldGNoKGNvbXB1dGVkVXJsLCBmZXRjaE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB1c2VGYWN0b3J5RmV0Y2g7XG59XG5mdW5jdGlvbiB1c2VGZXRjaCh1cmwsIC4uLmFyZ3MpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBzdXBwb3J0c0Fib3J0ID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gXCJmdW5jdGlvblwiO1xuICBsZXQgZmV0Y2hPcHRpb25zID0ge307XG4gIGxldCBvcHRpb25zID0ge1xuICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICByZWZldGNoOiBmYWxzZSxcbiAgICB0aW1lb3V0OiAwLFxuICAgIHVwZGF0ZURhdGFPbkVycm9yOiBmYWxzZVxuICB9O1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIHBheWxvYWQ6IHZvaWQgMFxuICB9O1xuICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGlzRmV0Y2hPcHRpb25zKGFyZ3NbMF0pKVxuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgLi4uYXJnc1swXSB9O1xuICAgIGVsc2VcbiAgICAgIGZldGNoT3B0aW9ucyA9IGFyZ3NbMF07XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgIGlmIChpc0ZldGNoT3B0aW9ucyhhcmdzWzFdKSlcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIC4uLmFyZ3NbMV0gfTtcbiAgfVxuICBjb25zdCB7XG4gICAgZmV0Y2ggPSAoX2EgPSBkZWZhdWx0V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmV0Y2gsXG4gICAgaW5pdGlhbERhdGEsXG4gICAgdGltZW91dFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVzcG9uc2VFdmVudCA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBlcnJvckV2ZW50ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IGZpbmFsbHlFdmVudCA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBpc0ZpbmlzaGVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgaXNGZXRjaGluZyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGFib3J0ZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCBzdGF0dXNDb2RlID0gcmVmKG51bGwpO1xuICBjb25zdCByZXNwb25zZSA9IHNoYWxsb3dSZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgZGF0YSA9IHNoYWxsb3dSZWYoaW5pdGlhbERhdGEgfHwgbnVsbCk7XG4gIGNvbnN0IGNhbkFib3J0ID0gY29tcHV0ZWQoKCkgPT4gc3VwcG9ydHNBYm9ydCAmJiBpc0ZldGNoaW5nLnZhbHVlKTtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGxldCB0aW1lcjtcbiAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzQWJvcnQpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb250cm9sbGVyLnNpZ25hbC5vbmFib3J0ID0gKCkgPT4gYWJvcnRlZC52YWx1ZSA9IHRydWU7XG4gICAgICBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxvYWRpbmcgPSAoaXNMb2FkaW5nKSA9PiB7XG4gICAgaXNGZXRjaGluZy52YWx1ZSA9IGlzTG9hZGluZztcbiAgICBpc0ZpbmlzaGVkLnZhbHVlID0gIWlzTG9hZGluZztcbiAgfTtcbiAgaWYgKHRpbWVvdXQpXG4gICAgdGltZXIgPSB1c2VUaW1lb3V0Rm4oYWJvcnQsIHRpbWVvdXQsIHsgaW1tZWRpYXRlOiBmYWxzZSB9KTtcbiAgbGV0IGV4ZWN1dGVDb3VudGVyID0gMDtcbiAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICh0aHJvd09uRmFpbGVkID0gZmFsc2UpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICBhYm9ydCgpO1xuICAgIGxvYWRpbmcodHJ1ZSk7XG4gICAgZXJyb3IudmFsdWUgPSBudWxsO1xuICAgIHN0YXR1c0NvZGUudmFsdWUgPSBudWxsO1xuICAgIGFib3J0ZWQudmFsdWUgPSBmYWxzZTtcbiAgICBleGVjdXRlQ291bnRlciArPSAxO1xuICAgIGNvbnN0IGN1cnJlbnRFeGVjdXRlQ291bnRlciA9IGV4ZWN1dGVDb3VudGVyO1xuICAgIGNvbnN0IGRlZmF1bHRGZXRjaE9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fVxuICAgIH07XG4gICAgaWYgKGNvbmZpZy5wYXlsb2FkKSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gaGVhZGVyc1RvT2JqZWN0KGRlZmF1bHRGZXRjaE9wdGlvbnMuaGVhZGVycyk7XG4gICAgICBjb25zdCBwYXlsb2FkID0gdG9WYWx1ZShjb25maWcucGF5bG9hZCk7XG4gICAgICBpZiAoIWNvbmZpZy5wYXlsb2FkVHlwZSAmJiBwYXlsb2FkICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXlsb2FkKSA9PT0gT2JqZWN0LnByb3RvdHlwZSAmJiAhKHBheWxvYWQgaW5zdGFuY2VvZiBGb3JtRGF0YSkpXG4gICAgICAgIGNvbmZpZy5wYXlsb2FkVHlwZSA9IFwianNvblwiO1xuICAgICAgaWYgKGNvbmZpZy5wYXlsb2FkVHlwZSlcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IChfYTIgPSBwYXlsb2FkTWFwcGluZ1tjb25maWcucGF5bG9hZFR5cGVdKSAhPSBudWxsID8gX2EyIDogY29uZmlnLnBheWxvYWRUeXBlO1xuICAgICAgZGVmYXVsdEZldGNoT3B0aW9ucy5ib2R5ID0gY29uZmlnLnBheWxvYWRUeXBlID09PSBcImpzb25cIiA/IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgdXJsOiB0b1ZhbHVlKHVybCksXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRGZXRjaE9wdGlvbnMsXG4gICAgICAgIC4uLmZldGNoT3B0aW9uc1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICBpc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmJlZm9yZUZldGNoKVxuICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LCBhd2FpdCBvcHRpb25zLmJlZm9yZUZldGNoKGNvbnRleHQpKTtcbiAgICBpZiAoaXNDYW5jZWxlZCB8fCAhZmV0Y2gpIHtcbiAgICAgIGxvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IG51bGw7XG4gICAgaWYgKHRpbWVyKVxuICAgICAgdGltZXIuc3RhcnQoKTtcbiAgICByZXR1cm4gZmV0Y2goXG4gICAgICBjb250ZXh0LnVybCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGVmYXVsdEZldGNoT3B0aW9ucyxcbiAgICAgICAgLi4uY29udGV4dC5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KGRlZmF1bHRGZXRjaE9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgICAgLi4uaGVhZGVyc1RvT2JqZWN0KChfYiA9IGNvbnRleHQub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLnRoZW4oYXN5bmMgKGZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgIHJlc3BvbnNlLnZhbHVlID0gZmV0Y2hSZXNwb25zZTtcbiAgICAgIHN0YXR1c0NvZGUudmFsdWUgPSBmZXRjaFJlc3BvbnNlLnN0YXR1cztcbiAgICAgIHJlc3BvbnNlRGF0YSA9IGF3YWl0IGZldGNoUmVzcG9uc2UuY2xvbmUoKVtjb25maWcudHlwZV0oKTtcbiAgICAgIGlmICghZmV0Y2hSZXNwb25zZS5vaykge1xuICAgICAgICBkYXRhLnZhbHVlID0gaW5pdGlhbERhdGEgfHwgbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hZnRlckZldGNoKSB7XG4gICAgICAgICh7IGRhdGE6IHJlc3BvbnNlRGF0YSB9ID0gYXdhaXQgb3B0aW9ucy5hZnRlckZldGNoKHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgcmVzcG9uc2U6IGZldGNoUmVzcG9uc2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgZGF0YS52YWx1ZSA9IHJlc3BvbnNlRGF0YTtcbiAgICAgIHJlc3BvbnNlRXZlbnQudHJpZ2dlcihmZXRjaFJlc3BvbnNlKTtcbiAgICAgIHJldHVybiBmZXRjaFJlc3BvbnNlO1xuICAgIH0pLmNhdGNoKGFzeW5jIChmZXRjaEVycm9yKSA9PiB7XG4gICAgICBsZXQgZXJyb3JEYXRhID0gZmV0Y2hFcnJvci5tZXNzYWdlIHx8IGZldGNoRXJyb3IubmFtZTtcbiAgICAgIGlmIChvcHRpb25zLm9uRmV0Y2hFcnJvcikge1xuICAgICAgICAoeyBlcnJvcjogZXJyb3JEYXRhLCBkYXRhOiByZXNwb25zZURhdGEgfSA9IGF3YWl0IG9wdGlvbnMub25GZXRjaEVycm9yKHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgZXJyb3I6IGZldGNoRXJyb3IsXG4gICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLnZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGVycm9yLnZhbHVlID0gZXJyb3JEYXRhO1xuICAgICAgaWYgKG9wdGlvbnMudXBkYXRlRGF0YU9uRXJyb3IpXG4gICAgICAgIGRhdGEudmFsdWUgPSByZXNwb25zZURhdGE7XG4gICAgICBlcnJvckV2ZW50LnRyaWdnZXIoZmV0Y2hFcnJvcik7XG4gICAgICBpZiAodGhyb3dPbkZhaWxlZClcbiAgICAgICAgdGhyb3cgZmV0Y2hFcnJvcjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnRFeGVjdXRlQ291bnRlciA9PT0gZXhlY3V0ZUNvdW50ZXIpXG4gICAgICAgIGxvYWRpbmcoZmFsc2UpO1xuICAgICAgaWYgKHRpbWVyKVxuICAgICAgICB0aW1lci5zdG9wKCk7XG4gICAgICBmaW5hbGx5RXZlbnQudHJpZ2dlcihudWxsKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgcmVmZXRjaCA9IHRvUmVmKG9wdGlvbnMucmVmZXRjaCk7XG4gIHdhdGNoKFxuICAgIFtcbiAgICAgIHJlZmV0Y2gsXG4gICAgICB0b1JlZih1cmwpXG4gICAgXSxcbiAgICAoW3JlZmV0Y2gyXSkgPT4gcmVmZXRjaDIgJiYgZXhlY3V0ZSgpLFxuICAgIHsgZGVlcDogdHJ1ZSB9XG4gICk7XG4gIGNvbnN0IHNoZWxsID0ge1xuICAgIGlzRmluaXNoZWQ6IHJlYWRvbmx5KGlzRmluaXNoZWQpLFxuICAgIGlzRmV0Y2hpbmc6IHJlYWRvbmx5KGlzRmV0Y2hpbmcpLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2UsXG4gICAgZXJyb3IsXG4gICAgZGF0YSxcbiAgICBjYW5BYm9ydCxcbiAgICBhYm9ydGVkLFxuICAgIGFib3J0LFxuICAgIGV4ZWN1dGUsXG4gICAgb25GZXRjaFJlc3BvbnNlOiByZXNwb25zZUV2ZW50Lm9uLFxuICAgIG9uRmV0Y2hFcnJvcjogZXJyb3JFdmVudC5vbixcbiAgICBvbkZldGNoRmluYWxseTogZmluYWxseUV2ZW50Lm9uLFxuICAgIC8vIG1ldGhvZFxuICAgIGdldDogc2V0TWV0aG9kKFwiR0VUXCIpLFxuICAgIHB1dDogc2V0TWV0aG9kKFwiUFVUXCIpLFxuICAgIHBvc3Q6IHNldE1ldGhvZChcIlBPU1RcIiksXG4gICAgZGVsZXRlOiBzZXRNZXRob2QoXCJERUxFVEVcIiksXG4gICAgcGF0Y2g6IHNldE1ldGhvZChcIlBBVENIXCIpLFxuICAgIGhlYWQ6IHNldE1ldGhvZChcIkhFQURcIiksXG4gICAgb3B0aW9uczogc2V0TWV0aG9kKFwiT1BUSU9OU1wiKSxcbiAgICAvLyB0eXBlXG4gICAganNvbjogc2V0VHlwZShcImpzb25cIiksXG4gICAgdGV4dDogc2V0VHlwZShcInRleHRcIiksXG4gICAgYmxvYjogc2V0VHlwZShcImJsb2JcIiksXG4gICAgYXJyYXlCdWZmZXI6IHNldFR5cGUoXCJhcnJheUJ1ZmZlclwiKSxcbiAgICBmb3JtRGF0YTogc2V0VHlwZShcImZvcm1EYXRhXCIpXG4gIH07XG4gIGZ1bmN0aW9uIHNldE1ldGhvZChtZXRob2QpIHtcbiAgICByZXR1cm4gKHBheWxvYWQsIHBheWxvYWRUeXBlKSA9PiB7XG4gICAgICBpZiAoIWlzRmV0Y2hpbmcudmFsdWUpIHtcbiAgICAgICAgY29uZmlnLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgY29uZmlnLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICBjb25maWcucGF5bG9hZFR5cGUgPSBwYXlsb2FkVHlwZTtcbiAgICAgICAgaWYgKGlzUmVmKGNvbmZpZy5wYXlsb2FkKSkge1xuICAgICAgICAgIHdhdGNoKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICByZWZldGNoLFxuICAgICAgICAgICAgICB0b1JlZihjb25maWcucGF5bG9hZClcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAoW3JlZmV0Y2gyXSkgPT4gcmVmZXRjaDIgJiYgZXhlY3V0ZSgpLFxuICAgICAgICAgICAgeyBkZWVwOiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2hlbGwsXG4gICAgICAgICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHdhaXRVbnRpbEZpbmlzaGVkKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHdhaXRVbnRpbEZpbmlzaGVkKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1bnRpbChpc0ZpbmlzaGVkKS50b0JlKHRydWUpLnRoZW4oKCkgPT4gcmVzb2x2ZShzaGVsbCkpLmNhdGNoKChlcnJvcjIpID0+IHJlamVjdChlcnJvcjIpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFpc0ZldGNoaW5nLnZhbHVlKSB7XG4gICAgICAgIGNvbmZpZy50eXBlID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zaGVsbCxcbiAgICAgICAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKVxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZXhlY3V0ZSgpKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5zaGVsbCxcbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gd2FpdFVudGlsRmluaXNoZWQoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBqb2luUGF0aHMoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0LmVuZHNXaXRoKFwiL1wiKSAmJiAhZW5kLnN0YXJ0c1dpdGgoXCIvXCIpKVxuICAgIHJldHVybiBgJHtzdGFydH0vJHtlbmR9YDtcbiAgcmV0dXJuIGAke3N0YXJ0fSR7ZW5kfWA7XG59XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgbXVsdGlwbGU6IHRydWUsXG4gIGFjY2VwdDogXCIqXCIsXG4gIHJlc2V0OiBmYWxzZSxcbiAgZGlyZWN0b3J5OiBmYWxzZVxufTtcbmZ1bmN0aW9uIHVzZUZpbGVEaWFsb2cob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmlsZXMgPSByZWYobnVsbCk7XG4gIGNvbnN0IHsgb246IG9uQ2hhbmdlLCB0cmlnZ2VyIH0gPSBjcmVhdGVFdmVudEhvb2soKTtcbiAgbGV0IGlucHV0O1xuICBpZiAoZG9jdW1lbnQpIHtcbiAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQub25jaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZpbGVzLnZhbHVlID0gcmVzdWx0LmZpbGVzO1xuICAgICAgdHJpZ2dlcihmaWxlcy52YWx1ZSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBmaWxlcy52YWx1ZSA9IG51bGw7XG4gICAgaWYgKGlucHV0ICYmIGlucHV0LnZhbHVlKSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICB0cmlnZ2VyKG51bGwpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb3BlbiA9IChsb2NhbE9wdGlvbnMpID0+IHtcbiAgICBpZiAoIWlucHV0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IF9vcHRpb25zID0ge1xuICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC4uLmxvY2FsT3B0aW9uc1xuICAgIH07XG4gICAgaW5wdXQubXVsdGlwbGUgPSBfb3B0aW9ucy5tdWx0aXBsZTtcbiAgICBpbnB1dC5hY2NlcHQgPSBfb3B0aW9ucy5hY2NlcHQ7XG4gICAgaW5wdXQud2Via2l0ZGlyZWN0b3J5ID0gX29wdGlvbnMuZGlyZWN0b3J5O1xuICAgIGlmIChoYXNPd24oX29wdGlvbnMsIFwiY2FwdHVyZVwiKSlcbiAgICAgIGlucHV0LmNhcHR1cmUgPSBfb3B0aW9ucy5jYXB0dXJlO1xuICAgIGlmIChfb3B0aW9ucy5yZXNldClcbiAgICAgIHJlc2V0KCk7XG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBmaWxlczogcmVhZG9ubHkoZmlsZXMpLFxuICAgIG9wZW4sXG4gICAgcmVzZXQsXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRmlsZVN5c3RlbUFjY2VzcyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdzogX3dpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgZGF0YVR5cGUgPSBcIlRleHRcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2luZG93ID0gX3dpbmRvdztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gd2luZG93ICYmIFwic2hvd1NhdmVGaWxlUGlja2VyXCIgaW4gd2luZG93ICYmIFwic2hvd09wZW5GaWxlUGlja2VyXCIgaW4gd2luZG93KTtcbiAgY29uc3QgZmlsZUhhbmRsZSA9IHJlZigpO1xuICBjb25zdCBkYXRhID0gcmVmKCk7XG4gIGNvbnN0IGZpbGUgPSByZWYoKTtcbiAgY29uc3QgZmlsZU5hbWUgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZmlsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gIH0pO1xuICBjb25zdCBmaWxlTUlNRSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHlwZSkgIT0gbnVsbCA/IF9iIDogXCJcIjtcbiAgfSk7XG4gIGNvbnN0IGZpbGVTaXplID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGZpbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaXplKSAhPSBudWxsID8gX2IgOiAwO1xuICB9KTtcbiAgY29uc3QgZmlsZUxhc3RNb2RpZmllZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGFzdE1vZGlmaWVkKSAhPSBudWxsID8gX2IgOiAwO1xuICB9KTtcbiAgYXN5bmMgZnVuY3Rpb24gb3Blbihfb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbaGFuZGxlXSA9IGF3YWl0IHdpbmRvdy5zaG93T3BlbkZpbGVQaWNrZXIoeyAuLi50b1ZhbHVlKG9wdGlvbnMpLCAuLi5fb3B0aW9ucyB9KTtcbiAgICBmaWxlSGFuZGxlLnZhbHVlID0gaGFuZGxlO1xuICAgIGF3YWl0IHVwZGF0ZURhdGEoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGUoX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgZmlsZUhhbmRsZS52YWx1ZSA9IGF3YWl0IHdpbmRvdy5zaG93U2F2ZUZpbGVQaWNrZXIoeyAuLi5vcHRpb25zLCAuLi5fb3B0aW9ucyB9KTtcbiAgICBkYXRhLnZhbHVlID0gdm9pZCAwO1xuICAgIGF3YWl0IHVwZGF0ZURhdGEoKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzYXZlKF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghZmlsZUhhbmRsZS52YWx1ZSlcbiAgICAgIHJldHVybiBzYXZlQXMoX29wdGlvbnMpO1xuICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IGF3YWl0IGZpbGVIYW5kbGUudmFsdWUuY3JlYXRlV3JpdGFibGUoKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLndyaXRlKGRhdGEudmFsdWUpO1xuICAgICAgYXdhaXQgd3JpdGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gICAgYXdhaXQgdXBkYXRlRmlsZSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHNhdmVBcyhfb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBmaWxlSGFuZGxlLnZhbHVlID0gYXdhaXQgd2luZG93LnNob3dTYXZlRmlsZVBpY2tlcih7IC4uLm9wdGlvbnMsIC4uLl9vcHRpb25zIH0pO1xuICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IGF3YWl0IGZpbGVIYW5kbGUudmFsdWUuY3JlYXRlV3JpdGFibGUoKTtcbiAgICAgIGF3YWl0IHdyaXRhYmxlU3RyZWFtLndyaXRlKGRhdGEudmFsdWUpO1xuICAgICAgYXdhaXQgd3JpdGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gICAgYXdhaXQgdXBkYXRlRmlsZSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUZpbGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGZpbGUudmFsdWUgPSBhd2FpdCAoKF9hID0gZmlsZUhhbmRsZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEZpbGUoKSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRGF0YSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGF3YWl0IHVwZGF0ZUZpbGUoKTtcbiAgICBjb25zdCB0eXBlID0gdG9WYWx1ZShkYXRhVHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwiVGV4dFwiKVxuICAgICAgZGF0YS52YWx1ZSA9IGF3YWl0ICgoX2EgPSBmaWxlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCgpKTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5QnVmZmVyXCIpXG4gICAgICBkYXRhLnZhbHVlID0gYXdhaXQgKChfYiA9IGZpbGUudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcnJheUJ1ZmZlcigpKTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkJsb2JcIilcbiAgICAgIGRhdGEudmFsdWUgPSBmaWxlLnZhbHVlO1xuICB9XG4gIHdhdGNoKCgpID0+IHRvVmFsdWUoZGF0YVR5cGUpLCB1cGRhdGVEYXRhKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBkYXRhLFxuICAgIGZpbGUsXG4gICAgZmlsZU5hbWUsXG4gICAgZmlsZU1JTUUsXG4gICAgZmlsZVNpemUsXG4gICAgZmlsZUxhc3RNb2RpZmllZCxcbiAgICBvcGVuLFxuICAgIGNyZWF0ZSxcbiAgICBzYXZlLFxuICAgIHNhdmVBcyxcbiAgICB1cGRhdGVEYXRhXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZvY3VzKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgaW5pdGlhbFZhbHVlID0gZmFsc2UsIGZvY3VzVmlzaWJsZSA9IGZhbHNlLCBwcmV2ZW50U2Nyb2xsID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyRm9jdXNlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjb21wdXRlZCgoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0KSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgXCJmb2N1c1wiLCAoZXZlbnQpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghZm9jdXNWaXNpYmxlIHx8ICgoX2IgPSAoX2EgPSBldmVudC50YXJnZXQpLm1hdGNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBcIjpmb2N1cy12aXNpYmxlXCIpKSlcbiAgICAgIGlubmVyRm9jdXNlZC52YWx1ZSA9IHRydWU7XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsIFwiYmx1clwiLCAoKSA9PiBpbm5lckZvY3VzZWQudmFsdWUgPSBmYWxzZSk7XG4gIGNvbnN0IGZvY3VzZWQgPSBjb21wdXRlZCh7XG4gICAgZ2V0OiAoKSA9PiBpbm5lckZvY3VzZWQudmFsdWUsXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKCF2YWx1ZSAmJiBpbm5lckZvY3VzZWQudmFsdWUpXG4gICAgICAgIChfYSA9IHRhcmdldEVsZW1lbnQudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ibHVyKCk7XG4gICAgICBlbHNlIGlmICh2YWx1ZSAmJiAhaW5uZXJGb2N1c2VkLnZhbHVlKVxuICAgICAgICAoX2IgPSB0YXJnZXRFbGVtZW50LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsIH0pO1xuICAgIH1cbiAgfSk7XG4gIHdhdGNoKFxuICAgIHRhcmdldEVsZW1lbnQsXG4gICAgKCkgPT4ge1xuICAgICAgZm9jdXNlZC52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlLCBmbHVzaDogXCJwb3N0XCIgfVxuICApO1xuICByZXR1cm4geyBmb2N1c2VkIH07XG59XG5cbmZ1bmN0aW9uIHVzZUZvY3VzV2l0aGluKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB1c2VBY3RpdmVFbGVtZW50KG9wdGlvbnMpO1xuICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KHRhcmdldCkpO1xuICBjb25zdCBmb2N1c2VkID0gY29tcHV0ZWQoKCkgPT4gdGFyZ2V0RWxlbWVudC52YWx1ZSAmJiBhY3RpdmVFbGVtZW50LnZhbHVlID8gdGFyZ2V0RWxlbWVudC52YWx1ZS5jb250YWlucyhhY3RpdmVFbGVtZW50LnZhbHVlKSA6IGZhbHNlKTtcbiAgcmV0dXJuIHsgZm9jdXNlZCB9O1xufVxuXG5mdW5jdGlvbiB1c2VGcHMob3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGZwcyA9IHJlZigwKTtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm4gZnBzO1xuICBjb25zdCBldmVyeSA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlcnkpICE9IG51bGwgPyBfYSA6IDEwO1xuICBsZXQgbGFzdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBsZXQgdGlja3MgPSAwO1xuICB1c2VSYWZGbigoKSA9PiB7XG4gICAgdGlja3MgKz0gMTtcbiAgICBpZiAodGlja3MgPj0gZXZlcnkpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZGlmZiA9IG5vdyAtIGxhc3Q7XG4gICAgICBmcHMudmFsdWUgPSBNYXRoLnJvdW5kKDFlMyAvIChkaWZmIC8gdGlja3MpKTtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgICB0aWNrcyA9IDA7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZwcztcbn1cblxuY29uc3QgZXZlbnRIYW5kbGVycyA9IFtcbiAgXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gIFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICBcIndlYmtpdGVuZGZ1bGxzY3JlZW5cIixcbiAgXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsXG4gIFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCJcbl07XG5mdW5jdGlvbiB1c2VGdWxsc2NyZWVuKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBhdXRvRXhpdCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB0YXJnZXRSZWYgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB1bnJlZkVsZW1lbnQodGFyZ2V0KSkgIT0gbnVsbCA/IF9hIDogZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpO1xuICB9KTtcbiAgY29uc3QgaXNGdWxsc2NyZWVuID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgcmVxdWVzdE1ldGhvZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJyZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFbnRlckZ1bGxzY3JlZW5cIixcbiAgICAgIFwid2Via2l0RW50ZXJGdWxsU2NyZWVuXCIsXG4gICAgICBcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1velJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIlxuICAgIF0uZmluZCgobSkgPT4gZG9jdW1lbnQgJiYgbSBpbiBkb2N1bWVudCB8fCB0YXJnZXRSZWYudmFsdWUgJiYgbSBpbiB0YXJnZXRSZWYudmFsdWUpO1xuICB9KTtcbiAgY29uc3QgZXhpdE1ldGhvZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJleGl0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFeGl0RnVsbHNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRFeGl0RnVsbFNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1vekNhbmNlbEZ1bGxTY3JlZW5cIixcbiAgICAgIFwibXNFeGl0RnVsbHNjcmVlblwiXG4gICAgXS5maW5kKChtKSA9PiBkb2N1bWVudCAmJiBtIGluIGRvY3VtZW50IHx8IHRhcmdldFJlZi52YWx1ZSAmJiBtIGluIHRhcmdldFJlZi52YWx1ZSk7XG4gIH0pO1xuICBjb25zdCBmdWxsc2NyZWVuRW5hYmxlZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJmdWxsU2NyZWVuXCIsXG4gICAgICBcIndlYmtpdElzRnVsbFNjcmVlblwiLFxuICAgICAgXCJ3ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlblwiLFxuICAgICAgXCJtb3pGdWxsU2NyZWVuXCIsXG4gICAgICBcIm1zRnVsbHNjcmVlbkVsZW1lbnRcIlxuICAgIF0uZmluZCgobSkgPT4gZG9jdW1lbnQgJiYgbSBpbiBkb2N1bWVudCB8fCB0YXJnZXRSZWYudmFsdWUgJiYgbSBpbiB0YXJnZXRSZWYudmFsdWUpO1xuICB9KTtcbiAgY29uc3QgZnVsbHNjcmVlbkVsZW1lbnRNZXRob2QgPSBbXG4gICAgXCJmdWxsc2NyZWVuRWxlbWVudFwiLFxuICAgIFwid2Via2l0RnVsbHNjcmVlbkVsZW1lbnRcIixcbiAgICBcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCIsXG4gICAgXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCJcbiAgXS5maW5kKChtKSA9PiBkb2N1bWVudCAmJiBtIGluIGRvY3VtZW50KTtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gdGFyZ2V0UmVmLnZhbHVlICYmIGRvY3VtZW50ICYmIHJlcXVlc3RNZXRob2QudmFsdWUgIT09IHZvaWQgMCAmJiBleGl0TWV0aG9kLnZhbHVlICE9PSB2b2lkIDAgJiYgZnVsbHNjcmVlbkVuYWJsZWQudmFsdWUgIT09IHZvaWQgMCk7XG4gIGNvbnN0IGlzQ3VycmVudEVsZW1lbnRGdWxsU2NyZWVuID0gKCkgPT4ge1xuICAgIGlmIChmdWxsc2NyZWVuRWxlbWVudE1ldGhvZClcbiAgICAgIHJldHVybiAoZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50W2Z1bGxzY3JlZW5FbGVtZW50TWV0aG9kXSkgPT09IHRhcmdldFJlZi52YWx1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGlzRWxlbWVudEZ1bGxTY3JlZW4gPSAoKSA9PiB7XG4gICAgaWYgKGZ1bGxzY3JlZW5FbmFibGVkLnZhbHVlKSB7XG4gICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnRbZnVsbHNjcmVlbkVuYWJsZWQudmFsdWVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50W2Z1bGxzY3JlZW5FbmFibGVkLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldDIgPSB0YXJnZXRSZWYudmFsdWU7XG4gICAgICAgIGlmICgodGFyZ2V0MiA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0MltmdWxsc2NyZWVuRW5hYmxlZC52YWx1ZV0pICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gQm9vbGVhbih0YXJnZXQyW2Z1bGxzY3JlZW5FbmFibGVkLnZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBhc3luYyBmdW5jdGlvbiBleGl0KCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIWlzRnVsbHNjcmVlbi52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZXhpdE1ldGhvZC52YWx1ZSkge1xuICAgICAgaWYgKChkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnRbZXhpdE1ldGhvZC52YWx1ZV0pICE9IG51bGwpIHtcbiAgICAgICAgYXdhaXQgZG9jdW1lbnRbZXhpdE1ldGhvZC52YWx1ZV0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldDIgPSB0YXJnZXRSZWYudmFsdWU7XG4gICAgICAgIGlmICgodGFyZ2V0MiA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0MltleGl0TWV0aG9kLnZhbHVlXSkgIT0gbnVsbClcbiAgICAgICAgICBhd2FpdCB0YXJnZXQyW2V4aXRNZXRob2QudmFsdWVdKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlzRnVsbHNjcmVlbi52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGVudGVyKCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgaXNGdWxsc2NyZWVuLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpc0VsZW1lbnRGdWxsU2NyZWVuKCkpXG4gICAgICBhd2FpdCBleGl0KCk7XG4gICAgY29uc3QgdGFyZ2V0MiA9IHRhcmdldFJlZi52YWx1ZTtcbiAgICBpZiAocmVxdWVzdE1ldGhvZC52YWx1ZSAmJiAodGFyZ2V0MiA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0MltyZXF1ZXN0TWV0aG9kLnZhbHVlXSkgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgdGFyZ2V0MltyZXF1ZXN0TWV0aG9kLnZhbHVlXSgpO1xuICAgICAgaXNGdWxsc2NyZWVuLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIGF3YWl0IChpc0Z1bGxzY3JlZW4udmFsdWUgPyBleGl0KCkgOiBlbnRlcigpKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlID0gaXNFbGVtZW50RnVsbFNjcmVlbigpO1xuICAgIGlmICghaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlIHx8IGlzRWxlbWVudEZ1bGxTY3JlZW5WYWx1ZSAmJiBpc0N1cnJlbnRFbGVtZW50RnVsbFNjcmVlbigpKVxuICAgICAgaXNGdWxsc2NyZWVuLnZhbHVlID0gaXNFbGVtZW50RnVsbFNjcmVlblZhbHVlO1xuICB9O1xuICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBldmVudEhhbmRsZXJzLCBoYW5kbGVyQ2FsbGJhY2ssIGZhbHNlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcigoKSA9PiB1bnJlZkVsZW1lbnQodGFyZ2V0UmVmKSwgZXZlbnRIYW5kbGVycywgaGFuZGxlckNhbGxiYWNrLCBmYWxzZSk7XG4gIGlmIChhdXRvRXhpdClcbiAgICB0cnlPblNjb3BlRGlzcG9zZShleGl0KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBpc0Z1bGxzY3JlZW4sXG4gICAgZW50ZXIsXG4gICAgZXhpdCxcbiAgICB0b2dnbGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwR2FtZXBhZFRvWGJveDM2MENvbnRyb2xsZXIoZ2FtZXBhZCkge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChnYW1lcGFkLnZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgYTogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzBdLFxuICAgICAgICAgIGI6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxXSxcbiAgICAgICAgICB4OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMl0sXG4gICAgICAgICAgeTogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzNdXG4gICAgICAgIH0sXG4gICAgICAgIGJ1bXBlcjoge1xuICAgICAgICAgIGxlZnQ6IGdhbWVwYWQudmFsdWUuYnV0dG9uc1s0XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzVdXG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJzOiB7XG4gICAgICAgICAgbGVmdDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzZdLFxuICAgICAgICAgIHJpZ2h0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbN11cbiAgICAgICAgfSxcbiAgICAgICAgc3RpY2s6IHtcbiAgICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICBob3Jpem9udGFsOiBnYW1lcGFkLnZhbHVlLmF4ZXNbMF0sXG4gICAgICAgICAgICB2ZXJ0aWNhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzFdLFxuICAgICAgICAgICAgYnV0dG9uOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogZ2FtZXBhZC52YWx1ZS5heGVzWzJdLFxuICAgICAgICAgICAgdmVydGljYWw6IGdhbWVwYWQudmFsdWUuYXhlc1szXSxcbiAgICAgICAgICAgIGJ1dHRvbjogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzExXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZHBhZDoge1xuICAgICAgICAgIHVwOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbMTJdLFxuICAgICAgICAgIGRvd246IGdhbWVwYWQudmFsdWUuYnV0dG9uc1sxM10sXG4gICAgICAgICAgbGVmdDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzE0XSxcbiAgICAgICAgICByaWdodDogZ2FtZXBhZC52YWx1ZS5idXR0b25zWzE1XVxuICAgICAgICB9LFxuICAgICAgICBiYWNrOiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbOF0sXG4gICAgICAgIHN0YXJ0OiBnYW1lcGFkLnZhbHVlLmJ1dHRvbnNbOV1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUdhbWVwYWQob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJnZXRHYW1lcGFkc1wiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGdhbWVwYWRzID0gcmVmKFtdKTtcbiAgY29uc3Qgb25Db25uZWN0ZWRIb29rID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IG9uRGlzY29ubmVjdGVkSG9vayA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBzdGF0ZUZyb21HYW1lcGFkID0gKGdhbWVwYWQpID0+IHtcbiAgICBjb25zdCBoYXB0aWNBY3R1YXRvcnMgPSBbXTtcbiAgICBjb25zdCB2aWJyYXRpb25BY3R1YXRvciA9IFwidmlicmF0aW9uQWN0dWF0b3JcIiBpbiBnYW1lcGFkID8gZ2FtZXBhZC52aWJyYXRpb25BY3R1YXRvciA6IG51bGw7XG4gICAgaWYgKHZpYnJhdGlvbkFjdHVhdG9yKVxuICAgICAgaGFwdGljQWN0dWF0b3JzLnB1c2godmlicmF0aW9uQWN0dWF0b3IpO1xuICAgIGlmIChnYW1lcGFkLmhhcHRpY0FjdHVhdG9ycylcbiAgICAgIGhhcHRpY0FjdHVhdG9ycy5wdXNoKC4uLmdhbWVwYWQuaGFwdGljQWN0dWF0b3JzKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdhbWVwYWQuaWQsXG4gICAgICBpbmRleDogZ2FtZXBhZC5pbmRleCxcbiAgICAgIGNvbm5lY3RlZDogZ2FtZXBhZC5jb25uZWN0ZWQsXG4gICAgICBtYXBwaW5nOiBnYW1lcGFkLm1hcHBpbmcsXG4gICAgICB0aW1lc3RhbXA6IGdhbWVwYWQudGltZXN0YW1wLFxuICAgICAgdmlicmF0aW9uQWN0dWF0b3I6IGdhbWVwYWQudmlicmF0aW9uQWN0dWF0b3IsXG4gICAgICBoYXB0aWNBY3R1YXRvcnMsXG4gICAgICBheGVzOiBnYW1lcGFkLmF4ZXMubWFwKChheGVzKSA9PiBheGVzKSxcbiAgICAgIGJ1dHRvbnM6IGdhbWVwYWQuYnV0dG9ucy5tYXAoKGJ1dHRvbikgPT4gKHsgcHJlc3NlZDogYnV0dG9uLnByZXNzZWQsIHRvdWNoZWQ6IGJ1dHRvbi50b3VjaGVkLCB2YWx1ZTogYnV0dG9uLnZhbHVlIH0pKVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUdhbWVwYWRTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBfZ2FtZXBhZHMgPSAobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSkgfHwgW107XG4gICAgZm9yIChjb25zdCBnYW1lcGFkIG9mIF9nYW1lcGFkcykge1xuICAgICAgaWYgKGdhbWVwYWQgJiYgZ2FtZXBhZHMudmFsdWVbZ2FtZXBhZC5pbmRleF0pXG4gICAgICAgIGdhbWVwYWRzLnZhbHVlW2dhbWVwYWQuaW5kZXhdID0gc3RhdGVGcm9tR2FtZXBhZChnYW1lcGFkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHsgaXNBY3RpdmUsIHBhdXNlLCByZXN1bWUgfSA9IHVzZVJhZkZuKHVwZGF0ZUdhbWVwYWRTdGF0ZSk7XG4gIGNvbnN0IG9uR2FtZXBhZENvbm5lY3RlZCA9IChnYW1lcGFkKSA9PiB7XG4gICAgaWYgKCFnYW1lcGFkcy52YWx1ZS5zb21lKCh7IGluZGV4IH0pID0+IGluZGV4ID09PSBnYW1lcGFkLmluZGV4KSkge1xuICAgICAgZ2FtZXBhZHMudmFsdWUucHVzaChzdGF0ZUZyb21HYW1lcGFkKGdhbWVwYWQpKTtcbiAgICAgIG9uQ29ubmVjdGVkSG9vay50cmlnZ2VyKGdhbWVwYWQuaW5kZXgpO1xuICAgIH1cbiAgICByZXN1bWUoKTtcbiAgfTtcbiAgY29uc3Qgb25HYW1lcGFkRGlzY29ubmVjdGVkID0gKGdhbWVwYWQpID0+IHtcbiAgICBnYW1lcGFkcy52YWx1ZSA9IGdhbWVwYWRzLnZhbHVlLmZpbHRlcigoeCkgPT4geC5pbmRleCAhPT0gZ2FtZXBhZC5pbmRleCk7XG4gICAgb25EaXNjb25uZWN0ZWRIb29rLnRyaWdnZXIoZ2FtZXBhZC5pbmRleCk7XG4gIH07XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkY29ubmVjdGVkXCIsIChlKSA9PiBvbkdhbWVwYWRDb25uZWN0ZWQoZS5nYW1lcGFkKSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsIChlKSA9PiBvbkdhbWVwYWREaXNjb25uZWN0ZWQoZS5nYW1lcGFkKSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgY29uc3QgX2dhbWVwYWRzID0gKG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpIHx8IFtdO1xuICAgIGZvciAoY29uc3QgZ2FtZXBhZCBvZiBfZ2FtZXBhZHMpIHtcbiAgICAgIGlmIChnYW1lcGFkICYmIGdhbWVwYWRzLnZhbHVlW2dhbWVwYWQuaW5kZXhdKVxuICAgICAgICBvbkdhbWVwYWRDb25uZWN0ZWQoZ2FtZXBhZCk7XG4gICAgfVxuICB9KTtcbiAgcGF1c2UoKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBvbkNvbm5lY3RlZDogb25Db25uZWN0ZWRIb29rLm9uLFxuICAgIG9uRGlzY29ubmVjdGVkOiBvbkRpc2Nvbm5lY3RlZEhvb2sub24sXG4gICAgZ2FtZXBhZHMsXG4gICAgcGF1c2UsXG4gICAgcmVzdW1lLFxuICAgIGlzQWN0aXZlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUdlb2xvY2F0aW9uKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZW5hYmxlSGlnaEFjY3VyYWN5ID0gdHJ1ZSxcbiAgICBtYXhpbXVtQWdlID0gM2U0LFxuICAgIHRpbWVvdXQgPSAyN2UzLFxuICAgIG5hdmlnYXRvciA9IGRlZmF1bHROYXZpZ2F0b3IsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwiZ2VvbG9jYXRpb25cIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBsb2NhdGVkQXQgPSByZWYobnVsbCk7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZihudWxsKTtcbiAgY29uc3QgY29vcmRzID0gcmVmKHtcbiAgICBhY2N1cmFjeTogMCxcbiAgICBsYXRpdHVkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGxvbmdpdHVkZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGFsdGl0dWRlOiBudWxsLFxuICAgIGFsdGl0dWRlQWNjdXJhY3k6IG51bGwsXG4gICAgaGVhZGluZzogbnVsbCxcbiAgICBzcGVlZDogbnVsbFxuICB9KTtcbiAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBsb2NhdGVkQXQudmFsdWUgPSBwb3NpdGlvbi50aW1lc3RhbXA7XG4gICAgY29vcmRzLnZhbHVlID0gcG9zaXRpb24uY29vcmRzO1xuICAgIGVycm9yLnZhbHVlID0gbnVsbDtcbiAgfVxuICBsZXQgd2F0Y2hlcjtcbiAgZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSkge1xuICAgICAgd2F0Y2hlciA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKFxuICAgICAgICB1cGRhdGVQb3NpdGlvbixcbiAgICAgICAgKGVycikgPT4gZXJyb3IudmFsdWUgPSBlcnIsXG4gICAgICAgIHtcbiAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3ksXG4gICAgICAgICAgbWF4aW11bUFnZSxcbiAgICAgICAgICB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChpbW1lZGlhdGUpXG4gICAgcmVzdW1lKCk7XG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmICh3YXRjaGVyICYmIG5hdmlnYXRvcilcbiAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHdhdGNoZXIpO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBwYXVzZSgpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBjb29yZHMsXG4gICAgbG9jYXRlZEF0LFxuICAgIGVycm9yLFxuICAgIHJlc3VtZSxcbiAgICBwYXVzZVxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0RXZlbnRzJDEgPSBbXCJtb3VzZW1vdmVcIiwgXCJtb3VzZWRvd25cIiwgXCJyZXNpemVcIiwgXCJrZXlkb3duXCIsIFwidG91Y2hzdGFydFwiLCBcIndoZWVsXCJdO1xuY29uc3Qgb25lTWludXRlID0gNmU0O1xuZnVuY3Rpb24gdXNlSWRsZSh0aW1lb3V0ID0gb25lTWludXRlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxTdGF0ZSA9IGZhbHNlLFxuICAgIGxpc3RlbkZvclZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlLFxuICAgIGV2ZW50cyA9IGRlZmF1bHRFdmVudHMkMSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIGV2ZW50RmlsdGVyID0gdGhyb3R0bGVGaWx0ZXIoNTApXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpZGxlID0gcmVmKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IGxhc3RBY3RpdmUgPSByZWYodGltZXN0YW1wKCkpO1xuICBsZXQgdGltZXI7XG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIGlkbGUudmFsdWUgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBpZGxlLnZhbHVlID0gdHJ1ZSwgdGltZW91dCk7XG4gIH07XG4gIGNvbnN0IG9uRXZlbnQgPSBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgIGV2ZW50RmlsdGVyLFxuICAgICgpID0+IHtcbiAgICAgIGxhc3RBY3RpdmUudmFsdWUgPSB0aW1lc3RhbXAoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICApO1xuICBpZiAod2luZG93KSB7XG4gICAgY29uc3QgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpXG4gICAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgZXZlbnQsIG9uRXZlbnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICBpZiAobGlzdGVuRm9yVmlzaWJpbGl0eUNoYW5nZSkge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pXG4gICAgICAgICAgb25FdmVudCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0KCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZGxlLFxuICAgIGxhc3RBY3RpdmUsXG4gICAgcmVzZXRcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEltYWdlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBjb25zdCB7IHNyYywgc3Jjc2V0LCBzaXplcywgY2xhc3M6IGNsYXp6LCBsb2FkaW5nLCBjcm9zc29yaWdpbiwgcmVmZXJyZXJQb2xpY3kgfSA9IG9wdGlvbnM7XG4gICAgaW1nLnNyYyA9IHNyYztcbiAgICBpZiAoc3Jjc2V0KVxuICAgICAgaW1nLnNyY3NldCA9IHNyY3NldDtcbiAgICBpZiAoc2l6ZXMpXG4gICAgICBpbWcuc2l6ZXMgPSBzaXplcztcbiAgICBpZiAoY2xhenopXG4gICAgICBpbWcuY2xhc3NOYW1lID0gY2xheno7XG4gICAgaWYgKGxvYWRpbmcpXG4gICAgICBpbWcubG9hZGluZyA9IGxvYWRpbmc7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKVxuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NvcmlnaW47XG4gICAgaWYgKHJlZmVycmVyUG9saWN5KVxuICAgICAgaW1nLnJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3k7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICBpbWcub25lcnJvciA9IHJlamVjdDtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VJbWFnZShvcHRpb25zLCBhc3luY1N0YXRlT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0YXRlID0gdXNlQXN5bmNTdGF0ZShcbiAgICAoKSA9PiBsb2FkSW1hZ2UodG9WYWx1ZShvcHRpb25zKSksXG4gICAgdm9pZCAwLFxuICAgIHtcbiAgICAgIHJlc2V0T25FeGVjdXRlOiB0cnVlLFxuICAgICAgLi4uYXN5bmNTdGF0ZU9wdGlvbnNcbiAgICB9XG4gICk7XG4gIHdhdGNoKFxuICAgICgpID0+IHRvVmFsdWUob3B0aW9ucyksXG4gICAgKCkgPT4gc3RhdGUuZXhlY3V0ZShhc3luY1N0YXRlT3B0aW9ucy5kZWxheSksXG4gICAgeyBkZWVwOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5jb25zdCBBUlJJVkVEX1NUQVRFX1RIUkVTSE9MRF9QSVhFTFMgPSAxO1xuZnVuY3Rpb24gdXNlU2Nyb2xsKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGhyb3R0bGUgPSAwLFxuICAgIGlkbGUgPSAyMDAsXG4gICAgb25TdG9wID0gbm9vcCxcbiAgICBvblNjcm9sbCA9IG5vb3AsXG4gICAgb2Zmc2V0ID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSxcbiAgICBldmVudExpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0sXG4gICAgYmVoYXZpb3IgPSBcImF1dG9cIixcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93LFxuICAgIG9uRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbnRlcm5hbFggPSByZWYoMCk7XG4gIGNvbnN0IGludGVybmFsWSA9IHJlZigwKTtcbiAgY29uc3QgeCA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxYLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHgyKSB7XG4gICAgICBzY3JvbGxUbyh4Miwgdm9pZCAwKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCB5ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbFkudmFsdWU7XG4gICAgfSxcbiAgICBzZXQoeTIpIHtcbiAgICAgIHNjcm9sbFRvKHZvaWQgMCwgeTIpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHNjcm9sbFRvKF94LCBfeSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBpZiAoIXdpbmRvdylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBfZWxlbWVudCA9IHRvVmFsdWUoZWxlbWVudCk7XG4gICAgaWYgKCFfZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICAoX2MgPSBfZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50ID8gd2luZG93LmRvY3VtZW50LmJvZHkgOiBfZWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnNjcm9sbFRvKHtcbiAgICAgIHRvcDogKF9hID0gdG9WYWx1ZShfeSkpICE9IG51bGwgPyBfYSA6IHkudmFsdWUsXG4gICAgICBsZWZ0OiAoX2IgPSB0b1ZhbHVlKF94KSkgIT0gbnVsbCA/IF9iIDogeC52YWx1ZSxcbiAgICAgIGJlaGF2aW9yOiB0b1ZhbHVlKGJlaGF2aW9yKVxuICAgIH0pO1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9ICgoX2QgPSBfZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5kb2N1bWVudEVsZW1lbnQpIHx8IChfZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQuZG9jdW1lbnRFbGVtZW50KSB8fCBfZWxlbWVudDtcbiAgICBpZiAoeCAhPSBudWxsKVxuICAgICAgaW50ZXJuYWxYLnZhbHVlID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQ7XG4gICAgaWYgKHkgIT0gbnVsbClcbiAgICAgIGludGVybmFsWS52YWx1ZSA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3A7XG4gIH1cbiAgY29uc3QgaXNTY3JvbGxpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBhcnJpdmVkU3RhdGUgPSByZWFjdGl2ZSh7XG4gICAgbGVmdDogdHJ1ZSxcbiAgICByaWdodDogZmFsc2UsXG4gICAgdG9wOiB0cnVlLFxuICAgIGJvdHRvbTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGRpcmVjdGlvbnMgPSByZWFjdGl2ZSh7XG4gICAgbGVmdDogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIHRvcDogZmFsc2UsXG4gICAgYm90dG9tOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgb25TY3JvbGxFbmQgPSAoZSkgPT4ge1xuICAgIGlmICghaXNTY3JvbGxpbmcudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaXNTY3JvbGxpbmcudmFsdWUgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLmxlZnQgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLnJpZ2h0ID0gZmFsc2U7XG4gICAgZGlyZWN0aW9ucy50b3AgPSBmYWxzZTtcbiAgICBkaXJlY3Rpb25zLmJvdHRvbSA9IGZhbHNlO1xuICAgIG9uU3RvcChlKTtcbiAgfTtcbiAgY29uc3Qgb25TY3JvbGxFbmREZWJvdW5jZWQgPSB1c2VEZWJvdW5jZUZuKG9uU2Nyb2xsRW5kLCB0aHJvdHRsZSArIGlkbGUpO1xuICBjb25zdCBzZXRBcnJpdmVkU3RhdGUgPSAodGFyZ2V0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gKChfYSA9IHRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogdGFyZ2V0LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZG9jdW1lbnRFbGVtZW50KSB8fCAodGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXQuZG9jdW1lbnRFbGVtZW50KSB8fCB1bnJlZkVsZW1lbnQodGFyZ2V0KTtcbiAgICBjb25zdCB7IGRpc3BsYXksIGZsZXhEaXJlY3Rpb24gfSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgIGRpcmVjdGlvbnMubGVmdCA9IHNjcm9sbExlZnQgPCBpbnRlcm5hbFgudmFsdWU7XG4gICAgZGlyZWN0aW9ucy5yaWdodCA9IHNjcm9sbExlZnQgPiBpbnRlcm5hbFgudmFsdWU7XG4gICAgY29uc3QgbGVmdCA9IE1hdGguYWJzKHNjcm9sbExlZnQpIDw9IChvZmZzZXQubGVmdCB8fCAwKTtcbiAgICBjb25zdCByaWdodCA9IE1hdGguYWJzKHNjcm9sbExlZnQpICsgZWwuY2xpZW50V2lkdGggPj0gZWwuc2Nyb2xsV2lkdGggLSAob2Zmc2V0LnJpZ2h0IHx8IDApIC0gQVJSSVZFRF9TVEFURV9USFJFU0hPTERfUElYRUxTO1xuICAgIGlmIChkaXNwbGF5ID09PSBcImZsZXhcIiAmJiBmbGV4RGlyZWN0aW9uID09PSBcInJvdy1yZXZlcnNlXCIpIHtcbiAgICAgIGFycml2ZWRTdGF0ZS5sZWZ0ID0gcmlnaHQ7XG4gICAgICBhcnJpdmVkU3RhdGUucmlnaHQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJpdmVkU3RhdGUubGVmdCA9IGxlZnQ7XG4gICAgICBhcnJpdmVkU3RhdGUucmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgaW50ZXJuYWxYLnZhbHVlID0gc2Nyb2xsTGVmdDtcbiAgICBsZXQgc2Nyb2xsVG9wID0gZWwuc2Nyb2xsVG9wO1xuICAgIGlmICh0YXJnZXQgPT09IHdpbmRvdy5kb2N1bWVudCAmJiAhc2Nyb2xsVG9wKVxuICAgICAgc2Nyb2xsVG9wID0gd2luZG93LmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgIGRpcmVjdGlvbnMudG9wID0gc2Nyb2xsVG9wIDwgaW50ZXJuYWxZLnZhbHVlO1xuICAgIGRpcmVjdGlvbnMuYm90dG9tID0gc2Nyb2xsVG9wID4gaW50ZXJuYWxZLnZhbHVlO1xuICAgIGNvbnN0IHRvcCA9IE1hdGguYWJzKHNjcm9sbFRvcCkgPD0gKG9mZnNldC50b3AgfHwgMCk7XG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5hYnMoc2Nyb2xsVG9wKSArIGVsLmNsaWVudEhlaWdodCA+PSBlbC5zY3JvbGxIZWlnaHQgLSAob2Zmc2V0LmJvdHRvbSB8fCAwKSAtIEFSUklWRURfU1RBVEVfVEhSRVNIT0xEX1BJWEVMUztcbiAgICBpZiAoZGlzcGxheSA9PT0gXCJmbGV4XCIgJiYgZmxleERpcmVjdGlvbiA9PT0gXCJjb2x1bW4tcmV2ZXJzZVwiKSB7XG4gICAgICBhcnJpdmVkU3RhdGUudG9wID0gYm90dG9tO1xuICAgICAgYXJyaXZlZFN0YXRlLmJvdHRvbSA9IHRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyaXZlZFN0YXRlLnRvcCA9IHRvcDtcbiAgICAgIGFycml2ZWRTdGF0ZS5ib3R0b20gPSBib3R0b207XG4gICAgfVxuICAgIGludGVybmFsWS52YWx1ZSA9IHNjcm9sbFRvcDtcbiAgfTtcbiAgY29uc3Qgb25TY3JvbGxIYW5kbGVyID0gKGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF3aW5kb3cpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSAoX2EgPSBlLnRhcmdldC5kb2N1bWVudEVsZW1lbnQpICE9IG51bGwgPyBfYSA6IGUudGFyZ2V0O1xuICAgIHNldEFycml2ZWRTdGF0ZShldmVudFRhcmdldCk7XG4gICAgaXNTY3JvbGxpbmcudmFsdWUgPSB0cnVlO1xuICAgIG9uU2Nyb2xsRW5kRGVib3VuY2VkKGUpO1xuICAgIG9uU2Nyb2xsKGUpO1xuICB9O1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIGVsZW1lbnQsXG4gICAgXCJzY3JvbGxcIixcbiAgICB0aHJvdHRsZSA/IHVzZVRocm90dGxlRm4ob25TY3JvbGxIYW5kbGVyLCB0aHJvdHRsZSwgdHJ1ZSwgZmFsc2UpIDogb25TY3JvbGxIYW5kbGVyLFxuICAgIGV2ZW50TGlzdGVuZXJPcHRpb25zXG4gICk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IF9lbGVtZW50ID0gdG9WYWx1ZShlbGVtZW50KTtcbiAgICAgIGlmICghX2VsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHNldEFycml2ZWRTdGF0ZShfZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFxuICAgIGVsZW1lbnQsXG4gICAgXCJzY3JvbGxlbmRcIixcbiAgICBvblNjcm9sbEVuZCxcbiAgICBldmVudExpc3RlbmVyT3B0aW9uc1xuICApO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBpc1Njcm9sbGluZyxcbiAgICBhcnJpdmVkU3RhdGUsXG4gICAgZGlyZWN0aW9ucyxcbiAgICBtZWFzdXJlKCkge1xuICAgICAgY29uc3QgX2VsZW1lbnQgPSB0b1ZhbHVlKGVsZW1lbnQpO1xuICAgICAgaWYgKHdpbmRvdyAmJiBfZWxlbWVudClcbiAgICAgICAgc2V0QXJyaXZlZFN0YXRlKF9lbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGVsKSB7XG4gIGlmICh0eXBlb2YgV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGVsIGluc3RhbmNlb2YgV2luZG93KVxuICAgIHJldHVybiBlbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICh0eXBlb2YgRG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZWwgaW5zdGFuY2VvZiBEb2N1bWVudClcbiAgICByZXR1cm4gZWwuZG9jdW1lbnRFbGVtZW50O1xuICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIHVzZUluZmluaXRlU2Nyb2xsKGVsZW1lbnQsIG9uTG9hZE1vcmUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBkaXJlY3Rpb24gPSBcImJvdHRvbVwiLFxuICAgIGludGVydmFsID0gMTAwLFxuICAgIGNhbkxvYWRNb3JlID0gKCkgPT4gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3RhdGUgPSByZWFjdGl2ZSh1c2VTY3JvbGwoXG4gICAgZWxlbWVudCxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIFtkaXJlY3Rpb25dOiAoX2EgPSBvcHRpb25zLmRpc3RhbmNlKSAhPSBudWxsID8gX2EgOiAwLFxuICAgICAgICAuLi5vcHRpb25zLm9mZnNldFxuICAgICAgfVxuICAgIH1cbiAgKSk7XG4gIGNvbnN0IHByb21pc2UgPSByZWYoKTtcbiAgY29uc3QgaXNMb2FkaW5nID0gY29tcHV0ZWQoKCkgPT4gISFwcm9taXNlLnZhbHVlKTtcbiAgY29uc3Qgb2JzZXJ2ZWRFbGVtZW50ID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiByZXNvbHZlRWxlbWVudCh0b1ZhbHVlKGVsZW1lbnQpKTtcbiAgfSk7XG4gIGNvbnN0IGlzRWxlbWVudFZpc2libGUgPSB1c2VFbGVtZW50VmlzaWJpbGl0eShvYnNlcnZlZEVsZW1lbnQpO1xuICBmdW5jdGlvbiBjaGVja0FuZExvYWQoKSB7XG4gICAgc3RhdGUubWVhc3VyZSgpO1xuICAgIGlmICghb2JzZXJ2ZWRFbGVtZW50LnZhbHVlIHx8ICFpc0VsZW1lbnRWaXNpYmxlLnZhbHVlIHx8ICFjYW5Mb2FkTW9yZShvYnNlcnZlZEVsZW1lbnQudmFsdWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQsIHNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aCB9ID0gb2JzZXJ2ZWRFbGVtZW50LnZhbHVlO1xuICAgIGNvbnN0IGlzTmFycm93ZXIgPSBkaXJlY3Rpb24gPT09IFwiYm90dG9tXCIgfHwgZGlyZWN0aW9uID09PSBcInRvcFwiID8gc2Nyb2xsSGVpZ2h0IDw9IGNsaWVudEhlaWdodCA6IHNjcm9sbFdpZHRoIDw9IGNsaWVudFdpZHRoO1xuICAgIGlmIChzdGF0ZS5hcnJpdmVkU3RhdGVbZGlyZWN0aW9uXSB8fCBpc05hcnJvd2VyKSB7XG4gICAgICBpZiAoIXByb21pc2UudmFsdWUpIHtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBvbkxvYWRNb3JlKHN0YXRlKSxcbiAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbnRlcnZhbCkpXG4gICAgICAgIF0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHByb21pc2UudmFsdWUgPSBudWxsO1xuICAgICAgICAgIG5leHRUaWNrKCgpID0+IGNoZWNrQW5kTG9hZCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdhdGNoKFxuICAgICgpID0+IFtzdGF0ZS5hcnJpdmVkU3RhdGVbZGlyZWN0aW9uXSwgaXNFbGVtZW50VmlzaWJsZS52YWx1ZV0sXG4gICAgY2hlY2tBbmRMb2FkLFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmdcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdEV2ZW50cyA9IFtcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJrZXlkb3duXCIsIFwia2V5dXBcIl07XG5mdW5jdGlvbiB1c2VLZXlNb2RpZmllcihtb2RpZmllciwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBldmVudHMgPSBkZWZhdWx0RXZlbnRzLFxuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIGluaXRpYWwgPSBudWxsXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzdGF0ZSA9IHJlZihpbml0aWFsKTtcbiAgaWYgKGRvY3VtZW50KSB7XG4gICAgZXZlbnRzLmZvckVhY2goKGxpc3RlbmVyRXZlbnQpID0+IHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIGxpc3RlbmVyRXZlbnQsIChldnQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBldnQuZ2V0TW9kaWZpZXJTdGF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHN0YXRlLnZhbHVlID0gZXZ0LmdldE1vZGlmaWVyU3RhdGUobW9kaWZpZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbFN0b3JhZ2Uoa2V5LCBpbml0aWFsVmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB1c2VTdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhbFN0b3JhZ2UsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBEZWZhdWx0TWFnaWNLZXlzQWxpYXNNYXAgPSB7XG4gIGN0cmw6IFwiY29udHJvbFwiLFxuICBjb21tYW5kOiBcIm1ldGFcIixcbiAgY21kOiBcIm1ldGFcIixcbiAgb3B0aW9uOiBcImFsdFwiLFxuICB1cDogXCJhcnJvd3VwXCIsXG4gIGRvd246IFwiYXJyb3dkb3duXCIsXG4gIGxlZnQ6IFwiYXJyb3dsZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93cmlnaHRcIlxufTtcblxuZnVuY3Rpb24gdXNlTWFnaWNLZXlzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcmVhY3RpdmU6IHVzZVJlYWN0aXZlID0gZmFsc2UsXG4gICAgdGFyZ2V0ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBhbGlhc01hcCA9IERlZmF1bHRNYWdpY0tleXNBbGlhc01hcCxcbiAgICBwYXNzaXZlID0gdHJ1ZSxcbiAgICBvbkV2ZW50RmlyZWQgPSBub29wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdXJyZW50ID0gcmVhY3RpdmUoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIGNvbnN0IG9iaiA9IHtcbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICBjdXJyZW50XG4gIH07XG4gIGNvbnN0IHJlZnMgPSB1c2VSZWFjdGl2ZSA/IHJlYWN0aXZlKG9iaikgOiBvYmo7XG4gIGNvbnN0IG1ldGFEZXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdXNlZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBzZXRSZWZzKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIHJlZnMpIHtcbiAgICAgIGlmICh1c2VSZWFjdGl2ZSlcbiAgICAgICAgcmVmc1trZXldID0gdmFsdWU7XG4gICAgICBlbHNlXG4gICAgICAgIHJlZnNba2V5XS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjdXJyZW50LmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZEtleXMpXG4gICAgICBzZXRSZWZzKGtleSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVJlZnMoZSwgdmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGtleSA9IChfYSA9IGUua2V5KSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb2RlID0gKF9iID0gZS5jb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbY29kZSwga2V5XS5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHZhbHVlKVxuICAgICAgICBjdXJyZW50LmFkZChrZXkpO1xuICAgICAgZWxzZVxuICAgICAgICBjdXJyZW50LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleTIgb2YgdmFsdWVzKSB7XG4gICAgICB1c2VkS2V5cy5hZGQoa2V5Mik7XG4gICAgICBzZXRSZWZzKGtleTIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCJtZXRhXCIgJiYgIXZhbHVlKSB7XG4gICAgICBtZXRhRGVwcy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGN1cnJlbnQuZGVsZXRlKGtleTIpO1xuICAgICAgICBzZXRSZWZzKGtleTIsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgbWV0YURlcHMuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlLmdldE1vZGlmaWVyU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiBlLmdldE1vZGlmaWVyU3RhdGUoXCJNZXRhXCIpICYmIHZhbHVlKSB7XG4gICAgICBbLi4uY3VycmVudCwgLi4udmFsdWVzXS5mb3JFYWNoKChrZXkyKSA9PiBtZXRhRGVwcy5hZGQoa2V5MikpO1xuICAgIH1cbiAgfVxuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgdXBkYXRlUmVmcyhlLCB0cnVlKTtcbiAgICByZXR1cm4gb25FdmVudEZpcmVkKGUpO1xuICB9LCB7IHBhc3NpdmUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImtleXVwXCIsIChlKSA9PiB7XG4gICAgdXBkYXRlUmVmcyhlLCBmYWxzZSk7XG4gICAgcmV0dXJuIG9uRXZlbnRGaXJlZChlKTtcbiAgfSwgeyBwYXNzaXZlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFwiYmx1clwiLCByZXNldCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgcmVzZXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgcmVmcyxcbiAgICB7XG4gICAgICBnZXQodGFyZ2V0MiwgcHJvcCwgcmVjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0MiwgcHJvcCwgcmVjKTtcbiAgICAgICAgcHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHByb3AgaW4gYWxpYXNNYXApXG4gICAgICAgICAgcHJvcCA9IGFsaWFzTWFwW3Byb3BdO1xuICAgICAgICBpZiAoIShwcm9wIGluIHJlZnMpKSB7XG4gICAgICAgICAgaWYgKC9bK18tXS8udGVzdChwcm9wKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHByb3Auc3BsaXQoL1srXy1dL2cpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgICAgICAgICAgcmVmc1twcm9wXSA9IGNvbXB1dGVkKCgpID0+IGtleXMuZXZlcnkoKGtleSkgPT4gdG9WYWx1ZShwcm94eVtrZXldKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZzW3Byb3BdID0gcmVmKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IFJlZmxlY3QuZ2V0KHRhcmdldDIsIHByb3AsIHJlYyk7XG4gICAgICAgIHJldHVybiB1c2VSZWFjdGl2ZSA/IHRvVmFsdWUocikgOiByO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHByb3h5O1xufVxuXG5mdW5jdGlvbiB1c2luZ0VsUmVmKHNvdXJjZSwgY2IpIHtcbiAgaWYgKHRvVmFsdWUoc291cmNlKSlcbiAgICBjYih0b1ZhbHVlKHNvdXJjZSkpO1xufVxuZnVuY3Rpb24gdGltZVJhbmdlVG9BcnJheSh0aW1lUmFuZ2VzKSB7XG4gIGxldCByYW5nZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2VzLmxlbmd0aDsgKytpKVxuICAgIHJhbmdlcyA9IFsuLi5yYW5nZXMsIFt0aW1lUmFuZ2VzLnN0YXJ0KGkpLCB0aW1lUmFuZ2VzLmVuZChpKV1dO1xuICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gdHJhY2tzVG9BcnJheSh0cmFja3MpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odHJhY2tzKS5tYXAoKHsgbGFiZWwsIGtpbmQsIGxhbmd1YWdlLCBtb2RlLCBhY3RpdmVDdWVzLCBjdWVzLCBpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlIH0sIGlkKSA9PiAoeyBpZCwgbGFiZWwsIGtpbmQsIGxhbmd1YWdlLCBtb2RlLCBhY3RpdmVDdWVzLCBjdWVzLCBpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlIH0pKTtcbn1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzcmM6IFwiXCIsXG4gIHRyYWNrczogW11cbn07XG5mdW5jdGlvbiB1c2VNZWRpYUNvbnRyb2xzKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIHRhcmdldCA9IHRvUmVmKHRhcmdldCk7XG4gIG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gcmVmKDApO1xuICBjb25zdCBkdXJhdGlvbiA9IHJlZigwKTtcbiAgY29uc3Qgc2Vla2luZyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHZvbHVtZSA9IHJlZigxKTtcbiAgY29uc3Qgd2FpdGluZyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGVuZGVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgcGxheWluZyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHJhdGUgPSByZWYoMSk7XG4gIGNvbnN0IHN0YWxsZWQgPSByZWYoZmFsc2UpO1xuICBjb25zdCBidWZmZXJlZCA9IHJlZihbXSk7XG4gIGNvbnN0IHRyYWNrcyA9IHJlZihbXSk7XG4gIGNvbnN0IHNlbGVjdGVkVHJhY2sgPSByZWYoLTEpO1xuICBjb25zdCBpc1BpY3R1cmVJblBpY3R1cmUgPSByZWYoZmFsc2UpO1xuICBjb25zdCBtdXRlZCA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IHN1cHBvcnRzUGljdHVyZUluUGljdHVyZSA9IGRvY3VtZW50ICYmIFwicGljdHVyZUluUGljdHVyZUVuYWJsZWRcIiBpbiBkb2N1bWVudDtcbiAgY29uc3Qgc291cmNlRXJyb3JFdmVudCA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBkaXNhYmxlVHJhY2sgPSAodHJhY2spID0+IHtcbiAgICB1c2luZ0VsUmVmKHRhcmdldCwgKGVsKSA9PiB7XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSB0eXBlb2YgdHJhY2sgPT09IFwibnVtYmVyXCIgPyB0cmFjayA6IHRyYWNrLmlkO1xuICAgICAgICBlbC50ZXh0VHJhY2tzW2lkXS5tb2RlID0gXCJkaXNhYmxlZFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC50ZXh0VHJhY2tzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGVsLnRleHRUcmFja3NbaV0ubW9kZSA9IFwiZGlzYWJsZWRcIjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkVHJhY2sudmFsdWUgPSAtMTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZW5hYmxlVHJhY2sgPSAodHJhY2ssIGRpc2FibGVUcmFja3MgPSB0cnVlKSA9PiB7XG4gICAgdXNpbmdFbFJlZih0YXJnZXQsIChlbCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0eXBlb2YgdHJhY2sgPT09IFwibnVtYmVyXCIgPyB0cmFjayA6IHRyYWNrLmlkO1xuICAgICAgaWYgKGRpc2FibGVUcmFja3MpXG4gICAgICAgIGRpc2FibGVUcmFjaygpO1xuICAgICAgZWwudGV4dFRyYWNrc1tpZF0ubW9kZSA9IFwic2hvd2luZ1wiO1xuICAgICAgc2VsZWN0ZWRUcmFjay52YWx1ZSA9IGlkO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1c2luZ0VsUmVmKHRhcmdldCwgYXN5bmMgKGVsKSA9PiB7XG4gICAgICAgIGlmIChzdXBwb3J0c1BpY3R1cmVJblBpY3R1cmUpIHtcbiAgICAgICAgICBpZiAoIWlzUGljdHVyZUluUGljdHVyZS52YWx1ZSkge1xuICAgICAgICAgICAgZWwucmVxdWVzdFBpY3R1cmVJblBpY3R1cmUoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRQaWN0dXJlSW5QaWN0dXJlKCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc3JjID0gdG9WYWx1ZShvcHRpb25zLnNyYyk7XG4gICAgbGV0IHNvdXJjZXMgPSBbXTtcbiAgICBpZiAoIXNyYylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHNvdXJjZXMgPSBbeyBzcmMgfV07XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgc291cmNlcyA9IHNyYztcbiAgICBlbHNlIGlmIChpc09iamVjdChzcmMpKVxuICAgICAgc291cmNlcyA9IFtzcmNdO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgc291cmNlRXJyb3JFdmVudC50cmlnZ2VyKTtcbiAgICAgIGUucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgc291cmNlcy5mb3JFYWNoKCh7IHNyYzogc3JjMiwgdHlwZSB9KSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgc291cmNlLnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMyKTtcbiAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHR5cGUgfHwgXCJcIik7XG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHNvdXJjZUVycm9yRXZlbnQudHJpZ2dlcik7XG4gICAgICBlbC5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgIH0pO1xuICAgIGVsLmxvYWQoKTtcbiAgfSk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIikuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgc291cmNlRXJyb3JFdmVudC50cmlnZ2VyKSk7XG4gIH0pO1xuICB3YXRjaChbdGFyZ2V0LCB2b2x1bWVdLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC52b2x1bWUgPSB2b2x1bWUudmFsdWU7XG4gIH0pO1xuICB3YXRjaChbdGFyZ2V0LCBtdXRlZF0sICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLm11dGVkID0gbXV0ZWQudmFsdWU7XG4gIH0pO1xuICB3YXRjaChbdGFyZ2V0LCByYXRlXSwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwucGxheWJhY2tSYXRlID0gcmF0ZS52YWx1ZTtcbiAgfSk7XG4gIHdhdGNoRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRleHRUcmFja3MgPSB0b1ZhbHVlKG9wdGlvbnMudHJhY2tzKTtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIXRleHRUcmFja3MgfHwgIXRleHRUcmFja3MubGVuZ3RoIHx8ICFlbClcbiAgICAgIHJldHVybjtcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwidHJhY2tcIikuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKCh7IGRlZmF1bHQ6IGlzRGVmYXVsdCwga2luZCwgbGFiZWwsIHNyYywgc3JjTGFuZyB9LCBpKSA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0cmFja1wiKTtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSBpc0RlZmF1bHQgfHwgZmFsc2U7XG4gICAgICB0cmFjay5raW5kID0ga2luZDtcbiAgICAgIHRyYWNrLmxhYmVsID0gbGFiZWw7XG4gICAgICB0cmFjay5zcmMgPSBzcmM7XG4gICAgICB0cmFjay5zcmNsYW5nID0gc3JjTGFuZztcbiAgICAgIGlmICh0cmFjay5kZWZhdWx0KVxuICAgICAgICBzZWxlY3RlZFRyYWNrLnZhbHVlID0gaTtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHRyYWNrKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHsgaWdub3JlVXBkYXRlczogaWdub3JlQ3VycmVudFRpbWVVcGRhdGVzIH0gPSB3YXRjaElnbm9yYWJsZShjdXJyZW50VGltZSwgKHRpbWUpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGVsLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgfSk7XG4gIGNvbnN0IHsgaWdub3JlVXBkYXRlczogaWdub3JlUGxheWluZ1VwZGF0ZXMgfSA9IHdhdGNoSWdub3JhYmxlKHBsYXlpbmcsIChpc1BsYXlpbmcpID0+IHtcbiAgICBjb25zdCBlbCA9IHRvVmFsdWUodGFyZ2V0KTtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuO1xuICAgIGlzUGxheWluZyA/IGVsLnBsYXkoKSA6IGVsLnBhdXNlKCk7XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ0aW1ldXBkYXRlXCIsICgpID0+IGlnbm9yZUN1cnJlbnRUaW1lVXBkYXRlcygoKSA9PiBjdXJyZW50VGltZS52YWx1ZSA9IHRvVmFsdWUodGFyZ2V0KS5jdXJyZW50VGltZSkpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJkdXJhdGlvbmNoYW5nZVwiLCAoKSA9PiBkdXJhdGlvbi52YWx1ZSA9IHRvVmFsdWUodGFyZ2V0KS5kdXJhdGlvbik7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInByb2dyZXNzXCIsICgpID0+IGJ1ZmZlcmVkLnZhbHVlID0gdGltZVJhbmdlVG9BcnJheSh0b1ZhbHVlKHRhcmdldCkuYnVmZmVyZWQpKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwic2Vla2luZ1wiLCAoKSA9PiBzZWVraW5nLnZhbHVlID0gdHJ1ZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInNlZWtlZFwiLCAoKSA9PiBzZWVraW5nLnZhbHVlID0gZmFsc2UpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1wid2FpdGluZ1wiLCBcImxvYWRzdGFydFwiXSwgKCkgPT4ge1xuICAgIHdhaXRpbmcudmFsdWUgPSB0cnVlO1xuICAgIGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSBmYWxzZSk7XG4gIH0pO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJsb2FkZWRkYXRhXCIsICgpID0+IHdhaXRpbmcudmFsdWUgPSBmYWxzZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBsYXlpbmdcIiwgKCkgPT4ge1xuICAgIHdhaXRpbmcudmFsdWUgPSBmYWxzZTtcbiAgICBlbmRlZC52YWx1ZSA9IGZhbHNlO1xuICAgIGlnbm9yZVBsYXlpbmdVcGRhdGVzKCgpID0+IHBsYXlpbmcudmFsdWUgPSB0cnVlKTtcbiAgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInJhdGVjaGFuZ2VcIiwgKCkgPT4gcmF0ZS52YWx1ZSA9IHRvVmFsdWUodGFyZ2V0KS5wbGF5YmFja1JhdGUpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJzdGFsbGVkXCIsICgpID0+IHN0YWxsZWQudmFsdWUgPSB0cnVlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZW5kZWRcIiwgKCkgPT4gZW5kZWQudmFsdWUgPSB0cnVlKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwicGF1c2VcIiwgKCkgPT4gaWdub3JlUGxheWluZ1VwZGF0ZXMoKCkgPT4gcGxheWluZy52YWx1ZSA9IGZhbHNlKSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBsYXlcIiwgKCkgPT4gaWdub3JlUGxheWluZ1VwZGF0ZXMoKCkgPT4gcGxheWluZy52YWx1ZSA9IHRydWUpKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFwiZW50ZXJwaWN0dXJlaW5waWN0dXJlXCIsICgpID0+IGlzUGljdHVyZUluUGljdHVyZS52YWx1ZSA9IHRydWUpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJsZWF2ZXBpY3R1cmVpbnBpY3R1cmVcIiwgKCkgPT4gaXNQaWN0dXJlSW5QaWN0dXJlLnZhbHVlID0gZmFsc2UpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ2b2x1bWVjaGFuZ2VcIiwgKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdG9WYWx1ZSh0YXJnZXQpO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm47XG4gICAgdm9sdW1lLnZhbHVlID0gZWwudm9sdW1lO1xuICAgIG11dGVkLnZhbHVlID0gZWwubXV0ZWQ7XG4gIH0pO1xuICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgY29uc3Qgc3RvcCA9IHdhdGNoKFt0YXJnZXRdLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0b1ZhbHVlKHRhcmdldCk7XG4gICAgaWYgKCFlbClcbiAgICAgIHJldHVybjtcbiAgICBzdG9wKCk7XG4gICAgbGlzdGVuZXJzWzBdID0gdXNlRXZlbnRMaXN0ZW5lcihlbC50ZXh0VHJhY2tzLCBcImFkZHRyYWNrXCIsICgpID0+IHRyYWNrcy52YWx1ZSA9IHRyYWNrc1RvQXJyYXkoZWwudGV4dFRyYWNrcykpO1xuICAgIGxpc3RlbmVyc1sxXSA9IHVzZUV2ZW50TGlzdGVuZXIoZWwudGV4dFRyYWNrcywgXCJyZW1vdmV0cmFja1wiLCAoKSA9PiB0cmFja3MudmFsdWUgPSB0cmFja3NUb0FycmF5KGVsLnRleHRUcmFja3MpKTtcbiAgICBsaXN0ZW5lcnNbMl0gPSB1c2VFdmVudExpc3RlbmVyKGVsLnRleHRUcmFja3MsIFwiY2hhbmdlXCIsICgpID0+IHRyYWNrcy52YWx1ZSA9IHRyYWNrc1RvQXJyYXkoZWwudGV4dFRyYWNrcykpO1xuICB9KTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4gbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKSk7XG4gIHJldHVybiB7XG4gICAgY3VycmVudFRpbWUsXG4gICAgZHVyYXRpb24sXG4gICAgd2FpdGluZyxcbiAgICBzZWVraW5nLFxuICAgIGVuZGVkLFxuICAgIHN0YWxsZWQsXG4gICAgYnVmZmVyZWQsXG4gICAgcGxheWluZyxcbiAgICByYXRlLFxuICAgIC8vIFZvbHVtZVxuICAgIHZvbHVtZSxcbiAgICBtdXRlZCxcbiAgICAvLyBUcmFja3NcbiAgICB0cmFja3MsXG4gICAgc2VsZWN0ZWRUcmFjayxcbiAgICBlbmFibGVUcmFjayxcbiAgICBkaXNhYmxlVHJhY2ssXG4gICAgLy8gUGljdHVyZSBpbiBQaWN0dXJlXG4gICAgc3VwcG9ydHNQaWN0dXJlSW5QaWN0dXJlLFxuICAgIHRvZ2dsZVBpY3R1cmVJblBpY3R1cmUsXG4gICAgaXNQaWN0dXJlSW5QaWN0dXJlLFxuICAgIC8vIEV2ZW50c1xuICAgIG9uU291cmNlRXJyb3I6IHNvdXJjZUVycm9yRXZlbnQub25cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFwVnVlMkNvbXBhdCgpIHtcbiAgY29uc3QgZGF0YSA9IHNoYWxsb3dSZWFjdGl2ZSh7fSk7XG4gIHJldHVybiB7XG4gICAgZ2V0OiAoa2V5KSA9PiBkYXRhW2tleV0sXG4gICAgc2V0OiAoa2V5LCB2YWx1ZSkgPT4gc2V0KGRhdGEsIGtleSwgdmFsdWUpLFxuICAgIGhhczogKGtleSkgPT4gaGFzT3duKGRhdGEsIGtleSksXG4gICAgZGVsZXRlOiAoa2V5KSA9PiBkZWwoZGF0YSwga2V5KSxcbiAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGRlbChkYXRhLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlTWVtb2l6ZShyZXNvbHZlciwgb3B0aW9ucykge1xuICBjb25zdCBpbml0Q2FjaGUgPSAoKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FjaGUpXG4gICAgICByZXR1cm4gc2hhbGxvd1JlYWN0aXZlKG9wdGlvbnMuY2FjaGUpO1xuICAgIGlmIChpc1Z1ZTIpXG4gICAgICByZXR1cm4gZ2V0TWFwVnVlMkNvbXBhdCgpO1xuICAgIHJldHVybiBzaGFsbG93UmVhY3RpdmUoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH07XG4gIGNvbnN0IGNhY2hlID0gaW5pdENhY2hlKCk7XG4gIGNvbnN0IGdlbmVyYXRlS2V5ID0gKC4uLmFyZ3MpID0+IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEtleSkgPyBvcHRpb25zLmdldEtleSguLi5hcmdzKSA6IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICBjb25zdCBfbG9hZERhdGEgPSAoa2V5LCAuLi5hcmdzKSA9PiB7XG4gICAgY2FjaGUuc2V0KGtleSwgcmVzb2x2ZXIoLi4uYXJncykpO1xuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgfTtcbiAgY29uc3QgbG9hZERhdGEgPSAoLi4uYXJncykgPT4gX2xvYWREYXRhKGdlbmVyYXRlS2V5KC4uLmFyZ3MpLCAuLi5hcmdzKTtcbiAgY29uc3QgZGVsZXRlRGF0YSA9ICguLi5hcmdzKSA9PiB7XG4gICAgY2FjaGUuZGVsZXRlKGdlbmVyYXRlS2V5KC4uLmFyZ3MpKTtcbiAgfTtcbiAgY29uc3QgY2xlYXJEYXRhID0gKCkgPT4ge1xuICAgIGNhY2hlLmNsZWFyKCk7XG4gIH07XG4gIGNvbnN0IG1lbW9pemVkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBrZXkgPSBnZW5lcmF0ZUtleSguLi5hcmdzKTtcbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpXG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgcmV0dXJuIF9sb2FkRGF0YShrZXksIC4uLmFyZ3MpO1xuICB9O1xuICBtZW1vaXplZC5sb2FkID0gbG9hZERhdGE7XG4gIG1lbW9pemVkLmRlbGV0ZSA9IGRlbGV0ZURhdGE7XG4gIG1lbW9pemVkLmNsZWFyID0gY2xlYXJEYXRhO1xuICBtZW1vaXplZC5nZW5lcmF0ZUtleSA9IGdlbmVyYXRlS2V5O1xuICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9yeShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgbWVtb3J5ID0gcmVmKCk7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm1lbW9yeVwiIGluIHBlcmZvcm1hbmNlKTtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgY29uc3QgeyBpbnRlcnZhbCA9IDFlMyB9ID0gb3B0aW9ucztcbiAgICB1c2VJbnRlcnZhbEZuKCgpID0+IHtcbiAgICAgIG1lbW9yeS52YWx1ZSA9IHBlcmZvcm1hbmNlLm1lbW9yeTtcbiAgICB9LCBpbnRlcnZhbCwgeyBpbW1lZGlhdGU6IG9wdGlvbnMuaW1tZWRpYXRlLCBpbW1lZGlhdGVDYWxsYmFjazogb3B0aW9ucy5pbW1lZGlhdGVDYWxsYmFjayB9KTtcbiAgfVxuICByZXR1cm4geyBpc1N1cHBvcnRlZCwgbWVtb3J5IH07XG59XG5cbmNvbnN0IFVzZU1vdXNlQnVpbHRpbkV4dHJhY3RvcnMgPSB7XG4gIHBhZ2U6IChldmVudCkgPT4gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV0sXG4gIGNsaWVudDogKGV2ZW50KSA9PiBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV0sXG4gIHNjcmVlbjogKGV2ZW50KSA9PiBbZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWV0sXG4gIG1vdmVtZW50OiAoZXZlbnQpID0+IGV2ZW50IGluc3RhbmNlb2YgVG91Y2ggPyBudWxsIDogW2V2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZXVxufTtcbmZ1bmN0aW9uIHVzZU1vdXNlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdHlwZSA9IFwicGFnZVwiLFxuICAgIHRvdWNoID0gdHJ1ZSxcbiAgICByZXNldE9uVG91Y2hFbmRzID0gZmFsc2UsXG4gICAgaW5pdGlhbFZhbHVlID0geyB4OiAwLCB5OiAwIH0sXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICB0YXJnZXQgPSB3aW5kb3csXG4gICAgc2Nyb2xsID0gdHJ1ZSxcbiAgICBldmVudEZpbHRlclxuICB9ID0gb3B0aW9ucztcbiAgbGV0IF9wcmV2TW91c2VFdmVudCA9IG51bGw7XG4gIGNvbnN0IHggPSByZWYoaW5pdGlhbFZhbHVlLngpO1xuICBjb25zdCB5ID0gcmVmKGluaXRpYWxWYWx1ZS55KTtcbiAgY29uc3Qgc291cmNlVHlwZSA9IHJlZihudWxsKTtcbiAgY29uc3QgZXh0cmFjdG9yID0gdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IHR5cGUgOiBVc2VNb3VzZUJ1aWx0aW5FeHRyYWN0b3JzW3R5cGVdO1xuICBjb25zdCBtb3VzZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0b3IoZXZlbnQpO1xuICAgIF9wcmV2TW91c2VFdmVudCA9IGV2ZW50O1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIFt4LnZhbHVlLCB5LnZhbHVlXSA9IHJlc3VsdDtcbiAgICAgIHNvdXJjZVR5cGUudmFsdWUgPSBcIm1vdXNlXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCB0b3VjaEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0b3IoZXZlbnQudG91Y2hlc1swXSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIFt4LnZhbHVlLCB5LnZhbHVlXSA9IHJlc3VsdDtcbiAgICAgICAgc291cmNlVHlwZS52YWx1ZSA9IFwidG91Y2hcIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFfcHJldk1vdXNlRXZlbnQgfHwgIXdpbmRvdylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3MgPSBleHRyYWN0b3IoX3ByZXZNb3VzZUV2ZW50KTtcbiAgICBpZiAoX3ByZXZNb3VzZUV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiBwb3MpIHtcbiAgICAgIHgudmFsdWUgPSBwb3NbMF0gKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgIHkudmFsdWUgPSBwb3NbMV0gKyB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgIHgudmFsdWUgPSBpbml0aWFsVmFsdWUueDtcbiAgICB5LnZhbHVlID0gaW5pdGlhbFZhbHVlLnk7XG4gIH07XG4gIGNvbnN0IG1vdXNlSGFuZGxlcldyYXBwZXIgPSBldmVudEZpbHRlciA/IChldmVudCkgPT4gZXZlbnRGaWx0ZXIoKCkgPT4gbW91c2VIYW5kbGVyKGV2ZW50KSwge30pIDogKGV2ZW50KSA9PiBtb3VzZUhhbmRsZXIoZXZlbnQpO1xuICBjb25zdCB0b3VjaEhhbmRsZXJXcmFwcGVyID0gZXZlbnRGaWx0ZXIgPyAoZXZlbnQpID0+IGV2ZW50RmlsdGVyKCgpID0+IHRvdWNoSGFuZGxlcihldmVudCksIHt9KSA6IChldmVudCkgPT4gdG91Y2hIYW5kbGVyKGV2ZW50KTtcbiAgY29uc3Qgc2Nyb2xsSGFuZGxlcldyYXBwZXIgPSBldmVudEZpbHRlciA/ICgpID0+IGV2ZW50RmlsdGVyKCgpID0+IHNjcm9sbEhhbmRsZXIoKSwge30pIDogKCkgPT4gc2Nyb2xsSGFuZGxlcigpO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgbGlzdGVuZXJPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIFtcIm1vdXNlbW92ZVwiLCBcImRyYWdvdmVyXCJdLCBtb3VzZUhhbmRsZXJXcmFwcGVyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIGlmICh0b3VjaCAmJiB0eXBlICE9PSBcIm1vdmVtZW50XCIpIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCJdLCB0b3VjaEhhbmRsZXJXcmFwcGVyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgICAgaWYgKHJlc2V0T25Ub3VjaEVuZHMpXG4gICAgICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInRvdWNoZW5kXCIsIHJlc2V0LCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2Nyb2xsICYmIHR5cGUgPT09IFwicGFnZVwiKVxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwic2Nyb2xsXCIsIHNjcm9sbEhhbmRsZXJXcmFwcGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgc291cmNlVHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VNb3VzZUluRWxlbWVudCh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlT3V0c2lkZSA9IHRydWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBcInBhZ2VcIjtcbiAgY29uc3QgeyB4LCB5LCBzb3VyY2VUeXBlIH0gPSB1c2VNb3VzZShvcHRpb25zKTtcbiAgY29uc3QgdGFyZ2V0UmVmID0gcmVmKHRhcmdldCAhPSBudWxsID8gdGFyZ2V0IDogd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG4gIGNvbnN0IGVsZW1lbnRYID0gcmVmKDApO1xuICBjb25zdCBlbGVtZW50WSA9IHJlZigwKTtcbiAgY29uc3QgZWxlbWVudFBvc2l0aW9uWCA9IHJlZigwKTtcbiAgY29uc3QgZWxlbWVudFBvc2l0aW9uWSA9IHJlZigwKTtcbiAgY29uc3QgZWxlbWVudEhlaWdodCA9IHJlZigwKTtcbiAgY29uc3QgZWxlbWVudFdpZHRoID0gcmVmKDApO1xuICBjb25zdCBpc091dHNpZGUgPSByZWYodHJ1ZSk7XG4gIGxldCBzdG9wID0gKCkgPT4ge1xuICB9O1xuICBpZiAod2luZG93KSB7XG4gICAgc3RvcCA9IHdhdGNoKFxuICAgICAgW3RhcmdldFJlZiwgeCwgeV0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KHRhcmdldFJlZik7XG4gICAgICAgIGlmICghZWwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZWxlbWVudFBvc2l0aW9uWC52YWx1ZSA9IGxlZnQgKyAodHlwZSA9PT0gXCJwYWdlXCIgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiAwKTtcbiAgICAgICAgZWxlbWVudFBvc2l0aW9uWS52YWx1ZSA9IHRvcCArICh0eXBlID09PSBcInBhZ2VcIiA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IDApO1xuICAgICAgICBlbGVtZW50SGVpZ2h0LnZhbHVlID0gaGVpZ2h0O1xuICAgICAgICBlbGVtZW50V2lkdGgudmFsdWUgPSB3aWR0aDtcbiAgICAgICAgY29uc3QgZWxYID0geC52YWx1ZSAtIGVsZW1lbnRQb3NpdGlvblgudmFsdWU7XG4gICAgICAgIGNvbnN0IGVsWSA9IHkudmFsdWUgLSBlbGVtZW50UG9zaXRpb25ZLnZhbHVlO1xuICAgICAgICBpc091dHNpZGUudmFsdWUgPSB3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDAgfHwgZWxYIDwgMCB8fCBlbFkgPCAwIHx8IGVsWCA+IHdpZHRoIHx8IGVsWSA+IGhlaWdodDtcbiAgICAgICAgaWYgKGhhbmRsZU91dHNpZGUgfHwgIWlzT3V0c2lkZS52YWx1ZSkge1xuICAgICAgICAgIGVsZW1lbnRYLnZhbHVlID0gZWxYO1xuICAgICAgICAgIGVsZW1lbnRZLnZhbHVlID0gZWxZO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICAgICk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIGlzT3V0c2lkZS52YWx1ZSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgc291cmNlVHlwZSxcbiAgICBlbGVtZW50WCxcbiAgICBlbGVtZW50WSxcbiAgICBlbGVtZW50UG9zaXRpb25YLFxuICAgIGVsZW1lbnRQb3NpdGlvblksXG4gICAgZWxlbWVudEhlaWdodCxcbiAgICBlbGVtZW50V2lkdGgsXG4gICAgaXNPdXRzaWRlLFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTW91c2VQcmVzc2VkKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdG91Y2ggPSB0cnVlLFxuICAgIGRyYWcgPSB0cnVlLFxuICAgIGNhcHR1cmUgPSBmYWxzZSxcbiAgICBpbml0aWFsVmFsdWUgPSBmYWxzZSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVzc2VkID0gcmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHNvdXJjZVR5cGUgPSByZWYobnVsbCk7XG4gIGlmICghd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZXNzZWQsXG4gICAgICBzb3VyY2VUeXBlXG4gICAgfTtcbiAgfVxuICBjb25zdCBvblByZXNzZWQgPSAoc3JjVHlwZSkgPT4gKCkgPT4ge1xuICAgIHByZXNzZWQudmFsdWUgPSB0cnVlO1xuICAgIHNvdXJjZVR5cGUudmFsdWUgPSBzcmNUeXBlO1xuICB9O1xuICBjb25zdCBvblJlbGVhc2VkID0gKCkgPT4ge1xuICAgIHByZXNzZWQudmFsdWUgPSBmYWxzZTtcbiAgICBzb3VyY2VUeXBlLnZhbHVlID0gbnVsbDtcbiAgfTtcbiAgY29uc3QgdGFyZ2V0ID0gY29tcHV0ZWQoKCkgPT4gdW5yZWZFbGVtZW50KG9wdGlvbnMudGFyZ2V0KSB8fCB3aW5kb3cpO1xuICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJtb3VzZWRvd25cIiwgb25QcmVzc2VkKFwibW91c2VcIiksIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwibW91c2VsZWF2ZVwiLCBvblJlbGVhc2VkLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmUgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm1vdXNldXBcIiwgb25SZWxlYXNlZCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICBpZiAoZHJhZykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcImRyYWdzdGFydFwiLCBvblByZXNzZWQoXCJtb3VzZVwiKSwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImRyb3BcIiwgb25SZWxlYXNlZCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImRyYWdlbmRcIiwgb25SZWxlYXNlZCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICB9XG4gIGlmICh0b3VjaCkge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInRvdWNoc3RhcnRcIiwgb25QcmVzc2VkKFwidG91Y2hcIiksIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZSB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2VkLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmUgfSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlZCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJlc3NlZCxcbiAgICBzb3VyY2VUeXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU5hdmlnYXRvckxhbmd1YWdlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gbmF2aWdhdG9yICYmIFwibGFuZ3VhZ2VcIiBpbiBuYXZpZ2F0b3IpO1xuICBjb25zdCBsYW5ndWFnZSA9IHJlZihuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImxhbmd1YWdlY2hhbmdlXCIsICgpID0+IHtcbiAgICBpZiAobmF2aWdhdG9yKVxuICAgICAgbGFuZ3VhZ2UudmFsdWUgPSBuYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGxhbmd1YWdlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU5ldHdvcmsob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJjb25uZWN0aW9uXCIgaW4gbmF2aWdhdG9yKTtcbiAgY29uc3QgaXNPbmxpbmUgPSByZWYodHJ1ZSk7XG4gIGNvbnN0IHNhdmVEYXRhID0gcmVmKGZhbHNlKTtcbiAgY29uc3Qgb2ZmbGluZUF0ID0gcmVmKHZvaWQgMCk7XG4gIGNvbnN0IG9ubGluZUF0ID0gcmVmKHZvaWQgMCk7XG4gIGNvbnN0IGRvd25saW5rID0gcmVmKHZvaWQgMCk7XG4gIGNvbnN0IGRvd25saW5rTWF4ID0gcmVmKHZvaWQgMCk7XG4gIGNvbnN0IHJ0dCA9IHJlZih2b2lkIDApO1xuICBjb25zdCBlZmZlY3RpdmVUeXBlID0gcmVmKHZvaWQgMCk7XG4gIGNvbnN0IHR5cGUgPSByZWYoXCJ1bmtub3duXCIpO1xuICBjb25zdCBjb25uZWN0aW9uID0gaXNTdXBwb3J0ZWQudmFsdWUgJiYgbmF2aWdhdG9yLmNvbm5lY3Rpb247XG4gIGZ1bmN0aW9uIHVwZGF0ZU5ldHdvcmtJbmZvcm1hdGlvbigpIHtcbiAgICBpZiAoIW5hdmlnYXRvcilcbiAgICAgIHJldHVybjtcbiAgICBpc09ubGluZS52YWx1ZSA9IG5hdmlnYXRvci5vbkxpbmU7XG4gICAgb2ZmbGluZUF0LnZhbHVlID0gaXNPbmxpbmUudmFsdWUgPyB2b2lkIDAgOiBEYXRlLm5vdygpO1xuICAgIG9ubGluZUF0LnZhbHVlID0gaXNPbmxpbmUudmFsdWUgPyBEYXRlLm5vdygpIDogdm9pZCAwO1xuICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICBkb3dubGluay52YWx1ZSA9IGNvbm5lY3Rpb24uZG93bmxpbms7XG4gICAgICBkb3dubGlua01heC52YWx1ZSA9IGNvbm5lY3Rpb24uZG93bmxpbmtNYXg7XG4gICAgICBlZmZlY3RpdmVUeXBlLnZhbHVlID0gY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlO1xuICAgICAgcnR0LnZhbHVlID0gY29ubmVjdGlvbi5ydHQ7XG4gICAgICBzYXZlRGF0YS52YWx1ZSA9IGNvbm5lY3Rpb24uc2F2ZURhdGE7XG4gICAgICB0eXBlLnZhbHVlID0gY29ubmVjdGlvbi50eXBlO1xuICAgIH1cbiAgfVxuICBpZiAod2luZG93KSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICBpc09ubGluZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgb2ZmbGluZUF0LnZhbHVlID0gRGF0ZS5ub3coKTtcbiAgICB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJvbmxpbmVcIiwgKCkgPT4ge1xuICAgICAgaXNPbmxpbmUudmFsdWUgPSB0cnVlO1xuICAgICAgb25saW5lQXQudmFsdWUgPSBEYXRlLm5vdygpO1xuICAgIH0pO1xuICB9XG4gIGlmIChjb25uZWN0aW9uKVxuICAgIHVzZUV2ZW50TGlzdGVuZXIoY29ubmVjdGlvbiwgXCJjaGFuZ2VcIiwgdXBkYXRlTmV0d29ya0luZm9ybWF0aW9uLCBmYWxzZSk7XG4gIHVwZGF0ZU5ldHdvcmtJbmZvcm1hdGlvbigpO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzT25saW5lLFxuICAgIHNhdmVEYXRhLFxuICAgIG9mZmxpbmVBdCxcbiAgICBvbmxpbmVBdCxcbiAgICBkb3dubGluayxcbiAgICBkb3dubGlua01heCxcbiAgICBlZmZlY3RpdmVUeXBlLFxuICAgIHJ0dCxcbiAgICB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzOiBleHBvc2VDb250cm9scyA9IGZhbHNlLFxuICAgIGludGVydmFsID0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgbm93ID0gcmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4gbm93LnZhbHVlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGNvbnN0IGNvbnRyb2xzID0gaW50ZXJ2YWwgPT09IFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgPyB1c2VSYWZGbih1cGRhdGUsIHsgaW1tZWRpYXRlOiB0cnVlIH0pIDogdXNlSW50ZXJ2YWxGbih1cGRhdGUsIGludGVydmFsLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vdyxcbiAgICAgIC4uLmNvbnRyb2xzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm93O1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU9iamVjdFVybChvYmplY3QpIHtcbiAgY29uc3QgdXJsID0gcmVmKCk7XG4gIGNvbnN0IHJlbGVhc2UgPSAoKSA9PiB7XG4gICAgaWYgKHVybC52YWx1ZSlcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsLnZhbHVlKTtcbiAgICB1cmwudmFsdWUgPSB2b2lkIDA7XG4gIH07XG4gIHdhdGNoKFxuICAgICgpID0+IHRvVmFsdWUob2JqZWN0KSxcbiAgICAobmV3T2JqZWN0KSA9PiB7XG4gICAgICByZWxlYXNlKCk7XG4gICAgICBpZiAobmV3T2JqZWN0KVxuICAgICAgICB1cmwudmFsdWUgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ld09iamVjdCk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHJlbGVhc2UpO1xuICByZXR1cm4gcmVhZG9ubHkodXJsKTtcbn1cblxuZnVuY3Rpb24gdXNlQ2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCBpc1JlYWRvbmx5KHZhbHVlKSlcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gY2xhbXAodG9WYWx1ZSh2YWx1ZSksIHRvVmFsdWUobWluKSwgdG9WYWx1ZShtYXgpKSk7XG4gIGNvbnN0IF92YWx1ZSA9IHJlZih2YWx1ZSk7XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIF92YWx1ZS52YWx1ZSA9IGNsYW1wKF92YWx1ZS52YWx1ZSwgdG9WYWx1ZShtaW4pLCB0b1ZhbHVlKG1heCkpO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlMikge1xuICAgICAgX3ZhbHVlLnZhbHVlID0gY2xhbXAodmFsdWUyLCB0b1ZhbHVlKG1pbiksIHRvVmFsdWUobWF4KSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlT2Zmc2V0UGFnaW5hdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0b3RhbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBwYWdlU2l6ZSA9IDEwLFxuICAgIHBhZ2UgPSAxLFxuICAgIG9uUGFnZUNoYW5nZSA9IG5vb3AsXG4gICAgb25QYWdlU2l6ZUNoYW5nZSA9IG5vb3AsXG4gICAgb25QYWdlQ291bnRDaGFuZ2UgPSBub29wXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdXJyZW50UGFnZVNpemUgPSB1c2VDbGFtcChwYWdlU2l6ZSwgMSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgY29uc3QgcGFnZUNvdW50ID0gY29tcHV0ZWQoKCkgPT4gTWF0aC5tYXgoXG4gICAgMSxcbiAgICBNYXRoLmNlaWwodG9WYWx1ZSh0b3RhbCkgLyB0b1ZhbHVlKGN1cnJlbnRQYWdlU2l6ZSkpXG4gICkpO1xuICBjb25zdCBjdXJyZW50UGFnZSA9IHVzZUNsYW1wKHBhZ2UsIDEsIHBhZ2VDb3VudCk7XG4gIGNvbnN0IGlzRmlyc3RQYWdlID0gY29tcHV0ZWQoKCkgPT4gY3VycmVudFBhZ2UudmFsdWUgPT09IDEpO1xuICBjb25zdCBpc0xhc3RQYWdlID0gY29tcHV0ZWQoKCkgPT4gY3VycmVudFBhZ2UudmFsdWUgPT09IHBhZ2VDb3VudC52YWx1ZSk7XG4gIGlmIChpc1JlZihwYWdlKSkge1xuICAgIHN5bmNSZWYocGFnZSwgY3VycmVudFBhZ2UsIHtcbiAgICAgIGRpcmVjdGlvbjogaXNSZWFkb25seShwYWdlKSA/IFwibHRyXCIgOiBcImJvdGhcIlxuICAgIH0pO1xuICB9XG4gIGlmIChpc1JlZihwYWdlU2l6ZSkpIHtcbiAgICBzeW5jUmVmKHBhZ2VTaXplLCBjdXJyZW50UGFnZVNpemUsIHtcbiAgICAgIGRpcmVjdGlvbjogaXNSZWFkb25seShwYWdlU2l6ZSkgPyBcImx0clwiIDogXCJib3RoXCJcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2KCkge1xuICAgIGN1cnJlbnRQYWdlLnZhbHVlLS07XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBjdXJyZW50UGFnZS52YWx1ZSsrO1xuICB9XG4gIGNvbnN0IHJldHVyblZhbHVlID0ge1xuICAgIGN1cnJlbnRQYWdlLFxuICAgIGN1cnJlbnRQYWdlU2l6ZSxcbiAgICBwYWdlQ291bnQsXG4gICAgaXNGaXJzdFBhZ2UsXG4gICAgaXNMYXN0UGFnZSxcbiAgICBwcmV2LFxuICAgIG5leHRcbiAgfTtcbiAgd2F0Y2goY3VycmVudFBhZ2UsICgpID0+IHtcbiAgICBvblBhZ2VDaGFuZ2UocmVhY3RpdmUocmV0dXJuVmFsdWUpKTtcbiAgfSk7XG4gIHdhdGNoKGN1cnJlbnRQYWdlU2l6ZSwgKCkgPT4ge1xuICAgIG9uUGFnZVNpemVDaGFuZ2UocmVhY3RpdmUocmV0dXJuVmFsdWUpKTtcbiAgfSk7XG4gIHdhdGNoKHBhZ2VDb3VudCwgKCkgPT4ge1xuICAgIG9uUGFnZUNvdW50Q2hhbmdlKHJlYWN0aXZlKHJldHVyblZhbHVlKSk7XG4gIH0pO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZU9ubGluZShvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBpc09ubGluZSB9ID0gdXNlTmV0d29yayhvcHRpb25zKTtcbiAgcmV0dXJuIGlzT25saW5lO1xufVxuXG5mdW5jdGlvbiB1c2VQYWdlTGVhdmUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93ID0gZGVmYXVsdFdpbmRvdyB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNMZWZ0ID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlmICghd2luZG93KVxuICAgICAgcmV0dXJuO1xuICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICAgIGNvbnN0IGZyb20gPSBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRvRWxlbWVudDtcbiAgICBpc0xlZnQudmFsdWUgPSAhZnJvbTtcbiAgfTtcbiAgaWYgKHdpbmRvdykge1xuICAgIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcIm1vdXNlb3V0XCIsIGhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudCwgXCJtb3VzZWxlYXZlXCIsIGhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudCwgXCJtb3VzZWVudGVyXCIsIGhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gaXNMZWZ0O1xufVxuXG5mdW5jdGlvbiB1c2VTY3JlZW5PcmllbnRhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcInNjcmVlblwiIGluIHdpbmRvdyAmJiBcIm9yaWVudGF0aW9uXCIgaW4gd2luZG93LnNjcmVlbik7XG4gIGNvbnN0IHNjcmVlbk9yaWVudGF0aW9uID0gaXNTdXBwb3J0ZWQudmFsdWUgPyB3aW5kb3cuc2NyZWVuLm9yaWVudGF0aW9uIDoge307XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gcmVmKHNjcmVlbk9yaWVudGF0aW9uLnR5cGUpO1xuICBjb25zdCBhbmdsZSA9IHJlZihzY3JlZW5PcmllbnRhdGlvbi5hbmdsZSB8fCAwKTtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwib3JpZW50YXRpb25jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgb3JpZW50YXRpb24udmFsdWUgPSBzY3JlZW5PcmllbnRhdGlvbi50eXBlO1xuICAgICAgYW5nbGUudmFsdWUgPSBzY3JlZW5PcmllbnRhdGlvbi5hbmdsZTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsb2NrT3JpZW50YXRpb24gPSAodHlwZSkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB0eXBlb2Ygc2NyZWVuT3JpZW50YXRpb24ubG9jayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIHNjcmVlbk9yaWVudGF0aW9uLmxvY2sodHlwZSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWRcIikpO1xuICB9O1xuICBjb25zdCB1bmxvY2tPcmllbnRhdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUgJiYgdHlwZW9mIHNjcmVlbk9yaWVudGF0aW9uLnVubG9jayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgc2NyZWVuT3JpZW50YXRpb24udW5sb2NrKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgYW5nbGUsXG4gICAgbG9ja09yaWVudGF0aW9uLFxuICAgIHVubG9ja09yaWVudGF0aW9uXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVBhcmFsbGF4KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZXZpY2VPcmllbnRhdGlvblRpbHRBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICBkZXZpY2VPcmllbnRhdGlvblJvbGxBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICBtb3VzZVRpbHRBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICBtb3VzZVJvbGxBZGp1c3QgPSAoaSkgPT4gaSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBvcmllbnRhdGlvbiA9IHJlYWN0aXZlKHVzZURldmljZU9yaWVudGF0aW9uKHsgd2luZG93IH0pKTtcbiAgY29uc3Qgc2NyZWVuT3JpZW50YXRpb24gPSByZWFjdGl2ZSh1c2VTY3JlZW5PcmllbnRhdGlvbih7IHdpbmRvdyB9KSk7XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50WDogeCxcbiAgICBlbGVtZW50WTogeSxcbiAgICBlbGVtZW50V2lkdGg6IHdpZHRoLFxuICAgIGVsZW1lbnRIZWlnaHQ6IGhlaWdodFxuICB9ID0gdXNlTW91c2VJbkVsZW1lbnQodGFyZ2V0LCB7IGhhbmRsZU91dHNpZGU6IGZhbHNlLCB3aW5kb3cgfSk7XG4gIGNvbnN0IHNvdXJjZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAob3JpZW50YXRpb24uaXNTdXBwb3J0ZWQgJiYgKG9yaWVudGF0aW9uLmFscGhhICE9IG51bGwgJiYgb3JpZW50YXRpb24uYWxwaGEgIT09IDAgfHwgb3JpZW50YXRpb24uZ2FtbWEgIT0gbnVsbCAmJiBvcmllbnRhdGlvbi5nYW1tYSAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBcImRldmljZU9yaWVudGF0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiBcIm1vdXNlXCI7XG4gIH0pO1xuICBjb25zdCByb2xsID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChzb3VyY2UudmFsdWUgPT09IFwiZGV2aWNlT3JpZW50YXRpb25cIikge1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgc3dpdGNoIChzY3JlZW5PcmllbnRhdGlvbi5vcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlIFwibGFuZHNjYXBlLXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsYW5kc2NhcGUtc2Vjb25kYXJ5XCI6XG4gICAgICAgICAgdmFsdWUgPSAtb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvcnRyYWl0LXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3J0cmFpdC1zZWNvbmRhcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5iZXRhIC8gOTA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlT3JpZW50YXRpb25Sb2xsQWRqdXN0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSAtKHkudmFsdWUgLSBoZWlnaHQudmFsdWUgLyAyKSAvIGhlaWdodC52YWx1ZTtcbiAgICAgIHJldHVybiBtb3VzZVJvbGxBZGp1c3QodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRpbHQgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKHNvdXJjZS52YWx1ZSA9PT0gXCJkZXZpY2VPcmllbnRhdGlvblwiKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBzd2l0Y2ggKHNjcmVlbk9yaWVudGF0aW9uLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJsYW5kc2NhcGUtcHJpbWFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uYmV0YSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGFuZHNjYXBlLXNlY29uZGFyeVwiOlxuICAgICAgICAgIHZhbHVlID0gLW9yaWVudGF0aW9uLmJldGEgLyA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBvcnRyYWl0LXByaW1hcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IG9yaWVudGF0aW9uLmdhbW1hIC8gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3J0cmFpdC1zZWNvbmRhcnlcIjpcbiAgICAgICAgICB2YWx1ZSA9IC1vcmllbnRhdGlvbi5nYW1tYSAvIDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlID0gb3JpZW50YXRpb24uZ2FtbWEgLyA5MDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VPcmllbnRhdGlvblRpbHRBZGp1c3QodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWx1ZSA9ICh4LnZhbHVlIC0gd2lkdGgudmFsdWUgLyAyKSAvIHdpZHRoLnZhbHVlO1xuICAgICAgcmV0dXJuIG1vdXNlVGlsdEFkanVzdCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgcm9sbCwgdGlsdCwgc291cmNlIH07XG59XG5cbmZ1bmN0aW9uIHVzZVBhcmVudEVsZW1lbnQoZWxlbWVudCA9IHVzZUN1cnJlbnRFbGVtZW50KCkpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gdW5yZWZFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChlbClcbiAgICAgIHBhcmVudEVsZW1lbnQudmFsdWUgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9O1xuICB0cnlPbk1vdW50ZWQodXBkYXRlKTtcbiAgd2F0Y2goKCkgPT4gdG9WYWx1ZShlbGVtZW50KSwgdXBkYXRlKTtcbiAgcmV0dXJuIHBhcmVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZVBlcmZvcm1hbmNlT2JzZXJ2ZXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICAuLi5wZXJmb3JtYW5jZU9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdXNlU3VwcG9ydGVkKCgpID0+IHdpbmRvdyAmJiBcIlBlcmZvcm1hbmNlT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpO1xuICBsZXQgb2JzZXJ2ZXI7XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgICBzdG9wKCk7XG4gICAgICBvYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUocGVyZm9ybWFuY2VPcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHN0b3ApO1xuICBpZiAoaW1tZWRpYXRlKVxuICAgIHN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RhcnQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHBvaW50ZXJJZDogMCxcbiAgcHJlc3N1cmU6IDAsXG4gIHRpbHRYOiAwLFxuICB0aWx0WTogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgdHdpc3Q6IDAsXG4gIHBvaW50ZXJUeXBlOiBudWxsXG59O1xuY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3Qua2V5cyhkZWZhdWx0U3RhdGUpO1xuZnVuY3Rpb24gdXNlUG9pbnRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldCA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlzSW5zaWRlID0gcmVmKGZhbHNlKTtcbiAgY29uc3Qgc3RhdGUgPSByZWYob3B0aW9ucy5pbml0aWFsVmFsdWUgfHwge30pO1xuICBPYmplY3QuYXNzaWduKHN0YXRlLnZhbHVlLCBkZWZhdWx0U3RhdGUsIHN0YXRlLnZhbHVlKTtcbiAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlzSW5zaWRlLnZhbHVlID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5wb2ludGVyVHlwZXMgJiYgIW9wdGlvbnMucG9pbnRlclR5cGVzLmluY2x1ZGVzKGV2ZW50LnBvaW50ZXJUeXBlKSlcbiAgICAgIHJldHVybjtcbiAgICBzdGF0ZS52YWx1ZSA9IG9iamVjdFBpY2soZXZlbnQsIGtleXMsIGZhbHNlKTtcbiAgfTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBbXCJwb2ludGVyZG93blwiLCBcInBvaW50ZXJtb3ZlXCIsIFwicG9pbnRlcnVwXCJdLCBoYW5kbGVyLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBvaW50ZXJsZWF2ZVwiLCAoKSA9PiBpc0luc2lkZS52YWx1ZSA9IGZhbHNlLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4udG9SZWZzKHN0YXRlKSxcbiAgICBpc0luc2lkZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQb2ludGVyTG9jayh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50IH0gPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBkb2N1bWVudCAmJiBcInBvaW50ZXJMb2NrRWxlbWVudFwiIGluIGRvY3VtZW50KTtcbiAgY29uc3QgZWxlbWVudCA9IHJlZigpO1xuICBjb25zdCB0cmlnZ2VyRWxlbWVudCA9IHJlZigpO1xuICBsZXQgdGFyZ2V0RWxlbWVudDtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJwb2ludGVybG9ja2NoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IChfYSA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCkgIT0gbnVsbCA/IF9hIDogZWxlbWVudC52YWx1ZTtcbiAgICAgIGlmICh0YXJnZXRFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50ID09PSB0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ7XG4gICAgICAgIGlmICghZWxlbWVudC52YWx1ZSlcbiAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gdHJpZ2dlckVsZW1lbnQudmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsIFwicG9pbnRlcmxvY2tlcnJvclwiLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IChfYSA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCkgIT0gbnVsbCA/IF9hIDogZWxlbWVudC52YWx1ZTtcbiAgICAgIGlmICh0YXJnZXRFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50ID09PSB0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCA/IFwicmVsZWFzZVwiIDogXCJhY3F1aXJlXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvICR7YWN0aW9ufSBwb2ludGVyIGxvY2suYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9jayhlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2ludGVyIExvY2sgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyLlwiKTtcbiAgICB0cmlnZ2VyRWxlbWVudC52YWx1ZSA9IGUgaW5zdGFuY2VvZiBFdmVudCA/IGUuY3VycmVudFRhcmdldCA6IG51bGw7XG4gICAgdGFyZ2V0RWxlbWVudCA9IGUgaW5zdGFuY2VvZiBFdmVudCA/IChfYSA9IHVucmVmRWxlbWVudCh0YXJnZXQpKSAhPSBudWxsID8gX2EgOiB0cmlnZ2VyRWxlbWVudC52YWx1ZSA6IHVucmVmRWxlbWVudChlKTtcbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgZWxlbWVudCB1bmRlZmluZWQuXCIpO1xuICAgIHRhcmdldEVsZW1lbnQucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgcmV0dXJuIGF3YWl0IHVudGlsKGVsZW1lbnQpLnRvQmUodGFyZ2V0RWxlbWVudCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgIGlmICghZWxlbWVudC52YWx1ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgICBhd2FpdCB1bnRpbChlbGVtZW50KS50b0JlTnVsbCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgZWxlbWVudCxcbiAgICB0cmlnZ2VyRWxlbWVudCxcbiAgICBsb2NrLFxuICAgIHVubG9ja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQb2ludGVyU3dpcGUodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgdGFyZ2V0UmVmID0gdG9SZWYodGFyZ2V0KTtcbiAgY29uc3Qge1xuICAgIHRocmVzaG9sZCA9IDUwLFxuICAgIG9uU3dpcGUsXG4gICAgb25Td2lwZUVuZCxcbiAgICBvblN3aXBlU3RhcnQsXG4gICAgZGlzYWJsZVRleHRTZWxlY3QgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcG9zU3RhcnQgPSByZWFjdGl2ZSh7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IHVwZGF0ZVBvc1N0YXJ0ID0gKHgsIHkpID0+IHtcbiAgICBwb3NTdGFydC54ID0geDtcbiAgICBwb3NTdGFydC55ID0geTtcbiAgfTtcbiAgY29uc3QgcG9zRW5kID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCB1cGRhdGVQb3NFbmQgPSAoeCwgeSkgPT4ge1xuICAgIHBvc0VuZC54ID0geDtcbiAgICBwb3NFbmQueSA9IHk7XG4gIH07XG4gIGNvbnN0IGRpc3RhbmNlWCA9IGNvbXB1dGVkKCgpID0+IHBvc1N0YXJ0LnggLSBwb3NFbmQueCk7XG4gIGNvbnN0IGRpc3RhbmNlWSA9IGNvbXB1dGVkKCgpID0+IHBvc1N0YXJ0LnkgLSBwb3NFbmQueSk7XG4gIGNvbnN0IHsgbWF4LCBhYnMgfSA9IE1hdGg7XG4gIGNvbnN0IGlzVGhyZXNob2xkRXhjZWVkZWQgPSBjb21wdXRlZCgoKSA9PiBtYXgoYWJzKGRpc3RhbmNlWC52YWx1ZSksIGFicyhkaXN0YW5jZVkudmFsdWUpKSA+PSB0aHJlc2hvbGQpO1xuICBjb25zdCBpc1N3aXBpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBpc1BvaW50ZXJEb3duID0gcmVmKGZhbHNlKTtcbiAgY29uc3QgZGlyZWN0aW9uID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmICghaXNUaHJlc2hvbGRFeGNlZWRlZC52YWx1ZSlcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICBpZiAoYWJzKGRpc3RhbmNlWC52YWx1ZSkgPiBhYnMoZGlzdGFuY2VZLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGRpc3RhbmNlWC52YWx1ZSA+IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRpc3RhbmNlWS52YWx1ZSA+IDAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBldmVudElzQWxsb3dlZCA9IChlKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgaXNSZWxlYXNpbmdCdXR0b24gPSBlLmJ1dHRvbnMgPT09IDA7XG4gICAgY29uc3QgaXNQcmltYXJ5QnV0dG9uID0gZS5idXR0b25zID09PSAxO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBvcHRpb25zLnBvaW50ZXJUeXBlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKGUucG9pbnRlclR5cGUpKSAhPSBudWxsID8gX2IgOiBpc1JlbGVhc2luZ0J1dHRvbiB8fCBpc1ByaW1hcnlCdXR0b24pICE9IG51bGwgPyBfYyA6IHRydWU7XG4gIH07XG4gIGNvbnN0IHN0b3BzID0gW1xuICAgIHVzZUV2ZW50TGlzdGVuZXIodGFyZ2V0LCBcInBvaW50ZXJkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50SXNBbGxvd2VkKGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpc1BvaW50ZXJEb3duLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICBldmVudFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgICAgY29uc3QgeyBjbGllbnRYOiB4LCBjbGllbnRZOiB5IH0gPSBlO1xuICAgICAgdXBkYXRlUG9zU3RhcnQoeCwgeSk7XG4gICAgICB1cGRhdGVQb3NFbmQoeCwgeSk7XG4gICAgICBvblN3aXBlU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGVTdGFydChlKTtcbiAgICB9KSxcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVybW92ZVwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCFldmVudElzQWxsb3dlZChlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFpc1BvaW50ZXJEb3duLnZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IGNsaWVudFg6IHgsIGNsaWVudFk6IHkgfSA9IGU7XG4gICAgICB1cGRhdGVQb3NFbmQoeCwgeSk7XG4gICAgICBpZiAoIWlzU3dpcGluZy52YWx1ZSAmJiBpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgICBpc1N3aXBpbmcudmFsdWUgPSB0cnVlO1xuICAgICAgaWYgKGlzU3dpcGluZy52YWx1ZSlcbiAgICAgICAgb25Td2lwZSA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZShlKTtcbiAgICB9KSxcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJwb2ludGVydXBcIiwgKGUpID0+IHtcbiAgICAgIGlmICghZXZlbnRJc0FsbG93ZWQoZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChpc1N3aXBpbmcudmFsdWUpXG4gICAgICAgIG9uU3dpcGVFbmQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGVFbmQoZSwgZGlyZWN0aW9uLnZhbHVlKTtcbiAgICAgIGlzUG9pbnRlckRvd24udmFsdWUgPSBmYWxzZTtcbiAgICAgIGlzU3dpcGluZy52YWx1ZSA9IGZhbHNlO1xuICAgIH0pXG4gIF07XG4gIHRyeU9uTW91bnRlZCgoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAoX2IgPSAoX2EgPSB0YXJnZXRSZWYudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNldFByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKTtcbiAgICBpZiAoZGlzYWJsZVRleHRTZWxlY3QpIHtcbiAgICAgIChfZCA9IChfYyA9IHRhcmdldFJlZi52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2Quc2V0UHJvcGVydHkoXCItd2Via2l0LXVzZXItc2VsZWN0XCIsIFwibm9uZVwiKTtcbiAgICAgIChfZiA9IChfZSA9IHRhcmdldFJlZi52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2Yuc2V0UHJvcGVydHkoXCItbXMtdXNlci1zZWxlY3RcIiwgXCJub25lXCIpO1xuICAgICAgKF9oID0gKF9nID0gdGFyZ2V0UmVmLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2cuc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBfaC5zZXRQcm9wZXJ0eShcInVzZXItc2VsZWN0XCIsIFwibm9uZVwiKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdG9wID0gKCkgPT4gc3RvcHMuZm9yRWFjaCgocykgPT4gcygpKTtcbiAgcmV0dXJuIHtcbiAgICBpc1N3aXBpbmc6IHJlYWRvbmx5KGlzU3dpcGluZyksXG4gICAgZGlyZWN0aW9uOiByZWFkb25seShkaXJlY3Rpb24pLFxuICAgIHBvc1N0YXJ0OiByZWFkb25seShwb3NTdGFydCksXG4gICAgcG9zRW5kOiByZWFkb25seShwb3NFbmQpLFxuICAgIGRpc3RhbmNlWCxcbiAgICBkaXN0YW5jZVksXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXJyZWRDb2xvclNjaGVtZShvcHRpb25zKSB7XG4gIGNvbnN0IGlzTGlnaHQgPSB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBsaWdodClcIiwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzRGFyayA9IHVzZU1lZGlhUXVlcnkoXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGlmIChpc0RhcmsudmFsdWUpXG4gICAgICByZXR1cm4gXCJkYXJrXCI7XG4gICAgaWYgKGlzTGlnaHQudmFsdWUpXG4gICAgICByZXR1cm4gXCJsaWdodFwiO1xuICAgIHJldHVybiBcIm5vLXByZWZlcmVuY2VcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZWZlcnJlZENvbnRyYXN0KG9wdGlvbnMpIHtcbiAgY29uc3QgaXNNb3JlID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbnRyYXN0OiBtb3JlKVwiLCBvcHRpb25zKTtcbiAgY29uc3QgaXNMZXNzID0gdXNlTWVkaWFRdWVyeShcIihwcmVmZXJzLWNvbnRyYXN0OiBsZXNzKVwiLCBvcHRpb25zKTtcbiAgY29uc3QgaXNDdXN0b20gPSB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtY29udHJhc3Q6IGN1c3RvbSlcIiwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKGlzTW9yZS52YWx1ZSlcbiAgICAgIHJldHVybiBcIm1vcmVcIjtcbiAgICBpZiAoaXNMZXNzLnZhbHVlKVxuICAgICAgcmV0dXJuIFwibGVzc1wiO1xuICAgIGlmIChpc0N1c3RvbS52YWx1ZSlcbiAgICAgIHJldHVybiBcImN1c3RvbVwiO1xuICAgIHJldHVybiBcIm5vLXByZWZlcmVuY2VcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZWZlcnJlZExhbmd1YWdlcyhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICBpZiAoIXdpbmRvdylcbiAgICByZXR1cm4gcmVmKFtcImVuXCJdKTtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgY29uc3QgdmFsdWUgPSByZWYobmF2aWdhdG9yLmxhbmd1YWdlcyk7XG4gIHVzZUV2ZW50TGlzdGVuZXIod2luZG93LCBcImxhbmd1YWdlY2hhbmdlXCIsICgpID0+IHtcbiAgICB2YWx1ZS52YWx1ZSA9IG5hdmlnYXRvci5sYW5ndWFnZXM7XG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVByZWZlcnJlZFJlZHVjZWRNb3Rpb24ob3B0aW9ucykge1xuICBjb25zdCBpc1JlZHVjZWQgPSB1c2VNZWRpYVF1ZXJ5KFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIiwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKGlzUmVkdWNlZC52YWx1ZSlcbiAgICAgIHJldHVybiBcInJlZHVjZVwiO1xuICAgIHJldHVybiBcIm5vLXByZWZlcmVuY2VcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVByZXZpb3VzKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBzaGFsbG93UmVmKGluaXRpYWxWYWx1ZSk7XG4gIHdhdGNoKFxuICAgIHRvUmVmKHZhbHVlKSxcbiAgICAoXywgb2xkVmFsdWUpID0+IHtcbiAgICAgIHByZXZpb3VzLnZhbHVlID0gb2xkVmFsdWU7XG4gICAgfSxcbiAgICB7IGZsdXNoOiBcInN5bmNcIiB9XG4gICk7XG4gIHJldHVybiByZWFkb25seShwcmV2aW91cyk7XG59XG5cbmNvbnN0IHRvcFZhck5hbWUgPSBcIi0tdnVldXNlLXNhZmUtYXJlYS10b3BcIjtcbmNvbnN0IHJpZ2h0VmFyTmFtZSA9IFwiLS12dWV1c2Utc2FmZS1hcmVhLXJpZ2h0XCI7XG5jb25zdCBib3R0b21WYXJOYW1lID0gXCItLXZ1ZXVzZS1zYWZlLWFyZWEtYm90dG9tXCI7XG5jb25zdCBsZWZ0VmFyTmFtZSA9IFwiLS12dWV1c2Utc2FmZS1hcmVhLWxlZnRcIjtcbmZ1bmN0aW9uIHVzZVNjcmVlblNhZmVBcmVhKCkge1xuICBjb25zdCB0b3AgPSByZWYoXCJcIik7XG4gIGNvbnN0IHJpZ2h0ID0gcmVmKFwiXCIpO1xuICBjb25zdCBib3R0b20gPSByZWYoXCJcIik7XG4gIGNvbnN0IGxlZnQgPSByZWYoXCJcIik7XG4gIGlmIChpc0NsaWVudCkge1xuICAgIGNvbnN0IHRvcENzc1ZhciA9IHVzZUNzc1Zhcih0b3BWYXJOYW1lKTtcbiAgICBjb25zdCByaWdodENzc1ZhciA9IHVzZUNzc1ZhcihyaWdodFZhck5hbWUpO1xuICAgIGNvbnN0IGJvdHRvbUNzc1ZhciA9IHVzZUNzc1Zhcihib3R0b21WYXJOYW1lKTtcbiAgICBjb25zdCBsZWZ0Q3NzVmFyID0gdXNlQ3NzVmFyKGxlZnRWYXJOYW1lKTtcbiAgICB0b3BDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtdG9wLCAwcHgpXCI7XG4gICAgcmlnaHRDc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtcmlnaHQsIDBweClcIjtcbiAgICBib3R0b21Dc3NWYXIudmFsdWUgPSBcImVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tLCAwcHgpXCI7XG4gICAgbGVmdENzc1Zhci52YWx1ZSA9IFwiZW52KHNhZmUtYXJlYS1pbnNldC1sZWZ0LCAwcHgpXCI7XG4gICAgdXBkYXRlKCk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1c2VEZWJvdW5jZUZuKHVwZGF0ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0b3AudmFsdWUgPSBnZXRWYWx1ZSh0b3BWYXJOYW1lKTtcbiAgICByaWdodC52YWx1ZSA9IGdldFZhbHVlKHJpZ2h0VmFyTmFtZSk7XG4gICAgYm90dG9tLnZhbHVlID0gZ2V0VmFsdWUoYm90dG9tVmFyTmFtZSk7XG4gICAgbGVmdC52YWx1ZSA9IGdldFZhbHVlKGxlZnRWYXJOYW1lKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcCxcbiAgICByaWdodCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKHBvc2l0aW9uKSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHVzZVNjcmlwdFRhZyhzcmMsIG9uTG9hZGVkID0gbm9vcCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIG1hbnVhbCA9IGZhbHNlLFxuICAgIHR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiLFxuICAgIGFzeW5jID0gdHJ1ZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICByZWZlcnJlclBvbGljeSxcbiAgICBub01vZHVsZSxcbiAgICBkZWZlcixcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBhdHRycyA9IHt9XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzY3JpcHRUYWcgPSByZWYobnVsbCk7XG4gIGxldCBfcHJvbWlzZSA9IG51bGw7XG4gIGNvbnN0IGxvYWRTY3JpcHQgPSAod2FpdEZvclNjcmlwdExvYWQpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXNvbHZlV2l0aEVsZW1lbnQgPSAoZWwyKSA9PiB7XG4gICAgICBzY3JpcHRUYWcudmFsdWUgPSBlbDI7XG4gICAgICByZXNvbHZlKGVsMik7XG4gICAgICByZXR1cm4gZWwyO1xuICAgIH07XG4gICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzaG91bGRBcHBlbmQgPSBmYWxzZTtcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjPVwiJHt0b1ZhbHVlKHNyYyl9XCJdYCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgZWwudHlwZSA9IHR5cGU7XG4gICAgICBlbC5hc3luYyA9IGFzeW5jO1xuICAgICAgZWwuc3JjID0gdG9WYWx1ZShzcmMpO1xuICAgICAgaWYgKGRlZmVyKVxuICAgICAgICBlbC5kZWZlciA9IGRlZmVyO1xuICAgICAgaWYgKGNyb3NzT3JpZ2luKVxuICAgICAgICBlbC5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgaWYgKG5vTW9kdWxlKVxuICAgICAgICBlbC5ub01vZHVsZSA9IG5vTW9kdWxlO1xuICAgICAgaWYgKHJlZmVycmVyUG9saWN5KVxuICAgICAgICBlbC5yZWZlcnJlclBvbGljeSA9IHJlZmVycmVyUG9saWN5O1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXR0cnMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKTtcbiAgICAgIHNob3VsZEFwcGVuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWxvYWRlZFwiKSkge1xuICAgICAgcmVzb2x2ZVdpdGhFbGVtZW50KGVsKTtcbiAgICB9XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50KSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIChldmVudCkgPT4gcmVqZWN0KGV2ZW50KSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sb2FkZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgb25Mb2FkZWQoZWwpO1xuICAgICAgcmVzb2x2ZVdpdGhFbGVtZW50KGVsKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkQXBwZW5kKVxuICAgICAgZWwgPSBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsKTtcbiAgICBpZiAoIXdhaXRGb3JTY3JpcHRMb2FkKVxuICAgICAgcmVzb2x2ZVdpdGhFbGVtZW50KGVsKTtcbiAgfSk7XG4gIGNvbnN0IGxvYWQgPSAod2FpdEZvclNjcmlwdExvYWQgPSB0cnVlKSA9PiB7XG4gICAgaWYgKCFfcHJvbWlzZSlcbiAgICAgIF9wcm9taXNlID0gbG9hZFNjcmlwdCh3YWl0Rm9yU2NyaXB0TG9hZCk7XG4gICAgcmV0dXJuIF9wcm9taXNlO1xuICB9O1xuICBjb25zdCB1bmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudClcbiAgICAgIHJldHVybjtcbiAgICBfcHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKHNjcmlwdFRhZy52YWx1ZSlcbiAgICAgIHNjcmlwdFRhZy52YWx1ZSA9IG51bGw7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjPVwiJHt0b1ZhbHVlKHNyYyl9XCJdYCk7XG4gICAgaWYgKGVsKVxuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChlbCk7XG4gIH07XG4gIGlmIChpbW1lZGlhdGUgJiYgIW1hbnVhbClcbiAgICB0cnlPbk1vdW50ZWQobG9hZCk7XG4gIGlmICghbWFudWFsKVxuICAgIHRyeU9uVW5tb3VudGVkKHVubG9hZCk7XG4gIHJldHVybiB7IHNjcmlwdFRhZywgbG9hZCwgdW5sb2FkIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3dTY3JvbGwoZWxlKSB7XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlKTtcbiAgaWYgKHN0eWxlLm92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fCBzdHlsZS5vdmVyZmxvd1kgPT09IFwic2Nyb2xsXCIgfHwgc3R5bGUub3ZlcmZsb3dYID09PSBcImF1dG9cIiAmJiBlbGUuY2xpZW50V2lkdGggPCBlbGUuc2Nyb2xsV2lkdGggfHwgc3R5bGUub3ZlcmZsb3dZID09PSBcImF1dG9cIiAmJiBlbGUuY2xpZW50SGVpZ2h0IDwgZWxlLnNjcm9sbEhlaWdodCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC50YWdOYW1lID09PSBcIkJPRFlcIilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY2hlY2tPdmVyZmxvd1Njcm9sbChwYXJlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChyYXdFdmVudCkge1xuICBjb25zdCBlID0gcmF3RXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICBjb25zdCBfdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmIChjaGVja092ZXJmbG93U2Nyb2xsKF90YXJnZXQpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGVsSW5pdGlhbE92ZXJmbG93ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB1c2VTY3JvbGxMb2NrKGVsZW1lbnQsIGluaXRpYWxTdGF0ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGlzTG9ja2VkID0gcmVmKGluaXRpYWxTdGF0ZSk7XG4gIGxldCBzdG9wVG91Y2hNb3ZlTGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaW5pdGlhbE92ZXJmbG93ID0gXCJcIjtcbiAgd2F0Y2godG9SZWYoZWxlbWVudCksIChlbCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHJlc29sdmVFbGVtZW50KHRvVmFsdWUoZWwpKTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBjb25zdCBlbGUgPSB0YXJnZXQ7XG4gICAgICBpZiAoIWVsSW5pdGlhbE92ZXJmbG93LmdldChlbGUpKVxuICAgICAgICBlbEluaXRpYWxPdmVyZmxvdy5zZXQoZWxlLCBlbGUuc3R5bGUub3ZlcmZsb3cpO1xuICAgICAgaWYgKGVsZS5zdHlsZS5vdmVyZmxvdyAhPT0gXCJoaWRkZW5cIilcbiAgICAgICAgaW5pdGlhbE92ZXJmbG93ID0gZWxlLnN0eWxlLm92ZXJmbG93O1xuICAgICAgaWYgKGVsZS5zdHlsZS5vdmVyZmxvdyA9PT0gXCJoaWRkZW5cIilcbiAgICAgICAgcmV0dXJuIGlzTG9ja2VkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGlmIChpc0xvY2tlZC52YWx1ZSlcbiAgICAgICAgcmV0dXJuIGVsZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgfVxuICB9LCB7XG4gICAgaW1tZWRpYXRlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBsb2NrID0gKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gcmVzb2x2ZUVsZW1lbnQodG9WYWx1ZShlbGVtZW50KSk7XG4gICAgaWYgKCFlbCB8fCBpc0xvY2tlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNJT1MpIHtcbiAgICAgIHN0b3BUb3VjaE1vdmVMaXN0ZW5lciA9IHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIGVsLFxuICAgICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9LFxuICAgICAgICB7IHBhc3NpdmU6IGZhbHNlIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBpc0xvY2tlZC52YWx1ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICBjb25zdCBlbCA9IHJlc29sdmVFbGVtZW50KHRvVmFsdWUoZWxlbWVudCkpO1xuICAgIGlmICghZWwgfHwgIWlzTG9ja2VkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlzSU9TICYmIChzdG9wVG91Y2hNb3ZlTGlzdGVuZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3BUb3VjaE1vdmVMaXN0ZW5lcigpKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9IGluaXRpYWxPdmVyZmxvdztcbiAgICBlbEluaXRpYWxPdmVyZmxvdy5kZWxldGUoZWwpO1xuICAgIGlzTG9ja2VkLnZhbHVlID0gZmFsc2U7XG4gIH07XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHVubG9jayk7XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGlzTG9ja2VkLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgIGlmICh2KVxuICAgICAgICBsb2NrKCk7XG4gICAgICBlbHNlIHVubG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNlc3Npb25TdG9yYWdlKGtleSwgaW5pdGlhbFZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93IH0gPSBvcHRpb25zO1xuICByZXR1cm4gdXNlU3RvcmFnZShrZXksIGluaXRpYWxWYWx1ZSwgd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB1c2VTaGFyZShzaGFyZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvciB9ID0gb3B0aW9ucztcbiAgY29uc3QgX25hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gX25hdmlnYXRvciAmJiBcImNhblNoYXJlXCIgaW4gX25hdmlnYXRvcik7XG4gIGNvbnN0IHNoYXJlID0gYXN5bmMgKG92ZXJyaWRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAuLi50b1ZhbHVlKHNoYXJlT3B0aW9ucyksXG4gICAgICAgIC4uLnRvVmFsdWUob3ZlcnJpZGVPcHRpb25zKVxuICAgICAgfTtcbiAgICAgIGxldCBncmFudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChkYXRhLmZpbGVzICYmIF9uYXZpZ2F0b3IuY2FuU2hhcmUpXG4gICAgICAgIGdyYW50ZWQgPSBfbmF2aWdhdG9yLmNhblNoYXJlKHsgZmlsZXM6IGRhdGEuZmlsZXMgfSk7XG4gICAgICBpZiAoZ3JhbnRlZClcbiAgICAgICAgcmV0dXJuIF9uYXZpZ2F0b3Iuc2hhcmUoZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIHNoYXJlXG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRTb3J0Rm4gPSAoc291cmNlLCBjb21wYXJlRm4pID0+IHNvdXJjZS5zb3J0KGNvbXBhcmVGbik7XG5jb25zdCBkZWZhdWx0Q29tcGFyZSA9IChhLCBiKSA9PiBhIC0gYjtcbmZ1bmN0aW9uIHVzZVNvcnRlZCguLi5hcmdzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgW3NvdXJjZV0gPSBhcmdzO1xuICBsZXQgY29tcGFyZUZuID0gZGVmYXVsdENvbXBhcmU7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICBjb21wYXJlRm4gPSAoX2EgPSBvcHRpb25zLmNvbXBhcmVGbikgIT0gbnVsbCA/IF9hIDogZGVmYXVsdENvbXBhcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBhcmVGbiA9IChfYiA9IGFyZ3NbMV0pICE9IG51bGwgPyBfYiA6IGRlZmF1bHRDb21wYXJlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICBjb21wYXJlRm4gPSAoX2MgPSBhcmdzWzFdKSAhPSBudWxsID8gX2MgOiBkZWZhdWx0Q29tcGFyZTtcbiAgICBvcHRpb25zID0gKF9kID0gYXJnc1syXSkgIT0gbnVsbCA/IF9kIDoge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpcnR5ID0gZmFsc2UsXG4gICAgc29ydEZuID0gZGVmYXVsdFNvcnRGblxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFkaXJ0eSlcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gc29ydEZuKFsuLi50b1ZhbHVlKHNvdXJjZSldLCBjb21wYXJlRm4pKTtcbiAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNvcnRGbih0b1ZhbHVlKHNvdXJjZSksIGNvbXBhcmVGbik7XG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpXG4gICAgICBzb3VyY2UudmFsdWUgPSByZXN1bHQ7XG4gICAgZWxzZVxuICAgICAgc291cmNlLnNwbGljZSgwLCBzb3VyY2UubGVuZ3RoLCAuLi5yZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gdXNlU3BlZWNoUmVjb2duaXRpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcmltUmVzdWx0cyA9IHRydWUsXG4gICAgY29udGludW91cyA9IHRydWUsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbGFuZyA9IHRvUmVmKG9wdGlvbnMubGFuZyB8fCBcImVuLVVTXCIpO1xuICBjb25zdCBpc0xpc3RlbmluZyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0IGlzRmluYWwgPSByZWYoZmFsc2UpO1xuICBjb25zdCByZXN1bHQgPSByZWYoXCJcIik7XG4gIGNvbnN0IGVycm9yID0gc2hhbGxvd1JlZih2b2lkIDApO1xuICBjb25zdCB0b2dnbGUgPSAodmFsdWUgPSAhaXNMaXN0ZW5pbmcudmFsdWUpID0+IHtcbiAgICBpc0xpc3RlbmluZy52YWx1ZSA9IHZhbHVlO1xuICB9O1xuICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICBpc0xpc3RlbmluZy52YWx1ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgaXNMaXN0ZW5pbmcudmFsdWUgPSBmYWxzZTtcbiAgfTtcbiAgY29uc3QgU3BlZWNoUmVjb2duaXRpb24gPSB3aW5kb3cgJiYgKHdpbmRvdy5TcGVlY2hSZWNvZ25pdGlvbiB8fCB3aW5kb3cud2Via2l0U3BlZWNoUmVjb2duaXRpb24pO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBTcGVlY2hSZWNvZ25pdGlvbik7XG4gIGxldCByZWNvZ25pdGlvbjtcbiAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKSB7XG4gICAgcmVjb2duaXRpb24gPSBuZXcgU3BlZWNoUmVjb2duaXRpb24oKTtcbiAgICByZWNvZ25pdGlvbi5jb250aW51b3VzID0gY29udGludW91cztcbiAgICByZWNvZ25pdGlvbi5pbnRlcmltUmVzdWx0cyA9IGludGVyaW1SZXN1bHRzO1xuICAgIHJlY29nbml0aW9uLmxhbmcgPSB0b1ZhbHVlKGxhbmcpO1xuICAgIHJlY29nbml0aW9uLm9uc3RhcnQgPSAoKSA9PiB7XG4gICAgICBpc0ZpbmFsLnZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICB3YXRjaChsYW5nLCAobGFuZzIpID0+IHtcbiAgICAgIGlmIChyZWNvZ25pdGlvbiAmJiAhaXNMaXN0ZW5pbmcudmFsdWUpXG4gICAgICAgIHJlY29nbml0aW9uLmxhbmcgPSBsYW5nMjtcbiAgICB9KTtcbiAgICByZWNvZ25pdGlvbi5vbnJlc3VsdCA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFJlc3VsdCA9IGV2ZW50LnJlc3VsdHNbZXZlbnQucmVzdWx0SW5kZXhdO1xuICAgICAgY29uc3QgeyB0cmFuc2NyaXB0IH0gPSBjdXJyZW50UmVzdWx0WzBdO1xuICAgICAgaXNGaW5hbC52YWx1ZSA9IGN1cnJlbnRSZXN1bHQuaXNGaW5hbDtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IHRyYW5zY3JpcHQ7XG4gICAgICBlcnJvci52YWx1ZSA9IHZvaWQgMDtcbiAgICB9O1xuICAgIHJlY29nbml0aW9uLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGVycm9yLnZhbHVlID0gZXZlbnQ7XG4gICAgfTtcbiAgICByZWNvZ25pdGlvbi5vbmVuZCA9ICgpID0+IHtcbiAgICAgIGlzTGlzdGVuaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICByZWNvZ25pdGlvbi5sYW5nID0gdG9WYWx1ZShsYW5nKTtcbiAgICB9O1xuICAgIHdhdGNoKGlzTGlzdGVuaW5nLCAoKSA9PiB7XG4gICAgICBpZiAoaXNMaXN0ZW5pbmcudmFsdWUpXG4gICAgICAgIHJlY29nbml0aW9uLnN0YXJ0KCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlY29nbml0aW9uLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgaXNMaXN0ZW5pbmcudmFsdWUgPSBmYWxzZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNMaXN0ZW5pbmcsXG4gICAgaXNGaW5hbCxcbiAgICByZWNvZ25pdGlvbixcbiAgICByZXN1bHQsXG4gICAgZXJyb3IsXG4gICAgdG9nZ2xlLFxuICAgIHN0YXJ0LFxuICAgIHN0b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU3BlZWNoU3ludGhlc2lzKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGl0Y2ggPSAxLFxuICAgIHJhdGUgPSAxLFxuICAgIHZvbHVtZSA9IDEsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc3ludGggPSB3aW5kb3cgJiYgd2luZG93LnNwZWVjaFN5bnRoZXNpcztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4gc3ludGgpO1xuICBjb25zdCBpc1BsYXlpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBzdGF0dXMgPSByZWYoXCJpbml0XCIpO1xuICBjb25zdCBzcG9rZW5UZXh0ID0gdG9SZWYodGV4dCB8fCBcIlwiKTtcbiAgY29uc3QgbGFuZyA9IHRvUmVmKG9wdGlvbnMubGFuZyB8fCBcImVuLVVTXCIpO1xuICBjb25zdCBlcnJvciA9IHNoYWxsb3dSZWYodm9pZCAwKTtcbiAgY29uc3QgdG9nZ2xlID0gKHZhbHVlID0gIWlzUGxheWluZy52YWx1ZSkgPT4ge1xuICAgIGlzUGxheWluZy52YWx1ZSA9IHZhbHVlO1xuICB9O1xuICBjb25zdCBiaW5kRXZlbnRzRm9yVXR0ZXJhbmNlID0gKHV0dGVyYW5jZTIpID0+IHtcbiAgICB1dHRlcmFuY2UyLmxhbmcgPSB0b1ZhbHVlKGxhbmcpO1xuICAgIHV0dGVyYW5jZTIudm9pY2UgPSB0b1ZhbHVlKG9wdGlvbnMudm9pY2UpIHx8IG51bGw7XG4gICAgdXR0ZXJhbmNlMi5waXRjaCA9IHRvVmFsdWUocGl0Y2gpO1xuICAgIHV0dGVyYW5jZTIucmF0ZSA9IHRvVmFsdWUocmF0ZSk7XG4gICAgdXR0ZXJhbmNlMi52b2x1bWUgPSB2b2x1bWU7XG4gICAgdXR0ZXJhbmNlMi5vbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaXNQbGF5aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwicGxheVwiO1xuICAgIH07XG4gICAgdXR0ZXJhbmNlMi5vbnBhdXNlID0gKCkgPT4ge1xuICAgICAgaXNQbGF5aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcInBhdXNlXCI7XG4gICAgfTtcbiAgICB1dHRlcmFuY2UyLm9ucmVzdW1lID0gKCkgPT4ge1xuICAgICAgaXNQbGF5aW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwicGxheVwiO1xuICAgIH07XG4gICAgdXR0ZXJhbmNlMi5vbmVuZCA9ICgpID0+IHtcbiAgICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgc3RhdHVzLnZhbHVlID0gXCJlbmRcIjtcbiAgICB9O1xuICAgIHV0dGVyYW5jZTIub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgZXJyb3IudmFsdWUgPSBldmVudDtcbiAgICB9O1xuICB9O1xuICBjb25zdCB1dHRlcmFuY2UgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaXNQbGF5aW5nLnZhbHVlID0gZmFsc2U7XG4gICAgc3RhdHVzLnZhbHVlID0gXCJpbml0XCI7XG4gICAgY29uc3QgbmV3VXR0ZXJhbmNlID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZShzcG9rZW5UZXh0LnZhbHVlKTtcbiAgICBiaW5kRXZlbnRzRm9yVXR0ZXJhbmNlKG5ld1V0dGVyYW5jZSk7XG4gICAgcmV0dXJuIG5ld1V0dGVyYW5jZTtcbiAgfSk7XG4gIGNvbnN0IHNwZWFrID0gKCkgPT4ge1xuICAgIHN5bnRoLmNhbmNlbCgpO1xuICAgIHV0dGVyYW5jZSAmJiBzeW50aC5zcGVhayh1dHRlcmFuY2UudmFsdWUpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIHN5bnRoLmNhbmNlbCgpO1xuICAgIGlzUGxheWluZy52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBpZiAoaXNTdXBwb3J0ZWQudmFsdWUpIHtcbiAgICBiaW5kRXZlbnRzRm9yVXR0ZXJhbmNlKHV0dGVyYW5jZS52YWx1ZSk7XG4gICAgd2F0Y2gobGFuZywgKGxhbmcyKSA9PiB7XG4gICAgICBpZiAodXR0ZXJhbmNlLnZhbHVlICYmICFpc1BsYXlpbmcudmFsdWUpXG4gICAgICAgIHV0dGVyYW5jZS52YWx1ZS5sYW5nID0gbGFuZzI7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMudm9pY2UpIHtcbiAgICAgIHdhdGNoKG9wdGlvbnMudm9pY2UsICgpID0+IHtcbiAgICAgICAgc3ludGguY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgd2F0Y2goaXNQbGF5aW5nLCAoKSA9PiB7XG4gICAgICBpZiAoaXNQbGF5aW5nLnZhbHVlKVxuICAgICAgICBzeW50aC5yZXN1bWUoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3ludGgucGF1c2UoKTtcbiAgICB9KTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgaXNQbGF5aW5nLnZhbHVlID0gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlzU3VwcG9ydGVkLFxuICAgIGlzUGxheWluZyxcbiAgICBzdGF0dXMsXG4gICAgdXR0ZXJhbmNlLFxuICAgIGVycm9yLFxuICAgIHN0b3AsXG4gICAgdG9nZ2xlLFxuICAgIHNwZWFrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVN0ZXBwZXIoc3RlcHMsIGluaXRpYWxTdGVwKSB7XG4gIGNvbnN0IHN0ZXBzUmVmID0gcmVmKHN0ZXBzKTtcbiAgY29uc3Qgc3RlcE5hbWVzID0gY29tcHV0ZWQoKCkgPT4gQXJyYXkuaXNBcnJheShzdGVwc1JlZi52YWx1ZSkgPyBzdGVwc1JlZi52YWx1ZSA6IE9iamVjdC5rZXlzKHN0ZXBzUmVmLnZhbHVlKSk7XG4gIGNvbnN0IGluZGV4ID0gcmVmKHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKGluaXRpYWxTdGVwICE9IG51bGwgPyBpbml0aWFsU3RlcCA6IHN0ZXBOYW1lcy52YWx1ZVswXSkpO1xuICBjb25zdCBjdXJyZW50ID0gY29tcHV0ZWQoKCkgPT4gYXQoaW5kZXgudmFsdWUpKTtcbiAgY29uc3QgaXNGaXJzdCA9IGNvbXB1dGVkKCgpID0+IGluZGV4LnZhbHVlID09PSAwKTtcbiAgY29uc3QgaXNMYXN0ID0gY29tcHV0ZWQoKCkgPT4gaW5kZXgudmFsdWUgPT09IHN0ZXBOYW1lcy52YWx1ZS5sZW5ndGggLSAxKTtcbiAgY29uc3QgbmV4dCA9IGNvbXB1dGVkKCgpID0+IHN0ZXBOYW1lcy52YWx1ZVtpbmRleC52YWx1ZSArIDFdKTtcbiAgY29uc3QgcHJldmlvdXMgPSBjb21wdXRlZCgoKSA9PiBzdGVwTmFtZXMudmFsdWVbaW5kZXgudmFsdWUgLSAxXSk7XG4gIGZ1bmN0aW9uIGF0KGluZGV4Mikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZXBzUmVmLnZhbHVlKSlcbiAgICAgIHJldHVybiBzdGVwc1JlZi52YWx1ZVtpbmRleDJdO1xuICAgIHJldHVybiBzdGVwc1JlZi52YWx1ZVtzdGVwTmFtZXMudmFsdWVbaW5kZXgyXV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KHN0ZXApIHtcbiAgICBpZiAoIXN0ZXBOYW1lcy52YWx1ZS5pbmNsdWRlcyhzdGVwKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gYXQoc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdvVG8oc3RlcCkge1xuICAgIGlmIChzdGVwTmFtZXMudmFsdWUuaW5jbHVkZXMoc3RlcCkpXG4gICAgICBpbmRleC52YWx1ZSA9IHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIGdvVG9OZXh0KCkge1xuICAgIGlmIChpc0xhc3QudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaW5kZXgudmFsdWUrKztcbiAgfVxuICBmdW5jdGlvbiBnb1RvUHJldmlvdXMoKSB7XG4gICAgaWYgKGlzRmlyc3QudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaW5kZXgudmFsdWUtLTtcbiAgfVxuICBmdW5jdGlvbiBnb0JhY2tUbyhzdGVwKSB7XG4gICAgaWYgKGlzQWZ0ZXIoc3RlcCkpXG4gICAgICBnb1RvKHN0ZXApO1xuICB9XG4gIGZ1bmN0aW9uIGlzTmV4dChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApID09PSBpbmRleC52YWx1ZSArIDE7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmV2aW91cyhzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXBOYW1lcy52YWx1ZS5pbmRleE9mKHN0ZXApID09PSBpbmRleC52YWx1ZSAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gaXNDdXJyZW50KHN0ZXApIHtcbiAgICByZXR1cm4gc3RlcE5hbWVzLnZhbHVlLmluZGV4T2Yoc3RlcCkgPT09IGluZGV4LnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQmVmb3JlKHN0ZXApIHtcbiAgICByZXR1cm4gaW5kZXgudmFsdWUgPCBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBpc0FmdGVyKHN0ZXApIHtcbiAgICByZXR1cm4gaW5kZXgudmFsdWUgPiBzdGVwTmFtZXMudmFsdWUuaW5kZXhPZihzdGVwKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXBzOiBzdGVwc1JlZixcbiAgICBzdGVwTmFtZXMsXG4gICAgaW5kZXgsXG4gICAgY3VycmVudCxcbiAgICBuZXh0LFxuICAgIHByZXZpb3VzLFxuICAgIGlzRmlyc3QsXG4gICAgaXNMYXN0LFxuICAgIGF0LFxuICAgIGdldCxcbiAgICBnb1RvLFxuICAgIGdvVG9OZXh0LFxuICAgIGdvVG9QcmV2aW91cyxcbiAgICBnb0JhY2tUbyxcbiAgICBpc05leHQsXG4gICAgaXNQcmV2aW91cyxcbiAgICBpc0N1cnJlbnQsXG4gICAgaXNCZWZvcmUsXG4gICAgaXNBZnRlclxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTdG9yYWdlQXN5bmMoa2V5LCBpbml0aWFsVmFsdWUsIHN0b3JhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBmbHVzaCA9IFwicHJlXCIsXG4gICAgZGVlcCA9IHRydWUsXG4gICAgbGlzdGVuVG9TdG9yYWdlQ2hhbmdlcyA9IHRydWUsXG4gICAgd3JpdGVEZWZhdWx0cyA9IHRydWUsXG4gICAgbWVyZ2VEZWZhdWx0cyA9IGZhbHNlLFxuICAgIHNoYWxsb3csXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBldmVudEZpbHRlcixcbiAgICBvbkVycm9yID0gKGUpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmF3SW5pdCA9IHRvVmFsdWUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdHlwZSA9IGd1ZXNzU2VyaWFsaXplclR5cGUocmF3SW5pdCk7XG4gIGNvbnN0IGRhdGEgPSAoc2hhbGxvdyA/IHNoYWxsb3dSZWYgOiByZWYpKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHNlcmlhbGl6ZXIgPSAoX2EgPSBvcHRpb25zLnNlcmlhbGl6ZXIpICE9IG51bGwgPyBfYSA6IFN0b3JhZ2VTZXJpYWxpemVyc1t0eXBlXTtcbiAgaWYgKCFzdG9yYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0b3JhZ2UgPSBnZXRTU1JIYW5kbGVyKFwiZ2V0RGVmYXVsdFN0b3JhZ2VBc3luY1wiLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gZGVmYXVsdFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5sb2NhbFN0b3JhZ2U7XG4gICAgICB9KSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICBpZiAoIXN0b3JhZ2UgfHwgZXZlbnQgJiYgZXZlbnQua2V5ICE9PSBrZXkpXG4gICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZXZlbnQgPyBldmVudC5uZXdWYWx1ZSA6IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKHJhd1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IHJhd0luaXQ7XG4gICAgICAgIGlmICh3cml0ZURlZmF1bHRzICYmIHJhd0luaXQgIT09IG51bGwpXG4gICAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgYXdhaXQgc2VyaWFsaXplci53cml0ZShyYXdJbml0KSk7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlRGVmYXVsdHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBzZXJpYWxpemVyLnJlYWQocmF3VmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIG1lcmdlRGVmYXVsdHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBkYXRhLnZhbHVlID0gbWVyZ2VEZWZhdWx0cyh2YWx1ZSwgcmF3SW5pdCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgIGRhdGEudmFsdWUgPSB7IC4uLnJhd0luaXQsIC4uLnZhbHVlIH07XG4gICAgICAgIGVsc2UgZGF0YS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IGF3YWl0IHNlcmlhbGl6ZXIucmVhZChyYXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgcmVhZCgpO1xuICBpZiAod2luZG93ICYmIGxpc3RlblRvU3RvcmFnZUNoYW5nZXMpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwic3RvcmFnZVwiLCAoZSkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiByZWFkKGUpKSk7XG4gIGlmIChzdG9yYWdlKSB7XG4gICAgd2F0Y2hXaXRoRmlsdGVyKFxuICAgICAgZGF0YSxcbiAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXRJdGVtKGtleSwgYXdhaXQgc2VyaWFsaXplci53cml0ZShkYXRhLnZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBmbHVzaCxcbiAgICAgICAgZGVlcCxcbiAgICAgICAgZXZlbnRGaWx0ZXJcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5sZXQgX2lkID0gMDtcbmZ1bmN0aW9uIHVzZVN0eWxlVGFnKGNzcywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlzTG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50ID0gZGVmYXVsdERvY3VtZW50LFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgbWFudWFsID0gZmFsc2UsXG4gICAgaWQgPSBgdnVldXNlX3N0eWxldGFnXyR7KytfaWR9YFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3NzUmVmID0gcmVmKGNzcyk7XG4gIGxldCBzdG9wID0gKCkgPT4ge1xuICB9O1xuICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGlmICghZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgIGVsLmlkID0gaWQ7XG4gICAgICBpZiAob3B0aW9ucy5tZWRpYSlcbiAgICAgICAgZWwubWVkaWEgPSBvcHRpb25zLm1lZGlhO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGlmIChpc0xvYWRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdG9wID0gd2F0Y2goXG4gICAgICBjc3NSZWYsXG4gICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICAgKTtcbiAgICBpc0xvYWRlZC52YWx1ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHVubG9hZCA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50IHx8ICFpc0xvYWRlZC52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdG9wKCk7XG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgIGlzTG9hZGVkLnZhbHVlID0gZmFsc2U7XG4gIH07XG4gIGlmIChpbW1lZGlhdGUgJiYgIW1hbnVhbClcbiAgICB0cnlPbk1vdW50ZWQobG9hZCk7XG4gIGlmICghbWFudWFsKVxuICAgIHRyeU9uU2NvcGVEaXNwb3NlKHVubG9hZCk7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgY3NzOiBjc3NSZWYsXG4gICAgdW5sb2FkLFxuICAgIGxvYWQsXG4gICAgaXNMb2FkZWQ6IHJlYWRvbmx5KGlzTG9hZGVkKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTd2lwZSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGhyZXNob2xkID0gNTAsXG4gICAgb25Td2lwZSxcbiAgICBvblN3aXBlRW5kLFxuICAgIG9uU3dpcGVTdGFydCxcbiAgICBwYXNzaXZlID0gdHJ1ZSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjb29yZHNTdGFydCA9IHJlYWN0aXZlKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3QgY29vcmRzRW5kID0gcmVhY3RpdmUoeyB4OiAwLCB5OiAwIH0pO1xuICBjb25zdCBkaWZmWCA9IGNvbXB1dGVkKCgpID0+IGNvb3Jkc1N0YXJ0LnggLSBjb29yZHNFbmQueCk7XG4gIGNvbnN0IGRpZmZZID0gY29tcHV0ZWQoKCkgPT4gY29vcmRzU3RhcnQueSAtIGNvb3Jkc0VuZC55KTtcbiAgY29uc3QgeyBtYXgsIGFicyB9ID0gTWF0aDtcbiAgY29uc3QgaXNUaHJlc2hvbGRFeGNlZWRlZCA9IGNvbXB1dGVkKCgpID0+IG1heChhYnMoZGlmZlgudmFsdWUpLCBhYnMoZGlmZlkudmFsdWUpKSA+PSB0aHJlc2hvbGQpO1xuICBjb25zdCBpc1N3aXBpbmcgPSByZWYoZmFsc2UpO1xuICBjb25zdCBkaXJlY3Rpb24gPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgaWYgKCFpc1RocmVzaG9sZEV4Y2VlZGVkLnZhbHVlKVxuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIGlmIChhYnMoZGlmZlgudmFsdWUpID4gYWJzKGRpZmZZLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGRpZmZYLnZhbHVlID4gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlmZlkudmFsdWUgPiAwID8gXCJ1cFwiIDogXCJkb3duXCI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZ2V0VG91Y2hFdmVudENvb3JkcyA9IChlKSA9PiBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXTtcbiAgY29uc3QgdXBkYXRlQ29vcmRzU3RhcnQgPSAoeCwgeSkgPT4ge1xuICAgIGNvb3Jkc1N0YXJ0LnggPSB4O1xuICAgIGNvb3Jkc1N0YXJ0LnkgPSB5O1xuICB9O1xuICBjb25zdCB1cGRhdGVDb29yZHNFbmQgPSAoeCwgeSkgPT4ge1xuICAgIGNvb3Jkc0VuZC54ID0geDtcbiAgICBjb29yZHNFbmQueSA9IHk7XG4gIH07XG4gIGxldCBsaXN0ZW5lck9wdGlvbnM7XG4gIGNvbnN0IGlzUGFzc2l2ZUV2ZW50U3VwcG9ydGVkID0gY2hlY2tQYXNzaXZlRXZlbnRTdXBwb3J0KHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmRvY3VtZW50KTtcbiAgaWYgKCFwYXNzaXZlKVxuICAgIGxpc3RlbmVyT3B0aW9ucyA9IGlzUGFzc2l2ZUV2ZW50U3VwcG9ydGVkID8geyBwYXNzaXZlOiBmYWxzZSwgY2FwdHVyZTogdHJ1ZSB9IDogeyBjYXB0dXJlOiB0cnVlIH07XG4gIGVsc2VcbiAgICBsaXN0ZW5lck9wdGlvbnMgPSBpc1Bhc3NpdmVFdmVudFN1cHBvcnRlZCA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogeyBjYXB0dXJlOiBmYWxzZSB9O1xuICBjb25zdCBvblRvdWNoRW5kID0gKGUpID0+IHtcbiAgICBpZiAoaXNTd2lwaW5nLnZhbHVlKVxuICAgICAgb25Td2lwZUVuZCA9PSBudWxsID8gdm9pZCAwIDogb25Td2lwZUVuZChlLCBkaXJlY3Rpb24udmFsdWUpO1xuICAgIGlzU3dpcGluZy52YWx1ZSA9IGZhbHNlO1xuICB9O1xuICBjb25zdCBzdG9wcyA9IFtcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ0b3VjaHN0YXJ0XCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGxpc3RlbmVyT3B0aW9ucy5jYXB0dXJlICYmICFsaXN0ZW5lck9wdGlvbnMucGFzc2l2ZSlcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgW3gsIHldID0gZ2V0VG91Y2hFdmVudENvb3JkcyhlKTtcbiAgICAgIHVwZGF0ZUNvb3Jkc1N0YXJ0KHgsIHkpO1xuICAgICAgdXBkYXRlQ29vcmRzRW5kKHgsIHkpO1xuICAgICAgb25Td2lwZVN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN3aXBlU3RhcnQoZSk7XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKSxcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBbeCwgeV0gPSBnZXRUb3VjaEV2ZW50Q29vcmRzKGUpO1xuICAgICAgdXBkYXRlQ29vcmRzRW5kKHgsIHkpO1xuICAgICAgaWYgKCFpc1N3aXBpbmcudmFsdWUgJiYgaXNUaHJlc2hvbGRFeGNlZWRlZC52YWx1ZSlcbiAgICAgICAgaXNTd2lwaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICAgIGlmIChpc1N3aXBpbmcudmFsdWUpXG4gICAgICAgIG9uU3dpcGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3dpcGUoZSk7XG4gICAgfSwgbGlzdGVuZXJPcHRpb25zKSxcbiAgICB1c2VFdmVudExpc3RlbmVyKHRhcmdldCwgW1widG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXSwgb25Ub3VjaEVuZCwgbGlzdGVuZXJPcHRpb25zKVxuICBdO1xuICBjb25zdCBzdG9wID0gKCkgPT4gc3RvcHMuZm9yRWFjaCgocykgPT4gcygpKTtcbiAgcmV0dXJuIHtcbiAgICBpc1Bhc3NpdmVFdmVudFN1cHBvcnRlZCxcbiAgICBpc1N3aXBpbmcsXG4gICAgZGlyZWN0aW9uLFxuICAgIGNvb3Jkc1N0YXJ0LFxuICAgIGNvb3Jkc0VuZCxcbiAgICBsZW5ndGhYOiBkaWZmWCxcbiAgICBsZW5ndGhZOiBkaWZmWSxcbiAgICBzdG9wXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja1Bhc3NpdmVFdmVudFN1cHBvcnQoZG9jdW1lbnQpIHtcbiAgaWYgKCFkb2N1bWVudClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgY29uc3Qgb3B0aW9uc0Jsb2NrID0ge1xuICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ4XCIsIG5vb3AsIG9wdGlvbnNCbG9jayk7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ4XCIsIG5vb3ApO1xuICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlO1xufVxuXG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZnNMaXN0KCkge1xuICBjb25zdCByZWZzID0gcmVmKFtdKTtcbiAgcmVmcy52YWx1ZS5zZXQgPSAoZWwpID0+IHtcbiAgICBpZiAoZWwpXG4gICAgICByZWZzLnZhbHVlLnB1c2goZWwpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcmVmcy52YWx1ZS5sZW5ndGggPSAwO1xuICB9KTtcbiAgcmV0dXJuIHJlZnM7XG59XG5cbmZ1bmN0aW9uIHVzZVRleHREaXJlY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudCxcbiAgICBzZWxlY3RvciA9IFwiaHRtbFwiLFxuICAgIG9ic2VydmUgPSBmYWxzZSxcbiAgICBpbml0aWFsVmFsdWUgPSBcImx0clwiXG4gIH0gPSBvcHRpb25zO1xuICBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBkb2N1bWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRBdHRyaWJ1dGUoXCJkaXJcIikpICE9IG51bGwgPyBfYiA6IGluaXRpYWxWYWx1ZTtcbiAgfVxuICBjb25zdCBkaXIgPSByZWYoZ2V0VmFsdWUoKSk7XG4gIHRyeU9uTW91bnRlZCgoKSA9PiBkaXIudmFsdWUgPSBnZXRWYWx1ZSgpKTtcbiAgaWYgKG9ic2VydmUgJiYgZG9jdW1lbnQpIHtcbiAgICB1c2VNdXRhdGlvbk9ic2VydmVyKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gICAgICAoKSA9PiBkaXIudmFsdWUgPSBnZXRWYWx1ZSgpLFxuICAgICAgeyBhdHRyaWJ1dGVzOiB0cnVlIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGRpci52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgZGlyLnZhbHVlID0gdjtcbiAgICAgIGlmICghZG9jdW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChkaXIudmFsdWUpXG4gICAgICAgIChfYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKFwiZGlyXCIsIGRpci52YWx1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIChfYiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2IucmVtb3ZlQXR0cmlidXRlKFwiZGlyXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlc0Zyb21TZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmFuZ2VDb3VudCA9IChfYSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50KSAhPSBudWxsID8gX2EgOiAwO1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogcmFuZ2VDb3VudCB9LCAoXywgaSkgPT4gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xufVxuZnVuY3Rpb24gdXNlVGV4dFNlbGVjdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3dcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHJlZihudWxsKTtcbiAgY29uc3QgdGV4dCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBzZWxlY3Rpb24udmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICB9KTtcbiAgY29uc3QgcmFuZ2VzID0gY29tcHV0ZWQoKCkgPT4gc2VsZWN0aW9uLnZhbHVlID8gZ2V0UmFuZ2VzRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24udmFsdWUpIDogW10pO1xuICBjb25zdCByZWN0cyA9IGNvbXB1dGVkKCgpID0+IHJhbmdlcy52YWx1ZS5tYXAoKHJhbmdlKSA9PiByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpO1xuICBmdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBzZWxlY3Rpb24udmFsdWUgPSBudWxsO1xuICAgIGlmICh3aW5kb3cpXG4gICAgICBzZWxlY3Rpb24udmFsdWUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cbiAgaWYgKHdpbmRvdylcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdy5kb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgb25TZWxlY3Rpb25DaGFuZ2UpO1xuICByZXR1cm4ge1xuICAgIHRleHQsXG4gICAgcmVjdHMsXG4gICAgcmFuZ2VzLFxuICAgIHNlbGVjdGlvblxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUZXh0YXJlYUF1dG9zaXplKG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0ZXh0YXJlYSA9IHJlZihvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmVsZW1lbnQpO1xuICBjb25zdCBpbnB1dCA9IHJlZihvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlucHV0KTtcbiAgY29uc3Qgc3R5bGVQcm9wID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdHlsZVByb3ApICE9IG51bGwgPyBfYSA6IFwiaGVpZ2h0XCI7XG4gIGNvbnN0IHRleHRhcmVhU2Nyb2xsSGVpZ2h0ID0gcmVmKDEpO1xuICBmdW5jdGlvbiB0cmlnZ2VyUmVzaXplKCkge1xuICAgIHZhciBfYTI7XG4gICAgaWYgKCF0ZXh0YXJlYS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgaGVpZ2h0ID0gXCJcIjtcbiAgICB0ZXh0YXJlYS52YWx1ZS5zdHlsZVtzdHlsZVByb3BdID0gXCIxcHhcIjtcbiAgICB0ZXh0YXJlYVNjcm9sbEhlaWdodC52YWx1ZSA9IChfYTIgPSB0ZXh0YXJlYS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zY3JvbGxIZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3R5bGVUYXJnZXQpXG4gICAgICB0b1ZhbHVlKG9wdGlvbnMuc3R5bGVUYXJnZXQpLnN0eWxlW3N0eWxlUHJvcF0gPSBgJHt0ZXh0YXJlYVNjcm9sbEhlaWdodC52YWx1ZX1weGA7XG4gICAgZWxzZVxuICAgICAgaGVpZ2h0ID0gYCR7dGV4dGFyZWFTY3JvbGxIZWlnaHQudmFsdWV9cHhgO1xuICAgIHRleHRhcmVhLnZhbHVlLnN0eWxlW3N0eWxlUHJvcF0gPSBoZWlnaHQ7XG4gIH1cbiAgd2F0Y2goW2lucHV0LCB0ZXh0YXJlYV0sICgpID0+IG5leHRUaWNrKHRyaWdnZXJSZXNpemUpLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KTtcbiAgd2F0Y2godGV4dGFyZWFTY3JvbGxIZWlnaHQsICgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiAoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vblJlc2l6ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMpO1xuICB9KTtcbiAgdXNlUmVzaXplT2JzZXJ2ZXIodGV4dGFyZWEsICgpID0+IHRyaWdnZXJSZXNpemUoKSk7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLndhdGNoKVxuICAgIHdhdGNoKG9wdGlvbnMud2F0Y2gsIHRyaWdnZXJSZXNpemUsIHsgaW1tZWRpYXRlOiB0cnVlLCBkZWVwOiB0cnVlIH0pO1xuICByZXR1cm4ge1xuICAgIHRleHRhcmVhLFxuICAgIGlucHV0LFxuICAgIHRyaWdnZXJSZXNpemVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVGhyb3R0bGVkUmVmSGlzdG9yeShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHRocm90dGxlID0gMjAwLCB0cmFpbGluZyA9IHRydWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZpbHRlciA9IHRocm90dGxlRmlsdGVyKHRocm90dGxlLCB0cmFpbGluZyk7XG4gIGNvbnN0IGhpc3RvcnkgPSB1c2VSZWZIaXN0b3J5KHNvdXJjZSwgeyAuLi5vcHRpb25zLCBldmVudEZpbHRlcjogZmlsdGVyIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmhpc3RvcnlcbiAgfTtcbn1cblxuY29uc3QgREVGQVVMVF9VTklUUyA9IFtcbiAgeyBtYXg6IDZlNCwgdmFsdWU6IDFlMywgbmFtZTogXCJzZWNvbmRcIiB9LFxuICB7IG1heDogMjc2ZTQsIHZhbHVlOiA2ZTQsIG5hbWU6IFwibWludXRlXCIgfSxcbiAgeyBtYXg6IDcyZTYsIHZhbHVlOiAzNmU1LCBuYW1lOiBcImhvdXJcIiB9LFxuICB7IG1heDogNTE4NGU1LCB2YWx1ZTogODY0ZTUsIG5hbWU6IFwiZGF5XCIgfSxcbiAgeyBtYXg6IDI0MTkyZTUsIHZhbHVlOiA2MDQ4ZTUsIG5hbWU6IFwid2Vla1wiIH0sXG4gIHsgbWF4OiAyODUxMmU2LCB2YWx1ZTogMjU5MmU2LCBuYW1lOiBcIm1vbnRoXCIgfSxcbiAgeyBtYXg6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdmFsdWU6IDMxNTM2ZTYsIG5hbWU6IFwieWVhclwiIH1cbl07XG5jb25zdCBERUZBVUxUX01FU1NBR0VTID0ge1xuICBqdXN0Tm93OiBcImp1c3Qgbm93XCIsXG4gIHBhc3Q6IChuKSA9PiBuLm1hdGNoKC9cXGQvKSA/IGAke259IGFnb2AgOiBuLFxuICBmdXR1cmU6IChuKSA9PiBuLm1hdGNoKC9cXGQvKSA/IGBpbiAke259YCA6IG4sXG4gIG1vbnRoOiAobiwgcGFzdCkgPT4gbiA9PT0gMSA/IHBhc3QgPyBcImxhc3QgbW9udGhcIiA6IFwibmV4dCBtb250aFwiIDogYCR7bn0gbW9udGgke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIHllYXI6IChuLCBwYXN0KSA9PiBuID09PSAxID8gcGFzdCA/IFwibGFzdCB5ZWFyXCIgOiBcIm5leHQgeWVhclwiIDogYCR7bn0geWVhciR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgZGF5OiAobiwgcGFzdCkgPT4gbiA9PT0gMSA/IHBhc3QgPyBcInllc3RlcmRheVwiIDogXCJ0b21vcnJvd1wiIDogYCR7bn0gZGF5JHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICB3ZWVrOiAobiwgcGFzdCkgPT4gbiA9PT0gMSA/IHBhc3QgPyBcImxhc3Qgd2Vla1wiIDogXCJuZXh0IHdlZWtcIiA6IGAke259IHdlZWske24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIGhvdXI6IChuKSA9PiBgJHtufSBob3VyJHtuID4gMSA/IFwic1wiIDogXCJcIn1gLFxuICBtaW51dGU6IChuKSA9PiBgJHtufSBtaW51dGUke24gPiAxID8gXCJzXCIgOiBcIlwifWAsXG4gIHNlY29uZDogKG4pID0+IGAke259IHNlY29uZCR7biA+IDEgPyBcInNcIiA6IFwiXCJ9YCxcbiAgaW52YWxpZDogXCJcIlxufTtcbmZ1bmN0aW9uIERFRkFVTFRfRk9STUFUVEVSKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCk7XG59XG5mdW5jdGlvbiB1c2VUaW1lQWdvKHRpbWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgdXBkYXRlSW50ZXJ2YWwgPSAzZTRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgbm93LCAuLi5jb250cm9scyB9ID0gdXNlTm93KHsgaW50ZXJ2YWw6IHVwZGF0ZUludGVydmFsLCBjb250cm9sczogdHJ1ZSB9KTtcbiAgY29uc3QgdGltZUFnbyA9IGNvbXB1dGVkKCgpID0+IGZvcm1hdFRpbWVBZ28obmV3IERhdGUodG9WYWx1ZSh0aW1lKSksIG9wdGlvbnMsIHRvVmFsdWUobm93KSkpO1xuICBpZiAoZXhwb3NlQ29udHJvbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZUFnbyxcbiAgICAgIC4uLmNvbnRyb2xzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGltZUFnbztcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0VGltZUFnbyhmcm9tLCBvcHRpb25zID0ge30sIG5vdyA9IERhdGUubm93KCkpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgbWF4LFxuICAgIG1lc3NhZ2VzID0gREVGQVVMVF9NRVNTQUdFUyxcbiAgICBmdWxsRGF0ZUZvcm1hdHRlciA9IERFRkFVTFRfRk9STUFUVEVSLFxuICAgIHVuaXRzID0gREVGQVVMVF9VTklUUyxcbiAgICBzaG93U2Vjb25kID0gZmFsc2UsXG4gICAgcm91bmRpbmcgPSBcInJvdW5kXCJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJvdW5kRm4gPSB0eXBlb2Ygcm91bmRpbmcgPT09IFwibnVtYmVyXCIgPyAobikgPT4gK24udG9GaXhlZChyb3VuZGluZykgOiBNYXRoW3JvdW5kaW5nXTtcbiAgY29uc3QgZGlmZiA9ICtub3cgLSArZnJvbTtcbiAgY29uc3QgYWJzRGlmZiA9IE1hdGguYWJzKGRpZmYpO1xuICBmdW5jdGlvbiBnZXRWYWx1ZShkaWZmMiwgdW5pdCkge1xuICAgIHJldHVybiByb3VuZEZuKE1hdGguYWJzKGRpZmYyKSAvIHVuaXQudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdChkaWZmMiwgdW5pdCkge1xuICAgIGNvbnN0IHZhbCA9IGdldFZhbHVlKGRpZmYyLCB1bml0KTtcbiAgICBjb25zdCBwYXN0ID0gZGlmZjIgPiAwO1xuICAgIGNvbnN0IHN0ciA9IGFwcGx5Rm9ybWF0KHVuaXQubmFtZSwgdmFsLCBwYXN0KTtcbiAgICByZXR1cm4gYXBwbHlGb3JtYXQocGFzdCA/IFwicGFzdFwiIDogXCJmdXR1cmVcIiwgc3RyLCBwYXN0KTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseUZvcm1hdChuYW1lLCB2YWwsIGlzUGFzdCkge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG1lc3NhZ2VzW25hbWVdO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gZm9ybWF0dGVyKHZhbCwgaXNQYXN0KTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnJlcGxhY2UoXCJ7MH1cIiwgdmFsLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmIChhYnNEaWZmIDwgNmU0ICYmICFzaG93U2Vjb25kKVxuICAgIHJldHVybiBtZXNzYWdlcy5qdXN0Tm93O1xuICBpZiAodHlwZW9mIG1heCA9PT0gXCJudW1iZXJcIiAmJiBhYnNEaWZmID4gbWF4KVxuICAgIHJldHVybiBmdWxsRGF0ZUZvcm1hdHRlcihuZXcgRGF0ZShmcm9tKSk7XG4gIGlmICh0eXBlb2YgbWF4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgdW5pdE1heCA9IChfYSA9IHVuaXRzLmZpbmQoKGkpID0+IGkubmFtZSA9PT0gbWF4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1heDtcbiAgICBpZiAodW5pdE1heCAmJiBhYnNEaWZmID4gdW5pdE1heClcbiAgICAgIHJldHVybiBmdWxsRGF0ZUZvcm1hdHRlcihuZXcgRGF0ZShmcm9tKSk7XG4gIH1cbiAgZm9yIChjb25zdCBbaWR4LCB1bml0XSBvZiB1bml0cy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCB2YWwgPSBnZXRWYWx1ZShkaWZmLCB1bml0KTtcbiAgICBpZiAodmFsIDw9IDAgJiYgdW5pdHNbaWR4IC0gMV0pXG4gICAgICByZXR1cm4gZm9ybWF0KGRpZmYsIHVuaXRzW2lkeCAtIDFdKTtcbiAgICBpZiAoYWJzRGlmZiA8IHVuaXQubWF4KVxuICAgICAgcmV0dXJuIGZvcm1hdChkaWZmLCB1bml0KTtcbiAgfVxuICByZXR1cm4gbWVzc2FnZXMuaW52YWxpZDtcbn1cblxuZnVuY3Rpb24gdXNlVGltZW91dFBvbGwoZm4sIGludGVydmFsLCB0aW1lb3V0UG9sbE9wdGlvbnMpIHtcbiAgY29uc3QgeyBzdGFydCB9ID0gdXNlVGltZW91dEZuKGxvb3AsIGludGVydmFsLCB7IGltbWVkaWF0ZTogZmFsc2UgfSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gcmVmKGZhbHNlKTtcbiAgYXN5bmMgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICBpZiAoIWlzQWN0aXZlLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGF3YWl0IGZuKCk7XG4gICAgc3RhcnQoKTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaWYgKCFpc0FjdGl2ZS52YWx1ZSkge1xuICAgICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICAgICAgbG9vcCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIGlmICh0aW1lb3V0UG9sbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRpbWVvdXRQb2xsT3B0aW9ucy5pbW1lZGlhdGUpXG4gICAgcmVzdW1lKCk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVGltZXN0YW1wKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGludGVydmFsID0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBjYWxsYmFja1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdHMgPSByZWYodGltZXN0YW1wKCkgKyBvZmZzZXQpO1xuICBjb25zdCB1cGRhdGUgPSAoKSA9PiB0cy52YWx1ZSA9IHRpbWVzdGFtcCgpICsgb2Zmc2V0O1xuICBjb25zdCBjYiA9IGNhbGxiYWNrID8gKCkgPT4ge1xuICAgIHVwZGF0ZSgpO1xuICAgIGNhbGxiYWNrKHRzLnZhbHVlKTtcbiAgfSA6IHVwZGF0ZTtcbiAgY29uc3QgY29udHJvbHMgPSBpbnRlcnZhbCA9PT0gXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIiA/IHVzZVJhZkZuKGNiLCB7IGltbWVkaWF0ZSB9KSA6IHVzZUludGVydmFsRm4oY2IsIGludGVydmFsLCB7IGltbWVkaWF0ZSB9KTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAuLi5jb250cm9sc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZVRpdGxlKG5ld1RpdGxlID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCB7XG4gICAgZG9jdW1lbnQgPSBkZWZhdWx0RG9jdW1lbnQsXG4gICAgcmVzdG9yZU9uVW5tb3VudCA9ICh0KSA9PiB0XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBvcmlnaW5hbFRpdGxlID0gKF9hID0gZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LnRpdGxlKSAhPSBudWxsID8gX2EgOiBcIlwiO1xuICBjb25zdCB0aXRsZSA9IHRvUmVmKChfYiA9IG5ld1RpdGxlICE9IG51bGwgPyBuZXdUaXRsZSA6IGRvY3VtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb2N1bWVudC50aXRsZSkgIT0gbnVsbCA/IF9iIDogbnVsbCk7XG4gIGNvbnN0IGlzUmVhZG9ubHkgPSBuZXdUaXRsZSAmJiB0eXBlb2YgbmV3VGl0bGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgZnVuY3Rpb24gZm9ybWF0KHQpIHtcbiAgICBpZiAoIShcInRpdGxlVGVtcGxhdGVcIiBpbiBvcHRpb25zKSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IHRlbXBsYXRlID0gb3B0aW9ucy50aXRsZVRlbXBsYXRlIHx8IFwiJXNcIjtcbiAgICByZXR1cm4gdHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIgPyB0ZW1wbGF0ZSh0KSA6IHRvVmFsdWUodGVtcGxhdGUpLnJlcGxhY2UoLyVzL2csIHQpO1xuICB9XG4gIHdhdGNoKFxuICAgIHRpdGxlLFxuICAgICh0LCBvKSA9PiB7XG4gICAgICBpZiAodCAhPT0gbyAmJiBkb2N1bWVudClcbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSBmb3JtYXQodHlwZW9mIHQgPT09IFwic3RyaW5nXCIgPyB0IDogXCJcIik7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogdHJ1ZSB9XG4gICk7XG4gIGlmIChvcHRpb25zLm9ic2VydmUgJiYgIW9wdGlvbnMudGl0bGVUZW1wbGF0ZSAmJiBkb2N1bWVudCAmJiAhaXNSZWFkb25seSkge1xuICAgIHVzZU11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICAoX2MgPSBkb2N1bWVudC5oZWFkKSA9PSBudWxsID8gdm9pZCAwIDogX2MucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQudGl0bGUgIT09IHRpdGxlLnZhbHVlKVxuICAgICAgICAgIHRpdGxlLnZhbHVlID0gZm9ybWF0KGRvY3VtZW50LnRpdGxlKTtcbiAgICAgIH0sXG4gICAgICB7IGNoaWxkTGlzdDogdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICB0cnlPbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgIGlmIChyZXN0b3JlT25Vbm1vdW50KSB7XG4gICAgICBjb25zdCByZXN0b3JlZFRpdGxlID0gcmVzdG9yZU9uVW5tb3VudChvcmlnaW5hbFRpdGxlLCB0aXRsZS52YWx1ZSB8fCBcIlwiKTtcbiAgICAgIGlmIChyZXN0b3JlZFRpdGxlICE9IG51bGwgJiYgZG9jdW1lbnQpXG4gICAgICAgIGRvY3VtZW50LnRpdGxlID0gcmVzdG9yZWRUaXRsZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGl0bGU7XG59XG5cbmNvbnN0IF9UcmFuc2l0aW9uUHJlc2V0cyA9IHtcbiAgZWFzZUluU2luZTogWzAuMTIsIDAsIDAuMzksIDBdLFxuICBlYXNlT3V0U2luZTogWzAuNjEsIDEsIDAuODgsIDFdLFxuICBlYXNlSW5PdXRTaW5lOiBbMC4zNywgMCwgMC42MywgMV0sXG4gIGVhc2VJblF1YWQ6IFswLjExLCAwLCAwLjUsIDBdLFxuICBlYXNlT3V0UXVhZDogWzAuNSwgMSwgMC44OSwgMV0sXG4gIGVhc2VJbk91dFF1YWQ6IFswLjQ1LCAwLCAwLjU1LCAxXSxcbiAgZWFzZUluQ3ViaWM6IFswLjMyLCAwLCAwLjY3LCAwXSxcbiAgZWFzZU91dEN1YmljOiBbMC4zMywgMSwgMC42OCwgMV0sXG4gIGVhc2VJbk91dEN1YmljOiBbMC42NSwgMCwgMC4zNSwgMV0sXG4gIGVhc2VJblF1YXJ0OiBbMC41LCAwLCAwLjc1LCAwXSxcbiAgZWFzZU91dFF1YXJ0OiBbMC4yNSwgMSwgMC41LCAxXSxcbiAgZWFzZUluT3V0UXVhcnQ6IFswLjc2LCAwLCAwLjI0LCAxXSxcbiAgZWFzZUluUXVpbnQ6IFswLjY0LCAwLCAwLjc4LCAwXSxcbiAgZWFzZU91dFF1aW50OiBbMC4yMiwgMSwgMC4zNiwgMV0sXG4gIGVhc2VJbk91dFF1aW50OiBbMC44MywgMCwgMC4xNywgMV0sXG4gIGVhc2VJbkV4cG86IFswLjcsIDAsIDAuODQsIDBdLFxuICBlYXNlT3V0RXhwbzogWzAuMTYsIDEsIDAuMywgMV0sXG4gIGVhc2VJbk91dEV4cG86IFswLjg3LCAwLCAwLjEzLCAxXSxcbiAgZWFzZUluQ2lyYzogWzAuNTUsIDAsIDEsIDAuNDVdLFxuICBlYXNlT3V0Q2lyYzogWzAsIDAuNTUsIDAuNDUsIDFdLFxuICBlYXNlSW5PdXRDaXJjOiBbMC44NSwgMCwgMC4xNSwgMV0sXG4gIGVhc2VJbkJhY2s6IFswLjM2LCAwLCAwLjY2LCAtMC41Nl0sXG4gIGVhc2VPdXRCYWNrOiBbMC4zNCwgMS41NiwgMC42NCwgMV0sXG4gIGVhc2VJbk91dEJhY2s6IFswLjY4LCAtMC42LCAwLjMyLCAxLjZdXG59O1xuY29uc3QgVHJhbnNpdGlvblByZXNldHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbih7fSwgeyBsaW5lYXI6IGlkZW50aXR5IH0sIF9UcmFuc2l0aW9uUHJlc2V0cyk7XG5mdW5jdGlvbiBjcmVhdGVFYXNpbmdGdW5jdGlvbihbcDAsIHAxLCBwMiwgcDNdKSB7XG4gIGNvbnN0IGEgPSAoYTEsIGEyKSA9PiAxIC0gMyAqIGEyICsgMyAqIGExO1xuICBjb25zdCBiID0gKGExLCBhMikgPT4gMyAqIGEyIC0gNiAqIGExO1xuICBjb25zdCBjID0gKGExKSA9PiAzICogYTE7XG4gIGNvbnN0IGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMoYTEpKSAqIHQ7XG4gIGNvbnN0IGdldFNsb3BlID0gKHQsIGExLCBhMikgPT4gMyAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMiAqIGIoYTEsIGEyKSAqIHQgKyBjKGExKTtcbiAgY29uc3QgZ2V0VGZvclggPSAoeCkgPT4ge1xuICAgIGxldCBhR3Vlc3NUID0geDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgcDAsIHAyKTtcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApXG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgY29uc3QgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIHAwLCBwMikgLSB4O1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH07XG4gIHJldHVybiAoeCkgPT4gcDAgPT09IHAxICYmIHAyID09PSBwMyA/IHggOiBjYWxjQmV6aWVyKGdldFRmb3JYKHgpLCBwMSwgcDMpO1xufVxuZnVuY3Rpb24gbGVycChhLCBiLCBhbHBoYSkge1xuICByZXR1cm4gYSArIGFscGhhICogKGIgLSBhKTtcbn1cbmZ1bmN0aW9uIHRvVmVjKHQpIHtcbiAgcmV0dXJuICh0eXBlb2YgdCA9PT0gXCJudW1iZXJcIiA/IFt0XSA6IHQpIHx8IFtdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVRyYW5zaXRpb24oc291cmNlLCBmcm9tLCB0bywgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGZyb21WYWwgPSB0b1ZhbHVlKGZyb20pO1xuICBjb25zdCB0b1ZhbCA9IHRvVmFsdWUodG8pO1xuICBjb25zdCB2MSA9IHRvVmVjKGZyb21WYWwpO1xuICBjb25zdCB2MiA9IHRvVmVjKHRvVmFsKTtcbiAgY29uc3QgZHVyYXRpb24gPSAoX2EgPSB0b1ZhbHVlKG9wdGlvbnMuZHVyYXRpb24pKSAhPSBudWxsID8gX2EgOiAxZTM7XG4gIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG4gIGNvbnN0IGVuZEF0ID0gRGF0ZS5ub3coKSArIGR1cmF0aW9uO1xuICBjb25zdCB0cmFucyA9IHR5cGVvZiBvcHRpb25zLnRyYW5zaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMudHJhbnNpdGlvbiA6IChfYiA9IHRvVmFsdWUob3B0aW9ucy50cmFuc2l0aW9uKSkgIT0gbnVsbCA/IF9iIDogaWRlbnRpdHk7XG4gIGNvbnN0IGVhc2UgPSB0eXBlb2YgdHJhbnMgPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zIDogY3JlYXRlRWFzaW5nRnVuY3Rpb24odHJhbnMpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzb3VyY2UudmFsdWUgPSBmcm9tVmFsO1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKChfYTIgPSBvcHRpb25zLmFib3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwob3B0aW9ucykpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgYWxwaGEgPSBlYXNlKChub3cgLSBzdGFydGVkQXQpIC8gZHVyYXRpb24pO1xuICAgICAgY29uc3QgYXJyID0gdG9WZWMoc291cmNlLnZhbHVlKS5tYXAoKG4sIGkpID0+IGxlcnAodjFbaV0sIHYyW2ldLCBhbHBoYSkpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlLnZhbHVlKSlcbiAgICAgICAgc291cmNlLnZhbHVlID0gYXJyLm1hcCgobiwgaSkgPT4ge1xuICAgICAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgICAgICByZXR1cm4gbGVycCgoX2EzID0gdjFbaV0pICE9IG51bGwgPyBfYTMgOiAwLCAoX2IyID0gdjJbaV0pICE9IG51bGwgPyBfYjIgOiAwLCBhbHBoYSk7XG4gICAgICAgIH0pO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZS52YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgc291cmNlLnZhbHVlID0gYXJyWzBdO1xuICAgICAgaWYgKG5vdyA8IGVuZEF0KSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZS52YWx1ZSA9IHRvVmFsO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aWNrKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbihzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgY3VycmVudElkID0gMDtcbiAgY29uc3Qgc291cmNlVmFsID0gKCkgPT4ge1xuICAgIGNvbnN0IHYgPSB0b1ZhbHVlKHNvdXJjZSk7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8gdiA6IHYubWFwKHRvVmFsdWUpO1xuICB9O1xuICBjb25zdCBvdXRwdXRSZWYgPSByZWYoc291cmNlVmFsKCkpO1xuICB3YXRjaChzb3VyY2VWYWwsIGFzeW5jICh0bykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHRvVmFsdWUob3B0aW9ucy5kaXNhYmxlZCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaWQgPSArK2N1cnJlbnRJZDtcbiAgICBpZiAob3B0aW9ucy5kZWxheSlcbiAgICAgIGF3YWl0IHByb21pc2VUaW1lb3V0KHRvVmFsdWUob3B0aW9ucy5kZWxheSkpO1xuICAgIGlmIChpZCAhPT0gY3VycmVudElkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRvVmFsID0gQXJyYXkuaXNBcnJheSh0bykgPyB0by5tYXAodG9WYWx1ZSkgOiB0b1ZhbHVlKHRvKTtcbiAgICAoX2EgPSBvcHRpb25zLm9uU3RhcnRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucyk7XG4gICAgYXdhaXQgZXhlY3V0ZVRyYW5zaXRpb24ob3V0cHV0UmVmLCBvdXRwdXRSZWYudmFsdWUsIHRvVmFsLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWJvcnQ6ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBjdXJyZW50SWQgfHwgKChfYTIgPSBvcHRpb25zLmFib3J0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwob3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIChfYiA9IG9wdGlvbnMub25GaW5pc2hlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucyk7XG4gIH0sIHsgZGVlcDogdHJ1ZSB9KTtcbiAgd2F0Y2goKCkgPT4gdG9WYWx1ZShvcHRpb25zLmRpc2FibGVkKSwgKGRpc2FibGVkKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBjdXJyZW50SWQrKztcbiAgICAgIG91dHB1dFJlZi52YWx1ZSA9IHNvdXJjZVZhbCgpO1xuICAgIH1cbiAgfSk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICBjdXJyZW50SWQrKztcbiAgfSk7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB0b1ZhbHVlKG9wdGlvbnMuZGlzYWJsZWQpID8gc291cmNlVmFsKCkgOiBvdXRwdXRSZWYudmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1c2VVcmxTZWFyY2hQYXJhbXMobW9kZSA9IFwiaGlzdG9yeVwiLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGluaXRpYWxWYWx1ZSA9IHt9LFxuICAgIHJlbW92ZU51bGxpc2hWYWx1ZXMgPSB0cnVlLFxuICAgIHJlbW92ZUZhbHN5VmFsdWVzID0gZmFsc2UsXG4gICAgd3JpdGU6IGVuYWJsZVdyaXRlID0gdHJ1ZSxcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIXdpbmRvdylcbiAgICByZXR1cm4gcmVhY3RpdmUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgc3RhdGUgPSByZWFjdGl2ZSh7fSk7XG4gIGZ1bmN0aW9uIGdldFJhd1BhcmFtcygpIHtcbiAgICBpZiAobW9kZSA9PT0gXCJoaXN0b3J5XCIpIHtcbiAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8IFwiXCI7XG4gICAgfSBlbHNlIGlmIChtb2RlID09PSBcImhhc2hcIikge1xuICAgICAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoIHx8IFwiXCI7XG4gICAgICBjb25zdCBpbmRleCA9IGhhc2guaW5kZXhPZihcIj9cIik7XG4gICAgICByZXR1cm4gaW5kZXggPiAwID8gaGFzaC5zbGljZShpbmRleCkgOiBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHdpbmRvdy5sb2NhdGlvbi5oYXNoIHx8IFwiXCIpLnJlcGxhY2UoL14jLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbnN0cnVjdFF1ZXJ5KHBhcmFtcykge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgaWYgKG1vZGUgPT09IFwiaGlzdG9yeVwiKVxuICAgICAgcmV0dXJuIGAke3N0cmluZ2lmaWVkID8gYD8ke3N0cmluZ2lmaWVkfWAgOiBcIlwifSR7d2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCJcIn1gO1xuICAgIGlmIChtb2RlID09PSBcImhhc2gtcGFyYW1zXCIpXG4gICAgICByZXR1cm4gYCR7d2luZG93LmxvY2F0aW9uLnNlYXJjaCB8fCBcIlwifSR7c3RyaW5naWZpZWQgPyBgIyR7c3RyaW5naWZpZWR9YCA6IFwiXCJ9YDtcbiAgICBjb25zdCBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCIjXCI7XG4gICAgY29uc3QgaW5kZXggPSBoYXNoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChpbmRleCA+IDApXG4gICAgICByZXR1cm4gYCR7aGFzaC5zbGljZSgwLCBpbmRleCl9JHtzdHJpbmdpZmllZCA/IGA/JHtzdHJpbmdpZmllZH1gIDogXCJcIn1gO1xuICAgIHJldHVybiBgJHtoYXNofSR7c3RyaW5naWZpZWQgPyBgPyR7c3RyaW5naWZpZWR9YCA6IFwiXCJ9YDtcbiAgfVxuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKGdldFJhd1BhcmFtcygpKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB1bnVzZWRLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhzdGF0ZSkpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcmFtcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHBhcmFtc0ZvcktleSA9IHBhcmFtcy5nZXRBbGwoa2V5KTtcbiAgICAgIHN0YXRlW2tleV0gPSBwYXJhbXNGb3JLZXkubGVuZ3RoID4gMSA/IHBhcmFtc0ZvcktleSA6IHBhcmFtcy5nZXQoa2V5KSB8fCBcIlwiO1xuICAgICAgdW51c2VkS2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgQXJyYXkuZnJvbSh1bnVzZWRLZXlzKS5mb3JFYWNoKChrZXkpID0+IGRlbGV0ZSBzdGF0ZVtrZXldKTtcbiAgfVxuICBjb25zdCB7IHBhdXNlLCByZXN1bWUgfSA9IHBhdXNhYmxlV2F0Y2goXG4gICAgc3RhdGUsXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhcIlwiKTtcbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbWFwRW50cnkgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBFbnRyeSkpXG4gICAgICAgICAgbWFwRW50cnkuZm9yRWFjaCgodmFsdWUpID0+IHBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICBlbHNlIGlmIChyZW1vdmVOdWxsaXNoVmFsdWVzICYmIG1hcEVudHJ5ID09IG51bGwpXG4gICAgICAgICAgcGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICBlbHNlIGlmIChyZW1vdmVGYWxzeVZhbHVlcyAmJiAhbWFwRW50cnkpXG4gICAgICAgICAgcGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcGFyYW1zLnNldChrZXksIG1hcEVudHJ5KTtcbiAgICAgIH0pO1xuICAgICAgd3JpdGUocGFyYW1zKTtcbiAgICB9LFxuICAgIHsgZGVlcDogdHJ1ZSB9XG4gICk7XG4gIGZ1bmN0aW9uIHdyaXRlKHBhcmFtcywgc2hvdWxkVXBkYXRlKSB7XG4gICAgcGF1c2UoKTtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKVxuICAgICAgdXBkYXRlU3RhdGUocGFyYW1zKTtcbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoXG4gICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZSxcbiAgICAgIHdpbmRvdy5kb2N1bWVudC50aXRsZSxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIGNvbnN0cnVjdFF1ZXJ5KHBhcmFtcylcbiAgICApO1xuICAgIHJlc3VtZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ2hhbmdlZCgpIHtcbiAgICBpZiAoIWVuYWJsZVdyaXRlKVxuICAgICAgcmV0dXJuO1xuICAgIHdyaXRlKHJlYWQoKSwgdHJ1ZSk7XG4gIH1cbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwicG9wc3RhdGVcIiwgb25DaGFuZ2VkLCBmYWxzZSk7XG4gIGlmIChtb2RlICE9PSBcImhpc3RvcnlcIilcbiAgICB1c2VFdmVudExpc3RlbmVyKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsIG9uQ2hhbmdlZCwgZmFsc2UpO1xuICBjb25zdCBpbml0aWFsID0gcmVhZCgpO1xuICBpZiAoaW5pdGlhbC5rZXlzKCkubmV4dCgpLnZhbHVlKVxuICAgIHVwZGF0ZVN0YXRlKGluaXRpYWwpO1xuICBlbHNlXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgaW5pdGlhbFZhbHVlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1c2VVc2VyTWVkaWEob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGVuYWJsZWQgPSByZWYoKF9hID0gb3B0aW9ucy5lbmFibGVkKSAhPSBudWxsID8gX2EgOiBmYWxzZSk7XG4gIGNvbnN0IGF1dG9Td2l0Y2ggPSByZWYoKF9iID0gb3B0aW9ucy5hdXRvU3dpdGNoKSAhPSBudWxsID8gX2IgOiB0cnVlKTtcbiAgY29uc3QgY29uc3RyYWludHMgPSByZWYob3B0aW9ucy5jb25zdHJhaW50cyk7XG4gIGNvbnN0IHsgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvciB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB1c2VTdXBwb3J0ZWQoKCkgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIChfYTIgPSBuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5tZWRpYURldmljZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0VXNlck1lZGlhO1xuICB9KTtcbiAgY29uc3Qgc3RyZWFtID0gc2hhbGxvd1JlZigpO1xuICBmdW5jdGlvbiBnZXREZXZpY2VPcHRpb25zKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ2aWRlb1wiOiB7XG4gICAgICAgIGlmIChjb25zdHJhaW50cy52YWx1ZSlcbiAgICAgICAgICByZXR1cm4gY29uc3RyYWludHMudmFsdWUudmlkZW8gfHwgZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImF1ZGlvXCI6IHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZhbHVlKVxuICAgICAgICAgIHJldHVybiBjb25zdHJhaW50cy52YWx1ZS5hdWRpbyB8fCBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIF9zdGFydCgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8IHN0cmVhbS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBzdHJlYW0udmFsdWUgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICB2aWRlbzogZ2V0RGV2aWNlT3B0aW9ucyhcInZpZGVvXCIpLFxuICAgICAgYXVkaW86IGdldERldmljZU9wdGlvbnMoXCJhdWRpb1wiKVxuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW0udmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgdmFyIF9hMjtcbiAgICAoX2EyID0gc3RyZWFtLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHQuc3RvcCgpKTtcbiAgICBzdHJlYW0udmFsdWUgPSB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBfc3RvcCgpO1xuICAgIGVuYWJsZWQudmFsdWUgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBhd2FpdCBfc3RhcnQoKTtcbiAgICBpZiAoc3RyZWFtLnZhbHVlKVxuICAgICAgZW5hYmxlZC52YWx1ZSA9IHRydWU7XG4gICAgcmV0dXJuIHN0cmVhbS52YWx1ZTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIF9zdG9wKCk7XG4gICAgcmV0dXJuIGF3YWl0IHN0YXJ0KCk7XG4gIH1cbiAgd2F0Y2goXG4gICAgZW5hYmxlZCxcbiAgICAodikgPT4ge1xuICAgICAgaWYgKHYpXG4gICAgICAgIF9zdGFydCgpO1xuICAgICAgZWxzZSBfc3RvcCgpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6IHRydWUgfVxuICApO1xuICB3YXRjaChcbiAgICBjb25zdHJhaW50cyxcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoYXV0b1N3aXRjaC52YWx1ZSAmJiBzdHJlYW0udmFsdWUpXG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiB0cnVlIH1cbiAgKTtcbiAgdHJ5T25TY29wZURpc3Bvc2UoKCkgPT4ge1xuICAgIHN0b3AoKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgc3RyZWFtLFxuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgcmVzdGFydCxcbiAgICBjb25zdHJhaW50cyxcbiAgICBlbmFibGVkLFxuICAgIGF1dG9Td2l0Y2hcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVk1vZGVsKHByb3BzLCBrZXksIGVtaXQsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICBjb25zdCB7XG4gICAgY2xvbmUgPSBmYWxzZSxcbiAgICBwYXNzaXZlID0gZmFsc2UsXG4gICAgZXZlbnROYW1lLFxuICAgIGRlZXAgPSBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWUsXG4gICAgc2hvdWxkRW1pdFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgdm0gPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgY29uc3QgX2VtaXQgPSBlbWl0IHx8ICh2bSA9PSBudWxsID8gdm9pZCAwIDogdm0uZW1pdCkgfHwgKChfYSA9IHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS4kZW1pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJpbmQodm0pKSB8fCAoKF9jID0gKF9iID0gdm0gPT0gbnVsbCA/IHZvaWQgMCA6IHZtLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2IuJGVtaXQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5iaW5kKHZtID09IG51bGwgPyB2b2lkIDAgOiB2bS5wcm94eSkpO1xuICBsZXQgZXZlbnQgPSBldmVudE5hbWU7XG4gIGlmICgha2V5KSB7XG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgY29uc3QgbW9kZWxPcHRpb25zID0gKF9lID0gKF9kID0gdm0gPT0gbnVsbCA/IHZvaWQgMCA6IHZtLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2QuJG9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5tb2RlbDtcbiAgICAgIGtleSA9IChtb2RlbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1vZGVsT3B0aW9ucy52YWx1ZSkgfHwgXCJ2YWx1ZVwiO1xuICAgICAgaWYgKCFldmVudE5hbWUpXG4gICAgICAgIGV2ZW50ID0gKG1vZGVsT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbW9kZWxPcHRpb25zLmV2ZW50KSB8fCBcImlucHV0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwibW9kZWxWYWx1ZVwiO1xuICAgIH1cbiAgfVxuICBldmVudCA9IGV2ZW50IHx8IGB1cGRhdGU6JHtrZXkudG9TdHJpbmcoKX1gO1xuICBjb25zdCBjbG9uZUZuID0gKHZhbCkgPT4gIWNsb25lID8gdmFsIDogdHlwZW9mIGNsb25lID09PSBcImZ1bmN0aW9uXCIgPyBjbG9uZSh2YWwpIDogY2xvbmVGbkpTT04odmFsKTtcbiAgY29uc3QgZ2V0VmFsdWUgPSAoKSA9PiBpc0RlZihwcm9wc1trZXldKSA/IGNsb25lRm4ocHJvcHNba2V5XSkgOiBkZWZhdWx0VmFsdWU7XG4gIGNvbnN0IHRyaWdnZXJFbWl0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHNob3VsZEVtaXQpIHtcbiAgICAgIGlmIChzaG91bGRFbWl0KHZhbHVlKSlcbiAgICAgICAgX2VtaXQoZXZlbnQsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2VtaXQoZXZlbnQsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGlmIChwYXNzaXZlKSB7XG4gICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwcm94eSA9IHJlZihpbml0aWFsVmFsdWUpO1xuICAgIGxldCBpc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBwcm9wc1trZXldLFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgaWYgKCFpc1VwZGF0aW5nKSB7XG4gICAgICAgICAgaXNVcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgcHJveHkudmFsdWUgPSBjbG9uZUZuKHYpO1xuICAgICAgICAgIG5leHRUaWNrKCgpID0+IGlzVXBkYXRpbmcgPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHdhdGNoKFxuICAgICAgcHJveHksXG4gICAgICAodikgPT4ge1xuICAgICAgICBpZiAoIWlzVXBkYXRpbmcgJiYgKHYgIT09IHByb3BzW2tleV0gfHwgZGVlcCkpXG4gICAgICAgICAgdHJpZ2dlckVtaXQodik7XG4gICAgICB9LFxuICAgICAgeyBkZWVwIH1cbiAgICApO1xuICAgIHJldHVybiBwcm94eTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoe1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWUoKTtcbiAgICAgIH0sXG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgdHJpZ2dlckVtaXQodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZVZNb2RlbHMocHJvcHMsIGVtaXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICByZXRba2V5XSA9IHVzZVZNb2RlbChcbiAgICAgIHByb3BzLFxuICAgICAga2V5LFxuICAgICAgZW1pdCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHVzZVZpYnJhdGUob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGF0dGVybiA9IFtdLFxuICAgIGludGVydmFsID0gMCxcbiAgICBuYXZpZ2F0b3IgPSBkZWZhdWx0TmF2aWdhdG9yXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IHBhdHRlcm5SZWYgPSB0b1JlZihwYXR0ZXJuKTtcbiAgbGV0IGludGVydmFsQ29udHJvbHM7XG4gIGNvbnN0IHZpYnJhdGUgPSAocGF0dGVybjIgPSBwYXR0ZXJuUmVmLnZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgbmF2aWdhdG9yLnZpYnJhdGUocGF0dGVybjIpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlmIChpc1N1cHBvcnRlZC52YWx1ZSlcbiAgICAgIG5hdmlnYXRvci52aWJyYXRlKDApO1xuICAgIGludGVydmFsQ29udHJvbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGludGVydmFsQ29udHJvbHMucGF1c2UoKTtcbiAgfTtcbiAgaWYgKGludGVydmFsID4gMCkge1xuICAgIGludGVydmFsQ29udHJvbHMgPSB1c2VJbnRlcnZhbEZuKFxuICAgICAgdmlicmF0ZSxcbiAgICAgIGludGVydmFsLFxuICAgICAge1xuICAgICAgICBpbW1lZGlhdGU6IGZhbHNlLFxuICAgICAgICBpbW1lZGlhdGVDYWxsYmFjazogZmFsc2VcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgcGF0dGVybixcbiAgICBpbnRlcnZhbENvbnRyb2xzLFxuICAgIHZpYnJhdGUsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VWaXJ0dWFsTGlzdChsaXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgY29udGFpbmVyU3R5bGUsIHdyYXBwZXJQcm9wcywgc2Nyb2xsVG8sIGNhbGN1bGF0ZVJhbmdlLCBjdXJyZW50TGlzdCwgY29udGFpbmVyUmVmIH0gPSBcIml0ZW1IZWlnaHRcIiBpbiBvcHRpb25zID8gdXNlVmVydGljYWxWaXJ0dWFsTGlzdChvcHRpb25zLCBsaXN0KSA6IHVzZUhvcml6b250YWxWaXJ0dWFsTGlzdChvcHRpb25zLCBsaXN0KTtcbiAgcmV0dXJuIHtcbiAgICBsaXN0OiBjdXJyZW50TGlzdCxcbiAgICBzY3JvbGxUbyxcbiAgICBjb250YWluZXJQcm9wczoge1xuICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICBvblNjcm9sbDogKCkgPT4ge1xuICAgICAgICBjYWxjdWxhdGVSYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiBjb250YWluZXJTdHlsZVxuICAgIH0sXG4gICAgd3JhcHBlclByb3BzXG4gIH07XG59XG5mdW5jdGlvbiB1c2VWaXJ0dWFsTGlzdFJlc291cmNlcyhsaXN0KSB7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHJlZihudWxsKTtcbiAgY29uc3Qgc2l6ZSA9IHVzZUVsZW1lbnRTaXplKGNvbnRhaW5lclJlZik7XG4gIGNvbnN0IGN1cnJlbnRMaXN0ID0gcmVmKFtdKTtcbiAgY29uc3Qgc291cmNlID0gc2hhbGxvd1JlZihsaXN0KTtcbiAgY29uc3Qgc3RhdGUgPSByZWYoeyBzdGFydDogMCwgZW5kOiAxMCB9KTtcbiAgcmV0dXJuIHsgc3RhdGUsIHNvdXJjZSwgY3VycmVudExpc3QsIHNpemUsIGNvbnRhaW5lclJlZiB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0Vmlld0NhcGFjaXR5KHN0YXRlLCBzb3VyY2UsIGl0ZW1TaXplKSB7XG4gIHJldHVybiAoY29udGFpbmVyU2l6ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbVNpemUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gTWF0aC5jZWlsKGNvbnRhaW5lclNpemUgLyBpdGVtU2l6ZSk7XG4gICAgY29uc3QgeyBzdGFydCA9IDAgfSA9IHN0YXRlLnZhbHVlO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBjYXBhY2l0eSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc291cmNlLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaXplID0gaXRlbVNpemUoaSk7XG4gICAgICBzdW0gKz0gc2l6ZTtcbiAgICAgIGNhcGFjaXR5ID0gaTtcbiAgICAgIGlmIChzdW0gPiBjb250YWluZXJTaXplKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNhcGFjaXR5IC0gc3RhcnQ7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXRPZmZzZXQoc291cmNlLCBpdGVtU2l6ZSkge1xuICByZXR1cm4gKHNjcm9sbERpcmVjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbVNpemUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihzY3JvbGxEaXJlY3Rpb24gLyBpdGVtU2l6ZSkgKyAxO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaXplID0gaXRlbVNpemUoaSk7XG4gICAgICBzdW0gKz0gc2l6ZTtcbiAgICAgIGlmIChzdW0gPj0gc2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgIG9mZnNldCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGN1bGF0ZVJhbmdlKHR5cGUsIG92ZXJzY2FuLCBnZXRPZmZzZXQsIGdldFZpZXdDYXBhY2l0eSwgeyBjb250YWluZXJSZWYsIHN0YXRlLCBjdXJyZW50TGlzdCwgc291cmNlIH0pIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gY29udGFpbmVyUmVmLnZhbHVlO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBnZXRPZmZzZXQodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gZWxlbWVudC5zY3JvbGxUb3AgOiBlbGVtZW50LnNjcm9sbExlZnQpO1xuICAgICAgY29uc3Qgdmlld0NhcGFjaXR5ID0gZ2V0Vmlld0NhcGFjaXR5KHR5cGUgPT09IFwidmVydGljYWxcIiA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogZWxlbWVudC5jbGllbnRXaWR0aCk7XG4gICAgICBjb25zdCBmcm9tID0gb2Zmc2V0IC0gb3ZlcnNjYW47XG4gICAgICBjb25zdCB0byA9IG9mZnNldCArIHZpZXdDYXBhY2l0eSArIG92ZXJzY2FuO1xuICAgICAgc3RhdGUudmFsdWUgPSB7XG4gICAgICAgIHN0YXJ0OiBmcm9tIDwgMCA/IDAgOiBmcm9tLFxuICAgICAgICBlbmQ6IHRvID4gc291cmNlLnZhbHVlLmxlbmd0aCA/IHNvdXJjZS52YWx1ZS5sZW5ndGggOiB0b1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnRMaXN0LnZhbHVlID0gc291cmNlLnZhbHVlLnNsaWNlKHN0YXRlLnZhbHVlLnN0YXJ0LCBzdGF0ZS52YWx1ZS5lbmQpLm1hcCgoZWxlLCBpbmRleCkgPT4gKHtcbiAgICAgICAgZGF0YTogZWxlLFxuICAgICAgICBpbmRleDogaW5kZXggKyBzdGF0ZS52YWx1ZS5zdGFydFxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldERpc3RhbmNlKGl0ZW1TaXplLCBzb3VyY2UpIHtcbiAgcmV0dXJuIChpbmRleCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaXRlbVNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHNpemUyID0gaW5kZXggKiBpdGVtU2l6ZTtcbiAgICAgIHJldHVybiBzaXplMjtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHNvdXJjZS52YWx1ZS5zbGljZSgwLCBpbmRleCkucmVkdWNlKChzdW0sIF8sIGkpID0+IHN1bSArIGl0ZW1TaXplKGkpLCAwKTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVdhdGNoRm9yU2l6ZXMoc2l6ZSwgbGlzdCwgY29udGFpbmVyUmVmLCBjYWxjdWxhdGVSYW5nZSkge1xuICB3YXRjaChbc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIGxpc3QsIGNvbnRhaW5lclJlZl0sICgpID0+IHtcbiAgICBjYWxjdWxhdGVSYW5nZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkVG90YWxTaXplKGl0ZW1TaXplLCBzb3VyY2UpIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW1TaXplID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHNvdXJjZS52YWx1ZS5sZW5ndGggKiBpdGVtU2l6ZTtcbiAgICByZXR1cm4gc291cmNlLnZhbHVlLnJlZHVjZSgoc3VtLCBfLCBpbmRleCkgPT4gc3VtICsgaXRlbVNpemUoaW5kZXgpLCAwKTtcbiAgfSk7XG59XG5jb25zdCBzY3JvbGxUb0RpY3Rpb25hcnlGb3JFbGVtZW50U2Nyb2xsS2V5ID0ge1xuICBob3Jpem9udGFsOiBcInNjcm9sbExlZnRcIixcbiAgdmVydGljYWw6IFwic2Nyb2xsVG9wXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVTY3JvbGxUbyh0eXBlLCBjYWxjdWxhdGVSYW5nZSwgZ2V0RGlzdGFuY2UsIGNvbnRhaW5lclJlZikge1xuICByZXR1cm4gKGluZGV4KSA9PiB7XG4gICAgaWYgKGNvbnRhaW5lclJlZi52YWx1ZSkge1xuICAgICAgY29udGFpbmVyUmVmLnZhbHVlW3Njcm9sbFRvRGljdGlvbmFyeUZvckVsZW1lbnRTY3JvbGxLZXlbdHlwZV1dID0gZ2V0RGlzdGFuY2UoaW5kZXgpO1xuICAgICAgY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VIb3Jpem9udGFsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCkge1xuICBjb25zdCByZXNvdXJjZXMgPSB1c2VWaXJ0dWFsTGlzdFJlc291cmNlcyhsaXN0KTtcbiAgY29uc3QgeyBzdGF0ZSwgc291cmNlLCBjdXJyZW50TGlzdCwgc2l6ZSwgY29udGFpbmVyUmVmIH0gPSByZXNvdXJjZXM7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0geyBvdmVyZmxvd1g6IFwiYXV0b1wiIH07XG4gIGNvbnN0IHsgaXRlbVdpZHRoLCBvdmVyc2NhbiA9IDUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGdldFZpZXdDYXBhY2l0eSA9IGNyZWF0ZUdldFZpZXdDYXBhY2l0eShzdGF0ZSwgc291cmNlLCBpdGVtV2lkdGgpO1xuICBjb25zdCBnZXRPZmZzZXQgPSBjcmVhdGVHZXRPZmZzZXQoc291cmNlLCBpdGVtV2lkdGgpO1xuICBjb25zdCBjYWxjdWxhdGVSYW5nZSA9IGNyZWF0ZUNhbGN1bGF0ZVJhbmdlKFwiaG9yaXpvbnRhbFwiLCBvdmVyc2NhbiwgZ2V0T2Zmc2V0LCBnZXRWaWV3Q2FwYWNpdHksIHJlc291cmNlcyk7XG4gIGNvbnN0IGdldERpc3RhbmNlTGVmdCA9IGNyZWF0ZUdldERpc3RhbmNlKGl0ZW1XaWR0aCwgc291cmNlKTtcbiAgY29uc3Qgb2Zmc2V0TGVmdCA9IGNvbXB1dGVkKCgpID0+IGdldERpc3RhbmNlTGVmdChzdGF0ZS52YWx1ZS5zdGFydCkpO1xuICBjb25zdCB0b3RhbFdpZHRoID0gY3JlYXRlQ29tcHV0ZWRUb3RhbFNpemUoaXRlbVdpZHRoLCBzb3VyY2UpO1xuICB1c2VXYXRjaEZvclNpemVzKHNpemUsIGxpc3QsIGNvbnRhaW5lclJlZiwgY2FsY3VsYXRlUmFuZ2UpO1xuICBjb25zdCBzY3JvbGxUbyA9IGNyZWF0ZVNjcm9sbFRvKFwiaG9yaXpvbnRhbFwiLCBjYWxjdWxhdGVSYW5nZSwgZ2V0RGlzdGFuY2VMZWZ0LCBjb250YWluZXJSZWYpO1xuICBjb25zdCB3cmFwcGVyUHJvcHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHdpZHRoOiBgJHt0b3RhbFdpZHRoLnZhbHVlIC0gb2Zmc2V0TGVmdC52YWx1ZX1weGAsXG4gICAgICAgIG1hcmdpbkxlZnQ6IGAke29mZnNldExlZnQudmFsdWV9cHhgLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIlxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNjcm9sbFRvLFxuICAgIGNhbGN1bGF0ZVJhbmdlLFxuICAgIHdyYXBwZXJQcm9wcyxcbiAgICBjb250YWluZXJTdHlsZSxcbiAgICBjdXJyZW50TGlzdCxcbiAgICBjb250YWluZXJSZWZcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVZlcnRpY2FsVmlydHVhbExpc3Qob3B0aW9ucywgbGlzdCkge1xuICBjb25zdCByZXNvdXJjZXMgPSB1c2VWaXJ0dWFsTGlzdFJlc291cmNlcyhsaXN0KTtcbiAgY29uc3QgeyBzdGF0ZSwgc291cmNlLCBjdXJyZW50TGlzdCwgc2l6ZSwgY29udGFpbmVyUmVmIH0gPSByZXNvdXJjZXM7XG4gIGNvbnN0IGNvbnRhaW5lclN0eWxlID0geyBvdmVyZmxvd1k6IFwiYXV0b1wiIH07XG4gIGNvbnN0IHsgaXRlbUhlaWdodCwgb3ZlcnNjYW4gPSA1IH0gPSBvcHRpb25zO1xuICBjb25zdCBnZXRWaWV3Q2FwYWNpdHkgPSBjcmVhdGVHZXRWaWV3Q2FwYWNpdHkoc3RhdGUsIHNvdXJjZSwgaXRlbUhlaWdodCk7XG4gIGNvbnN0IGdldE9mZnNldCA9IGNyZWF0ZUdldE9mZnNldChzb3VyY2UsIGl0ZW1IZWlnaHQpO1xuICBjb25zdCBjYWxjdWxhdGVSYW5nZSA9IGNyZWF0ZUNhbGN1bGF0ZVJhbmdlKFwidmVydGljYWxcIiwgb3ZlcnNjYW4sIGdldE9mZnNldCwgZ2V0Vmlld0NhcGFjaXR5LCByZXNvdXJjZXMpO1xuICBjb25zdCBnZXREaXN0YW5jZVRvcCA9IGNyZWF0ZUdldERpc3RhbmNlKGl0ZW1IZWlnaHQsIHNvdXJjZSk7XG4gIGNvbnN0IG9mZnNldFRvcCA9IGNvbXB1dGVkKCgpID0+IGdldERpc3RhbmNlVG9wKHN0YXRlLnZhbHVlLnN0YXJ0KSk7XG4gIGNvbnN0IHRvdGFsSGVpZ2h0ID0gY3JlYXRlQ29tcHV0ZWRUb3RhbFNpemUoaXRlbUhlaWdodCwgc291cmNlKTtcbiAgdXNlV2F0Y2hGb3JTaXplcyhzaXplLCBsaXN0LCBjb250YWluZXJSZWYsIGNhbGN1bGF0ZVJhbmdlKTtcbiAgY29uc3Qgc2Nyb2xsVG8gPSBjcmVhdGVTY3JvbGxUbyhcInZlcnRpY2FsXCIsIGNhbGN1bGF0ZVJhbmdlLCBnZXREaXN0YW5jZVRvcCwgY29udGFpbmVyUmVmKTtcbiAgY29uc3Qgd3JhcHBlclByb3BzID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgIGhlaWdodDogYCR7dG90YWxIZWlnaHQudmFsdWUgLSBvZmZzZXRUb3AudmFsdWV9cHhgLFxuICAgICAgICBtYXJnaW5Ub3A6IGAke29mZnNldFRvcC52YWx1ZX1weGBcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxjdWxhdGVSYW5nZSxcbiAgICBzY3JvbGxUbyxcbiAgICBjb250YWluZXJTdHlsZSxcbiAgICB3cmFwcGVyUHJvcHMsXG4gICAgY3VycmVudExpc3QsXG4gICAgY29udGFpbmVyUmVmXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVdha2VMb2NrKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbmF2aWdhdG9yID0gZGVmYXVsdE5hdmlnYXRvcixcbiAgICBkb2N1bWVudCA9IGRlZmF1bHREb2N1bWVudFxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHdha2VMb2NrO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiBuYXZpZ2F0b3IgJiYgXCJ3YWtlTG9ja1wiIGluIG5hdmlnYXRvcik7XG4gIGNvbnN0IGlzQWN0aXZlID0gcmVmKGZhbHNlKTtcbiAgYXN5bmMgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIXdha2VMb2NrKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKVxuICAgICAgd2FrZUxvY2sgPSBhd2FpdCBuYXZpZ2F0b3Iud2FrZUxvY2sucmVxdWVzdChcInNjcmVlblwiKTtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9ICF3YWtlTG9jay5yZWxlYXNlZDtcbiAgfVxuICBpZiAoZG9jdW1lbnQpXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICBhc3luYyBmdW5jdGlvbiByZXF1ZXN0KHR5cGUpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHdha2VMb2NrID0gYXdhaXQgbmF2aWdhdG9yLndha2VMb2NrLnJlcXVlc3QodHlwZSk7XG4gICAgaXNBY3RpdmUudmFsdWUgPSAhd2FrZUxvY2sucmVsZWFzZWQ7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICBpZiAoIWlzU3VwcG9ydGVkLnZhbHVlIHx8ICF3YWtlTG9jaylcbiAgICAgIHJldHVybjtcbiAgICBhd2FpdCB3YWtlTG9jay5yZWxlYXNlKCk7XG4gICAgaXNBY3RpdmUudmFsdWUgPSAhd2FrZUxvY2sucmVsZWFzZWQ7XG4gICAgd2FrZUxvY2sgPSBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNTdXBwb3J0ZWQsXG4gICAgaXNBY3RpdmUsXG4gICAgcmVxdWVzdCxcbiAgICByZWxlYXNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVdlYk5vdGlmaWNhdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHdpbmRvdyA9IGRlZmF1bHRXaW5kb3csXG4gICAgcmVxdWVzdFBlcm1pc3Npb25zOiBfcmVxdWVzdEZvclBlcm1pc3Npb25zID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGVmYXVsdFdlYk5vdGlmaWNhdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHVzZVN1cHBvcnRlZCgoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cgfHwgIShcIk5vdGlmaWNhdGlvblwiIGluIHdpbmRvdykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBOb3RpZmljYXRpb24oXCJcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IHBlcm1pc3Npb25HcmFudGVkID0gcmVmKGlzU3VwcG9ydGVkLnZhbHVlICYmIFwicGVybWlzc2lvblwiIGluIE5vdGlmaWNhdGlvbiAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gXCJncmFudGVkXCIpO1xuICBjb25zdCBub3RpZmljYXRpb24gPSByZWYobnVsbCk7XG4gIGNvbnN0IGVuc3VyZVBlcm1pc3Npb25zID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFwZXJtaXNzaW9uR3JhbnRlZC52YWx1ZSAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiAhPT0gXCJkZW5pZWRcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICBpZiAocmVzdWx0ID09PSBcImdyYW50ZWRcIilcbiAgICAgICAgcGVybWlzc2lvbkdyYW50ZWQudmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGVybWlzc2lvbkdyYW50ZWQudmFsdWU7XG4gIH07XG4gIGNvbnN0IHsgb246IG9uQ2xpY2ssIHRyaWdnZXI6IGNsaWNrVHJpZ2dlciB9ID0gY3JlYXRlRXZlbnRIb29rKCk7XG4gIGNvbnN0IHsgb246IG9uU2hvdywgdHJpZ2dlcjogc2hvd1RyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkVycm9yLCB0cmlnZ2VyOiBlcnJvclRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCB7IG9uOiBvbkNsb3NlLCB0cmlnZ2VyOiBjbG9zZVRyaWdnZXIgfSA9IGNyZWF0ZUV2ZW50SG9vaygpO1xuICBjb25zdCBzaG93ID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgIGlmICghaXNTdXBwb3J0ZWQudmFsdWUgfHwgIXBlcm1pc3Npb25HcmFudGVkLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9wdGlvbnMyID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFdlYk5vdGlmaWNhdGlvbk9wdGlvbnMsIG92ZXJyaWRlcyk7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlID0gbmV3IE5vdGlmaWNhdGlvbihvcHRpb25zMi50aXRsZSB8fCBcIlwiLCBvcHRpb25zMik7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlLm9uY2xpY2sgPSBjbGlja1RyaWdnZXI7XG4gICAgbm90aWZpY2F0aW9uLnZhbHVlLm9uc2hvdyA9IHNob3dUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmVycm9yID0gZXJyb3JUcmlnZ2VyO1xuICAgIG5vdGlmaWNhdGlvbi52YWx1ZS5vbmNsb3NlID0gY2xvc2VUcmlnZ2VyO1xuICAgIHJldHVybiBub3RpZmljYXRpb24udmFsdWU7XG4gIH07XG4gIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgIGlmIChub3RpZmljYXRpb24udmFsdWUpXG4gICAgICBub3RpZmljYXRpb24udmFsdWUuY2xvc2UoKTtcbiAgICBub3RpZmljYXRpb24udmFsdWUgPSBudWxsO1xuICB9O1xuICBpZiAoX3JlcXVlc3RGb3JQZXJtaXNzaW9ucylcbiAgICB0cnlPbk1vdW50ZWQoZW5zdXJlUGVybWlzc2lvbnMpO1xuICB0cnlPblNjb3BlRGlzcG9zZShjbG9zZSk7XG4gIGlmIChpc1N1cHBvcnRlZC52YWx1ZSAmJiB3aW5kb3cpIHtcbiAgICBjb25zdCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB1c2VFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcInZpc2liaWxpdHljaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc1N1cHBvcnRlZCxcbiAgICBub3RpZmljYXRpb24sXG4gICAgZW5zdXJlUGVybWlzc2lvbnMsXG4gICAgcGVybWlzc2lvbkdyYW50ZWQsXG4gICAgc2hvdyxcbiAgICBjbG9zZSxcbiAgICBvbkNsaWNrLFxuICAgIG9uU2hvdyxcbiAgICBvbkVycm9yLFxuICAgIG9uQ2xvc2VcbiAgfTtcbn1cblxuY29uc3QgREVGQVVMVF9QSU5HX01FU1NBR0UgPSBcInBpbmdcIjtcbmZ1bmN0aW9uIHJlc29sdmVOZXN0ZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHVzZVdlYlNvY2tldCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgb25Db25uZWN0ZWQsXG4gICAgb25EaXNjb25uZWN0ZWQsXG4gICAgb25FcnJvcixcbiAgICBvbk1lc3NhZ2UsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBhdXRvQ2xvc2UgPSB0cnVlLFxuICAgIHByb3RvY29scyA9IFtdXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhID0gcmVmKG51bGwpO1xuICBjb25zdCBzdGF0dXMgPSByZWYoXCJDTE9TRURcIik7XG4gIGNvbnN0IHdzUmVmID0gcmVmKCk7XG4gIGNvbnN0IHVybFJlZiA9IHRvUmVmKHVybCk7XG4gIGxldCBoZWFydGJlYXRQYXVzZTtcbiAgbGV0IGhlYXJ0YmVhdFJlc3VtZTtcbiAgbGV0IGV4cGxpY2l0bHlDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHJldHJpZWQgPSAwO1xuICBsZXQgYnVmZmVyZWREYXRhID0gW107XG4gIGxldCBwb25nVGltZW91dFdhaXQ7XG4gIGNvbnN0IF9zZW5kQnVmZmVyID0gKCkgPT4ge1xuICAgIGlmIChidWZmZXJlZERhdGEubGVuZ3RoICYmIHdzUmVmLnZhbHVlICYmIHN0YXR1cy52YWx1ZSA9PT0gXCJPUEVOXCIpIHtcbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcmVkRGF0YSlcbiAgICAgICAgd3NSZWYudmFsdWUuc2VuZChidWZmZXIpO1xuICAgICAgYnVmZmVyZWREYXRhID0gW107XG4gICAgfVxuICB9O1xuICBjb25zdCByZXNldEhlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQocG9uZ1RpbWVvdXRXYWl0KTtcbiAgICBwb25nVGltZW91dFdhaXQgPSB2b2lkIDA7XG4gIH07XG4gIGNvbnN0IGNsb3NlID0gKGNvZGUgPSAxZTMsIHJlYXNvbikgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIXdzUmVmLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGV4cGxpY2l0bHlDbG9zZWQgPSB0cnVlO1xuICAgIHJlc2V0SGVhcnRiZWF0KCk7XG4gICAgaGVhcnRiZWF0UGF1c2UgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYXJ0YmVhdFBhdXNlKCk7XG4gICAgd3NSZWYudmFsdWUuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICB3c1JlZi52YWx1ZSA9IHZvaWQgMDtcbiAgfTtcbiAgY29uc3Qgc2VuZCA9IChkYXRhMiwgdXNlQnVmZmVyID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghd3NSZWYudmFsdWUgfHwgc3RhdHVzLnZhbHVlICE9PSBcIk9QRU5cIikge1xuICAgICAgaWYgKHVzZUJ1ZmZlcilcbiAgICAgICAgYnVmZmVyZWREYXRhLnB1c2goZGF0YTIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfc2VuZEJ1ZmZlcigpO1xuICAgIHdzUmVmLnZhbHVlLnNlbmQoZGF0YTIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCBfaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoZXhwbGljaXRseUNsb3NlZCB8fCB0eXBlb2YgdXJsUmVmLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldCh1cmxSZWYudmFsdWUsIHByb3RvY29scyk7XG4gICAgd3NSZWYudmFsdWUgPSB3cztcbiAgICBzdGF0dXMudmFsdWUgPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBzdGF0dXMudmFsdWUgPSBcIk9QRU5cIjtcbiAgICAgIG9uQ29ubmVjdGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkNvbm5lY3RlZCh3cyk7XG4gICAgICBoZWFydGJlYXRSZXN1bWUgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYXJ0YmVhdFJlc3VtZSgpO1xuICAgICAgX3NlbmRCdWZmZXIoKTtcbiAgICB9O1xuICAgIHdzLm9uY2xvc2UgPSAoZXYpID0+IHtcbiAgICAgIHN0YXR1cy52YWx1ZSA9IFwiQ0xPU0VEXCI7XG4gICAgICBvbkRpc2Nvbm5lY3RlZCA9PSBudWxsID8gdm9pZCAwIDogb25EaXNjb25uZWN0ZWQod3MsIGV2KTtcbiAgICAgIGlmICghZXhwbGljaXRseUNsb3NlZCAmJiBvcHRpb25zLmF1dG9SZWNvbm5lY3QpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJldHJpZXMgPSAtMSxcbiAgICAgICAgICBkZWxheSA9IDFlMyxcbiAgICAgICAgICBvbkZhaWxlZFxuICAgICAgICB9ID0gcmVzb2x2ZU5lc3RlZE9wdGlvbnMob3B0aW9ucy5hdXRvUmVjb25uZWN0KTtcbiAgICAgICAgcmV0cmllZCArPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHJldHJpZXMgPT09IFwibnVtYmVyXCIgJiYgKHJldHJpZXMgPCAwIHx8IHJldHJpZWQgPCByZXRyaWVzKSlcbiAgICAgICAgICBzZXRUaW1lb3V0KF9pbml0LCBkZWxheSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXRyaWVzID09PSBcImZ1bmN0aW9uXCIgJiYgcmV0cmllcygpKVxuICAgICAgICAgIHNldFRpbWVvdXQoX2luaXQsIGRlbGF5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9uRmFpbGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkZhaWxlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgd3Mub25lcnJvciA9IChlKSA9PiB7XG4gICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKHdzLCBlKTtcbiAgICB9O1xuICAgIHdzLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5oZWFydGJlYXQpIHtcbiAgICAgICAgcmVzZXRIZWFydGJlYXQoKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1lc3NhZ2UgPSBERUZBVUxUX1BJTkdfTUVTU0FHRVxuICAgICAgICB9ID0gcmVzb2x2ZU5lc3RlZE9wdGlvbnMob3B0aW9ucy5oZWFydGJlYXQpO1xuICAgICAgICBpZiAoZS5kYXRhID09PSBtZXNzYWdlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEudmFsdWUgPSBlLmRhdGE7XG4gICAgICBvbk1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTWVzc2FnZSh3cywgZSk7XG4gICAgfTtcbiAgfTtcbiAgaWYgKG9wdGlvbnMuaGVhcnRiZWF0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSA9IERFRkFVTFRfUElOR19NRVNTQUdFLFxuICAgICAgaW50ZXJ2YWwgPSAxZTMsXG4gICAgICBwb25nVGltZW91dCA9IDFlM1xuICAgIH0gPSByZXNvbHZlTmVzdGVkT3B0aW9ucyhvcHRpb25zLmhlYXJ0YmVhdCk7XG4gICAgY29uc3QgeyBwYXVzZSwgcmVzdW1lIH0gPSB1c2VJbnRlcnZhbEZuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzZW5kKG1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKHBvbmdUaW1lb3V0V2FpdCAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcG9uZ1RpbWVvdXRXYWl0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICBleHBsaWNpdGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH0sIHBvbmdUaW1lb3V0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHsgaW1tZWRpYXRlOiBmYWxzZSB9XG4gICAgKTtcbiAgICBoZWFydGJlYXRQYXVzZSA9IHBhdXNlO1xuICAgIGhlYXJ0YmVhdFJlc3VtZSA9IHJlc3VtZTtcbiAgfVxuICBpZiAoYXV0b0Nsb3NlKSB7XG4gICAgaWYgKGlzQ2xpZW50KVxuICAgICAgdXNlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCAoKSA9PiBjbG9zZSgpKTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZShjbG9zZSk7XG4gIH1cbiAgY29uc3Qgb3BlbiA9ICgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50ICYmICFpc1dvcmtlcilcbiAgICAgIHJldHVybjtcbiAgICBjbG9zZSgpO1xuICAgIGV4cGxpY2l0bHlDbG9zZWQgPSBmYWxzZTtcbiAgICByZXRyaWVkID0gMDtcbiAgICBfaW5pdCgpO1xuICB9O1xuICBpZiAoaW1tZWRpYXRlKVxuICAgIG9wZW4oKTtcbiAgd2F0Y2godXJsUmVmLCBvcGVuKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIHN0YXR1cyxcbiAgICBjbG9zZSxcbiAgICBzZW5kLFxuICAgIG9wZW4sXG4gICAgd3M6IHdzUmVmXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVdlYldvcmtlcihhcmcwLCB3b3JrZXJPcHRpb25zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gIH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gIGNvbnN0IGRhdGEgPSByZWYobnVsbCk7XG4gIGNvbnN0IHdvcmtlciA9IHNoYWxsb3dSZWYoKTtcbiAgY29uc3QgcG9zdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCF3b3JrZXIudmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgd29ya2VyLnZhbHVlLnBvc3RNZXNzYWdlKC4uLmFyZ3MpO1xuICB9O1xuICBjb25zdCB0ZXJtaW5hdGUgPSBmdW5jdGlvbiB0ZXJtaW5hdGUyKCkge1xuICAgIGlmICghd29ya2VyLnZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHdvcmtlci52YWx1ZS50ZXJtaW5hdGUoKTtcbiAgfTtcbiAgaWYgKHdpbmRvdykge1xuICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHdvcmtlci52YWx1ZSA9IG5ldyBXb3JrZXIoYXJnMCwgd29ya2VyT3B0aW9ucyk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGFyZzAgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHdvcmtlci52YWx1ZSA9IGFyZzAoKTtcbiAgICBlbHNlXG4gICAgICB3b3JrZXIudmFsdWUgPSBhcmcwO1xuICAgIHdvcmtlci52YWx1ZS5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgZGF0YS52YWx1ZSA9IGUuZGF0YTtcbiAgICB9O1xuICAgIHRyeU9uU2NvcGVEaXNwb3NlKCgpID0+IHtcbiAgICAgIGlmICh3b3JrZXIudmFsdWUpXG4gICAgICAgIHdvcmtlci52YWx1ZS50ZXJtaW5hdGUoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgcG9zdCxcbiAgICB0ZXJtaW5hdGUsXG4gICAgd29ya2VyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGpvYlJ1bm5lcih1c2VyRnVuYykge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBjb25zdCB1c2VyRnVuY0FyZ3MgPSBlLmRhdGFbMF07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1c2VyRnVuYy5hcHBseSh2b2lkIDAsIHVzZXJGdW5jQXJncykpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgcG9zdE1lc3NhZ2UoW1wiU1VDQ0VTU1wiLCByZXN1bHRdKTtcbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHBvc3RNZXNzYWdlKFtcIkVSUk9SXCIsIGVycm9yXSk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlcHNQYXJzZXIoZGVwcywgbG9jYWxEZXBzKSB7XG4gIGlmIChkZXBzLmxlbmd0aCA9PT0gMCAmJiBsb2NhbERlcHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBkZXBzU3RyaW5nID0gZGVwcy5tYXAoKGRlcCkgPT4gYCcke2RlcH0nYCkudG9TdHJpbmcoKTtcbiAgY29uc3QgZGVwc0Z1bmN0aW9uU3RyaW5nID0gbG9jYWxEZXBzLmZpbHRlcigoZGVwKSA9PiB0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpLm1hcCgoZm4pID0+IHtcbiAgICBjb25zdCBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGlmIChzdHIudHJpbSgpLnN0YXJ0c1dpdGgoXCJmdW5jdGlvblwiKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IGZuLm5hbWU7XG4gICAgICByZXR1cm4gYGNvbnN0ICR7bmFtZX0gPSAke3N0cn1gO1xuICAgIH1cbiAgfSkuam9pbihcIjtcIik7XG4gIGNvbnN0IGltcG9ydFN0cmluZyA9IGBpbXBvcnRTY3JpcHRzKCR7ZGVwc1N0cmluZ30pO2A7XG4gIHJldHVybiBgJHtkZXBzU3RyaW5nLnRyaW0oKSA9PT0gXCJcIiA/IFwiXCIgOiBpbXBvcnRTdHJpbmd9ICR7ZGVwc0Z1bmN0aW9uU3RyaW5nfWA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtlckJsb2JVcmwoZm4sIGRlcHMsIGxvY2FsRGVwcykge1xuICBjb25zdCBibG9iQ29kZSA9IGAke2RlcHNQYXJzZXIoZGVwcywgbG9jYWxEZXBzKX07IG9ubWVzc2FnZT0oJHtqb2JSdW5uZXJ9KSgke2ZufSlgO1xuICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2Jsb2JDb2RlXSwgeyB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiIH0pO1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiB1c2VXZWJXb3JrZXJGbihmbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkZXBlbmRlbmNpZXMgPSBbXSxcbiAgICBsb2NhbERlcGVuZGVuY2llcyA9IFtdLFxuICAgIHRpbWVvdXQsXG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd29ya2VyID0gcmVmKCk7XG4gIGNvbnN0IHdvcmtlclN0YXR1cyA9IHJlZihcIlBFTkRJTkdcIik7XG4gIGNvbnN0IHByb21pc2UgPSByZWYoe30pO1xuICBjb25zdCB0aW1lb3V0SWQgPSByZWYoKTtcbiAgY29uc3Qgd29ya2VyVGVybWluYXRlID0gKHN0YXR1cyA9IFwiUEVORElOR1wiKSA9PiB7XG4gICAgaWYgKHdvcmtlci52YWx1ZSAmJiB3b3JrZXIudmFsdWUuX3VybCAmJiB3aW5kb3cpIHtcbiAgICAgIHdvcmtlci52YWx1ZS50ZXJtaW5hdGUoKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyLnZhbHVlLl91cmwpO1xuICAgICAgcHJvbWlzZS52YWx1ZSA9IHt9O1xuICAgICAgd29ya2VyLnZhbHVlID0gdm9pZCAwO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQudmFsdWUpO1xuICAgICAgd29ya2VyU3RhdHVzLnZhbHVlID0gc3RhdHVzO1xuICAgIH1cbiAgfTtcbiAgd29ya2VyVGVybWluYXRlKCk7XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHdvcmtlclRlcm1pbmF0ZSk7XG4gIGNvbnN0IGdlbmVyYXRlV29ya2VyID0gKCkgPT4ge1xuICAgIGNvbnN0IGJsb2JVcmwgPSBjcmVhdGVXb3JrZXJCbG9iVXJsKGZuLCBkZXBlbmRlbmNpZXMsIGxvY2FsRGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBuZXdXb3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVcmwpO1xuICAgIG5ld1dvcmtlci5fdXJsID0gYmxvYlVybDtcbiAgICBuZXdXb3JrZXIub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgIH0sIHJlamVjdCA9ICgpID0+IHtcbiAgICAgIH0gfSA9IHByb21pc2UudmFsdWU7XG4gICAgICBjb25zdCBbc3RhdHVzLCByZXN1bHRdID0gZS5kYXRhO1xuICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcIlNVQ0NFU1NcIjpcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgd29ya2VyVGVybWluYXRlKHN0YXR1cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVqZWN0KHJlc3VsdCk7XG4gICAgICAgICAgd29ya2VyVGVybWluYXRlKFwiRVJST1JcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBuZXdXb3JrZXIub25lcnJvciA9IChlKSA9PiB7XG4gICAgICBjb25zdCB7IHJlamVjdCA9ICgpID0+IHtcbiAgICAgIH0gfSA9IHByb21pc2UudmFsdWU7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZWplY3QoZSk7XG4gICAgICB3b3JrZXJUZXJtaW5hdGUoXCJFUlJPUlwiKTtcbiAgICB9O1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0SWQudmFsdWUgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB3b3JrZXJUZXJtaW5hdGUoXCJUSU1FT1VUX0VYUElSRURcIiksXG4gICAgICAgIHRpbWVvdXRcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXdXb3JrZXI7XG4gIH07XG4gIGNvbnN0IGNhbGxXb3JrZXIgPSAoLi4uZm5BcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcHJvbWlzZS52YWx1ZSA9IHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3RcbiAgICB9O1xuICAgIHdvcmtlci52YWx1ZSAmJiB3b3JrZXIudmFsdWUucG9zdE1lc3NhZ2UoW1suLi5mbkFyZ3NdXSk7XG4gICAgd29ya2VyU3RhdHVzLnZhbHVlID0gXCJSVU5OSU5HXCI7XG4gIH0pO1xuICBjb25zdCB3b3JrZXJGbiA9ICguLi5mbkFyZ3MpID0+IHtcbiAgICBpZiAod29ya2VyU3RhdHVzLnZhbHVlID09PSBcIlJVTk5JTkdcIikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJbdXNlV2ViV29ya2VyRm5dIFlvdSBjYW4gb25seSBydW4gb25lIGluc3RhbmNlIG9mIHRoZSB3b3JrZXIgYXQgYSB0aW1lLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgfVxuICAgIHdvcmtlci52YWx1ZSA9IGdlbmVyYXRlV29ya2VyKCk7XG4gICAgcmV0dXJuIGNhbGxXb3JrZXIoLi4uZm5BcmdzKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZXJGbixcbiAgICB3b3JrZXJTdGF0dXMsXG4gICAgd29ya2VyVGVybWluYXRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd0ZvY3VzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHdpbmRvdyA9IGRlZmF1bHRXaW5kb3cgfSA9IG9wdGlvbnM7XG4gIGlmICghd2luZG93KVxuICAgIHJldHVybiByZWYoZmFsc2UpO1xuICBjb25zdCBmb2N1c2VkID0gcmVmKHdpbmRvdy5kb2N1bWVudC5oYXNGb2N1cygpKTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiYmx1clwiLCAoKSA9PiB7XG4gICAgZm9jdXNlZC52YWx1ZSA9IGZhbHNlO1xuICB9KTtcbiAgdXNlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgIGZvY3VzZWQudmFsdWUgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGZvY3VzZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1Njcm9sbChvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB3aW5kb3cgPSBkZWZhdWx0V2luZG93LCBiZWhhdmlvciA9IFwiYXV0b1wiIH0gPSBvcHRpb25zO1xuICBpZiAoIXdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiByZWYoMCksXG4gICAgICB5OiByZWYoMClcbiAgICB9O1xuICB9XG4gIGNvbnN0IGludGVybmFsWCA9IHJlZih3aW5kb3cuc2Nyb2xsWCk7XG4gIGNvbnN0IGludGVybmFsWSA9IHJlZih3aW5kb3cuc2Nyb2xsWSk7XG4gIGNvbnN0IHggPSBjb21wdXRlZCh7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsWC52YWx1ZTtcbiAgICB9LFxuICAgIHNldCh4Mikge1xuICAgICAgc2Nyb2xsVG8oeyBsZWZ0OiB4MiwgYmVoYXZpb3IgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgeSA9IGNvbXB1dGVkKHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxZLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0KHkyKSB7XG4gICAgICBzY3JvbGxUbyh7IHRvcDogeTIsIGJlaGF2aW9yIH0pO1xuICAgIH1cbiAgfSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgd2luZG93LFxuICAgIFwic2Nyb2xsXCIsXG4gICAgKCkgPT4ge1xuICAgICAgaW50ZXJuYWxYLnZhbHVlID0gd2luZG93LnNjcm9sbFg7XG4gICAgICBpbnRlcm5hbFkudmFsdWUgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9LFxuICAgIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuXG5mdW5jdGlvbiB1c2VXaW5kb3dTaXplKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgd2luZG93ID0gZGVmYXVsdFdpbmRvdyxcbiAgICBpbml0aWFsV2lkdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgaW5pdGlhbEhlaWdodCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBsaXN0ZW5PcmllbnRhdGlvbiA9IHRydWUsXG4gICAgaW5jbHVkZVNjcm9sbGJhciA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdpZHRoID0gcmVmKGluaXRpYWxXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IHJlZihpbml0aWFsSGVpZ2h0KTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIGlmIChpbmNsdWRlU2Nyb2xsYmFyKSB7XG4gICAgICAgIHdpZHRoLnZhbHVlID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodC52YWx1ZSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoLnZhbHVlID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgaGVpZ2h0LnZhbHVlID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB1cGRhdGUoKTtcbiAgdHJ5T25Nb3VudGVkKHVwZGF0ZSk7XG4gIHVzZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGlmIChsaXN0ZW5PcmllbnRhdGlvbikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB1c2VNZWRpYVF1ZXJ5KFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIik7XG4gICAgd2F0Y2gobWF0Y2hlcywgKCkgPT4gdXBkYXRlKCkpO1xuICB9XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdE1hZ2ljS2V5c0FsaWFzTWFwLCBTdG9yYWdlU2VyaWFsaXplcnMsIFRyYW5zaXRpb25QcmVzZXRzLCBjb21wdXRlZEFzeW5jIGFzIGFzeW5jQ29tcHV0ZWQsIGJyZWFrcG9pbnRzQW50RGVzaWduLCBicmVha3BvaW50c0Jvb3RzdHJhcFY1LCBicmVha3BvaW50c01hc3RlckNzcywgYnJlYWtwb2ludHNQcmltZUZsZXgsIGJyZWFrcG9pbnRzUXVhc2FyLCBicmVha3BvaW50c1NlbWF0aWMsIGJyZWFrcG9pbnRzVGFpbHdpbmQsIGJyZWFrcG9pbnRzVnVldGlmeSwgYnJlYWtwb2ludHNWdWV0aWZ5VjIsIGJyZWFrcG9pbnRzVnVldGlmeVYzLCBjbG9uZUZuSlNPTiwgY29tcHV0ZWRBc3luYywgY29tcHV0ZWRJbmplY3QsIGNyZWF0ZUZldGNoLCBjcmVhdGVSZXVzYWJsZVRlbXBsYXRlLCBjcmVhdGVUZW1wbGF0ZVByb21pc2UsIGNyZWF0ZVVucmVmRm4sIGN1c3RvbVN0b3JhZ2VFdmVudE5hbWUsIGRlZmF1bHREb2N1bWVudCwgZGVmYXVsdExvY2F0aW9uLCBkZWZhdWx0TmF2aWdhdG9yLCBkZWZhdWx0V2luZG93LCBleGVjdXRlVHJhbnNpdGlvbiwgZm9ybWF0VGltZUFnbywgZ2V0U1NSSGFuZGxlciwgbWFwR2FtZXBhZFRvWGJveDM2MENvbnRyb2xsZXIsIG9uQ2xpY2tPdXRzaWRlLCBvbktleURvd24sIG9uS2V5UHJlc3NlZCwgb25LZXlTdHJva2UsIG9uS2V5VXAsIG9uTG9uZ1ByZXNzLCBvblN0YXJ0VHlwaW5nLCBzZXRTU1JIYW5kbGVyLCB0ZW1wbGF0ZVJlZiwgdW5yZWZFbGVtZW50LCB1c2VBY3RpdmVFbGVtZW50LCB1c2VBbmltYXRlLCB1c2VBc3luY1F1ZXVlLCB1c2VBc3luY1N0YXRlLCB1c2VCYXNlNjQsIHVzZUJhdHRlcnksIHVzZUJsdWV0b290aCwgdXNlQnJlYWtwb2ludHMsIHVzZUJyb2FkY2FzdENoYW5uZWwsIHVzZUJyb3dzZXJMb2NhdGlvbiwgdXNlQ2FjaGVkLCB1c2VDbGlwYm9hcmQsIHVzZUNsaXBib2FyZEl0ZW1zLCB1c2VDbG9uZWQsIHVzZUNvbG9yTW9kZSwgdXNlQ29uZmlybURpYWxvZywgdXNlQ3NzVmFyLCB1c2VDdXJyZW50RWxlbWVudCwgdXNlQ3ljbGVMaXN0LCB1c2VEYXJrLCB1c2VEZWJvdW5jZWRSZWZIaXN0b3J5LCB1c2VEZXZpY2VNb3Rpb24sIHVzZURldmljZU9yaWVudGF0aW9uLCB1c2VEZXZpY2VQaXhlbFJhdGlvLCB1c2VEZXZpY2VzTGlzdCwgdXNlRGlzcGxheU1lZGlhLCB1c2VEb2N1bWVudFZpc2liaWxpdHksIHVzZURyYWdnYWJsZSwgdXNlRHJvcFpvbmUsIHVzZUVsZW1lbnRCb3VuZGluZywgdXNlRWxlbWVudEJ5UG9pbnQsIHVzZUVsZW1lbnRIb3ZlciwgdXNlRWxlbWVudFNpemUsIHVzZUVsZW1lbnRWaXNpYmlsaXR5LCB1c2VFdmVudEJ1cywgdXNlRXZlbnRMaXN0ZW5lciwgdXNlRXZlbnRTb3VyY2UsIHVzZUV5ZURyb3BwZXIsIHVzZUZhdmljb24sIHVzZUZldGNoLCB1c2VGaWxlRGlhbG9nLCB1c2VGaWxlU3lzdGVtQWNjZXNzLCB1c2VGb2N1cywgdXNlRm9jdXNXaXRoaW4sIHVzZUZwcywgdXNlRnVsbHNjcmVlbiwgdXNlR2FtZXBhZCwgdXNlR2VvbG9jYXRpb24sIHVzZUlkbGUsIHVzZUltYWdlLCB1c2VJbmZpbml0ZVNjcm9sbCwgdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIHVzZUtleU1vZGlmaWVyLCB1c2VMb2NhbFN0b3JhZ2UsIHVzZU1hZ2ljS2V5cywgdXNlTWFudWFsUmVmSGlzdG9yeSwgdXNlTWVkaWFDb250cm9scywgdXNlTWVkaWFRdWVyeSwgdXNlTWVtb2l6ZSwgdXNlTWVtb3J5LCB1c2VNb3VudGVkLCB1c2VNb3VzZSwgdXNlTW91c2VJbkVsZW1lbnQsIHVzZU1vdXNlUHJlc3NlZCwgdXNlTXV0YXRpb25PYnNlcnZlciwgdXNlTmF2aWdhdG9yTGFuZ3VhZ2UsIHVzZU5ldHdvcmssIHVzZU5vdywgdXNlT2JqZWN0VXJsLCB1c2VPZmZzZXRQYWdpbmF0aW9uLCB1c2VPbmxpbmUsIHVzZVBhZ2VMZWF2ZSwgdXNlUGFyYWxsYXgsIHVzZVBhcmVudEVsZW1lbnQsIHVzZVBlcmZvcm1hbmNlT2JzZXJ2ZXIsIHVzZVBlcm1pc3Npb24sIHVzZVBvaW50ZXIsIHVzZVBvaW50ZXJMb2NrLCB1c2VQb2ludGVyU3dpcGUsIHVzZVByZWZlcnJlZENvbG9yU2NoZW1lLCB1c2VQcmVmZXJyZWRDb250cmFzdCwgdXNlUHJlZmVycmVkRGFyaywgdXNlUHJlZmVycmVkTGFuZ3VhZ2VzLCB1c2VQcmVmZXJyZWRSZWR1Y2VkTW90aW9uLCB1c2VQcmV2aW91cywgdXNlUmFmRm4sIHVzZVJlZkhpc3RvcnksIHVzZVJlc2l6ZU9ic2VydmVyLCB1c2VTY3JlZW5PcmllbnRhdGlvbiwgdXNlU2NyZWVuU2FmZUFyZWEsIHVzZVNjcmlwdFRhZywgdXNlU2Nyb2xsLCB1c2VTY3JvbGxMb2NrLCB1c2VTZXNzaW9uU3RvcmFnZSwgdXNlU2hhcmUsIHVzZVNvcnRlZCwgdXNlU3BlZWNoUmVjb2duaXRpb24sIHVzZVNwZWVjaFN5bnRoZXNpcywgdXNlU3RlcHBlciwgdXNlU3RvcmFnZSwgdXNlU3RvcmFnZUFzeW5jLCB1c2VTdHlsZVRhZywgdXNlU3VwcG9ydGVkLCB1c2VTd2lwZSwgdXNlVGVtcGxhdGVSZWZzTGlzdCwgdXNlVGV4dERpcmVjdGlvbiwgdXNlVGV4dFNlbGVjdGlvbiwgdXNlVGV4dGFyZWFBdXRvc2l6ZSwgdXNlVGhyb3R0bGVkUmVmSGlzdG9yeSwgdXNlVGltZUFnbywgdXNlVGltZW91dFBvbGwsIHVzZVRpbWVzdGFtcCwgdXNlVGl0bGUsIHVzZVRyYW5zaXRpb24sIHVzZVVybFNlYXJjaFBhcmFtcywgdXNlVXNlck1lZGlhLCB1c2VWTW9kZWwsIHVzZVZNb2RlbHMsIHVzZVZpYnJhdGUsIHVzZVZpcnR1YWxMaXN0LCB1c2VXYWtlTG9jaywgdXNlV2ViTm90aWZpY2F0aW9uLCB1c2VXZWJTb2NrZXQsIHVzZVdlYldvcmtlciwgdXNlV2ViV29ya2VyRm4sIHVzZVdpbmRvd0ZvY3VzLCB1c2VXaW5kb3dTY3JvbGwsIHVzZVdpbmRvd1NpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vueuse/core/index.mjs\n"));

/***/ }),

/***/ "./node_modules/@vueuse/core/node_modules/vue-demi/lib/index.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@vueuse/core/node_modules/vue-demi/lib/index.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vue: function() { return /* reexport module object */ vue__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   Vue2: function() { return /* binding */ Vue2; },\n/* harmony export */   del: function() { return /* binding */ del; },\n/* harmony export */   install: function() { return /* binding */ install; },\n/* harmony export */   isVue2: function() { return /* binding */ isVue2; },\n/* harmony export */   isVue3: function() { return /* binding */ isVue3; },\n/* harmony export */   set: function() { return /* binding */ set; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in vue__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"set\",\"del\",\"Vue\",\"Vue2\",\"isVue2\",\"isVue3\",\"install\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return vue__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nfunction set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nfunction del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZXVzZS9jb3JlL25vZGVfbW9kdWxlcy92dWUtZGVtaS9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQjtBQU9sQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHZ1ZXVzZS9jb3JlL25vZGVfbW9kdWxlcy92dWUtZGVtaS9saWIvaW5kZXgubWpzP2M3YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVnVlIGZyb20gJ3Z1ZSdcblxudmFyIGlzVnVlMiA9IGZhbHNlXG52YXIgaXNWdWUzID0gdHJ1ZVxudmFyIFZ1ZTIgPSB1bmRlZmluZWRcblxuZnVuY3Rpb24gaW5zdGFsbCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSlcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKVxuICAgIHJldHVybiB2YWxcbiAgfVxuICB0YXJnZXRba2V5XSA9IHZhbFxuICByZXR1cm4gdmFsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWwodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKVxuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XVxufVxuXG5leHBvcnQgKiBmcm9tICd2dWUnXG5leHBvcnQge1xuICBWdWUsXG4gIFZ1ZTIsXG4gIGlzVnVlMixcbiAgaXNWdWUzLFxuICBpbnN0YWxsLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vueuse/core/node_modules/vue-demi/lib/index.mjs\n"));

/***/ }),

/***/ "./node_modules/@vueuse/shared/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@vueuse/shared/index.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   autoResetRef: function() { return /* binding */ refAutoReset; },\n/* harmony export */   bypassFilter: function() { return /* binding */ bypassFilter; },\n/* harmony export */   camelize: function() { return /* binding */ camelize; },\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   computedEager: function() { return /* binding */ computedEager; },\n/* harmony export */   computedWithControl: function() { return /* binding */ computedWithControl; },\n/* harmony export */   containsProp: function() { return /* binding */ containsProp; },\n/* harmony export */   controlledComputed: function() { return /* binding */ computedWithControl; },\n/* harmony export */   controlledRef: function() { return /* binding */ controlledRef; },\n/* harmony export */   createEventHook: function() { return /* binding */ createEventHook; },\n/* harmony export */   createFilterWrapper: function() { return /* binding */ createFilterWrapper; },\n/* harmony export */   createGlobalState: function() { return /* binding */ createGlobalState; },\n/* harmony export */   createInjectionState: function() { return /* binding */ createInjectionState; },\n/* harmony export */   createReactiveFn: function() { return /* binding */ reactify; },\n/* harmony export */   createSharedComposable: function() { return /* binding */ createSharedComposable; },\n/* harmony export */   createSingletonPromise: function() { return /* binding */ createSingletonPromise; },\n/* harmony export */   debounceFilter: function() { return /* binding */ debounceFilter; },\n/* harmony export */   debouncedRef: function() { return /* binding */ refDebounced; },\n/* harmony export */   debouncedWatch: function() { return /* binding */ watchDebounced; },\n/* harmony export */   directiveHooks: function() { return /* binding */ directiveHooks; },\n/* harmony export */   eagerComputed: function() { return /* binding */ computedEager; },\n/* harmony export */   extendRef: function() { return /* binding */ extendRef; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   get: function() { return /* binding */ get; },\n/* harmony export */   getLifeCycleTarget: function() { return /* binding */ getLifeCycleTarget; },\n/* harmony export */   hasOwn: function() { return /* binding */ hasOwn; },\n/* harmony export */   hyphenate: function() { return /* binding */ hyphenate; },\n/* harmony export */   identity: function() { return /* binding */ identity; },\n/* harmony export */   ignorableWatch: function() { return /* binding */ watchIgnorable; },\n/* harmony export */   increaseWithUnit: function() { return /* binding */ increaseWithUnit; },\n/* harmony export */   injectLocal: function() { return /* binding */ injectLocal; },\n/* harmony export */   invoke: function() { return /* binding */ invoke; },\n/* harmony export */   isClient: function() { return /* binding */ isClient; },\n/* harmony export */   isDef: function() { return /* binding */ isDef; },\n/* harmony export */   isDefined: function() { return /* binding */ isDefined; },\n/* harmony export */   isIOS: function() { return /* binding */ isIOS; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isWorker: function() { return /* binding */ isWorker; },\n/* harmony export */   makeDestructurable: function() { return /* binding */ makeDestructurable; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   normalizeDate: function() { return /* binding */ normalizeDate; },\n/* harmony export */   notNullish: function() { return /* binding */ notNullish; },\n/* harmony export */   now: function() { return /* binding */ now; },\n/* harmony export */   objectEntries: function() { return /* binding */ objectEntries; },\n/* harmony export */   objectOmit: function() { return /* binding */ objectOmit; },\n/* harmony export */   objectPick: function() { return /* binding */ objectPick; },\n/* harmony export */   pausableFilter: function() { return /* binding */ pausableFilter; },\n/* harmony export */   pausableWatch: function() { return /* binding */ watchPausable; },\n/* harmony export */   promiseTimeout: function() { return /* binding */ promiseTimeout; },\n/* harmony export */   provideLocal: function() { return /* binding */ provideLocal; },\n/* harmony export */   rand: function() { return /* binding */ rand; },\n/* harmony export */   reactify: function() { return /* binding */ reactify; },\n/* harmony export */   reactifyObject: function() { return /* binding */ reactifyObject; },\n/* harmony export */   reactiveComputed: function() { return /* binding */ reactiveComputed; },\n/* harmony export */   reactiveOmit: function() { return /* binding */ reactiveOmit; },\n/* harmony export */   reactivePick: function() { return /* binding */ reactivePick; },\n/* harmony export */   refAutoReset: function() { return /* binding */ refAutoReset; },\n/* harmony export */   refDebounced: function() { return /* binding */ refDebounced; },\n/* harmony export */   refDefault: function() { return /* binding */ refDefault; },\n/* harmony export */   refThrottled: function() { return /* binding */ refThrottled; },\n/* harmony export */   refWithControl: function() { return /* binding */ refWithControl; },\n/* harmony export */   resolveRef: function() { return /* binding */ resolveRef; },\n/* harmony export */   resolveUnref: function() { return /* binding */ resolveUnref; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   syncRef: function() { return /* binding */ syncRef; },\n/* harmony export */   syncRefs: function() { return /* binding */ syncRefs; },\n/* harmony export */   throttleFilter: function() { return /* binding */ throttleFilter; },\n/* harmony export */   throttledRef: function() { return /* binding */ refThrottled; },\n/* harmony export */   throttledWatch: function() { return /* binding */ watchThrottled; },\n/* harmony export */   timestamp: function() { return /* binding */ timestamp; },\n/* harmony export */   toReactive: function() { return /* binding */ toReactive; },\n/* harmony export */   toRef: function() { return /* binding */ toRef; },\n/* harmony export */   toRefs: function() { return /* binding */ toRefs; },\n/* harmony export */   toValue: function() { return /* binding */ toValue; },\n/* harmony export */   tryOnBeforeMount: function() { return /* binding */ tryOnBeforeMount; },\n/* harmony export */   tryOnBeforeUnmount: function() { return /* binding */ tryOnBeforeUnmount; },\n/* harmony export */   tryOnMounted: function() { return /* binding */ tryOnMounted; },\n/* harmony export */   tryOnScopeDispose: function() { return /* binding */ tryOnScopeDispose; },\n/* harmony export */   tryOnUnmounted: function() { return /* binding */ tryOnUnmounted; },\n/* harmony export */   until: function() { return /* binding */ until; },\n/* harmony export */   useArrayDifference: function() { return /* binding */ useArrayDifference; },\n/* harmony export */   useArrayEvery: function() { return /* binding */ useArrayEvery; },\n/* harmony export */   useArrayFilter: function() { return /* binding */ useArrayFilter; },\n/* harmony export */   useArrayFind: function() { return /* binding */ useArrayFind; },\n/* harmony export */   useArrayFindIndex: function() { return /* binding */ useArrayFindIndex; },\n/* harmony export */   useArrayFindLast: function() { return /* binding */ useArrayFindLast; },\n/* harmony export */   useArrayIncludes: function() { return /* binding */ useArrayIncludes; },\n/* harmony export */   useArrayJoin: function() { return /* binding */ useArrayJoin; },\n/* harmony export */   useArrayMap: function() { return /* binding */ useArrayMap; },\n/* harmony export */   useArrayReduce: function() { return /* binding */ useArrayReduce; },\n/* harmony export */   useArraySome: function() { return /* binding */ useArraySome; },\n/* harmony export */   useArrayUnique: function() { return /* binding */ useArrayUnique; },\n/* harmony export */   useCounter: function() { return /* binding */ useCounter; },\n/* harmony export */   useDateFormat: function() { return /* binding */ useDateFormat; },\n/* harmony export */   useDebounce: function() { return /* binding */ refDebounced; },\n/* harmony export */   useDebounceFn: function() { return /* binding */ useDebounceFn; },\n/* harmony export */   useInterval: function() { return /* binding */ useInterval; },\n/* harmony export */   useIntervalFn: function() { return /* binding */ useIntervalFn; },\n/* harmony export */   useLastChanged: function() { return /* binding */ useLastChanged; },\n/* harmony export */   useThrottle: function() { return /* binding */ refThrottled; },\n/* harmony export */   useThrottleFn: function() { return /* binding */ useThrottleFn; },\n/* harmony export */   useTimeout: function() { return /* binding */ useTimeout; },\n/* harmony export */   useTimeoutFn: function() { return /* binding */ useTimeoutFn; },\n/* harmony export */   useToNumber: function() { return /* binding */ useToNumber; },\n/* harmony export */   useToString: function() { return /* binding */ useToString; },\n/* harmony export */   useToggle: function() { return /* binding */ useToggle; },\n/* harmony export */   watchArray: function() { return /* binding */ watchArray; },\n/* harmony export */   watchAtMost: function() { return /* binding */ watchAtMost; },\n/* harmony export */   watchDebounced: function() { return /* binding */ watchDebounced; },\n/* harmony export */   watchDeep: function() { return /* binding */ watchDeep; },\n/* harmony export */   watchIgnorable: function() { return /* binding */ watchIgnorable; },\n/* harmony export */   watchImmediate: function() { return /* binding */ watchImmediate; },\n/* harmony export */   watchOnce: function() { return /* binding */ watchOnce; },\n/* harmony export */   watchPausable: function() { return /* binding */ watchPausable; },\n/* harmony export */   watchThrottled: function() { return /* binding */ watchThrottled; },\n/* harmony export */   watchTriggerable: function() { return /* binding */ watchTriggerable; },\n/* harmony export */   watchWithFilter: function() { return /* binding */ watchWithFilter; },\n/* harmony export */   whenever: function() { return /* binding */ whenever; }\n/* harmony export */ });\n/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ \"./node_modules/@vueuse/shared/node_modules/vue-demi/lib/index.mjs\");\n\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.shallowRef)();\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.readonly)(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.customRef)((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)()) {\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose)(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.effectScope)(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.provide)(key, value);\n};\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.inject)(...args);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.effectScope)(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue3 && !vue_demi__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"2.7.\")) {\n    if (true)\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(obj);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(obj)[key];\n}\n\nfunction isDefined(v) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref : toValue;\n  return function(...args) {\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(objectRef))\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.reactive)(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(objectRef.value[p]) && !(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.reactive)(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.readonly)(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue3 ? \"mounted\" : \"inserted\",\n  updated: vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRef)(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.readonly)((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.customRef)(() => ({ get: r, set: noop }))) : (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.customRef)((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.customRef)((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue2) {\n      (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.set)(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(objectRef))\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.toRefs)(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.customRef)(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount)(fn, target);\n  else if (sync)\n    fn();\n  else\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onMounted)(fn, target);\n  else if (sync)\n    fn();\n  else\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(initialValue);\n  const count = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(interval) || typeof interval === \"function\") {\n    const stopWatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)((_a = options.initialValue) != null ? _a : null);\n  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.readonly)(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(initialValue);\n  const _value = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    const syncCounter = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(source, (...args) => {\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReactive)(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZXVzZS9zaGFyZWQvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvVzs7QUFFcFc7QUFDQTtBQUNBLGlCQUFpQixvREFBVTtBQUMzQixFQUFFLHFEQUFXO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLGtEQUFRO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwrQ0FBSyxtQkFBbUIsZUFBZTtBQUN6QztBQUNBO0FBQ0EsaUJBQWlCLG1EQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSx5REFBZTtBQUNyQixJQUFJLHdEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaURBQU87QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERB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SztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLCtDQUFLO0FBQ3BCLElBQUksa0RBQVE7QUFDWjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwrQ0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0RBQVE7QUFDbEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaTBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdnVldXNlL3NoYXJlZC9pbmRleC5tanM/OTU5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaGFsbG93UmVmLCB3YXRjaEVmZmVjdCwgcmVhZG9ubHksIHJlZiwgd2F0Y2gsIGN1c3RvbVJlZiwgZ2V0Q3VycmVudFNjb3BlLCBvblNjb3BlRGlzcG9zZSwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgcHJvdmlkZSwgaW5qZWN0LCBpc1Z1ZTMsIHZlcnNpb24sIGlzUmVmLCB1bnJlZiwgY29tcHV0ZWQsIHJlYWN0aXZlLCB0b1JlZnMgYXMgdG9SZWZzJDEsIHRvUmVmIGFzIHRvUmVmJDEsIGlzVnVlMiwgc2V0IGFzIHNldCQxLCBvbkJlZm9yZU1vdW50LCBuZXh0VGljaywgb25CZWZvcmVVbm1vdW50LCBvbk1vdW50ZWQsIG9uVW5tb3VudGVkLCBpc1JlYWN0aXZlIH0gZnJvbSAndnVlLWRlbWknO1xuXG5mdW5jdGlvbiBjb21wdXRlZEVhZ2VyKGZuLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzdWx0ID0gc2hhbGxvd1JlZigpO1xuICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgcmVzdWx0LnZhbHVlID0gZm4oKTtcbiAgfSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZmx1c2g6IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmx1c2gpICE9IG51bGwgPyBfYSA6IFwic3luY1wiXG4gIH0pO1xuICByZXR1cm4gcmVhZG9ubHkocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZWRXaXRoQ29udHJvbChzb3VyY2UsIGZuKSB7XG4gIGxldCB2ID0gdm9pZCAwO1xuICBsZXQgdHJhY2s7XG4gIGxldCB0cmlnZ2VyO1xuICBjb25zdCBkaXJ0eSA9IHJlZih0cnVlKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIGRpcnR5LnZhbHVlID0gdHJ1ZTtcbiAgICB0cmlnZ2VyKCk7XG4gIH07XG4gIHdhdGNoKHNvdXJjZSwgdXBkYXRlLCB7IGZsdXNoOiBcInN5bmNcIiB9KTtcbiAgY29uc3QgZ2V0ID0gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyBmbiA6IGZuLmdldDtcbiAgY29uc3Qgc2V0ID0gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBmbi5zZXQ7XG4gIGNvbnN0IHJlc3VsdCA9IGN1c3RvbVJlZigoX3RyYWNrLCBfdHJpZ2dlcikgPT4ge1xuICAgIHRyYWNrID0gX3RyYWNrO1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcjtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAoZGlydHkudmFsdWUpIHtcbiAgICAgICAgICB2ID0gZ2V0KCk7XG4gICAgICAgICAgZGlydHkudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0sXG4gICAgICBzZXQodjIpIHtcbiAgICAgICAgc2V0ID09IG51bGwgPyB2b2lkIDAgOiBzZXQodjIpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShyZXN1bHQpKVxuICAgIHJlc3VsdC50cmlnZ2VyID0gdXBkYXRlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB0cnlPblNjb3BlRGlzcG9zZShmbikge1xuICBpZiAoZ2V0Q3VycmVudFNjb3BlKCkpIHtcbiAgICBvblNjb3BlRGlzcG9zZShmbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudEhvb2soKSB7XG4gIGNvbnN0IGZucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG9mZiA9IChmbikgPT4ge1xuICAgIGZucy5kZWxldGUoZm4pO1xuICB9O1xuICBjb25zdCBvbiA9IChmbikgPT4ge1xuICAgIGZucy5hZGQoZm4pO1xuICAgIGNvbnN0IG9mZkZuID0gKCkgPT4gb2ZmKGZuKTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZShvZmZGbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZjogb2ZmRm5cbiAgICB9O1xuICB9O1xuICBjb25zdCB0cmlnZ2VyID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShmbnMpLm1hcCgoZm4pID0+IGZuKC4uLmFyZ3MpKSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIHRyaWdnZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlR2xvYmFsU3RhdGUoc3RhdGVGYWN0b3J5KSB7XG4gIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGNvbnN0IHNjb3BlID0gZWZmZWN0U2NvcGUodHJ1ZSk7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXRlID0gc2NvcGUucnVuKCgpID0+IHN0YXRlRmFjdG9yeSguLi5hcmdzKSk7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuY29uc3QgbG9jYWxQcm92aWRlZFN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IHByb3ZpZGVMb2NhbCA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgaW5zdGFuY2UgPSAoX2EgPSBnZXRDdXJyZW50SW5zdGFuY2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnByb3h5O1xuICBpZiAoaW5zdGFuY2UgPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm92aWRlTG9jYWwgbXVzdCBiZSBjYWxsZWQgaW4gc2V0dXBcIik7XG4gIGlmICghbG9jYWxQcm92aWRlZFN0YXRlTWFwLmhhcyhpbnN0YW5jZSkpXG4gICAgbG9jYWxQcm92aWRlZFN0YXRlTWFwLnNldChpbnN0YW5jZSwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICBjb25zdCBsb2NhbFByb3ZpZGVkU3RhdGUgPSBsb2NhbFByb3ZpZGVkU3RhdGVNYXAuZ2V0KGluc3RhbmNlKTtcbiAgbG9jYWxQcm92aWRlZFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgcHJvdmlkZShrZXksIHZhbHVlKTtcbn07XG5cbmNvbnN0IGluamVjdExvY2FsID0gKC4uLmFyZ3MpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICBjb25zdCBpbnN0YW5jZSA9IChfYSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EucHJveHk7XG4gIGlmIChpbnN0YW5jZSA9PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImluamVjdExvY2FsIG11c3QgYmUgY2FsbGVkIGluIHNldHVwXCIpO1xuICBpZiAobG9jYWxQcm92aWRlZFN0YXRlTWFwLmhhcyhpbnN0YW5jZSkgJiYga2V5IGluIGxvY2FsUHJvdmlkZWRTdGF0ZU1hcC5nZXQoaW5zdGFuY2UpKVxuICAgIHJldHVybiBsb2NhbFByb3ZpZGVkU3RhdGVNYXAuZ2V0KGluc3RhbmNlKVtrZXldO1xuICByZXR1cm4gaW5qZWN0KC4uLmFyZ3MpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0aW9uU3RhdGUoY29tcG9zYWJsZSwgb3B0aW9ucykge1xuICBjb25zdCBrZXkgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbmplY3Rpb25LZXkpIHx8IFN5bWJvbChjb21wb3NhYmxlLm5hbWUgfHwgXCJJbmplY3Rpb25TdGF0ZVwiKTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gIGNvbnN0IHVzZVByb3ZpZGluZ1N0YXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGNvbXBvc2FibGUoLi4uYXJncyk7XG4gICAgcHJvdmlkZUxvY2FsKGtleSwgc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbiAgY29uc3QgdXNlSW5qZWN0ZWRTdGF0ZSA9ICgpID0+IGluamVjdExvY2FsKGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgcmV0dXJuIFt1c2VQcm92aWRpbmdTdGF0ZSwgdXNlSW5qZWN0ZWRTdGF0ZV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXJlZENvbXBvc2FibGUoY29tcG9zYWJsZSkge1xuICBsZXQgc3Vic2NyaWJlcnMgPSAwO1xuICBsZXQgc3RhdGU7XG4gIGxldCBzY29wZTtcbiAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcbiAgICBzdWJzY3JpYmVycyAtPSAxO1xuICAgIGlmIChzY29wZSAmJiBzdWJzY3JpYmVycyA8PSAwKSB7XG4gICAgICBzY29wZS5zdG9wKCk7XG4gICAgICBzdGF0ZSA9IHZvaWQgMDtcbiAgICAgIHNjb3BlID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgc3Vic2NyaWJlcnMgKz0gMTtcbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICBzY29wZSA9IGVmZmVjdFNjb3BlKHRydWUpO1xuICAgICAgc3RhdGUgPSBzY29wZS5ydW4oKCkgPT4gY29tcG9zYWJsZSguLi5hcmdzKSk7XG4gICAgfVxuICAgIHRyeU9uU2NvcGVEaXNwb3NlKGRpc3Bvc2UpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kUmVmKHJlZiwgZXh0ZW5kLCB7IGVudW1lcmFibGUgPSBmYWxzZSwgdW53cmFwID0gdHJ1ZSB9ID0ge30pIHtcbiAgaWYgKCFpc1Z1ZTMgJiYgIXZlcnNpb24uc3RhcnRzV2l0aChcIjIuNy5cIikpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1Z1ZVVzZV0gZXh0ZW5kUmVmIG9ubHkgd29ya3MgaW4gVnVlIDIuNyBvciBhYm92ZS5cIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGV4dGVuZCkpIHtcbiAgICBpZiAoa2V5ID09PSBcInZhbHVlXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNSZWYodmFsdWUpICYmIHVud3JhcCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZiwga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgdmFsdWUudmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZiwga2V5LCB7IHZhbHVlLCBlbnVtZXJhYmxlIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBrZXkpIHtcbiAgaWYgKGtleSA9PSBudWxsKVxuICAgIHJldHVybiB1bnJlZihvYmopO1xuICByZXR1cm4gdW5yZWYob2JqKVtrZXldO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodikge1xuICByZXR1cm4gdW5yZWYodikgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFrZURlc3RydWN0dXJhYmxlKG9iaiwgYXJyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgY2xvbmUgPSB7IC4uLm9iaiB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6ICgpID0+ICh7XG4gICAgICAgICAgICB2YWx1ZTogYXJyW2luZGV4KytdLFxuICAgICAgICAgICAgZG9uZTogaW5kZXggPiBhcnIubGVuZ3RoXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oWy4uLmFycl0sIG9iaik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9WYWx1ZShyKSB7XG4gIHJldHVybiB0eXBlb2YgciA9PT0gXCJmdW5jdGlvblwiID8gcigpIDogdW5yZWYocik7XG59XG5jb25zdCByZXNvbHZlVW5yZWYgPSB0b1ZhbHVlO1xuXG5mdW5jdGlvbiByZWFjdGlmeShmbiwgb3B0aW9ucykge1xuICBjb25zdCB1bnJlZkZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29tcHV0ZWRHZXR0ZXIpID09PSBmYWxzZSA/IHVucmVmIDogdG9WYWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gZm4uYXBwbHkodGhpcywgYXJncy5tYXAoKGkpID0+IHVucmVmRm4oaSkpKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWN0aWZ5T2JqZWN0KG9iaiwgb3B0aW9uc09yS2V5cyA9IHt9KSB7XG4gIGxldCBrZXlzID0gW107XG4gIGxldCBvcHRpb25zO1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zT3JLZXlzKSkge1xuICAgIGtleXMgPSBvcHRpb25zT3JLZXlzO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zT3JLZXlzO1xuICAgIGNvbnN0IHsgaW5jbHVkZU93blByb3BlcnRpZXMgPSB0cnVlIH0gPSBvcHRpb25zT3JLZXlzO1xuICAgIGtleXMucHVzaCguLi5PYmplY3Qua2V5cyhvYmopKTtcbiAgICBpZiAoaW5jbHVkZU93blByb3BlcnRpZXMpXG4gICAgICBrZXlzLnB1c2goLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBrZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAga2V5LFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlYWN0aWZ5KHZhbHVlLmJpbmQob2JqKSwgb3B0aW9ucykgOiB2YWx1ZVxuICAgICAgXTtcbiAgICB9KVxuICApO1xufVxuXG5mdW5jdGlvbiB0b1JlYWN0aXZlKG9iamVjdFJlZikge1xuICBpZiAoIWlzUmVmKG9iamVjdFJlZikpXG4gICAgcmV0dXJuIHJlYWN0aXZlKG9iamVjdFJlZik7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0KF8sIHAsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gdW5yZWYoUmVmbGVjdC5nZXQob2JqZWN0UmVmLnZhbHVlLCBwLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgc2V0KF8sIHAsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNSZWYob2JqZWN0UmVmLnZhbHVlW3BdKSAmJiAhaXNSZWYodmFsdWUpKVxuICAgICAgICBvYmplY3RSZWYudmFsdWVbcF0udmFsdWUgPSB2YWx1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgb2JqZWN0UmVmLnZhbHVlW3BdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KF8sIHApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KG9iamVjdFJlZi52YWx1ZSwgcCk7XG4gICAgfSxcbiAgICBoYXMoXywgcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKG9iamVjdFJlZi52YWx1ZSwgcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdFJlZi52YWx1ZSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlYWN0aXZlKHByb3h5KTtcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVDb21wdXRlZChmbikge1xuICByZXR1cm4gdG9SZWFjdGl2ZShjb21wdXRlZChmbikpO1xufVxuXG5mdW5jdGlvbiByZWFjdGl2ZU9taXQob2JqLCAuLi5rZXlzKSB7XG4gIGNvbnN0IGZsYXRLZXlzID0ga2V5cy5mbGF0KCk7XG4gIGNvbnN0IHByZWRpY2F0ZSA9IGZsYXRLZXlzWzBdO1xuICByZXR1cm4gcmVhY3RpdmVDb21wdXRlZCgoKSA9PiB0eXBlb2YgcHJlZGljYXRlID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModG9SZWZzJDEob2JqKSkuZmlsdGVyKChbaywgdl0pID0+ICFwcmVkaWNhdGUodG9WYWx1ZSh2KSwgaykpKSA6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0b1JlZnMkMShvYmopKS5maWx0ZXIoKGUpID0+ICFmbGF0S2V5cy5pbmNsdWRlcyhlWzBdKSkpKTtcbn1cblxuY29uc3QgaXNDbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGlzV29ya2VyID0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbFRoaXMgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZTtcbmNvbnN0IGlzRGVmID0gKHZhbCkgPT4gdHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IG5vdE51bGxpc2ggPSAodmFsKSA9PiB2YWwgIT0gbnVsbDtcbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIC4uLmluZm9zKSA9PiB7XG4gIGlmICghY29uZGl0aW9uKVxuICAgIGNvbnNvbGUud2FybiguLi5pbmZvcyk7XG59O1xuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0b1N0cmluZy5jYWxsKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5jb25zdCBub3cgPSAoKSA9PiBEYXRlLm5vdygpO1xuY29uc3QgdGltZXN0YW1wID0gKCkgPT4gK0RhdGUubm93KCk7XG5jb25zdCBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3QgcmFuZCA9IChtaW4sIG1heCkgPT4ge1xuICBtaW4gPSBNYXRoLmNlaWwobWluKTtcbiAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn07XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0lPUyA9IC8qIEBfX1BVUkVfXyAqLyBnZXRJc0lPUygpO1xuZnVuY3Rpb24gZ2V0SXNJT1MoKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiBpc0NsaWVudCAmJiAoKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXNlckFnZW50KSAmJiAoL2lQKD86YWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICgoX2IgPSB3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5tYXhUb3VjaFBvaW50cykgPiAyICYmIC9pUGFkfE1hY2ludG9zaC8udGVzdCh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcldyYXBwZXIoZmlsdGVyLCBmbikge1xuICBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGZpbHRlcigoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKSwgeyBmbiwgdGhpc0FyZzogdGhpcywgYXJncyB9KSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuY29uc3QgYnlwYXNzRmlsdGVyID0gKGludm9rZSkgPT4ge1xuICByZXR1cm4gaW52b2tlKCk7XG59O1xuZnVuY3Rpb24gZGVib3VuY2VGaWx0ZXIobXMsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgdGltZXI7XG4gIGxldCBtYXhUaW1lcjtcbiAgbGV0IGxhc3RSZWplY3RvciA9IG5vb3A7XG4gIGNvbnN0IF9jbGVhclRpbWVvdXQgPSAodGltZXIyKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyMik7XG4gICAgbGFzdFJlamVjdG9yKCk7XG4gICAgbGFzdFJlamVjdG9yID0gbm9vcDtcbiAgfTtcbiAgY29uc3QgZmlsdGVyID0gKGludm9rZSkgPT4ge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdG9WYWx1ZShtcyk7XG4gICAgY29uc3QgbWF4RHVyYXRpb24gPSB0b1ZhbHVlKG9wdGlvbnMubWF4V2FpdCk7XG4gICAgaWYgKHRpbWVyKVxuICAgICAgX2NsZWFyVGltZW91dCh0aW1lcik7XG4gICAgaWYgKGR1cmF0aW9uIDw9IDAgfHwgbWF4RHVyYXRpb24gIT09IHZvaWQgMCAmJiBtYXhEdXJhdGlvbiA8PSAwKSB7XG4gICAgICBpZiAobWF4VGltZXIpIHtcbiAgICAgICAgX2NsZWFyVGltZW91dChtYXhUaW1lcik7XG4gICAgICAgIG1heFRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW52b2tlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGFzdFJlamVjdG9yID0gb3B0aW9ucy5yZWplY3RPbkNhbmNlbCA/IHJlamVjdCA6IHJlc29sdmU7XG4gICAgICBpZiAobWF4RHVyYXRpb24gJiYgIW1heFRpbWVyKSB7XG4gICAgICAgIG1heFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRpbWVyKVxuICAgICAgICAgICAgX2NsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgbWF4VGltZXIgPSBudWxsO1xuICAgICAgICAgIHJlc29sdmUoaW52b2tlKCkpO1xuICAgICAgICB9LCBtYXhEdXJhdGlvbik7XG4gICAgICB9XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAobWF4VGltZXIpXG4gICAgICAgICAgX2NsZWFyVGltZW91dChtYXhUaW1lcik7XG4gICAgICAgIG1heFRpbWVyID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShpbnZva2UoKSk7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBmaWx0ZXI7XG59XG5mdW5jdGlvbiB0aHJvdHRsZUZpbHRlciguLi5hcmdzKSB7XG4gIGxldCBsYXN0RXhlYyA9IDA7XG4gIGxldCB0aW1lcjtcbiAgbGV0IGlzTGVhZGluZyA9IHRydWU7XG4gIGxldCBsYXN0UmVqZWN0b3IgPSBub29wO1xuICBsZXQgbGFzdFZhbHVlO1xuICBsZXQgbXM7XG4gIGxldCB0cmFpbGluZztcbiAgbGV0IGxlYWRpbmc7XG4gIGxldCByZWplY3RPbkNhbmNlbDtcbiAgaWYgKCFpc1JlZihhcmdzWzBdKSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gXCJvYmplY3RcIilcbiAgICAoeyBkZWxheTogbXMsIHRyYWlsaW5nID0gdHJ1ZSwgbGVhZGluZyA9IHRydWUsIHJlamVjdE9uQ2FuY2VsID0gZmFsc2UgfSA9IGFyZ3NbMF0pO1xuICBlbHNlXG4gICAgW21zLCB0cmFpbGluZyA9IHRydWUsIGxlYWRpbmcgPSB0cnVlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlXSA9IGFyZ3M7XG4gIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gdm9pZCAwO1xuICAgICAgbGFzdFJlamVjdG9yKCk7XG4gICAgICBsYXN0UmVqZWN0b3IgPSBub29wO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZmlsdGVyID0gKF9pbnZva2UpID0+IHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRvVmFsdWUobXMpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG4gICAgY29uc3QgaW52b2tlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGxhc3RWYWx1ZSA9IF9pbnZva2UoKTtcbiAgICB9O1xuICAgIGNsZWFyKCk7XG4gICAgaWYgKGR1cmF0aW9uIDw9IDApIHtcbiAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiBpbnZva2UoKTtcbiAgICB9XG4gICAgaWYgKGVsYXBzZWQgPiBkdXJhdGlvbiAmJiAobGVhZGluZyB8fCAhaXNMZWFkaW5nKSkge1xuICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgaW52b2tlKCk7XG4gICAgfSBlbHNlIGlmICh0cmFpbGluZykge1xuICAgICAgbGFzdFZhbHVlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsYXN0UmVqZWN0b3IgPSByZWplY3RPbkNhbmNlbCA/IHJlamVjdCA6IHJlc29sdmU7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGlzTGVhZGluZyA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShpbnZva2UoKSk7XG4gICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgfSwgTWF0aC5tYXgoMCwgZHVyYXRpb24gLSBlbGFwc2VkKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFsZWFkaW5nICYmICF0aW1lcilcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBpc0xlYWRpbmcgPSB0cnVlLCBkdXJhdGlvbik7XG4gICAgaXNMZWFkaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgfTtcbiAgcmV0dXJuIGZpbHRlcjtcbn1cbmZ1bmN0aW9uIHBhdXNhYmxlRmlsdGVyKGV4dGVuZEZpbHRlciA9IGJ5cGFzc0ZpbHRlcikge1xuICBjb25zdCBpc0FjdGl2ZSA9IHJlZih0cnVlKTtcbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSB0cnVlO1xuICB9XG4gIGNvbnN0IGV2ZW50RmlsdGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoaXNBY3RpdmUudmFsdWUpXG4gICAgICBleHRlbmRGaWx0ZXIoLi4uYXJncyk7XG4gIH07XG4gIHJldHVybiB7IGlzQWN0aXZlOiByZWFkb25seShpc0FjdGl2ZSksIHBhdXNlLCByZXN1bWUsIGV2ZW50RmlsdGVyIH07XG59XG5cbmNvbnN0IGRpcmVjdGl2ZUhvb2tzID0ge1xuICBtb3VudGVkOiBpc1Z1ZTMgPyBcIm1vdW50ZWRcIiA6IFwiaW5zZXJ0ZWRcIixcbiAgdXBkYXRlZDogaXNWdWUzID8gXCJ1cGRhdGVkXCIgOiBcImNvbXBvbmVudFVwZGF0ZWRcIixcbiAgdW5tb3VudGVkOiBpc1Z1ZTMgPyBcInVubW91bnRlZFwiIDogXCJ1bmJpbmRcIlxufTtcblxuZnVuY3Rpb24gY2FjaGVTdHJpbmdGdW5jdGlvbihmbikge1xuICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufVxuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG59KTtcblxuZnVuY3Rpb24gcHJvbWlzZVRpbWVvdXQobXMsIHRocm93T25UaW1lb3V0ID0gZmFsc2UsIHJlYXNvbiA9IFwiVGltZW91dFwiKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHRocm93T25UaW1lb3V0KVxuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QocmVhc29uKSwgbXMpO1xuICAgIGVsc2VcbiAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlkZW50aXR5KGFyZykge1xuICByZXR1cm4gYXJnO1xufVxuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uUHJvbWlzZShmbikge1xuICBsZXQgX3Byb21pc2U7XG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgaWYgKCFfcHJvbWlzZSlcbiAgICAgIF9wcm9taXNlID0gZm4oKTtcbiAgICByZXR1cm4gX3Byb21pc2U7XG4gIH1cbiAgd3JhcHBlci5yZXNldCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBfcHJldiA9IF9wcm9taXNlO1xuICAgIF9wcm9taXNlID0gdm9pZCAwO1xuICAgIGlmIChfcHJldilcbiAgICAgIGF3YWl0IF9wcmV2O1xuICB9O1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbmZ1bmN0aW9uIGludm9rZShmbikge1xuICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zUHJvcChvYmosIC4uLnByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5zb21lKChrKSA9PiBrIGluIG9iaik7XG59XG5mdW5jdGlvbiBpbmNyZWFzZVdpdGhVbml0KHRhcmdldCwgZGVsdGEpIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gdGFyZ2V0ICsgZGVsdGE7XG4gIGNvbnN0IHZhbHVlID0gKChfYSA9IHRhcmdldC5tYXRjaCgvXi0/XFxkK1xcLj9cXGQqLykpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSkgfHwgXCJcIjtcbiAgY29uc3QgdW5pdCA9IHRhcmdldC5zbGljZSh2YWx1ZS5sZW5ndGgpO1xuICBjb25zdCByZXN1bHQgPSBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSkgKyBkZWx0YTtcbiAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIHJldHVybiByZXN1bHQgKyB1bml0O1xufVxuZnVuY3Rpb24gb2JqZWN0UGljayhvYmosIGtleXMsIG9taXRVbmRlZmluZWQgPSBmYWxzZSkge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKG4sIGspID0+IHtcbiAgICBpZiAoayBpbiBvYmopIHtcbiAgICAgIGlmICghb21pdFVuZGVmaW5lZCB8fCBvYmpba10gIT09IHZvaWQgMClcbiAgICAgICAgbltrXSA9IG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdE9taXQob2JqLCBrZXlzLCBvbWl0VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgcmV0dXJuICghb21pdFVuZGVmaW5lZCB8fCB2YWx1ZSAhPT0gdm9pZCAwKSAmJiAha2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9KSk7XG59XG5mdW5jdGlvbiBvYmplY3RFbnRyaWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKTtcbn1cbmZ1bmN0aW9uIGdldExpZmVDeWNsZVRhcmdldCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCB8fCBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbn1cblxuZnVuY3Rpb24gdG9SZWYoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggIT09IDEpXG4gICAgcmV0dXJuIHRvUmVmJDEoLi4uYXJncyk7XG4gIGNvbnN0IHIgPSBhcmdzWzBdO1xuICByZXR1cm4gdHlwZW9mIHIgPT09IFwiZnVuY3Rpb25cIiA/IHJlYWRvbmx5KGN1c3RvbVJlZigoKSA9PiAoeyBnZXQ6IHIsIHNldDogbm9vcCB9KSkpIDogcmVmKHIpO1xufVxuY29uc3QgcmVzb2x2ZVJlZiA9IHRvUmVmO1xuXG5mdW5jdGlvbiByZWFjdGl2ZVBpY2sob2JqLCAuLi5rZXlzKSB7XG4gIGNvbnN0IGZsYXRLZXlzID0ga2V5cy5mbGF0KCk7XG4gIGNvbnN0IHByZWRpY2F0ZSA9IGZsYXRLZXlzWzBdO1xuICByZXR1cm4gcmVhY3RpdmVDb21wdXRlZCgoKSA9PiB0eXBlb2YgcHJlZGljYXRlID09PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModG9SZWZzJDEob2JqKSkuZmlsdGVyKChbaywgdl0pID0+IHByZWRpY2F0ZSh0b1ZhbHVlKHYpLCBrKSkpIDogT2JqZWN0LmZyb21FbnRyaWVzKGZsYXRLZXlzLm1hcCgoaykgPT4gW2ssIHRvUmVmKG9iaiwgayldKSkpO1xufVxuXG5mdW5jdGlvbiByZWZBdXRvUmVzZXQoZGVmYXVsdFZhbHVlLCBhZnRlck1zID0gMWU0KSB7XG4gIHJldHVybiBjdXN0b21SZWYoKHRyYWNrLCB0cmlnZ2VyKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gdG9WYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgIGxldCB0aW1lcjtcbiAgICBjb25zdCByZXNldEFmdGVyID0gKCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YWx1ZSA9IHRvVmFsdWUoZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRyaWdnZXIoKTtcbiAgICB9LCB0b1ZhbHVlKGFmdGVyTXMpKTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZSgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHRyYWNrKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHJlc2V0QWZ0ZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlRGVib3VuY2VGbihmbiwgbXMgPSAyMDAsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlRmlsdGVyV3JhcHBlcihcbiAgICBkZWJvdW5jZUZpbHRlcihtcywgb3B0aW9ucyksXG4gICAgZm5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVmRGVib3VuY2VkKHZhbHVlLCBtcyA9IDIwMCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGRlYm91bmNlZCA9IHJlZih2YWx1ZS52YWx1ZSk7XG4gIGNvbnN0IHVwZGF0ZXIgPSB1c2VEZWJvdW5jZUZuKCgpID0+IHtcbiAgICBkZWJvdW5jZWQudmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgfSwgbXMsIG9wdGlvbnMpO1xuICB3YXRjaCh2YWx1ZSwgKCkgPT4gdXBkYXRlcigpKTtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZnVuY3Rpb24gcmVmRGVmYXVsdChzb3VyY2UsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBzb3VyY2UudmFsdWUpICE9IG51bGwgPyBfYSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc291cmNlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlVGhyb3R0bGVGbihmbiwgbXMgPSAyMDAsIHRyYWlsaW5nID0gZmFsc2UsIGxlYWRpbmcgPSB0cnVlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlKSB7XG4gIHJldHVybiBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgIHRocm90dGxlRmlsdGVyKG1zLCB0cmFpbGluZywgbGVhZGluZywgcmVqZWN0T25DYW5jZWwpLFxuICAgIGZuXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlZlRocm90dGxlZCh2YWx1ZSwgZGVsYXkgPSAyMDAsIHRyYWlsaW5nID0gdHJ1ZSwgbGVhZGluZyA9IHRydWUpIHtcbiAgaWYgKGRlbGF5IDw9IDApXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCB0aHJvdHRsZWQgPSByZWYodmFsdWUudmFsdWUpO1xuICBjb25zdCB1cGRhdGVyID0gdXNlVGhyb3R0bGVGbigoKSA9PiB7XG4gICAgdGhyb3R0bGVkLnZhbHVlID0gdmFsdWUudmFsdWU7XG4gIH0sIGRlbGF5LCB0cmFpbGluZywgbGVhZGluZyk7XG4gIHdhdGNoKHZhbHVlLCAoKSA9PiB1cGRhdGVyKCkpO1xuICByZXR1cm4gdGhyb3R0bGVkO1xufVxuXG5mdW5jdGlvbiByZWZXaXRoQ29udHJvbChpbml0aWFsLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IHNvdXJjZSA9IGluaXRpYWw7XG4gIGxldCB0cmFjaztcbiAgbGV0IHRyaWdnZXI7XG4gIGNvbnN0IHJlZiA9IGN1c3RvbVJlZigoX3RyYWNrLCBfdHJpZ2dlcikgPT4ge1xuICAgIHRyYWNrID0gX3RyYWNrO1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcjtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0KCk7XG4gICAgICB9LFxuICAgICAgc2V0KHYpIHtcbiAgICAgICAgc2V0KHYpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBmdW5jdGlvbiBnZXQodHJhY2tpbmcgPSB0cnVlKSB7XG4gICAgaWYgKHRyYWNraW5nKVxuICAgICAgdHJhY2soKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGZ1bmN0aW9uIHNldCh2YWx1ZSwgdHJpZ2dlcmluZyA9IHRydWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh2YWx1ZSA9PT0gc291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9sZCA9IHNvdXJjZTtcbiAgICBpZiAoKChfYSA9IG9wdGlvbnMub25CZWZvcmVDaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHZhbHVlLCBvbGQpKSA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgc291cmNlID0gdmFsdWU7XG4gICAgKF9iID0gb3B0aW9ucy5vbkNoYW5nZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHZhbHVlLCBvbGQpO1xuICAgIGlmICh0cmlnZ2VyaW5nKVxuICAgICAgdHJpZ2dlcigpO1xuICB9XG4gIGNvbnN0IHVudHJhY2tlZEdldCA9ICgpID0+IGdldChmYWxzZSk7XG4gIGNvbnN0IHNpbGVudFNldCA9ICh2KSA9PiBzZXQodiwgZmFsc2UpO1xuICBjb25zdCBwZWVrID0gKCkgPT4gZ2V0KGZhbHNlKTtcbiAgY29uc3QgbGF5ID0gKHYpID0+IHNldCh2LCBmYWxzZSk7XG4gIHJldHVybiBleHRlbmRSZWYoXG4gICAgcmVmLFxuICAgIHtcbiAgICAgIGdldCxcbiAgICAgIHNldCxcbiAgICAgIHVudHJhY2tlZEdldCxcbiAgICAgIHNpbGVudFNldCxcbiAgICAgIHBlZWssXG4gICAgICBsYXlcbiAgICB9LFxuICAgIHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICk7XG59XG5jb25zdCBjb250cm9sbGVkUmVmID0gcmVmV2l0aENvbnRyb2w7XG5cbmZ1bmN0aW9uIHNldCguLi5hcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFtyZWYsIHZhbHVlXSA9IGFyZ3M7XG4gICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGlzVnVlMikge1xuICAgICAgc2V0JDEoLi4uYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFt0YXJnZXQsIGtleSwgdmFsdWVdID0gYXJncztcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhdGNoV2l0aEZpbHRlcihzb3VyY2UsIGNiLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGV2ZW50RmlsdGVyID0gYnlwYXNzRmlsdGVyLFxuICAgIC4uLndhdGNoT3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgICAgZXZlbnRGaWx0ZXIsXG4gICAgICBjYlxuICAgICksXG4gICAgd2F0Y2hPcHRpb25zXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdhdGNoUGF1c2FibGUoc291cmNlLCBjYiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBldmVudEZpbHRlcjogZmlsdGVyLFxuICAgIC4uLndhdGNoT3B0aW9uc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBldmVudEZpbHRlciwgcGF1c2UsIHJlc3VtZSwgaXNBY3RpdmUgfSA9IHBhdXNhYmxlRmlsdGVyKGZpbHRlcik7XG4gIGNvbnN0IHN0b3AgPSB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgc291cmNlLFxuICAgIGNiLFxuICAgIHtcbiAgICAgIC4uLndhdGNoT3B0aW9ucyxcbiAgICAgIGV2ZW50RmlsdGVyXG4gICAgfVxuICApO1xuICByZXR1cm4geyBzdG9wLCBwYXVzZSwgcmVzdW1lLCBpc0FjdGl2ZSB9O1xufVxuXG5mdW5jdGlvbiBzeW5jUmVmKGxlZnQsIHJpZ2h0LCAuLi5bb3B0aW9uc10pIHtcbiAgY29uc3Qge1xuICAgIGZsdXNoID0gXCJzeW5jXCIsXG4gICAgZGVlcCA9IGZhbHNlLFxuICAgIGltbWVkaWF0ZSA9IHRydWUsXG4gICAgZGlyZWN0aW9uID0gXCJib3RoXCIsXG4gICAgdHJhbnNmb3JtID0ge31cbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHdhdGNoZXJzID0gW107XG4gIGNvbnN0IHRyYW5zZm9ybUxUUiA9IFwibHRyXCIgaW4gdHJhbnNmb3JtICYmIHRyYW5zZm9ybS5sdHIgfHwgKCh2KSA9PiB2KTtcbiAgY29uc3QgdHJhbnNmb3JtUlRMID0gXCJydGxcIiBpbiB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtLnJ0bCB8fCAoKHYpID0+IHYpO1xuICBpZiAoZGlyZWN0aW9uID09PSBcImJvdGhcIiB8fCBkaXJlY3Rpb24gPT09IFwibHRyXCIpIHtcbiAgICB3YXRjaGVycy5wdXNoKHdhdGNoUGF1c2FibGUoXG4gICAgICBsZWZ0LFxuICAgICAgKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIHdhdGNoZXJzLmZvckVhY2goKHcpID0+IHcucGF1c2UoKSk7XG4gICAgICAgIHJpZ2h0LnZhbHVlID0gdHJhbnNmb3JtTFRSKG5ld1ZhbHVlKTtcbiAgICAgICAgd2F0Y2hlcnMuZm9yRWFjaCgodykgPT4gdy5yZXN1bWUoKSk7XG4gICAgICB9LFxuICAgICAgeyBmbHVzaCwgZGVlcCwgaW1tZWRpYXRlIH1cbiAgICApKTtcbiAgfVxuICBpZiAoZGlyZWN0aW9uID09PSBcImJvdGhcIiB8fCBkaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICB3YXRjaGVycy5wdXNoKHdhdGNoUGF1c2FibGUoXG4gICAgICByaWdodCxcbiAgICAgIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICB3YXRjaGVycy5mb3JFYWNoKCh3KSA9PiB3LnBhdXNlKCkpO1xuICAgICAgICBsZWZ0LnZhbHVlID0gdHJhbnNmb3JtUlRMKG5ld1ZhbHVlKTtcbiAgICAgICAgd2F0Y2hlcnMuZm9yRWFjaCgodykgPT4gdy5yZXN1bWUoKSk7XG4gICAgICB9LFxuICAgICAgeyBmbHVzaCwgZGVlcCwgaW1tZWRpYXRlIH1cbiAgICApKTtcbiAgfVxuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIHdhdGNoZXJzLmZvckVhY2goKHcpID0+IHcuc3RvcCgpKTtcbiAgfTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIHN5bmNSZWZzKHNvdXJjZSwgdGFyZ2V0cywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBmbHVzaCA9IFwic3luY1wiLFxuICAgIGRlZXAgPSBmYWxzZSxcbiAgICBpbW1lZGlhdGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0cykpXG4gICAgdGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICAobmV3VmFsdWUpID0+IHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB0YXJnZXQudmFsdWUgPSBuZXdWYWx1ZSksXG4gICAgeyBmbHVzaCwgZGVlcCwgaW1tZWRpYXRlIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdFJlZiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghaXNSZWYob2JqZWN0UmVmKSlcbiAgICByZXR1cm4gdG9SZWZzJDEob2JqZWN0UmVmKTtcbiAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShvYmplY3RSZWYudmFsdWUpID8gQXJyYXkuZnJvbSh7IGxlbmd0aDogb2JqZWN0UmVmLnZhbHVlLmxlbmd0aCB9KSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3RSZWYudmFsdWUpIHtcbiAgICByZXN1bHRba2V5XSA9IGN1c3RvbVJlZigoKSA9PiAoe1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0UmVmLnZhbHVlW2tleV07XG4gICAgICB9LFxuICAgICAgc2V0KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXBsYWNlUmVmID0gKF9hID0gdG9WYWx1ZShvcHRpb25zLnJlcGxhY2VSZWYpKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICAgICAgICBpZiAocmVwbGFjZVJlZikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFJlZi52YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBbLi4ub2JqZWN0UmVmLnZhbHVlXTtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHY7XG4gICAgICAgICAgICBvYmplY3RSZWYudmFsdWUgPSBjb3B5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdPYmplY3QgPSB7IC4uLm9iamVjdFJlZi52YWx1ZSwgW2tleV06IHYgfTtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdPYmplY3QsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3RSZWYudmFsdWUpKTtcbiAgICAgICAgICAgIG9iamVjdFJlZi52YWx1ZSA9IG5ld09iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0UmVmLnZhbHVlW2tleV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHRyeU9uQmVmb3JlTW91bnQoZm4sIHN5bmMgPSB0cnVlLCB0YXJnZXQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRMaWZlQ3ljbGVUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKGluc3RhbmNlKVxuICAgIG9uQmVmb3JlTW91bnQoZm4sIHRhcmdldCk7XG4gIGVsc2UgaWYgKHN5bmMpXG4gICAgZm4oKTtcbiAgZWxzZVxuICAgIG5leHRUaWNrKGZuKTtcbn1cblxuZnVuY3Rpb24gdHJ5T25CZWZvcmVVbm1vdW50KGZuLCB0YXJnZXQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRMaWZlQ3ljbGVUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKGluc3RhbmNlKVxuICAgIG9uQmVmb3JlVW5tb3VudChmbiwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gdHJ5T25Nb3VudGVkKGZuLCBzeW5jID0gdHJ1ZSwgdGFyZ2V0KSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0TGlmZUN5Y2xlVGFyZ2V0KCk7XG4gIGlmIChpbnN0YW5jZSlcbiAgICBvbk1vdW50ZWQoZm4sIHRhcmdldCk7XG4gIGVsc2UgaWYgKHN5bmMpXG4gICAgZm4oKTtcbiAgZWxzZVxuICAgIG5leHRUaWNrKGZuKTtcbn1cblxuZnVuY3Rpb24gdHJ5T25Vbm1vdW50ZWQoZm4sIHRhcmdldCkge1xuICBjb25zdCBpbnN0YW5jZSA9IGdldExpZmVDeWNsZVRhcmdldCh0YXJnZXQpO1xuICBpZiAoaW5zdGFuY2UpXG4gICAgb25Vbm1vdW50ZWQoZm4sIHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVudGlsKHIsIGlzTm90ID0gZmFsc2UpIHtcbiAgZnVuY3Rpb24gdG9NYXRjaChjb25kaXRpb24sIHsgZmx1c2ggPSBcInN5bmNcIiwgZGVlcCA9IGZhbHNlLCB0aW1lb3V0LCB0aHJvd09uVGltZW91dCB9ID0ge30pIHtcbiAgICBsZXQgc3RvcCA9IG51bGw7XG4gICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzdG9wID0gd2F0Y2goXG4gICAgICAgIHIsXG4gICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbih2KSAhPT0gaXNOb3QpIHtcbiAgICAgICAgICAgIHN0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AoKTtcbiAgICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZmx1c2gsXG4gICAgICAgICAgZGVlcCxcbiAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt3YXRjaGVyXTtcbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICBwcm9taXNlVGltZW91dCh0aW1lb3V0LCB0aHJvd09uVGltZW91dCkudGhlbigoKSA9PiB0b1ZhbHVlKHIpKS5maW5hbGx5KCgpID0+IHN0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJhY2UocHJvbWlzZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHRvQmUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzUmVmKHZhbHVlKSlcbiAgICAgIHJldHVybiB0b01hdGNoKCh2KSA9PiB2ID09PSB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBmbHVzaCA9IFwic3luY1wiLCBkZWVwID0gZmFsc2UsIHRpbWVvdXQsIHRocm93T25UaW1lb3V0IH0gPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgbGV0IHN0b3AgPSBudWxsO1xuICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc3RvcCA9IHdhdGNoKFxuICAgICAgICBbciwgdmFsdWVdLFxuICAgICAgICAoW3YxLCB2Ml0pID0+IHtcbiAgICAgICAgICBpZiAoaXNOb3QgIT09ICh2MSA9PT0gdjIpKSB7XG4gICAgICAgICAgICBzdG9wID09IG51bGwgPyB2b2lkIDAgOiBzdG9wKCk7XG4gICAgICAgICAgICByZXNvbHZlKHYxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBmbHVzaCxcbiAgICAgICAgICBkZWVwLFxuICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3dhdGNoZXJdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIHByb21pc2VUaW1lb3V0KHRpbWVvdXQsIHRocm93T25UaW1lb3V0KS50aGVuKCgpID0+IHRvVmFsdWUocikpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHN0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3AoKTtcbiAgICAgICAgICByZXR1cm4gdG9WYWx1ZShyKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJhY2UocHJvbWlzZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHRvQmVUcnV0aHkob3B0aW9ucykge1xuICAgIHJldHVybiB0b01hdGNoKCh2KSA9PiBCb29sZWFuKHYpLCBvcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiB0b0JlTnVsbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQmUobnVsbCwgb3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gdG9CZVVuZGVmaW5lZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQmUodm9pZCAwLCBvcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiB0b0JlTmFOKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9NYXRjaChOdW1iZXIuaXNOYU4sIG9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIHRvQ29udGFpbnModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9NYXRjaCgodikgPT4ge1xuICAgICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHYpO1xuICAgICAgcmV0dXJuIGFycmF5LmluY2x1ZGVzKHZhbHVlKSB8fCBhcnJheS5pbmNsdWRlcyh0b1ZhbHVlKHZhbHVlKSk7XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gY2hhbmdlZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNoYW5nZWRUaW1lcygxLCBvcHRpb25zKTtcbiAgfVxuICBmdW5jdGlvbiBjaGFuZ2VkVGltZXMobiA9IDEsIG9wdGlvbnMpIHtcbiAgICBsZXQgY291bnQgPSAtMTtcbiAgICByZXR1cm4gdG9NYXRjaCgoKSA9PiB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgcmV0dXJuIGNvdW50ID49IG47XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodG9WYWx1ZShyKSkpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgIHRvTWF0Y2gsXG4gICAgICB0b0NvbnRhaW5zLFxuICAgICAgY2hhbmdlZCxcbiAgICAgIGNoYW5nZWRUaW1lcyxcbiAgICAgIGdldCBub3QoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVVbnRpbChyLCAhaXNOb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgdG9NYXRjaCxcbiAgICAgIHRvQmUsXG4gICAgICB0b0JlVHJ1dGh5LFxuICAgICAgdG9CZU51bGwsXG4gICAgICB0b0JlTmFOLFxuICAgICAgdG9CZVVuZGVmaW5lZCxcbiAgICAgIGNoYW5nZWQsXG4gICAgICBjaGFuZ2VkVGltZXMsXG4gICAgICBnZXQgbm90KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVW50aWwociwgIWlzTm90KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxufVxuZnVuY3Rpb24gdW50aWwocikge1xuICByZXR1cm4gY3JlYXRlVW50aWwocik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKHZhbHVlLCBvdGhWYWwpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhWYWw7XG59XG5mdW5jdGlvbiB1c2VBcnJheURpZmZlcmVuY2UoLi4uYXJncykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxpc3QgPSBhcmdzWzBdO1xuICBjb25zdCB2YWx1ZXMgPSBhcmdzWzFdO1xuICBsZXQgY29tcGFyZUZuID0gKF9hID0gYXJnc1syXSkgIT0gbnVsbCA/IF9hIDogZGVmYXVsdENvbXBhcmF0b3I7XG4gIGlmICh0eXBlb2YgY29tcGFyZUZuID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3Qga2V5ID0gY29tcGFyZUZuO1xuICAgIGNvbXBhcmVGbiA9ICh2YWx1ZSwgb3RoVmFsKSA9PiB2YWx1ZVtrZXldID09PSBvdGhWYWxba2V5XTtcbiAgfVxuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5maWx0ZXIoKHgpID0+IHRvVmFsdWUodmFsdWVzKS5maW5kSW5kZXgoKHkpID0+IGNvbXBhcmVGbih4LCB5KSkgPT09IC0xKSk7XG59XG5cbmZ1bmN0aW9uIHVzZUFycmF5RXZlcnkobGlzdCwgZm4pIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkuZXZlcnkoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gZm4odG9WYWx1ZShlbGVtZW50KSwgaW5kZXgsIGFycmF5KSkpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheUZpbHRlcihsaXN0LCBmbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5tYXAoKGkpID0+IHRvVmFsdWUoaSkpLmZpbHRlcihmbikpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheUZpbmQobGlzdCwgZm4pIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUoXG4gICAgdG9WYWx1ZShsaXN0KS5maW5kKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IGZuKHRvVmFsdWUoZWxlbWVudCksIGluZGV4LCBhcnJheSkpXG4gICkpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheUZpbmRJbmRleChsaXN0LCBmbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5maW5kSW5kZXgoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gZm4odG9WYWx1ZShlbGVtZW50KSwgaW5kZXgsIGFycmF5KSkpO1xufVxuXG5mdW5jdGlvbiBmaW5kTGFzdChhcnIsIGNiKSB7XG4gIGxldCBpbmRleCA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgIGlmIChjYihhcnJbaW5kZXhdLCBpbmRleCwgYXJyKSlcbiAgICAgIHJldHVybiBhcnJbaW5kZXhdO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiB1c2VBcnJheUZpbmRMYXN0KGxpc3QsIGZuKSB7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB0b1ZhbHVlKFxuICAgICFBcnJheS5wcm90b3R5cGUuZmluZExhc3QgPyBmaW5kTGFzdCh0b1ZhbHVlKGxpc3QpLCAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBmbih0b1ZhbHVlKGVsZW1lbnQpLCBpbmRleCwgYXJyYXkpKSA6IHRvVmFsdWUobGlzdCkuZmluZExhc3QoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gZm4odG9WYWx1ZShlbGVtZW50KSwgaW5kZXgsIGFycmF5KSlcbiAgKSk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJbmNsdWRlc09wdGlvbnMob2JqKSB7XG4gIHJldHVybiBpc09iamVjdChvYmopICYmIGNvbnRhaW5zUHJvcChvYmosIFwiZm9ybUluZGV4XCIsIFwiY29tcGFyYXRvclwiKTtcbn1cbmZ1bmN0aW9uIHVzZUFycmF5SW5jbHVkZXMoLi4uYXJncykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxpc3QgPSBhcmdzWzBdO1xuICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV07XG4gIGxldCBjb21wYXJhdG9yID0gYXJnc1syXTtcbiAgbGV0IGZvcm1JbmRleCA9IDA7XG4gIGlmIChpc0FycmF5SW5jbHVkZXNPcHRpb25zKGNvbXBhcmF0b3IpKSB7XG4gICAgZm9ybUluZGV4ID0gKF9hID0gY29tcGFyYXRvci5mcm9tSW5kZXgpICE9IG51bGwgPyBfYSA6IDA7XG4gICAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IuY29tcGFyYXRvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBrZXkgPSBjb21wYXJhdG9yO1xuICAgIGNvbXBhcmF0b3IgPSAoZWxlbWVudCwgdmFsdWUyKSA9PiBlbGVtZW50W2tleV0gPT09IHRvVmFsdWUodmFsdWUyKTtcbiAgfVxuICBjb21wYXJhdG9yID0gY29tcGFyYXRvciAhPSBudWxsID8gY29tcGFyYXRvciA6IChlbGVtZW50LCB2YWx1ZTIpID0+IGVsZW1lbnQgPT09IHRvVmFsdWUodmFsdWUyKTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkuc2xpY2UoZm9ybUluZGV4KS5zb21lKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IGNvbXBhcmF0b3IoXG4gICAgdG9WYWx1ZShlbGVtZW50KSxcbiAgICB0b1ZhbHVlKHZhbHVlKSxcbiAgICBpbmRleCxcbiAgICB0b1ZhbHVlKGFycmF5KVxuICApKSk7XG59XG5cbmZ1bmN0aW9uIHVzZUFycmF5Sm9pbihsaXN0LCBzZXBhcmF0b3IpIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkubWFwKChpKSA9PiB0b1ZhbHVlKGkpKS5qb2luKHRvVmFsdWUoc2VwYXJhdG9yKSkpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheU1hcChsaXN0LCBmbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4gdG9WYWx1ZShsaXN0KS5tYXAoKGkpID0+IHRvVmFsdWUoaSkpLm1hcChmbikpO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheVJlZHVjZShsaXN0LCByZWR1Y2VyLCAuLi5hcmdzKSB7XG4gIGNvbnN0IHJlZHVjZUNhbGxiYWNrID0gKHN1bSwgdmFsdWUsIGluZGV4KSA9PiByZWR1Y2VyKHRvVmFsdWUoc3VtKSwgdG9WYWx1ZSh2YWx1ZSksIGluZGV4KTtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHRvVmFsdWUobGlzdCk7XG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID8gcmVzb2x2ZWQucmVkdWNlKHJlZHVjZUNhbGxiYWNrLCB0b1ZhbHVlKGFyZ3NbMF0pKSA6IHJlc29sdmVkLnJlZHVjZShyZWR1Y2VDYWxsYmFjayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VBcnJheVNvbWUobGlzdCwgZm4pIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IHRvVmFsdWUobGlzdCkuc29tZSgoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBmbih0b1ZhbHVlKGVsZW1lbnQpLCBpbmRleCwgYXJyYXkpKSk7XG59XG5cbmZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheSkpO1xufVxuZnVuY3Rpb24gdW5pcXVlRWxlbWVudHNCeShhcnJheSwgZm4pIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjLCB2KSA9PiB7XG4gICAgaWYgKCFhY2Muc29tZSgoeCkgPT4gZm4odiwgeCwgYXJyYXkpKSlcbiAgICAgIGFjYy5wdXNoKHYpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIHVzZUFycmF5VW5pcXVlKGxpc3QsIGNvbXBhcmVGbikge1xuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkTGlzdCA9IHRvVmFsdWUobGlzdCkubWFwKChlbGVtZW50KSA9PiB0b1ZhbHVlKGVsZW1lbnQpKTtcbiAgICByZXR1cm4gY29tcGFyZUZuID8gdW5pcXVlRWxlbWVudHNCeShyZXNvbHZlZExpc3QsIGNvbXBhcmVGbikgOiB1bmlxKHJlc29sdmVkTGlzdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VDb3VudGVyKGluaXRpYWxWYWx1ZSA9IDAsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgX2luaXRpYWxWYWx1ZSA9IHVucmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IGNvdW50ID0gcmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHtcbiAgICBtYXggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgbWluID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpbmMgPSAoZGVsdGEgPSAxKSA9PiBjb3VudC52YWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgY291bnQudmFsdWUgKyBkZWx0YSksIG1pbik7XG4gIGNvbnN0IGRlYyA9IChkZWx0YSA9IDEpID0+IGNvdW50LnZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgobWluLCBjb3VudC52YWx1ZSAtIGRlbHRhKSwgbWF4KTtcbiAgY29uc3QgZ2V0ID0gKCkgPT4gY291bnQudmFsdWU7XG4gIGNvbnN0IHNldCA9ICh2YWwpID0+IGNvdW50LnZhbHVlID0gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xuICBjb25zdCByZXNldCA9ICh2YWwgPSBfaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgX2luaXRpYWxWYWx1ZSA9IHZhbDtcbiAgICByZXR1cm4gc2V0KHZhbCk7XG4gIH07XG4gIHJldHVybiB7IGNvdW50LCBpbmMsIGRlYywgZ2V0LCBzZXQsIHJlc2V0IH07XG59XG5cbmNvbnN0IFJFR0VYX1BBUlNFID0gL14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVFxcc10qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pP1suOl0/KFxcZCspPyQvaTtcbmNvbnN0IFJFR0VYX0ZPUk1BVCA9IC9bWU1ESGhtc11vfFxcWyhbXlxcXV0rKVxcXXxZezEsNH18TXsxLDR9fER7MSwyfXxkezEsNH18SHsxLDJ9fGh7MSwyfXxhezEsMn18QXsxLDJ9fG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nO1xuZnVuY3Rpb24gZGVmYXVsdE1lcmlkaWVtKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyY2FzZSwgaGFzUGVyaW9kKSB7XG4gIGxldCBtID0gaG91cnMgPCAxMiA/IFwiQU1cIiA6IFwiUE1cIjtcbiAgaWYgKGhhc1BlcmlvZClcbiAgICBtID0gbS5zcGxpdChcIlwiKS5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICs9IGAke2N1cnJ9LmAsIFwiXCIpO1xuICByZXR1cm4gaXNMb3dlcmNhc2UgPyBtLnRvTG93ZXJDYXNlKCkgOiBtO1xufVxuZnVuY3Rpb24gZm9ybWF0T3JkaW5hbChudW0pIHtcbiAgY29uc3Qgc3VmZml4ZXMgPSBbXCJ0aFwiLCBcInN0XCIsIFwibmRcIiwgXCJyZFwiXTtcbiAgY29uc3QgdiA9IG51bSAlIDEwMDtcbiAgcmV0dXJuIG51bSArIChzdWZmaXhlc1sodiAtIDIwKSAlIDEwXSB8fCBzdWZmaXhlc1t2XSB8fCBzdWZmaXhlc1swXSk7XG59XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0ciwgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeWVhcnMgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCBkYXlzID0gZGF0ZS5nZXREYXRlKCk7XG4gIGNvbnN0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuICBjb25zdCBtaW51dGVzID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIGNvbnN0IHNlY29uZHMgPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgY29uc3QgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgY29uc3QgbWVyaWRpZW0gPSAoX2EgPSBvcHRpb25zLmN1c3RvbU1lcmlkaWVtKSAhPSBudWxsID8gX2EgOiBkZWZhdWx0TWVyaWRpZW07XG4gIGNvbnN0IG1hdGNoZXMgPSB7XG4gICAgWW86ICgpID0+IGZvcm1hdE9yZGluYWwoeWVhcnMpLFxuICAgIFlZOiAoKSA9PiBTdHJpbmcoeWVhcnMpLnNsaWNlKC0yKSxcbiAgICBZWVlZOiAoKSA9PiB5ZWFycyxcbiAgICBNOiAoKSA9PiBtb250aCArIDEsXG4gICAgTW86ICgpID0+IGZvcm1hdE9yZGluYWwobW9udGggKyAxKSxcbiAgICBNTTogKCkgPT4gYCR7bW9udGggKyAxfWAucGFkU3RhcnQoMiwgXCIwXCIpLFxuICAgIE1NTTogKCkgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcob3B0aW9ucy5sb2NhbGVzLCB7IG1vbnRoOiBcInNob3J0XCIgfSksXG4gICAgTU1NTTogKCkgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcob3B0aW9ucy5sb2NhbGVzLCB7IG1vbnRoOiBcImxvbmdcIiB9KSxcbiAgICBEOiAoKSA9PiBTdHJpbmcoZGF5cyksXG4gICAgRG86ICgpID0+IGZvcm1hdE9yZGluYWwoZGF5cyksXG4gICAgREQ6ICgpID0+IGAke2RheXN9YC5wYWRTdGFydCgyLCBcIjBcIiksXG4gICAgSDogKCkgPT4gU3RyaW5nKGhvdXJzKSxcbiAgICBIbzogKCkgPT4gZm9ybWF0T3JkaW5hbChob3VycyksXG4gICAgSEg6ICgpID0+IGAke2hvdXJzfWAucGFkU3RhcnQoMiwgXCIwXCIpLFxuICAgIGg6ICgpID0+IGAke2hvdXJzICUgMTIgfHwgMTJ9YC5wYWRTdGFydCgxLCBcIjBcIiksXG4gICAgaG86ICgpID0+IGZvcm1hdE9yZGluYWwoaG91cnMgJSAxMiB8fCAxMiksXG4gICAgaGg6ICgpID0+IGAke2hvdXJzICUgMTIgfHwgMTJ9YC5wYWRTdGFydCgyLCBcIjBcIiksXG4gICAgbTogKCkgPT4gU3RyaW5nKG1pbnV0ZXMpLFxuICAgIG1vOiAoKSA9PiBmb3JtYXRPcmRpbmFsKG1pbnV0ZXMpLFxuICAgIG1tOiAoKSA9PiBgJHttaW51dGVzfWAucGFkU3RhcnQoMiwgXCIwXCIpLFxuICAgIHM6ICgpID0+IFN0cmluZyhzZWNvbmRzKSxcbiAgICBzbzogKCkgPT4gZm9ybWF0T3JkaW5hbChzZWNvbmRzKSxcbiAgICBzczogKCkgPT4gYCR7c2Vjb25kc31gLnBhZFN0YXJ0KDIsIFwiMFwiKSxcbiAgICBTU1M6ICgpID0+IGAke21pbGxpc2Vjb25kc31gLnBhZFN0YXJ0KDMsIFwiMFwiKSxcbiAgICBkOiAoKSA9PiBkYXksXG4gICAgZGQ6ICgpID0+IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKG9wdGlvbnMubG9jYWxlcywgeyB3ZWVrZGF5OiBcIm5hcnJvd1wiIH0pLFxuICAgIGRkZDogKCkgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcob3B0aW9ucy5sb2NhbGVzLCB7IHdlZWtkYXk6IFwic2hvcnRcIiB9KSxcbiAgICBkZGRkOiAoKSA9PiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhvcHRpb25zLmxvY2FsZXMsIHsgd2Vla2RheTogXCJsb25nXCIgfSksXG4gICAgQTogKCkgPT4gbWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMpLFxuICAgIEFBOiAoKSA9PiBtZXJpZGllbShob3VycywgbWludXRlcywgZmFsc2UsIHRydWUpLFxuICAgIGE6ICgpID0+IG1lcmlkaWVtKGhvdXJzLCBtaW51dGVzLCB0cnVlKSxcbiAgICBhYTogKCkgPT4gbWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIHRydWUsIHRydWUpXG4gIH07XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShSRUdFWF9GT1JNQVQsIChtYXRjaCwgJDEpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKF9iID0gJDEgIT0gbnVsbCA/ICQxIDogKF9hMiA9IG1hdGNoZXNbbWF0Y2hdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwobWF0Y2hlcykpICE9IG51bGwgPyBfYiA6IG1hdGNoO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGUoZGF0ZSkge1xuICBpZiAoZGF0ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLk5hTik7XG4gIGlmIChkYXRlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICBpZiAodHlwZW9mIGRhdGUgPT09IFwic3RyaW5nXCIgJiYgIS9aJC9pLnRlc3QoZGF0ZSkpIHtcbiAgICBjb25zdCBkID0gZGF0ZS5tYXRjaChSRUdFWF9QQVJTRSk7XG4gICAgaWYgKGQpIHtcbiAgICAgIGNvbnN0IG0gPSBkWzJdIC0gMSB8fCAwO1xuICAgICAgY29uc3QgbXMgPSAoZFs3XSB8fCBcIjBcIikuc3Vic3RyaW5nKDAsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRbMV0sIG0sIGRbM10gfHwgMSwgZFs0XSB8fCAwLCBkWzVdIHx8IDAsIGRbNl0gfHwgMCwgbXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VEYXRlRm9ybWF0KGRhdGUsIGZvcm1hdFN0ciA9IFwiSEg6bW06c3NcIiwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiBmb3JtYXREYXRlKG5vcm1hbGl6ZURhdGUodG9WYWx1ZShkYXRlKSksIHRvVmFsdWUoZm9ybWF0U3RyKSwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRlcnZhbEZuKGNiLCBpbnRlcnZhbCA9IDFlMywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpbW1lZGlhdGUgPSB0cnVlLFxuICAgIGltbWVkaWF0ZUNhbGxiYWNrID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB0aW1lciA9IG51bGw7XG4gIGNvbnN0IGlzQWN0aXZlID0gcmVmKGZhbHNlKTtcbiAgZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaXNBY3RpdmUudmFsdWUgPSBmYWxzZTtcbiAgICBjbGVhbigpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICBjb25zdCBpbnRlcnZhbFZhbHVlID0gdG9WYWx1ZShpbnRlcnZhbCk7XG4gICAgaWYgKGludGVydmFsVmFsdWUgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBpc0FjdGl2ZS52YWx1ZSA9IHRydWU7XG4gICAgaWYgKGltbWVkaWF0ZUNhbGxiYWNrKVxuICAgICAgY2IoKTtcbiAgICBjbGVhbigpO1xuICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoY2IsIGludGVydmFsVmFsdWUpO1xuICB9XG4gIGlmIChpbW1lZGlhdGUgJiYgaXNDbGllbnQpXG4gICAgcmVzdW1lKCk7XG4gIGlmIChpc1JlZihpbnRlcnZhbCkgfHwgdHlwZW9mIGludGVydmFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzdG9wV2F0Y2ggPSB3YXRjaChpbnRlcnZhbCwgKCkgPT4ge1xuICAgICAgaWYgKGlzQWN0aXZlLnZhbHVlICYmIGlzQ2xpZW50KVxuICAgICAgICByZXN1bWUoKTtcbiAgICB9KTtcbiAgICB0cnlPblNjb3BlRGlzcG9zZShzdG9wV2F0Y2gpO1xuICB9XG4gIHRyeU9uU2NvcGVEaXNwb3NlKHBhdXNlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwYXVzZSxcbiAgICByZXN1bWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSW50ZXJ2YWwoaW50ZXJ2YWwgPSAxZTMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgY29udHJvbHM6IGV4cG9zZUNvbnRyb2xzID0gZmFsc2UsXG4gICAgaW1tZWRpYXRlID0gdHJ1ZSxcbiAgICBjYWxsYmFja1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY291bnRlciA9IHJlZigwKTtcbiAgY29uc3QgdXBkYXRlID0gKCkgPT4gY291bnRlci52YWx1ZSArPSAxO1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBjb3VudGVyLnZhbHVlID0gMDtcbiAgfTtcbiAgY29uc3QgY29udHJvbHMgPSB1c2VJbnRlcnZhbEZuKFxuICAgIGNhbGxiYWNrID8gKCkgPT4ge1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBjYWxsYmFjayhjb3VudGVyLnZhbHVlKTtcbiAgICB9IDogdXBkYXRlLFxuICAgIGludGVydmFsLFxuICAgIHsgaW1tZWRpYXRlIH1cbiAgKTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50ZXIsXG4gICAgICByZXNldCxcbiAgICAgIC4uLmNvbnRyb2xzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VMYXN0Q2hhbmdlZChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IG1zID0gcmVmKChfYSA9IG9wdGlvbnMuaW5pdGlhbFZhbHVlKSAhPSBudWxsID8gX2EgOiBudWxsKTtcbiAgd2F0Y2goXG4gICAgc291cmNlLFxuICAgICgpID0+IG1zLnZhbHVlID0gdGltZXN0YW1wKCksXG4gICAgb3B0aW9uc1xuICApO1xuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVvdXRGbihjYiwgaW50ZXJ2YWwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgaW1tZWRpYXRlID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaXNQZW5kaW5nID0gcmVmKGZhbHNlKTtcbiAgbGV0IHRpbWVyID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlzUGVuZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgIGNsZWFyKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoLi4uYXJncykge1xuICAgIGNsZWFyKCk7XG4gICAgaXNQZW5kaW5nLnZhbHVlID0gdHJ1ZTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaXNQZW5kaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgICBjYiguLi5hcmdzKTtcbiAgICB9LCB0b1ZhbHVlKGludGVydmFsKSk7XG4gIH1cbiAgaWYgKGltbWVkaWF0ZSkge1xuICAgIGlzUGVuZGluZy52YWx1ZSA9IHRydWU7XG4gICAgaWYgKGlzQ2xpZW50KVxuICAgICAgc3RhcnQoKTtcbiAgfVxuICB0cnlPblNjb3BlRGlzcG9zZShzdG9wKTtcbiAgcmV0dXJuIHtcbiAgICBpc1BlbmRpbmc6IHJlYWRvbmx5KGlzUGVuZGluZyksXG4gICAgc3RhcnQsXG4gICAgc3RvcFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lb3V0KGludGVydmFsID0gMWUzLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2xzOiBleHBvc2VDb250cm9scyA9IGZhbHNlLFxuICAgIGNhbGxiYWNrXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjb250cm9scyA9IHVzZVRpbWVvdXRGbihcbiAgICBjYWxsYmFjayAhPSBudWxsID8gY2FsbGJhY2sgOiBub29wLFxuICAgIGludGVydmFsLFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgY29uc3QgcmVhZHkgPSBjb21wdXRlZCgoKSA9PiAhY29udHJvbHMuaXNQZW5kaW5nLnZhbHVlKTtcbiAgaWYgKGV4cG9zZUNvbnRyb2xzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlYWR5LFxuICAgICAgLi4uY29udHJvbHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWFkeTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VUb051bWJlcih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBtZXRob2QgPSBcInBhcnNlRmxvYXRcIixcbiAgICByYWRpeCxcbiAgICBuYW5Ub1plcm9cbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiBjb21wdXRlZCgoKSA9PiB7XG4gICAgbGV0IHJlc29sdmVkID0gdG9WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJlc29sdmVkID0gTnVtYmVyW21ldGhvZF0ocmVzb2x2ZWQsIHJhZGl4KTtcbiAgICBpZiAobmFuVG9aZXJvICYmIE51bWJlci5pc05hTihyZXNvbHZlZCkpXG4gICAgICByZXNvbHZlZCA9IDA7XG4gICAgcmV0dXJuIHJlc29sdmVkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIGNvbXB1dGVkKCgpID0+IGAke3RvVmFsdWUodmFsdWUpfWApO1xufVxuXG5mdW5jdGlvbiB1c2VUb2dnbGUoaW5pdGlhbFZhbHVlID0gZmFsc2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdHJ1dGh5VmFsdWUgPSB0cnVlLFxuICAgIGZhbHN5VmFsdWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdmFsdWVJc1JlZiA9IGlzUmVmKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IF92YWx1ZSA9IHJlZihpbml0aWFsVmFsdWUpO1xuICBmdW5jdGlvbiB0b2dnbGUodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgX3ZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gX3ZhbHVlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cnV0aHkgPSB0b1ZhbHVlKHRydXRoeVZhbHVlKTtcbiAgICAgIF92YWx1ZS52YWx1ZSA9IF92YWx1ZS52YWx1ZSA9PT0gdHJ1dGh5ID8gdG9WYWx1ZShmYWxzeVZhbHVlKSA6IHRydXRoeTtcbiAgICAgIHJldHVybiBfdmFsdWUudmFsdWU7XG4gICAgfVxuICB9XG4gIGlmICh2YWx1ZUlzUmVmKVxuICAgIHJldHVybiB0b2dnbGU7XG4gIGVsc2VcbiAgICByZXR1cm4gW192YWx1ZSwgdG9nZ2xlXTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hBcnJheShzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGxldCBvbGRMaXN0ID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW1tZWRpYXRlKSA/IFtdIDogWy4uLnNvdXJjZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gc291cmNlKCkgOiBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiB0b1ZhbHVlKHNvdXJjZSldO1xuICByZXR1cm4gd2F0Y2goc291cmNlLCAobmV3TGlzdCwgXywgb25DbGVhbnVwKSA9PiB7XG4gICAgY29uc3Qgb2xkTGlzdFJlbWFpbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBvbGRMaXN0Lmxlbmd0aCB9KTtcbiAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgb2JqIG9mIG5ld0xpc3QpIHtcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb2xkTGlzdFJlbWFpbnNbaV0gJiYgb2JqID09PSBvbGRMaXN0W2ldKSB7XG4gICAgICAgICAgb2xkTGlzdFJlbWFpbnNbaV0gPSB0cnVlO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgYWRkZWQucHVzaChvYmopO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVkID0gb2xkTGlzdC5maWx0ZXIoKF8yLCBpKSA9PiAhb2xkTGlzdFJlbWFpbnNbaV0pO1xuICAgIGNiKG5ld0xpc3QsIG9sZExpc3QsIGFkZGVkLCByZW1vdmVkLCBvbkNsZWFudXApO1xuICAgIG9sZExpc3QgPSBbLi4ubmV3TGlzdF07XG4gIH0sIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB3YXRjaEF0TW9zdChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBjb3VudCxcbiAgICAuLi53YXRjaE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN1cnJlbnQgPSByZWYoMCk7XG4gIGNvbnN0IHN0b3AgPSB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgc291cmNlLFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBjdXJyZW50LnZhbHVlICs9IDE7XG4gICAgICBpZiAoY3VycmVudC52YWx1ZSA+PSB0b1ZhbHVlKGNvdW50KSlcbiAgICAgICAgbmV4dFRpY2soKCkgPT4gc3RvcCgpKTtcbiAgICAgIGNiKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd2F0Y2hPcHRpb25zXG4gICk7XG4gIHJldHVybiB7IGNvdW50OiBjdXJyZW50LCBzdG9wIH07XG59XG5cbmZ1bmN0aW9uIHdhdGNoRGVib3VuY2VkKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZGVib3VuY2UgPSAwLFxuICAgIG1heFdhaXQgPSB2b2lkIDAsXG4gICAgLi4ud2F0Y2hPcHRpb25zXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gd2F0Y2hXaXRoRmlsdGVyKFxuICAgIHNvdXJjZSxcbiAgICBjYixcbiAgICB7XG4gICAgICAuLi53YXRjaE9wdGlvbnMsXG4gICAgICBldmVudEZpbHRlcjogZGVib3VuY2VGaWx0ZXIoZGVib3VuY2UsIHsgbWF4V2FpdCB9KVxuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hEZWVwKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICBjYixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hJZ25vcmFibGUoc291cmNlLCBjYiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBldmVudEZpbHRlciA9IGJ5cGFzc0ZpbHRlcixcbiAgICAuLi53YXRjaE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZpbHRlcmVkQ2IgPSBjcmVhdGVGaWx0ZXJXcmFwcGVyKFxuICAgIGV2ZW50RmlsdGVyLFxuICAgIGNiXG4gICk7XG4gIGxldCBpZ25vcmVVcGRhdGVzO1xuICBsZXQgaWdub3JlUHJldkFzeW5jVXBkYXRlcztcbiAgbGV0IHN0b3A7XG4gIGlmICh3YXRjaE9wdGlvbnMuZmx1c2ggPT09IFwic3luY1wiKSB7XG4gICAgY29uc3QgaWdub3JlID0gcmVmKGZhbHNlKTtcbiAgICBpZ25vcmVQcmV2QXN5bmNVcGRhdGVzID0gKCkgPT4ge1xuICAgIH07XG4gICAgaWdub3JlVXBkYXRlcyA9ICh1cGRhdGVyKSA9PiB7XG4gICAgICBpZ25vcmUudmFsdWUgPSB0cnVlO1xuICAgICAgdXBkYXRlcigpO1xuICAgICAgaWdub3JlLnZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICBzdG9wID0gd2F0Y2goXG4gICAgICBzb3VyY2UsXG4gICAgICAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWlnbm9yZS52YWx1ZSlcbiAgICAgICAgICBmaWx0ZXJlZENiKC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHdhdGNoT3B0aW9uc1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGlzcG9zYWJsZXMgPSBbXTtcbiAgICBjb25zdCBpZ25vcmVDb3VudGVyID0gcmVmKDApO1xuICAgIGNvbnN0IHN5bmNDb3VudGVyID0gcmVmKDApO1xuICAgIGlnbm9yZVByZXZBc3luY1VwZGF0ZXMgPSAoKSA9PiB7XG4gICAgICBpZ25vcmVDb3VudGVyLnZhbHVlID0gc3luY0NvdW50ZXIudmFsdWU7XG4gICAgfTtcbiAgICBkaXNwb3NhYmxlcy5wdXNoKFxuICAgICAgd2F0Y2goXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN5bmNDb3VudGVyLnZhbHVlKys7XG4gICAgICAgIH0sXG4gICAgICAgIHsgLi4ud2F0Y2hPcHRpb25zLCBmbHVzaDogXCJzeW5jXCIgfVxuICAgICAgKVxuICAgICk7XG4gICAgaWdub3JlVXBkYXRlcyA9ICh1cGRhdGVyKSA9PiB7XG4gICAgICBjb25zdCBzeW5jQ291bnRlclByZXYgPSBzeW5jQ291bnRlci52YWx1ZTtcbiAgICAgIHVwZGF0ZXIoKTtcbiAgICAgIGlnbm9yZUNvdW50ZXIudmFsdWUgKz0gc3luY0NvdW50ZXIudmFsdWUgLSBzeW5jQ291bnRlclByZXY7XG4gICAgfTtcbiAgICBkaXNwb3NhYmxlcy5wdXNoKFxuICAgICAgd2F0Y2goXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBpZ25vcmUgPSBpZ25vcmVDb3VudGVyLnZhbHVlID4gMCAmJiBpZ25vcmVDb3VudGVyLnZhbHVlID09PSBzeW5jQ291bnRlci52YWx1ZTtcbiAgICAgICAgICBpZ25vcmVDb3VudGVyLnZhbHVlID0gMDtcbiAgICAgICAgICBzeW5jQ291bnRlci52YWx1ZSA9IDA7XG4gICAgICAgICAgaWYgKGlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmaWx0ZXJlZENiKC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICB3YXRjaE9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICAgIHN0b3AgPSAoKSA9PiB7XG4gICAgICBkaXNwb3NhYmxlcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBzdG9wLCBpZ25vcmVVcGRhdGVzLCBpZ25vcmVQcmV2QXN5bmNVcGRhdGVzIH07XG59XG5cbmZ1bmN0aW9uIHdhdGNoSW1tZWRpYXRlKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdhdGNoKFxuICAgIHNvdXJjZSxcbiAgICBjYixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiB3YXRjaE9uY2Uoc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBjb25zdCBzdG9wID0gd2F0Y2goc291cmNlLCAoLi4uYXJncykgPT4ge1xuICAgIG5leHRUaWNrKCgpID0+IHN0b3AoKSk7XG4gICAgcmV0dXJuIGNiKC4uLmFyZ3MpO1xuICB9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbmZ1bmN0aW9uIHdhdGNoVGhyb3R0bGVkKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGhyb3R0bGUgPSAwLFxuICAgIHRyYWlsaW5nID0gdHJ1ZSxcbiAgICBsZWFkaW5nID0gdHJ1ZSxcbiAgICAuLi53YXRjaE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiB3YXRjaFdpdGhGaWx0ZXIoXG4gICAgc291cmNlLFxuICAgIGNiLFxuICAgIHtcbiAgICAgIC4uLndhdGNoT3B0aW9ucyxcbiAgICAgIGV2ZW50RmlsdGVyOiB0aHJvdHRsZUZpbHRlcih0aHJvdHRsZSwgdHJhaWxpbmcsIGxlYWRpbmcpXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiB3YXRjaFRyaWdnZXJhYmxlKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgY2xlYW51cEZuO1xuICBmdW5jdGlvbiBvbkVmZmVjdCgpIHtcbiAgICBpZiAoIWNsZWFudXBGbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IGNsZWFudXBGbjtcbiAgICBjbGVhbnVwRm4gPSB2b2lkIDA7XG4gICAgZm4oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkNsZWFudXAoY2FsbGJhY2spIHtcbiAgICBjbGVhbnVwRm4gPSBjYWxsYmFjaztcbiAgfVxuICBjb25zdCBfY2IgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgb25FZmZlY3QoKTtcbiAgICByZXR1cm4gY2IodmFsdWUsIG9sZFZhbHVlLCBvbkNsZWFudXApO1xuICB9O1xuICBjb25zdCByZXMgPSB3YXRjaElnbm9yYWJsZShzb3VyY2UsIF9jYiwgb3B0aW9ucyk7XG4gIGNvbnN0IHsgaWdub3JlVXBkYXRlcyB9ID0gcmVzO1xuICBjb25zdCB0cmlnZ2VyID0gKCkgPT4ge1xuICAgIGxldCByZXMyO1xuICAgIGlnbm9yZVVwZGF0ZXMoKCkgPT4ge1xuICAgICAgcmVzMiA9IF9jYihnZXRXYXRjaFNvdXJjZXMoc291cmNlKSwgZ2V0T2xkVmFsdWUoc291cmNlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlczI7XG4gIH07XG4gIHJldHVybiB7XG4gICAgLi4ucmVzLFxuICAgIHRyaWdnZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFdhdGNoU291cmNlcyhzb3VyY2VzKSB7XG4gIGlmIChpc1JlYWN0aXZlKHNvdXJjZXMpKVxuICAgIHJldHVybiBzb3VyY2VzO1xuICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VzKSlcbiAgICByZXR1cm4gc291cmNlcy5tYXAoKGl0ZW0pID0+IHRvVmFsdWUoaXRlbSkpO1xuICByZXR1cm4gdG9WYWx1ZShzb3VyY2VzKTtcbn1cbmZ1bmN0aW9uIGdldE9sZFZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlLm1hcCgoKSA9PiB2b2lkIDApIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiB3aGVuZXZlcihzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3AgPSB3YXRjaChcbiAgICBzb3VyY2UsXG4gICAgKHYsIG92LCBvbkludmFsaWRhdGUpID0+IHtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uY2UpXG4gICAgICAgICAgbmV4dFRpY2soKCkgPT4gc3RvcCgpKTtcbiAgICAgICAgY2Iodiwgb3YsIG9uSW52YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgb25jZTogZmFsc2VcbiAgICB9XG4gICk7XG4gIHJldHVybiBzdG9wO1xufVxuXG5leHBvcnQgeyBhc3NlcnQsIHJlZkF1dG9SZXNldCBhcyBhdXRvUmVzZXRSZWYsIGJ5cGFzc0ZpbHRlciwgY2FtZWxpemUsIGNsYW1wLCBjb21wdXRlZEVhZ2VyLCBjb21wdXRlZFdpdGhDb250cm9sLCBjb250YWluc1Byb3AsIGNvbXB1dGVkV2l0aENvbnRyb2wgYXMgY29udHJvbGxlZENvbXB1dGVkLCBjb250cm9sbGVkUmVmLCBjcmVhdGVFdmVudEhvb2ssIGNyZWF0ZUZpbHRlcldyYXBwZXIsIGNyZWF0ZUdsb2JhbFN0YXRlLCBjcmVhdGVJbmplY3Rpb25TdGF0ZSwgcmVhY3RpZnkgYXMgY3JlYXRlUmVhY3RpdmVGbiwgY3JlYXRlU2hhcmVkQ29tcG9zYWJsZSwgY3JlYXRlU2luZ2xldG9uUHJvbWlzZSwgZGVib3VuY2VGaWx0ZXIsIHJlZkRlYm91bmNlZCBhcyBkZWJvdW5jZWRSZWYsIHdhdGNoRGVib3VuY2VkIGFzIGRlYm91bmNlZFdhdGNoLCBkaXJlY3RpdmVIb29rcywgY29tcHV0ZWRFYWdlciBhcyBlYWdlckNvbXB1dGVkLCBleHRlbmRSZWYsIGZvcm1hdERhdGUsIGdldCwgZ2V0TGlmZUN5Y2xlVGFyZ2V0LCBoYXNPd24sIGh5cGhlbmF0ZSwgaWRlbnRpdHksIHdhdGNoSWdub3JhYmxlIGFzIGlnbm9yYWJsZVdhdGNoLCBpbmNyZWFzZVdpdGhVbml0LCBpbmplY3RMb2NhbCwgaW52b2tlLCBpc0NsaWVudCwgaXNEZWYsIGlzRGVmaW5lZCwgaXNJT1MsIGlzT2JqZWN0LCBpc1dvcmtlciwgbWFrZURlc3RydWN0dXJhYmxlLCBub29wLCBub3JtYWxpemVEYXRlLCBub3ROdWxsaXNoLCBub3csIG9iamVjdEVudHJpZXMsIG9iamVjdE9taXQsIG9iamVjdFBpY2ssIHBhdXNhYmxlRmlsdGVyLCB3YXRjaFBhdXNhYmxlIGFzIHBhdXNhYmxlV2F0Y2gsIHByb21pc2VUaW1lb3V0LCBwcm92aWRlTG9jYWwsIHJhbmQsIHJlYWN0aWZ5LCByZWFjdGlmeU9iamVjdCwgcmVhY3RpdmVDb21wdXRlZCwgcmVhY3RpdmVPbWl0LCByZWFjdGl2ZVBpY2ssIHJlZkF1dG9SZXNldCwgcmVmRGVib3VuY2VkLCByZWZEZWZhdWx0LCByZWZUaHJvdHRsZWQsIHJlZldpdGhDb250cm9sLCByZXNvbHZlUmVmLCByZXNvbHZlVW5yZWYsIHNldCwgc3luY1JlZiwgc3luY1JlZnMsIHRocm90dGxlRmlsdGVyLCByZWZUaHJvdHRsZWQgYXMgdGhyb3R0bGVkUmVmLCB3YXRjaFRocm90dGxlZCBhcyB0aHJvdHRsZWRXYXRjaCwgdGltZXN0YW1wLCB0b1JlYWN0aXZlLCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cnlPbkJlZm9yZU1vdW50LCB0cnlPbkJlZm9yZVVubW91bnQsIHRyeU9uTW91bnRlZCwgdHJ5T25TY29wZURpc3Bvc2UsIHRyeU9uVW5tb3VudGVkLCB1bnRpbCwgdXNlQXJyYXlEaWZmZXJlbmNlLCB1c2VBcnJheUV2ZXJ5LCB1c2VBcnJheUZpbHRlciwgdXNlQXJyYXlGaW5kLCB1c2VBcnJheUZpbmRJbmRleCwgdXNlQXJyYXlGaW5kTGFzdCwgdXNlQXJyYXlJbmNsdWRlcywgdXNlQXJyYXlKb2luLCB1c2VBcnJheU1hcCwgdXNlQXJyYXlSZWR1Y2UsIHVzZUFycmF5U29tZSwgdXNlQXJyYXlVbmlxdWUsIHVzZUNvdW50ZXIsIHVzZURhdGVGb3JtYXQsIHJlZkRlYm91bmNlZCBhcyB1c2VEZWJvdW5jZSwgdXNlRGVib3VuY2VGbiwgdXNlSW50ZXJ2YWwsIHVzZUludGVydmFsRm4sIHVzZUxhc3RDaGFuZ2VkLCByZWZUaHJvdHRsZWQgYXMgdXNlVGhyb3R0bGUsIHVzZVRocm90dGxlRm4sIHVzZVRpbWVvdXQsIHVzZVRpbWVvdXRGbiwgdXNlVG9OdW1iZXIsIHVzZVRvU3RyaW5nLCB1c2VUb2dnbGUsIHdhdGNoQXJyYXksIHdhdGNoQXRNb3N0LCB3YXRjaERlYm91bmNlZCwgd2F0Y2hEZWVwLCB3YXRjaElnbm9yYWJsZSwgd2F0Y2hJbW1lZGlhdGUsIHdhdGNoT25jZSwgd2F0Y2hQYXVzYWJsZSwgd2F0Y2hUaHJvdHRsZWQsIHdhdGNoVHJpZ2dlcmFibGUsIHdhdGNoV2l0aEZpbHRlciwgd2hlbmV2ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vueuse/shared/index.mjs\n"));

/***/ }),

/***/ "./node_modules/@vueuse/shared/node_modules/vue-demi/lib/index.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@vueuse/shared/node_modules/vue-demi/lib/index.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vue: function() { return /* reexport module object */ vue__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   Vue2: function() { return /* binding */ Vue2; },\n/* harmony export */   del: function() { return /* binding */ del; },\n/* harmony export */   install: function() { return /* binding */ install; },\n/* harmony export */   isVue2: function() { return /* binding */ isVue2; },\n/* harmony export */   isVue3: function() { return /* binding */ isVue3; },\n/* harmony export */   set: function() { return /* binding */ set; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in vue__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"set\",\"del\",\"Vue\",\"Vue2\",\"isVue2\",\"isVue3\",\"install\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return vue__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nfunction set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nfunction del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZXVzZS9zaGFyZWQvbm9kZV9tb2R1bGVzL3Z1ZS1kZW1pL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBT2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdnVldXNlL3NoYXJlZC9ub2RlX21vZHVsZXMvdnVlLWRlbWkvbGliL2luZGV4Lm1qcz9iNmQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFZ1ZSBmcm9tICd2dWUnXG5cbnZhciBpc1Z1ZTIgPSBmYWxzZVxudmFyIGlzVnVlMyA9IHRydWVcbnZhciBWdWUyID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIGluc3RhbGwoKSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbClcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgcmV0dXJuIHZhbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSlcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV1cbn1cblxuZXhwb3J0ICogZnJvbSAndnVlJ1xuZXhwb3J0IHtcbiAgVnVlLFxuICBWdWUyLFxuICBpc1Z1ZTIsXG4gIGlzVnVlMyxcbiAgaW5zdGFsbCxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vueuse/shared/node_modules/vue-demi/lib/index.mjs\n"));

/***/ }),

/***/ "./node_modules/@waline/client/dist/shim.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@waline/client/dist/shim.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RecentComments: function() { return /* binding */ aa; },\n/* harmony export */   UserList: function() { return /* binding */ la; },\n/* harmony export */   commentCount: function() { return /* binding */ ze; },\n/* harmony export */   defaultLocales: function() { return /* binding */ ie; },\n/* harmony export */   init: function() { return /* binding */ na; },\n/* harmony export */   pageviewCount: function() { return /* binding */ ta; },\n/* harmony export */   version: function() { return /* binding */ Hn; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var _vueuse_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vueuse/core */ \"./node_modules/@vueuse/core/index.mjs\");\n/* harmony import */ var autosize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! autosize */ \"./node_modules/autosize/dist/autosize.esm.js\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.esm.js\");\nconst V=[\"nick\",\"mail\",\"link\"],D=e=>e.filter((e=>V.includes(e))),N=[\"//unpkg.com/@waline/emojis@1.1.0/weibo\"],B=\"en-US\",W=[\"//unpkg.com/@waline/emojis/tieba/tieba_agree.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_look_down.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_sunglasses.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_pick_nose.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_awkward.png\",\"//unpkg.com/@waline/emojis/tieba/tieba_sleep.png\"],F=e=>new Promise(((t,n)=>{if(e.size>128e3)return n(new Error(\"File too large! File size limit 128KB\"));const a=new FileReader;a.readAsDataURL(e),a.onload=()=>t(a.result?.toString()||\"\"),a.onerror=n})),K=e=>!0===e?'<p class=\"wl-tex\">TeX is not available in preview</p>':'<span class=\"wl-tex\">TeX is not available in preview</span>',q=e=>{const t=async(t,n={})=>fetch(`https://api.giphy.com/v1/gifs/${t}?${new URLSearchParams({lang:e,limit:\"20\",rating:\"g\",api_key:\"6CIMLkNMMOhRcXPoMCPkFy4Ybk2XUiMp\",...n}).toString()}`).then((e=>e.json())).then((({data:e})=>e.map((e=>({title:e.title,src:e.images.downsized_medium.url})))));return{search:e=>t(\"search\",{q:e,offset:\"0\"}),default:()=>t(\"trending\",{}),more:(e,n=0)=>t(\"search\",{q:e,offset:n.toString()})}},G=new RegExp(`(${/[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04FF]+|\\w+/.source}|${/</.source})|((?:${/(?:^|\\s)\\/\\/(.+?)$/gm.source})|(?:${/\\/\\*([\\S\\s]*?)\\*\\//gm.source}))`,\"gmi\"),Z=[\"23AC69\",\"91C132\",\"F19726\",\"E8552D\",\"1AAB8E\",\"E1147F\",\"2980C1\",\"1BA1E6\",\"9FA0A0\",\"F19726\",\"E30B20\",\"E30B20\",\"A3338B\"],J={},Y=e=>{let t=0;return e.replace(G,((e,n,a)=>{if(a)return`<span style=\"color: slategray\">${a}</span>`;if(\"<\"===n)return\"&lt;\";let l;J[n]?l=J[n]:(l=Z[t],J[n]=l);const r=`<span style=\"color: #${l}\">${n}</span>`;return t=++t%Z.length,r}))},X=[\"nick\",\"nickError\",\"mail\",\"mailError\",\"link\",\"optional\",\"placeholder\",\"sofa\",\"submit\",\"like\",\"cancelLike\",\"reply\",\"cancelReply\",\"comment\",\"refresh\",\"more\",\"preview\",\"emoji\",\"uploadImage\",\"seconds\",\"minutes\",\"hours\",\"days\",\"now\",\"uploading\",\"login\",\"logout\",\"admin\",\"sticky\",\"word\",\"wordHint\",\"anonymous\",\"level0\",\"level1\",\"level2\",\"level3\",\"level4\",\"level5\",\"gif\",\"gifSearchPlaceholder\",\"profile\",\"approved\",\"waiting\",\"spam\",\"unsticky\",\"oldest\",\"latest\",\"hottest\",\"reactionTitle\"],Q=e=>Object.fromEntries(e.map(((e,t)=>[X[t],e])));var ee=Q([\"NickName\",\"NickName cannot be less than 3 bytes.\",\"E-Mail\",\"Please confirm your email address.\",\"Website\",\"Optional\",\"Comment here...\",\"No comment yet.\",\"Submit\",\"Like\",\"Cancel like\",\"Reply\",\"Cancel reply\",\"Comments\",\"Refresh\",\"Load More...\",\"Preview\",\"Emoji\",\"Upload Image\",\"seconds ago\",\"minutes ago\",\"hours ago\",\"days ago\",\"just now\",\"Uploading\",\"Login\",\"logout\",\"Admin\",\"Sticky\",\"Words\",\"Please input comments between $0 and $1 words!\\n Current word number: $2\",\"Anonymous\",\"Dwarves\",\"Hobbits\",\"Ents\",\"Wizards\",\"Elves\",\"Maiar\",\"GIF\",\"Search GIF\",\"Profile\",\"Approved\",\"Waiting\",\"Spam\",\"Unsticky\",\"Oldest\",\"Latest\",\"Hottest\",\"What do you think?\"]),te=Q([\"\",\"3.\",\"\",\".\",\"\",\"\",\"\",\"~\",\"\",\"Like\",\"Cancel like\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\" $0  $1 !\\n : $2\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"GIF\",\" GIF\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]),ne=Q([\"Apelido\",\"Apelido no pode ser menor que 3 bytes.\",\"E-Mail\",\"Por favor, confirme seu endereo de e-mail.\",\"Website\",\"Opcional\",\"Comente aqui...\",\"Nenhum comentrio, ainda.\",\"Enviar\",\"Like\",\"Cancel like\",\"Responder\",\"Cancelar resposta\",\"Comentrios\",\"Refrescar\",\"Carregar Mais...\",\"Visualizar\",\"Emoji\",\"Enviar Imagem\",\"segundos atrs\",\"minutos atrs\",\"horas atrs\",\"dias atrs\",\"agora mesmo\",\"Enviando\",\"Entrar\",\"Sair\",\"Admin\",\"Sticky\",\"Palavras\",\"Favor enviar comentrio com $0 a $1 palavras!\\n Nmero de palavras atuais: $2\",\"Annimo\",\"Dwarves\",\"Hobbits\",\"Ents\",\"Wizards\",\"Elves\",\"Maiar\",\"GIF\",\"Pesquisar GIF\",\"informao pessoal\",\"Aprovado\",\"Espera\",\"Spam\",\"Unsticky\",\"Mais velho\",\"Mais recentes\",\"Mais quente\",\"O que voc acha?\"]),ae=Q([\"\",\"     3 .\",\". \",\",     .\",\"-\",\"\",\" ...\",\"  .\",\"\",\"Like\",\"Cancel like\",\"\",\" \",\"\",\"\",\" ...\",\"\",\"\",\" \",\" \",\"  \",\"  \",\" \",\" \",\"\",\"\",\"  \",\"\",\"\",\"\",\",    $0  $1 !\\n  : $2\",\"\",\"Dwarves\",\"Hobbits\",\"Ents\",\"Wizards\",\"Elves\",\"Maiar\",\"GIF\",\" GIF\",\" \",\"\",\"\",\"\",\"\",\" \",\"\",\" \",\"  ?\"]),le=Q([\"\",\"3\",\"\",\"\",\"\",\"\",\"\",\"~\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"...\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\" $0  $1 \\n$2\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]),re=Q([\"\",\"3\",\"\",\"\",\"\",\"\",\"\",\"~\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"...\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\" $0  $1 \\n$2\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]);const ie={zh:le,\"zh-cn\":le,\"zh-CN\":le,\"zh-tw\":re,\"zh-TW\":re,en:ee,\"en-US\":ee,\"en-us\":ee,jp:te,ja:te,\"jp-jp\":te,\"jp-JP\":te,\"pt-br\":ne,\"pt-BR\":ne,ru:ae,\"ru-ru\":ae,\"ru-RU\":ae},oe={\"Content-Type\":\"application/json\"},se=(e,t=\"\")=>{if(\"object\"==typeof e&&e.errno)throw new TypeError(`${t} failed with ${e.errno}: ${e.errmsg}`);return e},ce=({serverURL:e,lang:t,paths:n,type:a,signal:l})=>fetch(`${e}/article?path=${encodeURIComponent(n.join(\",\"))}&type=${encodeURIComponent(a.join(\",\"))}&lang=${t}`,{signal:l}).then((e=>e.json())),ue=({serverURL:e,lang:t,path:n,type:a,action:l})=>fetch(`${e}/article?lang=${t}`,{method:\"POST\",headers:oe,body:JSON.stringify({path:n,type:a,action:l})}).then((e=>e.json())),de=({serverURL:e,lang:t,token:n,objectId:a,comment:l})=>fetch(`${e}/comment/${a}?lang=${t}`,{method:\"PUT\",headers:{...oe,Authorization:`Bearer ${n}`},body:JSON.stringify(l)}).then((e=>e.json())).then((e=>se(e,\"Update comment\"))),ve=e=>{try{e=decodeURI(e)}catch(e){}return e},me=(e=\"\")=>e.replace(/\\/$/u,\"\"),pe=e=>/^(https?:)?\\/\\//.test(e),ge=e=>{const t=me(e);return pe(t)?t:`https://${t}`},he=e=>Array.isArray(e)?e:!!e&&[0,e],fe=(e,t)=>\"function\"==typeof e?e:!1!==e&&t,ye=\"{--waline-white:#000;--waline-light-grey:#666;--waline-dark-grey:#999;--waline-color:#888;--waline-bgcolor:#1e1e1e;--waline-bgcolor-light:#272727;--waline-bgcolor-hover: #444;--waline-border-color:#333;--waline-disable-bgcolor:#444;--waline-disable-color:#272727;--waline-bq-color:#272727;--waline-info-bgcolor:#272727;--waline-info-color:#666}\",we=(e,t)=>{let n=e.toString();for(;n.length<t;)n=\"0\"+n;return n},be=(e,t,n)=>{if(!e)return\"\";const a=\"string\"==typeof e?new Date(-1!==e.indexOf(\" \")?e.replace(/-/g,\"/\"):e):e,l=t.getTime()-a.getTime(),r=Math.floor(l/864e5);if(0===r){const e=l%864e5,t=Math.floor(e/36e5);if(0===t){const t=e%36e5,a=Math.floor(t/6e4);if(0===a){const e=t%6e4;return`${Math.round(e/1e3)} ${n.seconds}`}return`${a} ${n.minutes}`}return`${t} ${n.hours}`}return r<0?n.now:r<8?`${r} ${n.days}`:(e=>{const t=we(e.getDate(),2),n=we(e.getMonth()+1,2);return`${we(e.getFullYear(),2)}-${n}-${t}`})(a)},ke=/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,Ce=e=>{const t=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStorage)(\"WALINE_EMOJI\",{}),n=Boolean(/@[0-9]+\\.[0-9]+\\.[0-9]+/.test(e));if(n){const n=t.value[e];if(n)return Promise.resolve(n)}return fetch(`${e}/info.json`).then((e=>e.json())).then((a=>{const l={folder:e,...a};return n&&(t.value[e]=l),l}))},$e=(e,t=\"\",n=\"\",a=\"\")=>`${t?`${t}/`:\"\"}${n}${e}${a?`.${a}`:\"\"}`,Le=e=>{\"AbortError\"!==e.name&&console.error(e.message)},Re=e=>e instanceof HTMLElement?e:\"string\"==typeof e?document.querySelector(e):null,xe=e=>e.type.includes(\"image\"),Ee=e=>{const t=Array.from(e).find(xe);return t?t.getAsFile():null},Ie=/\\$.*?\\$/,je=/^\\$(.*?)\\$/,Ae=/^(?:\\s{0,3})\\$\\$((?:[^\\n]|\\n[^\\n])+?)\\n{0,1}\\$\\$/,Se=(e=\"\",t={})=>e.replace(/:(.+?):/g,((e,n)=>t[n]?`<img class=\"wl-emoji\" src=\"${t[n]}\" alt=\"${n}\">`:e)),Ue=(e,{emojiMap:t,highlighter:n,texRenderer:a})=>{if(marked__WEBPACK_IMPORTED_MODULE_2__.marked.setOptions({highlight:n||void 0,breaks:!0,smartLists:!0,smartypants:!0}),a){const e=(e=>[{name:\"blockMath\",level:\"block\",tokenizer(t){const n=Ae.exec(t);if(null!==n)return{type:\"html\",raw:n[0],text:e(!0,n[1])}}},{name:\"inlineMath\",level:\"inline\",start(e){const t=e.search(Ie);return-1!==t?t:e.length},tokenizer(t){const n=je.exec(t);if(null!==n)return{type:\"html\",raw:n[0],text:e(!1,n[1])}}}])(a);marked__WEBPACK_IMPORTED_MODULE_2__.marked.use({extensions:e})}return marked__WEBPACK_IMPORTED_MODULE_2__.marked.parse(Se(e,t))},_e=e=>e.dataset.path||e.getAttribute(\"id\"),ze=({serverURL:e,path:t=window.location.pathname,selector:n=\".waline-comment-count\",lang:a=navigator.language})=>{const l=new AbortController,r=document.querySelectorAll(n);return r.length&&(({serverURL:e,lang:t,paths:n,signal:a})=>fetch(`${e}/comment?type=count&url=${encodeURIComponent(n.join(\",\"))}&lang=${t}`,{signal:a}).then((e=>e.json())).then((e=>Array.isArray(e)?e:[e])))({serverURL:ge(e),paths:Array.from(r).map((e=>ve(e.dataset.path||e.getAttribute(\"id\")||t))),lang:a,signal:l.signal}).then((e=>{r.forEach(((t,n)=>{t.innerText=e[n].toString()}))})).catch(Le),l.abort.bind(l)},Me=({size:t})=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{class:\"wl-close-icon\",viewBox:\"0 0 1024 1024\",width:t,height:t},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M697.173 85.333h-369.92c-144.64 0-241.92 101.547-241.92 252.587v348.587c0 150.613 97.28 252.16 241.92 252.16h369.92c144.64 0 241.494-101.547 241.494-252.16V337.92c0-151.04-96.854-252.587-241.494-252.587z\",fill:\"currentColor\"}),(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"m640.683 587.52-75.947-75.861 75.904-75.862a37.29 37.29 0 0 0 0-52.778 37.205 37.205 0 0 0-52.779 0l-75.946 75.818-75.862-75.946a37.419 37.419 0 0 0-52.821 0 37.419 37.419 0 0 0 0 52.821l75.947 75.947-75.776 75.733a37.29 37.29 0 1 0 52.778 52.821l75.776-75.776 75.947 75.947a37.376 37.376 0 0 0 52.779-52.821z\",fill:\"#888\"})]),He=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"m341.013 394.667 27.755 393.45h271.83l27.733-393.45h64.106l-28.01 397.952a64 64 0 0 1-63.83 59.498H368.768a64 64 0 0 1-63.83-59.52l-28.053-397.93h64.128zm139.307 19.818v298.667h-64V414.485h64zm117.013 0v298.667h-64V414.485h64zM181.333 288h640v64h-640v-64zm453.483-106.667v64h-256v-64h256z\",fill:\"red\"})),Te=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z\",fill:\"currentColor\"})),Oe=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z\",fill:\"currentColor\"}),(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z\",fill:\"currentColor\"})]),Pe=({active:t=!1})=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M850.654 323.804c-11.042-25.625-26.862-48.532-46.885-68.225-20.022-19.61-43.258-34.936-69.213-45.73-26.78-11.124-55.124-16.727-84.375-16.727-40.622 0-80.256 11.123-114.698 32.135A214.79 214.79 0 0 0 512 241.819a214.79 214.79 0 0 0-23.483-16.562c-34.442-21.012-74.076-32.135-114.698-32.135-29.25 0-57.595 5.603-84.375 16.727-25.872 10.711-49.19 26.12-69.213 45.73-20.105 19.693-35.843 42.6-46.885 68.225-11.453 26.615-17.303 54.877-17.303 83.963 0 27.439 5.603 56.03 16.727 85.117 9.31 24.307 22.659 49.52 39.715 74.981 27.027 40.293 64.188 82.316 110.33 124.915 76.465 70.615 152.189 119.394 155.402 121.371l19.528 12.525c8.652 5.52 19.776 5.52 28.427 0l19.529-12.525c3.213-2.06 78.854-50.756 155.401-121.371 46.143-42.6 83.304-84.622 110.33-124.915 17.057-25.46 30.487-50.674 39.716-74.981 11.124-29.087 16.727-57.678 16.727-85.117.082-29.086-5.768-57.348-17.221-83.963z\"+(t?\"\":\"M512 761.5S218.665 573.55 218.665 407.767c0-83.963 69.461-152.023 155.154-152.023 60.233 0 112.473 33.618 138.181 82.727 25.708-49.109 77.948-82.727 138.18-82.727 85.694 0 155.155 68.06 155.155 152.023C805.335 573.551 512 761.5 512 761.5z\"),fill:t?\"red\":\"currentColor\"})]),Ve=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0\",fill:\"currentColor\"}),(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0\",fill:\"currentColor\"})]),De=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{width:\"16\",height:\"16\",ariaHidden:\"true\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z\",fill:\"currentColor\"})),Ne=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M810.667 213.333a64 64 0 0 1 64 64V704a64 64 0 0 1-64 64H478.336l-146.645 96.107a21.333 21.333 0 0 1-33.024-17.856V768h-85.334a64 64 0 0 1-64-64V277.333a64 64 0 0 1 64-64h597.334zm0 64H213.333V704h149.334v63.296L459.243 704h351.424V277.333zm-271.36 213.334v64h-176.64v-64h176.64zm122.026-128v64H362.667v-64h298.666z\",fill:\"currentColor\"})),Be=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{viewBox:\"0 0 1024 1024\",width:\"24\",height:\"24\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M813.039 318.772L480.53 651.278H360.718V531.463L693.227 198.961C697.904 194.284 704.027 192 710.157 192C716.302 192 722.436 194.284 727.114 198.961L813.039 284.88C817.72 289.561 820 295.684 820 301.825C820 307.95 817.72 314.093 813.039 318.772ZM710.172 261.888L420.624 551.431V591.376H460.561L750.109 301.825L710.172 261.888ZM490.517 291.845H240.906V771.09H720.156V521.479C720.156 504.947 733.559 491.529 750.109 491.529C766.653 491.529 780.063 504.947 780.063 521.479V791.059C780.063 813.118 762.18 831 740.125 831H220.937C198.882 831 181 813.118 181 791.059V271.872C181 249.817 198.882 231.935 220.937 231.935H490.517C507.06 231.935 520.47 245.352 520.47 261.888C520.47 278.424 507.06 291.845 490.517 291.845Z\",fill:\"currentColor\"})),We=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{class:\"verified-icon\",viewBox:\"0 0 1024 1024\",width:\"14\",height:\"14\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"m894.4 461.56-54.4-63.2c-10.4-12-18.8-34.4-18.8-50.4v-68c0-42.4-34.8-77.2-77.2-77.2h-68c-15.6 0-38.4-8.4-50.4-18.8l-63.2-54.4c-27.6-23.6-72.8-23.6-100.8 0l-62.8 54.8c-12 10-34.8 18.4-50.4 18.4h-69.2c-42.4 0-77.2 34.8-77.2 77.2v68.4c0 15.6-8.4 38-18.4 50l-54 63.6c-23.2 27.6-23.2 72.4 0 100l54 63.6c10 12 18.4 34.4 18.4 50v68.4c0 42.4 34.8 77.2 77.2 77.2h69.2c15.6 0 38.4 8.4 50.4 18.8l63.2 54.4c27.6 23.6 72.8 23.6 100.8 0l63.2-54.4c12-10.4 34.4-18.8 50.4-18.8h68c42.4 0 77.2-34.8 77.2-77.2v-68c0-15.6 8.4-38.4 18.8-50.4l54.4-63.2c23.2-27.6 23.2-73.2-.4-100.8zm-216-25.2-193.2 193.2a30 30 0 0 1-42.4 0l-96.8-96.8a30.16 30.16 0 0 1 0-42.4c11.6-11.6 30.8-11.6 42.4 0l75.6 75.6 172-172c11.6-11.6 30.8-11.6 42.4 0 11.6 11.6 11.6 30.8 0 42.4z\",fill:\"#27ae60\"})),Fe=({size:t=100})=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{width:t,height:t,viewBox:\"0 0 100 100\",preserveAspectRatio:\"xMidYMid\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"circle\",{cx:50,cy:50,fill:\"none\",stroke:\"currentColor\",strokeWidth:\"4\",r:\"40\",\"stroke-dasharray\":\"85 30\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"animateTransform\",{attributeName:\"transform\",type:\"rotate\",repeatCount:\"indefinite\",dur:\"1s\",values:\"0 50 50;360 50 50\",keyTimes:\"0;1\"}))),Ke=()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"svg\",{width:24,height:24,fill:\"currentcolor\",viewBox:\"0 0 24 24\"},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{style:\"transform: translateY(0.5px)\",d:\"M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z\"}),(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(\"path\",{d:\"M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z\"})]);let qe=null;const Ge=()=>qe||(qe=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStorage)(\"WALINE_LIKE\",[]));let Ze=null;const Je=()=>Ze??(Ze=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStorage)(\"WALINE_REACTION\",{}));var Ye=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{},Xe={},Qe={},et={},tt=Ye&&Ye.__awaiter||function(e,t,n,a){return new(n||(n=Promise))((function(l,r){function i(e){try{s(a.next(e))}catch(e){r(e)}}function o(e){try{s(a.throw(e))}catch(e){r(e)}}function s(e){var t;e.done?l(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}s((a=a.apply(e,t||[])).next())}))},nt=Ye&&Ye.__generator||function(e,t){var n,a,l,r,i={label:0,sent:function(){if(1&l[0])throw l[1];return l[1]},trys:[],ops:[]};return r={next:o(0),throw:o(1),return:o(2)},\"function\"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function o(r){return function(o){return function(r){if(n)throw new TypeError(\"Generator is already executing.\");for(;i;)try{if(n=1,a&&(l=2&r[0]?a.return:r[0]?a.throw||((l=a.return)&&l.call(a),0):a.next)&&!(l=l.call(a,r[1])).done)return l;switch(a=0,l&&(r=[2&r[0],l.value]),r[0]){case 0:case 1:l=r;break;case 4:return i.label++,{value:r[1],done:!1};case 5:i.label++,a=r[1],r=[0];continue;case 7:r=i.ops.pop(),i.trys.pop();continue;default:if(!(l=i.trys,(l=l.length>0&&l[l.length-1])||6!==r[0]&&2!==r[0])){i=0;continue}if(3===r[0]&&(!l||r[1]>l[0]&&r[1]<l[3])){i.label=r[1];break}if(6===r[0]&&i.label<l[1]){i.label=l[1],l=r;break}if(l&&i.label<l[2]){i.label=l[2],i.ops.push(r);break}l[2]&&i.ops.pop(),i.trys.pop();continue}r=t.call(e,i)}catch(e){r=[6,e],a=0}finally{n=l=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,o])}}};Object.defineProperty(et,\"__esModule\",{value:!0}),et.ReCaptchaInstance=void 0;var at=function(){function e(e,t,n){this.siteKey=e,this.recaptchaID=t,this.recaptcha=n,this.styleContainer=null}return e.prototype.execute=function(e){return tt(this,void 0,void 0,(function(){return nt(this,(function(t){return[2,this.recaptcha.enterprise?this.recaptcha.enterprise.execute(this.recaptchaID,{action:e}):this.recaptcha.execute(this.recaptchaID,{action:e})]}))}))},e.prototype.getSiteKey=function(){return this.siteKey},e.prototype.hideBadge=function(){null===this.styleContainer&&(this.styleContainer=document.createElement(\"style\"),this.styleContainer.innerHTML=\".grecaptcha-badge{visibility:hidden !important;}\",document.head.appendChild(this.styleContainer))},e.prototype.showBadge=function(){null!==this.styleContainer&&(document.head.removeChild(this.styleContainer),this.styleContainer=null)},e}();et.ReCaptchaInstance=at,Object.defineProperty(Qe,\"__esModule\",{value:!0}),Qe.getInstance=Qe.load=void 0;var lt,rt=et;!function(e){e[e.NOT_LOADED=0]=\"NOT_LOADED\",e[e.LOADING=1]=\"LOADING\",e[e.LOADED=2]=\"LOADED\"}(lt||(lt={}));var it=function(){function e(){}return e.load=function(t,n){if(void 0===n&&(n={}),\"undefined\"==typeof document)return Promise.reject(new Error(\"This is a library for the browser!\"));if(e.getLoadingState()===lt.LOADED)return e.instance.getSiteKey()===t?Promise.resolve(e.instance):Promise.reject(new Error(\"reCAPTCHA already loaded with different site key!\"));if(e.getLoadingState()===lt.LOADING)return t!==e.instanceSiteKey?Promise.reject(new Error(\"reCAPTCHA already loaded with different site key!\")):new Promise((function(t,n){e.successfulLoadingConsumers.push((function(e){return t(e)})),e.errorLoadingRunnable.push((function(e){return n(e)}))}));e.instanceSiteKey=t,e.setLoadingState(lt.LOADING);var a=new e;return new Promise((function(l,r){a.loadScript(t,n.useRecaptchaNet||!1,n.useEnterprise||!1,n.renderParameters?n.renderParameters:{},n.customUrl).then((function(){e.setLoadingState(lt.LOADED);var r=a.doExplicitRender(grecaptcha,t,n.explicitRenderParameters?n.explicitRenderParameters:{},n.useEnterprise||!1),i=new rt.ReCaptchaInstance(t,r,grecaptcha);e.successfulLoadingConsumers.forEach((function(e){return e(i)})),e.successfulLoadingConsumers=[],n.autoHideBadge&&i.hideBadge(),e.instance=i,l(i)})).catch((function(t){e.errorLoadingRunnable.forEach((function(e){return e(t)})),e.errorLoadingRunnable=[],r(t)}))}))},e.getInstance=function(){return e.instance},e.setLoadingState=function(t){e.loadingState=t},e.getLoadingState=function(){return null===e.loadingState?lt.NOT_LOADED:e.loadingState},e.prototype.loadScript=function(t,n,a,l,r){var i=this;void 0===n&&(n=!1),void 0===a&&(a=!1),void 0===l&&(l={}),void 0===r&&(r=\"\");var o=document.createElement(\"script\");o.setAttribute(\"recaptcha-v3-script\",\"\");var s=\"https://www.google.com/recaptcha/api.js\";n&&(s=a?\"https://recaptcha.net/recaptcha/enterprise.js\":\"https://recaptcha.net/recaptcha/api.js\"),a&&(s=\"https://www.google.com/recaptcha/enterprise.js\"),r&&(s=r),l.render&&(l.render=void 0);var c=this.buildQueryString(l);return o.src=s+\"?render=explicit\"+c,new Promise((function(t,n){o.addEventListener(\"load\",i.waitForScriptToLoad((function(){t(o)}),a),!1),o.onerror=function(t){e.setLoadingState(lt.NOT_LOADED),n(t)},document.head.appendChild(o)}))},e.prototype.buildQueryString=function(e){return Object.keys(e).length<1?\"\":\"&\"+Object.keys(e).filter((function(t){return!!e[t]})).map((function(t){return t+\"=\"+e[t]})).join(\"&\")},e.prototype.waitForScriptToLoad=function(t,n){var a=this;return function(){void 0===window.grecaptcha?setTimeout((function(){a.waitForScriptToLoad(t,n)}),e.SCRIPT_LOAD_DELAY):n?window.grecaptcha.enterprise.ready((function(){t()})):window.grecaptcha.ready((function(){t()}))}},e.prototype.doExplicitRender=function(e,t,n,a){var l={sitekey:t,badge:n.badge,size:n.size,tabindex:n.tabindex};return n.container?a?e.enterprise.render(n.container,l):e.render(n.container,l):a?e.enterprise.render(l):e.render(l)},e.loadingState=null,e.instance=null,e.instanceSiteKey=null,e.successfulLoadingConsumers=[],e.errorLoadingRunnable=[],e.SCRIPT_LOAD_DELAY=25,e}();Qe.load=it.load,Qe.getInstance=it.getInstance,function(e){Object.defineProperty(e,\"__esModule\",{value:!0}),e.ReCaptchaInstance=e.getInstance=e.load=void 0;var t=Qe;Object.defineProperty(e,\"load\",{enumerable:!0,get:function(){return t.load}}),Object.defineProperty(e,\"getInstance\",{enumerable:!0,get:function(){return t.getInstance}});var n=et;Object.defineProperty(e,\"ReCaptchaInstance\",{enumerable:!0,get:function(){return n.ReCaptchaInstance}})}(Xe);const ot={};let st=null;const ct=()=>st??(st=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStorage)(\"WALINE_USER\",{})),ut={key:0,class:\"wl-reaction\"},dt=[\"textContent\"],vt={class:\"wl-reaction-list\"},mt=[\"onClick\"],pt={class:\"wl-reaction-img\"},gt=[\"src\",\"alt\"],ht=[\"textContent\"],ft=[\"textContent\"];var yt=(0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({__name:\"ArticleReaction\",setup(e,{expose:t}){t();const y=Je(),w=(0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"config\"),b=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(-1),k=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([]),C=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>w.value.locale)),$=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>w.value.reaction.length>0)),L=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>{const{reaction:e,path:t}=w.value;return e.map(((e,n)=>({icon:e,desc:C.value[`reaction${n}`],active:y.value[t]===n})))}));let R;return (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)((()=>{(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)((()=>[w.value.serverURL,w.value.path]),(()=>{(async()=>{if($.value){const{serverURL:e,lang:t,path:n,reaction:a}=w.value,l=new AbortController;R=l.abort.bind(l);const r=await ce({serverURL:e,lang:t,paths:[n],type:a.map(((e,t)=>`reaction${t}`)),signal:l.signal});if(Array.isArray(r)||\"number\"==typeof r)return;k.value=a.map(((e,t)=>r[`reaction${t}`]))}})()}),{immediate:!0})})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)((()=>R?.())),(e,t)=>L.value.length?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",ut,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",{class:\"wl-reaction-title\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(C.value.reactionTitle)},null,8,dt),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"ul\",vt,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(L.value,(({active:e,icon:t,desc:n},a)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"li\",{key:a,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-reaction-item\",{active:e}]),onClick:e=>(async e=>{if(-1===b.value){const{serverURL:t,lang:n,path:a}=w.value,l=y.value[a];b.value=e,void 0!==l&&(await ue({serverURL:t,lang:n,path:a,type:`reaction${l}`,action:\"desc\"}),k.value[l]=Math.max(k.value[l]-1,0)),l!==e&&(await ue({serverURL:t,lang:n,path:a,type:`reaction${e}`}),k.value[e]=(k.value[e]||0)+1),l===e?delete y.value[a]:y.value[a]=e,b.value=-1}})(a)},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",pt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"img\",{src:t,alt:n},null,8,gt),b.value===a?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Fe),{key:0,class:\"wl-reaction-loading\"})):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:1,class:\"wl-reaction-votes\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(k.value[a]||0)},null,8,ht))]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",{class:\"wl-reaction-text\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(n)},null,8,ft)],10,mt)))),128))])])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)}}),wt=(e,t)=>{const n=e.__vccOpts||e;for(const[e,a]of t)n[e]=a;return n},bt=wt(yt,[[\"__file\",\"ArticleReaction.vue\"]]);const kt=[\"data-index\"],Ct=[\"src\",\"title\",\"onClick\"];var $t=wt((0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({__name:\"ImageWall\",props:{items:{default:()=>[]},columnWidth:{default:300},gap:{default:0}},emits:[\"insert\"],setup(e,{expose:t}){const n=e;t();let l=null;const o=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),d=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({}),p=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([]),k=()=>{const e=Math.floor((o.value.getBoundingClientRect().width+n.gap)/(n.columnWidth+n.gap));return e>0?e:1},C=async e=>{if(e>=n.items.length)return;await (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)();const t=Array.from(o.value?.children||[]).reduce(((e,t)=>t.getBoundingClientRect().height<e.getBoundingClientRect().height?t:e));p.value[Number(t.dataset.index)].push(e),await C(e+1)},$=async(e=!1)=>{if(p.value.length===k()&&!e)return;var t;p.value=(t=k(),new Array(t).fill(null).map((()=>[])));const n=window.scrollY;await C(0),window.scrollTo({top:n})},L=e=>{d.value[e.target.src]=!0};return (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)((()=>{$(!0),l=new ResizeObserver((()=>{$()})),l.observe(o.value),(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)((()=>[n.items]),(()=>{d.value={},$(!0)})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)((()=>[n.columnWidth,n.gap]),(()=>{$()}))})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)((()=>l.unobserve(o.value))),(e,t)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{ref_key:\"wall\",ref:o,class:\"wl-gallery\",style:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({gap:`${e.gap}px`})},[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(p.value,((t,n)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:n,class:\"wl-gallery-column\",\"data-index\":n,style:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({gap:`${e.gap}px`})},[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(t,(t=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,{key:t},[d.value[e.items[t].src]?(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Fe),{key:0,size:36,style:{margin:\"20px auto\"}})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"img\",{class:\"wl-gallery-item\",src:e.items[t].src,title:e.items[t].title,loading:\"lazy\",onLoad:L,onClick:n=>e.$emit(\"insert\",`![](${e.items[t].src})`)},null,40,Ct)],64)))),128))],12,kt)))),128))],4))}}),[[\"__file\",\"ImageWall.vue\"]]);const Lt={class:\"wl-comment\"},Rt={key:0,class:\"wl-login-info\"},xt={class:\"wl-avatar\"},Et=[\"title\"],It=[\"title\"],jt=[\"src\"],At=[\"title\",\"textContent\"],St={class:\"wl-panel\"},Ut=[\"for\",\"textContent\"],_t=[\"id\",\"onUpdate:modelValue\",\"name\",\"type\"],zt=[\"placeholder\"],Mt={class:\"wl-preview\"},Ht=(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"hr\",null,null,-1),Tt=[\"innerHTML\"],Ot={class:\"wl-footer\"},Pt={class:\"wl-actions\"},Vt={href:\"https://guides.github.com/features/mastering-markdown/\",title:\"Markdown Guide\",\"aria-label\":\"Markdown is supported\",class:\"wl-action\",target:\"_blank\",rel:\"noopener noreferrer\"},Dt=[\"title\"],Nt=[\"title\"],Bt=[\"title\"],Wt=[\"title\"],Ft={class:\"wl-info\"},Kt=(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",{class:\"wl-captcha-container\"},null,-1),qt={class:\"wl-text-number\"},Gt={key:0},Zt=[\"textContent\"],Jt=[\"textContent\"],Yt=[\"disabled\"],Xt=[\"placeholder\"],Qt={key:1,class:\"wl-loading\"},en={key:0,class:\"wl-tab-wrapper\"},tn=[\"title\",\"onClick\"],nn=[\"src\",\"alt\"],an={key:0,class:\"wl-tabs\"},ln=[\"onClick\"],rn=[\"src\",\"alt\",\"title\"],on=[\"title\"];var sn=(0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({__name:\"CommentBox\",props:{edit:{default:null},rootId:{default:\"\"},replyId:{default:\"\"},replyUser:{default:\"\"}},emits:[\"log\",\"cancelEdit\",\"cancelReply\",\"submit\"],setup(e,{expose:t,emit:y}){const w=e;t();const b=(0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"config\"),j=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStorage)(\"WALINE_COMMENT_BOX_EDITOR\",\"\"),A=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStorage)(\"WALINE_USER_META\",{nick:\"\",mail:\"\",link:\"\"}),S=ct(),U=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({}),H=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),T=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),P=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),V=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),D=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),N=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),B=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),W=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({tabs:[],map:{}}),F=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0),K=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(!1),q=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(!1),G=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(!1),Z=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(\"\"),J=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0),Y=(0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({loading:!0,list:[]}),X=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0),Q=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(!1),ee=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(\"\"),te=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(!1),ne=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(!1),ae=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>b.value.locale)),le=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>Boolean(S.value?.token))),re=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>!1!==b.value.imageUploader)),ie=e=>{const t=H.value,n=t.selectionStart,a=t.selectionEnd||0,l=t.scrollTop;j.value=t.value.substring(0,n)+e+t.value.substring(a,t.value.length),t.focus(),t.selectionStart=n+e.length,t.selectionEnd=n+e.length,t.scrollTop=l},oe=e=>{const t=e.key;(e.ctrlKey||e.metaKey)&&\"Enter\"===t&&pe()},se=e=>{const t=`![${b.value.locale.uploading} ${e.name}]()`;return ie(t),te.value=!0,Promise.resolve().then((()=>b.value.imageUploader(e))).then((n=>{j.value=j.value.replace(t,`\\r\\n![${e.name}](${n})`)})).catch((e=>{alert(e.message),j.value=j.value.replace(t,\"\")})).then((()=>{te.value=!1}))},ce=e=>{if(e.dataTransfer?.items){const t=Ee(e.dataTransfer.items);t&&re.value&&(se(t),e.preventDefault())}},ue=e=>{if(e.clipboardData){const t=Ee(e.clipboardData.items);t&&re.value&&se(t)}},ve=()=>{const e=T.value;e.files&&re.value&&se(e.files[0]).then((()=>{e.value=\"\"}))},pe=async()=>{const{serverURL:e,lang:t,login:n,wordLimit:a,requiredMeta:l,recaptchaV3Key:r,turnstileKey:i}=b.value,o=await(async()=>{if(!navigator)return\"\";const{userAgentData:e}=navigator;let t=navigator.userAgent;if(!e||\"Windows\"!==e.platform)return t;const{platformVersion:n}=await e.getHighEntropyValues([\"platformVersion\"]);return n?(parseInt(n.split(\".\")[0])>=13&&(t=t.replace(\"Windows NT 10.0\",\"Windows NT 11.0\")),t):t})(),s={comment:ee.value,nick:A.value.nick,mail:A.value.mail,link:A.value.link,url:b.value.path,ua:o};if(S.value?.token)s.nick=S.value.display_name,s.mail=S.value.email,s.link=S.value.url;else{if(\"force\"===n)return;if(l.indexOf(\"nick\")>-1&&!s.nick)return U.value.nick?.focus(),alert(ae.value.nickError);if(l.indexOf(\"mail\")>-1&&!s.mail||s.mail&&(c=s.mail,!ke.test(c)))return U.value.mail?.focus(),alert(ae.value.mailError);s.nick||(s.nick=ae.value.anonymous)}var c;if(s.comment){if(!Q.value)return alert(ae.value.wordHint.replace(\"$0\",a[0].toString()).replace(\"$1\",a[1].toString()).replace(\"$2\",J.value.toString()));s.comment=Se(s.comment,W.value.map),w.replyId&&w.rootId&&(s.pid=w.replyId,s.rid=w.rootId,s.at=w.replyUser),te.value=!0;try{r&&(s.recaptchaV3=await(e=>{const t=ot[e]??(ot[e]=Xe.load(e,{useRecaptchaNet:!0,autoHideBadge:!0}));return{execute:e=>t.then((t=>t.execute(e)))}})(r).execute(\"social\")),i&&(s.turnstile=await(u=i,{execute:async e=>{const{load:t}=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useScriptTag)(\"https://challenges.cloudflare.com/turnstile/v0/api.js\",void 0,{async:!1});await t();const n=window?.turnstile;return new Promise((t=>{n?.ready((()=>{n?.render(\".wl-captcha-container\",{sitekey:u,action:e,size:\"compact\",callback:t})}))}))}}).execute(\"social\"));const n={serverURL:e,lang:t,token:S.value?.token,comment:s},a=await(w.edit?de({objectId:w.edit.objectId,...n}):(({serverURL:e,lang:t,token:n,comment:a})=>{const l={\"Content-Type\":\"application/json\"};return n&&(l.Authorization=`Bearer ${n}`),fetch(`${e}/comment?lang=${t}`,{method:\"POST\",headers:l,body:JSON.stringify(a)}).then((e=>e.json()))})(n));if(te.value=!1,a.errmsg)return alert(a.errmsg);y(\"submit\",a.data),j.value=\"\",Z.value=\"\",w.replyId&&y(\"cancelReply\"),w.edit?.objectId&&y(\"cancelEdit\")}catch(e){te.value=!1,alert(e.message)}var u}else H.value?.focus()},ge=e=>{e.preventDefault();const{lang:t,serverURL:n}=b.value;(({lang:e,serverURL:t})=>{const n=(window.innerWidth-450)/2,a=(window.innerHeight-450)/2,l=window.open(`${t}/ui/login?lng=${encodeURIComponent(e)}`,\"_blank\",`width=450,height=450,left=${n},top=${a},scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no`);return l?.postMessage({type:\"TOKEN\",data:null},\"*\"),new Promise((e=>{const t=({data:n})=>{n&&\"object\"==typeof n&&\"userInfo\"===n.type&&n.data.token&&(l?.close(),window.removeEventListener(\"message\",t),e(n.data))};window.addEventListener(\"message\",t)}))})({serverURL:n,lang:t}).then((e=>{S.value=e,(e.remember?localStorage:sessionStorage).setItem(\"WALINE_USER\",JSON.stringify(e)),y(\"log\")}))},he=()=>{S.value={},localStorage.setItem(\"WALINE_USER\",\"null\"),sessionStorage.setItem(\"WALINE_USER\",\"null\"),y(\"log\")},fe=e=>{e.preventDefault();const{lang:t,serverURL:n}=b.value,a=(window.innerWidth-800)/2,l=(window.innerHeight-800)/2,r=new URLSearchParams({lng:t,token:S.value.token}),i=window.open(`${n}/ui/profile?${r.toString()}`,\"_blank\",`width=800,height=800,left=${a},top=${l},scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no`);i?.postMessage({type:\"TOKEN\",data:S.value.token},\"*\")},ye=e=>{P.value?.contains(e.target)||V.value?.contains(e.target)||(K.value=!1),D.value?.contains(e.target)||N.value?.contains(e.target)||(q.value=!1)},we=async e=>{const{scrollTop:t,clientHeight:n,scrollHeight:a}=e.target,l=(n+t)/a,r=b.value.search,i=B.value?.value||\"\";if(l<.9||Y.loading||ne.value)return;Y.loading=!0;(r.more&&Y.list.length?await r.more(i,Y.list.length):await r.search(i)).length?Y.list=[...Y.list,...r.more&&Y.list.length?await r.more(i,Y.list.length):await r.search(i)]:ne.value=!0,Y.loading=!1,setTimeout((()=>{e.target.scrollTop=t}),50)},be=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useDebounceFn)((e=>{Y.list=[],ne.value=!1,we(e)}),300);(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)([b,J],(([e,t])=>{const{wordLimit:n}=e;n?t<n[0]&&0!==n[0]?(X.value=n[0],Q.value=!1):t>n[1]?(X.value=n[1],Q.value=!1):(X.value=n[1],Q.value=!0):(X.value=0,Q.value=!0)}),{immediate:!0});const Le=({data:e})=>{e&&\"profile\"===e.type&&(S.value={...S.value,...e.data},[localStorage,sessionStorage].filter((e=>e.getItem(\"WALINE_USER\"))).forEach((e=>e.setItem(\"WALINE_USER\",JSON.stringify(S)))))};return (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)((()=>{document.body.addEventListener(\"click\",ye),window.addEventListener(\"message\",Le),w.edit?.objectId&&(j.value=w.edit.orig),(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(q,(async e=>{if(!e)return;const t=b.value.search;B.value&&(B.value.value=\"\"),Y.loading=!0,Y.list=t.default?await t.default():await t.search(\"\"),Y.loading=!1})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)((()=>j.value),(e=>{const{highlighter:t,texRenderer:n}=b.value;ee.value=e,Z.value=Ue(e,{emojiMap:W.value.map,highlighter:t,texRenderer:n}),J.value=(e=>((e=>e.match(/[\\w\\d\\s,.\\u00C0-\\u024F\\u0400-\\u04FF]+/giu))(e)?.reduce(((e,t)=>e+(\"\"===t.trim()?0:t.trim().split(/\\s+/u).length)),0)||0)+((e=>e.match(/[\\u4E00-\\u9FD5]/gu))(e)?.length||0))(e),e?(0,autosize__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(H.value):autosize__WEBPACK_IMPORTED_MODULE_1__[\"default\"].destroy(H.value)}),{immediate:!0}),(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)((()=>b.value.emoji),(e=>{return(t=e,Promise.all(t.map((e=>\"string\"==typeof e?Ce(me(e)):Promise.resolve(e)))).then((e=>{const t={tabs:[],map:{}};return e.forEach((e=>{const{name:n,folder:a,icon:l,prefix:r,type:i,items:o}=e;t.tabs.push({name:n,icon:$e(l,a,r,i),items:o.map((e=>{const n=`${r||\"\"}${e}`;return t.map[n]=$e(e,a,r,i),n}))})})),t}))).then((e=>{W.value=e}));var t}),{immediate:!0})})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)((()=>{document.body.removeEventListener(\"click\",ye),window.removeEventListener(\"message\",Le)})),(e,t)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Lt,[\"disable\"!==(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).login&&le.value&&!e.edit?.objectId?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Rt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",xt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{type:\"submit\",class:\"wl-logout-btn\",title:ae.value.logout,onClick:he},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Me),{size:14})],8,Et),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"a\",{href:\"#\",class:\"wl-login-nick\",\"aria-label\":\"Profile\",title:ae.value.profile,onClick:fe},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"img\",{src:(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(S).avatar,alt:\"avatar\"},null,8,jt)],8,It)]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"a\",{href:\"#\",class:\"wl-login-nick\",\"aria-label\":\"Profile\",title:ae.value.profile,onClick:fe,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(S).display_name)},null,8,At)])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",St,[\"force\"!==(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).login&&(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).meta.length&&!le.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:0,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-header\",`item${(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).meta.length}`])},[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).meta,(e=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:e,class:\"wl-header-item\"},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"label\",{for:`wl-${e}`,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(ae.value[e]+((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).requiredMeta.includes(e)||!(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).requiredMeta.length?\"\":`(${ae.value.optional})`))},null,8,Ut),(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\",{id:`wl-${e}`,ref_for:!0,ref:t=>{t&&(U.value[e]=t)},\"onUpdate:modelValue\":t=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(A)[e]=t,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-input\",`wl-${e}`]),name:e,type:\"mail\"===e?\"email\":\"text\"},null,10,_t),[[vue__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic,(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(A)[e]]])])))),128))],2)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"textarea\",{id:\"wl-edit\",ref_key:\"editorRef\",ref:H,\"onUpdate:modelValue\":t[0]||(t[0]=e=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(j)?j.value=e:null),class:\"wl-editor\",placeholder:e.replyUser?`@${e.replyUser}`:ae.value.placeholder,onKeydown:oe,onDrop:ce,onPaste:ue},null,40,zt),[[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText,(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(j)]]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Mt,[Ht,(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"h4\",null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(ae.value.preview)+\":\",1),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",{class:\"wl-content\",innerHTML:Z.value},null,8,Tt)],512),[[vue__WEBPACK_IMPORTED_MODULE_0__.vShow,G.value]]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Ot,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Pt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"a\",Vt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(De))]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{ref_key:\"emojiButtonRef\",ref:P,type:\"button\",class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-action\",{active:K.value}]),title:ae.value.emoji,onClick:t[1]||(t[1]=e=>K.value=!K.value)},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Te))],10,Dt),[[vue__WEBPACK_IMPORTED_MODULE_0__.vShow,W.value.tabs.length]]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).search?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:0,ref_key:\"gifButtonRef\",ref:D,type:\"button\",class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-action\",{active:q.value}]),title:ae.value.gif,onClick:t[2]||(t[2]=e=>q.value=!q.value)},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Ke))],10,Nt)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\",{id:\"wl-image-upload\",ref_key:\"imageUploadRef\",ref:T,class:\"upload\",type:\"file\",accept:\".png,.jpg,.jpeg,.webp,.bmp,.gif\",onChange:ve},null,544),re.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"label\",{key:1,for:\"wl-image-upload\",class:\"wl-action\",title:ae.value.uploadImage},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Oe))],8,Bt)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{type:\"button\",class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-action\",{active:G.value}]),title:ae.value.preview,onClick:t[3]||(t[3]=e=>G.value=!G.value)},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Ve))],10,Wt)]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Ft,[Kt,(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",qt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(J.value)+\" \",1),(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).wordLimit?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",Gt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(\" / \"),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"span\",{class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)({illegal:!Q.value}),textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(X.value)},null,10,Zt)])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(\" \"+(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(ae.value.word),1)]),\"disable\"===(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).login||le.value?(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:0,type:\"button\",class:\"wl-btn\",onClick:ge,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(ae.value.login)},null,8,Jt)),\"force\"!==(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(b).login||le.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:1,type:\"submit\",class:\"primary wl-btn\",title:\"Cmd|Ctrl + Enter\",disabled:te.value,onClick:pe},[te.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Fe),{key:0,size:16})):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,{key:1},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(ae.value.submit),1)],64))],8,Yt)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",{ref_key:\"gifPopupRef\",ref:N,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-gif-popup\",{display:q.value}])},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\",{ref_key:\"gifSearchInputRef\",ref:B,type:\"text\",placeholder:ae.value.gifSearchPlaceholder,onInput:t[4]||(t[4]=(...e)=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(be)&&(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(be)(...e))},null,40,Xt),Y.list.length?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)($t,{key:0,items:Y.list,\"column-width\":200,gap:6,onInsert:t[5]||(t[5]=e=>ie(e)),onScroll:we},null,8,[\"items\"])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),Y.loading?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Qt,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Fe),{size:30})])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)],2),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",{ref_key:\"emojiPopupRef\",ref:V,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-emoji-popup\",{display:K.value}])},[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(W.value.tabs,((e,t)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,{key:e.name},[t===F.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",en,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(e.items,(e=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:e,type:\"button\",title:e,onClick:t=>ie(`:${e}:`)},[K.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"img\",{key:0,class:\"wl-emoji\",src:W.value.map[e],alt:e,loading:\"lazy\",referrerPolicy:\"no-referrer\"},null,8,nn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)],8,tn)))),128))])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)],64)))),128)),W.value.tabs.length>1?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",an,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(W.value.tabs,((e,t)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:e.name,type:\"button\",class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-tab\",{active:F.value===t}]),onClick:e=>F.value=t},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"img\",{class:\"wl-emoji\",src:e.icon,alt:e.name,title:e.name,loading:\"lazy\",referrerPolicy:\"no-referrer\"},null,8,rn)],10,ln)))),128))])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)],2)])]),e.replyId||e.edit?.objectId?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:1,type:\"button\",class:\"wl-close\",title:ae.value.cancelReply,onClick:t[6]||(t[6]=t=>e.$emit(e.replyId?\"cancelReply\":\"cancelEdit\"))},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Me),{size:24})],8,on)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)]))}}),cn=wt(sn,[[\"__file\",\"CommentBox.vue\"]]);const un=[\"id\"],dn={class:\"wl-user\",\"aria-hidden\":\"true\"},vn=[\"src\"],mn={class:\"wl-card\"},pn={class:\"wl-head\"},gn=[\"href\"],hn={key:1,class:\"wl-nick\"},fn=[\"textContent\"],yn=[\"textContent\"],wn=[\"textContent\"],bn=[\"textContent\"],kn=[\"textContent\"],Cn={class:\"wl-comment-actions\"},$n=[\"title\"],Ln=[\"textContent\"],Rn=[\"title\"],xn={class:\"wl-meta\",\"aria-hidden\":\"true\"},En=[\"data-value\",\"textContent\"],In=[\"data-value\",\"textContent\"],jn=[\"data-value\",\"textContent\"],An=[\"innerHTML\"],Sn={key:1,class:\"wl-admin-actions\"},Un={class:\"wl-comment-status\"},_n=[\"disabled\",\"onClick\",\"textContent\"],zn={key:3,class:\"wl-quote\"};var Mn=wt((0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({__name:\"CommentCard\",props:{comment:{},edit:{default:null},rootId:{},reply:{default:null}},emits:[\"log\",\"submit\",\"delete\",\"edit\",\"like\",\"status\",\"sticky\",\"reply\"],setup(e){const t=e,a=[\"approved\",\"waiting\",\"spam\"],r=(0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"config\"),i=Ge(),o=(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useNow)(),y=ct(),w=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>r.value.locale)),b=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>{const{link:e}=t.comment;return e?pe(e)?e:`https://${e}`:\"\"})),k=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>i.value.includes(t.comment.objectId))),$=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>be(t.comment.insertedAt,o.value,w.value))),L=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>\"administrator\"===y.value.type)),R=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>t.comment.user_id&&y.value.objectId===t.comment.user_id)),x=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>t.comment.objectId===t.reply?.objectId)),E=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>t.comment.objectId===t.edit?.objectId));return(e,t)=>{const n=(0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"CommentCard\",!0);return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{id:e.comment.objectId,class:\"wl-card-item\"},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",dn,[e.comment.avatar?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"img\",{key:0,src:e.comment.avatar},null,8,vn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),e.comment.type?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(We),{key:1})):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",mn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",pn,[b.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"a\",{key:0,class:\"wl-nick\",href:b.value,target:\"_blank\",rel:\"nofollow noopener noreferrer\"},(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.nick),9,gn)):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",hn,(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.nick),1)),\"administrator\"===e.comment.type?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:2,class:\"wl-badge\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(w.value.admin)},null,8,fn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),e.comment.label?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:3,class:\"wl-badge\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.label)},null,8,yn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),e.comment.sticky?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:4,class:\"wl-badge\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(w.value.sticky)},null,8,wn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),void 0!==e.comment.level&&e.comment.level>=0?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:5,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(`wl-badge level${e.comment.level}`),textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(w.value[`level${e.comment.level}`]||`Level ${e.comment.level}`)},null,10,bn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"span\",{class:\"wl-time\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($.value)},null,8,kn),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Cn,[L.value||R.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:0,type:\"button\",class:\"wl-edit\",onClick:t[0]||(t[0]=()=>e.$emit(\"edit\",e.comment))},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Be))])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),L.value||R.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:1,type:\"button\",class:\"wl-delete\",onClick:t[1]||(t[1]=t=>e.$emit(\"delete\",e.comment))},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(He))])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{type:\"button\",class:\"wl-like\",title:k.value?w.value.cancelLike:w.value.like,onClick:t[2]||(t[2]=t=>e.$emit(\"like\",e.comment))},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Pe),{active:k.value},null,8,[\"active\"]),\"like\"in e.comment?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:0,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.like)},null,8,Ln)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)],8,$n),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{type:\"button\",class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([\"wl-reply\",{active:x.value}]),title:x.value?w.value.cancelReply:w.value.reply,onClick:t[3]||(t[3]=t=>e.$emit(\"reply\",x.value?null:e.comment))},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Ne))],10,Rn)])]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",xn,[e.comment.addr?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:0,class:\"wl-addr\",\"data-value\":e.comment.addr,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.addr)},null,8,En)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),e.comment.browser?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:1,class:\"wl-browser\",\"data-value\":e.comment.browser,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.browser)},null,8,In)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),e.comment.os?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:2,class:\"wl-os\",\"data-value\":e.comment.os,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.os)},null,8,jn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)]),E.value?(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:0,class:\"wl-content\",innerHTML:e.comment.comment},null,8,An)),L.value&&!E.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Sn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"span\",Un,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(a,(t=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{key:t,type:\"submit\",class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(`wl-btn wl-${t}`),disabled:e.comment.status===t,onClick:n=>e.$emit(\"status\",{status:t,comment:e.comment}),textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(w.value[t])},null,10,_n))),64))]),L.value&&!e.comment.rid?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\",{key:0,type:\"submit\",class:\"wl-btn wl-sticky\",onClick:t[4]||(t[4]=t=>e.$emit(\"sticky\",e.comment))},(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(e.comment.sticky?w.value.unsticky:w.value.sticky),1)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),x.value||E.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:2,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)({\"wl-reply-wrapper\":x.value,\"wl-edit-wrapper\":E.value})},[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(cn,{edit:e.edit,\"reply-id\":e.reply?.objectId,\"reply-user\":e.comment.nick,\"root-id\":e.rootId,onLog:t[5]||(t[5]=t=>e.$emit(\"log\")),onCancelReply:t[6]||(t[6]=t=>e.$emit(\"reply\",null)),onCancelEdit:t[7]||(t[7]=t=>e.$emit(\"edit\",null)),onSubmit:t[8]||(t[8]=t=>e.$emit(\"submit\",t))},null,8,[\"edit\",\"reply-id\",\"reply-user\",\"root-id\"])],2)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),e.comment.children?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",zn,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(e.comment.children,(a=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(n,{key:a.objectId,comment:a,reply:e.reply,edit:e.edit,\"root-id\":e.rootId,onLog:t[9]||(t[9]=t=>e.$emit(\"log\")),onDelete:t[10]||(t[10]=t=>e.$emit(\"delete\",t)),onEdit:t[11]||(t[11]=t=>e.$emit(\"edit\",t)),onLike:t[12]||(t[12]=t=>e.$emit(\"like\",t)),onReply:t[13]||(t[13]=t=>e.$emit(\"reply\",t)),onStatus:t[14]||(t[14]=t=>e.$emit(\"status\",t)),onSticky:t[15]||(t[15]=t=>e.$emit(\"sticky\",t)),onSubmit:t[16]||(t[16]=t=>e.$emit(\"submit\",t))},null,8,[\"comment\",\"reply\",\"edit\",\"root-id\"])))),128))])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)])],8,un)}}}),[[\"__file\",\"CommentCard.vue\"]]);const Hn=\"2.15.8\",Tn={\"data-waline\":\"\"},On={class:\"wl-meta-head\"},Pn={class:\"wl-count\"},Vn=[\"textContent\"],Dn={class:\"wl-sort\"},Nn=[\"onClick\"],Bn={class:\"wl-cards\"},Wn={key:1,class:\"wl-operation\"},Fn=[\"textContent\"],Kn={key:0,class:\"wl-loading\"},qn=[\"textContent\"],Gn={key:2,class:\"wl-operation\"},Zn=[\"textContent\"],Jn={key:3,class:\"wl-power\"},Yn=(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"a\",{href:\"https://github.com/walinejs/waline\",target:\"_blank\",rel:\"noopener noreferrer\"},\" Waline \",-1);var Xn=(0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({__name:\"WalineComment\",props:[\"serverURL\",\"path\",\"meta\",\"requiredMeta\",\"dark\",\"commentSorting\",\"lang\",\"locale\",\"pageSize\",\"wordLimit\",\"emoji\",\"login\",\"highlighter\",\"texRenderer\",\"imageUploader\",\"search\",\"copyright\",\"recaptchaV3Key\",\"turnstileKey\",\"reaction\"],setup(e){const t=e,n={latest:\"insertedAt_desc\",oldest:\"insertedAt_asc\",hottest:\"like_desc\"},y=Object.keys(n),w=ct(),b=Ge(),k=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(\"loading\"),$=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0),L=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(1),R=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0),x=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>(({serverURL:e,path:t=location.pathname,lang:n=(\"undefined\"==typeof navigator?\"en-US\":navigator.language),locale:a,emoji:l=N,meta:r=[\"nick\",\"mail\",\"link\"],requiredMeta:i=[],dark:o=!1,pageSize:s=10,wordLimit:c,imageUploader:u,highlighter:d,texRenderer:v,copyright:m=!0,login:p=\"enable\",search:g,reaction:h,recaptchaV3Key:f=\"\",turnstileKey:y=\"\",commentSorting:w=\"latest\",...b})=>({serverURL:ge(e),path:ve(t),locale:{...ie[n]||ie[B],...\"object\"==typeof a?a:{}},wordLimit:he(c),meta:D(r),requiredMeta:D(i),imageUploader:fe(u,F),highlighter:fe(d,Y),texRenderer:fe(v,K),lang:Object.keys(ie).includes(n)?n:\"en-US\",dark:o,emoji:\"boolean\"==typeof l?l?N:[]:l,pageSize:s,login:p,copyright:m,search:!1!==g&&(\"object\"==typeof g?g:q(n)),recaptchaV3Key:f,turnstileKey:y,reaction:Array.isArray(h)?h:!0===h?W:[],commentSorting:w,...b}))(t))),E=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(x.value.commentSorting),j=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([]),S=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),U=(0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null),_=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>{return\"string\"==typeof(e=x.value.dark)?\"auto\"===e?`@media(prefers-color-scheme:dark){body${ye}}`:`${e}${ye}`:!0===e?`:root${ye}`:\"\";var e})),z=(0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)((()=>x.value.locale));let M;(0,_vueuse_core__WEBPACK_IMPORTED_MODULE_3__.useStyleTag)(_,{id:\"waline-darkmode\"});const H=e=>{const{serverURL:t,path:a,pageSize:l}=x.value,r=new AbortController;k.value=\"loading\",M?.(),(({serverURL:e,lang:t,path:n,page:a,pageSize:l,sortBy:r,signal:i,token:o})=>{const s={};return o&&(s.Authorization=`Bearer ${o}`),fetch(`${e}/comment?path=${encodeURIComponent(n)}&pageSize=${l}&page=${a}&lang=${t}&sortBy=${r}`,{signal:i,headers:s}).then((e=>e.json())).then((e=>se(e,\"Get comment data\")))})({serverURL:t,lang:x.value.lang,path:a,pageSize:l,sortBy:n[E.value],page:e,signal:r.signal,token:w.value?.token}).then((t=>{k.value=\"success\",$.value=t.count,j.value.push(...t.data),L.value=e,R.value=t.totalPages})).catch((e=>{\"AbortError\"!==e.name&&(console.error(e.message),k.value=\"error\")})),M=r.abort.bind(r)},O=()=>H(L.value+1),P=()=>{$.value=0,j.value=[],H(1)},V=e=>{S.value=e},G=e=>{U.value=e},Z=e=>{if(U.value)U.value.comment=e.comment,U.value.orig=e.orig;else if(e.rid){const t=j.value.find((({objectId:t})=>t===e.rid));if(!t)return;Array.isArray(t.children)||(t.children=[]),t.children.push(e)}else j.value.unshift(e),$.value+=1},J=async({comment:e,status:t})=>{if(e.status===t)return;const{serverURL:n,lang:a}=x.value;await de({serverURL:n,lang:a,token:w.value?.token,objectId:e.objectId,comment:{status:t}}),e.status=t},X=async e=>{if(e.rid)return;const{serverURL:t,lang:n}=x.value;await de({serverURL:t,lang:n,token:w.value?.token,objectId:e.objectId,comment:{sticky:e.sticky?0:1}}),e.sticky=!e.sticky},Q=async({objectId:e})=>{if(!confirm(\"Are you sure you want to delete this comment?\"))return;const{serverURL:t,lang:n}=x.value;await(({serverURL:e,lang:t,token:n,objectId:a})=>fetch(`${e}/comment/${a}?lang=${t}`,{method:\"DELETE\",headers:{Authorization:`Bearer ${n}`}}).then((e=>e.json())).then((e=>se(e,\"Delete comment\"))))({serverURL:t,lang:n,token:w.value?.token,objectId:e}),j.value.some(((t,n)=>t.objectId===e?(j.value=j.value.filter(((e,t)=>t!==n)),!0):t.children.some(((a,l)=>a.objectId===e&&(j.value[n].children=t.children.filter(((e,t)=>t!==l)),!0)))))},ee=async e=>{const{serverURL:t,lang:n}=x.value,{objectId:a}=e,l=b.value.includes(a);await de({serverURL:t,lang:n,objectId:a,token:w.value?.token,comment:{like:!l}}),l?b.value=b.value.filter((e=>e!==a)):(b.value=[...b.value,a],b.value.length>50&&(b.value=b.value.slice(-50))),e.like=(e.like||0)+(l?-1:1)};return (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"config\",x),(0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)((()=>{(0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)((()=>[t.serverURL,t.path]),(()=>P()),{immediate:!0})})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)((()=>M?.())),(e,t)=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Tn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(bt),S.value?(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(cn,{key:0,onLog:P,onSubmit:Z})),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",On,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Pn,[$.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"span\",{key:0,class:\"wl-num\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($.value)},null,8,Vn)):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(\" \"+(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(z.value.comment),1)]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"ul\",Dn,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(y),(e=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"li\",{key:e,class:(0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)([e===E.value?\"active\":\"\"]),onClick:t=>(e=>{E.value!==e&&(E.value=e,P())})(e)},(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(z.value[e]),11,Nn)))),128))])]),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\",Bn,[((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(!0),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,(0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(j.value,(e=>((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(Mn,{key:e.objectId,\"root-id\":e.objectId,comment:e,reply:S.value,edit:U.value,onLog:P,onReply:V,onEdit:G,onSubmit:Z,onStatus:J,onDelete:Q,onSticky:X,onLike:ee},null,8,[\"root-id\",\"comment\",\"reply\",\"edit\"])))),128))]),\"error\"===k.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Wn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{type:\"button\",class:\"wl-btn\",onClick:P,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(z.value.refresh)},null,8,Fn)])):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment,{key:2},[\"loading\"===k.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Kn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Fe),{size:30})])):j.value.length?L.value<R.value?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Gn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\",{type:\"button\",class:\"wl-btn\",onClick:O,textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(z.value.more)},null,8,Zn)])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0):((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",{key:1,class:\"wl-empty\",textContent:(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(z.value.sofa)},null,8,qn))],64)),x.value.copyright?((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(),(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\",Jn,[(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(\" Powered by \"),Yn,(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)(\" v\"+(0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(Hn)),1)])):(0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\",!0)]))}}),Qn=wt(Xn,[[\"__file\",\"WalineComment.vue\"]]);const ea=(e,t)=>{t.forEach(((t,n)=>{t.innerText=e[n].toString()}))},ta=({serverURL:e,path:t=window.location.pathname,selector:n=\".waline-pageview-count\",update:a=!0,lang:l=navigator.language})=>{const r=new AbortController,i=Array.from(document.querySelectorAll(n)),o=e=>{const n=_e(e);return null!==n&&t!==n},s=n=>(({serverURL:e,lang:t,paths:n,signal:a})=>ce({serverURL:e,lang:t,paths:n,type:[\"time\"],signal:a}).then((e=>Array.isArray(e)?e:[e])))({serverURL:ge(e),paths:n.map((e=>_e(e)||t)),lang:l,signal:r.signal}).then((e=>ea(e,n))).catch(Le);if(a){const n=i.filter((e=>!o(e))),a=i.filter(o);(c={serverURL:ge(e),path:t,lang:l},ue({...c,type:\"time\",action:\"inc\"})).then((e=>ea(new Array(n.length).fill(e),n))),a.length&&s(a)}else s(i);var c;return r.abort.bind(r)},na=({el:t=\"#waline\",path:n=window.location.pathname,comment:a=!1,pageview:l=!1,...r})=>{const i=t?Re(t):null;if(t&&!i)throw new Error(\"Option 'el' do not match any domElement!\");if(!r.serverURL)throw new Error(\"Option 'serverURL' is missing!\");const o=(0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({...r}),s=(0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({comment:a,pageview:l,path:n}),c=i?(0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)((()=>(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(Qn,{path:s.path,...o}))):null;c&&c.mount(i);const u=(0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)((()=>{s.comment&&ze({serverURL:o.serverURL,path:s.path,selector:\"string\"==typeof s.comment?s.comment:void 0})})),d=(0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)((()=>{s.pageview&&ta({serverURL:o.serverURL,path:s.path,selector:\"string\"==typeof s.pageview?s.pageview:void 0})}));return{el:i,update:({comment:e,pageview:t,path:n=window.location.pathname,...a}={})=>{Object.entries(a).forEach((([e,t])=>{o[e]=t})),s.path=n,void 0!==e&&(s.comment=e),void 0!==t&&(s.pageview=t)},destroy:()=>{c?.unmount(),u(),d()}}},aa=({el:e,serverURL:t,count:n,lang:a=navigator.language})=>{const l=ct(),r=Re(e),i=new AbortController;return(({serverURL:e,lang:t,count:n,signal:a,token:l})=>{const r={};return l&&(r.Authorization=`Bearer ${l}`),fetch(`${e}/comment?type=recent&count=${n}&lang=${t}`,{signal:a,headers:r}).then((e=>e.json()))})({serverURL:t,count:n,lang:a,signal:i.signal,token:l.value?.token}).then((e=>r&&e.length?(r.innerHTML=`<ul class=\"wl-recent-list\">${e.map((e=>`<li class=\"wl-recent-item\"><a href=\"${e.url}\">${e.nick}</a>${e.comment}</li>`)).join(\"\")}</ul>`,{comments:e,destroy:()=>{i.abort(),r.innerHTML=\"\"}}):{comments:e,destroy:()=>i.abort()}))},la=({el:e,serverURL:t,count:n,locale:a,lang:l=navigator.language,mode:r=\"list\"})=>{const i=Re(e),o=new AbortController;return(({serverURL:e,signal:t,pageSize:n,lang:a})=>fetch(`${e}/user?pageSize=${n}&lang=${a}`,{signal:t}).then((e=>e.json())).then((e=>se(e,\"user list\"))).then((e=>e.data)))({serverURL:t,pageSize:n,lang:l,signal:o.signal}).then((e=>i&&e.length?(a={...ie[l]||ie[B],...\"object\"==typeof a?a:{}},i.innerHTML=`<ul class=\"wl-user-${r}\">${e.map(((e,t)=>[`<li class=\"wl-user-item\" aria-label=\"${e.nick}\">`,e.link&&`<a href=\"${e.link}\" target=\"_blank\">`,'<div class=\"wl-user-avatar\">',`<img src=\"${e.avatar}\" alt=\"${e.nick}\">`,`<span class=\"wl-user-badge\">${t+1}</span>`,\"</div>\",'<div class=\"wl-user-meta\">','<div class=\"wl-user-name\">',e.nick,e.level&&`<span class=\"wl-badge\">${a?a[`level${e.level}`]:`Level ${e.level}`}</span>`,e.label&&`<span class=\"wl-badge\">${e.label}</span>`,\"</div>\",e.link&&e.link,\"</div>\",e.link&&\"</a>\",\"</li>\"].filter((e=>e)).join(\"\"))).join(\"\")}</ul>`,{users:e,destroy:()=>{o.abort(),i.innerHTML=\"\"}}):{users:e,destroy:()=>o.abort()}))};\n//# sourceMappingURL=shim.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHdhbGluZS9jbGllbnQvZGlzdC9zaGltLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFvdEIsdWRBQXVkLDZFQUE2RSx1QkFBdUIsd0VBQXdFLDJJQUEySSxvQkFBb0IsMENBQTBDLEVBQUUsR0FBRyxxQkFBcUIsNkVBQTZFLGFBQWEsK0JBQStCLE9BQU8sZUFBZSxnREFBZ0QsTUFBTSxPQUFPLHNCQUFzQixlQUFlLDZCQUE2Qiw0QkFBNEIsd0JBQXdCLEdBQUcsa0JBQWtCLCtGQUErRixHQUFHLFdBQVcsUUFBUSw4QkFBOEIsT0FBTyw4QkFBOEIsd0lBQXdJLE9BQU8sUUFBUSw4QkFBOEIsNkNBQTZDLEVBQUUsU0FBUyxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixnQ0FBZ0MsRUFBRSxJQUFJLEVBQUUsU0FBUyx3QkFBd0IsR0FBRyx1aEJBQXVoQix5dkdBQXl2RyxVQUFVLGtLQUFrSyxLQUFLLGtDQUFrQyxlQUFlLHNEQUFzRCxHQUFHLGNBQWMsUUFBUSxJQUFJLFNBQVMsR0FBRyxTQUFTLE1BQU0sMkNBQTJDLFlBQVksRUFBRSxnQkFBZ0IsZ0NBQWdDLFFBQVEsZ0NBQWdDLFFBQVEsRUFBRSxHQUFHLFNBQVMsMkJBQTJCLDBDQUEwQyxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyw4Q0FBOEMsdUJBQXVCLEVBQUUsMkJBQTJCLGdEQUFnRCxZQUFZLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxHQUFHLHNCQUFzQiw4QkFBOEIsRUFBRSxFQUFFLHdCQUF3QiwrREFBK0QsSUFBSSxlQUFlLFVBQVUsU0FBUyx3RUFBd0UsY0FBYywwQkFBMEIsRUFBRSxFQUFFLHFGQUFxRixvQkFBb0IseUJBQXlCLHdCQUF3QixvQkFBb0IseUJBQXlCLCtCQUErQiw2QkFBNkIsMkJBQTJCLDhCQUE4QiwrQkFBK0IsMEJBQTBCLDhCQUE4Qix5QkFBeUIsYUFBYSxtQkFBbUIsS0FBSyxXQUFXLFNBQVMsU0FBUyxjQUFjLGVBQWUsaUlBQWlJLFVBQVUscUNBQXFDLFVBQVUsbUNBQW1DLFVBQVUsY0FBYyxTQUFTLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxTQUFTLEdBQUcsRUFBRSxVQUFVLEVBQUUsU0FBUyxHQUFHLEVBQUUsUUFBUSxFQUFFLHdCQUF3QixHQUFHLEVBQUUsT0FBTyxPQUFPLGlEQUFpRCxTQUFTLHNCQUFzQixHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsS0FBSyxnQ0FBZ0MsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSyx5QkFBeUIsUUFBUSx3REFBQyxrQkFBa0IsK0NBQStDLE1BQU0sbUJBQW1CLCtCQUErQixnQkFBZ0IsRUFBRSwyQ0FBMkMsU0FBUyxlQUFlLDJCQUEyQixHQUFHLDJCQUEyQixLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssU0FBUyxnREFBZ0QsMEhBQTBILCtCQUErQiw0QkFBNEIseUNBQXlDLElBQUksNkJBQTZCLElBQUksbUJBQW1CLG1FQUFtRSxLQUFLLFNBQVMsRUFBRSxlQUFlLHVDQUF1QyxJQUFJLEdBQUcsMENBQUMsYUFBYSwyREFBMkQsS0FBSyxjQUFjLDRDQUE0QyxtQkFBbUIsbUJBQW1CLHVDQUF1QyxFQUFFLDBDQUEwQyxxQkFBcUIsd0JBQXdCLGNBQWMsbUJBQW1CLG1CQUFtQix1Q0FBdUMsTUFBTSwwQ0FBQyxNQUFNLGFBQWEsRUFBRSxPQUFPLDBDQUFDLGdCQUFnQixpREFBaUQseUdBQXlHLElBQUksMkRBQTJELG9CQUFvQixvQ0FBb0MsWUFBWSxFQUFFLDBCQUEwQixnQ0FBZ0MsUUFBUSxFQUFFLEdBQUcsU0FBUywwREFBMEQsaUhBQWlILFlBQVksbUJBQW1CLDRCQUE0QixHQUFHLDZCQUE2QixNQUFNLE9BQU8sR0FBRyxzQ0FBQyxRQUFRLCtEQUErRCxFQUFFLHNDQUFDLFNBQVMsb09BQW9PLEVBQUUsc0NBQUMsU0FBUyxzVUFBc1UsV0FBVyxzQ0FBQyxRQUFRLCtDQUErQyxDQUFDLHNDQUFDLFNBQVMsZ1RBQWdULFVBQVUsc0NBQUMsUUFBUSwrQ0FBK0MsQ0FBQyxzQ0FBQyxTQUFTLDRuREFBNG5ELFVBQVUsc0NBQUMsUUFBUSwrQ0FBK0MsRUFBRSxzQ0FBQyxTQUFTLGdQQUFnUCxFQUFFLHNDQUFDLFNBQVMsNGdCQUE0Z0IsU0FBUyxZQUFZLEdBQUcsc0NBQUMsUUFBUSwrQ0FBK0MsRUFBRSxzQ0FBQyxTQUFTLGdvQ0FBZ29DLFdBQVcsc0NBQUMsUUFBUSwrQ0FBK0MsRUFBRSxzQ0FBQyxTQUFTLDhxQkFBOHFCLEVBQUUsc0NBQUMsU0FBUywrZUFBK2UsV0FBVyxzQ0FBQyxRQUFRLHlDQUF5QyxDQUFDLHNDQUFDLFNBQVMsb09BQW9PLFVBQVUsc0NBQUMsUUFBUSwrQ0FBK0MsQ0FBQyxzQ0FBQyxTQUFTLG9WQUFvVixVQUFVLHNDQUFDLFFBQVEsK0NBQStDLENBQUMsc0NBQUMsU0FBUyxndUJBQWd1QixVQUFVLHNDQUFDLFFBQVEscUVBQXFFLENBQUMsc0NBQUMsU0FBUyxxdkJBQXF2QixRQUFRLFdBQVcsR0FBRyxzQ0FBQyxRQUFRLHNFQUFzRSxDQUFDLHNDQUFDLFdBQVcsZ0dBQWdHLENBQUMsc0NBQUMscUJBQXFCLDBGQUEwRix1QkFBdUIsR0FBRyxXQUFXLHNDQUFDLFFBQVEsMkRBQTJELEVBQUUsc0NBQUMsU0FBUyxtaEJBQW1oQixFQUFFLHNDQUFDLFNBQVMsbVVBQW1VLElBQUksWUFBWSxxQkFBcUIsd0RBQUMsb0JBQW9CLFlBQVkscUJBQXFCLHdEQUFDLHFCQUFxQixHQUFHLHFKQUFxSixNQUFNLE1BQU0sTUFBTSx3Q0FBd0MsMENBQTBDLGNBQWMsSUFBSSxhQUFhLFNBQVMsTUFBTSxjQUFjLElBQUksY0FBYyxTQUFTLE1BQU0sY0FBYyxNQUFNLGlFQUFpRSxLQUFLLGNBQWMsK0JBQStCLEdBQUcsc0NBQXNDLGVBQWUsd0JBQXdCLHFCQUFxQixZQUFZLGlCQUFpQixVQUFVLGlDQUFpQywyREFBMkQsWUFBWSxJQUFJLGNBQWMsbUJBQW1CLG1CQUFtQiw0REFBNEQsS0FBSyxFQUFFLEtBQUssa0hBQWtILHlDQUF5QyxrQkFBa0IsTUFBTSx5QkFBeUIsb0JBQW9CLDhCQUE4QixTQUFTLGtDQUFrQyxTQUFTLDBFQUEwRSxJQUFJLFNBQVMseUNBQXlDLGFBQWEsTUFBTSwyQkFBMkIsaUJBQWlCLE1BQU0sb0JBQW9CLDJCQUEyQixNQUFNLCtCQUErQixTQUFTLGNBQWMsU0FBUyxZQUFZLFFBQVEsTUFBTSxxQkFBcUIsT0FBTyxnQ0FBZ0MsV0FBVyx1Q0FBdUMsU0FBUyw4QkFBOEIsa0JBQWtCLGtCQUFrQiw0RUFBNEUsdUNBQXVDLHlDQUF5Qyw0QkFBNEIsdUZBQXVGLFNBQVMsMkNBQTJDLFNBQVMsR0FBRyxHQUFHLEdBQUcsbUNBQW1DLG9CQUFvQixrQ0FBa0Msa0lBQWtJLDhCQUE4QixrREFBa0Qsa0NBQWtDLHNHQUFzRyxHQUFHLEdBQUcsK0RBQStELFNBQVMsZ0NBQWdDLGFBQWEsYUFBYSwrRUFBK0UsV0FBVyxHQUFHLGtCQUFrQixjQUFjLDRCQUE0QixvQkFBb0Isc0dBQXNHLGlMQUFpTCwyS0FBMkssK0NBQStDLFlBQVksNENBQTRDLFlBQVksR0FBRyxHQUFHLGtEQUFrRCxZQUFZLGtDQUFrQyxpR0FBaUcsK0JBQStCLDZCQUE2Qiw4RkFBOEYsaUVBQWlFLGtEQUFrRCxZQUFZLG9GQUFvRixzQkFBc0IsNENBQTRDLFlBQVksa0NBQWtDLEdBQUcsR0FBRywwQkFBMEIsa0JBQWtCLCtCQUErQixpQkFBaUIsOEJBQThCLDBEQUEwRCw0Q0FBNEMsV0FBVyx1REFBdUQscUJBQXFCLHVDQUF1Qyx5Q0FBeUMsZ0RBQWdELCtMQUErTCwrQkFBK0IsK0RBQStELDREQUE0RCxLQUFLLCtCQUErQixzQ0FBc0MsOEJBQThCLEdBQUcsMENBQTBDLHlFQUF5RSxhQUFhLG9CQUFvQixrQkFBa0IsYUFBYSwrQ0FBK0MsV0FBVyxrQkFBa0Isa0RBQWtELDJCQUEyQix3RUFBd0UsSUFBSSx1Q0FBdUMsSUFBSSxJQUFJLGdEQUFnRCxPQUFPLHlEQUF5RCxxSEFBcUgsK0lBQStJLEdBQUcsMERBQTBELHNDQUFzQyxTQUFTLGtEQUFrRCxTQUFTLGdDQUFnQyw2QkFBNkIsZUFBZSx5Q0FBeUMsNkJBQTZCLHNCQUFzQixFQUFFLFNBQVMsNkNBQTZDLDZCQUE2Qiw0QkFBNEIsRUFBRSxLQUFLLFlBQVksWUFBWSxxQkFBcUIsd0RBQUMsaUJBQWlCLE9BQU8sMEJBQTBCLHdCQUF3Qix5QkFBeUIsb0JBQW9CLHdCQUF3Qix3REFBd0QsT0FBTyxvREFBQyxFQUFFLGtDQUFrQyxTQUFTLEVBQUUsSUFBSSxlQUFlLDJDQUFDLGFBQWEsd0NBQUMsT0FBTyx3Q0FBQyxPQUFPLDZDQUFDLHlCQUF5Qiw2Q0FBQyxvQ0FBb0MsNkNBQUMsT0FBTyxNQUFNLGtCQUFrQixTQUFTLHVCQUF1QiwrQkFBK0IsRUFBRSx5QkFBeUIsSUFBSSxHQUFHLE1BQU0sT0FBTyw4Q0FBQyxPQUFPLDBDQUFDLDhDQUE4QyxXQUFXLFlBQVksTUFBTSxxQ0FBcUMsK0JBQStCLGtCQUFrQixrQkFBa0IsMkRBQTJELEVBQUUsb0JBQW9CLEVBQUUsK0NBQStDLG1DQUFtQyxFQUFFLE1BQU0sSUFBSSxHQUFHLGFBQWEsRUFBRSxHQUFHLGdEQUFDLHFDQUFxQyw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsdURBQUMsUUFBUSxzQ0FBc0Msb0RBQUMsd0JBQXdCLFlBQVksdURBQUMsV0FBVyw4Q0FBQyxLQUFLLHVEQUFDLENBQUMseUNBQUMsTUFBTSwrQ0FBQyxZQUFZLHVCQUF1QixNQUFNLDhDQUFDLEdBQUcsdURBQUMsT0FBTyxZQUFZLG1EQUFDLHNCQUFzQixTQUFTLHlCQUF5QixpQkFBaUIsTUFBTSwwQkFBMEIsc0JBQXNCLGlDQUFpQywwQ0FBMEMsRUFBRSxnQkFBZ0IseURBQXlELDBDQUEwQyxFQUFFLEVBQUUsaUZBQWlGLEtBQUssRUFBRSx1REFBQyxXQUFXLHVEQUFDLFFBQVEsWUFBWSx5QkFBeUIsOENBQUMsR0FBRyxnREFBQyxDQUFDLDBDQUFDLE1BQU0sa0NBQWtDLElBQUksOENBQUMsR0FBRyx1REFBQyxRQUFRLDRDQUE0QyxvREFBQyxnQkFBZ0IsZUFBZSx1REFBQyxRQUFRLHFDQUFxQyxvREFBQyxJQUFJLGtDQUFrQyx1REFBQyxhQUFhLGFBQWEsdUJBQXVCLDBCQUEwQixTQUFTLDhDQUE4QyxxREFBcUQsVUFBVSxvREFBQyxFQUFFLDBCQUEwQixPQUFPLGVBQWUsY0FBYyxZQUFZLE1BQU0sV0FBVywyQkFBMkIsU0FBUyxFQUFFLFVBQVUsSUFBSSxXQUFXLFFBQVEsd0NBQUMsU0FBUyx3Q0FBQyxHQUFHLElBQUksd0NBQUMsWUFBWSx3RkFBd0YsZUFBZSxhQUFhLDRCQUE0QixNQUFNLDZDQUFDLEdBQUcsaUlBQWlJLHNEQUFzRCxpQkFBaUIsbUNBQW1DLE1BQU0sc0RBQXNELHVCQUF1Qiw0QkFBNEIsTUFBTSxFQUFFLE9BQU8sMEJBQTBCLE9BQU8sOENBQUMsT0FBTyxpQ0FBaUMsSUFBSSxzQkFBc0IsMENBQUMsdUJBQXVCLFVBQVUsT0FBTyxHQUFHLDBDQUFDLG1DQUFtQyxJQUFJLEdBQUcsR0FBRyxvREFBQyxxQ0FBcUMsOENBQUMsR0FBRyx1REFBQyxRQUFRLDhDQUE4QyxtREFBQyxFQUFFLE9BQU8sTUFBTSxJQUFJLEVBQUUsR0FBRyw4Q0FBQyxLQUFLLHVEQUFDLENBQUMseUNBQUMsTUFBTSwrQ0FBQyxrQkFBa0IsOENBQUMsR0FBRyx1REFBQyxRQUFRLHFEQUFxRCxtREFBQyxFQUFFLE9BQU8sTUFBTSxJQUFJLEVBQUUsR0FBRyw4Q0FBQyxLQUFLLHVEQUFDLENBQUMseUNBQUMsTUFBTSwrQ0FBQyxRQUFRLDhDQUFDLEdBQUcsdURBQUMsQ0FBQyx5Q0FBQyxFQUFFLE1BQU0sMEJBQTBCLHVEQUFDLGFBQWEsOENBQUMsR0FBRyxnREFBQyxDQUFDLDBDQUFDLE1BQU0scUJBQXFCLG9CQUFvQixHQUFHLHVEQUFDLFFBQVEsNkhBQTZILGVBQWUsSUFBSSxrREFBa0QsZ0NBQWdDLFVBQVUsbUJBQW1CLEtBQUssNEJBQTRCLEtBQUssa0JBQWtCLHFFQUFxRSxpQkFBaUIsK0ZBQStGLG1CQUFtQixJQUFJLHVEQUFDLHlDQUF5QyxrQkFBa0IsS0FBSyxtQkFBbUIsS0FBSyxzTEFBc0wseURBQXlELGdCQUFnQixJQUFJLHVEQUFDLFFBQVEsNkJBQTZCLGNBQWMsdUJBQXVCLEtBQUssTUFBTSw4RUFBOEUseUJBQXlCLEtBQUssNkJBQTZCLDZDQUE2QyxzQkFBc0Isc0RBQXNELE9BQU8sb0RBQUMsRUFBRSwyQkFBMkIsTUFBTSxhQUFhLFNBQVMsV0FBVyxVQUFVLFdBQVcsWUFBWSxZQUFZLDREQUE0RCxnQkFBZ0IsRUFBRSxVQUFVLElBQUksUUFBUSwyQ0FBQyxhQUFhLHdEQUFDLG1DQUFtQyx3REFBQyxxQkFBcUIsd0JBQXdCLFdBQVcsd0NBQUMsR0FBRyxJQUFJLHdDQUFDLFNBQVMsd0NBQUMsU0FBUyx3Q0FBQyxTQUFTLHdDQUFDLFNBQVMsd0NBQUMsU0FBUyx3Q0FBQyxTQUFTLHdDQUFDLFNBQVMsd0NBQUMsRUFBRSxlQUFlLElBQUksd0NBQUMsTUFBTSx3Q0FBQyxPQUFPLHdDQUFDLE9BQU8sd0NBQUMsT0FBTyx3Q0FBQyxPQUFPLHdDQUFDLE1BQU0sNkNBQUMsRUFBRSxtQkFBbUIsSUFBSSx3Q0FBQyxNQUFNLHdDQUFDLFFBQVEsd0NBQUMsUUFBUSx3Q0FBQyxRQUFRLHdDQUFDLFFBQVEsNkNBQUMsMEJBQTBCLDZDQUFDLG1DQUFtQyw2Q0FBQywwQ0FBMEMscUVBQXFFLG1KQUFtSixRQUFRLGNBQWMsMENBQTBDLFFBQVEsYUFBYSwwQkFBMEIsRUFBRSxPQUFPLEtBQUssMEZBQTBGLG1DQUFtQyxPQUFPLElBQUksRUFBRSxJQUFJLGNBQWMsK0NBQStDLGNBQWMsWUFBWSxHQUFHLFFBQVEsMEJBQTBCLGlDQUFpQyx5Q0FBeUMsUUFBUSxvQkFBb0Isa0NBQWtDLG9CQUFvQixTQUFTLGdCQUFnQiw2Q0FBNkMsV0FBVyxHQUFHLGNBQWMsTUFBTSxzRkFBc0YsMkJBQTJCLHVCQUF1QixNQUFNLGdCQUFnQixXQUFXLDBCQUEwQix1Q0FBdUMsTUFBTSxrQkFBa0IsbURBQW1ELGlHQUFpRyxPQUFPLDhGQUE4RixzRkFBc0YsS0FBSyxzQkFBc0Isd0ZBQXdGLHdIQUF3SCxvQ0FBb0MsTUFBTSxjQUFjLHlJQUF5SSx1SEFBdUgsSUFBSSw0QkFBNEIsaUNBQWlDLG9DQUFvQyxHQUFHLE9BQU8sc0NBQXNDLG1EQUFtRCxrQkFBa0IsTUFBTSxPQUFPLENBQUMsMERBQUMsaUVBQWlFLFNBQVMsRUFBRSxVQUFVLDBCQUEwQix3QkFBd0IsZUFBZSxtQ0FBbUMsNkNBQTZDLEVBQUUsR0FBRyxJQUFJLHFCQUFxQixTQUFTLGtEQUFrRCxvQkFBb0IsOEJBQThCLEtBQUsscUNBQXFDLElBQUksU0FBUyxtQ0FBbUMscUNBQXFDLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLEdBQUcsK0NBQStDLHNCQUFzQixNQUFNLCtDQUErQyx1R0FBdUcsU0FBUyw2QkFBNkIsTUFBTSxzQkFBc0IsUUFBUSxtQkFBbUIsTUFBTSxtQkFBbUIsU0FBUyxHQUFHLG1CQUFtQixJQUFJLGdGQUFnRixFQUFFLGdCQUFnQixzQkFBc0Isd0NBQXdDLEVBQUUsT0FBTyxFQUFFLDBFQUEwRSx1QkFBdUIsdUJBQXVCLHVCQUF1QixVQUFVLE9BQU8sSUFBSSwwSEFBMEgscUNBQXFDLEdBQUcsR0FBRyxtQkFBbUIsWUFBWSxxR0FBcUcsR0FBRyxTQUFTLFVBQVUsa0dBQWtHLFFBQVEsbUJBQW1CLE1BQU0sbUJBQW1CLHlGQUF5RiwwQkFBMEIsbUJBQW1CLEVBQUUsY0FBYyxhQUFhLHdDQUF3QyxFQUFFLE9BQU8sRUFBRSwwRUFBMEUsZ0JBQWdCLGdDQUFnQyxNQUFNLFFBQVEsOElBQThJLGNBQWMsTUFBTSwwQ0FBMEMsMERBQTBELG9DQUFvQyxhQUFhLHFOQUFxTixxQkFBcUIsTUFBTSxJQUFJLDJEQUFDLE1BQU0sNEJBQTRCLE9BQU8sMENBQUMsa0JBQWtCLE1BQU0sWUFBWSxHQUFHLCtIQUErSCxHQUFHLGFBQWEsRUFBRSxXQUFXLE9BQU8sSUFBSSxpQ0FBaUMscUJBQXFCLGdJQUFnSSxPQUFPLDhDQUFDLE9BQU8seUhBQXlILDBDQUFDLGNBQWMsYUFBYSx1QkFBdUIsNEdBQTRHLEdBQUcsMENBQUMsb0JBQW9CLE1BQU0sNEJBQTRCLFNBQVMseUJBQXlCLGlEQUFpRCw2TUFBNk0sb0RBQUMsVUFBVSx3REFBUyxVQUFVLEdBQUcsYUFBYSxFQUFFLDBDQUFDLDBCQUEwQiw4RkFBOEYsU0FBUyxnQkFBZ0Isc0JBQXNCLE1BQU0sK0NBQStDLEdBQUcsYUFBYSx5Q0FBeUMsV0FBVyxNQUFNLEVBQUUsRUFBRSxFQUFFLDhCQUE4QixHQUFHLEVBQUUsS0FBSyxjQUFjLFVBQVUsR0FBRyxNQUFNLEdBQUcsYUFBYSxFQUFFLEdBQUcsZ0RBQUMsT0FBTyx1RkFBdUYsV0FBVyw4Q0FBQyxHQUFHLHVEQUFDLHVCQUF1QiwwQ0FBQyx3Q0FBd0MsOENBQUMsR0FBRyx1REFBQyxXQUFXLHVEQUFDLFdBQVcsdURBQUMsV0FBVyxxRUFBcUUsRUFBRSxnREFBQyxDQUFDLDBDQUFDLE1BQU0sUUFBUSxTQUFTLHVEQUFDLE1BQU0sd0ZBQXdGLEVBQUUsdURBQUMsUUFBUSxJQUFJLDBDQUFDLHdCQUF3QixxQkFBcUIsdURBQUMsTUFBTSxvR0FBb0csb0RBQUMsQ0FBQywwQ0FBQyxrQkFBa0IsZUFBZSx1REFBQyxZQUFZLHVEQUFDLHFCQUFxQiwwQ0FBQyxXQUFXLDBDQUFDLDRCQUE0Qiw4Q0FBQyxHQUFHLHVEQUFDLFFBQVEsWUFBWSxtREFBQyxxQkFBcUIsMENBQUMsZ0JBQWdCLElBQUksR0FBRyw4Q0FBQyxLQUFLLHVEQUFDLENBQUMseUNBQUMsTUFBTSwrQ0FBQyxDQUFDLDBDQUFDLGNBQWMsOENBQUMsR0FBRyx1REFBQyxRQUFRLDZCQUE2QixFQUFFLHVEQUFDLFVBQVUsVUFBVSxFQUFFLGNBQWMsb0RBQUMsY0FBYywwQ0FBQywrQkFBK0IsMENBQUMsK0JBQStCLGtCQUFrQixLQUFLLFlBQVksbURBQUMsQ0FBQyx1REFBQyxVQUFVLFNBQVMsRUFBRSxxQkFBcUIsa0JBQWtCLDBCQUEwQiwwQ0FBQyxlQUFlLG1EQUFDLG1CQUFtQixFQUFFLDBDQUEwQyxlQUFlLDhDQUFDLENBQUMsMENBQUMsMEJBQTBCLHVEQUFDLFlBQVksbURBQUMsQ0FBQyx1REFBQyxhQUFhLDRFQUE0RSwwQ0FBQyxrRUFBa0UsWUFBWSx5REFBeUQsZUFBZSwyQ0FBQyxDQUFDLDBDQUFDLE9BQU8sbURBQUMsQ0FBQyx1REFBQyxjQUFjLHVEQUFDLFdBQVcsb0RBQUMsMEJBQTBCLHVEQUFDLFFBQVEscUNBQXFDLG9CQUFvQixzQ0FBQyxZQUFZLHVEQUFDLFdBQVcsdURBQUMsV0FBVyx1REFBQyxTQUFTLGdEQUFDLENBQUMsMENBQUMsUUFBUSxtREFBQyxDQUFDLHVEQUFDLFdBQVcsbURBQW1ELG1EQUFDLGVBQWUsZUFBZSxpRUFBaUUsRUFBRSxnREFBQyxDQUFDLDBDQUFDLGdCQUFnQixzQ0FBQyx3QkFBd0IsMENBQUMsWUFBWSw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsdURBQXVELG1EQUFDLGVBQWUsZUFBZSwrREFBK0QsRUFBRSxnREFBQyxDQUFDLDBDQUFDLGVBQWUsdURBQUMsWUFBWSx1REFBQyxVQUFVLG9JQUFvSSxxQkFBcUIsOENBQUMsR0FBRyx1REFBQyxVQUFVLHlFQUF5RSxFQUFFLGdEQUFDLENBQUMsMENBQUMsY0FBYyx1REFBQyxZQUFZLHVEQUFDLFdBQVcsb0JBQW9CLG1EQUFDLGVBQWUsZUFBZSxtRUFBbUUsRUFBRSxnREFBQyxDQUFDLDBDQUFDLGdCQUFnQix1REFBQyxjQUFjLHVEQUFDLFdBQVcsb0RBQUMsQ0FBQyxvREFBQyxpQkFBaUIsMENBQUMsZUFBZSw4Q0FBQyxHQUFHLHVEQUFDLFlBQVksb0RBQUMsVUFBVSx1REFBQyxTQUFTLE1BQU0sbURBQUMsRUFBRSxpQkFBaUIsY0FBYyxvREFBQyxVQUFVLGdCQUFnQix1REFBQyxZQUFZLG9EQUFDLE1BQU0sb0RBQUMsaUNBQWlDLDBDQUFDLG9CQUFvQix1REFBQyxhQUFhLDhDQUFDLEdBQUcsdURBQUMsV0FBVywwREFBMEQsb0RBQUMsaUJBQWlCLHVCQUF1QiwwQ0FBQyxxQkFBcUIsOENBQUMsR0FBRyx1REFBQyxXQUFXLGlHQUFpRyxZQUFZLDhDQUFDLEdBQUcsZ0RBQUMsQ0FBQywwQ0FBQyxNQUFNLGNBQWMsSUFBSSw4Q0FBQyxHQUFHLHVEQUFDLENBQUMseUNBQUMsRUFBRSxNQUFNLEVBQUUsb0RBQUMsQ0FBQyxvREFBQyxtQ0FBbUMsdURBQUMsY0FBYyx1REFBQyxRQUFRLGtDQUFrQyxtREFBQyxrQkFBa0IsZ0JBQWdCLEdBQUcsRUFBRSx1REFBQyxVQUFVLG9IQUFvSCwwQ0FBQyxNQUFNLDBDQUFDLFlBQVksNEJBQTRCLDhDQUFDLEdBQUcsZ0RBQUMsS0FBSyx1RkFBdUYsb0JBQW9CLHVEQUFDLHVCQUF1Qiw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsZ0RBQUMsQ0FBQywwQ0FBQyxNQUFNLFFBQVEsS0FBSyx1REFBQyxnQkFBZ0IsdURBQUMsUUFBUSxvQ0FBb0MsbURBQUMsb0JBQW9CLGdCQUFnQixHQUFHLEdBQUcsOENBQUMsS0FBSyx1REFBQyxDQUFDLHlDQUFDLE1BQU0sK0NBQUMsdUJBQXVCLDhDQUFDLEdBQUcsdURBQUMsQ0FBQyx5Q0FBQyxFQUFFLFdBQVcsZUFBZSw4Q0FBQyxHQUFHLHVEQUFDLFlBQVksOENBQUMsS0FBSyx1REFBQyxDQUFDLHlDQUFDLE1BQU0sK0NBQUMsY0FBYyw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsOENBQThDLEVBQUUsSUFBSSxXQUFXLDhDQUFDLEdBQUcsdURBQUMsUUFBUSw0RkFBNEYsYUFBYSx1REFBQywrQkFBK0IsdURBQUMsaURBQWlELDhDQUFDLEdBQUcsdURBQUMsWUFBWSw4Q0FBQyxLQUFLLHVEQUFDLENBQUMseUNBQUMsTUFBTSwrQ0FBQyx1QkFBdUIsOENBQUMsR0FBRyx1REFBQyxXQUFXLCtCQUErQixtREFBQyxZQUFZLG1CQUFtQix3QkFBd0IsRUFBRSx1REFBQyxRQUFRLGdHQUFnRyxnQ0FBZ0MsdURBQUMsaURBQWlELDhDQUFDLEdBQUcsdURBQUMsV0FBVyxzSUFBc0ksRUFBRSxnREFBQyxDQUFDLDBDQUFDLE1BQU0sUUFBUSxVQUFVLHVEQUFDLGdCQUFnQiwwQ0FBMEMsb0JBQW9CLHFDQUFxQyxnQkFBZ0IsZ0JBQWdCLEtBQUssZ0JBQWdCLGlCQUFpQixzQkFBc0Isb0dBQW9HLDJCQUEyQixrREFBa0QscUNBQXFDLHNIQUFzSCwrQkFBK0IsS0FBSywwQkFBMEIsNkNBQTZDLHdCQUF3QixVQUFVLG9EQUFDLEVBQUUsNEJBQTRCLFVBQVUsT0FBTyxhQUFhLFVBQVUsUUFBUSxjQUFjLGtGQUFrRiw0Q0FBNEMsMkNBQUMsb0JBQW9CLG9EQUFDLFlBQVksNkNBQUMseUJBQXlCLDZDQUFDLE9BQU8sTUFBTSxPQUFPLFdBQVcsNEJBQTRCLEVBQUUsS0FBSyxLQUFLLDZDQUFDLCtDQUErQyw2Q0FBQyxtREFBbUQsNkNBQUMseUNBQXlDLDZDQUFDLGtFQUFrRSw2Q0FBQyxpREFBaUQsNkNBQUMsOENBQThDLGNBQWMsUUFBUSxxREFBQyxtQkFBbUIsT0FBTyw4Q0FBQyxHQUFHLHVEQUFDLFFBQVEsMkNBQTJDLEVBQUUsdURBQUMsNkJBQTZCLDhDQUFDLEdBQUcsdURBQUMsUUFBUSwyQkFBMkIsYUFBYSx1REFBQyw0QkFBNEIsOENBQUMsR0FBRyxnREFBQyxDQUFDLDBDQUFDLE1BQU0sTUFBTSxHQUFHLHVEQUFDLGNBQWMsdURBQUMsV0FBVyx1REFBQyxvQkFBb0IsOENBQUMsR0FBRyx1REFBQyxNQUFNLHNGQUFzRixDQUFDLG9EQUFDLHlCQUF5Qiw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsb0RBQUMsdURBQXVELDhDQUFDLEdBQUcsdURBQUMsU0FBUyxtQ0FBbUMsb0RBQUMsZ0JBQWdCLGFBQWEsdURBQUMsNkJBQTZCLDhDQUFDLEdBQUcsdURBQUMsU0FBUyxtQ0FBbUMsb0RBQUMsa0JBQWtCLGFBQWEsdURBQUMsOEJBQThCLDhDQUFDLEdBQUcsdURBQUMsU0FBUyxtQ0FBbUMsb0RBQUMsaUJBQWlCLGFBQWEsdURBQUMsMERBQTBELDhDQUFDLEdBQUcsdURBQUMsU0FBUyxZQUFZLG1EQUFDLGtCQUFrQixnQkFBZ0IsZUFBZSxvREFBQyxpQkFBaUIsZ0JBQWdCLGFBQWEsZ0JBQWdCLEdBQUcsY0FBYyx1REFBQyxZQUFZLHVEQUFDLFNBQVMsNEJBQTRCLG9EQUFDLFVBQVUsWUFBWSx1REFBQyw2QkFBNkIsOENBQUMsR0FBRyx1REFBQyxXQUFXLHVGQUF1RixFQUFFLGdEQUFDLENBQUMsMENBQUMsU0FBUyx1REFBQyw4QkFBOEIsOENBQUMsR0FBRyx1REFBQyxXQUFXLDBGQUEwRixFQUFFLGdEQUFDLENBQUMsMENBQUMsU0FBUyx1REFBQyxZQUFZLHVEQUFDLFdBQVcsOEhBQThILEVBQUUsZ0RBQUMsQ0FBQywwQ0FBQyxNQUFNLGVBQWUsd0NBQXdDLDhDQUFDLEdBQUcsdURBQUMsU0FBUyxrQkFBa0Isb0RBQUMsaUJBQWlCLGFBQWEsdURBQUMsbUJBQW1CLHVEQUFDLFdBQVcsb0JBQW9CLG1EQUFDLGNBQWMsZUFBZSxtSEFBbUgsRUFBRSxnREFBQyxDQUFDLDBDQUFDLGtCQUFrQix1REFBQywyQkFBMkIsOENBQUMsR0FBRyx1REFBQyxTQUFTLDhEQUE4RCxvREFBQyxpQkFBaUIsYUFBYSx1REFBQywrQkFBK0IsOENBQUMsR0FBRyx1REFBQyxTQUFTLG9FQUFvRSxvREFBQyxvQkFBb0IsYUFBYSx1REFBQywwQkFBMEIsOENBQUMsR0FBRyx1REFBQyxTQUFTLDBEQUEwRCxvREFBQyxlQUFlLGFBQWEsdURBQUMsc0JBQXNCLHVEQUFDLGFBQWEsOENBQUMsR0FBRyx1REFBQyxRQUFRLHFEQUFxRCxnQ0FBZ0MsOENBQUMsR0FBRyx1REFBQyxXQUFXLHVEQUFDLGFBQWEsOENBQUMsR0FBRyx1REFBQyxDQUFDLHlDQUFDLE1BQU0sK0NBQUMsT0FBTyx1REFBQyxXQUFXLDBCQUEwQixtREFBQyxjQUFjLEVBQUUsOERBQThELDJCQUEyQixjQUFjLG9EQUFDLGFBQWEsK0NBQStDLDhDQUFDLEdBQUcsdURBQUMsV0FBVyxpR0FBaUcsQ0FBQyxvREFBQyx1REFBdUQsdURBQUMsZUFBZSx1REFBQyw4QkFBOEIsOENBQUMsR0FBRyx1REFBQyxRQUFRLFlBQVksbURBQUMsRUFBRSxxREFBcUQsRUFBRSxFQUFFLGdEQUFDLEtBQUssZ1JBQWdSLHlEQUF5RCx1REFBQyxnQ0FBZ0MsOENBQUMsR0FBRyx1REFBQyxZQUFZLDhDQUFDLEtBQUssdURBQUMsQ0FBQyx5Q0FBQyxNQUFNLCtDQUFDLHlCQUF5Qiw4Q0FBQyxHQUFHLGdEQUFDLElBQUksMGFBQTBhLDBEQUEwRCx1REFBQyx1QkFBdUIsa0NBQWtDLHNCQUFzQixpQkFBaUIsS0FBSyxxQkFBcUIsS0FBSyxpQkFBaUIsd0JBQXdCLGdCQUFnQixvQkFBb0IsaUJBQWlCLEtBQUssMkJBQTJCLHdCQUF3Qix5QkFBeUIsd0JBQXdCLDJCQUEyQix3QkFBd0IsdUJBQXVCLElBQUksdURBQUMsTUFBTSxvRkFBb0YsZ0JBQWdCLE9BQU8sb0RBQUMsRUFBRSw0UUFBNFEsYUFBYSxxRUFBcUUsa0NBQWtDLHdDQUFDLGNBQWMsd0NBQUMsTUFBTSx3Q0FBQyxNQUFNLHdDQUFDLE1BQU0sNkNBQUMsU0FBUyxtWEFBbVgsS0FBSyxtQ0FBbUMsMkNBQTJDLHdXQUF3VyxVQUFVLHdDQUFDLDJCQUEyQix3Q0FBQyxPQUFPLHdDQUFDLFNBQVMsd0NBQUMsU0FBUyw2Q0FBQyxPQUFPLHFGQUFxRixNQUFNLElBQUksS0FBSyxFQUFFLEVBQUUsR0FBRyxpQkFBaUIsR0FBRyxLQUFLLE1BQU0sS0FBSyw2Q0FBQyx1QkFBdUIsTUFBTSx5REFBQyxJQUFJLHFCQUFxQixFQUFFLFlBQVksTUFBTSw4QkFBOEIsK0JBQStCLDJCQUEyQixzRUFBc0UsSUFBSSxXQUFXLHFDQUFxQyxFQUFFLFlBQVksRUFBRSxnQkFBZ0Isc0JBQXNCLFlBQVksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxHQUFHLG1CQUFtQiwwREFBMEQsR0FBRyw4R0FBOEcsWUFBWSx5RkFBeUYsY0FBYyxrRUFBa0UscUJBQXFCLDJCQUEyQiwwQkFBMEIsT0FBTyxVQUFVLE9BQU8sVUFBVSxPQUFPLHlEQUF5RCxlQUFlLHdCQUF3QixXQUFXLGVBQWUsYUFBYSw4REFBOEQsbUNBQW1DLFVBQVUsbUJBQW1CLElBQUksdUJBQXVCLE1BQU0sbUJBQW1CLFNBQVMsVUFBVSxxRUFBcUUsVUFBVSxhQUFhLGFBQWEsZ0JBQWdCLE1BQU0sbUJBQW1CLFNBQVMsVUFBVSxxRUFBcUUscUJBQXFCLHFCQUFxQixVQUFVLFdBQVcsSUFBSSxvRUFBb0UsTUFBTSxtQkFBbUIsU0FBUyxRQUFRLHNDQUFzQyxZQUFZLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxHQUFHLHlCQUF5Qix3QkFBd0IsRUFBRSxHQUFHLDBEQUEwRCxtREFBbUQseUxBQXlMLGNBQWMsTUFBTSxtQkFBbUIsVUFBVSxXQUFXLHlCQUF5QixVQUFVLDREQUE0RCxTQUFTLDZJQUE2SSxPQUFPLDRDQUFDLGFBQWEsOENBQUMsT0FBTywwQ0FBQyx1Q0FBdUMsYUFBYSxFQUFFLEdBQUcsZ0RBQUMsc0JBQXNCLDhDQUFDLEdBQUcsdURBQUMsV0FBVyxnREFBQyxhQUFhLHVEQUFDLGFBQWEsOENBQUMsR0FBRyxnREFBQyxLQUFLLHlCQUF5QixHQUFHLHVEQUFDLFdBQVcsdURBQUMsb0JBQW9CLDhDQUFDLEdBQUcsdURBQUMsU0FBUyxpQ0FBaUMsb0RBQUMsVUFBVSxhQUFhLHVEQUFDLFlBQVksb0RBQUMsS0FBSyxvREFBQyx1QkFBdUIsdURBQUMsV0FBVyw4Q0FBQyxLQUFLLHVEQUFDLENBQUMseUNBQUMsTUFBTSwrQ0FBQyxDQUFDLDBDQUFDLFNBQVMsOENBQUMsR0FBRyx1REFBQyxPQUFPLFlBQVksbURBQUMsNENBQTRDLDZCQUE2QixLQUFLLENBQUMsb0RBQUMsaUNBQWlDLHVEQUFDLFlBQVksOENBQUMsS0FBSyx1REFBQyxDQUFDLHlDQUFDLE1BQU0sK0NBQUMsY0FBYyw4Q0FBQyxHQUFHLGdEQUFDLEtBQUssMEpBQTBKLDRFQUE0RSw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsdURBQUMsV0FBVyxtREFBbUQsb0RBQUMsa0JBQWtCLGdCQUFnQiw4Q0FBQyxHQUFHLHVEQUFDLENBQUMseUNBQUMsRUFBRSxNQUFNLHVCQUF1Qiw4Q0FBQyxHQUFHLHVEQUFDLFdBQVcsZ0RBQUMsQ0FBQywwQ0FBQyxNQUFNLFFBQVEscUNBQXFDLDhDQUFDLEdBQUcsdURBQUMsV0FBVyx1REFBQyxXQUFXLG1EQUFtRCxvREFBQyxlQUFlLGVBQWUsdURBQUMsYUFBYSw4Q0FBQyxHQUFHLHVEQUFDLFFBQVEsbUNBQW1DLG9EQUFDLGVBQWUsc0NBQXNDLDhDQUFDLEdBQUcsdURBQUMsV0FBVyxvREFBQyxvQkFBb0Isb0RBQUMsTUFBTSxvREFBQyxDQUFDLDBDQUFDLFlBQVksdURBQUMsZ0JBQWdCLDZDQUE2QyxpQkFBaUIsbUJBQW1CLDRCQUE0QixHQUFHLE1BQU0sc0hBQXNILElBQUksNkVBQTZFLGNBQWMsdUJBQXVCLFNBQVMsb0NBQW9DLE9BQU8sa0RBQWtELHNDQUFzQyxrRUFBa0UsK0JBQStCLE1BQU0sMkNBQTJDLElBQUksOEJBQThCLEtBQUssOEJBQThCLCtEQUErRCxVQUFVLE1BQU0sdUJBQXVCLE1BQU0sK0VBQStFLElBQUkscUJBQXFCLHFFQUFxRSxrRUFBa0UsUUFBUSw2Q0FBQyxFQUFFLEtBQUssSUFBSSw2Q0FBQyxFQUFFLDRCQUE0QixNQUFNLDhDQUFDLE1BQU0sc0NBQUMsS0FBSyxpQkFBaUIsU0FBUyxjQUFjLFFBQVEsZ0RBQUMsT0FBTyxlQUFlLHVGQUF1RixFQUFFLEtBQUssZ0RBQUMsT0FBTyxnQkFBZ0IseUZBQXlGLEVBQUUsR0FBRyxPQUFPLGNBQWMsMERBQTBELEdBQUcsSUFBSSxxQ0FBcUMsT0FBTyxpRUFBaUUsY0FBYyx1QkFBdUIsTUFBTSxtREFBbUQsSUFBSSwyQ0FBMkMsU0FBUyw0Q0FBNEMsSUFBSSxXQUFXLHFDQUFxQyxFQUFFLFlBQVksRUFBRSw2QkFBNkIsRUFBRSxRQUFRLEVBQUUsR0FBRyxtQkFBbUIsc0JBQXNCLEdBQUcsZ0VBQWdFLGtFQUFrRSxpREFBaUQsTUFBTSxJQUFJLE9BQU8sT0FBTyxVQUFVLGtCQUFrQixRQUFRLHdCQUF3QiwwQkFBMEIsR0FBRyxpQ0FBaUMsR0FBRyxNQUFNLDBFQUEwRSxJQUFJLG9DQUFvQyxTQUFTLHVDQUF1QyxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxFQUFFLEdBQUcsU0FBUyx1RUFBdUUsOENBQThDLDJCQUEyQiwyQ0FBMkMsbUNBQW1DLEVBQUUsSUFBSSx1REFBdUQsT0FBTyx3QkFBd0IsT0FBTyxnRUFBZ0UsU0FBUyxTQUFTLE9BQU8sbUNBQW1DLElBQUksc0hBQXNILFlBQVksUUFBUSxZQUFZLFFBQVEsRUFBRSw0Q0FBNEMsUUFBUSxxR0FBcUcsUUFBUSxxQkFBcUIsMEJBQTBCLEdBQUcsOEJBQThCLElBQXFJO0FBQ2wwdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B3YWxpbmUvY2xpZW50L2Rpc3Qvc2hpbS5tanM/MmU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7aCBhcyBlLGRlZmluZUNvbXBvbmVudCBhcyB0LGluamVjdCBhcyBuLHJlZiBhcyBhLGNvbXB1dGVkIGFzIGwsb25Nb3VudGVkIGFzIHIsd2F0Y2ggYXMgaSxvblVubW91bnRlZCBhcyBvLG9wZW5CbG9jayBhcyBzLGNyZWF0ZUVsZW1lbnRCbG9jayBhcyBjLGNyZWF0ZUVsZW1lbnRWTm9kZSBhcyB1LHRvRGlzcGxheVN0cmluZyBhcyBkLEZyYWdtZW50IGFzIHYscmVuZGVyTGlzdCBhcyBtLG5vcm1hbGl6ZUNsYXNzIGFzIHAsY3JlYXRlQmxvY2sgYXMgZyx1bnJlZiBhcyBoLGNyZWF0ZUNvbW1lbnRWTm9kZSBhcyBmLG9uQmVmb3JlVW5tb3VudCBhcyB5LG5vcm1hbGl6ZVN0eWxlIGFzIHcsbmV4dFRpY2sgYXMgYixyZWFjdGl2ZSBhcyBrLGNyZWF0ZVZOb2RlIGFzIEMsd2l0aERpcmVjdGl2ZXMgYXMgJCx2TW9kZWxEeW5hbWljIGFzIEwsaXNSZWYgYXMgUix2TW9kZWxUZXh0IGFzIHgsdlNob3cgYXMgRSxjcmVhdGVUZXh0Vk5vZGUgYXMgSSxyZXNvbHZlQ29tcG9uZW50IGFzIGoscHJvdmlkZSBhcyBBLGNyZWF0ZUFwcCBhcyBTLHdhdGNoRWZmZWN0IGFzIFV9ZnJvbVwidnVlXCI7aW1wb3J0e3VzZVN0b3JhZ2UgYXMgXyx1c2VTY3JpcHRUYWcgYXMgeix1c2VEZWJvdW5jZUZuIGFzIE0sdXNlTm93IGFzIEgsdXNlU3R5bGVUYWcgYXMgVH1mcm9tXCJAdnVldXNlL2NvcmVcIjtpbXBvcnQgTyBmcm9tXCJhdXRvc2l6ZVwiO2ltcG9ydHttYXJrZWQgYXMgUH1mcm9tXCJtYXJrZWRcIjtjb25zdCBWPVtcIm5pY2tcIixcIm1haWxcIixcImxpbmtcIl0sRD1lPT5lLmZpbHRlcigoZT0+Vi5pbmNsdWRlcyhlKSkpLE49W1wiLy91bnBrZy5jb20vQHdhbGluZS9lbW9qaXNAMS4xLjAvd2VpYm9cIl0sQj1cImVuLVVTXCIsVz1bXCIvL3VucGtnLmNvbS9Ad2FsaW5lL2Vtb2ppcy90aWViYS90aWViYV9hZ3JlZS5wbmdcIixcIi8vdW5wa2cuY29tL0B3YWxpbmUvZW1vamlzL3RpZWJhL3RpZWJhX2xvb2tfZG93bi5wbmdcIixcIi8vdW5wa2cuY29tL0B3YWxpbmUvZW1vamlzL3RpZWJhL3RpZWJhX3N1bmdsYXNzZXMucG5nXCIsXCIvL3VucGtnLmNvbS9Ad2FsaW5lL2Vtb2ppcy90aWViYS90aWViYV9waWNrX25vc2UucG5nXCIsXCIvL3VucGtnLmNvbS9Ad2FsaW5lL2Vtb2ppcy90aWViYS90aWViYV9hd2t3YXJkLnBuZ1wiLFwiLy91bnBrZy5jb20vQHdhbGluZS9lbW9qaXMvdGllYmEvdGllYmFfc2xlZXAucG5nXCJdLEY9ZT0+bmV3IFByb21pc2UoKCh0LG4pPT57aWYoZS5zaXplPjEyOGUzKXJldHVybiBuKG5ldyBFcnJvcihcIkZpbGUgdG9vIGxhcmdlISBGaWxlIHNpemUgbGltaXQgMTI4S0JcIikpO2NvbnN0IGE9bmV3IEZpbGVSZWFkZXI7YS5yZWFkQXNEYXRhVVJMKGUpLGEub25sb2FkPSgpPT50KGEucmVzdWx0Py50b1N0cmluZygpfHxcIlwiKSxhLm9uZXJyb3I9bn0pKSxLPWU9PiEwPT09ZT8nPHAgY2xhc3M9XCJ3bC10ZXhcIj5UZVggaXMgbm90IGF2YWlsYWJsZSBpbiBwcmV2aWV3PC9wPic6JzxzcGFuIGNsYXNzPVwid2wtdGV4XCI+VGVYIGlzIG5vdCBhdmFpbGFibGUgaW4gcHJldmlldzwvc3Bhbj4nLHE9ZT0+e2NvbnN0IHQ9YXN5bmModCxuPXt9KT0+ZmV0Y2goYGh0dHBzOi8vYXBpLmdpcGh5LmNvbS92MS9naWZzLyR7dH0/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKHtsYW5nOmUsbGltaXQ6XCIyMFwiLHJhdGluZzpcImdcIixhcGlfa2V5OlwiNkNJTUxrTk1NT2hSY1hQb01DUGtGeTRZYmsyWFVpTXBcIiwuLi5ufSkudG9TdHJpbmcoKX1gKS50aGVuKChlPT5lLmpzb24oKSkpLnRoZW4oKCh7ZGF0YTplfSk9PmUubWFwKChlPT4oe3RpdGxlOmUudGl0bGUsc3JjOmUuaW1hZ2VzLmRvd25zaXplZF9tZWRpdW0udXJsfSkpKSkpO3JldHVybntzZWFyY2g6ZT0+dChcInNlYXJjaFwiLHtxOmUsb2Zmc2V0OlwiMFwifSksZGVmYXVsdDooKT0+dChcInRyZW5kaW5nXCIse30pLG1vcmU6KGUsbj0wKT0+dChcInNlYXJjaFwiLHtxOmUsb2Zmc2V0Om4udG9TdHJpbmcoKX0pfX0sRz1uZXcgUmVnRXhwKGAoJHsvW1xcdTRFMDAtXFx1OUZGRlxcdTM0MDAtXFx1NGRiZlxcdWY5MDAtXFx1ZmFmZlxcdTMwNDAtXFx1MzA5ZlxcdWFjMDAtXFx1ZDdhZlxcdTA0MDAtXFx1MDRGRl0rfFxcdysvLnNvdXJjZX18JHsvPC8uc291cmNlfSl8KCg/OiR7Lyg/Ol58XFxzKVxcL1xcLyguKz8pJC9nbS5zb3VyY2V9KXwoPzokey9cXC9cXCooW1xcU1xcc10qPylcXCpcXC8vZ20uc291cmNlfSkpYCxcImdtaVwiKSxaPVtcIjIzQUM2OVwiLFwiOTFDMTMyXCIsXCJGMTk3MjZcIixcIkU4NTUyRFwiLFwiMUFBQjhFXCIsXCJFMTE0N0ZcIixcIjI5ODBDMVwiLFwiMUJBMUU2XCIsXCI5RkEwQTBcIixcIkYxOTcyNlwiLFwiRTMwQjIwXCIsXCJFMzBCMjBcIixcIkEzMzM4QlwiXSxKPXt9LFk9ZT0+e2xldCB0PTA7cmV0dXJuIGUucmVwbGFjZShHLCgoZSxuLGEpPT57aWYoYSlyZXR1cm5gPHNwYW4gc3R5bGU9XCJjb2xvcjogc2xhdGVncmF5XCI+JHthfTwvc3Bhbj5gO2lmKFwiPFwiPT09bilyZXR1cm5cIiZsdDtcIjtsZXQgbDtKW25dP2w9SltuXToobD1aW3RdLEpbbl09bCk7Y29uc3Qgcj1gPHNwYW4gc3R5bGU9XCJjb2xvcjogIyR7bH1cIj4ke259PC9zcGFuPmA7cmV0dXJuIHQ9Kyt0JVoubGVuZ3RoLHJ9KSl9LFg9W1wibmlja1wiLFwibmlja0Vycm9yXCIsXCJtYWlsXCIsXCJtYWlsRXJyb3JcIixcImxpbmtcIixcIm9wdGlvbmFsXCIsXCJwbGFjZWhvbGRlclwiLFwic29mYVwiLFwic3VibWl0XCIsXCJsaWtlXCIsXCJjYW5jZWxMaWtlXCIsXCJyZXBseVwiLFwiY2FuY2VsUmVwbHlcIixcImNvbW1lbnRcIixcInJlZnJlc2hcIixcIm1vcmVcIixcInByZXZpZXdcIixcImVtb2ppXCIsXCJ1cGxvYWRJbWFnZVwiLFwic2Vjb25kc1wiLFwibWludXRlc1wiLFwiaG91cnNcIixcImRheXNcIixcIm5vd1wiLFwidXBsb2FkaW5nXCIsXCJsb2dpblwiLFwibG9nb3V0XCIsXCJhZG1pblwiLFwic3RpY2t5XCIsXCJ3b3JkXCIsXCJ3b3JkSGludFwiLFwiYW5vbnltb3VzXCIsXCJsZXZlbDBcIixcImxldmVsMVwiLFwibGV2ZWwyXCIsXCJsZXZlbDNcIixcImxldmVsNFwiLFwibGV2ZWw1XCIsXCJnaWZcIixcImdpZlNlYXJjaFBsYWNlaG9sZGVyXCIsXCJwcm9maWxlXCIsXCJhcHByb3ZlZFwiLFwid2FpdGluZ1wiLFwic3BhbVwiLFwidW5zdGlja3lcIixcIm9sZGVzdFwiLFwibGF0ZXN0XCIsXCJob3R0ZXN0XCIsXCJyZWFjdGlvblRpdGxlXCJdLFE9ZT0+T2JqZWN0LmZyb21FbnRyaWVzKGUubWFwKCgoZSx0KT0+W1hbdF0sZV0pKSk7dmFyIGVlPVEoW1wiTmlja05hbWVcIixcIk5pY2tOYW1lIGNhbm5vdCBiZSBsZXNzIHRoYW4gMyBieXRlcy5cIixcIkUtTWFpbFwiLFwiUGxlYXNlIGNvbmZpcm0geW91ciBlbWFpbCBhZGRyZXNzLlwiLFwiV2Vic2l0ZVwiLFwiT3B0aW9uYWxcIixcIkNvbW1lbnQgaGVyZS4uLlwiLFwiTm8gY29tbWVudCB5ZXQuXCIsXCJTdWJtaXRcIixcIkxpa2VcIixcIkNhbmNlbCBsaWtlXCIsXCJSZXBseVwiLFwiQ2FuY2VsIHJlcGx5XCIsXCJDb21tZW50c1wiLFwiUmVmcmVzaFwiLFwiTG9hZCBNb3JlLi4uXCIsXCJQcmV2aWV3XCIsXCJFbW9qaVwiLFwiVXBsb2FkIEltYWdlXCIsXCJzZWNvbmRzIGFnb1wiLFwibWludXRlcyBhZ29cIixcImhvdXJzIGFnb1wiLFwiZGF5cyBhZ29cIixcImp1c3Qgbm93XCIsXCJVcGxvYWRpbmdcIixcIkxvZ2luXCIsXCJsb2dvdXRcIixcIkFkbWluXCIsXCJTdGlja3lcIixcIldvcmRzXCIsXCJQbGVhc2UgaW5wdXQgY29tbWVudHMgYmV0d2VlbiAkMCBhbmQgJDEgd29yZHMhXFxuIEN1cnJlbnQgd29yZCBudW1iZXI6ICQyXCIsXCJBbm9ueW1vdXNcIixcIkR3YXJ2ZXNcIixcIkhvYmJpdHNcIixcIkVudHNcIixcIldpemFyZHNcIixcIkVsdmVzXCIsXCJNYWlhclwiLFwiR0lGXCIsXCJTZWFyY2ggR0lGXCIsXCJQcm9maWxlXCIsXCJBcHByb3ZlZFwiLFwiV2FpdGluZ1wiLFwiU3BhbVwiLFwiVW5zdGlja3lcIixcIk9sZGVzdFwiLFwiTGF0ZXN0XCIsXCJIb3R0ZXN0XCIsXCJXaGF0IGRvIHlvdSB0aGluaz9cIl0pLHRlPVEoW1wi44OL44OD44Kv44ON44O844OgXCIsXCIz44OQ44Kk44OI5Lul5LiK44Gu44OL44OD44Kv44ON44O844Og44KS44GU5YWl5Yqb44GP44Gg44GV44GELlwiLFwi44Oh44O844Or44Ki44OJ44Os44K5XCIsXCLjg6Hjg7zjg6vjgqLjg4njg6zjgrnjgpLjgZTnorroqo3jgY/jgaDjgZXjgYQuXCIsXCLjgrXjgqTjg4hcIixcIuOCquODl+OCt+ODp+ODs1wiLFwi44GT44GT44Gr44Kz44Oh44Oz44OIXCIsXCLjgrPjg6Hjg7Pjg4jjgZfjgb7jgZfjgofjgYZ+XCIsXCLmj5Dlh7rjgZnjgotcIixcIkxpa2VcIixcIkNhbmNlbCBsaWtlXCIsXCLov5Tkv6HjgZnjgotcIixcIuOCreODo+ODs+OCu+ODq1wiLFwi44Kz44Oh44Oz44OIXCIsXCLmm7TmlrBcIixcIuOBleOCieOBq+iqreOBv+i+vOOCgFwiLFwi44OX44Os44OT44Ol44O8XCIsXCLntbXmloflrZdcIixcIueUu+WDj+OCkuOCouODg+ODl+ODreODvOODiVwiLFwi56eS5YmNXCIsXCLliIbliY1cIixcIuaZgumWk+WJjVwiLFwi5pel5YmNXCIsXCLjgZ/jgaPjgaDku4pcIixcIuOCouODg+ODl+ODreODvOODiVwiLFwi44Ot44Kw44Kk44Oz44GZ44KLXCIsXCLjg63jgrDjgqLjgqbjg4hcIixcIueuoeeQhuiAhVwiLFwi44OI44OD44OX44Gr572u44GPXCIsXCLjg6/jg7zjg4lcIixcIuOCs+ODoeODs+ODiOOBryAkMCDjgYvjgokgJDEg44Ov44O844OJ44Gu6ZaT44Gn44Gq44GR44KM44Gw44Gq44KK44G+44Gb44KTIVxcbiDnj77lnKjjga7ljZjoqp7nlarlj7c6ICQyXCIsXCLljL/lkI1cIixcIuOBhuOBiOOBq+OCk1wiLFwi44Gq44GL44Gr44KTXCIsXCLjgZfjgoLjgYrjgZdcIixcIueJueOBq+OBl+OCguOBiuOBl1wiLFwi44GL44GSXCIsXCLjgarjgazjgZdcIixcIkdJRlwiLFwi5o6i44GZIEdJRlwiLFwi5YCL5Lq65oOF5aCxXCIsXCLmib/oqo3muIjjgb9cIixcIuW+heOBo+OBpuOBhOOCi1wiLFwi44K544OR44OgXCIsXCLjgbnjgZ/jgaTjgYvjgarjgYRcIixcIumAhumghlwiLFwi5q2j6aCGXCIsXCLkurrmsJfpoIZcIixcIuOBqeOBhuaAneOBhOOBvuOBmeOBi++8n1wiXSksbmU9UShbXCJBcGVsaWRvXCIsXCJBcGVsaWRvIG7Do28gcG9kZSBzZXIgbWVub3IgcXVlIDMgYnl0ZXMuXCIsXCJFLU1haWxcIixcIlBvciBmYXZvciwgY29uZmlybWUgc2V1IGVuZGVyZcOnbyBkZSBlLW1haWwuXCIsXCJXZWJzaXRlXCIsXCJPcGNpb25hbFwiLFwiQ29tZW50ZSBhcXVpLi4uXCIsXCJOZW5odW0gY29tZW50w6FyaW8sIGFpbmRhLlwiLFwiRW52aWFyXCIsXCJMaWtlXCIsXCJDYW5jZWwgbGlrZVwiLFwiUmVzcG9uZGVyXCIsXCJDYW5jZWxhciByZXNwb3N0YVwiLFwiQ29tZW50w6FyaW9zXCIsXCJSZWZyZXNjYXJcIixcIkNhcnJlZ2FyIE1haXMuLi5cIixcIlZpc3VhbGl6YXJcIixcIkVtb2ppXCIsXCJFbnZpYXIgSW1hZ2VtXCIsXCJzZWd1bmRvcyBhdHLDoXNcIixcIm1pbnV0b3MgYXRyw6FzXCIsXCJob3JhcyBhdHLDoXNcIixcImRpYXMgYXRyw6FzXCIsXCJhZ29yYSBtZXNtb1wiLFwiRW52aWFuZG9cIixcIkVudHJhclwiLFwiU2FpclwiLFwiQWRtaW5cIixcIlN0aWNreVwiLFwiUGFsYXZyYXNcIixcIkZhdm9yIGVudmlhciBjb21lbnTDoXJpbyBjb20gJDAgYSAkMSBwYWxhdnJhcyFcXG4gTsO6bWVybyBkZSBwYWxhdnJhcyBhdHVhaXM6ICQyXCIsXCJBbsO0bmltb1wiLFwiRHdhcnZlc1wiLFwiSG9iYml0c1wiLFwiRW50c1wiLFwiV2l6YXJkc1wiLFwiRWx2ZXNcIixcIk1haWFyXCIsXCJHSUZcIixcIlBlc3F1aXNhciBHSUZcIixcImluZm9ybWHDp8OjbyBwZXNzb2FsXCIsXCJBcHJvdmFkb1wiLFwiRXNwZXJhXCIsXCJTcGFtXCIsXCJVbnN0aWNreVwiLFwiTWFpcyB2ZWxob1wiLFwiTWFpcyByZWNlbnRlc1wiLFwiTWFpcyBxdWVudGVcIixcIk8gcXVlIHZvY8OqIGFjaGE/XCJdKSxhZT1RKFtcItCf0YHQtdCy0LTQvtC90LjQvFwiLFwi0J3QuNC60L3QtdC50Lwg0L3QtSDQvNC+0LbQtdGCINCx0YvRgtGMINC80LXQvdGM0YjQtSAzINCx0LDQudGCLlwiLFwi0K3Quy4g0LDQtNGA0LXRgVwiLFwi0J/QvtC20LDQu9GD0LnRgdGC0LAsINC/0L7QtNGC0LLQtdGA0LTQuNGC0LUg0LDQtNGA0LXRgSDQstCw0YjQtdC5INGN0LvQtdC60YLRgNC+0L3QvdC+0Lkg0L/QvtGH0YLRiy5cIixcItCS0LXQsS3RgdCw0LnRglwiLFwi0J3QtdC+0LHRj9C30LDRgtC10LvRjNC90YvQuVwiLFwi0JrQvtC80LzQtdC90YLQsNGA0LjQuSDQt9C00LXRgdGMLi4uXCIsXCLQn9C+0LrQsCDQvdC10YIg0LrQvtC80LzQtdC90YLQsNGA0LjQtdCyLlwiLFwi0J7RgtC/0YDQsNCy0LjRgtGMXCIsXCJMaWtlXCIsXCJDYW5jZWwgbGlrZVwiLFwi0J7RgtCy0LXRh9Cw0YLRjFwiLFwi0J7RgtC80LXQvdC40YLRjCDQvtGC0LLQtdGCXCIsXCLQmtC+0LzQvNC10L3RgtCw0YDQuNC4XCIsXCLQntCx0L3QvtCy0LjRgtGMXCIsXCLQl9Cw0LPRgNGD0LfQuCDQsdC+0LvRjNGI0LUuLi5cIixcItCf0YDQtdCy0YzRjlwiLFwi0Y3QvNC+0LTQt9C4XCIsXCLQl9Cw0LPRgNGD0LfQuNGC0Ywg0LjQt9C+0LHRgNCw0LbQtdC90LjQtVwiLFwi0YHQtdC60YPQvdC0INC90LDQt9Cw0LRcIixcItC90LXRgdC60L7Qu9GM0LrQviDQvNC40L3Rg9GCINC90LDQt9Cw0LRcIixcItC90LXRgdC60L7Qu9GM0LrQviDRh9Cw0YHQvtCyINC90LDQt9Cw0LRcIixcItC00L3QtdC5INC90LDQt9Cw0LRcIixcItC/0YDRj9C80L4g0YHQtdC50YfQsNGBXCIsXCLQl9Cw0LPRgNGD0LfQutCwXCIsXCLQkNCy0YLQvtGA0LjQt9C+0LLQsNGC0YzRgdGPXCIsXCLQktGL0YXQvtC0INC40Lcg0YHQuNGB0YLQtdC80YtcIixcItCQ0LTQvNC40L1cIixcItCb0LjQv9C60LjQuVwiLFwi0KHQu9C+0LLQsFwiLFwi0J/QvtC20LDQu9GD0LnRgdGC0LAsINCy0LLQtdC00LjRgtC1INC60L7QvNC80LXQvdGC0LDRgNC40Lgg0L7RgiAkMCDQtNC+ICQxINGB0LvQvtCyIVxcbtCd0L7QvNC10YAg0YLQtdC60YPRidC10LPQviDRgdC70L7QstCwOiAkMlwiLFwi0JDQvdC+0L3QuNC80L3Ri9C5XCIsXCJEd2FydmVzXCIsXCJIb2JiaXRzXCIsXCJFbnRzXCIsXCJXaXphcmRzXCIsXCJFbHZlc1wiLFwiTWFpYXJcIixcIkdJRlwiLFwi0J/QvtC40YHQuiBHSUZcIixcItCf0LXRgNGB0L7QvdCw0LvRjNC90YvQtSDQtNCw0L3QvdGL0LVcIixcItCe0LTQvtCx0YDQtdC90L3Ri9C5XCIsXCLQntC20LjQtNCw0Y7RidC40LlcIixcItCh0L/QsNC8XCIsXCLQndC10LvQuNC/0LrQuNC5XCIsXCLRgdCw0LzRi9C5INGB0YLQsNGA0YvQuVwiLFwi0L/QvtGB0LvQtdC00L3QuNC5XCIsXCLRgdCw0LzRi9C5INCz0L7RgNGP0YfQuNC5XCIsXCLQp9GC0L4g0LLRiyDQtNGD0LzQsNC10YLQtT9cIl0pLGxlPVEoW1wi5pi156ewXCIsXCLmmLXnp7DkuI3og73lsJHkuo4z5Liq5a2X56ymXCIsXCLpgq7nrrFcIixcIuivt+Whq+WGmeato+ehrueahOmCruS7tuWcsOWdgFwiLFwi572R5Z2AXCIsXCLlj6/pgIlcIixcIuasoui/juivhOiuulwiLFwi5p2l5Y+R6K+E6K665ZCnflwiLFwi5o+Q5LqkXCIsXCLllpzmrKJcIixcIuWPlua2iOWWnOasolwiLFwi5Zue5aSNXCIsXCLlj5bmtojlm57lpI1cIixcIuivhOiuulwiLFwi5Yi35pawXCIsXCLliqDovb3mm7TlpJouLi5cIixcIumihOiniFwiLFwi6KGo5oOFXCIsXCLkuIrkvKDlm77niYdcIixcIuenkuWJjVwiLFwi5YiG6ZKf5YmNXCIsXCLlsI/ml7bliY1cIixcIuWkqeWJjVwiLFwi5Yia5YiaXCIsXCLmraPlnKjkuIrkvKBcIixcIueZu+W9lVwiLFwi6YCA5Ye6XCIsXCLljZrkuLtcIixcIue9rumhtlwiLFwi5a2XXCIsXCLor4TorrrlrZfmlbDlupTlnKggJDAg5YiwICQxIOWtl+S5i+mXtO+8gVxcbuW9k+WJjeWtl+aVsO+8miQyXCIsXCLljL/lkI1cIixcIua9nOawtFwiLFwi5YaS5rOhXCIsXCLlkJDmp71cIixcIua0u+i3g1wiLFwi6K+d55eoXCIsXCLkvKDor7RcIixcIuihqOaDheWMhVwiLFwi5pCc57Si6KGo5oOF5YyFXCIsXCLkuKrkurrotYTmlplcIixcIumAmui/h1wiLFwi5b6F5a6h5qC4XCIsXCLlnoPlnL5cIixcIuWPlua2iOe9rumhtlwiLFwi5oyJ5YCS5bqPXCIsXCLmjInmraPluo9cIixcIuaMieeDreW6plwiLFwi5L2g6K6k5Li66L+Z56+H5paH56ug5oCO5LmI5qC377yfXCJdKSxyZT1RKFtcIuaaseeosVwiLFwi5pqx56ix5LiN6IO95bCR5pa8M+WAi+Wtl+WFg1wiLFwi6YO1566xXCIsXCLoq4vloavlr6vmraPnorrnmoTpg7Xku7blnLDlnYBcIixcIue2suWdgFwiLFwi5Y+v6YG4XCIsXCLmraHov47nlZnoqIBcIixcIuS+hueZvOeVmeiogOWQp35cIixcIumAgeWHulwiLFwi5Zac5q2hXCIsXCLlj5bmtojllpzmraFcIixcIuWbnuimhlwiLFwi5Y+W5raI5Zue6KaGXCIsXCLnlZnoqIBcIixcIumHjeaVtFwiLFwi6LyJ5YWl5pu05aSaLi4uXCIsXCLpoJDopr1cIixcIuihqOaDhVwiLFwi5LiK5YKz5ZyW54mHXCIsXCLnp5LliY1cIixcIuWIhumQmOWJjVwiLFwi5bCP5pmC5YmNXCIsXCLlpKnliY1cIixcIuWJm+WJm1wiLFwi5q2j5Zyo5LiK5YKzXCIsXCLnmbvlhaVcIixcIueZu+WHulwiLFwi566h55CG6ICFXCIsXCLnva7poIJcIixcIuWtl1wiLFwi55WZ6KiA5a2X5pW45oeJ5ZyoICQwIOWIsCAkMSDlrZfkuYvplpPvvIFcXG7nm67liY3lrZfmlbjvvJokMlwiLFwi5Yy/5ZCNXCIsXCLmvZvmsLRcIixcIuWGkuazoVwiLFwi5ZCQ5qe9XCIsXCLmtLvouo1cIixcIuWkmuipsVwiLFwi5YKz6KqqXCIsXCLooajmg4XljIVcIixcIuaQnOWwi+ihqOaDheWMhVwiLFwi5YCL5Lq66LOH5paZXCIsXCLpgJrpgY5cIixcIuW+heWvqeaguFwiLFwi5Z6D5Zy+XCIsXCLlj5bmtojnva7poIJcIixcIuacgOaXqVwiLFwi5pyA5pawXCIsXCLnhrHploBcIixcIuS9oOiqjeeCuumAmeevh+aWh+eroOaAjum6vOaoo++8n1wiXSk7Y29uc3QgaWU9e3poOmxlLFwiemgtY25cIjpsZSxcInpoLUNOXCI6bGUsXCJ6aC10d1wiOnJlLFwiemgtVFdcIjpyZSxlbjplZSxcImVuLVVTXCI6ZWUsXCJlbi11c1wiOmVlLGpwOnRlLGphOnRlLFwianAtanBcIjp0ZSxcImpwLUpQXCI6dGUsXCJwdC1iclwiOm5lLFwicHQtQlJcIjpuZSxydTphZSxcInJ1LXJ1XCI6YWUsXCJydS1SVVwiOmFlfSxvZT17XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL2pzb25cIn0sc2U9KGUsdD1cIlwiKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlLmVycm5vKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gZmFpbGVkIHdpdGggJHtlLmVycm5vfTogJHtlLmVycm1zZ31gKTtyZXR1cm4gZX0sY2U9KHtzZXJ2ZXJVUkw6ZSxsYW5nOnQscGF0aHM6bix0eXBlOmEsc2lnbmFsOmx9KT0+ZmV0Y2goYCR7ZX0vYXJ0aWNsZT9wYXRoPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG4uam9pbihcIixcIikpfSZ0eXBlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGEuam9pbihcIixcIikpfSZsYW5nPSR7dH1gLHtzaWduYWw6bH0pLnRoZW4oKGU9PmUuanNvbigpKSksdWU9KHtzZXJ2ZXJVUkw6ZSxsYW5nOnQscGF0aDpuLHR5cGU6YSxhY3Rpb246bH0pPT5mZXRjaChgJHtlfS9hcnRpY2xlP2xhbmc9JHt0fWAse21ldGhvZDpcIlBPU1RcIixoZWFkZXJzOm9lLGJvZHk6SlNPTi5zdHJpbmdpZnkoe3BhdGg6bix0eXBlOmEsYWN0aW9uOmx9KX0pLnRoZW4oKGU9PmUuanNvbigpKSksZGU9KHtzZXJ2ZXJVUkw6ZSxsYW5nOnQsdG9rZW46bixvYmplY3RJZDphLGNvbW1lbnQ6bH0pPT5mZXRjaChgJHtlfS9jb21tZW50LyR7YX0/bGFuZz0ke3R9YCx7bWV0aG9kOlwiUFVUXCIsaGVhZGVyczp7Li4ub2UsQXV0aG9yaXphdGlvbjpgQmVhcmVyICR7bn1gfSxib2R5OkpTT04uc3RyaW5naWZ5KGwpfSkudGhlbigoZT0+ZS5qc29uKCkpKS50aGVuKChlPT5zZShlLFwiVXBkYXRlIGNvbW1lbnRcIikpKSx2ZT1lPT57dHJ5e2U9ZGVjb2RlVVJJKGUpfWNhdGNoKGUpe31yZXR1cm4gZX0sbWU9KGU9XCJcIik9PmUucmVwbGFjZSgvXFwvJC91LFwiXCIpLHBlPWU9Pi9eKGh0dHBzPzopP1xcL1xcLy8udGVzdChlKSxnZT1lPT57Y29uc3QgdD1tZShlKTtyZXR1cm4gcGUodCk/dDpgaHR0cHM6Ly8ke3R9YH0saGU9ZT0+QXJyYXkuaXNBcnJheShlKT9lOiEhZSYmWzAsZV0sZmU9KGUsdCk9PlwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZTohMSE9PWUmJnQseWU9XCJ7LS13YWxpbmUtd2hpdGU6IzAwMDstLXdhbGluZS1saWdodC1ncmV5OiM2NjY7LS13YWxpbmUtZGFyay1ncmV5OiM5OTk7LS13YWxpbmUtY29sb3I6Izg4ODstLXdhbGluZS1iZ2NvbG9yOiMxZTFlMWU7LS13YWxpbmUtYmdjb2xvci1saWdodDojMjcyNzI3Oy0td2FsaW5lLWJnY29sb3ItaG92ZXI6ICM0NDQ7LS13YWxpbmUtYm9yZGVyLWNvbG9yOiMzMzM7LS13YWxpbmUtZGlzYWJsZS1iZ2NvbG9yOiM0NDQ7LS13YWxpbmUtZGlzYWJsZS1jb2xvcjojMjcyNzI3Oy0td2FsaW5lLWJxLWNvbG9yOiMyNzI3Mjc7LS13YWxpbmUtaW5mby1iZ2NvbG9yOiMyNzI3Mjc7LS13YWxpbmUtaW5mby1jb2xvcjojNjY2fVwiLHdlPShlLHQpPT57bGV0IG49ZS50b1N0cmluZygpO2Zvcig7bi5sZW5ndGg8dDspbj1cIjBcIituO3JldHVybiBufSxiZT0oZSx0LG4pPT57aWYoIWUpcmV0dXJuXCJcIjtjb25zdCBhPVwic3RyaW5nXCI9PXR5cGVvZiBlP25ldyBEYXRlKC0xIT09ZS5pbmRleE9mKFwiIFwiKT9lLnJlcGxhY2UoLy0vZyxcIi9cIik6ZSk6ZSxsPXQuZ2V0VGltZSgpLWEuZ2V0VGltZSgpLHI9TWF0aC5mbG9vcihsLzg2NGU1KTtpZigwPT09cil7Y29uc3QgZT1sJTg2NGU1LHQ9TWF0aC5mbG9vcihlLzM2ZTUpO2lmKDA9PT10KXtjb25zdCB0PWUlMzZlNSxhPU1hdGguZmxvb3IodC82ZTQpO2lmKDA9PT1hKXtjb25zdCBlPXQlNmU0O3JldHVybmAke01hdGgucm91bmQoZS8xZTMpfSAke24uc2Vjb25kc31gfXJldHVybmAke2F9ICR7bi5taW51dGVzfWB9cmV0dXJuYCR7dH0gJHtuLmhvdXJzfWB9cmV0dXJuIHI8MD9uLm5vdzpyPDg/YCR7cn0gJHtuLmRheXN9YDooZT0+e2NvbnN0IHQ9d2UoZS5nZXREYXRlKCksMiksbj13ZShlLmdldE1vbnRoKCkrMSwyKTtyZXR1cm5gJHt3ZShlLmdldEZ1bGxZZWFyKCksMil9LSR7bn0tJHt0fWB9KShhKX0sa2U9L15bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLENlPWU9Pntjb25zdCB0PV8oXCJXQUxJTkVfRU1PSklcIix7fSksbj1Cb29sZWFuKC9AWzAtOV0rXFwuWzAtOV0rXFwuWzAtOV0rLy50ZXN0KGUpKTtpZihuKXtjb25zdCBuPXQudmFsdWVbZV07aWYobilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4pfXJldHVybiBmZXRjaChgJHtlfS9pbmZvLmpzb25gKS50aGVuKChlPT5lLmpzb24oKSkpLnRoZW4oKGE9Pntjb25zdCBsPXtmb2xkZXI6ZSwuLi5hfTtyZXR1cm4gbiYmKHQudmFsdWVbZV09bCksbH0pKX0sJGU9KGUsdD1cIlwiLG49XCJcIixhPVwiXCIpPT5gJHt0P2Ake3R9L2A6XCJcIn0ke259JHtlfSR7YT9gLiR7YX1gOlwiXCJ9YCxMZT1lPT57XCJBYm9ydEVycm9yXCIhPT1lLm5hbWUmJmNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlKX0sUmU9ZT0+ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50P2U6XCJzdHJpbmdcIj09dHlwZW9mIGU/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTpudWxsLHhlPWU9PmUudHlwZS5pbmNsdWRlcyhcImltYWdlXCIpLEVlPWU9Pntjb25zdCB0PUFycmF5LmZyb20oZSkuZmluZCh4ZSk7cmV0dXJuIHQ/dC5nZXRBc0ZpbGUoKTpudWxsfSxJZT0vXFwkLio/XFwkLyxqZT0vXlxcJCguKj8pXFwkLyxBZT0vXig/Olxcc3swLDN9KVxcJFxcJCgoPzpbXlxcbl18XFxuW15cXG5dKSs/KVxcbnswLDF9XFwkXFwkLyxTZT0oZT1cIlwiLHQ9e30pPT5lLnJlcGxhY2UoLzooLis/KTovZywoKGUsbik9PnRbbl0/YDxpbWcgY2xhc3M9XCJ3bC1lbW9qaVwiIHNyYz1cIiR7dFtuXX1cIiBhbHQ9XCIke259XCI+YDplKSksVWU9KGUse2Vtb2ppTWFwOnQsaGlnaGxpZ2h0ZXI6bix0ZXhSZW5kZXJlcjphfSk9PntpZihQLnNldE9wdGlvbnMoe2hpZ2hsaWdodDpufHx2b2lkIDAsYnJlYWtzOiEwLHNtYXJ0TGlzdHM6ITAsc21hcnR5cGFudHM6ITB9KSxhKXtjb25zdCBlPShlPT5be25hbWU6XCJibG9ja01hdGhcIixsZXZlbDpcImJsb2NrXCIsdG9rZW5pemVyKHQpe2NvbnN0IG49QWUuZXhlYyh0KTtpZihudWxsIT09bilyZXR1cm57dHlwZTpcImh0bWxcIixyYXc6blswXSx0ZXh0OmUoITAsblsxXSl9fX0se25hbWU6XCJpbmxpbmVNYXRoXCIsbGV2ZWw6XCJpbmxpbmVcIixzdGFydChlKXtjb25zdCB0PWUuc2VhcmNoKEllKTtyZXR1cm4tMSE9PXQ/dDplLmxlbmd0aH0sdG9rZW5pemVyKHQpe2NvbnN0IG49amUuZXhlYyh0KTtpZihudWxsIT09bilyZXR1cm57dHlwZTpcImh0bWxcIixyYXc6blswXSx0ZXh0OmUoITEsblsxXSl9fX1dKShhKTtQLnVzZSh7ZXh0ZW5zaW9uczplfSl9cmV0dXJuIFAucGFyc2UoU2UoZSx0KSl9LF9lPWU9PmUuZGF0YXNldC5wYXRofHxlLmdldEF0dHJpYnV0ZShcImlkXCIpLHplPSh7c2VydmVyVVJMOmUscGF0aDp0PXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxzZWxlY3RvcjpuPVwiLndhbGluZS1jb21tZW50LWNvdW50XCIsbGFuZzphPW5hdmlnYXRvci5sYW5ndWFnZX0pPT57Y29uc3QgbD1uZXcgQWJvcnRDb250cm9sbGVyLHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChuKTtyZXR1cm4gci5sZW5ndGgmJigoe3NlcnZlclVSTDplLGxhbmc6dCxwYXRoczpuLHNpZ25hbDphfSk9PmZldGNoKGAke2V9L2NvbW1lbnQ/dHlwZT1jb3VudCZ1cmw9JHtlbmNvZGVVUklDb21wb25lbnQobi5qb2luKFwiLFwiKSl9Jmxhbmc9JHt0fWAse3NpZ25hbDphfSkudGhlbigoZT0+ZS5qc29uKCkpKS50aGVuKChlPT5BcnJheS5pc0FycmF5KGUpP2U6W2VdKSkpKHtzZXJ2ZXJVUkw6Z2UoZSkscGF0aHM6QXJyYXkuZnJvbShyKS5tYXAoKGU9PnZlKGUuZGF0YXNldC5wYXRofHxlLmdldEF0dHJpYnV0ZShcImlkXCIpfHx0KSkpLGxhbmc6YSxzaWduYWw6bC5zaWduYWx9KS50aGVuKChlPT57ci5mb3JFYWNoKCgodCxuKT0+e3QuaW5uZXJUZXh0PWVbbl0udG9TdHJpbmcoKX0pKX0pKS5jYXRjaChMZSksbC5hYm9ydC5iaW5kKGwpfSxNZT0oe3NpemU6dH0pPT5lKFwic3ZnXCIse2NsYXNzOlwid2wtY2xvc2UtaWNvblwiLHZpZXdCb3g6XCIwIDAgMTAyNCAxMDI0XCIsd2lkdGg6dCxoZWlnaHQ6dH0sW2UoXCJwYXRoXCIse2Q6XCJNNjk3LjE3MyA4NS4zMzNoLTM2OS45MmMtMTQ0LjY0IDAtMjQxLjkyIDEwMS41NDctMjQxLjkyIDI1Mi41ODd2MzQ4LjU4N2MwIDE1MC42MTMgOTcuMjggMjUyLjE2IDI0MS45MiAyNTIuMTZoMzY5LjkyYzE0NC42NCAwIDI0MS40OTQtMTAxLjU0NyAyNDEuNDk0LTI1Mi4xNlYzMzcuOTJjMC0xNTEuMDQtOTYuODU0LTI1Mi41ODctMjQxLjQ5NC0yNTIuNTg3elwiLGZpbGw6XCJjdXJyZW50Q29sb3JcIn0pLGUoXCJwYXRoXCIse2Q6XCJtNjQwLjY4MyA1ODcuNTItNzUuOTQ3LTc1Ljg2MSA3NS45MDQtNzUuODYyYTM3LjI5IDM3LjI5IDAgMCAwIDAtNTIuNzc4IDM3LjIwNSAzNy4yMDUgMCAwIDAtNTIuNzc5IDBsLTc1Ljk0NiA3NS44MTgtNzUuODYyLTc1Ljk0NmEzNy40MTkgMzcuNDE5IDAgMCAwLTUyLjgyMSAwIDM3LjQxOSAzNy40MTkgMCAwIDAgMCA1Mi44MjFsNzUuOTQ3IDc1Ljk0Ny03NS43NzYgNzUuNzMzYTM3LjI5IDM3LjI5IDAgMSAwIDUyLjc3OCA1Mi44MjFsNzUuNzc2LTc1Ljc3NiA3NS45NDcgNzUuOTQ3YTM3LjM3NiAzNy4zNzYgMCAwIDAgNTIuNzc5LTUyLjgyMXpcIixmaWxsOlwiIzg4OFwifSldKSxIZT0oKT0+ZShcInN2Z1wiLHt2aWV3Qm94OlwiMCAwIDEwMjQgMTAyNFwiLHdpZHRoOlwiMjRcIixoZWlnaHQ6XCIyNFwifSxlKFwicGF0aFwiLHtkOlwibTM0MS4wMTMgMzk0LjY2NyAyNy43NTUgMzkzLjQ1aDI3MS44M2wyNy43MzMtMzkzLjQ1aDY0LjEwNmwtMjguMDEgMzk3Ljk1MmE2NCA2NCAwIDAgMS02My44MyA1OS40OThIMzY4Ljc2OGE2NCA2NCAwIDAgMS02My44My01OS41MmwtMjguMDUzLTM5Ny45M2g2NC4xMjh6bTEzOS4zMDcgMTkuODE4djI5OC42NjdoLTY0VjQxNC40ODVoNjR6bTExNy4wMTMgMHYyOTguNjY3aC02NFY0MTQuNDg1aDY0ek0xODEuMzMzIDI4OGg2NDB2NjRoLTY0MHYtNjR6bTQ1My40ODMtMTA2LjY2N3Y2NGgtMjU2di02NGgyNTZ6XCIsZmlsbDpcInJlZFwifSkpLFRlPSgpPT5lKFwic3ZnXCIse3ZpZXdCb3g6XCIwIDAgMTAyNCAxMDI0XCIsd2lkdGg6XCIyNFwiLGhlaWdodDpcIjI0XCJ9LGUoXCJwYXRoXCIse2Q6XCJNNTYzLjIgNDYzLjMgNjc3IDU0MGMxLjcgMS4yIDMuNyAxLjggNS44IDEuOC43IDAgMS40LS4xIDItLjIgMi43LS41IDUuMS0yLjEgNi42LTQuNGwyNS4zLTM3LjhjMS41LTIuMyAyLjEtNS4xIDEuNi03LjhzLTIuMS01LjEtNC40LTYuNmwtNzMuNi00OS4xIDczLjYtNDkuMWMyLjMtMS41IDMuOS0zLjkgNC40LTYuNi41LTIuNyAwLTUuNS0xLjYtNy44bC0yNS4zLTM3LjhhMTAuMSAxMC4xIDAgMCAwLTYuNi00LjRjLS43LS4xLTEuMy0uMi0yLS4yLTIuMSAwLTQuMS42LTUuOCAxLjhsLTExMy44IDc2LjZjLTkuMiA2LjItMTQuNyAxNi40LTE0LjcgMjcuNS4xIDExIDUuNSAyMS4zIDE0LjcgMjcuNHpNMzg3IDM0OC44aC00NS41Yy01LjcgMC0xMC40IDQuNy0xMC40IDEwLjR2MTUzLjNjMCA1LjcgNC43IDEwLjQgMTAuNCAxMC40SDM4N2M1LjcgMCAxMC40LTQuNyAxMC40LTEwLjRWMzU5LjJjMC01LjctNC43LTEwLjQtMTAuNC0xMC40em0zMzMuOCAyNDEuMy00MS0yMGExMC4zIDEwLjMgMCAwIDAtOC4xLS41Yy0yLjYuOS00LjggMi45LTUuOSA1LjQtMzAuMSA2NC45LTkzLjEgMTA5LjEtMTY0LjQgMTE1LjItNS43LjUtOS45IDUuNS05LjUgMTEuMmwzLjkgNDUuNWMuNSA1LjMgNSA5LjUgMTAuMyA5LjVoLjljOTQuOC04IDE3OC41LTY2LjUgMjE4LjYtMTUyLjcgMi40LTUgLjMtMTEuMi00LjgtMTMuNnptMTg2LTE4Ni4xYy0xMS45LTQyLTMwLjUtODEuNC01NS4yLTExNy4xLTI0LjEtMzQuOS01My41LTY1LjYtODcuNS05MS4yLTMzLjktMjUuNi03MS41LTQ1LjUtMTExLjYtNTkuMi00MS4yLTE0LTg0LjEtMjEuMS0xMjcuOC0yMS4xaC0xLjJjLTc1LjQgMC0xNDguOCAyMS40LTIxMi41IDYxLjctNjMuNyA0MC4zLTExNC4zIDk3LjYtMTQ2LjUgMTY1LjgtMzIuMiA2OC4xLTQ0LjMgMTQzLjYtMzUuMSAyMTguNCA5LjMgNzQuOCAzOS40IDE0NSA4Ny4zIDIwMy4zLjEuMi4zLjMuNC41bDM2LjIgMzguNGMxLjEgMS4yIDIuNSAyLjEgMy45IDIuNiA3My4zIDY2LjcgMTY4LjIgMTAzLjUgMjY3LjUgMTAzLjUgNzMuMyAwIDE0NS4yLTIwLjMgMjA3LjctNTguNyAzNy4zLTIyLjkgNzAuMy01MS41IDk4LjEtODUgMjcuMS0zMi43IDQ4LjctNjkuNSA2NC4yLTEwOS4xIDE1LjUtMzkuNyAyNC40LTgxLjMgMjYuNi0xMjMuOCAyLjQtNDMuNi0yLjUtODctMTQuNS0xMjl6bS02MC41IDE4MS4xYy04LjMgMzctMjIuOCA3Mi00MyAxMDQtMTkuNyAzMS4xLTQ0LjMgNTguNi03My4xIDgxLjctMjguOCAyMy4xLTYxIDQxLTk1LjcgNTMuNC0zNS42IDEyLjctNzIuOSAxOS4xLTExMC45IDE5LjEtODIuNiAwLTE2MS43LTMwLjYtMjIyLjgtODYuMmwtMzQuMS0zNS44Yy0yMy45LTI5LjMtNDIuNC02Mi4yLTU1LjEtOTcuNy0xMi40LTM0LjctMTguOC03MS0xOS4yLTEwNy45LS40LTM2LjkgNS40LTczLjMgMTcuMS0xMDguMiAxMi0zNS44IDMwLTY5LjIgNTMuNC05OS4xIDMxLjctNDAuNCA3MS4xLTcyIDExNy4yLTk0LjEgNDQuNS0yMS4zIDk0LTMyLjYgMTQzLjQtMzIuNiA0OS4zIDAgOTcgMTAuOCAxNDEuOCAzMiAzNC4zIDE2LjMgNjUuMyAzOC4xIDkyIDY0LjggMjYuMSAyNiA0Ny41IDU2IDYzLjYgODkuMiAxNi4yIDMzLjIgMjYuNiA2OC41IDMxIDEwNS4xIDQuNiAzNy41IDIuNyA3NS4zLTUuNiAxMTIuM3pcIixmaWxsOlwiY3VycmVudENvbG9yXCJ9KSksT2U9KCk9PmUoXCJzdmdcIix7dmlld0JveDpcIjAgMCAxMDI0IDEwMjRcIix3aWR0aDpcIjI0XCIsaGVpZ2h0OlwiMjRcIn0sW2UoXCJwYXRoXCIse2Q6XCJNNzg0IDExMkgyNDBjLTg4IDAtMTYwIDcyLTE2MCAxNjB2NDgwYzAgODggNzIgMTYwIDE2MCAxNjBoNTQ0Yzg4IDAgMTYwLTcyIDE2MC0xNjBWMjcyYzAtODgtNzItMTYwLTE2MC0xNjB6bTk2IDY0MGMwIDUyLjgtNDMuMiA5Ni05NiA5NkgyNDBjLTUyLjggMC05Ni00My4yLTk2LTk2VjI3MmMwLTUyLjggNDMuMi05NiA5Ni05Nmg1NDRjNTIuOCAwIDk2IDQzLjIgOTYgOTZ2NDgwelwiLGZpbGw6XCJjdXJyZW50Q29sb3JcIn0pLGUoXCJwYXRoXCIse2Q6XCJNMzUyIDQ4MGM1Mi44IDAgOTYtNDMuMiA5Ni05NnMtNDMuMi05Ni05Ni05Ni05NiA0My4yLTk2IDk2IDQzLjIgOTYgOTYgOTZ6bTAtMTI4YzE3LjYgMCAzMiAxNC40IDMyIDMycy0xNC40IDMyLTMyIDMyLTMyLTE0LjQtMzItMzIgMTQuNC0zMiAzMi0zMnptNDYyLjQgMzc5LjItMy4yLTMuMi0xNzcuNi0xNzcuNmMtMjUuNi0yNS42LTY1LjYtMjUuNi05MS4yIDBsLTgwIDgwLTM2LjgtMzYuOGMtMjUuNi0yNS42LTY1LjYtMjUuNi05MS4yIDBMMjAwIDcyOGMtNC44IDYuNC04IDE0LjQtOCAyNCAwIDE3LjYgMTQuNCAzMiAzMiAzMiA5LjYgMCAxNi0zLjIgMjIuNC05LjZMMzgwLjggNjQwbDEzNC40IDEzNC40YzYuNCA2LjQgMTQuNCA5LjYgMjQgOS42IDE3LjYgMCAzMi0xNC40IDMyLTMyIDAtOS42LTQuOC0xNy42LTkuNi0yNGwtNTIuOC01Mi44IDgwLTgwTDc2OS42IDc3NmM2LjQgNC44IDEyLjggOCAyMC44IDggMTcuNiAwIDMyLTE0LjQgMzItMzIgMC04LTMuMi0xNi04LTIwLjh6XCIsZmlsbDpcImN1cnJlbnRDb2xvclwifSldKSxQZT0oe2FjdGl2ZTp0PSExfSk9PmUoXCJzdmdcIix7dmlld0JveDpcIjAgMCAxMDI0IDEwMjRcIix3aWR0aDpcIjI0XCIsaGVpZ2h0OlwiMjRcIn0sW2UoXCJwYXRoXCIse2Q6XCJNODUwLjY1NCAzMjMuODA0Yy0xMS4wNDItMjUuNjI1LTI2Ljg2Mi00OC41MzItNDYuODg1LTY4LjIyNS0yMC4wMjItMTkuNjEtNDMuMjU4LTM0LjkzNi02OS4yMTMtNDUuNzMtMjYuNzgtMTEuMTI0LTU1LjEyNC0xNi43MjctODQuMzc1LTE2LjcyNy00MC42MjIgMC04MC4yNTYgMTEuMTIzLTExNC42OTggMzIuMTM1QTIxNC43OSAyMTQuNzkgMCAwIDAgNTEyIDI0MS44MTlhMjE0Ljc5IDIxNC43OSAwIDAgMC0yMy40ODMtMTYuNTYyYy0zNC40NDItMjEuMDEyLTc0LjA3Ni0zMi4xMzUtMTE0LjY5OC0zMi4xMzUtMjkuMjUgMC01Ny41OTUgNS42MDMtODQuMzc1IDE2LjcyNy0yNS44NzIgMTAuNzExLTQ5LjE5IDI2LjEyLTY5LjIxMyA0NS43My0yMC4xMDUgMTkuNjkzLTM1Ljg0MyA0Mi42LTQ2Ljg4NSA2OC4yMjUtMTEuNDUzIDI2LjYxNS0xNy4zMDMgNTQuODc3LTE3LjMwMyA4My45NjMgMCAyNy40MzkgNS42MDMgNTYuMDMgMTYuNzI3IDg1LjExNyA5LjMxIDI0LjMwNyAyMi42NTkgNDkuNTIgMzkuNzE1IDc0Ljk4MSAyNy4wMjcgNDAuMjkzIDY0LjE4OCA4Mi4zMTYgMTEwLjMzIDEyNC45MTUgNzYuNDY1IDcwLjYxNSAxNTIuMTg5IDExOS4zOTQgMTU1LjQwMiAxMjEuMzcxbDE5LjUyOCAxMi41MjVjOC42NTIgNS41MiAxOS43NzYgNS41MiAyOC40MjcgMGwxOS41MjktMTIuNTI1YzMuMjEzLTIuMDYgNzguODU0LTUwLjc1NiAxNTUuNDAxLTEyMS4zNzEgNDYuMTQzLTQyLjYgODMuMzA0LTg0LjYyMiAxMTAuMzMtMTI0LjkxNSAxNy4wNTctMjUuNDYgMzAuNDg3LTUwLjY3NCAzOS43MTYtNzQuOTgxIDExLjEyNC0yOS4wODcgMTYuNzI3LTU3LjY3OCAxNi43MjctODUuMTE3LjA4Mi0yOS4wODYtNS43NjgtNTcuMzQ4LTE3LjIyMS04My45NjN6XCIrKHQ/XCJcIjpcIk01MTIgNzYxLjVTMjE4LjY2NSA1NzMuNTUgMjE4LjY2NSA0MDcuNzY3YzAtODMuOTYzIDY5LjQ2MS0xNTIuMDIzIDE1NS4xNTQtMTUyLjAyMyA2MC4yMzMgMCAxMTIuNDczIDMzLjYxOCAxMzguMTgxIDgyLjcyNyAyNS43MDgtNDkuMTA5IDc3Ljk0OC04Mi43MjcgMTM4LjE4LTgyLjcyNyA4NS42OTQgMCAxNTUuMTU1IDY4LjA2IDE1NS4xNTUgMTUyLjAyM0M4MDUuMzM1IDU3My41NTEgNTEyIDc2MS41IDUxMiA3NjEuNXpcIiksZmlsbDp0P1wicmVkXCI6XCJjdXJyZW50Q29sb3JcIn0pXSksVmU9KCk9PmUoXCJzdmdcIix7dmlld0JveDpcIjAgMCAxMDI0IDEwMjRcIix3aWR0aDpcIjI0XCIsaGVpZ2h0OlwiMjRcIn0sW2UoXCJwYXRoXCIse2Q6XCJNNzEwLjgxNiA2NTQuMzAxYzcwLjMyMy05Ni42MzkgNjEuMDg0LTIzMC41NzgtMjMuNzA1LTMxNC44NDMtNDYuMDk4LTQ2LjA5OC0xMDcuMTgzLTcxLjEwOS0xNzIuMjgtNzEuMTA5LTY1LjAwOCAwLTEyNi4wOTIgMjUuNDQ0LTE3Mi4yOCA3MS4xMDktNDUuMjI3IDQ2LjA5OC03MC43NTYgMTA3LjE4My03MC43NTYgMTcyLjEwNiAwIDY0LjkyMyAyNS40NDQgMTI2LjAwNyA3MS4xOTQgMTcyLjEwNiA0Ni4wOTkgNDYuMDk4IDEwNy4xODQgNzEuMTA5IDE3Mi4yOCA3MS4xMDkgNTEuNDE0IDAgMTAwLjY0OC0xNi4yMTIgMTQyLjgyNC00Ny40MDRsMTI2LjUzIDEyNi4wMDZjNy4wNTggNy4wNiAxNi4yOTcgMTAuOTc5IDI2LjQwNiAxMC45NzkgMTAuMTA1IDAgMTkuMzQzLTMuOTE5IDI2LjQwMi0xMC45NzkgMTQuNDY3LTE0LjQ2NyAxNC40NjctMzguMTcyIDAtNTIuNzIzTDcxMC44MTYgNjU0LjMwMXptLTMxNS4xMDctMjMuMjY1Yy02NS44OC02NS44OC02NS44OC0xNzIuNTQgMC0yMzguNDIgMzIuMDY5LTMyLjA3IDc0LjI0NS00OS4xNDkgMTE5LjQ3MS00OS4xNDkgNDUuMjI3IDAgODcuNDA3IDE3LjYwMyAxMTkuNDcyIDQ5LjE0OSA2NS44OCA2NS44NzkgNjUuODggMTcyLjUzOSAwIDIzOC40Mi02My42MTIgNjMuMTc4LTE3NS4yNDIgNjMuMTc4LTIzOC45NDMgMHptMCAwXCIsZmlsbDpcImN1cnJlbnRDb2xvclwifSksZShcInBhdGhcIix7ZDpcIk03MDMuMzE5IDEyMS42MDNIMzIxLjAzYy0xMDkuOCAwLTE5OS40NjkgODkuMTQ2LTE5OS40NjkgMTk5LjM4djM4Mi4wMzRjMCAxMDkuNzk2IDg5LjIzNiAxOTkuMzggMTk5LjQ2OSAxOTkuMzhoMjA3LjM5N2MyMC42NTMgMCAzNy4zODQtMTYuNjQ1IDM3LjM4NC0zNy4yOTkgMC0yMC42NDktMTYuNzMxLTM3LjI5Ni0zNy4zODQtMzcuMjk2SDMyMS4wM2MtNjguNTgyIDAtMTI0LjM1Mi01NS43Ny0xMjQuMzUyLTEyNC4yNjdWMzIxLjQyMWMwLTY4LjQ5NiA1NS43Ny0xMjQuMjY3IDEyNC4zNTItMTI0LjI2N2gzODIuMjg5YzY4LjU4MiAwIDEyNC4zNTIgNTUuNzcxIDEyNC4zNTIgMTI0LjI2N1Y1MjQuNzJjMCAyMC42NTQgMTYuNzM2IDM3LjI5OSAzNy4zODUgMzcuMjk5IDIwLjY1NCAwIDM3LjM4NC0xNi42NDUgMzcuMzg0LTM3LjI5OVYzMjAuNTQ5Yy0uMDg1LTEwOS44LTg5LjMyMS0xOTguOTQ2LTE5OS4xMjEtMTk4Ljk0NnptMCAwXCIsZmlsbDpcImN1cnJlbnRDb2xvclwifSldKSxEZT0oKT0+ZShcInN2Z1wiLHt3aWR0aDpcIjE2XCIsaGVpZ2h0OlwiMTZcIixhcmlhSGlkZGVuOlwidHJ1ZVwifSxlKFwicGF0aFwiLHtkOlwiTTE0Ljg1IDNIMS4xNUMuNTIgMyAwIDMuNTIgMCA0LjE1djcuNjlDMCAxMi40OC41MiAxMyAxLjE1IDEzaDEzLjY5Yy42NCAwIDEuMTUtLjUyIDEuMTUtMS4xNXYtNy43QzE2IDMuNTIgMTUuNDggMyAxNC44NSAzek05IDExSDdWOEw1LjUgOS45MiA0IDh2M0gyVjVoMmwxLjUgMkw3IDVoMnY2em0yLjk5LjVMOS41IDhIMTFWNWgydjNoMS41bC0yLjUxIDMuNXpcIixmaWxsOlwiY3VycmVudENvbG9yXCJ9KSksTmU9KCk9PmUoXCJzdmdcIix7dmlld0JveDpcIjAgMCAxMDI0IDEwMjRcIix3aWR0aDpcIjI0XCIsaGVpZ2h0OlwiMjRcIn0sZShcInBhdGhcIix7ZDpcIk04MTAuNjY3IDIxMy4zMzNhNjQgNjQgMCAwIDEgNjQgNjRWNzA0YTY0IDY0IDAgMCAxLTY0IDY0SDQ3OC4zMzZsLTE0Ni42NDUgOTYuMTA3YTIxLjMzMyAyMS4zMzMgMCAwIDEtMzMuMDI0LTE3Ljg1NlY3NjhoLTg1LjMzNGE2NCA2NCAwIDAgMS02NC02NFYyNzcuMzMzYTY0IDY0IDAgMCAxIDY0LTY0aDU5Ny4zMzR6bTAgNjRIMjEzLjMzM1Y3MDRoMTQ5LjMzNHY2My4yOTZMNDU5LjI0MyA3MDRoMzUxLjQyNFYyNzcuMzMzem0tMjcxLjM2IDIxMy4zMzR2NjRoLTE3Ni42NHYtNjRoMTc2LjY0em0xMjIuMDI2LTEyOHY2NEgzNjIuNjY3di02NGgyOTguNjY2elwiLGZpbGw6XCJjdXJyZW50Q29sb3JcIn0pKSxCZT0oKT0+ZShcInN2Z1wiLHt2aWV3Qm94OlwiMCAwIDEwMjQgMTAyNFwiLHdpZHRoOlwiMjRcIixoZWlnaHQ6XCIyNFwifSxlKFwicGF0aFwiLHtkOlwiTTgxMy4wMzkgMzE4Ljc3Mkw0ODAuNTMgNjUxLjI3OEgzNjAuNzE4VjUzMS40NjNMNjkzLjIyNyAxOTguOTYxQzY5Ny45MDQgMTk0LjI4NCA3MDQuMDI3IDE5MiA3MTAuMTU3IDE5MkM3MTYuMzAyIDE5MiA3MjIuNDM2IDE5NC4yODQgNzI3LjExNCAxOTguOTYxTDgxMy4wMzkgMjg0Ljg4QzgxNy43MiAyODkuNTYxIDgyMCAyOTUuNjg0IDgyMCAzMDEuODI1QzgyMCAzMDcuOTUgODE3LjcyIDMxNC4wOTMgODEzLjAzOSAzMTguNzcyWk03MTAuMTcyIDI2MS44ODhMNDIwLjYyNCA1NTEuNDMxVjU5MS4zNzZINDYwLjU2MUw3NTAuMTA5IDMwMS44MjVMNzEwLjE3MiAyNjEuODg4Wk00OTAuNTE3IDI5MS44NDVIMjQwLjkwNlY3NzEuMDlINzIwLjE1NlY1MjEuNDc5QzcyMC4xNTYgNTA0Ljk0NyA3MzMuNTU5IDQ5MS41MjkgNzUwLjEwOSA0OTEuNTI5Qzc2Ni42NTMgNDkxLjUyOSA3ODAuMDYzIDUwNC45NDcgNzgwLjA2MyA1MjEuNDc5Vjc5MS4wNTlDNzgwLjA2MyA4MTMuMTE4IDc2Mi4xOCA4MzEgNzQwLjEyNSA4MzFIMjIwLjkzN0MxOTguODgyIDgzMSAxODEgODEzLjExOCAxODEgNzkxLjA1OVYyNzEuODcyQzE4MSAyNDkuODE3IDE5OC44ODIgMjMxLjkzNSAyMjAuOTM3IDIzMS45MzVINDkwLjUxN0M1MDcuMDYgMjMxLjkzNSA1MjAuNDcgMjQ1LjM1MiA1MjAuNDcgMjYxLjg4OEM1MjAuNDcgMjc4LjQyNCA1MDcuMDYgMjkxLjg0NSA0OTAuNTE3IDI5MS44NDVaXCIsZmlsbDpcImN1cnJlbnRDb2xvclwifSkpLFdlPSgpPT5lKFwic3ZnXCIse2NsYXNzOlwidmVyaWZpZWQtaWNvblwiLHZpZXdCb3g6XCIwIDAgMTAyNCAxMDI0XCIsd2lkdGg6XCIxNFwiLGhlaWdodDpcIjE0XCJ9LGUoXCJwYXRoXCIse2Q6XCJtODk0LjQgNDYxLjU2LTU0LjQtNjMuMmMtMTAuNC0xMi0xOC44LTM0LjQtMTguOC01MC40di02OGMwLTQyLjQtMzQuOC03Ny4yLTc3LjItNzcuMmgtNjhjLTE1LjYgMC0zOC40LTguNC01MC40LTE4LjhsLTYzLjItNTQuNGMtMjcuNi0yMy42LTcyLjgtMjMuNi0xMDAuOCAwbC02Mi44IDU0LjhjLTEyIDEwLTM0LjggMTguNC01MC40IDE4LjRoLTY5LjJjLTQyLjQgMC03Ny4yIDM0LjgtNzcuMiA3Ny4ydjY4LjRjMCAxNS42LTguNCAzOC0xOC40IDUwbC01NCA2My42Yy0yMy4yIDI3LjYtMjMuMiA3Mi40IDAgMTAwbDU0IDYzLjZjMTAgMTIgMTguNCAzNC40IDE4LjQgNTB2NjguNGMwIDQyLjQgMzQuOCA3Ny4yIDc3LjIgNzcuMmg2OS4yYzE1LjYgMCAzOC40IDguNCA1MC40IDE4LjhsNjMuMiA1NC40YzI3LjYgMjMuNiA3Mi44IDIzLjYgMTAwLjggMGw2My4yLTU0LjRjMTItMTAuNCAzNC40LTE4LjggNTAuNC0xOC44aDY4YzQyLjQgMCA3Ny4yLTM0LjggNzcuMi03Ny4ydi02OGMwLTE1LjYgOC40LTM4LjQgMTguOC01MC40bDU0LjQtNjMuMmMyMy4yLTI3LjYgMjMuMi03My4yLS40LTEwMC44em0tMjE2LTI1LjItMTkzLjIgMTkzLjJhMzAgMzAgMCAwIDEtNDIuNCAwbC05Ni44LTk2LjhhMzAuMTYgMzAuMTYgMCAwIDEgMC00Mi40YzExLjYtMTEuNiAzMC44LTExLjYgNDIuNCAwbDc1LjYgNzUuNiAxNzItMTcyYzExLjYtMTEuNiAzMC44LTExLjYgNDIuNCAwIDExLjYgMTEuNiAxMS42IDMwLjggMCA0Mi40elwiLGZpbGw6XCIjMjdhZTYwXCJ9KSksRmU9KHtzaXplOnQ9MTAwfSk9PmUoXCJzdmdcIix7d2lkdGg6dCxoZWlnaHQ6dCx2aWV3Qm94OlwiMCAwIDEwMCAxMDBcIixwcmVzZXJ2ZUFzcGVjdFJhdGlvOlwieE1pZFlNaWRcIn0sZShcImNpcmNsZVwiLHtjeDo1MCxjeTo1MCxmaWxsOlwibm9uZVwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiNFwiLHI6XCI0MFwiLFwic3Ryb2tlLWRhc2hhcnJheVwiOlwiODUgMzBcIn0sZShcImFuaW1hdGVUcmFuc2Zvcm1cIix7YXR0cmlidXRlTmFtZTpcInRyYW5zZm9ybVwiLHR5cGU6XCJyb3RhdGVcIixyZXBlYXRDb3VudDpcImluZGVmaW5pdGVcIixkdXI6XCIxc1wiLHZhbHVlczpcIjAgNTAgNTA7MzYwIDUwIDUwXCIsa2V5VGltZXM6XCIwOzFcIn0pKSksS2U9KCk9PmUoXCJzdmdcIix7d2lkdGg6MjQsaGVpZ2h0OjI0LGZpbGw6XCJjdXJyZW50Y29sb3JcIix2aWV3Qm94OlwiMCAwIDI0IDI0XCJ9LFtlKFwicGF0aFwiLHtzdHlsZTpcInRyYW5zZm9ybTogdHJhbnNsYXRlWSgwLjVweClcIixkOlwiTTE4Ljk2OCAxMC41SDE1Ljk2OFYxMS40ODRIMTcuOTg0VjEyLjk4NEgxNS45NjhWMTVIMTQuNDY4VjlIMTguOTY4VjEwLjVWMTAuNVpNOC45ODQgOUM5LjI2NTMzIDkgOS40OTk2NyA5LjA5MzY3IDkuNjg3IDkuMjgxQzkuODc0MzMgOS40NjgzMyA5Ljk2OCA5LjcwMjY3IDkuOTY4IDkuOTg0VjEwLjVINi40OTlWMTMuNUg4LjQ2OFYxMkg5Ljk2OFYxNC4wMTZDOS45NjggMTQuMjk3MyA5Ljg3NDMzIDE0LjUzMTcgOS42ODcgMTQuNzE5QzkuNDk5NjcgMTQuOTA2MyA5LjI2NTMzIDE1IDguOTg0IDE1SDUuOTg0QzUuNzAyNjcgMTUgNS40NjgzMyAxNC45MDYzIDUuMjgxIDE0LjcxOUM1LjA5MzY3IDE0LjUzMTcgNSAxNC4yOTczIDUgMTQuMDE2VjkuOTg1QzUgOS43MDM2NyA1LjA5MzY3IDkuNDY5MzMgNS4yODEgOS4yODJDNS40NjgzMyA5LjA5NDY3IDUuNzAyNjcgOS4wMDEgNS45ODQgOS4wMDFIOC45ODRWOVpNMTEuNDY4IDlIMTIuOTY4VjE1SDExLjQ2OFY5VjlaXCJ9KSxlKFwicGF0aFwiLHtkOlwiTTE4LjUgM0g1Ljc1QzMuNjg3NSAzIDIgNC42ODc1IDIgNi43NVYxOEMyIDIwLjA2MjUgMy42ODc1IDIxLjc1IDUuNzUgMjEuNzVIMTguNUMyMC41NjI1IDIxLjc1IDIyLjI1IDIwLjA2MjUgMjIuMjUgMThWNi43NUMyMi4yNSA0LjY4NzUgMjAuNTYyNSAzIDE4LjUgM1pNMjAuNzUgMThDMjAuNzUgMTkuMjM3NSAxOS43Mzc1IDIwLjI1IDE4LjUgMjAuMjVINS43NUM0LjUxMjUgMjAuMjUgMy41IDE5LjIzNzUgMy41IDE4VjYuNzVDMy41IDUuNTEyNSA0LjUxMjUgNC41IDUuNzUgNC41SDE4LjVDMTkuNzM3NSA0LjUgMjAuNzUgNS41MTI1IDIwLjc1IDYuNzVWMThaXCJ9KV0pO2xldCBxZT1udWxsO2NvbnN0IEdlPSgpPT5xZXx8KHFlPV8oXCJXQUxJTkVfTElLRVwiLFtdKSk7bGV0IFplPW51bGw7Y29uc3QgSmU9KCk9PlplPz8oWmU9XyhcIldBTElORV9SRUFDVElPTlwiLHt9KSk7dmFyIFllPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp7fSxYZT17fSxRZT17fSxldD17fSx0dD1ZZSYmWWUuX19hd2FpdGVyfHxmdW5jdGlvbihlLHQsbixhKXtyZXR1cm4gbmV3KG58fChuPVByb21pc2UpKSgoZnVuY3Rpb24obCxyKXtmdW5jdGlvbiBpKGUpe3RyeXtzKGEubmV4dChlKSl9Y2F0Y2goZSl7cihlKX19ZnVuY3Rpb24gbyhlKXt0cnl7cyhhLnRocm93KGUpKX1jYXRjaChlKXtyKGUpfX1mdW5jdGlvbiBzKGUpe3ZhciB0O2UuZG9uZT9sKGUudmFsdWUpOih0PWUudmFsdWUsdCBpbnN0YW5jZW9mIG4/dDpuZXcgbigoZnVuY3Rpb24oZSl7ZSh0KX0pKSkudGhlbihpLG8pfXMoKGE9YS5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pKX0sbnQ9WWUmJlllLl9fZ2VuZXJhdG9yfHxmdW5jdGlvbihlLHQpe3ZhciBuLGEsbCxyLGk9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmbFswXSl0aHJvdyBsWzFdO3JldHVybiBsWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIHI9e25leHQ6bygwKSx0aHJvdzpvKDEpLHJldHVybjpvKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihyW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHI7ZnVuY3Rpb24gbyhyKXtyZXR1cm4gZnVuY3Rpb24obyl7cmV0dXJuIGZ1bmN0aW9uKHIpe2lmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtpOyl0cnl7aWYobj0xLGEmJihsPTImclswXT9hLnJldHVybjpyWzBdP2EudGhyb3d8fCgobD1hLnJldHVybikmJmwuY2FsbChhKSwwKTphLm5leHQpJiYhKGw9bC5jYWxsKGEsclsxXSkpLmRvbmUpcmV0dXJuIGw7c3dpdGNoKGE9MCxsJiYocj1bMiZyWzBdLGwudmFsdWVdKSxyWzBdKXtjYXNlIDA6Y2FzZSAxOmw9cjticmVhaztjYXNlIDQ6cmV0dXJuIGkubGFiZWwrKyx7dmFsdWU6clsxXSxkb25lOiExfTtjYXNlIDU6aS5sYWJlbCsrLGE9clsxXSxyPVswXTtjb250aW51ZTtjYXNlIDc6cj1pLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKGw9aS50cnlzLChsPWwubGVuZ3RoPjAmJmxbbC5sZW5ndGgtMV0pfHw2IT09clswXSYmMiE9PXJbMF0pKXtpPTA7Y29udGludWV9aWYoMz09PXJbMF0mJighbHx8clsxXT5sWzBdJiZyWzFdPGxbM10pKXtpLmxhYmVsPXJbMV07YnJlYWt9aWYoNj09PXJbMF0mJmkubGFiZWw8bFsxXSl7aS5sYWJlbD1sWzFdLGw9cjticmVha31pZihsJiZpLmxhYmVsPGxbMl0pe2kubGFiZWw9bFsyXSxpLm9wcy5wdXNoKHIpO2JyZWFrfWxbMl0mJmkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZX1yPXQuY2FsbChlLGkpfWNhdGNoKGUpe3I9WzYsZV0sYT0wfWZpbmFsbHl7bj1sPTB9aWYoNSZyWzBdKXRocm93IHJbMV07cmV0dXJue3ZhbHVlOnJbMF0/clsxXTp2b2lkIDAsZG9uZTohMH19KFtyLG9dKX19fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZXQuUmVDYXB0Y2hhSW5zdGFuY2U9dm9pZCAwO3ZhciBhdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMuc2l0ZUtleT1lLHRoaXMucmVjYXB0Y2hhSUQ9dCx0aGlzLnJlY2FwdGNoYT1uLHRoaXMuc3R5bGVDb250YWluZXI9bnVsbH1yZXR1cm4gZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBudCh0aGlzLChmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLnJlY2FwdGNoYS5lbnRlcnByaXNlP3RoaXMucmVjYXB0Y2hhLmVudGVycHJpc2UuZXhlY3V0ZSh0aGlzLnJlY2FwdGNoYUlELHthY3Rpb246ZX0pOnRoaXMucmVjYXB0Y2hhLmV4ZWN1dGUodGhpcy5yZWNhcHRjaGFJRCx7YWN0aW9uOmV9KV19KSl9KSl9LGUucHJvdG90eXBlLmdldFNpdGVLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXRlS2V5fSxlLnByb3RvdHlwZS5oaWRlQmFkZ2U9ZnVuY3Rpb24oKXtudWxsPT09dGhpcy5zdHlsZUNvbnRhaW5lciYmKHRoaXMuc3R5bGVDb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLHRoaXMuc3R5bGVDb250YWluZXIuaW5uZXJIVE1MPVwiLmdyZWNhcHRjaGEtYmFkZ2V7dmlzaWJpbGl0eTpoaWRkZW4gIWltcG9ydGFudDt9XCIsZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlQ29udGFpbmVyKSl9LGUucHJvdG90eXBlLnNob3dCYWRnZT1mdW5jdGlvbigpe251bGwhPT10aGlzLnN0eWxlQ29udGFpbmVyJiYoZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZCh0aGlzLnN0eWxlQ29udGFpbmVyKSx0aGlzLnN0eWxlQ29udGFpbmVyPW51bGwpfSxlfSgpO2V0LlJlQ2FwdGNoYUluc3RhbmNlPWF0LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxRZS5nZXRJbnN0YW5jZT1RZS5sb2FkPXZvaWQgMDt2YXIgbHQscnQ9ZXQ7IWZ1bmN0aW9uKGUpe2VbZS5OT1RfTE9BREVEPTBdPVwiTk9UX0xPQURFRFwiLGVbZS5MT0FESU5HPTFdPVwiTE9BRElOR1wiLGVbZS5MT0FERUQ9Ml09XCJMT0FERURcIn0obHR8fChsdD17fSkpO3ZhciBpdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUubG9hZD1mdW5jdGlvbih0LG4pe2lmKHZvaWQgMD09PW4mJihuPXt9KSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlRoaXMgaXMgYSBsaWJyYXJ5IGZvciB0aGUgYnJvd3NlciFcIikpO2lmKGUuZ2V0TG9hZGluZ1N0YXRlKCk9PT1sdC5MT0FERUQpcmV0dXJuIGUuaW5zdGFuY2UuZ2V0U2l0ZUtleSgpPT09dD9Qcm9taXNlLnJlc29sdmUoZS5pbnN0YW5jZSk6UHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwicmVDQVBUQ0hBIGFscmVhZHkgbG9hZGVkIHdpdGggZGlmZmVyZW50IHNpdGUga2V5IVwiKSk7aWYoZS5nZXRMb2FkaW5nU3RhdGUoKT09PWx0LkxPQURJTkcpcmV0dXJuIHQhPT1lLmluc3RhbmNlU2l0ZUtleT9Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJyZUNBUFRDSEEgYWxyZWFkeSBsb2FkZWQgd2l0aCBkaWZmZXJlbnQgc2l0ZSBrZXkhXCIpKTpuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXtlLnN1Y2Nlc3NmdWxMb2FkaW5nQ29uc3VtZXJzLnB1c2goKGZ1bmN0aW9uKGUpe3JldHVybiB0KGUpfSkpLGUuZXJyb3JMb2FkaW5nUnVubmFibGUucHVzaCgoZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSl9KSl9KSk7ZS5pbnN0YW5jZVNpdGVLZXk9dCxlLnNldExvYWRpbmdTdGF0ZShsdC5MT0FESU5HKTt2YXIgYT1uZXcgZTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGwscil7YS5sb2FkU2NyaXB0KHQsbi51c2VSZWNhcHRjaGFOZXR8fCExLG4udXNlRW50ZXJwcmlzZXx8ITEsbi5yZW5kZXJQYXJhbWV0ZXJzP24ucmVuZGVyUGFyYW1ldGVyczp7fSxuLmN1c3RvbVVybCkudGhlbigoZnVuY3Rpb24oKXtlLnNldExvYWRpbmdTdGF0ZShsdC5MT0FERUQpO3ZhciByPWEuZG9FeHBsaWNpdFJlbmRlcihncmVjYXB0Y2hhLHQsbi5leHBsaWNpdFJlbmRlclBhcmFtZXRlcnM/bi5leHBsaWNpdFJlbmRlclBhcmFtZXRlcnM6e30sbi51c2VFbnRlcnByaXNlfHwhMSksaT1uZXcgcnQuUmVDYXB0Y2hhSW5zdGFuY2UodCxyLGdyZWNhcHRjaGEpO2Uuc3VjY2Vzc2Z1bExvYWRpbmdDb25zdW1lcnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoaSl9KSksZS5zdWNjZXNzZnVsTG9hZGluZ0NvbnN1bWVycz1bXSxuLmF1dG9IaWRlQmFkZ2UmJmkuaGlkZUJhZGdlKCksZS5pbnN0YW5jZT1pLGwoaSl9KSkuY2F0Y2goKGZ1bmN0aW9uKHQpe2UuZXJyb3JMb2FkaW5nUnVubmFibGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUodCl9KSksZS5lcnJvckxvYWRpbmdSdW5uYWJsZT1bXSxyKHQpfSkpfSkpfSxlLmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIGUuaW5zdGFuY2V9LGUuc2V0TG9hZGluZ1N0YXRlPWZ1bmN0aW9uKHQpe2UubG9hZGluZ1N0YXRlPXR9LGUuZ2V0TG9hZGluZ1N0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT1lLmxvYWRpbmdTdGF0ZT9sdC5OT1RfTE9BREVEOmUubG9hZGluZ1N0YXRlfSxlLnByb3RvdHlwZS5sb2FkU2NyaXB0PWZ1bmN0aW9uKHQsbixhLGwscil7dmFyIGk9dGhpczt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09YSYmKGE9ITEpLHZvaWQgMD09PWwmJihsPXt9KSx2b2lkIDA9PT1yJiYocj1cIlwiKTt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO28uc2V0QXR0cmlidXRlKFwicmVjYXB0Y2hhLXYzLXNjcmlwdFwiLFwiXCIpO3ZhciBzPVwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYXBpLmpzXCI7biYmKHM9YT9cImh0dHBzOi8vcmVjYXB0Y2hhLm5ldC9yZWNhcHRjaGEvZW50ZXJwcmlzZS5qc1wiOlwiaHR0cHM6Ly9yZWNhcHRjaGEubmV0L3JlY2FwdGNoYS9hcGkuanNcIiksYSYmKHM9XCJodHRwczovL3d3dy5nb29nbGUuY29tL3JlY2FwdGNoYS9lbnRlcnByaXNlLmpzXCIpLHImJihzPXIpLGwucmVuZGVyJiYobC5yZW5kZXI9dm9pZCAwKTt2YXIgYz10aGlzLmJ1aWxkUXVlcnlTdHJpbmcobCk7cmV0dXJuIG8uc3JjPXMrXCI/cmVuZGVyPWV4cGxpY2l0XCIrYyxuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXtvLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsaS53YWl0Rm9yU2NyaXB0VG9Mb2FkKChmdW5jdGlvbigpe3Qobyl9KSxhKSwhMSksby5vbmVycm9yPWZ1bmN0aW9uKHQpe2Uuc2V0TG9hZGluZ1N0YXRlKGx0Lk5PVF9MT0FERUQpLG4odCl9LGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobyl9KSl9LGUucHJvdG90eXBlLmJ1aWxkUXVlcnlTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLmxlbmd0aDwxP1wiXCI6XCImXCIrT2JqZWN0LmtleXMoZSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hIWVbdF19KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdCtcIj1cIitlW3RdfSkpLmpvaW4oXCImXCIpfSxlLnByb3RvdHlwZS53YWl0Rm9yU2NyaXB0VG9Mb2FkPWZ1bmN0aW9uKHQsbil7dmFyIGE9dGhpcztyZXR1cm4gZnVuY3Rpb24oKXt2b2lkIDA9PT13aW5kb3cuZ3JlY2FwdGNoYT9zZXRUaW1lb3V0KChmdW5jdGlvbigpe2Eud2FpdEZvclNjcmlwdFRvTG9hZCh0LG4pfSksZS5TQ1JJUFRfTE9BRF9ERUxBWSk6bj93aW5kb3cuZ3JlY2FwdGNoYS5lbnRlcnByaXNlLnJlYWR5KChmdW5jdGlvbigpe3QoKX0pKTp3aW5kb3cuZ3JlY2FwdGNoYS5yZWFkeSgoZnVuY3Rpb24oKXt0KCl9KSl9fSxlLnByb3RvdHlwZS5kb0V4cGxpY2l0UmVuZGVyPWZ1bmN0aW9uKGUsdCxuLGEpe3ZhciBsPXtzaXRla2V5OnQsYmFkZ2U6bi5iYWRnZSxzaXplOm4uc2l6ZSx0YWJpbmRleDpuLnRhYmluZGV4fTtyZXR1cm4gbi5jb250YWluZXI/YT9lLmVudGVycHJpc2UucmVuZGVyKG4uY29udGFpbmVyLGwpOmUucmVuZGVyKG4uY29udGFpbmVyLGwpOmE/ZS5lbnRlcnByaXNlLnJlbmRlcihsKTplLnJlbmRlcihsKX0sZS5sb2FkaW5nU3RhdGU9bnVsbCxlLmluc3RhbmNlPW51bGwsZS5pbnN0YW5jZVNpdGVLZXk9bnVsbCxlLnN1Y2Nlc3NmdWxMb2FkaW5nQ29uc3VtZXJzPVtdLGUuZXJyb3JMb2FkaW5nUnVubmFibGU9W10sZS5TQ1JJUFRfTE9BRF9ERUxBWT0yNSxlfSgpO1FlLmxvYWQ9aXQubG9hZCxRZS5nZXRJbnN0YW5jZT1pdC5nZXRJbnN0YW5jZSxmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlJlQ2FwdGNoYUluc3RhbmNlPWUuZ2V0SW5zdGFuY2U9ZS5sb2FkPXZvaWQgMDt2YXIgdD1RZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImxvYWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5sb2FkfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZ2V0SW5zdGFuY2VcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5nZXRJbnN0YW5jZX19KTt2YXIgbj1ldDtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIlJlQ2FwdGNoYUluc3RhbmNlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uUmVDYXB0Y2hhSW5zdGFuY2V9fSl9KFhlKTtjb25zdCBvdD17fTtsZXQgc3Q9bnVsbDtjb25zdCBjdD0oKT0+c3Q/PyhzdD1fKFwiV0FMSU5FX1VTRVJcIix7fSkpLHV0PXtrZXk6MCxjbGFzczpcIndsLXJlYWN0aW9uXCJ9LGR0PVtcInRleHRDb250ZW50XCJdLHZ0PXtjbGFzczpcIndsLXJlYWN0aW9uLWxpc3RcIn0sbXQ9W1wib25DbGlja1wiXSxwdD17Y2xhc3M6XCJ3bC1yZWFjdGlvbi1pbWdcIn0sZ3Q9W1wic3JjXCIsXCJhbHRcIl0saHQ9W1widGV4dENvbnRlbnRcIl0sZnQ9W1widGV4dENvbnRlbnRcIl07dmFyIHl0PXQoe19fbmFtZTpcIkFydGljbGVSZWFjdGlvblwiLHNldHVwKGUse2V4cG9zZTp0fSl7dCgpO2NvbnN0IHk9SmUoKSx3PW4oXCJjb25maWdcIiksYj1hKC0xKSxrPWEoW10pLEM9bCgoKCk9PncudmFsdWUubG9jYWxlKSksJD1sKCgoKT0+dy52YWx1ZS5yZWFjdGlvbi5sZW5ndGg+MCkpLEw9bCgoKCk9Pntjb25zdHtyZWFjdGlvbjplLHBhdGg6dH09dy52YWx1ZTtyZXR1cm4gZS5tYXAoKChlLG4pPT4oe2ljb246ZSxkZXNjOkMudmFsdWVbYHJlYWN0aW9uJHtufWBdLGFjdGl2ZTp5LnZhbHVlW3RdPT09bn0pKSl9KSk7bGV0IFI7cmV0dXJuIHIoKCgpPT57aSgoKCk9Plt3LnZhbHVlLnNlcnZlclVSTCx3LnZhbHVlLnBhdGhdKSwoKCk9PnsoYXN5bmMoKT0+e2lmKCQudmFsdWUpe2NvbnN0e3NlcnZlclVSTDplLGxhbmc6dCxwYXRoOm4scmVhY3Rpb246YX09dy52YWx1ZSxsPW5ldyBBYm9ydENvbnRyb2xsZXI7Uj1sLmFib3J0LmJpbmQobCk7Y29uc3Qgcj1hd2FpdCBjZSh7c2VydmVyVVJMOmUsbGFuZzp0LHBhdGhzOltuXSx0eXBlOmEubWFwKCgoZSx0KT0+YHJlYWN0aW9uJHt0fWApKSxzaWduYWw6bC5zaWduYWx9KTtpZihBcnJheS5pc0FycmF5KHIpfHxcIm51bWJlclwiPT10eXBlb2YgcilyZXR1cm47ay52YWx1ZT1hLm1hcCgoKGUsdCk9PnJbYHJlYWN0aW9uJHt0fWBdKSl9fSkoKX0pLHtpbW1lZGlhdGU6ITB9KX0pKSxvKCgoKT0+Uj8uKCkpKSwoZSx0KT0+TC52YWx1ZS5sZW5ndGg/KHMoKSxjKFwiZGl2XCIsdXQsW3UoXCJkaXZcIix7Y2xhc3M6XCJ3bC1yZWFjdGlvbi10aXRsZVwiLHRleHRDb250ZW50OmQoQy52YWx1ZS5yZWFjdGlvblRpdGxlKX0sbnVsbCw4LGR0KSx1KFwidWxcIix2dCxbKHMoITApLGModixudWxsLG0oTC52YWx1ZSwoKHthY3RpdmU6ZSxpY29uOnQsZGVzYzpufSxhKT0+KHMoKSxjKFwibGlcIix7a2V5OmEsY2xhc3M6cChbXCJ3bC1yZWFjdGlvbi1pdGVtXCIse2FjdGl2ZTplfV0pLG9uQ2xpY2s6ZT0+KGFzeW5jIGU9PntpZigtMT09PWIudmFsdWUpe2NvbnN0e3NlcnZlclVSTDp0LGxhbmc6bixwYXRoOmF9PXcudmFsdWUsbD15LnZhbHVlW2FdO2IudmFsdWU9ZSx2b2lkIDAhPT1sJiYoYXdhaXQgdWUoe3NlcnZlclVSTDp0LGxhbmc6bixwYXRoOmEsdHlwZTpgcmVhY3Rpb24ke2x9YCxhY3Rpb246XCJkZXNjXCJ9KSxrLnZhbHVlW2xdPU1hdGgubWF4KGsudmFsdWVbbF0tMSwwKSksbCE9PWUmJihhd2FpdCB1ZSh7c2VydmVyVVJMOnQsbGFuZzpuLHBhdGg6YSx0eXBlOmByZWFjdGlvbiR7ZX1gfSksay52YWx1ZVtlXT0oay52YWx1ZVtlXXx8MCkrMSksbD09PWU/ZGVsZXRlIHkudmFsdWVbYV06eS52YWx1ZVthXT1lLGIudmFsdWU9LTF9fSkoYSl9LFt1KFwiZGl2XCIscHQsW3UoXCJpbWdcIix7c3JjOnQsYWx0Om59LG51bGwsOCxndCksYi52YWx1ZT09PWE/KHMoKSxnKGgoRmUpLHtrZXk6MCxjbGFzczpcIndsLXJlYWN0aW9uLWxvYWRpbmdcIn0pKToocygpLGMoXCJkaXZcIix7a2V5OjEsY2xhc3M6XCJ3bC1yZWFjdGlvbi12b3Rlc1wiLHRleHRDb250ZW50OmQoay52YWx1ZVthXXx8MCl9LG51bGwsOCxodCkpXSksdShcImRpdlwiLHtjbGFzczpcIndsLXJlYWN0aW9uLXRleHRcIix0ZXh0Q29udGVudDpkKG4pfSxudWxsLDgsZnQpXSwxMCxtdCkpKSksMTI4KSldKV0pKTpmKFwidi1pZlwiLCEwKX19KSx3dD0oZSx0KT0+e2NvbnN0IG49ZS5fX3ZjY09wdHN8fGU7Zm9yKGNvbnN0W2UsYV1vZiB0KW5bZV09YTtyZXR1cm4gbn0sYnQ9d3QoeXQsW1tcIl9fZmlsZVwiLFwiQXJ0aWNsZVJlYWN0aW9uLnZ1ZVwiXV0pO2NvbnN0IGt0PVtcImRhdGEtaW5kZXhcIl0sQ3Q9W1wic3JjXCIsXCJ0aXRsZVwiLFwib25DbGlja1wiXTt2YXIgJHQ9d3QodCh7X19uYW1lOlwiSW1hZ2VXYWxsXCIscHJvcHM6e2l0ZW1zOntkZWZhdWx0OigpPT5bXX0sY29sdW1uV2lkdGg6e2RlZmF1bHQ6MzAwfSxnYXA6e2RlZmF1bHQ6MH19LGVtaXRzOltcImluc2VydFwiXSxzZXR1cChlLHtleHBvc2U6dH0pe2NvbnN0IG49ZTt0KCk7bGV0IGw9bnVsbDtjb25zdCBvPWEobnVsbCksZD1hKHt9KSxwPWEoW10pLGs9KCk9Pntjb25zdCBlPU1hdGguZmxvb3IoKG8udmFsdWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgrbi5nYXApLyhuLmNvbHVtbldpZHRoK24uZ2FwKSk7cmV0dXJuIGU+MD9lOjF9LEM9YXN5bmMgZT0+e2lmKGU+PW4uaXRlbXMubGVuZ3RoKXJldHVybjthd2FpdCBiKCk7Y29uc3QgdD1BcnJheS5mcm9tKG8udmFsdWU/LmNoaWxkcmVufHxbXSkucmVkdWNlKCgoZSx0KT0+dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ8ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ/dDplKSk7cC52YWx1ZVtOdW1iZXIodC5kYXRhc2V0LmluZGV4KV0ucHVzaChlKSxhd2FpdCBDKGUrMSl9LCQ9YXN5bmMoZT0hMSk9PntpZihwLnZhbHVlLmxlbmd0aD09PWsoKSYmIWUpcmV0dXJuO3ZhciB0O3AudmFsdWU9KHQ9aygpLG5ldyBBcnJheSh0KS5maWxsKG51bGwpLm1hcCgoKCk9PltdKSkpO2NvbnN0IG49d2luZG93LnNjcm9sbFk7YXdhaXQgQygwKSx3aW5kb3cuc2Nyb2xsVG8oe3RvcDpufSl9LEw9ZT0+e2QudmFsdWVbZS50YXJnZXQuc3JjXT0hMH07cmV0dXJuIHIoKCgpPT57JCghMCksbD1uZXcgUmVzaXplT2JzZXJ2ZXIoKCgpPT57JCgpfSkpLGwub2JzZXJ2ZShvLnZhbHVlKSxpKCgoKT0+W24uaXRlbXNdKSwoKCk9PntkLnZhbHVlPXt9LCQoITApfSkpLGkoKCgpPT5bbi5jb2x1bW5XaWR0aCxuLmdhcF0pLCgoKT0+eyQoKX0pKX0pKSx5KCgoKT0+bC51bm9ic2VydmUoby52YWx1ZSkpKSwoZSx0KT0+KHMoKSxjKFwiZGl2XCIse3JlZl9rZXk6XCJ3YWxsXCIscmVmOm8sY2xhc3M6XCJ3bC1nYWxsZXJ5XCIsc3R5bGU6dyh7Z2FwOmAke2UuZ2FwfXB4YH0pfSxbKHMoITApLGModixudWxsLG0ocC52YWx1ZSwoKHQsbik9PihzKCksYyhcImRpdlwiLHtrZXk6bixjbGFzczpcIndsLWdhbGxlcnktY29sdW1uXCIsXCJkYXRhLWluZGV4XCI6bixzdHlsZTp3KHtnYXA6YCR7ZS5nYXB9cHhgfSl9LFsocyghMCksYyh2LG51bGwsbSh0LCh0PT4ocygpLGModix7a2V5OnR9LFtkLnZhbHVlW2UuaXRlbXNbdF0uc3JjXT9mKFwidi1pZlwiLCEwKToocygpLGcoaChGZSkse2tleTowLHNpemU6MzYsc3R5bGU6e21hcmdpbjpcIjIwcHggYXV0b1wifX0pKSx1KFwiaW1nXCIse2NsYXNzOlwid2wtZ2FsbGVyeS1pdGVtXCIsc3JjOmUuaXRlbXNbdF0uc3JjLHRpdGxlOmUuaXRlbXNbdF0udGl0bGUsbG9hZGluZzpcImxhenlcIixvbkxvYWQ6TCxvbkNsaWNrOm49PmUuJGVtaXQoXCJpbnNlcnRcIixgIVtdKCR7ZS5pdGVtc1t0XS5zcmN9KWApfSxudWxsLDQwLEN0KV0sNjQpKSkpLDEyOCkpXSwxMixrdCkpKSksMTI4KSldLDQpKX19KSxbW1wiX19maWxlXCIsXCJJbWFnZVdhbGwudnVlXCJdXSk7Y29uc3QgTHQ9e2NsYXNzOlwid2wtY29tbWVudFwifSxSdD17a2V5OjAsY2xhc3M6XCJ3bC1sb2dpbi1pbmZvXCJ9LHh0PXtjbGFzczpcIndsLWF2YXRhclwifSxFdD1bXCJ0aXRsZVwiXSxJdD1bXCJ0aXRsZVwiXSxqdD1bXCJzcmNcIl0sQXQ9W1widGl0bGVcIixcInRleHRDb250ZW50XCJdLFN0PXtjbGFzczpcIndsLXBhbmVsXCJ9LFV0PVtcImZvclwiLFwidGV4dENvbnRlbnRcIl0sX3Q9W1wiaWRcIixcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIixcIm5hbWVcIixcInR5cGVcIl0senQ9W1wicGxhY2Vob2xkZXJcIl0sTXQ9e2NsYXNzOlwid2wtcHJldmlld1wifSxIdD11KFwiaHJcIixudWxsLG51bGwsLTEpLFR0PVtcImlubmVySFRNTFwiXSxPdD17Y2xhc3M6XCJ3bC1mb290ZXJcIn0sUHQ9e2NsYXNzOlwid2wtYWN0aW9uc1wifSxWdD17aHJlZjpcImh0dHBzOi8vZ3VpZGVzLmdpdGh1Yi5jb20vZmVhdHVyZXMvbWFzdGVyaW5nLW1hcmtkb3duL1wiLHRpdGxlOlwiTWFya2Rvd24gR3VpZGVcIixcImFyaWEtbGFiZWxcIjpcIk1hcmtkb3duIGlzIHN1cHBvcnRlZFwiLGNsYXNzOlwid2wtYWN0aW9uXCIsdGFyZ2V0OlwiX2JsYW5rXCIscmVsOlwibm9vcGVuZXIgbm9yZWZlcnJlclwifSxEdD1bXCJ0aXRsZVwiXSxOdD1bXCJ0aXRsZVwiXSxCdD1bXCJ0aXRsZVwiXSxXdD1bXCJ0aXRsZVwiXSxGdD17Y2xhc3M6XCJ3bC1pbmZvXCJ9LEt0PXUoXCJkaXZcIix7Y2xhc3M6XCJ3bC1jYXB0Y2hhLWNvbnRhaW5lclwifSxudWxsLC0xKSxxdD17Y2xhc3M6XCJ3bC10ZXh0LW51bWJlclwifSxHdD17a2V5OjB9LFp0PVtcInRleHRDb250ZW50XCJdLEp0PVtcInRleHRDb250ZW50XCJdLFl0PVtcImRpc2FibGVkXCJdLFh0PVtcInBsYWNlaG9sZGVyXCJdLFF0PXtrZXk6MSxjbGFzczpcIndsLWxvYWRpbmdcIn0sZW49e2tleTowLGNsYXNzOlwid2wtdGFiLXdyYXBwZXJcIn0sdG49W1widGl0bGVcIixcIm9uQ2xpY2tcIl0sbm49W1wic3JjXCIsXCJhbHRcIl0sYW49e2tleTowLGNsYXNzOlwid2wtdGFic1wifSxsbj1bXCJvbkNsaWNrXCJdLHJuPVtcInNyY1wiLFwiYWx0XCIsXCJ0aXRsZVwiXSxvbj1bXCJ0aXRsZVwiXTt2YXIgc249dCh7X19uYW1lOlwiQ29tbWVudEJveFwiLHByb3BzOntlZGl0OntkZWZhdWx0Om51bGx9LHJvb3RJZDp7ZGVmYXVsdDpcIlwifSxyZXBseUlkOntkZWZhdWx0OlwiXCJ9LHJlcGx5VXNlcjp7ZGVmYXVsdDpcIlwifX0sZW1pdHM6W1wibG9nXCIsXCJjYW5jZWxFZGl0XCIsXCJjYW5jZWxSZXBseVwiLFwic3VibWl0XCJdLHNldHVwKGUse2V4cG9zZTp0LGVtaXQ6eX0pe2NvbnN0IHc9ZTt0KCk7Y29uc3QgYj1uKFwiY29uZmlnXCIpLGo9XyhcIldBTElORV9DT01NRU5UX0JPWF9FRElUT1JcIixcIlwiKSxBPV8oXCJXQUxJTkVfVVNFUl9NRVRBXCIse25pY2s6XCJcIixtYWlsOlwiXCIsbGluazpcIlwifSksUz1jdCgpLFU9YSh7fSksSD1hKG51bGwpLFQ9YShudWxsKSxQPWEobnVsbCksVj1hKG51bGwpLEQ9YShudWxsKSxOPWEobnVsbCksQj1hKG51bGwpLFc9YSh7dGFiczpbXSxtYXA6e319KSxGPWEoMCksSz1hKCExKSxxPWEoITEpLEc9YSghMSksWj1hKFwiXCIpLEo9YSgwKSxZPWsoe2xvYWRpbmc6ITAsbGlzdDpbXX0pLFg9YSgwKSxRPWEoITEpLGVlPWEoXCJcIiksdGU9YSghMSksbmU9YSghMSksYWU9bCgoKCk9PmIudmFsdWUubG9jYWxlKSksbGU9bCgoKCk9PkJvb2xlYW4oUy52YWx1ZT8udG9rZW4pKSkscmU9bCgoKCk9PiExIT09Yi52YWx1ZS5pbWFnZVVwbG9hZGVyKSksaWU9ZT0+e2NvbnN0IHQ9SC52YWx1ZSxuPXQuc2VsZWN0aW9uU3RhcnQsYT10LnNlbGVjdGlvbkVuZHx8MCxsPXQuc2Nyb2xsVG9wO2oudmFsdWU9dC52YWx1ZS5zdWJzdHJpbmcoMCxuKStlK3QudmFsdWUuc3Vic3RyaW5nKGEsdC52YWx1ZS5sZW5ndGgpLHQuZm9jdXMoKSx0LnNlbGVjdGlvblN0YXJ0PW4rZS5sZW5ndGgsdC5zZWxlY3Rpb25FbmQ9bitlLmxlbmd0aCx0LnNjcm9sbFRvcD1sfSxvZT1lPT57Y29uc3QgdD1lLmtleTsoZS5jdHJsS2V5fHxlLm1ldGFLZXkpJiZcIkVudGVyXCI9PT10JiZwZSgpfSxzZT1lPT57Y29uc3QgdD1gIVske2IudmFsdWUubG9jYWxlLnVwbG9hZGluZ30gJHtlLm5hbWV9XSgpYDtyZXR1cm4gaWUodCksdGUudmFsdWU9ITAsUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCk9PmIudmFsdWUuaW1hZ2VVcGxvYWRlcihlKSkpLnRoZW4oKG49PntqLnZhbHVlPWoudmFsdWUucmVwbGFjZSh0LGBcXHJcXG4hWyR7ZS5uYW1lfV0oJHtufSlgKX0pKS5jYXRjaCgoZT0+e2FsZXJ0KGUubWVzc2FnZSksai52YWx1ZT1qLnZhbHVlLnJlcGxhY2UodCxcIlwiKX0pKS50aGVuKCgoKT0+e3RlLnZhbHVlPSExfSkpfSxjZT1lPT57aWYoZS5kYXRhVHJhbnNmZXI/Lml0ZW1zKXtjb25zdCB0PUVlKGUuZGF0YVRyYW5zZmVyLml0ZW1zKTt0JiZyZS52YWx1ZSYmKHNlKHQpLGUucHJldmVudERlZmF1bHQoKSl9fSx1ZT1lPT57aWYoZS5jbGlwYm9hcmREYXRhKXtjb25zdCB0PUVlKGUuY2xpcGJvYXJkRGF0YS5pdGVtcyk7dCYmcmUudmFsdWUmJnNlKHQpfX0sdmU9KCk9Pntjb25zdCBlPVQudmFsdWU7ZS5maWxlcyYmcmUudmFsdWUmJnNlKGUuZmlsZXNbMF0pLnRoZW4oKCgpPT57ZS52YWx1ZT1cIlwifSkpfSxwZT1hc3luYygpPT57Y29uc3R7c2VydmVyVVJMOmUsbGFuZzp0LGxvZ2luOm4sd29yZExpbWl0OmEscmVxdWlyZWRNZXRhOmwscmVjYXB0Y2hhVjNLZXk6cix0dXJuc3RpbGVLZXk6aX09Yi52YWx1ZSxvPWF3YWl0KGFzeW5jKCk9PntpZighbmF2aWdhdG9yKXJldHVyblwiXCI7Y29uc3R7dXNlckFnZW50RGF0YTplfT1uYXZpZ2F0b3I7bGV0IHQ9bmF2aWdhdG9yLnVzZXJBZ2VudDtpZighZXx8XCJXaW5kb3dzXCIhPT1lLnBsYXRmb3JtKXJldHVybiB0O2NvbnN0e3BsYXRmb3JtVmVyc2lvbjpufT1hd2FpdCBlLmdldEhpZ2hFbnRyb3B5VmFsdWVzKFtcInBsYXRmb3JtVmVyc2lvblwiXSk7cmV0dXJuIG4/KHBhcnNlSW50KG4uc3BsaXQoXCIuXCIpWzBdKT49MTMmJih0PXQucmVwbGFjZShcIldpbmRvd3MgTlQgMTAuMFwiLFwiV2luZG93cyBOVCAxMS4wXCIpKSx0KTp0fSkoKSxzPXtjb21tZW50OmVlLnZhbHVlLG5pY2s6QS52YWx1ZS5uaWNrLG1haWw6QS52YWx1ZS5tYWlsLGxpbms6QS52YWx1ZS5saW5rLHVybDpiLnZhbHVlLnBhdGgsdWE6b307aWYoUy52YWx1ZT8udG9rZW4pcy5uaWNrPVMudmFsdWUuZGlzcGxheV9uYW1lLHMubWFpbD1TLnZhbHVlLmVtYWlsLHMubGluaz1TLnZhbHVlLnVybDtlbHNle2lmKFwiZm9yY2VcIj09PW4pcmV0dXJuO2lmKGwuaW5kZXhPZihcIm5pY2tcIik+LTEmJiFzLm5pY2spcmV0dXJuIFUudmFsdWUubmljaz8uZm9jdXMoKSxhbGVydChhZS52YWx1ZS5uaWNrRXJyb3IpO2lmKGwuaW5kZXhPZihcIm1haWxcIik+LTEmJiFzLm1haWx8fHMubWFpbCYmKGM9cy5tYWlsLCFrZS50ZXN0KGMpKSlyZXR1cm4gVS52YWx1ZS5tYWlsPy5mb2N1cygpLGFsZXJ0KGFlLnZhbHVlLm1haWxFcnJvcik7cy5uaWNrfHwocy5uaWNrPWFlLnZhbHVlLmFub255bW91cyl9dmFyIGM7aWYocy5jb21tZW50KXtpZighUS52YWx1ZSlyZXR1cm4gYWxlcnQoYWUudmFsdWUud29yZEhpbnQucmVwbGFjZShcIiQwXCIsYVswXS50b1N0cmluZygpKS5yZXBsYWNlKFwiJDFcIixhWzFdLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCIkMlwiLEoudmFsdWUudG9TdHJpbmcoKSkpO3MuY29tbWVudD1TZShzLmNvbW1lbnQsVy52YWx1ZS5tYXApLHcucmVwbHlJZCYmdy5yb290SWQmJihzLnBpZD13LnJlcGx5SWQscy5yaWQ9dy5yb290SWQscy5hdD13LnJlcGx5VXNlciksdGUudmFsdWU9ITA7dHJ5e3ImJihzLnJlY2FwdGNoYVYzPWF3YWl0KGU9Pntjb25zdCB0PW90W2VdPz8ob3RbZV09WGUubG9hZChlLHt1c2VSZWNhcHRjaGFOZXQ6ITAsYXV0b0hpZGVCYWRnZTohMH0pKTtyZXR1cm57ZXhlY3V0ZTplPT50LnRoZW4oKHQ9PnQuZXhlY3V0ZShlKSkpfX0pKHIpLmV4ZWN1dGUoXCJzb2NpYWxcIikpLGkmJihzLnR1cm5zdGlsZT1hd2FpdCh1PWkse2V4ZWN1dGU6YXN5bmMgZT0+e2NvbnN0e2xvYWQ6dH09eihcImh0dHBzOi8vY2hhbGxlbmdlcy5jbG91ZGZsYXJlLmNvbS90dXJuc3RpbGUvdjAvYXBpLmpzXCIsdm9pZCAwLHthc3luYzohMX0pO2F3YWl0IHQoKTtjb25zdCBuPXdpbmRvdz8udHVybnN0aWxlO3JldHVybiBuZXcgUHJvbWlzZSgodD0+e24/LnJlYWR5KCgoKT0+e24/LnJlbmRlcihcIi53bC1jYXB0Y2hhLWNvbnRhaW5lclwiLHtzaXRla2V5OnUsYWN0aW9uOmUsc2l6ZTpcImNvbXBhY3RcIixjYWxsYmFjazp0fSl9KSl9KSl9fSkuZXhlY3V0ZShcInNvY2lhbFwiKSk7Y29uc3Qgbj17c2VydmVyVVJMOmUsbGFuZzp0LHRva2VuOlMudmFsdWU/LnRva2VuLGNvbW1lbnQ6c30sYT1hd2FpdCh3LmVkaXQ/ZGUoe29iamVjdElkOncuZWRpdC5vYmplY3RJZCwuLi5ufSk6KCh7c2VydmVyVVJMOmUsbGFuZzp0LHRva2VuOm4sY29tbWVudDphfSk9Pntjb25zdCBsPXtcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24vanNvblwifTtyZXR1cm4gbiYmKGwuQXV0aG9yaXphdGlvbj1gQmVhcmVyICR7bn1gKSxmZXRjaChgJHtlfS9jb21tZW50P2xhbmc9JHt0fWAse21ldGhvZDpcIlBPU1RcIixoZWFkZXJzOmwsYm9keTpKU09OLnN0cmluZ2lmeShhKX0pLnRoZW4oKGU9PmUuanNvbigpKSl9KShuKSk7aWYodGUudmFsdWU9ITEsYS5lcnJtc2cpcmV0dXJuIGFsZXJ0KGEuZXJybXNnKTt5KFwic3VibWl0XCIsYS5kYXRhKSxqLnZhbHVlPVwiXCIsWi52YWx1ZT1cIlwiLHcucmVwbHlJZCYmeShcImNhbmNlbFJlcGx5XCIpLHcuZWRpdD8ub2JqZWN0SWQmJnkoXCJjYW5jZWxFZGl0XCIpfWNhdGNoKGUpe3RlLnZhbHVlPSExLGFsZXJ0KGUubWVzc2FnZSl9dmFyIHV9ZWxzZSBILnZhbHVlPy5mb2N1cygpfSxnZT1lPT57ZS5wcmV2ZW50RGVmYXVsdCgpO2NvbnN0e2xhbmc6dCxzZXJ2ZXJVUkw6bn09Yi52YWx1ZTsoKHtsYW5nOmUsc2VydmVyVVJMOnR9KT0+e2NvbnN0IG49KHdpbmRvdy5pbm5lcldpZHRoLTQ1MCkvMixhPSh3aW5kb3cuaW5uZXJIZWlnaHQtNDUwKS8yLGw9d2luZG93Lm9wZW4oYCR7dH0vdWkvbG9naW4/bG5nPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGUpfWAsXCJfYmxhbmtcIixgd2lkdGg9NDUwLGhlaWdodD00NTAsbGVmdD0ke259LHRvcD0ke2F9LHNjcm9sbGJhcnM9bm8scmVzaXphYmxlPW5vLHN0YXR1cz1ubyxsb2NhdGlvbj1ubyx0b29sYmFyPW5vLG1lbnViYXI9bm9gKTtyZXR1cm4gbD8ucG9zdE1lc3NhZ2Uoe3R5cGU6XCJUT0tFTlwiLGRhdGE6bnVsbH0sXCIqXCIpLG5ldyBQcm9taXNlKChlPT57Y29uc3QgdD0oe2RhdGE6bn0pPT57biYmXCJvYmplY3RcIj09dHlwZW9mIG4mJlwidXNlckluZm9cIj09PW4udHlwZSYmbi5kYXRhLnRva2VuJiYobD8uY2xvc2UoKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0KSxlKG4uZGF0YSkpfTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0KX0pKX0pKHtzZXJ2ZXJVUkw6bixsYW5nOnR9KS50aGVuKChlPT57Uy52YWx1ZT1lLChlLnJlbWVtYmVyP2xvY2FsU3RvcmFnZTpzZXNzaW9uU3RvcmFnZSkuc2V0SXRlbShcIldBTElORV9VU0VSXCIsSlNPTi5zdHJpbmdpZnkoZSkpLHkoXCJsb2dcIil9KSl9LGhlPSgpPT57Uy52YWx1ZT17fSxsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIldBTElORV9VU0VSXCIsXCJudWxsXCIpLHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJXQUxJTkVfVVNFUlwiLFwibnVsbFwiKSx5KFwibG9nXCIpfSxmZT1lPT57ZS5wcmV2ZW50RGVmYXVsdCgpO2NvbnN0e2xhbmc6dCxzZXJ2ZXJVUkw6bn09Yi52YWx1ZSxhPSh3aW5kb3cuaW5uZXJXaWR0aC04MDApLzIsbD0od2luZG93LmlubmVySGVpZ2h0LTgwMCkvMixyPW5ldyBVUkxTZWFyY2hQYXJhbXMoe2xuZzp0LHRva2VuOlMudmFsdWUudG9rZW59KSxpPXdpbmRvdy5vcGVuKGAke259L3VpL3Byb2ZpbGU/JHtyLnRvU3RyaW5nKCl9YCxcIl9ibGFua1wiLGB3aWR0aD04MDAsaGVpZ2h0PTgwMCxsZWZ0PSR7YX0sdG9wPSR7bH0sc2Nyb2xsYmFycz1ubyxyZXNpemFibGU9bm8sc3RhdHVzPW5vLGxvY2F0aW9uPW5vLHRvb2xiYXI9bm8sbWVudWJhcj1ub2ApO2k/LnBvc3RNZXNzYWdlKHt0eXBlOlwiVE9LRU5cIixkYXRhOlMudmFsdWUudG9rZW59LFwiKlwiKX0seWU9ZT0+e1AudmFsdWU/LmNvbnRhaW5zKGUudGFyZ2V0KXx8Vi52YWx1ZT8uY29udGFpbnMoZS50YXJnZXQpfHwoSy52YWx1ZT0hMSksRC52YWx1ZT8uY29udGFpbnMoZS50YXJnZXQpfHxOLnZhbHVlPy5jb250YWlucyhlLnRhcmdldCl8fChxLnZhbHVlPSExKX0sd2U9YXN5bmMgZT0+e2NvbnN0e3Njcm9sbFRvcDp0LGNsaWVudEhlaWdodDpuLHNjcm9sbEhlaWdodDphfT1lLnRhcmdldCxsPShuK3QpL2Escj1iLnZhbHVlLnNlYXJjaCxpPUIudmFsdWU/LnZhbHVlfHxcIlwiO2lmKGw8Ljl8fFkubG9hZGluZ3x8bmUudmFsdWUpcmV0dXJuO1kubG9hZGluZz0hMDsoci5tb3JlJiZZLmxpc3QubGVuZ3RoP2F3YWl0IHIubW9yZShpLFkubGlzdC5sZW5ndGgpOmF3YWl0IHIuc2VhcmNoKGkpKS5sZW5ndGg/WS5saXN0PVsuLi5ZLmxpc3QsLi4uci5tb3JlJiZZLmxpc3QubGVuZ3RoP2F3YWl0IHIubW9yZShpLFkubGlzdC5sZW5ndGgpOmF3YWl0IHIuc2VhcmNoKGkpXTpuZS52YWx1ZT0hMCxZLmxvYWRpbmc9ITEsc2V0VGltZW91dCgoKCk9PntlLnRhcmdldC5zY3JvbGxUb3A9dH0pLDUwKX0sYmU9TSgoZT0+e1kubGlzdD1bXSxuZS52YWx1ZT0hMSx3ZShlKX0pLDMwMCk7aShbYixKXSwoKFtlLHRdKT0+e2NvbnN0e3dvcmRMaW1pdDpufT1lO24/dDxuWzBdJiYwIT09blswXT8oWC52YWx1ZT1uWzBdLFEudmFsdWU9ITEpOnQ+blsxXT8oWC52YWx1ZT1uWzFdLFEudmFsdWU9ITEpOihYLnZhbHVlPW5bMV0sUS52YWx1ZT0hMCk6KFgudmFsdWU9MCxRLnZhbHVlPSEwKX0pLHtpbW1lZGlhdGU6ITB9KTtjb25zdCBMZT0oe2RhdGE6ZX0pPT57ZSYmXCJwcm9maWxlXCI9PT1lLnR5cGUmJihTLnZhbHVlPXsuLi5TLnZhbHVlLC4uLmUuZGF0YX0sW2xvY2FsU3RvcmFnZSxzZXNzaW9uU3RvcmFnZV0uZmlsdGVyKChlPT5lLmdldEl0ZW0oXCJXQUxJTkVfVVNFUlwiKSkpLmZvckVhY2goKGU9PmUuc2V0SXRlbShcIldBTElORV9VU0VSXCIsSlNPTi5zdHJpbmdpZnkoUykpKSkpfTtyZXR1cm4gcigoKCk9Pntkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHllKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixMZSksdy5lZGl0Py5vYmplY3RJZCYmKGoudmFsdWU9dy5lZGl0Lm9yaWcpLGkocSwoYXN5bmMgZT0+e2lmKCFlKXJldHVybjtjb25zdCB0PWIudmFsdWUuc2VhcmNoO0IudmFsdWUmJihCLnZhbHVlLnZhbHVlPVwiXCIpLFkubG9hZGluZz0hMCxZLmxpc3Q9dC5kZWZhdWx0P2F3YWl0IHQuZGVmYXVsdCgpOmF3YWl0IHQuc2VhcmNoKFwiXCIpLFkubG9hZGluZz0hMX0pKSxpKCgoKT0+ai52YWx1ZSksKGU9Pntjb25zdHtoaWdobGlnaHRlcjp0LHRleFJlbmRlcmVyOm59PWIudmFsdWU7ZWUudmFsdWU9ZSxaLnZhbHVlPVVlKGUse2Vtb2ppTWFwOlcudmFsdWUubWFwLGhpZ2hsaWdodGVyOnQsdGV4UmVuZGVyZXI6bn0pLEoudmFsdWU9KGU9PigoZT0+ZS5tYXRjaCgvW1xcd1xcZFxccywuXFx1MDBDMC1cXHUwMjRGXFx1MDQwMC1cXHUwNEZGXSsvZ2l1KSkoZSk/LnJlZHVjZSgoKGUsdCk9PmUrKFwiXCI9PT10LnRyaW0oKT8wOnQudHJpbSgpLnNwbGl0KC9cXHMrL3UpLmxlbmd0aCkpLDApfHwwKSsoKGU9PmUubWF0Y2goL1tcXHU0RTAwLVxcdTlGRDVdL2d1KSkoZSk/Lmxlbmd0aHx8MCkpKGUpLGU/TyhILnZhbHVlKTpPLmRlc3Ryb3koSC52YWx1ZSl9KSx7aW1tZWRpYXRlOiEwfSksaSgoKCk9PmIudmFsdWUuZW1vamkpLChlPT57cmV0dXJuKHQ9ZSxQcm9taXNlLmFsbCh0Lm1hcCgoZT0+XCJzdHJpbmdcIj09dHlwZW9mIGU/Q2UobWUoZSkpOlByb21pc2UucmVzb2x2ZShlKSkpKS50aGVuKChlPT57Y29uc3QgdD17dGFiczpbXSxtYXA6e319O3JldHVybiBlLmZvckVhY2goKGU9Pntjb25zdHtuYW1lOm4sZm9sZGVyOmEsaWNvbjpsLHByZWZpeDpyLHR5cGU6aSxpdGVtczpvfT1lO3QudGFicy5wdXNoKHtuYW1lOm4saWNvbjokZShsLGEscixpKSxpdGVtczpvLm1hcCgoZT0+e2NvbnN0IG49YCR7cnx8XCJcIn0ke2V9YDtyZXR1cm4gdC5tYXBbbl09JGUoZSxhLHIsaSksbn0pKX0pfSkpLHR9KSkpLnRoZW4oKGU9PntXLnZhbHVlPWV9KSk7dmFyIHR9KSx7aW1tZWRpYXRlOiEwfSl9KSksbygoKCk9Pntkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHllKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixMZSl9KSksKGUsdCk9PihzKCksYyhcImRpdlwiLEx0LFtcImRpc2FibGVcIiE9PWgoYikubG9naW4mJmxlLnZhbHVlJiYhZS5lZGl0Py5vYmplY3RJZD8ocygpLGMoXCJkaXZcIixSdCxbdShcImRpdlwiLHh0LFt1KFwiYnV0dG9uXCIse3R5cGU6XCJzdWJtaXRcIixjbGFzczpcIndsLWxvZ291dC1idG5cIix0aXRsZTphZS52YWx1ZS5sb2dvdXQsb25DbGljazpoZX0sW0MoaChNZSkse3NpemU6MTR9KV0sOCxFdCksdShcImFcIix7aHJlZjpcIiNcIixjbGFzczpcIndsLWxvZ2luLW5pY2tcIixcImFyaWEtbGFiZWxcIjpcIlByb2ZpbGVcIix0aXRsZTphZS52YWx1ZS5wcm9maWxlLG9uQ2xpY2s6ZmV9LFt1KFwiaW1nXCIse3NyYzpoKFMpLmF2YXRhcixhbHQ6XCJhdmF0YXJcIn0sbnVsbCw4LGp0KV0sOCxJdCldKSx1KFwiYVwiLHtocmVmOlwiI1wiLGNsYXNzOlwid2wtbG9naW4tbmlja1wiLFwiYXJpYS1sYWJlbFwiOlwiUHJvZmlsZVwiLHRpdGxlOmFlLnZhbHVlLnByb2ZpbGUsb25DbGljazpmZSx0ZXh0Q29udGVudDpkKGgoUykuZGlzcGxheV9uYW1lKX0sbnVsbCw4LEF0KV0pKTpmKFwidi1pZlwiLCEwKSx1KFwiZGl2XCIsU3QsW1wiZm9yY2VcIiE9PWgoYikubG9naW4mJmgoYikubWV0YS5sZW5ndGgmJiFsZS52YWx1ZT8ocygpLGMoXCJkaXZcIix7a2V5OjAsY2xhc3M6cChbXCJ3bC1oZWFkZXJcIixgaXRlbSR7aChiKS5tZXRhLmxlbmd0aH1gXSl9LFsocyghMCksYyh2LG51bGwsbShoKGIpLm1ldGEsKGU9PihzKCksYyhcImRpdlwiLHtrZXk6ZSxjbGFzczpcIndsLWhlYWRlci1pdGVtXCJ9LFt1KFwibGFiZWxcIix7Zm9yOmB3bC0ke2V9YCx0ZXh0Q29udGVudDpkKGFlLnZhbHVlW2VdKyhoKGIpLnJlcXVpcmVkTWV0YS5pbmNsdWRlcyhlKXx8IWgoYikucmVxdWlyZWRNZXRhLmxlbmd0aD9cIlwiOmAoJHthZS52YWx1ZS5vcHRpb25hbH0pYCkpfSxudWxsLDgsVXQpLCQodShcImlucHV0XCIse2lkOmB3bC0ke2V9YCxyZWZfZm9yOiEwLHJlZjp0PT57dCYmKFUudmFsdWVbZV09dCl9LFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOnQ9PmgoQSlbZV09dCxjbGFzczpwKFtcIndsLWlucHV0XCIsYHdsLSR7ZX1gXSksbmFtZTplLHR5cGU6XCJtYWlsXCI9PT1lP1wiZW1haWxcIjpcInRleHRcIn0sbnVsbCwxMCxfdCksW1tMLGgoQSlbZV1dXSldKSkpKSwxMjgpKV0sMikpOmYoXCJ2LWlmXCIsITApLCQodShcInRleHRhcmVhXCIse2lkOlwid2wtZWRpdFwiLHJlZl9rZXk6XCJlZGl0b3JSZWZcIixyZWY6SCxcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjp0WzBdfHwodFswXT1lPT5SKGopP2oudmFsdWU9ZTpudWxsKSxjbGFzczpcIndsLWVkaXRvclwiLHBsYWNlaG9sZGVyOmUucmVwbHlVc2VyP2BAJHtlLnJlcGx5VXNlcn1gOmFlLnZhbHVlLnBsYWNlaG9sZGVyLG9uS2V5ZG93bjpvZSxvbkRyb3A6Y2Usb25QYXN0ZTp1ZX0sbnVsbCw0MCx6dCksW1t4LGgoaildXSksJCh1KFwiZGl2XCIsTXQsW0h0LHUoXCJoNFwiLG51bGwsZChhZS52YWx1ZS5wcmV2aWV3KStcIjpcIiwxKSx1KFwiZGl2XCIse2NsYXNzOlwid2wtY29udGVudFwiLGlubmVySFRNTDpaLnZhbHVlfSxudWxsLDgsVHQpXSw1MTIpLFtbRSxHLnZhbHVlXV0pLHUoXCJkaXZcIixPdCxbdShcImRpdlwiLFB0LFt1KFwiYVwiLFZ0LFtDKGgoRGUpKV0pLCQodShcImJ1dHRvblwiLHtyZWZfa2V5OlwiZW1vamlCdXR0b25SZWZcIixyZWY6UCx0eXBlOlwiYnV0dG9uXCIsY2xhc3M6cChbXCJ3bC1hY3Rpb25cIix7YWN0aXZlOksudmFsdWV9XSksdGl0bGU6YWUudmFsdWUuZW1vamksb25DbGljazp0WzFdfHwodFsxXT1lPT5LLnZhbHVlPSFLLnZhbHVlKX0sW0MoaChUZSkpXSwxMCxEdCksW1tFLFcudmFsdWUudGFicy5sZW5ndGhdXSksaChiKS5zZWFyY2g/KHMoKSxjKFwiYnV0dG9uXCIse2tleTowLHJlZl9rZXk6XCJnaWZCdXR0b25SZWZcIixyZWY6RCx0eXBlOlwiYnV0dG9uXCIsY2xhc3M6cChbXCJ3bC1hY3Rpb25cIix7YWN0aXZlOnEudmFsdWV9XSksdGl0bGU6YWUudmFsdWUuZ2lmLG9uQ2xpY2s6dFsyXXx8KHRbMl09ZT0+cS52YWx1ZT0hcS52YWx1ZSl9LFtDKGgoS2UpKV0sMTAsTnQpKTpmKFwidi1pZlwiLCEwKSx1KFwiaW5wdXRcIix7aWQ6XCJ3bC1pbWFnZS11cGxvYWRcIixyZWZfa2V5OlwiaW1hZ2VVcGxvYWRSZWZcIixyZWY6VCxjbGFzczpcInVwbG9hZFwiLHR5cGU6XCJmaWxlXCIsYWNjZXB0OlwiLnBuZywuanBnLC5qcGVnLC53ZWJwLC5ibXAsLmdpZlwiLG9uQ2hhbmdlOnZlfSxudWxsLDU0NCkscmUudmFsdWU/KHMoKSxjKFwibGFiZWxcIix7a2V5OjEsZm9yOlwid2wtaW1hZ2UtdXBsb2FkXCIsY2xhc3M6XCJ3bC1hY3Rpb25cIix0aXRsZTphZS52YWx1ZS51cGxvYWRJbWFnZX0sW0MoaChPZSkpXSw4LEJ0KSk6ZihcInYtaWZcIiwhMCksdShcImJ1dHRvblwiLHt0eXBlOlwiYnV0dG9uXCIsY2xhc3M6cChbXCJ3bC1hY3Rpb25cIix7YWN0aXZlOkcudmFsdWV9XSksdGl0bGU6YWUudmFsdWUucHJldmlldyxvbkNsaWNrOnRbM118fCh0WzNdPWU9PkcudmFsdWU9IUcudmFsdWUpfSxbQyhoKFZlKSldLDEwLFd0KV0pLHUoXCJkaXZcIixGdCxbS3QsdShcImRpdlwiLHF0LFtJKGQoSi52YWx1ZSkrXCIgXCIsMSksaChiKS53b3JkTGltaXQ/KHMoKSxjKFwic3BhblwiLEd0LFtJKFwiIMKgL8KgIFwiKSx1KFwic3BhblwiLHtjbGFzczpwKHtpbGxlZ2FsOiFRLnZhbHVlfSksdGV4dENvbnRlbnQ6ZChYLnZhbHVlKX0sbnVsbCwxMCxadCldKSk6ZihcInYtaWZcIiwhMCksSShcIiDCoFwiK2QoYWUudmFsdWUud29yZCksMSldKSxcImRpc2FibGVcIj09PWgoYikubG9naW58fGxlLnZhbHVlP2YoXCJ2LWlmXCIsITApOihzKCksYyhcImJ1dHRvblwiLHtrZXk6MCx0eXBlOlwiYnV0dG9uXCIsY2xhc3M6XCJ3bC1idG5cIixvbkNsaWNrOmdlLHRleHRDb250ZW50OmQoYWUudmFsdWUubG9naW4pfSxudWxsLDgsSnQpKSxcImZvcmNlXCIhPT1oKGIpLmxvZ2lufHxsZS52YWx1ZT8ocygpLGMoXCJidXR0b25cIix7a2V5OjEsdHlwZTpcInN1Ym1pdFwiLGNsYXNzOlwicHJpbWFyeSB3bC1idG5cIix0aXRsZTpcIkNtZHxDdHJsICsgRW50ZXJcIixkaXNhYmxlZDp0ZS52YWx1ZSxvbkNsaWNrOnBlfSxbdGUudmFsdWU/KHMoKSxnKGgoRmUpLHtrZXk6MCxzaXplOjE2fSkpOihzKCksYyh2LHtrZXk6MX0sW0koZChhZS52YWx1ZS5zdWJtaXQpLDEpXSw2NCkpXSw4LFl0KSk6ZihcInYtaWZcIiwhMCldKSx1KFwiZGl2XCIse3JlZl9rZXk6XCJnaWZQb3B1cFJlZlwiLHJlZjpOLGNsYXNzOnAoW1wid2wtZ2lmLXBvcHVwXCIse2Rpc3BsYXk6cS52YWx1ZX1dKX0sW3UoXCJpbnB1dFwiLHtyZWZfa2V5OlwiZ2lmU2VhcmNoSW5wdXRSZWZcIixyZWY6Qix0eXBlOlwidGV4dFwiLHBsYWNlaG9sZGVyOmFlLnZhbHVlLmdpZlNlYXJjaFBsYWNlaG9sZGVyLG9uSW5wdXQ6dFs0XXx8KHRbNF09KC4uLmUpPT5oKGJlKSYmaChiZSkoLi4uZSkpfSxudWxsLDQwLFh0KSxZLmxpc3QubGVuZ3RoPyhzKCksZygkdCx7a2V5OjAsaXRlbXM6WS5saXN0LFwiY29sdW1uLXdpZHRoXCI6MjAwLGdhcDo2LG9uSW5zZXJ0OnRbNV18fCh0WzVdPWU9PmllKGUpKSxvblNjcm9sbDp3ZX0sbnVsbCw4LFtcIml0ZW1zXCJdKSk6ZihcInYtaWZcIiwhMCksWS5sb2FkaW5nPyhzKCksYyhcImRpdlwiLFF0LFtDKGgoRmUpLHtzaXplOjMwfSldKSk6ZihcInYtaWZcIiwhMCldLDIpLHUoXCJkaXZcIix7cmVmX2tleTpcImVtb2ppUG9wdXBSZWZcIixyZWY6VixjbGFzczpwKFtcIndsLWVtb2ppLXBvcHVwXCIse2Rpc3BsYXk6Sy52YWx1ZX1dKX0sWyhzKCEwKSxjKHYsbnVsbCxtKFcudmFsdWUudGFicywoKGUsdCk9PihzKCksYyh2LHtrZXk6ZS5uYW1lfSxbdD09PUYudmFsdWU/KHMoKSxjKFwiZGl2XCIsZW4sWyhzKCEwKSxjKHYsbnVsbCxtKGUuaXRlbXMsKGU9PihzKCksYyhcImJ1dHRvblwiLHtrZXk6ZSx0eXBlOlwiYnV0dG9uXCIsdGl0bGU6ZSxvbkNsaWNrOnQ9PmllKGA6JHtlfTpgKX0sW0sudmFsdWU/KHMoKSxjKFwiaW1nXCIse2tleTowLGNsYXNzOlwid2wtZW1vamlcIixzcmM6Vy52YWx1ZS5tYXBbZV0sYWx0OmUsbG9hZGluZzpcImxhenlcIixyZWZlcnJlclBvbGljeTpcIm5vLXJlZmVycmVyXCJ9LG51bGwsOCxubikpOmYoXCJ2LWlmXCIsITApXSw4LHRuKSkpKSwxMjgpKV0pKTpmKFwidi1pZlwiLCEwKV0sNjQpKSkpLDEyOCkpLFcudmFsdWUudGFicy5sZW5ndGg+MT8ocygpLGMoXCJkaXZcIixhbixbKHMoITApLGModixudWxsLG0oVy52YWx1ZS50YWJzLCgoZSx0KT0+KHMoKSxjKFwiYnV0dG9uXCIse2tleTplLm5hbWUsdHlwZTpcImJ1dHRvblwiLGNsYXNzOnAoW1wid2wtdGFiXCIse2FjdGl2ZTpGLnZhbHVlPT09dH1dKSxvbkNsaWNrOmU9PkYudmFsdWU9dH0sW3UoXCJpbWdcIix7Y2xhc3M6XCJ3bC1lbW9qaVwiLHNyYzplLmljb24sYWx0OmUubmFtZSx0aXRsZTplLm5hbWUsbG9hZGluZzpcImxhenlcIixyZWZlcnJlclBvbGljeTpcIm5vLXJlZmVycmVyXCJ9LG51bGwsOCxybildLDEwLGxuKSkpKSwxMjgpKV0pKTpmKFwidi1pZlwiLCEwKV0sMildKV0pLGUucmVwbHlJZHx8ZS5lZGl0Py5vYmplY3RJZD8ocygpLGMoXCJidXR0b25cIix7a2V5OjEsdHlwZTpcImJ1dHRvblwiLGNsYXNzOlwid2wtY2xvc2VcIix0aXRsZTphZS52YWx1ZS5jYW5jZWxSZXBseSxvbkNsaWNrOnRbNl18fCh0WzZdPXQ9PmUuJGVtaXQoZS5yZXBseUlkP1wiY2FuY2VsUmVwbHlcIjpcImNhbmNlbEVkaXRcIikpfSxbQyhoKE1lKSx7c2l6ZToyNH0pXSw4LG9uKSk6ZihcInYtaWZcIiwhMCldKSl9fSksY249d3Qoc24sW1tcIl9fZmlsZVwiLFwiQ29tbWVudEJveC52dWVcIl1dKTtjb25zdCB1bj1bXCJpZFwiXSxkbj17Y2xhc3M6XCJ3bC11c2VyXCIsXCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSx2bj1bXCJzcmNcIl0sbW49e2NsYXNzOlwid2wtY2FyZFwifSxwbj17Y2xhc3M6XCJ3bC1oZWFkXCJ9LGduPVtcImhyZWZcIl0saG49e2tleToxLGNsYXNzOlwid2wtbmlja1wifSxmbj1bXCJ0ZXh0Q29udGVudFwiXSx5bj1bXCJ0ZXh0Q29udGVudFwiXSx3bj1bXCJ0ZXh0Q29udGVudFwiXSxibj1bXCJ0ZXh0Q29udGVudFwiXSxrbj1bXCJ0ZXh0Q29udGVudFwiXSxDbj17Y2xhc3M6XCJ3bC1jb21tZW50LWFjdGlvbnNcIn0sJG49W1widGl0bGVcIl0sTG49W1widGV4dENvbnRlbnRcIl0sUm49W1widGl0bGVcIl0seG49e2NsYXNzOlwid2wtbWV0YVwiLFwiYXJpYS1oaWRkZW5cIjpcInRydWVcIn0sRW49W1wiZGF0YS12YWx1ZVwiLFwidGV4dENvbnRlbnRcIl0sSW49W1wiZGF0YS12YWx1ZVwiLFwidGV4dENvbnRlbnRcIl0sam49W1wiZGF0YS12YWx1ZVwiLFwidGV4dENvbnRlbnRcIl0sQW49W1wiaW5uZXJIVE1MXCJdLFNuPXtrZXk6MSxjbGFzczpcIndsLWFkbWluLWFjdGlvbnNcIn0sVW49e2NsYXNzOlwid2wtY29tbWVudC1zdGF0dXNcIn0sX249W1wiZGlzYWJsZWRcIixcIm9uQ2xpY2tcIixcInRleHRDb250ZW50XCJdLHpuPXtrZXk6MyxjbGFzczpcIndsLXF1b3RlXCJ9O3ZhciBNbj13dCh0KHtfX25hbWU6XCJDb21tZW50Q2FyZFwiLHByb3BzOntjb21tZW50Ont9LGVkaXQ6e2RlZmF1bHQ6bnVsbH0scm9vdElkOnt9LHJlcGx5OntkZWZhdWx0Om51bGx9fSxlbWl0czpbXCJsb2dcIixcInN1Ym1pdFwiLFwiZGVsZXRlXCIsXCJlZGl0XCIsXCJsaWtlXCIsXCJzdGF0dXNcIixcInN0aWNreVwiLFwicmVwbHlcIl0sc2V0dXAoZSl7Y29uc3QgdD1lLGE9W1wiYXBwcm92ZWRcIixcIndhaXRpbmdcIixcInNwYW1cIl0scj1uKFwiY29uZmlnXCIpLGk9R2UoKSxvPUgoKSx5PWN0KCksdz1sKCgoKT0+ci52YWx1ZS5sb2NhbGUpKSxiPWwoKCgpPT57Y29uc3R7bGluazplfT10LmNvbW1lbnQ7cmV0dXJuIGU/cGUoZSk/ZTpgaHR0cHM6Ly8ke2V9YDpcIlwifSkpLGs9bCgoKCk9PmkudmFsdWUuaW5jbHVkZXModC5jb21tZW50Lm9iamVjdElkKSkpLCQ9bCgoKCk9PmJlKHQuY29tbWVudC5pbnNlcnRlZEF0LG8udmFsdWUsdy52YWx1ZSkpKSxMPWwoKCgpPT5cImFkbWluaXN0cmF0b3JcIj09PXkudmFsdWUudHlwZSkpLFI9bCgoKCk9PnQuY29tbWVudC51c2VyX2lkJiZ5LnZhbHVlLm9iamVjdElkPT09dC5jb21tZW50LnVzZXJfaWQpKSx4PWwoKCgpPT50LmNvbW1lbnQub2JqZWN0SWQ9PT10LnJlcGx5Py5vYmplY3RJZCkpLEU9bCgoKCk9PnQuY29tbWVudC5vYmplY3RJZD09PXQuZWRpdD8ub2JqZWN0SWQpKTtyZXR1cm4oZSx0KT0+e2NvbnN0IG49aihcIkNvbW1lbnRDYXJkXCIsITApO3JldHVybiBzKCksYyhcImRpdlwiLHtpZDplLmNvbW1lbnQub2JqZWN0SWQsY2xhc3M6XCJ3bC1jYXJkLWl0ZW1cIn0sW3UoXCJkaXZcIixkbixbZS5jb21tZW50LmF2YXRhcj8ocygpLGMoXCJpbWdcIix7a2V5OjAsc3JjOmUuY29tbWVudC5hdmF0YXJ9LG51bGwsOCx2bikpOmYoXCJ2LWlmXCIsITApLGUuY29tbWVudC50eXBlPyhzKCksZyhoKFdlKSx7a2V5OjF9KSk6ZihcInYtaWZcIiwhMCldKSx1KFwiZGl2XCIsbW4sW3UoXCJkaXZcIixwbixbYi52YWx1ZT8ocygpLGMoXCJhXCIse2tleTowLGNsYXNzOlwid2wtbmlja1wiLGhyZWY6Yi52YWx1ZSx0YXJnZXQ6XCJfYmxhbmtcIixyZWw6XCJub2ZvbGxvdyBub29wZW5lciBub3JlZmVycmVyXCJ9LGQoZS5jb21tZW50Lm5pY2spLDksZ24pKToocygpLGMoXCJzcGFuXCIsaG4sZChlLmNvbW1lbnQubmljayksMSkpLFwiYWRtaW5pc3RyYXRvclwiPT09ZS5jb21tZW50LnR5cGU/KHMoKSxjKFwic3BhblwiLHtrZXk6MixjbGFzczpcIndsLWJhZGdlXCIsdGV4dENvbnRlbnQ6ZCh3LnZhbHVlLmFkbWluKX0sbnVsbCw4LGZuKSk6ZihcInYtaWZcIiwhMCksZS5jb21tZW50LmxhYmVsPyhzKCksYyhcInNwYW5cIix7a2V5OjMsY2xhc3M6XCJ3bC1iYWRnZVwiLHRleHRDb250ZW50OmQoZS5jb21tZW50LmxhYmVsKX0sbnVsbCw4LHluKSk6ZihcInYtaWZcIiwhMCksZS5jb21tZW50LnN0aWNreT8ocygpLGMoXCJzcGFuXCIse2tleTo0LGNsYXNzOlwid2wtYmFkZ2VcIix0ZXh0Q29udGVudDpkKHcudmFsdWUuc3RpY2t5KX0sbnVsbCw4LHduKSk6ZihcInYtaWZcIiwhMCksdm9pZCAwIT09ZS5jb21tZW50LmxldmVsJiZlLmNvbW1lbnQubGV2ZWw+PTA/KHMoKSxjKFwic3BhblwiLHtrZXk6NSxjbGFzczpwKGB3bC1iYWRnZSBsZXZlbCR7ZS5jb21tZW50LmxldmVsfWApLHRleHRDb250ZW50OmQody52YWx1ZVtgbGV2ZWwke2UuY29tbWVudC5sZXZlbH1gXXx8YExldmVsICR7ZS5jb21tZW50LmxldmVsfWApfSxudWxsLDEwLGJuKSk6ZihcInYtaWZcIiwhMCksdShcInNwYW5cIix7Y2xhc3M6XCJ3bC10aW1lXCIsdGV4dENvbnRlbnQ6ZCgkLnZhbHVlKX0sbnVsbCw4LGtuKSx1KFwiZGl2XCIsQ24sW0wudmFsdWV8fFIudmFsdWU/KHMoKSxjKFwiYnV0dG9uXCIse2tleTowLHR5cGU6XCJidXR0b25cIixjbGFzczpcIndsLWVkaXRcIixvbkNsaWNrOnRbMF18fCh0WzBdPSgpPT5lLiRlbWl0KFwiZWRpdFwiLGUuY29tbWVudCkpfSxbQyhoKEJlKSldKSk6ZihcInYtaWZcIiwhMCksTC52YWx1ZXx8Ui52YWx1ZT8ocygpLGMoXCJidXR0b25cIix7a2V5OjEsdHlwZTpcImJ1dHRvblwiLGNsYXNzOlwid2wtZGVsZXRlXCIsb25DbGljazp0WzFdfHwodFsxXT10PT5lLiRlbWl0KFwiZGVsZXRlXCIsZS5jb21tZW50KSl9LFtDKGgoSGUpKV0pKTpmKFwidi1pZlwiLCEwKSx1KFwiYnV0dG9uXCIse3R5cGU6XCJidXR0b25cIixjbGFzczpcIndsLWxpa2VcIix0aXRsZTprLnZhbHVlP3cudmFsdWUuY2FuY2VsTGlrZTp3LnZhbHVlLmxpa2Usb25DbGljazp0WzJdfHwodFsyXT10PT5lLiRlbWl0KFwibGlrZVwiLGUuY29tbWVudCkpfSxbQyhoKFBlKSx7YWN0aXZlOmsudmFsdWV9LG51bGwsOCxbXCJhY3RpdmVcIl0pLFwibGlrZVwiaW4gZS5jb21tZW50PyhzKCksYyhcInNwYW5cIix7a2V5OjAsdGV4dENvbnRlbnQ6ZChlLmNvbW1lbnQubGlrZSl9LG51bGwsOCxMbikpOmYoXCJ2LWlmXCIsITApXSw4LCRuKSx1KFwiYnV0dG9uXCIse3R5cGU6XCJidXR0b25cIixjbGFzczpwKFtcIndsLXJlcGx5XCIse2FjdGl2ZTp4LnZhbHVlfV0pLHRpdGxlOngudmFsdWU/dy52YWx1ZS5jYW5jZWxSZXBseTp3LnZhbHVlLnJlcGx5LG9uQ2xpY2s6dFszXXx8KHRbM109dD0+ZS4kZW1pdChcInJlcGx5XCIseC52YWx1ZT9udWxsOmUuY29tbWVudCkpfSxbQyhoKE5lKSldLDEwLFJuKV0pXSksdShcImRpdlwiLHhuLFtlLmNvbW1lbnQuYWRkcj8ocygpLGMoXCJzcGFuXCIse2tleTowLGNsYXNzOlwid2wtYWRkclwiLFwiZGF0YS12YWx1ZVwiOmUuY29tbWVudC5hZGRyLHRleHRDb250ZW50OmQoZS5jb21tZW50LmFkZHIpfSxudWxsLDgsRW4pKTpmKFwidi1pZlwiLCEwKSxlLmNvbW1lbnQuYnJvd3Nlcj8ocygpLGMoXCJzcGFuXCIse2tleToxLGNsYXNzOlwid2wtYnJvd3NlclwiLFwiZGF0YS12YWx1ZVwiOmUuY29tbWVudC5icm93c2VyLHRleHRDb250ZW50OmQoZS5jb21tZW50LmJyb3dzZXIpfSxudWxsLDgsSW4pKTpmKFwidi1pZlwiLCEwKSxlLmNvbW1lbnQub3M/KHMoKSxjKFwic3BhblwiLHtrZXk6MixjbGFzczpcIndsLW9zXCIsXCJkYXRhLXZhbHVlXCI6ZS5jb21tZW50Lm9zLHRleHRDb250ZW50OmQoZS5jb21tZW50Lm9zKX0sbnVsbCw4LGpuKSk6ZihcInYtaWZcIiwhMCldKSxFLnZhbHVlP2YoXCJ2LWlmXCIsITApOihzKCksYyhcImRpdlwiLHtrZXk6MCxjbGFzczpcIndsLWNvbnRlbnRcIixpbm5lckhUTUw6ZS5jb21tZW50LmNvbW1lbnR9LG51bGwsOCxBbikpLEwudmFsdWUmJiFFLnZhbHVlPyhzKCksYyhcImRpdlwiLFNuLFt1KFwic3BhblwiLFVuLFsocygpLGModixudWxsLG0oYSwodD0+dShcImJ1dHRvblwiLHtrZXk6dCx0eXBlOlwic3VibWl0XCIsY2xhc3M6cChgd2wtYnRuIHdsLSR7dH1gKSxkaXNhYmxlZDplLmNvbW1lbnQuc3RhdHVzPT09dCxvbkNsaWNrOm49PmUuJGVtaXQoXCJzdGF0dXNcIix7c3RhdHVzOnQsY29tbWVudDplLmNvbW1lbnR9KSx0ZXh0Q29udGVudDpkKHcudmFsdWVbdF0pfSxudWxsLDEwLF9uKSkpLDY0KSldKSxMLnZhbHVlJiYhZS5jb21tZW50LnJpZD8ocygpLGMoXCJidXR0b25cIix7a2V5OjAsdHlwZTpcInN1Ym1pdFwiLGNsYXNzOlwid2wtYnRuIHdsLXN0aWNreVwiLG9uQ2xpY2s6dFs0XXx8KHRbNF09dD0+ZS4kZW1pdChcInN0aWNreVwiLGUuY29tbWVudCkpfSxkKGUuY29tbWVudC5zdGlja3k/dy52YWx1ZS51bnN0aWNreTp3LnZhbHVlLnN0aWNreSksMSkpOmYoXCJ2LWlmXCIsITApXSkpOmYoXCJ2LWlmXCIsITApLHgudmFsdWV8fEUudmFsdWU/KHMoKSxjKFwiZGl2XCIse2tleToyLGNsYXNzOnAoe1wid2wtcmVwbHktd3JhcHBlclwiOngudmFsdWUsXCJ3bC1lZGl0LXdyYXBwZXJcIjpFLnZhbHVlfSl9LFtDKGNuLHtlZGl0OmUuZWRpdCxcInJlcGx5LWlkXCI6ZS5yZXBseT8ub2JqZWN0SWQsXCJyZXBseS11c2VyXCI6ZS5jb21tZW50Lm5pY2ssXCJyb290LWlkXCI6ZS5yb290SWQsb25Mb2c6dFs1XXx8KHRbNV09dD0+ZS4kZW1pdChcImxvZ1wiKSksb25DYW5jZWxSZXBseTp0WzZdfHwodFs2XT10PT5lLiRlbWl0KFwicmVwbHlcIixudWxsKSksb25DYW5jZWxFZGl0OnRbN118fCh0WzddPXQ9PmUuJGVtaXQoXCJlZGl0XCIsbnVsbCkpLG9uU3VibWl0OnRbOF18fCh0WzhdPXQ9PmUuJGVtaXQoXCJzdWJtaXRcIix0KSl9LG51bGwsOCxbXCJlZGl0XCIsXCJyZXBseS1pZFwiLFwicmVwbHktdXNlclwiLFwicm9vdC1pZFwiXSldLDIpKTpmKFwidi1pZlwiLCEwKSxlLmNvbW1lbnQuY2hpbGRyZW4/KHMoKSxjKFwiZGl2XCIsem4sWyhzKCEwKSxjKHYsbnVsbCxtKGUuY29tbWVudC5jaGlsZHJlbiwoYT0+KHMoKSxnKG4se2tleTphLm9iamVjdElkLGNvbW1lbnQ6YSxyZXBseTplLnJlcGx5LGVkaXQ6ZS5lZGl0LFwicm9vdC1pZFwiOmUucm9vdElkLG9uTG9nOnRbOV18fCh0WzldPXQ9PmUuJGVtaXQoXCJsb2dcIikpLG9uRGVsZXRlOnRbMTBdfHwodFsxMF09dD0+ZS4kZW1pdChcImRlbGV0ZVwiLHQpKSxvbkVkaXQ6dFsxMV18fCh0WzExXT10PT5lLiRlbWl0KFwiZWRpdFwiLHQpKSxvbkxpa2U6dFsxMl18fCh0WzEyXT10PT5lLiRlbWl0KFwibGlrZVwiLHQpKSxvblJlcGx5OnRbMTNdfHwodFsxM109dD0+ZS4kZW1pdChcInJlcGx5XCIsdCkpLG9uU3RhdHVzOnRbMTRdfHwodFsxNF09dD0+ZS4kZW1pdChcInN0YXR1c1wiLHQpKSxvblN0aWNreTp0WzE1XXx8KHRbMTVdPXQ9PmUuJGVtaXQoXCJzdGlja3lcIix0KSksb25TdWJtaXQ6dFsxNl18fCh0WzE2XT10PT5lLiRlbWl0KFwic3VibWl0XCIsdCkpfSxudWxsLDgsW1wiY29tbWVudFwiLFwicmVwbHlcIixcImVkaXRcIixcInJvb3QtaWRcIl0pKSkpLDEyOCkpXSkpOmYoXCJ2LWlmXCIsITApXSldLDgsdW4pfX19KSxbW1wiX19maWxlXCIsXCJDb21tZW50Q2FyZC52dWVcIl1dKTtjb25zdCBIbj1cIjIuMTUuOFwiLFRuPXtcImRhdGEtd2FsaW5lXCI6XCJcIn0sT249e2NsYXNzOlwid2wtbWV0YS1oZWFkXCJ9LFBuPXtjbGFzczpcIndsLWNvdW50XCJ9LFZuPVtcInRleHRDb250ZW50XCJdLERuPXtjbGFzczpcIndsLXNvcnRcIn0sTm49W1wib25DbGlja1wiXSxCbj17Y2xhc3M6XCJ3bC1jYXJkc1wifSxXbj17a2V5OjEsY2xhc3M6XCJ3bC1vcGVyYXRpb25cIn0sRm49W1widGV4dENvbnRlbnRcIl0sS249e2tleTowLGNsYXNzOlwid2wtbG9hZGluZ1wifSxxbj1bXCJ0ZXh0Q29udGVudFwiXSxHbj17a2V5OjIsY2xhc3M6XCJ3bC1vcGVyYXRpb25cIn0sWm49W1widGV4dENvbnRlbnRcIl0sSm49e2tleTozLGNsYXNzOlwid2wtcG93ZXJcIn0sWW49dShcImFcIix7aHJlZjpcImh0dHBzOi8vZ2l0aHViLmNvbS93YWxpbmVqcy93YWxpbmVcIix0YXJnZXQ6XCJfYmxhbmtcIixyZWw6XCJub29wZW5lciBub3JlZmVycmVyXCJ9LFwiIFdhbGluZSBcIiwtMSk7dmFyIFhuPXQoe19fbmFtZTpcIldhbGluZUNvbW1lbnRcIixwcm9wczpbXCJzZXJ2ZXJVUkxcIixcInBhdGhcIixcIm1ldGFcIixcInJlcXVpcmVkTWV0YVwiLFwiZGFya1wiLFwiY29tbWVudFNvcnRpbmdcIixcImxhbmdcIixcImxvY2FsZVwiLFwicGFnZVNpemVcIixcIndvcmRMaW1pdFwiLFwiZW1vamlcIixcImxvZ2luXCIsXCJoaWdobGlnaHRlclwiLFwidGV4UmVuZGVyZXJcIixcImltYWdlVXBsb2FkZXJcIixcInNlYXJjaFwiLFwiY29weXJpZ2h0XCIsXCJyZWNhcHRjaGFWM0tleVwiLFwidHVybnN0aWxlS2V5XCIsXCJyZWFjdGlvblwiXSxzZXR1cChlKXtjb25zdCB0PWUsbj17bGF0ZXN0OlwiaW5zZXJ0ZWRBdF9kZXNjXCIsb2xkZXN0OlwiaW5zZXJ0ZWRBdF9hc2NcIixob3R0ZXN0OlwibGlrZV9kZXNjXCJ9LHk9T2JqZWN0LmtleXMobiksdz1jdCgpLGI9R2UoKSxrPWEoXCJsb2FkaW5nXCIpLCQ9YSgwKSxMPWEoMSksUj1hKDApLHg9bCgoKCk9Pigoe3NlcnZlclVSTDplLHBhdGg6dD1sb2NhdGlvbi5wYXRobmFtZSxsYW5nOm49KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBuYXZpZ2F0b3I/XCJlbi1VU1wiOm5hdmlnYXRvci5sYW5ndWFnZSksbG9jYWxlOmEsZW1vamk6bD1OLG1ldGE6cj1bXCJuaWNrXCIsXCJtYWlsXCIsXCJsaW5rXCJdLHJlcXVpcmVkTWV0YTppPVtdLGRhcms6bz0hMSxwYWdlU2l6ZTpzPTEwLHdvcmRMaW1pdDpjLGltYWdlVXBsb2FkZXI6dSxoaWdobGlnaHRlcjpkLHRleFJlbmRlcmVyOnYsY29weXJpZ2h0Om09ITAsbG9naW46cD1cImVuYWJsZVwiLHNlYXJjaDpnLHJlYWN0aW9uOmgscmVjYXB0Y2hhVjNLZXk6Zj1cIlwiLHR1cm5zdGlsZUtleTp5PVwiXCIsY29tbWVudFNvcnRpbmc6dz1cImxhdGVzdFwiLC4uLmJ9KT0+KHtzZXJ2ZXJVUkw6Z2UoZSkscGF0aDp2ZSh0KSxsb2NhbGU6ey4uLmllW25dfHxpZVtCXSwuLi5cIm9iamVjdFwiPT10eXBlb2YgYT9hOnt9fSx3b3JkTGltaXQ6aGUoYyksbWV0YTpEKHIpLHJlcXVpcmVkTWV0YTpEKGkpLGltYWdlVXBsb2FkZXI6ZmUodSxGKSxoaWdobGlnaHRlcjpmZShkLFkpLHRleFJlbmRlcmVyOmZlKHYsSyksbGFuZzpPYmplY3Qua2V5cyhpZSkuaW5jbHVkZXMobik/bjpcImVuLVVTXCIsZGFyazpvLGVtb2ppOlwiYm9vbGVhblwiPT10eXBlb2YgbD9sP046W106bCxwYWdlU2l6ZTpzLGxvZ2luOnAsY29weXJpZ2h0Om0sc2VhcmNoOiExIT09ZyYmKFwib2JqZWN0XCI9PXR5cGVvZiBnP2c6cShuKSkscmVjYXB0Y2hhVjNLZXk6Zix0dXJuc3RpbGVLZXk6eSxyZWFjdGlvbjpBcnJheS5pc0FycmF5KGgpP2g6ITA9PT1oP1c6W10sY29tbWVudFNvcnRpbmc6dywuLi5ifSkpKHQpKSksRT1hKHgudmFsdWUuY29tbWVudFNvcnRpbmcpLGo9YShbXSksUz1hKG51bGwpLFU9YShudWxsKSxfPWwoKCgpPT57cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mKGU9eC52YWx1ZS5kYXJrKT9cImF1dG9cIj09PWU/YEBtZWRpYShwcmVmZXJzLWNvbG9yLXNjaGVtZTpkYXJrKXtib2R5JHt5ZX19YDpgJHtlfSR7eWV9YDohMD09PWU/YDpyb290JHt5ZX1gOlwiXCI7dmFyIGV9KSksej1sKCgoKT0+eC52YWx1ZS5sb2NhbGUpKTtsZXQgTTtUKF8se2lkOlwid2FsaW5lLWRhcmttb2RlXCJ9KTtjb25zdCBIPWU9Pntjb25zdHtzZXJ2ZXJVUkw6dCxwYXRoOmEscGFnZVNpemU6bH09eC52YWx1ZSxyPW5ldyBBYm9ydENvbnRyb2xsZXI7ay52YWx1ZT1cImxvYWRpbmdcIixNPy4oKSwoKHtzZXJ2ZXJVUkw6ZSxsYW5nOnQscGF0aDpuLHBhZ2U6YSxwYWdlU2l6ZTpsLHNvcnRCeTpyLHNpZ25hbDppLHRva2VuOm99KT0+e2NvbnN0IHM9e307cmV0dXJuIG8mJihzLkF1dGhvcml6YXRpb249YEJlYXJlciAke299YCksZmV0Y2goYCR7ZX0vY29tbWVudD9wYXRoPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG4pfSZwYWdlU2l6ZT0ke2x9JnBhZ2U9JHthfSZsYW5nPSR7dH0mc29ydEJ5PSR7cn1gLHtzaWduYWw6aSxoZWFkZXJzOnN9KS50aGVuKChlPT5lLmpzb24oKSkpLnRoZW4oKGU9PnNlKGUsXCJHZXQgY29tbWVudCBkYXRhXCIpKSl9KSh7c2VydmVyVVJMOnQsbGFuZzp4LnZhbHVlLmxhbmcscGF0aDphLHBhZ2VTaXplOmwsc29ydEJ5Om5bRS52YWx1ZV0scGFnZTplLHNpZ25hbDpyLnNpZ25hbCx0b2tlbjp3LnZhbHVlPy50b2tlbn0pLnRoZW4oKHQ9PntrLnZhbHVlPVwic3VjY2Vzc1wiLCQudmFsdWU9dC5jb3VudCxqLnZhbHVlLnB1c2goLi4udC5kYXRhKSxMLnZhbHVlPWUsUi52YWx1ZT10LnRvdGFsUGFnZXN9KSkuY2F0Y2goKGU9PntcIkFib3J0RXJyb3JcIiE9PWUubmFtZSYmKGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlKSxrLnZhbHVlPVwiZXJyb3JcIil9KSksTT1yLmFib3J0LmJpbmQocil9LE89KCk9PkgoTC52YWx1ZSsxKSxQPSgpPT57JC52YWx1ZT0wLGoudmFsdWU9W10sSCgxKX0sVj1lPT57Uy52YWx1ZT1lfSxHPWU9PntVLnZhbHVlPWV9LFo9ZT0+e2lmKFUudmFsdWUpVS52YWx1ZS5jb21tZW50PWUuY29tbWVudCxVLnZhbHVlLm9yaWc9ZS5vcmlnO2Vsc2UgaWYoZS5yaWQpe2NvbnN0IHQ9ai52YWx1ZS5maW5kKCgoe29iamVjdElkOnR9KT0+dD09PWUucmlkKSk7aWYoIXQpcmV0dXJuO0FycmF5LmlzQXJyYXkodC5jaGlsZHJlbil8fCh0LmNoaWxkcmVuPVtdKSx0LmNoaWxkcmVuLnB1c2goZSl9ZWxzZSBqLnZhbHVlLnVuc2hpZnQoZSksJC52YWx1ZSs9MX0sSj1hc3luYyh7Y29tbWVudDplLHN0YXR1czp0fSk9PntpZihlLnN0YXR1cz09PXQpcmV0dXJuO2NvbnN0e3NlcnZlclVSTDpuLGxhbmc6YX09eC52YWx1ZTthd2FpdCBkZSh7c2VydmVyVVJMOm4sbGFuZzphLHRva2VuOncudmFsdWU/LnRva2VuLG9iamVjdElkOmUub2JqZWN0SWQsY29tbWVudDp7c3RhdHVzOnR9fSksZS5zdGF0dXM9dH0sWD1hc3luYyBlPT57aWYoZS5yaWQpcmV0dXJuO2NvbnN0e3NlcnZlclVSTDp0LGxhbmc6bn09eC52YWx1ZTthd2FpdCBkZSh7c2VydmVyVVJMOnQsbGFuZzpuLHRva2VuOncudmFsdWU/LnRva2VuLG9iamVjdElkOmUub2JqZWN0SWQsY29tbWVudDp7c3RpY2t5OmUuc3RpY2t5PzA6MX19KSxlLnN0aWNreT0hZS5zdGlja3l9LFE9YXN5bmMoe29iamVjdElkOmV9KT0+e2lmKCFjb25maXJtKFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIGNvbW1lbnQ/XCIpKXJldHVybjtjb25zdHtzZXJ2ZXJVUkw6dCxsYW5nOm59PXgudmFsdWU7YXdhaXQoKHtzZXJ2ZXJVUkw6ZSxsYW5nOnQsdG9rZW46bixvYmplY3RJZDphfSk9PmZldGNoKGAke2V9L2NvbW1lbnQvJHthfT9sYW5nPSR7dH1gLHttZXRob2Q6XCJERUxFVEVcIixoZWFkZXJzOntBdXRob3JpemF0aW9uOmBCZWFyZXIgJHtufWB9fSkudGhlbigoZT0+ZS5qc29uKCkpKS50aGVuKChlPT5zZShlLFwiRGVsZXRlIGNvbW1lbnRcIikpKSkoe3NlcnZlclVSTDp0LGxhbmc6bix0b2tlbjp3LnZhbHVlPy50b2tlbixvYmplY3RJZDplfSksai52YWx1ZS5zb21lKCgodCxuKT0+dC5vYmplY3RJZD09PWU/KGoudmFsdWU9ai52YWx1ZS5maWx0ZXIoKChlLHQpPT50IT09bikpLCEwKTp0LmNoaWxkcmVuLnNvbWUoKChhLGwpPT5hLm9iamVjdElkPT09ZSYmKGoudmFsdWVbbl0uY2hpbGRyZW49dC5jaGlsZHJlbi5maWx0ZXIoKChlLHQpPT50IT09bCkpLCEwKSkpKSl9LGVlPWFzeW5jIGU9Pntjb25zdHtzZXJ2ZXJVUkw6dCxsYW5nOm59PXgudmFsdWUse29iamVjdElkOmF9PWUsbD1iLnZhbHVlLmluY2x1ZGVzKGEpO2F3YWl0IGRlKHtzZXJ2ZXJVUkw6dCxsYW5nOm4sb2JqZWN0SWQ6YSx0b2tlbjp3LnZhbHVlPy50b2tlbixjb21tZW50OntsaWtlOiFsfX0pLGw/Yi52YWx1ZT1iLnZhbHVlLmZpbHRlcigoZT0+ZSE9PWEpKTooYi52YWx1ZT1bLi4uYi52YWx1ZSxhXSxiLnZhbHVlLmxlbmd0aD41MCYmKGIudmFsdWU9Yi52YWx1ZS5zbGljZSgtNTApKSksZS5saWtlPShlLmxpa2V8fDApKyhsPy0xOjEpfTtyZXR1cm4gQShcImNvbmZpZ1wiLHgpLHIoKCgpPT57aSgoKCk9Plt0LnNlcnZlclVSTCx0LnBhdGhdKSwoKCk9PlAoKSkse2ltbWVkaWF0ZTohMH0pfSkpLG8oKCgpPT5NPy4oKSkpLChlLHQpPT4ocygpLGMoXCJkaXZcIixUbixbQyhidCksUy52YWx1ZT9mKFwidi1pZlwiLCEwKToocygpLGcoY24se2tleTowLG9uTG9nOlAsb25TdWJtaXQ6Wn0pKSx1KFwiZGl2XCIsT24sW3UoXCJkaXZcIixQbixbJC52YWx1ZT8ocygpLGMoXCJzcGFuXCIse2tleTowLGNsYXNzOlwid2wtbnVtXCIsdGV4dENvbnRlbnQ6ZCgkLnZhbHVlKX0sbnVsbCw4LFZuKSk6ZihcInYtaWZcIiwhMCksSShcIiBcIitkKHoudmFsdWUuY29tbWVudCksMSldKSx1KFwidWxcIixEbixbKHMoITApLGModixudWxsLG0oaCh5KSwoZT0+KHMoKSxjKFwibGlcIix7a2V5OmUsY2xhc3M6cChbZT09PUUudmFsdWU/XCJhY3RpdmVcIjpcIlwiXSksb25DbGljazp0PT4oZT0+e0UudmFsdWUhPT1lJiYoRS52YWx1ZT1lLFAoKSl9KShlKX0sZCh6LnZhbHVlW2VdKSwxMSxObikpKSksMTI4KSldKV0pLHUoXCJkaXZcIixCbixbKHMoITApLGModixudWxsLG0oai52YWx1ZSwoZT0+KHMoKSxnKE1uLHtrZXk6ZS5vYmplY3RJZCxcInJvb3QtaWRcIjplLm9iamVjdElkLGNvbW1lbnQ6ZSxyZXBseTpTLnZhbHVlLGVkaXQ6VS52YWx1ZSxvbkxvZzpQLG9uUmVwbHk6VixvbkVkaXQ6RyxvblN1Ym1pdDpaLG9uU3RhdHVzOkosb25EZWxldGU6USxvblN0aWNreTpYLG9uTGlrZTplZX0sbnVsbCw4LFtcInJvb3QtaWRcIixcImNvbW1lbnRcIixcInJlcGx5XCIsXCJlZGl0XCJdKSkpKSwxMjgpKV0pLFwiZXJyb3JcIj09PWsudmFsdWU/KHMoKSxjKFwiZGl2XCIsV24sW3UoXCJidXR0b25cIix7dHlwZTpcImJ1dHRvblwiLGNsYXNzOlwid2wtYnRuXCIsb25DbGljazpQLHRleHRDb250ZW50OmQoei52YWx1ZS5yZWZyZXNoKX0sbnVsbCw4LEZuKV0pKToocygpLGModix7a2V5OjJ9LFtcImxvYWRpbmdcIj09PWsudmFsdWU/KHMoKSxjKFwiZGl2XCIsS24sW0MoaChGZSkse3NpemU6MzB9KV0pKTpqLnZhbHVlLmxlbmd0aD9MLnZhbHVlPFIudmFsdWU/KHMoKSxjKFwiZGl2XCIsR24sW3UoXCJidXR0b25cIix7dHlwZTpcImJ1dHRvblwiLGNsYXNzOlwid2wtYnRuXCIsb25DbGljazpPLHRleHRDb250ZW50OmQoei52YWx1ZS5tb3JlKX0sbnVsbCw4LFpuKV0pKTpmKFwidi1pZlwiLCEwKToocygpLGMoXCJkaXZcIix7a2V5OjEsY2xhc3M6XCJ3bC1lbXB0eVwiLHRleHRDb250ZW50OmQoei52YWx1ZS5zb2ZhKX0sbnVsbCw4LHFuKSldLDY0KSkseC52YWx1ZS5jb3B5cmlnaHQ/KHMoKSxjKFwiZGl2XCIsSm4sW0koXCIgUG93ZXJlZCBieSBcIiksWW4sSShcIiB2XCIrZChoKEhuKSksMSldKSk6ZihcInYtaWZcIiwhMCldKSl9fSksUW49d3QoWG4sW1tcIl9fZmlsZVwiLFwiV2FsaW5lQ29tbWVudC52dWVcIl1dKTtjb25zdCBlYT0oZSx0KT0+e3QuZm9yRWFjaCgoKHQsbik9Pnt0LmlubmVyVGV4dD1lW25dLnRvU3RyaW5nKCl9KSl9LHRhPSh7c2VydmVyVVJMOmUscGF0aDp0PXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxzZWxlY3RvcjpuPVwiLndhbGluZS1wYWdldmlldy1jb3VudFwiLHVwZGF0ZTphPSEwLGxhbmc6bD1uYXZpZ2F0b3IubGFuZ3VhZ2V9KT0+e2NvbnN0IHI9bmV3IEFib3J0Q29udHJvbGxlcixpPUFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChuKSksbz1lPT57Y29uc3Qgbj1fZShlKTtyZXR1cm4gbnVsbCE9PW4mJnQhPT1ufSxzPW49Pigoe3NlcnZlclVSTDplLGxhbmc6dCxwYXRoczpuLHNpZ25hbDphfSk9PmNlKHtzZXJ2ZXJVUkw6ZSxsYW5nOnQscGF0aHM6bix0eXBlOltcInRpbWVcIl0sc2lnbmFsOmF9KS50aGVuKChlPT5BcnJheS5pc0FycmF5KGUpP2U6W2VdKSkpKHtzZXJ2ZXJVUkw6Z2UoZSkscGF0aHM6bi5tYXAoKGU9Pl9lKGUpfHx0KSksbGFuZzpsLHNpZ25hbDpyLnNpZ25hbH0pLnRoZW4oKGU9PmVhKGUsbikpKS5jYXRjaChMZSk7aWYoYSl7Y29uc3Qgbj1pLmZpbHRlcigoZT0+IW8oZSkpKSxhPWkuZmlsdGVyKG8pOyhjPXtzZXJ2ZXJVUkw6Z2UoZSkscGF0aDp0LGxhbmc6bH0sdWUoey4uLmMsdHlwZTpcInRpbWVcIixhY3Rpb246XCJpbmNcIn0pKS50aGVuKChlPT5lYShuZXcgQXJyYXkobi5sZW5ndGgpLmZpbGwoZSksbikpKSxhLmxlbmd0aCYmcyhhKX1lbHNlIHMoaSk7dmFyIGM7cmV0dXJuIHIuYWJvcnQuYmluZChyKX0sbmE9KHtlbDp0PVwiI3dhbGluZVwiLHBhdGg6bj13aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsY29tbWVudDphPSExLHBhZ2V2aWV3Omw9ITEsLi4ucn0pPT57Y29uc3QgaT10P1JlKHQpOm51bGw7aWYodCYmIWkpdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uICdlbCcgZG8gbm90IG1hdGNoIGFueSBkb21FbGVtZW50IVwiKTtpZighci5zZXJ2ZXJVUkwpdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uICdzZXJ2ZXJVUkwnIGlzIG1pc3NpbmchXCIpO2NvbnN0IG89ayh7Li4ucn0pLHM9ayh7Y29tbWVudDphLHBhZ2V2aWV3OmwscGF0aDpufSksYz1pP1MoKCgpPT5lKFFuLHtwYXRoOnMucGF0aCwuLi5vfSkpKTpudWxsO2MmJmMubW91bnQoaSk7Y29uc3QgdT1VKCgoKT0+e3MuY29tbWVudCYmemUoe3NlcnZlclVSTDpvLnNlcnZlclVSTCxwYXRoOnMucGF0aCxzZWxlY3RvcjpcInN0cmluZ1wiPT10eXBlb2Ygcy5jb21tZW50P3MuY29tbWVudDp2b2lkIDB9KX0pKSxkPVUoKCgpPT57cy5wYWdldmlldyYmdGEoe3NlcnZlclVSTDpvLnNlcnZlclVSTCxwYXRoOnMucGF0aCxzZWxlY3RvcjpcInN0cmluZ1wiPT10eXBlb2Ygcy5wYWdldmlldz9zLnBhZ2V2aWV3OnZvaWQgMH0pfSkpO3JldHVybntlbDppLHVwZGF0ZTooe2NvbW1lbnQ6ZSxwYWdldmlldzp0LHBhdGg6bj13aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsLi4uYX09e30pPT57T2JqZWN0LmVudHJpZXMoYSkuZm9yRWFjaCgoKFtlLHRdKT0+e29bZV09dH0pKSxzLnBhdGg9bix2b2lkIDAhPT1lJiYocy5jb21tZW50PWUpLHZvaWQgMCE9PXQmJihzLnBhZ2V2aWV3PXQpfSxkZXN0cm95OigpPT57Yz8udW5tb3VudCgpLHUoKSxkKCl9fX0sYWE9KHtlbDplLHNlcnZlclVSTDp0LGNvdW50Om4sbGFuZzphPW5hdmlnYXRvci5sYW5ndWFnZX0pPT57Y29uc3QgbD1jdCgpLHI9UmUoZSksaT1uZXcgQWJvcnRDb250cm9sbGVyO3JldHVybigoe3NlcnZlclVSTDplLGxhbmc6dCxjb3VudDpuLHNpZ25hbDphLHRva2VuOmx9KT0+e2NvbnN0IHI9e307cmV0dXJuIGwmJihyLkF1dGhvcml6YXRpb249YEJlYXJlciAke2x9YCksZmV0Y2goYCR7ZX0vY29tbWVudD90eXBlPXJlY2VudCZjb3VudD0ke259Jmxhbmc9JHt0fWAse3NpZ25hbDphLGhlYWRlcnM6cn0pLnRoZW4oKGU9PmUuanNvbigpKSl9KSh7c2VydmVyVVJMOnQsY291bnQ6bixsYW5nOmEsc2lnbmFsOmkuc2lnbmFsLHRva2VuOmwudmFsdWU/LnRva2VufSkudGhlbigoZT0+ciYmZS5sZW5ndGg/KHIuaW5uZXJIVE1MPWA8dWwgY2xhc3M9XCJ3bC1yZWNlbnQtbGlzdFwiPiR7ZS5tYXAoKGU9PmA8bGkgY2xhc3M9XCJ3bC1yZWNlbnQtaXRlbVwiPjxhIGhyZWY9XCIke2UudXJsfVwiPiR7ZS5uaWNrfTwvYT7vvJoke2UuY29tbWVudH08L2xpPmApKS5qb2luKFwiXCIpfTwvdWw+YCx7Y29tbWVudHM6ZSxkZXN0cm95OigpPT57aS5hYm9ydCgpLHIuaW5uZXJIVE1MPVwiXCJ9fSk6e2NvbW1lbnRzOmUsZGVzdHJveTooKT0+aS5hYm9ydCgpfSkpfSxsYT0oe2VsOmUsc2VydmVyVVJMOnQsY291bnQ6bixsb2NhbGU6YSxsYW5nOmw9bmF2aWdhdG9yLmxhbmd1YWdlLG1vZGU6cj1cImxpc3RcIn0pPT57Y29uc3QgaT1SZShlKSxvPW5ldyBBYm9ydENvbnRyb2xsZXI7cmV0dXJuKCh7c2VydmVyVVJMOmUsc2lnbmFsOnQscGFnZVNpemU6bixsYW5nOmF9KT0+ZmV0Y2goYCR7ZX0vdXNlcj9wYWdlU2l6ZT0ke259Jmxhbmc9JHthfWAse3NpZ25hbDp0fSkudGhlbigoZT0+ZS5qc29uKCkpKS50aGVuKChlPT5zZShlLFwidXNlciBsaXN0XCIpKSkudGhlbigoZT0+ZS5kYXRhKSkpKHtzZXJ2ZXJVUkw6dCxwYWdlU2l6ZTpuLGxhbmc6bCxzaWduYWw6by5zaWduYWx9KS50aGVuKChlPT5pJiZlLmxlbmd0aD8oYT17Li4uaWVbbF18fGllW0JdLC4uLlwib2JqZWN0XCI9PXR5cGVvZiBhP2E6e319LGkuaW5uZXJIVE1MPWA8dWwgY2xhc3M9XCJ3bC11c2VyLSR7cn1cIj4ke2UubWFwKCgoZSx0KT0+W2A8bGkgY2xhc3M9XCJ3bC11c2VyLWl0ZW1cIiBhcmlhLWxhYmVsPVwiJHtlLm5pY2t9XCI+YCxlLmxpbmsmJmA8YSBocmVmPVwiJHtlLmxpbmt9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+YCwnPGRpdiBjbGFzcz1cIndsLXVzZXItYXZhdGFyXCI+JyxgPGltZyBzcmM9XCIke2UuYXZhdGFyfVwiIGFsdD1cIiR7ZS5uaWNrfVwiPmAsYDxzcGFuIGNsYXNzPVwid2wtdXNlci1iYWRnZVwiPiR7dCsxfTwvc3Bhbj5gLFwiPC9kaXY+XCIsJzxkaXYgY2xhc3M9XCJ3bC11c2VyLW1ldGFcIj4nLCc8ZGl2IGNsYXNzPVwid2wtdXNlci1uYW1lXCI+JyxlLm5pY2ssZS5sZXZlbCYmYDxzcGFuIGNsYXNzPVwid2wtYmFkZ2VcIj4ke2E/YVtgbGV2ZWwke2UubGV2ZWx9YF06YExldmVsICR7ZS5sZXZlbH1gfTwvc3Bhbj5gLGUubGFiZWwmJmA8c3BhbiBjbGFzcz1cIndsLWJhZGdlXCI+JHtlLmxhYmVsfTwvc3Bhbj5gLFwiPC9kaXY+XCIsZS5saW5rJiZlLmxpbmssXCI8L2Rpdj5cIixlLmxpbmsmJlwiPC9hPlwiLFwiPC9saT5cIl0uZmlsdGVyKChlPT5lKSkuam9pbihcIlwiKSkpLmpvaW4oXCJcIil9PC91bD5gLHt1c2VyczplLGRlc3Ryb3k6KCk9PntvLmFib3J0KCksaS5pbm5lckhUTUw9XCJcIn19KTp7dXNlcnM6ZSxkZXN0cm95OigpPT5vLmFib3J0KCl9KSl9O2V4cG9ydHthYSBhcyBSZWNlbnRDb21tZW50cyxsYSBhcyBVc2VyTGlzdCx6ZSBhcyBjb21tZW50Q291bnQsaWUgYXMgZGVmYXVsdExvY2FsZXMsbmEgYXMgaW5pdCx0YSBhcyBwYWdldmlld0NvdW50LEhuIGFzIHZlcnNpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hpbS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@waline/client/dist/shim.mjs\n"));

/***/ }),

/***/ "./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: function() { return /* binding */ Hooks; },\n/* harmony export */   Lexer: function() { return /* binding */ Lexer; },\n/* harmony export */   Parser: function() { return /* binding */ Parser; },\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; },\n/* harmony export */   Slugger: function() { return /* binding */ Slugger; },\n/* harmony export */   TextRenderer: function() { return /* binding */ TextRenderer; },\n/* harmony export */   Tokenizer: function() { return /* binding */ Tokenizer; },\n/* harmony export */   defaults: function() { return /* binding */ defaults; },\n/* harmony export */   getDefaults: function() { return /* binding */ getDefaults; },\n/* harmony export */   lexer: function() { return /* binding */ lexer; },\n/* harmony export */   marked: function() { return /* binding */ marked; },\n/* harmony export */   options: function() { return /* binding */ options; },\n/* harmony export */   parse: function() { return /* binding */ parse; },\n/* harmony export */   parseInline: function() { return /* binding */ parseInline; },\n/* harmony export */   parser: function() { return /* binding */ parser; },\n/* harmony export */   setOptions: function() { return /* binding */ setOptions; },\n/* harmony export */   use: function() { return /* binding */ use; },\n/* harmony export */   walkTokens: function() { return /* binding */ walkTokens; }\n/* harmony export */ });\n/**\n * marked v4.3.0 - a markdown parser\n * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\nfunction getDefaults() {\n  return {\n    async: false,\n    baseUrl: null,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    hooks: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartypants: false,\n    tokenizer: null,\n    walkTokens: null,\n    xhtml: false\n  };\n}\n\nlet defaults = getDefaults();\n\nfunction changeDefaults(newDefaults) {\n  defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n/**\n * @param {string} html\n */\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\n\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */\nfunction edit(regex, opt) {\n  regex = typeof regex === 'string' ? regex : regex.source;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n/**\n * @param {string} base\n * @param {string} href\n */\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) { cells.shift(); }\n  if (cells.length > 0 && !cells[cells.length - 1].trim()) { cells.pop(); }\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\n// copied from https://stackoverflow.com/a/5450113/806777\n/**\n * @param {string} pattern\n * @param {number} count\n */\nfunction repeatString(pattern, count) {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1;\n    pattern += pattern;\n  }\n  return result + pattern;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n  const href = link.href;\n  const title = link.title ? escape(link.title) : null;\n  const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    lexer.state.inLink = true;\n    const token = {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text,\n      tokens: lexer.inlineTokens(text)\n    };\n    lexer.state.inLink = false;\n    return token;\n  }\n  return {\n    type: 'image',\n    raw,\n    href,\n    title,\n    text: escape(text)\n  };\n}\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nclass Tokenizer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  space(src) {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0]\n      };\n    }\n  }\n\n  code(src) {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ {1,4}/gm, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text\n      };\n    }\n  }\n\n  fences(src) {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],\n        text\n      };\n    }\n  }\n\n  heading(src) {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (/#$/.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || / $/.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text)\n      };\n    }\n  }\n\n  hr(src) {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: cap[0]\n      };\n    }\n  }\n\n  blockquote(src) {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ *>[ \\t]?/gm, '');\n      const top = this.lexer.state.top;\n      this.lexer.state.top = true;\n      const tokens = this.lexer.blockTokens(text);\n      this.lexer.state.top = top;\n      return {\n        type: 'blockquote',\n        raw: cap[0],\n        tokens,\n        text\n      };\n    }\n  }\n\n  list(src) {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,\n        line, nextLine, rawLine, itemContents, endEarly;\n\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: []\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        endEarly = false;\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n        nextLine = src.split('\\n', 1)[0];\n\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimLeft();\n        } else {\n          indent = cap[2].search(/[^ ]/); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        blankLine = false;\n\n        if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            rawLine = src.split('\\n', 1)[0];\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(src)) {\n              break;\n            }\n\n            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLine.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.search(/[^ ]/) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLine.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (/\\n *\\n *$/.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = /^\\[[ xX]\\] /.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      list.items[list.items.length - 1].raw = raw.trimRight();\n      list.items[list.items.length - 1].text = itemContents.trimRight();\n      list.raw = list.raw.trimRight();\n\n      const l = list.items.length;\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (i = 0; i < l; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (i = 0; i < l; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src) {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token = {\n        type: 'html',\n        raw: cap[0],\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      };\n      if (this.options.sanitize) {\n        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n        token.type = 'paragraph';\n        token.text = text;\n        token.tokens = this.lexer.inline(text);\n      }\n      return token;\n    }\n  }\n\n  def(src) {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title\n      };\n    }\n  }\n\n  table(src) {\n    const cap = this.rules.block.table.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1]).map(c => { return { text: c }; }),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        item.raw = cap[0];\n\n        let l = item.align.length;\n        let i, j, k, row;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.rows.length;\n        for (i = 0; i < l; i++) {\n          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => { return { text: c }; });\n        }\n\n        // parse child tokens inside headers and cells\n\n        // header child tokens\n        l = item.header.length;\n        for (j = 0; j < l; j++) {\n          item.header[j].tokens = this.lexer.inline(item.header[j].text);\n        }\n\n        // cell child tokens\n        l = item.rows.length;\n        for (j = 0; j < l; j++) {\n          row = item.rows[j];\n          for (k = 0; k < row.length; k++) {\n            row[k].tokens = this.lexer.inline(row[k].text);\n          }\n        }\n\n        return item;\n      }\n    }\n  }\n\n  lheading(src) {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1])\n      };\n    }\n  }\n\n  paragraph(src) {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text)\n      };\n    }\n  }\n\n  text(src) {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0])\n      };\n    }\n  }\n\n  escape(src) {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: escape(cap[1])\n      };\n    }\n  }\n\n  tag(src) {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: this.options.sanitize\n          ? 'text'\n          : 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        text: this.options.sanitize\n          ? (this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0]))\n          : cap[0]\n      };\n    }\n  }\n\n  link(src) {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(/>$/.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (/^</.test(href)) {\n        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n        title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n      }, cap[0], this.lexer);\n    }\n  }\n\n  reflink(src, links) {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n        || (cap = this.rules.inline.nolink.exec(src))) {\n      let link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = links[link.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer);\n    }\n  }\n\n  emStrong(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.emStrong.lDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n      const lLength = match[0].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = rDelim.length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n\n        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text)\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text)\n        };\n      }\n    }\n  }\n\n  codespan(src) {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(/\\n/g, ' ');\n      const hasNonSpaceChars = /[^ ]/.test(text);\n      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      text = escape(text, true);\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  br(src) {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0]\n      };\n    }\n  }\n\n  del(src) {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2])\n      };\n    }\n  }\n\n  autolink(src, mangle) {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  url(src, mangle) {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  inlineText(src, smartypants) {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      let text;\n      if (this.lexer.state.inRawBlock) {\n        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];\n      } else {\n        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n      }\n      return {\n        type: 'text',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n}\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^(?: *(?:\\n|$))+/,\n  code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n  fences: /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n  hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n  table: noopTest,\n  lheading: /^((?:.|\\n(?!\\n))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */)\n  .replace('bull', block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = { ...block };\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = {\n  ...block.normal,\n  table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n};\n\nblock.gfm.table = edit(block.gfm.table)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.gfm.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('table', block.gfm.table) // interrupt paragraphs with table\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = {\n  ...block.normal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n};\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n  nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n  reflinkSearch: 'reflink|nolink(?!\\\\()',\n  emStrong: {\n    lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n    rDelimAst: /^(?:[^_*\\\\]|\\\\.)*?\\_\\_(?:[^_*\\\\]|\\\\.)*?\\*(?:[^_*\\\\]|\\\\.)*?(?=\\_\\_)|(?:[^*\\\\]|\\\\.)+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[^punct*_\\s])/,\n    rDelimUnd: /^(?:[^_*\\\\]|\\\\.)*?\\*\\*(?:[^_*\\\\]|\\\\.)*?\\_(?:[^_*\\\\]|\\\\.)*?(?=\\*\\*)|(?:[^_\\\\]|\\\\.)+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n  },\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n  punctuation: /^([\\spunctuation])/\n};\n\n// list of punctuation marks from CommonMark spec\n// without * and _ to handle the different emphasis markers * and _\ninline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n// lookbehind is not available on Safari as of version 16\n// inline.escapedEmSt = /(?<=(?:^|[^\\\\)(?:\\\\[^])*)\\\\[*_]/g;\ninline.escapedEmSt = /(?:^|[^\\\\])(?:\\\\\\\\)*\\\\[*_]/g;\n\ninline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim)\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', inline._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.nolink = edit(inline.nolink)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.reflinkSearch = edit(inline.reflinkSearch, 'g')\n  .replace('reflink', inline.reflink)\n  .replace('nolink', inline.nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = { ...inline };\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = {\n  ...inline.normal,\n  strong: {\n    start: /^__|\\*\\*/,\n    middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    endAst: /\\*\\*(?!\\*)/g,\n    endUnd: /__(?!_)/g\n  },\n  em: {\n    start: /^_|\\*/,\n    middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n    endAst: /\\*(?!\\*)/g,\n    endUnd: /_(?!_)/g\n  },\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n};\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = {\n  ...inline.normal,\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = {\n  ...inline.gfm,\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n};\n\n/**\n * smartypants text replacement\n * @param {string} text\n */\nfunction smartypants(text) {\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n}\n\n/**\n * mangle email addresses\n * @param {string} text\n */\nfunction mangle(text) {\n  let out = '',\n    i,\n    ch;\n\n  const l = text.length;\n  for (i = 0; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n}\n\n/**\n * Block Lexer\n */\nclass Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true\n    };\n\n    const rules = {\n      block: block.normal,\n      inline: inline.normal\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    let next;\n    while (next = this.inlineQueue.shift()) {\n      this.inlineTokens(next.src, next.tokens);\n    }\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src, tokens = []) {\n    if (this.options.pedantic) {\n      src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n    } else {\n      src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n        return leading + '    '.repeat(tabs.length);\n      });\n    }\n\n    let token, lastToken, cutSrc, lastParagraphClipped;\n\n    while (src) {\n      if (this.options.extensions\n        && this.options.extensions.block\n        && this.options.extensions.block.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.length === 1 && tokens.length > 0) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unecessary paragraph tags\n          tokens[tokens.length - 1].raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        lastToken = tokens[tokens.length - 1];\n        if (lastParagraphClipped && lastToken.type === 'paragraph') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = (cutSrc.length !== src.length);\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src, tokens = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src, tokens = []) {\n    let token, lastToken, cutSrc;\n\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match;\n    let keepPrevChar, prevChar;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out escaped em & strong delimiters\n    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;\n    }\n\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      // extensions\n      if (this.options.extensions\n        && this.options.extensions.inline\n        && this.options.extensions.inline.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src, mangle)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n\n/**\n * Renderer\n */\nclass Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    code = code.replace(/\\n$/, '') + '\\n';\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  /**\n   * @param {string} quote\n   */\n  blockquote(quote) {\n    return `<blockquote>\\n${quote}</blockquote>\\n`;\n  }\n\n  html(html) {\n    return html;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      const id = this.options.headerPrefix + slugger.slug(raw);\n      return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n    }\n\n    // ignore IDs\n    return `<h${level}>${text}</h${level}>\\n`;\n  }\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  /**\n   * @param {string} text\n   */\n  listitem(text) {\n    return `<li>${text}</li>\\n`;\n  }\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  }\n\n  /**\n   * @param {string} text\n   */\n  paragraph(text) {\n    return `<p>${text}</p>\\n`;\n  }\n\n  /**\n   * @param {string} header\n   * @param {string} body\n   */\n  table(header, body) {\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  /**\n   * @param {string} content\n   */\n  tablerow(content) {\n    return `<tr>\\n${content}</tr>\\n`;\n  }\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? `<${type} align=\"${flags.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n`;\n  }\n\n  /**\n   * span level renderer\n   * @param {string} text\n   */\n  strong(text) {\n    return `<strong>${text}</strong>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  em(text) {\n    return `<em>${text}</em>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  codespan(text) {\n    return `<code>${text}</code>`;\n  }\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  /**\n   * @param {string} text\n   */\n  del(text) {\n    return `<del>${text}</del>`;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${title}\"`;\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  }\n\n  text(text) {\n    return text;\n  }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  html(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n}\n\n/**\n * Slugger generates header id\n */\nclass Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  /**\n   * @param {string} value\n   */\n  serialize(value) {\n    return value\n      .toLowerCase()\n      .trim()\n      // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '')\n      // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n  }\n\n  /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */\n  getNextSafeSlug(originalSlug, isDryRun) {\n    let slug = originalSlug;\n    let occurenceAccumulator = 0;\n    if (this.seen.hasOwnProperty(slug)) {\n      occurenceAccumulator = this.seen[originalSlug];\n      do {\n        occurenceAccumulator++;\n        slug = originalSlug + '-' + occurenceAccumulator;\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    if (!isDryRun) {\n      this.seen[originalSlug] = occurenceAccumulator;\n      this.seen[slug] = 0;\n    }\n    return slug;\n  }\n\n  /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */\n  slug(value, options = {}) {\n    const slug = this.serialize(value);\n    return this.getNextSafeSlug(slug, options.dryrun);\n  }\n}\n\n/**\n * Parsing & Compiling\n */\nclass Parser {\n  constructor(options) {\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.textRenderer = new TextRenderer();\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens, top = true) {\n    let out = '',\n      i,\n      j,\n      k,\n      l2,\n      l3,\n      row,\n      cell,\n      header,\n      body,\n      token,\n      ordered,\n      start,\n      loose,\n      itemBody,\n      item,\n      checked,\n      task,\n      checkbox,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'space': {\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr();\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(\n            this.parseInline(token.tokens),\n            token.depth,\n            unescape(this.parseInline(token.tokens, this.textRenderer)),\n            this.slugger);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token.text,\n            token.lang,\n            token.escaped);\n          continue;\n        }\n        case 'table': {\n          header = '';\n\n          // header\n          cell = '';\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            cell += this.renderer.tablecell(\n              this.parseInline(token.header[j].tokens),\n              { header: true, align: token.align[j] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n\n          body = '';\n          l2 = token.rows.length;\n          for (j = 0; j < l2; j++) {\n            row = token.rows[j];\n\n            cell = '';\n            l3 = row.length;\n            for (k = 0; k < l3; k++) {\n              cell += this.renderer.tablecell(\n                this.parseInline(row[k].tokens),\n                { header: false, align: token.align[k] }\n              );\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n          out += this.renderer.table(header, body);\n          continue;\n        }\n        case 'blockquote': {\n          body = this.parse(token.tokens);\n          out += this.renderer.blockquote(body);\n          continue;\n        }\n        case 'list': {\n          ordered = token.ordered;\n          start = token.start;\n          loose = token.loose;\n          l2 = token.items.length;\n\n          body = '';\n          for (j = 0; j < l2; j++) {\n            item = token.items[j];\n            checked = item.checked;\n            task = item.task;\n\n            itemBody = '';\n            if (item.task) {\n              checkbox = this.renderer.checkbox(checked);\n              if (loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                  }\n                } else {\n                  item.tokens.unshift({\n                    type: 'text',\n                    text: checkbox\n                  });\n                }\n              } else {\n                itemBody += checkbox;\n              }\n            }\n\n            itemBody += this.parse(item.tokens, loose);\n            body += this.renderer.listitem(itemBody, task, checked);\n          }\n\n          out += this.renderer.list(body, ordered, start);\n          continue;\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          out += this.renderer.html(token.text);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(this.parseInline(token.tokens));\n          continue;\n        }\n        case 'text': {\n          body = token.tokens ? this.parseInline(token.tokens) : token.text;\n          while (i + 1 < l && tokens[i + 1].type === 'text') {\n            token = tokens[++i];\n            body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n          }\n          out += top ? this.renderer.paragraph(body) : body;\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens, renderer) {\n    renderer = renderer || this.renderer;\n    let out = '',\n      i,\n      token,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token.text);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token.text);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token.href, token.title, token.text);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'em': {\n          out += renderer.em(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token.text);\n          break;\n        }\n        case 'br': {\n          out += renderer.br();\n          break;\n        }\n        case 'del': {\n          out += renderer.del(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token.text);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n}\n\nclass Hooks {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess'\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html) {\n    return html;\n  }\n}\n\nfunction onError(silent, async, callback) {\n  return (e) => {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n    if (silent) {\n      const msg = '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n      if (async) {\n        return Promise.resolve(msg);\n      }\n      if (callback) {\n        callback(null, msg);\n        return;\n      }\n      return msg;\n    }\n\n    if (async) {\n      return Promise.reject(e);\n    }\n    if (callback) {\n      callback(e);\n      return;\n    }\n    throw e;\n  };\n}\n\nfunction parseMarkdown(lexer, parser) {\n  return (src, opt, callback) => {\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    const origOpt = { ...opt };\n    opt = { ...marked.defaults, ...origOpt };\n    const throwError = onError(opt.silent, opt.async, callback);\n\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      return throwError(new Error('marked(): input parameter is undefined or null'));\n    }\n    if (typeof src !== 'string') {\n      return throwError(new Error('marked(): input parameter is of type '\n        + Object.prototype.toString.call(src) + ', string expected'));\n    }\n\n    checkSanitizeDeprecation(opt);\n\n    if (opt.hooks) {\n      opt.hooks.options = opt;\n    }\n\n    if (callback) {\n      const highlight = opt.highlight;\n      let tokens;\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src);\n        }\n        tokens = lexer(src, opt);\n      } catch (e) {\n        return throwError(e);\n      }\n\n      const done = function(err) {\n        let out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n            out = parser(tokens, opt);\n            if (opt.hooks) {\n              out = opt.hooks.postprocess(out);\n            }\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n\n        return err\n          ? throwError(err)\n          : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n\n      if (!tokens.length) return done();\n\n      let pending = 0;\n      marked.walkTokens(tokens, function(token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(() => {\n            highlight(token.text, token.lang, function(err, code) {\n              if (err) {\n                return done(err);\n              }\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    if (opt.async) {\n      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n        .then(src => lexer(src, opt))\n        .then(tokens => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n        .then(tokens => parser(tokens, opt))\n        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n        .catch(throwError);\n    }\n\n    try {\n      if (opt.hooks) {\n        src = opt.hooks.preprocess(src);\n      }\n      const tokens = lexer(src, opt);\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n      let html = parser(tokens, opt);\n      if (opt.hooks) {\n        html = opt.hooks.postprocess(html);\n      }\n      return html;\n    } catch (e) {\n      return throwError(e);\n    }\n  };\n}\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  return parseMarkdown(Lexer.lex, Parser.parse)(src, opt, callback);\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  marked.defaults = { ...marked.defaults, ...opt };\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args) {\n  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };\n\n  args.forEach((pack) => {\n    // copy options to new object\n    const opts = { ...pack };\n\n    // set async to true if it was set to true before\n    opts.async = marked.defaults.async || opts.async || false;\n\n    // ==-- Parse \"addon\" extensions --== //\n    if (pack.extensions) {\n      pack.extensions.forEach((ext) => {\n        if (!ext.name) {\n          throw new Error('extension name required');\n        }\n        if (ext.renderer) { // Renderer extensions\n          const prevRenderer = extensions.renderers[ext.name];\n          if (prevRenderer) {\n            // Replace extension with func to run new extension but fall back if false\n            extensions.renderers[ext.name] = function(...args) {\n              let ret = ext.renderer.apply(this, args);\n              if (ret === false) {\n                ret = prevRenderer.apply(this, args);\n              }\n              return ret;\n            };\n          } else {\n            extensions.renderers[ext.name] = ext.renderer;\n          }\n        }\n        if (ext.tokenizer) { // Tokenizer Extensions\n          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n            throw new Error(\"extension level must be 'block' or 'inline'\");\n          }\n          if (extensions[ext.level]) {\n            extensions[ext.level].unshift(ext.tokenizer);\n          } else {\n            extensions[ext.level] = [ext.tokenizer];\n          }\n          if (ext.start) { // Function to check for start of token\n            if (ext.level === 'block') {\n              if (extensions.startBlock) {\n                extensions.startBlock.push(ext.start);\n              } else {\n                extensions.startBlock = [ext.start];\n              }\n            } else if (ext.level === 'inline') {\n              if (extensions.startInline) {\n                extensions.startInline.push(ext.start);\n              } else {\n                extensions.startInline = [ext.start];\n              }\n            }\n          }\n        }\n        if (ext.childTokens) { // Child tokens to be visited by walkTokens\n          extensions.childTokens[ext.name] = ext.childTokens;\n        }\n      });\n      opts.extensions = extensions;\n    }\n\n    // ==-- Parse \"overwrite\" extensions --== //\n    if (pack.renderer) {\n      const renderer = marked.defaults.renderer || new Renderer();\n      for (const prop in pack.renderer) {\n        const prevRenderer = renderer[prop];\n        // Replace renderer with func to run extension, but fall back if false\n        renderer[prop] = (...args) => {\n          let ret = pack.renderer[prop].apply(renderer, args);\n          if (ret === false) {\n            ret = prevRenderer.apply(renderer, args);\n          }\n          return ret;\n        };\n      }\n      opts.renderer = renderer;\n    }\n    if (pack.tokenizer) {\n      const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n      for (const prop in pack.tokenizer) {\n        const prevTokenizer = tokenizer[prop];\n        // Replace tokenizer with func to run extension, but fall back if false\n        tokenizer[prop] = (...args) => {\n          let ret = pack.tokenizer[prop].apply(tokenizer, args);\n          if (ret === false) {\n            ret = prevTokenizer.apply(tokenizer, args);\n          }\n          return ret;\n        };\n      }\n      opts.tokenizer = tokenizer;\n    }\n\n    // ==-- Parse Hooks extensions --== //\n    if (pack.hooks) {\n      const hooks = marked.defaults.hooks || new Hooks();\n      for (const prop in pack.hooks) {\n        const prevHook = hooks[prop];\n        if (Hooks.passThroughHooks.has(prop)) {\n          hooks[prop] = (arg) => {\n            if (marked.defaults.async) {\n              return Promise.resolve(pack.hooks[prop].call(hooks, arg)).then(ret => {\n                return prevHook.call(hooks, ret);\n              });\n            }\n\n            const ret = pack.hooks[prop].call(hooks, arg);\n            return prevHook.call(hooks, ret);\n          };\n        } else {\n          hooks[prop] = (...args) => {\n            let ret = pack.hooks[prop].apply(hooks, args);\n            if (ret === false) {\n              ret = prevHook.apply(hooks, args);\n            }\n            return ret;\n          };\n        }\n      }\n      opts.hooks = hooks;\n    }\n\n    // ==-- Parse WalkTokens extensions --== //\n    if (pack.walkTokens) {\n      const walkTokens = marked.defaults.walkTokens;\n      opts.walkTokens = function(token) {\n        let values = [];\n        values.push(pack.walkTokens.call(this, token));\n        if (walkTokens) {\n          values = values.concat(walkTokens.call(this, token));\n        }\n        return values;\n      };\n    }\n\n    marked.setOptions(opts);\n  });\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens, callback) {\n  let values = [];\n  for (const token of tokens) {\n    values = values.concat(callback.call(marked, token));\n    switch (token.type) {\n      case 'table': {\n        for (const cell of token.header) {\n          values = values.concat(marked.walkTokens(cell.tokens, callback));\n        }\n        for (const row of token.rows) {\n          for (const cell of row) {\n            values = values.concat(marked.walkTokens(cell.tokens, callback));\n          }\n        }\n        break;\n      }\n      case 'list': {\n        values = values.concat(marked.walkTokens(token.items, callback));\n        break;\n      }\n      default: {\n        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) { // Walk any extensions\n          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {\n            values = values.concat(marked.walkTokens(token[childTokens], callback));\n          });\n        } else if (token.tokens) {\n          values = values.concat(marked.walkTokens(token.tokens, callback));\n        }\n      }\n    }\n  }\n  return values;\n};\n\n/**\n * Parse Inline\n * @param {string} src\n */\nmarked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);\n\n/**\n * Expose\n */\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.Hooks = Hooks;\nmarked.parse = marked;\n\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = Parser.parse;\nconst lexer = Lexer.lex;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUksa0JBQWtCLElBQUksTUFBTTtBQUM1RTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZEQUE2RDs7QUFFN0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLElBQUksSUFBSSxlQUFlLFNBQVMsS0FBSzs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RCxpRUFBaUU7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hELGlFQUFpRTtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsWUFBWTtBQUNaOztBQUVB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azovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzPzZkZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjQuMy4wIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIzLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB7XG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGJhc2VVcmw6IG51bGwsXG4gICAgYnJlYWtzOiBmYWxzZSxcbiAgICBleHRlbnNpb25zOiBudWxsLFxuICAgIGdmbTogdHJ1ZSxcbiAgICBoZWFkZXJJZHM6IHRydWUsXG4gICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICBoaWdobGlnaHQ6IG51bGwsXG4gICAgaG9va3M6IG51bGwsXG4gICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgbWFuZ2xlOiB0cnVlLFxuICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICByZW5kZXJlcjogbnVsbCxcbiAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgc2FuaXRpemVyOiBudWxsLFxuICAgIHNpbGVudDogZmFsc2UsXG4gICAgc21hcnR5cGFudHM6IGZhbHNlLFxuICAgIHRva2VuaXplcjogbnVsbCxcbiAgICB3YWxrVG9rZW5zOiBudWxsLFxuICAgIHhodG1sOiBmYWxzZVxuICB9O1xufVxuXG5sZXQgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuXG5mdW5jdGlvbiBjaGFuZ2VEZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICBkZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuY29uc3QgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG5jb25zdCBlc2NhcGVSZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0LnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLztcbmNvbnN0IGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdE5vRW5jb2RlLnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICBpZiAoZW5jb2RlKSB7XG4gICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn1cblxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIC8vIGV4cGxpY2l0bHkgbWF0Y2ggZGVjaW1hbCwgaGV4LCBhbmQgbmFtZWQgSFRNTCBlbnRpdGllc1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgKF8sIG4pID0+IHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmNvbnN0IGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gcmVnZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRcbiAqL1xuZnVuY3Rpb24gZWRpdChyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIGNvbnN0IG9iaiA9IHtcbiAgICByZXBsYWNlOiAobmFtZSwgdmFsKSA9PiB7XG4gICAgICB2YWwgPSB2YWwuc291cmNlIHx8IHZhbDtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKGNhcmV0LCAnJDEnKTtcbiAgICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBvYmo7XG59XG5cbmNvbnN0IG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xuY29uc3Qgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2FuaXRpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICovXG5mdW5jdGlvbiBjbGVhblVybChzYW5pdGl6ZSwgYmFzZSwgaHJlZikge1xuICBpZiAoc2FuaXRpemUpIHtcbiAgICBsZXQgcHJvdDtcbiAgICB0cnkge1xuICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2Uobm9uV29yZEFuZENvbG9uVGVzdCwgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvdC5pbmRleE9mKCdqYXZhc2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZigndmJzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICBocmVmID0gcmVzb2x2ZVVybChiYXNlLCBocmVmKTtcbiAgfVxuICB0cnkge1xuICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaHJlZjtcbn1cblxuY29uc3QgYmFzZVVybHMgPSB7fTtcbmNvbnN0IGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuY29uc3QgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG5jb25zdCBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBocmVmXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0oYmFzZSwgJy8nLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICBjb25zdCByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG5cbiAgaWYgKGhyZWYuc3Vic3RyaW5nKDAsIDIpID09PSAnLy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICB9XG59XG5cbmNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiBmdW5jdGlvbiBub29wVGVzdCgpIHt9IH07XG5cbmZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICBjb25zdCByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgICAgbGV0IGVzY2FwZWQgPSBmYWxzZSxcbiAgICAgICAgY3VyciA9IG9mZnNldDtcbiAgICAgIHdoaWxlICgtLWN1cnIgPj0gMCAmJiBzdHJbY3Vycl0gPT09ICdcXFxcJykgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICBsZXQgaSA9IDA7XG5cbiAgLy8gRmlyc3QvbGFzdCBjZWxsIGluIGEgcm93IGNhbm5vdCBiZSBlbXB0eSBpZiBpdCBoYXMgbm8gbGVhZGluZy90cmFpbGluZyBwaXBlXG4gIGlmICghY2VsbHNbMF0udHJpbSgpKSB7IGNlbGxzLnNoaWZ0KCk7IH1cbiAgaWYgKGNlbGxzLmxlbmd0aCA+IDAgJiYgIWNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLnRyaW0oKSkgeyBjZWxscy5wb3AoKTsgfVxuXG4gIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KSBjZWxscy5wdXNoKCcnKTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgY2VsbHNbaV0gPSBjZWxsc1tpXS50cmltKCkucmVwbGFjZSgvXFxcXFxcfC9nLCAnfCcpO1xuICB9XG4gIHJldHVybiBjZWxscztcbn1cblxuLyoqXG4gKiBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuICogL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gY1xuICogQHBhcmFtIHtib29sZWFufSBpbnZlcnQgUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cbiAqL1xuZnVuY3Rpb24gcnRyaW0oc3RyLCBjLCBpbnZlcnQpIHtcbiAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gIGlmIChsID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgbGV0IHN1ZmZMZW4gPSAwO1xuXG4gIC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICBjb25zdCBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcbiAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgc3VmZkxlbisrO1xuICAgIH0gZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICBzdWZmTGVuKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHIuc2xpY2UoMCwgbCAtIHN1ZmZMZW4pO1xufVxuXG5mdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQoc3RyLCBiKSB7XG4gIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gIGxldCBsZXZlbCA9IDAsXG4gICAgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgIGxldmVsKys7XG4gICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMV0pIHtcbiAgICAgIGxldmVsLS07XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpIHtcbiAgaWYgKG9wdCAmJiBvcHQuc2FuaXRpemUgJiYgIW9wdC5zaWxlbnQpIHtcbiAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBzYW5pdGl6ZSBhbmQgc2FuaXRpemVyIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjcuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vbWFya2VkLmpzLm9yZy8jL1VTSU5HX0FEVkFOQ0VELm1kI29wdGlvbnMnKTtcbiAgfVxufVxuXG4vLyBjb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTQ1MDExMy84MDY3Nzdcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICovXG5mdW5jdGlvbiByZXBlYXRTdHJpbmcocGF0dGVybiwgY291bnQpIHtcbiAgaWYgKGNvdW50IDwgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIHdoaWxlIChjb3VudCA+IDEpIHtcbiAgICBpZiAoY291bnQgJiAxKSB7XG4gICAgICByZXN1bHQgKz0gcGF0dGVybjtcbiAgICB9XG4gICAgY291bnQgPj49IDE7XG4gICAgcGF0dGVybiArPSBwYXR0ZXJuO1xuICB9XG4gIHJldHVybiByZXN1bHQgKyBwYXR0ZXJuO1xufVxuXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICBjb25zdCBocmVmID0gbGluay5ocmVmO1xuICBjb25zdCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuXG4gIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgcmF3LFxuICAgICAgaHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgdGV4dCxcbiAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgfTtcbiAgICBsZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnaW1hZ2UnLFxuICAgIHJhdyxcbiAgICBocmVmLFxuICAgIHRpdGxlLFxuICAgIHRleHQ6IGVzY2FwZSh0ZXh0KVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICBjb25zdCBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICBpZiAobWF0Y2hJbmRlbnRUb0NvZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGNvbnN0IGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuXG4gIHJldHVybiB0ZXh0XG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICBjb25zdCBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG4gICAgICBpZiAobWF0Y2hJbmRlbnRJbk5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtpbmRlbnRJbk5vZGVdID0gbWF0Y2hJbmRlbnRJbk5vZGU7XG5cbiAgICAgIGlmIChpbmRlbnRJbk5vZGUubGVuZ3RoID49IGluZGVudFRvQ29kZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc2xpY2UoaW5kZW50VG9Db2RlLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBUb2tlbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cztcbiAgfVxuXG4gIHNwYWNlKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2submV3bGluZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29kZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgIDogdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmZW5jZXMoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHJhdyA9IGNhcFswXTtcbiAgICAgIGNvbnN0IHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICByYXcsXG4gICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaGVhZGluZyhzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnRyaW0oKTtcblxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBydHJpbSh0ZXh0LCAnIycpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0LFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGhyKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHIuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5ibG9ja3F1b3RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj5bIFxcdF0/L2dtLCAnJyk7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLmxleGVyLnN0YXRlLnRvcDtcbiAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnModGV4dCk7XG4gICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRvcDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRva2VucyxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBsaXN0KHNyYykge1xuICAgIGxldCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGxldCByYXcsIGlzdGFzaywgaXNjaGVja2VkLCBpbmRlbnQsIGksIGJsYW5rTGluZSwgZW5kc1dpdGhCbGFua0xpbmUsXG4gICAgICAgIGxpbmUsIG5leHRMaW5lLCByYXdMaW5lLCBpdGVtQ29udGVudHMsIGVuZEVhcmx5O1xuXG4gICAgICBsZXQgYnVsbCA9IGNhcFsxXS50cmltKCk7XG4gICAgICBjb25zdCBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG5cbiAgICAgIGNvbnN0IGxpc3QgPSB7XG4gICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwuc2xpY2UoMCwgLTEpIDogJycsXG4gICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBidWxsID0gaXNvcmRlcmVkID8gYFxcXFxkezEsOX1cXFxcJHtidWxsLnNsaWNlKC0xKX1gIDogYFxcXFwke2J1bGx9YDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYnVsbCA6ICdbKistXSc7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBuZXh0IGxpc3QgaXRlbVxuICAgICAgY29uc3QgaXRlbVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiggezAsM30ke2J1bGx9KSgoPzpbXFx0IF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGJ1bGxldCBwb2ludCBjYW4gc3RhcnQgYSBuZXcgTGlzdCBJdGVtXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIGVuZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSgvXlxcdCsvLCAodCkgPT4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICBpbmRlbnQgPSAyO1xuICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUudHJpbUxlZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRlbnQgPSBjYXBbMl0uc2VhcmNoKC9bXiBdLyk7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDsgLy8gVHJlYXQgaW5kZW50ZWQgY29kZSBibG9ja3MgKD4gNCBzcGFjZXMpIGFzIGhhdmluZyBvbmx5IDEgaW5kZW50XG4gICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxhbmtMaW5lID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFsaW5lICYmIC9eICokLy50ZXN0KG5leHRMaW5lKSkgeyAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKG5leHRMaW5lLmxlbmd0aCArIDEpO1xuICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZW5kRWFybHkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgY29uc3QgZmVuY2VzQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86XFxgXFxgXFxgfH5+filgKTtcbiAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZm9sbG93aW5nIGxpbmVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBMaXN0IEl0ZW1cbiAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICByYXdMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgIG5leHRMaW5lID0gcmF3TGluZTtcblxuICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL14gezEsNH0oPz0oIHs0fSkqW14gXSkvZywgJyAgJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgaWYgKGJsYW5rTGluZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcGFyYWdyYXBoIGNvbnRpbnVhdGlvbiB1bmxlc3MgbGFzdCBsaW5lIHdhcyBhIGRpZmZlcmVudCBibG9jayBsZXZlbCBlbGVtZW50XG4gICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJsYW5rTGluZSAmJiAhbmV4dExpbmUudHJpbSgpKSB7IC8vIENoZWNrIGlmIGN1cnJlbnQgbGluZSBpcyBibGFua1xuICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYXcgKz0gcmF3TGluZSArICdcXG4nO1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXdMaW5lLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgbGluZSA9IG5leHRMaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9cXG4gKlxcbiAqJC8udGVzdChyYXcpKSB7XG4gICAgICAgICAgICBlbmRzV2l0aEJsYW5rTGluZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgaXNjaGVja2VkID0gaXN0YXNrWzBdICE9PSAnWyBdICc7XG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBpdGVtQ29udGVudHMucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICByYXcsXG4gICAgICAgICAgdGFzazogISFpc3Rhc2ssXG4gICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICB0ZXh0OiBpdGVtQ29udGVudHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgY29uc3VtZSBuZXdsaW5lcyBhdCBlbmQgb2YgZmluYWwgaXRlbS4gQWx0ZXJuYXRpdmVseSwgbWFrZSBpdGVtUmVnZXggKnN0YXJ0KiB3aXRoIGFueSBuZXdsaW5lcyB0byBzaW1wbGlmeS9zcGVlZCB1cCBlbmRzV2l0aEJsYW5rTGluZSBsb2dpY1xuICAgICAgbGlzdC5pdGVtc1tsaXN0Lml0ZW1zLmxlbmd0aCAtIDFdLnJhdyA9IHJhdy50cmltUmlnaHQoKTtcbiAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS50ZXh0ID0gaXRlbUNvbnRlbnRzLnRyaW1SaWdodCgpO1xuICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltUmlnaHQoKTtcblxuICAgICAgY29uc3QgbCA9IGxpc3QuaXRlbXMubGVuZ3RoO1xuXG4gICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG5cbiAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgbGlzdCBzaG91bGQgYmUgbG9vc2VcbiAgICAgICAgICBjb25zdCBzcGFjZXJzID0gbGlzdC5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUxpbmVCcmVha3MgPSBzcGFjZXJzLmxlbmd0aCA+IDAgJiYgc3BhY2Vycy5zb21lKHQgPT4gL1xcbi4qXFxuLy50ZXN0KHQucmF3KSk7XG5cbiAgICAgICAgICBsaXN0Lmxvb3NlID0gaGFzTXVsdGlwbGVMaW5lQnJlYWtzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBhbGwgaXRlbXMgdG8gbG9vc2UgaWYgbGlzdCBpcyBsb29zZVxuICAgICAgaWYgKGxpc3QubG9vc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIGh0bWwoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICB0b2tlbi50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgIHRva2VuLnRleHQgPSB0ZXh0O1xuICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmxleGVyLmlubGluZSh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gIH1cblxuICBkZWYoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGNvbnN0IGhyZWYgPSBjYXBbMl0gPyBjYXBbMl0ucmVwbGFjZSgvXjwoLiopPiQvLCAnJDEnKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6ICcnO1xuICAgICAgY29uc3QgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGNhcFszXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICB0YWcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBocmVmLFxuICAgICAgICB0aXRsZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0YWJsZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IHNwbGl0Q2VsbHMoY2FwWzFdKS5tYXAoYyA9PiB7IHJldHVybiB7IHRleHQ6IGMgfTsgfSksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgcm93czogY2FwWzNdICYmIGNhcFszXS50cmltKCkgPyBjYXBbM10ucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW11cbiAgICAgIH07XG5cbiAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0ucmF3ID0gY2FwWzBdO1xuXG4gICAgICAgIGxldCBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgIGxldCBpLCBqLCBrLCByb3c7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbCA9IGl0ZW0ucm93cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpdGVtLnJvd3NbaV0gPSBzcGxpdENlbGxzKGl0ZW0ucm93c1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoYyA9PiB7IHJldHVybiB7IHRleHQ6IGMgfTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXJzZSBjaGlsZCB0b2tlbnMgaW5zaWRlIGhlYWRlcnMgYW5kIGNlbGxzXG5cbiAgICAgICAgLy8gaGVhZGVyIGNoaWxkIHRva2Vuc1xuICAgICAgICBsID0gaXRlbS5oZWFkZXIubGVuZ3RoO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgaXRlbS5oZWFkZXJbal0udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUoaXRlbS5oZWFkZXJbal0udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjZWxsIGNoaWxkIHRva2Vuc1xuICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICAgIHJvdyA9IGl0ZW0ucm93c1tqXTtcbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICByb3dba10udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUocm93W2tdLnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxoZWFkaW5nKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcGFyYWdyYXBoKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICA6IGNhcFsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0ZXh0KHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZXNjYXBlKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVzY2FwZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBlc2NhcGUoY2FwWzFdKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0YWcoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePFxcLyhwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3RleHQnXG4gICAgICAgICAgOiAnaHRtbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBpbkxpbms6IHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rLFxuICAgICAgICBpblJhd0Jsb2NrOiB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2ssXG4gICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gKHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgICA6IGVzY2FwZShjYXBbMF0pKVxuICAgICAgICAgIDogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGxpbmsoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubGluay5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICBpZiAoISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5kaW5nIGFuZ2xlIGJyYWNrZXQgY2Fubm90IGJlIGVzY2FwZWRcbiAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICBpZiAoKHRyaW1tZWRVcmwubGVuZ3RoIC0gcnRyaW1TbGFzaC5sZW5ndGgpICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgIGNvbnN0IGxhc3RQYXJlbkluZGV4ID0gZmluZENsb3NpbmdCcmFja2V0KGNhcFsyXSwgJygpJyk7XG4gICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBjYXBbMF0uaW5kZXhPZignIScpID09PSAwID8gNSA6IDQ7XG4gICAgICAgICAgY29uc3QgbGlua0xlbiA9IHN0YXJ0ICsgY2FwWzFdLmxlbmd0aCArIGxhc3RQYXJlbkluZGV4O1xuICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgIGNhcFswXSA9IGNhcFswXS5zdWJzdHJpbmcoMCwgbGlua0xlbikudHJpbSgpO1xuICAgICAgICAgIGNhcFszXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaHJlZiA9IGNhcFsyXTtcbiAgICAgIGxldCB0aXRsZSA9ICcnO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICBjb25zdCBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgfVxuXG4gICAgICBocmVmID0gaHJlZi50cmltKCk7XG4gICAgICBpZiAoL148Ly50ZXN0KGhyZWYpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiB0aXRsZVxuICAgICAgfSwgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICB9XG4gIH1cblxuICByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICBsZXQgY2FwO1xuICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgbGV0IGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgfVxuICB9XG5cbiAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgIC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuICAgIGlmIChtYXRjaFszXSAmJiBwcmV2Q2hhci5tYXRjaCgvW1xccHtMfVxccHtOfV0vdSkpIHJldHVybjtcblxuICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG5cbiAgICBpZiAoIW5leHRDaGFyIHx8IChuZXh0Q2hhciAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgIGNvbnN0IGxMZW5ndGggPSBtYXRjaFswXS5sZW5ndGggLSAxO1xuICAgICAgbGV0IHJEZWxpbSwgckxlbmd0aCwgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsIG1pZERlbGltVG90YWwgPSAwO1xuXG4gICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kO1xuICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG5cbiAgICAgICAgaWYgKCFyRGVsaW0pIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG5cbiAgICAgICAgckxlbmd0aCA9IHJEZWxpbS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcblxuICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcblxuICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuXG4gICAgICAgIGNvbnN0IHJhdyA9IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyAobWF0Y2hbMF0ubGVuZ3RoIC0gckRlbGltLmxlbmd0aCkgKyByTGVuZ3RoKTtcblxuICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDIsIC0yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICByYXcsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29kZXNwYW4oc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHRleHQgPSBlc2NhcGUodGV4dCwgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBicihzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZGVsKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RlbCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnMoY2FwWzJdKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhdXRvbGluayhzcmMsIG1hbmdsZSkge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzFdKSA6IGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgdGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB1cmwoc3JjLCBtYW5nbGUpIHtcbiAgICBsZXQgY2FwO1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgIGxldCBwcmV2Q2FwWmVybztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pWzBdO1xuICAgICAgICB9IHdoaWxlIChwcmV2Q2FwWmVybyAhPT0gY2FwWzBdKTtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICBpZiAoY2FwWzFdID09PSAnd3d3LicpIHtcbiAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgY2FwWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBjYXBbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRva2VuczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaW5saW5lVGV4dChzcmMsIHNtYXJ0eXBhbnRzKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQ7XG4gICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAodGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IGVzY2FwZShjYXBbMF0pKSA6IGNhcFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICBmZW5jZXM6IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS8sXG4gIGhyOiAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICBsaXN0OiAvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLyxcbiAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuICopPyhbXjxcXHNdW15cXHNdKnw8Lio/PikoPzooPzogKyg/OlxcbiAqKT98ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcFRlc3QsXG4gIGxoZWFkaW5nOiAvXigoPzoufFxcbig/IVxcbikpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHx0YWJsZXwgK1xcbilbXlxcbl0rKSopLyxcbiAgdGV4dDogL15bXlxcbl0rL1xufTtcblxuYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS87XG5ibG9jay5kZWYgPSBlZGl0KGJsb2NrLmRlZilcbiAgLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKVxuICAucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5ibG9jay5saXN0SXRlbVN0YXJ0ID0gZWRpdCgvXiggKikoYnVsbCkgKi8pXG4gIC5yZXBsYWNlKCdidWxsJywgYmxvY2suYnVsbGV0KVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2subGlzdCA9IGVkaXQoYmxvY2subGlzdClcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbidcbiAgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJ1xuICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nXG4gICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInXG4gICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKVxuICAucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KVxuICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZylcbiAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pXG4gIC5nZXRSZWdleCgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gIC5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJylcbiAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gIC5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IGVkaXQoYmxvY2suYmxvY2txdW90ZSlcbiAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaClcbiAgLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5ub3JtYWwgPSB7IC4uLmJsb2NrIH07XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSB7XG4gIC4uLmJsb2NrLm5vcm1hbCxcbiAgdGFibGU6ICdeICooW15cXFxcbiBdLipcXFxcfC4qKVxcXFxuJyAvLyBIZWFkZXJcbiAgICArICcgezAsM30oPzpcXFxcfCAqKT8oOj8tKzo/ICooPzpcXFxcfCAqOj8tKzo/ICopKikoPzpcXFxcfCAqKT8nIC8vIEFsaWduXG4gICAgKyAnKD86XFxcXG4oKD86KD8hICpcXFxcbnxocnxoZWFkaW5nfGJsb2NrcXVvdGV8Y29kZXxmZW5jZXN8bGlzdHxodG1sKS4qKD86XFxcXG58JCkpKilcXFxcbip8JCknIC8vIENlbGxzXG59O1xuXG5ibG9jay5nZm0udGFibGUgPSBlZGl0KGJsb2NrLmdmbS50YWJsZSlcbiAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJylcbiAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gIC5yZXBsYWNlKCd0YWJsZScsIGJsb2NrLmdmbS50YWJsZSkgLy8gaW50ZXJydXB0IHBhcmFncmFwaHMgd2l0aCB0YWJsZVxuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gKi9cblxuYmxvY2sucGVkYW50aWMgPSB7XG4gIC4uLmJsb2NrLm5vcm1hbCxcbiAgaHRtbDogZWRpdChcbiAgICAnXiAqKD86Y29tbWVudCAqKD86XFxcXG58XFxcXHMqJCknXG4gICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudClcbiAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICArICdhfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3ViJ1xuICAgICAgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknXG4gICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgIC5nZXRSZWdleCgpLFxuICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgZmVuY2VzOiBub29wVGVzdCwgLy8gZmVuY2VzIG5vdCBzdXBwb3J0ZWRcbiAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiBlZGl0KGJsb2NrLm5vcm1hbC5fcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgIC5yZXBsYWNlKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCd8ZmVuY2VzJywgJycpXG4gICAgLnJlcGxhY2UoJ3xsaXN0JywgJycpXG4gICAgLnJlcGxhY2UoJ3xodG1sJywgJycpXG4gICAgLmdldFJlZ2V4KClcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvLFxuICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgdXJsOiBub29wVGVzdCxcbiAgdGFnOiAnXmNvbW1lbnQnXG4gICAgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsIC8vIENEQVRBIHNlY3Rpb25cbiAgbGluazogL14hP1xcWyhsYWJlbClcXF1cXChcXHMqKGhyZWYpKD86XFxzKyh0aXRsZSkpP1xccypcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyhyZWYpXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKHJlZilcXF0oPzpcXFtcXF0pPy8sXG4gIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gIGVtU3Ryb25nOiB7XG4gICAgbERlbGltOiAvXig/OlxcKisoPzooW3B1bmN0X10pfFteXFxzKl0pKXxeXysoPzooW3B1bmN0Kl0pfChbXlxcc19dKSkvLFxuICAgIC8vICAgICAgICAoMSkgYW5kICgyKSBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlci4gKDMpIGFuZCAoNCkgY2FuIG9ubHkgYmUgTGVmdC4gICg1KSBhbmQgKDYpIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodC5cbiAgICAvLyAgICAgICAgICAoKSBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSBDb25zdW1lIHRvIGRlbGltICAgICAoMSkgIyoqKiAgICAgICAgICAgICAgICAoMikgYSoqKiMsIGEqKiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICgzKSAjKioqYSwgKioqYSAgICAgICAgICAgICAgICAgKDQpICoqKiMgICAgICAgICAgICAgICg1KSAjKioqIyAgICAgICAgICAgICAgICAgKDYpIGEqKiphXG4gICAgckRlbGltQXN0OiAvXig/OlteXypcXFxcXXxcXFxcLikqP1xcX1xcXyg/OlteXypcXFxcXXxcXFxcLikqP1xcKig/OlteXypcXFxcXXxcXFxcLikqPyg/PVxcX1xcXyl8KD86W14qXFxcXF18XFxcXC4pKyg/PVteKl0pfFtwdW5jdF9dKFxcKispKD89W1xcc118JCl8KD86W15wdW5jdCpfXFxzXFxcXF18XFxcXC4pKFxcKispKD89W3B1bmN0X1xcc118JCl8W3B1bmN0X1xcc10oXFwqKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXCorKSg/PVtwdW5jdF9dKXxbcHVuY3RfXShcXCorKSg/PVtwdW5jdF9dKXwoPzpbXnB1bmN0Kl9cXHNcXFxcXXxcXFxcLikoXFwqKykoPz1bXnB1bmN0Kl9cXHNdKS8sXG4gICAgckRlbGltVW5kOiAvXig/OlteXypcXFxcXXxcXFxcLikqP1xcKlxcKig/OlteXypcXFxcXXxcXFxcLikqP1xcXyg/OlteXypcXFxcXXxcXFxcLikqPyg/PVxcKlxcKil8KD86W15fXFxcXF18XFxcXC4pKyg/PVteX10pfFtwdW5jdCpdKFxcXyspKD89W1xcc118JCl8KD86W15wdW5jdCpfXFxzXFxcXF18XFxcXC4pKFxcXyspKD89W3B1bmN0Klxcc118JCl8W3B1bmN0Klxcc10oXFxfKykoPz1bXnB1bmN0Kl9cXHNdKXxbXFxzXShcXF8rKSg/PVtwdW5jdCpdKXxbcHVuY3QqXShcXF8rKSg/PVtwdW5jdCpdKS8gLy8gXi0gTm90IGFsbG93ZWQgZm9yIF9cbiAgfSxcbiAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgYnI6IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wVGVzdCxcbiAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgcHVuY3R1YXRpb246IC9eKFtcXHNwdW5jdHVhdGlvbl0pL1xufTtcblxuLy8gbGlzdCBvZiBwdW5jdHVhdGlvbiBtYXJrcyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuLy8gd2l0aG91dCAqIGFuZCBfIHRvIGhhbmRsZSB0aGUgZGlmZmVyZW50IGVtcGhhc2lzIG1hcmtlcnMgKiBhbmQgX1xuaW5saW5lLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG5pbmxpbmUucHVuY3R1YXRpb24gPSBlZGl0KGlubGluZS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcblxuLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cbmlubGluZS5ibG9ja1NraXAgPSAvXFxbW15cXF1dKj9cXF1cXChbXlxcKV0qP1xcKXxgW15gXSo/YHw8W14+XSo/Pi9nO1xuLy8gbG9va2JlaGluZCBpcyBub3QgYXZhaWxhYmxlIG9uIFNhZmFyaSBhcyBvZiB2ZXJzaW9uIDE2XG4vLyBpbmxpbmUuZXNjYXBlZEVtU3QgPSAvKD88PSg/Ol58W15cXFxcKSg/OlxcXFxbXl0pKilcXFxcWypfXS9nO1xuaW5saW5lLmVzY2FwZWRFbVN0ID0gLyg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkqXFxcXFsqX10vZztcblxuaW5saW5lLl9jb21tZW50ID0gZWRpdChibG9jay5fY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG5cbmlubGluZS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZS5lbVN0cm9uZy5sRGVsaW0pXG4gIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCA9IGVkaXQoaW5saW5lLmVtU3Ryb25nLnJEZWxpbUFzdCwgJ2cnKVxuICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQsICdnJylcbiAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2VzY2FwZXMgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvZztcblxuaW5saW5lLl9zY2hlbWUgPSAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS87XG5pbmxpbmUuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG5pbmxpbmUuYXV0b2xpbmsgPSBlZGl0KGlubGluZS5hdXRvbGluaylcbiAgLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKVxuICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuX2VtYWlsKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLl9hdHRyaWJ1dGUgPSAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy87XG5cbmlubGluZS50YWcgPSBlZGl0KGlubGluZS50YWcpXG4gIC5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lLl9jb21tZW50KVxuICAucmVwbGFjZSgnYXR0cmlidXRlJywgaW5saW5lLl9hdHRyaWJ1dGUpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUuX2xhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbmlubGluZS5faHJlZiA9IC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteXFxzXFx4MDAtXFx4MWZdKi87XG5pbmxpbmUuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG5cbmlubGluZS5saW5rID0gZWRpdChpbmxpbmUubGluaylcbiAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gIC5yZXBsYWNlKCd0aXRsZScsIGlubGluZS5fdGl0bGUpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUucmVmbGluayA9IGVkaXQoaW5saW5lLnJlZmxpbmspXG4gIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gIC5nZXRSZWdleCgpO1xuXG5pbmxpbmUubm9saW5rID0gZWRpdChpbmxpbmUubm9saW5rKVxuICAucmVwbGFjZSgncmVmJywgYmxvY2suX2xhYmVsKVxuICAuZ2V0UmVnZXgoKTtcblxuaW5saW5lLnJlZmxpbmtTZWFyY2ggPSBlZGl0KGlubGluZS5yZWZsaW5rU2VhcmNoLCAnZycpXG4gIC5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lLnJlZmxpbmspXG4gIC5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUubm9saW5rKVxuICAuZ2V0UmVnZXgoKTtcblxuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUubm9ybWFsID0geyAuLi5pbmxpbmUgfTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IHtcbiAgLi4uaW5saW5lLm5vcm1hbCxcbiAgc3Ryb25nOiB7XG4gICAgc3RhcnQ6IC9eX198XFwqXFwqLyxcbiAgICBtaWRkbGU6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICBlbmRVbmQ6IC9fXyg/IV8pL2dcbiAgfSxcbiAgZW06IHtcbiAgICBzdGFydDogL15ffFxcKi8sXG4gICAgbWlkZGxlOiAvXigpXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKil8Xl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pLyxcbiAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgZW5kVW5kOiAvXyg/IV8pL2dcbiAgfSxcbiAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgIC5nZXRSZWdleCgpLFxuICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbClcbiAgICAuZ2V0UmVnZXgoKVxufTtcblxuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuZ2ZtID0ge1xuICAuLi5pbmxpbmUubm9ybWFsLFxuICBlc2NhcGU6IGVkaXQoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypfJ1wifigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypfJ1wifildKyg/ISQpKSsvLFxuICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn07XG5cbmlubGluZS5nZm0udXJsID0gZWRpdChpbmxpbmUuZ2ZtLnVybCwgJ2knKVxuICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuZ2ZtLl9leHRlbmRlZF9lbWFpbClcbiAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IHtcbiAgLi4uaW5saW5lLmdmbSxcbiAgYnI6IGVkaXQoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICB0ZXh0OiBlZGl0KGlubGluZS5nZm0udGV4dClcbiAgICAucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJylcbiAgICAucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKVxuICAgIC5nZXRSZWdleCgpXG59O1xuXG4vKipcbiAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKi9cbmZ1bmN0aW9uIHNtYXJ0eXBhbnRzKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAvLyBlbi1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTMnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn1cblxuLyoqXG4gKiBtYW5nbGUgZW1haWwgYWRkcmVzc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICovXG5mdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICBsZXQgb3V0ID0gJycsXG4gICAgaSxcbiAgICBjaDtcblxuICBjb25zdCBsID0gdGV4dC5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHM7XG4gICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcigpO1xuICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMudG9rZW5pemVyLmxleGVyID0gdGhpcztcbiAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGluTGluazogZmFsc2UsXG4gICAgICBpblJhd0Jsb2NrOiBmYWxzZSxcbiAgICAgIHRvcDogdHJ1ZVxuICAgIH07XG5cbiAgICBjb25zdCBydWxlcyA9IHtcbiAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICBpbmxpbmU6IGlubGluZS5ub3JtYWxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5wZWRhbnRpYztcbiAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5wZWRhbnRpYztcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2suZ2ZtO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lLmJyZWFrcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5nZm07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlIFJ1bGVzXG4gICAqL1xuICBzdGF0aWMgZ2V0IHJ1bGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9jayxcbiAgICAgIGlubGluZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIExleCBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHJvY2Vzc2luZ1xuICAgKi9cbiAgbGV4KHNyYykge1xuICAgIHNyYyA9IHNyY1xuICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpO1xuXG4gICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zKTtcblxuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChuZXh0ID0gdGhpcy5pbmxpbmVRdWV1ZS5zaGlmdCgpKSB7XG4gICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXhpbmdcbiAgICovXG4gIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFx0L2csICcgICAgJykucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiggKikoXFx0KykvZ20sIChfLCBsZWFkaW5nLCB0YWJzKSA9PiB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nICsgJyAgICAnLnJlcGVhdCh0YWJzLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZDtcblxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9jay5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXdsaW5lXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGlmICh0b2tlbi5yYXcubGVuZ3RoID09PSAxICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAvLyBzbyBtb3ZlIGl0IHRoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IHVuZWNlc3NhcnkgcGFyYWdyYXBoIHRhZ3NcbiAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvZGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGZlbmNlc1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaGVhZGluZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGhyXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBsaXN0XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaHRtbFxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZlxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10pIHtcbiAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGxoZWFkaW5nXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saGVhZGluZyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgY3V0U3JjID0gc3JjO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKGZ1bmN0aW9uKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHsgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IChjdXRTcmMubGVuZ3RoICE9PSBzcmMubGVuZ3RoKTtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRleHRcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgaW5saW5lKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICB0aGlzLmlubGluZVF1ZXVlLnB1c2goeyBzcmMsIHRva2VucyB9KTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIExleGluZy9Db21waWxpbmdcbiAgICovXG4gIGlubGluZVRva2VucyhzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgbGV0IHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcblxuICAgIC8vIFN0cmluZyB3aXRoIGxpbmtzIG1hc2tlZCB0byBhdm9pZCBpbnRlcmZlcmVuY2Ugd2l0aCBlbSBhbmQgc3Ryb25nXG4gICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IGtlZXBQcmV2Q2hhciwgcHJldkNoYXI7XG5cbiAgICAvLyBNYXNrIG91dCByZWZsaW5rc1xuICAgIGlmICh0aGlzLnRva2Vucy5saW5rcykge1xuICAgICAgY29uc3QgbGlua3MgPSBPYmplY3Qua2V5cyh0aGlzLnRva2Vucy5saW5rcyk7XG4gICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgcmVwZWF0U3RyaW5nKCdhJywgbWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2gubGFzdEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG4gICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgcmVwZWF0U3RyaW5nKCdhJywgbWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgIH1cblxuICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgZW0gJiBzdHJvbmcgZGVsaW1pdGVyc1xuICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuZXNjYXBlZEVtU3QuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSAyKSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0Lmxhc3RJbmRleCk7XG4gICAgICB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuZXNjYXBlZEVtU3QubGFzdEluZGV4LS07XG4gICAgfVxuXG4gICAgd2hpbGUgKHNyYykge1xuICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgIH1cbiAgICAgIGtlZXBQcmV2Q2hhciA9IGZhbHNlO1xuXG4gICAgICAvLyBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuaW5saW5lXG4gICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBlc2NhcGVcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRhZ1xuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFnKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBsaW5rXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5yZWZsaW5rKHNyYywgdGhpcy50b2tlbnMubGlua3MpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZW0gJiBzdHJvbmdcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVtU3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29kZVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBiclxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWwgKGdmbSlcbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlbChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGF1dG9saW5rXG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMsIG1hbmdsZSkpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXJsIChnZm0pXG4gICAgICBpZiAoIXRoaXMuc3RhdGUuaW5MaW5rICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnVybChzcmMsIG1hbmdsZSkpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRleHRcbiAgICAgIC8vIHByZXZlbnQgaW5saW5lVGV4dCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKGZ1bmN0aW9uKGdldFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHsgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoY3V0U3JjLCBzbWFydHlwYW50cykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRva2VuLnJhdy5zbGljZSgtMSkgIT09ICdfJykgeyAvLyBUcmFjayBwcmV2Q2hhciBiZWZvcmUgc3RyaW5nIG9mIF9fX18gc3RhcnRlZFxuICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cbmNsYXNzIFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHM7XG4gIH1cblxuICBjb2RlKGNvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICBjb25zdCBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgIGNvbnN0IG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICBjb2RlID0gb3V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcblxuICAgIGlmICghbGFuZykge1xuICAgICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cblxuICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIidcbiAgICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICAgICsgZXNjYXBlKGxhbmcpXG4gICAgICArICdcIj4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdW90ZVxuICAgKi9cbiAgYmxvY2txdW90ZShxdW90ZSkge1xuICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtxdW90ZX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgfVxuXG4gIGh0bWwoaHRtbCkge1xuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3XG4gICAqIEBwYXJhbSB7YW55fSBzbHVnZ2VyXG4gICAqL1xuICBoZWFkaW5nKHRleHQsIGxldmVsLCByYXcsIHNsdWdnZXIpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4ICsgc2x1Z2dlci5zbHVnKHJhdyk7XG4gICAgICByZXR1cm4gYDxoJHtsZXZlbH0gaWQ9XCIke2lkfVwiPiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBJRHNcbiAgICByZXR1cm4gYDxoJHtsZXZlbH0+JHt0ZXh0fTwvaCR7bGV2ZWx9PlxcbmA7XG4gIH1cblxuICBocigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgfVxuXG4gIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgc3RhcnRhdHQgPSAob3JkZXJlZCAmJiBzdGFydCAhPT0gMSkgPyAoJyBzdGFydD1cIicgKyBzdGFydCArICdcIicpIDogJyc7XG4gICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgbGlzdGl0ZW0odGV4dCkge1xuICAgIHJldHVybiBgPGxpPiR7dGV4dH08L2xpPlxcbmA7XG4gIH1cblxuICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgcmV0dXJuICc8aW5wdXQgJ1xuICAgICAgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKVxuICAgICAgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIidcbiAgICAgICsgKHRoaXMub3B0aW9ucy54aHRtbCA/ICcgLycgOiAnJylcbiAgICAgICsgJz4gJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICByZXR1cm4gYDxwPiR7dGV4dH08L3A+XFxuYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG4gICAqL1xuICB0YWJsZShoZWFkZXIsIGJvZHkpIHtcbiAgICBpZiAoYm9keSkgYm9keSA9IGA8dGJvZHk+JHtib2R5fTwvdGJvZHk+YDtcblxuICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICArIGhlYWRlclxuICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICArIGJvZHlcbiAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgdGFibGVyb3coY29udGVudCkge1xuICAgIHJldHVybiBgPHRyPlxcbiR7Y29udGVudH08L3RyPlxcbmA7XG4gIH1cblxuICB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICBjb25zdCB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgY29uc3QgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICAgID8gYDwke3R5cGV9IGFsaWduPVwiJHtmbGFncy5hbGlnbn1cIj5gXG4gICAgICA6IGA8JHt0eXBlfT5gO1xuICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICB9XG5cbiAgLyoqXG4gICAqIHNwYW4gbGV2ZWwgcmVuZGVyZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIHN0cm9uZyh0ZXh0KSB7XG4gICAgcmV0dXJuIGA8c3Ryb25nPiR7dGV4dH08L3N0cm9uZz5gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqL1xuICBlbSh0ZXh0KSB7XG4gICAgcmV0dXJuIGA8ZW0+JHt0ZXh0fTwvZW0+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgY29kZXNwYW4odGV4dCkge1xuICAgIHJldHVybiBgPGNvZGU+JHt0ZXh0fTwvY29kZT5gO1xuICB9XG5cbiAgYnIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGRlbCh0ZXh0KSB7XG4gICAgcmV0dXJuIGA8ZGVsPiR7dGV4dH08L2RlbD5gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICB9XG4gICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgaHJlZiA9IGNsZWFuVXJsKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuICAgIGlmIChocmVmID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gYCB0aXRsZT1cIiR7dGl0bGV9XCJgO1xuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXh0UmVuZGVyZXJcbiAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICovXG5jbGFzcyBUZXh0UmVuZGVyZXIge1xuICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgc3Ryb25nKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGVtKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGNvZGVzcGFuKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGRlbCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBodG1sKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHRleHQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICBicigpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAqL1xuY2xhc3MgU2x1Z2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VlbiA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgLnRyaW0oKVxuICAgICAgLy8gcmVtb3ZlIGh0bWwgdGFnc1xuICAgICAgLnJlcGxhY2UoLzxbIVxcL2Etel0uKj8+L2lnLCAnJylcbiAgICAgIC8vIHJlbW92ZSB1bndhbnRlZCBjaGFyc1xuICAgICAgLnJlcGxhY2UoL1tcXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0ZcXFxcJyFcIiMkJSYoKSorLC4vOjs8PT4/QFtcXF1eYHt8fX5dL2csICcnKVxuICAgICAgLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbmFsU2x1Z1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRHJ5UnVuXG4gICAqL1xuICBnZXROZXh0U2FmZVNsdWcob3JpZ2luYWxTbHVnLCBpc0RyeVJ1bikge1xuICAgIGxldCBzbHVnID0gb3JpZ2luYWxTbHVnO1xuICAgIGxldCBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IDA7XG4gICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcbiAgICAgIGRvIHtcbiAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IrKztcbiAgICAgICAgc2x1ZyA9IG9yaWdpbmFsU2x1ZyArICctJyArIG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgfSB3aGlsZSAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKTtcbiAgICB9XG4gICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgIHRoaXMuc2VlbltzbHVnXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzbHVnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZHJ5cnVuXSBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dFxuICAgKiB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAqL1xuICBzbHVnKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzbHVnID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXIoKTtcbiAgICB0aGlzLnNsdWdnZXIgPSBuZXcgU2x1Z2dlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIExvb3BcbiAgICovXG4gIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgIGxldCBvdXQgPSAnJyxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIGwyLFxuICAgICAgbDMsXG4gICAgICByb3csXG4gICAgICBjZWxsLFxuICAgICAgaGVhZGVyLFxuICAgICAgYm9keSxcbiAgICAgIHRva2VuLFxuICAgICAgb3JkZXJlZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgbG9vc2UsXG4gICAgICBpdGVtQm9keSxcbiAgICAgIGl0ZW0sXG4gICAgICBjaGVja2VkLFxuICAgICAgdGFzayxcbiAgICAgIGNoZWNrYm94LFxuICAgICAgcmV0O1xuXG4gICAgY29uc3QgbCA9IHRva2Vucy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgdG9rZW4pO1xuICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyh0b2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hyJzoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKFxuICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpLFxuICAgICAgICAgICAgdG9rZW4uZGVwdGgsXG4gICAgICAgICAgICB1bmVzY2FwZSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSxcbiAgICAgICAgICAgIHRoaXMuc2x1Z2dlcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsXG4gICAgICAgICAgICB0b2tlbi5sYW5nLFxuICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgaGVhZGVyID0gJyc7XG5cbiAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgICB0aGlzLnBhcnNlSW5saW5lKHRva2VuLmhlYWRlcltqXS50b2tlbnMpLFxuICAgICAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgIGwyID0gdG9rZW4ucm93cy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgIHJvdyA9IHRva2VuLnJvd3Nbal07XG5cbiAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsMzsgaysrKSB7XG4gICAgICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlubGluZShyb3dba10udG9rZW5zKSxcbiAgICAgICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0b2tlbi5hbGlnbltrXSB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgIHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgICAgICBpZiAoaXRlbS50YXNrKSB7XG4gICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcbiAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgY2hlY2tlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBib2R5ID0gdG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dDtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCBsICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgKi9cbiAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgb3V0ID0gJycsXG4gICAgICBpLFxuICAgICAgdG9rZW4sXG4gICAgICByZXQ7XG5cbiAgICBjb25zdCBsID0gdG9rZW5zLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCB0b2tlbik7XG4gICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdlc2NhcGUnOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdsaW5rJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRva2VuLnRleHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VtJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4odG9rZW4udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYnInOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5jbGFzcyBIb29rcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuICB9XG5cbiAgc3RhdGljIHBhc3NUaHJvdWdoSG9va3MgPSBuZXcgU2V0KFtcbiAgICAncHJlcHJvY2VzcycsXG4gICAgJ3Bvc3Rwcm9jZXNzJ1xuICBdKTtcblxuICAvKipcbiAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAqL1xuICBwcmVwcm9jZXNzKG1hcmtkb3duKSB7XG4gICAgcmV0dXJuIG1hcmtkb3duO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICovXG4gIHBvc3Rwcm9jZXNzKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkVycm9yKHNpbGVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAoZSkgPT4ge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcblxuICAgIGlmIChzaWxlbnQpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nXG4gICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICArICc8L3ByZT4nO1xuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH1cblxuICAgIGlmIChhc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hcmtkb3duKGxleGVyLCBwYXJzZXIpIHtcbiAgcmV0dXJuIChzcmMsIG9wdCwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdPcHQgPSB7IC4uLm9wdCB9O1xuICAgIG9wdCA9IHsgLi4ubWFya2VkLmRlZmF1bHRzLCAuLi5vcmlnT3B0IH07XG4gICAgY29uc3QgdGhyb3dFcnJvciA9IG9uRXJyb3Iob3B0LnNpbGVudCwgb3B0LmFzeW5jLCBjYWxsYmFjayk7XG5cbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgICArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJykpO1xuICAgIH1cblxuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpO1xuXG4gICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgbGV0IHRva2VucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgIHNyYyA9IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZG9uZSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICBsZXQgb3V0O1xuXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCA9IHBhcnNlcih0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgIG91dCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcblxuICAgICAgICByZXR1cm4gZXJyXG4gICAgICAgICAgPyB0aHJvd0Vycm9yKGVycilcbiAgICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcblxuICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgICBsZXQgcGVuZGluZyA9IDA7XG4gICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24oZXJyLCBjb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYykgOiBzcmMpXG4gICAgICAgIC50aGVuKHNyYyA9PiBsZXhlcihzcmMsIG9wdCkpXG4gICAgICAgIC50aGVuKHRva2VucyA9PiBvcHQud2Fsa1Rva2VucyA/IFByb21pc2UuYWxsKG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICBodG1sID0gb3B0Lmhvb2tzLnBvc3Rwcm9jZXNzKGh0bWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE1hcmtlZFxuICovXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBwYXJzZU1hcmtkb3duKExleGVyLmxleCwgUGFyc2VyLnBhcnNlKShzcmMsIG9wdCwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtYXJrZWQuZGVmYXVsdHMgPSB7IC4uLm1hcmtlZC5kZWZhdWx0cywgLi4ub3B0IH07XG4gIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcblxubWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5cbi8qKlxuICogVXNlIEV4dGVuc2lvblxuICovXG5cbm1hcmtlZC51c2UgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucyB8fCB7IHJlbmRlcmVyczoge30sIGNoaWxkVG9rZW5zOiB7fSB9O1xuXG4gIGFyZ3MuZm9yRWFjaCgocGFjaykgPT4ge1xuICAgIC8vIGNvcHkgb3B0aW9ucyB0byBuZXcgb2JqZWN0XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4ucGFjayB9O1xuXG4gICAgLy8gc2V0IGFzeW5jIHRvIHRydWUgaWYgaXQgd2FzIHNldCB0byB0cnVlIGJlZm9yZVxuICAgIG9wdHMuYXN5bmMgPSBtYXJrZWQuZGVmYXVsdHMuYXN5bmMgfHwgb3B0cy5hc3luYyB8fCBmYWxzZTtcblxuICAgIC8vID09LS0gUGFyc2UgXCJhZGRvblwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgIHBhY2suZXh0ZW5zaW9ucy5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgaWYgKCFleHQubmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0LnJlbmRlcmVyKSB7IC8vIFJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV07XG4gICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBleHRlbnNpb24gd2l0aCBmdW5jIHRvIHJ1biBuZXcgZXh0ZW5zaW9uIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGV4dC5yZW5kZXJlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dC50b2tlbml6ZXIpIHsgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICBpZiAoIWV4dC5sZXZlbCB8fCAoZXh0LmxldmVsICE9PSAnYmxvY2snICYmIGV4dC5sZXZlbCAhPT0gJ2lubGluZScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnNpb24gbGV2ZWwgbXVzdCBiZSAnYmxvY2snIG9yICdpbmxpbmUnXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1tleHQubGV2ZWxdKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0udW5zaGlmdChleHQudG9rZW5pemVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdID0gW2V4dC50b2tlbml6ZXJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0LnN0YXJ0KSB7IC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciBzdGFydCBvZiB0b2tlblxuICAgICAgICAgICAgaWYgKGV4dC5sZXZlbCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHQubGV2ZWwgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZS5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHQuY2hpbGRUb2tlbnMpIHsgLy8gQ2hpbGQgdG9rZW5zIHRvIGJlIHZpc2l0ZWQgYnkgd2Fsa1Rva2Vuc1xuICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICBjb25zdCByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIoKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgIHJlbmRlcmVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgcmV0ID0gcGFjay5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGlmIChwYWNrLnRva2VuaXplcikge1xuICAgICAgY29uc3QgdG9rZW5pemVyID0gbWFya2VkLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgY29uc3QgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTtcbiAgICAgICAgLy8gUmVwbGFjZSB0b2tlbml6ZXIgd2l0aCBmdW5jIHRvIHJ1biBleHRlbnNpb24sIGJ1dCBmYWxsIGJhY2sgaWYgZmFsc2VcbiAgICAgICAgdG9rZW5pemVyW3Byb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBsZXQgcmV0ID0gcGFjay50b2tlbml6ZXJbcHJvcF0uYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBIb29rcyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICBpZiAocGFjay5ob29rcykge1xuICAgICAgY29uc3QgaG9va3MgPSBtYXJrZWQuZGVmYXVsdHMuaG9va3MgfHwgbmV3IEhvb2tzKCk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5ob29rcykge1xuICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW3Byb3BdO1xuICAgICAgICBpZiAoSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBob29rc1twcm9wXSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrZWQuZGVmYXVsdHMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWNrLmhvb2tzW3Byb3BdLmNhbGwoaG9va3MsIGFyZykpLnRoZW4ocmV0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHBhY2suaG9va3NbcHJvcF0uY2FsbChob29rcywgYXJnKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaG9va3NbcHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgbGV0IHJldCA9IHBhY2suaG9va3NbcHJvcF0uYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgfVxuXG4gICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgIGlmIChwYWNrLndhbGtUb2tlbnMpIHtcbiAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgIG9wdHMud2Fsa1Rva2VucyA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFsdWVzLnB1c2gocGFjay53YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgaWYgKHdhbGtUb2tlbnMpIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIG1hcmtlZC5zZXRPcHRpb25zKG9wdHMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICovXG5cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24odG9rZW5zLCBjYWxsYmFjaykge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChjYWxsYmFjay5jYWxsKG1hcmtlZCwgdG9rZW4pKTtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdG9rZW4uaGVhZGVyKSB7XG4gICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtYXJrZWQud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0b2tlbi5yb3dzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChtYXJrZWQud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zICYmIG1hcmtlZC5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW3Rva2VuLnR5cGVdKSB7IC8vIFdhbGsgYW55IGV4dGVuc2lvbnNcbiAgICAgICAgICBtYXJrZWQuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1t0b2tlbi50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkVG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKHRva2VuW2NoaWxkVG9rZW5zXSwgY2FsbGJhY2spKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50b2tlbnMpIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBQYXJzZSBJbmxpbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqL1xubWFya2VkLnBhcnNlSW5saW5lID0gcGFyc2VNYXJrZG93bihMZXhlci5sZXhJbmxpbmUsIFBhcnNlci5wYXJzZUlubGluZSk7XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyO1xubWFya2VkLkhvb2tzID0gSG9va3M7XG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmNvbnN0IG9wdGlvbnMgPSBtYXJrZWQub3B0aW9ucztcbmNvbnN0IHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbmNvbnN0IHVzZSA9IG1hcmtlZC51c2U7XG5jb25zdCB3YWxrVG9rZW5zID0gbWFya2VkLndhbGtUb2tlbnM7XG5jb25zdCBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbmNvbnN0IHBhcnNlID0gbWFya2VkO1xuY29uc3QgcGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuY29uc3QgbGV4ZXIgPSBMZXhlci5sZXg7XG5cbmV4cG9ydCB7IEhvb2tzLCBMZXhlciwgUGFyc2VyLCBSZW5kZXJlciwgU2x1Z2dlciwgVGV4dFJlbmRlcmVyLCBUb2tlbml6ZXIsIGRlZmF1bHRzLCBnZXREZWZhdWx0cywgbGV4ZXIsIG1hcmtlZCwgb3B0aW9ucywgcGFyc2UsIHBhcnNlSW5saW5lLCBwYXJzZXIsIHNldE9wdGlvbnMsIHVzZSwgd2Fsa1Rva2VucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/marked/lib/marked.esm.js\n"));

/***/ })

}]);